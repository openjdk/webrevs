{"files":[{"patch":"@@ -13,1 +13,1 @@\n-        default: \"Linux additional (hotspot only), Linux x64, Linux x86, Windows x64, macOS x64\"\n+        default: \"Linux additional (hotspot only), Linux x64, Linux x86, Windows aarch64, Windows x64, macOS x64\"\n@@ -25,0 +25,1 @@\n+      platform_windows_aarch64: ${{ steps.check_platforms.outputs.platform_windows_aarch64 }}\n@@ -41,0 +42,1 @@\n+          echo \"::set-output name=platform_windows_aarch64::${{ contains(github.event.inputs.platforms, 'windows aarch64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows aarch64'))) }}\"\n@@ -850,0 +852,88 @@\n+  windows_aarch64_build:\n+    name: Windows aarch64\n+    runs-on: \"windows-2019\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_windows_aarch64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Restore cygwin packages from cache\n+        id: cygwin\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/cygwin\/packages\n+          key: cygwin-packages-${{ runner.os }}-v1\n+\n+      - name: Install cygwin\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+\n+      - name: Checkout the source\n+        uses: actions\/checkout@v2\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+          & curl -L \"$env:BOOT_JDK_URL\" -o \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash = Get-FileHash -Algorithm SHA256 \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash.Hash -eq $env:BOOT_JDK_SHA256\n+          & tar -xf \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\" -C \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\"\n+          Get-ChildItem \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\\*\\*\" | Move-Item -Destination \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Ensure a specific version of MSVC is installed\n+        run: >\n+          Start-Process -FilePath 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vs_installer.exe' -Wait -NoNewWindow -ArgumentList\n+          'modify --installPath \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\" --quiet\n+          --add Microsoft.VisualStudio.Component.VC.14.29.arm64'\n+\n+      - name: Configure\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          $env:BOOT_JDK = cygpath \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\" ;\n+          & bash configure\n+          --with-conf-name=windows-aarch64\n+          --with-msvc-toolset-version=14.29\n+          --openjdk-target=aarch64-unknown-cygwin\n+          ${{ matrix.flags }}\n+          --with-version-opt=\"$env:GITHUB_ACTOR-$env:GITHUB_SHA\"\n+          --with-version-build=0\n+          --with-boot-jdk=\"$env:BOOT_JDK\"\n+          --with-default-make-target=\"hotspot\"\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: |\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          & make CONF_NAME=windows-aarch64\n+        working-directory: jdk\n+\n@@ -1574,0 +1664,1 @@\n+      - windows_aarch64_build\n","filename":".github\/workflows\/submit.yml","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -19,0 +19,2 @@\n+\/.project\/\n+\/.settings\/\n","filename":".gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-      echo \"usage: $0 [-h|--help] [-v|--verbose] [-o|--output <path>] [modules]+\"\n+      echo \"usage: $0 [-h|--help] [-v|--verbose] [-o|--output <path>] [-c|--conf <conf_name>] [modules]+\"\n@@ -40,0 +40,1 @@\n+CONF_ARG=\n@@ -55,0 +56,4 @@\n+    -c | --conf )\n+      CONF_ARG=\"CONF_NAME=$2\"\n+      shift\n+      ;;\n@@ -67,0 +72,3 @@\n+if [ -e $IDEA_OUTPUT ] ; then\n+    rm -r $IDEA_OUTPUT\n+fi\n@@ -94,1 +102,1 @@\n-cd $TOP ; make -f \"$IDEA_MAKE\/idea.gmk\" -I $MAKE_DIR\/.. idea MAKEOVERRIDES= OUT=$IDEA_OUTPUT\/env.cfg MODULES=\"$*\" || exit 1\n+cd $TOP ; make -f \"$IDEA_MAKE\/idea.gmk\" -I $MAKE_DIR\/.. idea MAKEOVERRIDES= OUT=$IDEA_OUTPUT\/env.cfg MODULES=\"$*\" $CONF_ARG || exit 1\n@@ -151,4 +159,4 @@\n-    add_replacement \"###BUILD_DIR###\" \"`cygpath -am $SPEC_DIR`\"\n-    add_replacement \"###IMAGES_DIR###\" \"`cygpath -am $SPEC_DIR`\/images\/jdk\"\n-    add_replacement \"###ROOT_DIR###\" \"`cygpath -am $TOPLEVEL_DIR`\"\n-    add_replacement \"###IDEA_DIR###\" \"`cygpath -am $IDEA_OUTPUT`\"\n+    add_replacement \"###BUILD_DIR###\" \"`$CYGPATH -am $SPEC_DIR`\"\n+    add_replacement \"###IMAGES_DIR###\" \"`$CYGPATH -am $SPEC_DIR`\/images\/jdk\"\n+    add_replacement \"###ROOT_DIR###\" \"`$CYGPATH -am $TOPLEVEL_DIR`\"\n+    add_replacement \"###IDEA_DIR###\" \"`$CYGPATH -am $IDEA_OUTPUT`\"\n@@ -158,1 +166,1 @@\n-      add_replacement \"###JTREG_HOME###\" \"`cygpath -am $JT_HOME`\"\n+      add_replacement \"###JTREG_HOME###\" \"`$CYGPATH -am $JT_HOME`\"\n@@ -183,1 +191,1 @@\n-      root=`cygpath -am $root`\n+      root=`$CYGPATH -am $root`\n@@ -222,5 +230,4 @@\n-if [ \"x$CYGPATH\" != \"x\" ] ; then ## CYGPATH may be set in env.cfg\n-  JAVAC_SOURCE_FILE=`cygpath -am $IDEA_OUTPUT\/src\/idea\/IdeaLoggerWrapper.java`\n-  JAVAC_SOURCE_PATH=`cygpath -am $IDEA_OUTPUT\/src`\n-  JAVAC_CLASSES=`cygpath -am $CLASSES`\n-  JAVAC_CP=`cygpath -am $CP`\n+# If we have a Windows boot JDK, we need a .exe suffix\n+if [ -e \"$BOOT_JDK\/bin\/java.exe\" ] ; then\n+  JAVAC=javac.exe\n+else \n@@ -228,1 +235,6 @@\n-elif [ \"x$WSL_DISTRO_NAME\" != \"x\" ]; then\n+fi\n+\n+# If we are on WSL, the boot JDK might be either Windows or Linux,\n+# and we need to use realpath instead of CYGPATH to make javac work on both.\n+# We need to handle this case first since CYGPATH might be set on WSL.\n+if [ \"x$WSL_DISTRO_NAME\" != \"x\" ]; then\n@@ -235,1 +247,5 @@\n-  JAVAC=javac.exe\n+elif [ \"x$CYGPATH\" != \"x\" ] ; then ## CYGPATH may be set in env.cfg\n+  JAVAC_SOURCE_FILE=`$CYGPATH -am $IDEA_OUTPUT\/src\/idea\/IdeaLoggerWrapper.java`\n+  JAVAC_SOURCE_PATH=`$CYGPATH -am $IDEA_OUTPUT\/src`\n+  JAVAC_CLASSES=`$CYGPATH -am $CLASSES`\n+  JAVAC_CP=`$CYGPATH -am $CP`\n@@ -241,1 +257,0 @@\n-  JAVAC=javac\n","filename":"bin\/idea.sh","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-<p>The <a href=\"https:\/\/wiki.openjdk.java.net\/display\/Adoption\">Adoption Group<\/a> provides recent builds of jtreg <a href=\"https:\/\/ci.adoptopenjdk.net\/view\/Dependencies\/job\/jtreg\/lastSuccessfulBuild\/artifact\">here<\/a>. Download the latest <code>.tar.gz<\/code> file, unpack it, and point <code>--with-jtreg<\/code> to the <code>jtreg<\/code> directory that you just unpacked.<\/p>\n+<p>The <a href=\"https:\/\/wiki.openjdk.java.net\/display\/Adoption\">Adoption Group<\/a> provides recent builds of jtreg <a href=\"https:\/\/ci.adoptopenjdk.net\/view\/Dependencies\/job\/dependency_pipeline\/lastSuccessfulBuild\/artifact\/jtreg\/\">here<\/a>. Download the latest <code>.tar.gz<\/code> file, unpack it, and point <code>--with-jtreg<\/code> to the <code>jtreg<\/code> directory that you just unpacked.<\/p>\n","filename":"doc\/building.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -851,1 +851,1 @@\n-https:\/\/ci.adoptopenjdk.net\/view\/Dependencies\/job\/jtreg\/lastSuccessfulBuild\/artifact).\n+https:\/\/ci.adoptopenjdk.net\/view\/Dependencies\/job\/dependency_pipeline\/lastSuccessfulBuild\/artifact\/jtreg\/).\n","filename":"doc\/building.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,9 @@\n+# Test and fix LoongArch64.\n+if [ \"x$OUT\" = x ]; then\n+  if [ `uname -s` = Linux ]; then\n+    if [ `uname -m` = loongarch64 ]; then\n+      OUT=loongarch64-unknown-linux-gnu\n+    fi\n+  fi\n+fi\n+\n","filename":"make\/autoconf\/build-aux\/config.guess","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -75,0 +75,6 @@\n+    loongarch64)\n+      VAR_CPU=loongarch64\n+      VAR_CPU_ARCH=loongarch\n+      VAR_CPU_BITS=64\n+      VAR_CPU_ENDIAN=little\n+      ;;\n","filename":"make\/autoconf\/platform.m4","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+  # Linux x86_64 needs higher binutils after 8265783\n+  # (this really is a dependency on as version, but we take ld as a check for a general binutils version)\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+    TOOLCHAIN_MINIMUM_LD_VERSION_gcc=\"2.25\"\n+  fi\n+\n@@ -680,0 +686,1 @@\n+    AC_MSG_NOTICE([comparing linker version to minimum version $TOOLCHAIN_MINIMUM_LD_VERSION])\n@@ -682,1 +689,1 @@\n-          AC_MSG_WARN([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n+          AC_MSG_ERROR([You are using a linker older than $TOOLCHAIN_MINIMUM_LD_VERSION. This is not a supported configuration.])\n","filename":"make\/autoconf\/toolchain.m4","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1167,1 +1167,1 @@\n-            revision: \"3.0-7-jdk-asm+1.0\",\n+            revision: \"3.0-9-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=17\n+DEFAULT_VERSION_FEATURE=18\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2021-09-14\n-DEFAULT_VERSION_CLASSFILE_MAJOR=61  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-03-15\n+DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=17\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17 18\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n","filename":"make\/conf\/version-numbers.conf","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/CharArrayReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/Console\n+method name charset descriptor ()Ljava\/nio\/charset\/Charset; flags 1\n+\n+class name java\/io\/FileInputStream\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/InputStreamReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/ObjectInputFilter\n+method name allowFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name rejectFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name merge descriptor (Ljava\/io\/ObjectInputFilter;Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+method name rejectUndecidedClass descriptor (Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+\n+class name java\/io\/ObjectInputFilter$Config\n+method name getSerialFilterFactory descriptor ()Ljava\/util\/function\/BinaryOperator; flags 9 signature ()Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;\n+method name setSerialFilterFactory descriptor (Ljava\/util\/function\/BinaryOperator;)V flags 9 signature (Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;)V\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/WriteAbortedException\n+-field name detail descriptor Ljava\/lang\/Exception;\n+field name detail descriptor Ljava\/lang\/Exception; flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Class\n+-method name isSealed descriptor ()Z\n+-method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class;\n+method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class; flags 1 signature ()[Ljava\/lang\/Class<*>; runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isSealed descriptor ()Z flags 1\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Process\n+method name inputReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name inputReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name outputWriter descriptor ()Ljava\/io\/BufferedWriter; flags 11\n+method name outputWriter descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedWriter; flags 11\n+\n+class name java\/lang\/SecurityManager\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V\n+method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.4\")\n+\n+class name java\/lang\/StrictMath\n+-method name toRadians descriptor (D)D\n+-method name toDegrees descriptor (D)D\n+method name toRadians descriptor (D)D flags 9\n+method name toDegrees descriptor (D)D flags 9\n+\n+class name java\/lang\/SuppressWarnings\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;MODULE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)\n+\n+class name java\/lang\/System\n+-method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V\n+-method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager;\n+method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")@Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name java\/lang\/Thread\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/ThreadGroup\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/DynamicConstantDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/Enum$EnumDesc outerClass java\/lang\/Enum innerClassName EnumDesc flags 19\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandles\n+method name tableSwitch descriptor (Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/invoke\/MethodHandle; flags 89\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/runtime\/SwitchBootstraps\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;)\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name typeSwitch descriptor (Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite; flags 89\n+method name enumSwitch descriptor (Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite; flags 89\n+\n+class name java\/net\/DatagramSocket\n+-method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V\n+method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name joinGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+method name leaveGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/net\/ServerSocket\n+-method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/Socket\n+-method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/URLDecoder\n+-method name <init> descriptor ()V\n+\n+class name java\/net\/URLStreamHandler\n+-method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress;\n+method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress; flags 4\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/MappedByteBuffer\n+method name slice descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name slice descriptor (II)Ljava\/nio\/MappedByteBuffer; flags 401\n+method name duplicate descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/Buffer; flags 1041\n+\n+class name java\/security\/AccessControlContext\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessControlException\n+header extends java\/lang\/SecurityException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessController\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/DomainCombiner\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Policy\n+header extends java\/lang\/Object nestMembers java\/security\/Policy$Parameters flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/Policy$Parameters\n+header extends java\/lang\/Object nestHost java\/security\/Policy flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/PolicySpi\n+header extends java\/lang\/Object flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+-method name toString descriptor ()Ljava\/lang\/String;\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/Clock\n+header extends java\/lang\/Object implements java\/time\/InstantSource flags 421\n+\n+class name java\/time\/InstantSource\n+header extends java\/lang\/Object flags 601\n+method name system descriptor ()Ljava\/time\/InstantSource; flags 9\n+method name tick descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name fixed descriptor (Ljava\/time\/Instant;)Ljava\/time\/InstantSource; flags 9\n+method name offset descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name instant descriptor ()Ljava\/time\/Instant; flags 401\n+method name millis descriptor ()J flags 1\n+method name withZone descriptor (Ljava\/time\/ZoneId;)Ljava\/time\/Clock; flags 1\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/HashSet\n+header extends java\/util\/AbstractSet implements java\/util\/Set,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/Set<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/HexFormat\n+header extends java\/lang\/Object flags 31\n+method name of descriptor ()Ljava\/util\/HexFormat; flags 9\n+method name ofDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 9\n+method name withDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withPrefix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withSuffix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withUpperCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name withLowerCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name delimiter descriptor ()Ljava\/lang\/String; flags 1\n+method name prefix descriptor ()Ljava\/lang\/String; flags 1\n+method name suffix descriptor ()Ljava\/lang\/String; flags 1\n+method name isUpperCase descriptor ()Z flags 1\n+method name formatHex descriptor ([B)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor ([BII)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[B)TA;\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[BII)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[BII)TA;\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;)[B flags 1\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;II)[B flags 1\n+method name parseHex descriptor ([CII)[B flags 1\n+method name toLowHexDigit descriptor (I)C flags 1\n+method name toHighHexDigit descriptor (I)C flags 1\n+method name toHexDigits descriptor (Ljava\/lang\/Appendable;B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;B)TA;\n+method name toHexDigits descriptor (B)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (C)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (S)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (I)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (J)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (JI)Ljava\/lang\/String; flags 1\n+method name isHexDigit descriptor (I)Z flags 9\n+method name fromHexDigit descriptor (I)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;II)I flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;)J flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;II)J flags 9\n+method name equals descriptor (Ljava\/lang\/Object;)Z flags 1\n+method name hashCode descriptor ()I flags 1\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Map$Entry\n+method name copyOf descriptor (Ljava\/util\/Map$Entry;)Ljava\/util\/Map$Entry; flags 9 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>(Ljava\/util\/Map$Entry<+TK;+TV;>;)Ljava\/util\/Map$Entry<TK;TV;>;\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Random\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator,java\/io\/Serializable flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"Random\",i=I48,j=I0,k=I0,equidistribution=I0)\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/util\/SplittableRandom\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator,java\/util\/random\/RandomGenerator$SplittableGenerator flags 31 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SplittableRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+-method name nextInt descriptor (I)I\n+-method name nextInt descriptor (II)I\n+-method name nextLong descriptor (J)J\n+-method name nextLong descriptor (JJ)J\n+-method name nextDouble descriptor ()D\n+-method name nextDouble descriptor (D)D\n+-method name nextDouble descriptor (DD)D\n+-method name nextBoolean descriptor ()Z\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/SplittableRandom; flags 1\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/Timer\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/ref\/Cleaner$Cleanable outerClass java\/lang\/ref\/Cleaner innerClassName Cleanable flags 609\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/Executors\n+-method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory;\n+-method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+-method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/concurrent\/ForkJoinPool\n+header extends java\/util\/concurrent\/AbstractExecutorService nestMembers java\/util\/concurrent\/ForkJoinPool$ManagedBlocker,java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory flags 21\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ForkJoinWorkerThreadFactory flags 609\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name invokeAll descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List; thrownTypes java\/lang\/InterruptedException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List<Ljava\/util\/concurrent\/Future<TT;>;>;\n+method name invokeAny descriptor (Ljava\/util\/Collection;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;)TT;\n+method name invokeAny descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException,java\/util\/concurrent\/TimeoutException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)TT;\n+\n+class name java\/util\/concurrent\/ForkJoinWorkerThread\n+header extends java\/lang\/Thread flags 21\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/util\/concurrent\/LinkedTransferQueue\n+header extends java\/util\/AbstractQueue implements java\/util\/concurrent\/TransferQueue,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractQueue<TE;>;Ljava\/util\/concurrent\/TransferQueue<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ThreadLocalRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"ThreadLocalRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+-method name nextGaussian descriptor ()D\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/random\/RandomGenerator\n+header extends java\/lang\/Object nestMembers java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator,java\/util\/random\/RandomGenerator$LeapableGenerator,java\/util\/random\/RandomGenerator$JumpableGenerator,java\/util\/random\/RandomGenerator$SplittableGenerator,java\/util\/random\/RandomGenerator$StreamableGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator; flags 9\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGenerator; flags 9\n+method name isDeprecated descriptor ()Z flags 1\n+method name doubles descriptor ()Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (DD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (J)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (JDD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name ints descriptor ()Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (II)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (J)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (JII)Ljava\/util\/stream\/IntStream; flags 1\n+method name longs descriptor ()Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (J)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name nextBoolean descriptor ()Z flags 1\n+method name nextBytes descriptor ([B)V flags 1\n+method name nextFloat descriptor ()F flags 1\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+method name nextDouble descriptor ()D flags 1\n+method name nextDouble descriptor (D)D flags 1\n+method name nextDouble descriptor (DD)D flags 1\n+method name nextInt descriptor ()I flags 1\n+method name nextInt descriptor (I)I flags 1\n+method name nextInt descriptor (II)I flags 1\n+method name nextLong descriptor ()J flags 401\n+method name nextLong descriptor (J)J flags 1\n+method name nextLong descriptor (JJ)J flags 1\n+method name nextGaussian descriptor ()D flags 1\n+method name nextGaussian descriptor (DD)D flags 1\n+method name nextExponential descriptor ()D flags 1\n+\n+class name java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$LeapableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 401\n+method name jumpPowerOfTwo descriptor (I)V flags 401\n+method name jump descriptor (D)V flags 401\n+method name jump descriptor ()V flags 1\n+method name jumps descriptor (D)Ljava\/util\/stream\/Stream; flags 1 signature (D)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name jumps descriptor (JD)Ljava\/util\/stream\/Stream; flags 1 signature (JD)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name leap descriptor ()V flags 1\n+method name copyAndJump descriptor (D)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 1041\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$JumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 401\n+method name jump descriptor ()V flags 401\n+method name jumpDistance descriptor ()D flags 401\n+method name jumps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name jumps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name copyAndJump descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1\n+\n+class name java\/util\/random\/RandomGenerator$LeapableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$JumpableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 401\n+method name leap descriptor ()V flags 401\n+method name leapDistance descriptor ()D flags 401\n+method name leaps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name leaps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name copyAndLeap descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$SplittableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 9\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 401 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGenerator$StreamableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$StreamableGenerator; flags 9\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 401 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGeneratorFactory\n+header extends java\/lang\/Object flags 31 signature <T::Ljava\/util\/random\/RandomGenerator;>Ljava\/lang\/Object;\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature <T::Ljava\/util\/random\/RandomGenerator;>(Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory<TT;>;\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature ()Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;\n+method name all descriptor ()Ljava\/util\/stream\/Stream; flags 9 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;>;\n+method name name descriptor ()Ljava\/lang\/String; flags 1\n+method name group descriptor ()Ljava\/lang\/String; flags 1\n+method name stateBits descriptor ()I flags 1\n+method name equidistribution descriptor ()I flags 1\n+method name period descriptor ()Ljava\/math\/BigInteger; flags 1\n+method name isStatistical descriptor ()Z flags 1\n+method name isStochastic descriptor ()Z flags 1\n+method name isHardware descriptor ()Z flags 1\n+method name isArbitrarilyJumpable descriptor ()Z flags 1\n+method name isJumpable descriptor ()Z flags 1\n+method name isLeapable descriptor ()Z flags 1\n+method name isSplittable descriptor ()Z flags 1\n+method name isStreamable descriptor ()Z flags 1\n+method name isDeprecated descriptor ()Z flags 1\n+method name create descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1 signature ()TT;\n+method name create descriptor (J)Ljava\/util\/random\/RandomGenerator; flags 1 signature (J)TT;\n+method name create descriptor ([B)Ljava\/util\/random\/RandomGenerator; flags 1 signature ([B)TT;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/SecretKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec,javax\/crypto\/SecretKey flags 21\n+\n+class name javax\/security\/auth\/Subject\n+-method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; thrownTypes java\/security\/PrivilegedActionException flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name javax\/security\/auth\/SubjectDomainCombiner\n+header extends java\/lang\/Object implements java\/security\/DomainCombiner flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n","filename":"make\/data\/symbols\/java.base-H.sym.txt","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_17 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+-field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+-field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+\n+class name javax\/lang\/model\/element\/TypeElement\n+-method name getPermittedSubclasses descriptor ()Ljava\/util\/List;\n+method name getPermittedSubclasses descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Ljavax\/lang\/model\/type\/TypeMirror;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isAutomaticModule descriptor (Ljavax\/lang\/model\/element\/ModuleElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.compiler-H.sym.txt","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/datatransfer\/Clipboard\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/datatransfer\/DataFlavor\n+header extends java\/lang\/Object implements java\/io\/Externalizable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+\n","filename":"make\/data\/symbols\/java.datatransfer-H.sym.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,902 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/applet\/Applet\n+header extends java\/awt\/Panel nestMembers java\/applet\/Applet$AccessibleApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+innerclass innerClass java\/applet\/Applet$AccessibleApplet outerClass java\/applet\/Applet innerClassName AccessibleApplet flags 4\n+\n+class name java\/applet\/AppletContext\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AppletStub\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AudioClip\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridBagLayoutInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/AppletInitializer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object;\n+method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object; thrownTypes java\/io\/IOException,java\/lang\/ClassNotFoundException flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JApplet\n+header extends java\/applet\/Applet implements javax\/accessibility\/Accessible,javax\/swing\/RootPaneContainer,javax\/swing\/TransferHandler$HasGetTransferHandler nestMembers javax\/swing\/JApplet$AccessibleJApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")@Ljava\/beans\/JavaBean;(defaultProperty=\"JMenuBar\",description=\"Swing's\\u005C;u0020;Applet\\u005C;u0020;subclass.\")@Ljavax\/swing\/SwingContainer;(delegate=\"getContentPane\")\n+innerclass innerClass javax\/swing\/JApplet$AccessibleJApplet outerClass javax\/swing\/JApplet innerClassName AccessibleJApplet flags 4\n+innerclass innerClass javax\/swing\/TransferHandler$HasGetTransferHandler outerClass javax\/swing\/TransferHandler innerClassName HasGetTransferHandler flags 608\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JSlider$AccessibleJSlider\n+header extends javax\/swing\/JComponent$AccessibleJComponent implements javax\/accessibility\/AccessibleValue,javax\/swing\/event\/ChangeListener,javax\/accessibility\/AccessibleAction nestHost javax\/swing\/JSlider flags 21\n+innerclass innerClass javax\/swing\/JSlider$AccessibleJSlider outerClass javax\/swing\/JSlider innerClassName AccessibleJSlider flags 4\n+innerclass innerClass javax\/swing\/JComponent$AccessibleJComponent outerClass javax\/swing\/JComponent innerClassName AccessibleJComponent flags 401\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+method name getAccessibleActionCount descriptor ()I flags 1\n+method name getAccessibleActionDescription descriptor (I)Ljava\/lang\/String; flags 1\n+method name doAccessibleAction descriptor (I)Z flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/RepaintManager\n+-method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V\n+method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileSystemView\n+method name getSystemIcon descriptor (Ljava\/io\/File;II)Ljavax\/swing\/Icon; flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicDirectoryModel\n+-method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z\n+method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/MouseInputListener nestHost javax\/swing\/plaf\/basic\/BasicMenuItemUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler outerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI innerClassName MouseInputHandler flags 4\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName HSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler\n+header extends java\/lang\/Object implements java\/beans\/PropertyChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName PropertyChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName VSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName ViewportChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarUI\n+-method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame;\n+method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame; flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ListView\n+header extends javax\/swing\/text\/html\/BlockView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$ListPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName ListPainter flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/MinimalHTMLWriter\n+header extends javax\/swing\/text\/AbstractWriter flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 9\n+innerclass innerClass javax\/swing\/text\/AbstractDocument$BranchElement outerClass javax\/swing\/text\/AbstractDocument innerClassName BranchElement flags 1\n+innerclass innerClass javax\/swing\/text\/StyleContext$NamedStyle outerClass javax\/swing\/text\/StyleContext innerClassName NamedStyle flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ParagraphView\n+header extends javax\/swing\/text\/ParagraphView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$BoxPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName BoxPainter flags 9\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.desktop-H.sym.txt","additions":902,"deletions":0,"binary":false,"changes":902,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/instrument\/UnmodifiableModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/java.instrument-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/util\/logging\/ErrorManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/LogManager\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V thrownTypes java\/lang\/SecurityException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/logging\/LoggingMXBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/logging\/LoggingPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/MemoryHandler\n+header extends java\/util\/logging\/Handler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SimpleFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SocketHandler\n+header extends java\/util\/logging\/StreamHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/XMLFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.logging-H.sym.txt","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management-H.sym.txt","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/management\/remote\/rmi\/RMIConnectorServer\n+header extends javax\/management\/remote\/JMXConnectorServer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/rmi\/RMIIIOPServerImpl\n+header extends javax\/management\/remote\/rmi\/RMIServerImpl flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name javax\/management\/remote\/rmi\/RMIServerImpl\n+header extends java\/lang\/Object implements java\/io\/Closeable,javax\/management\/remote\/rmi\/RMIServer flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management.rmi-H.sym.txt","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Context\n+-field name APPLET descriptor Ljava\/lang\/String;\n+field name APPLET descriptor Ljava\/lang\/String; constantValue java.naming.applet flags 19 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.naming-H.sym.txt","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.rmi\n+header exports java\/rmi,java\/rmi\/dgc,java\/rmi\/registry,java\/rmi\/server,javax\/rmi\/ssl requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;java.logging\\u0020;flags\\u0020;0 uses java\/rmi\/server\/RMIClassLoaderSpi target linux-amd64 flags 8000\n+\n+class name java\/rmi\/RMISecurityManager\n+header extends java\/lang\/SecurityManager flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.8\")\n+\n+class name java\/rmi\/RemoteException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name java\/rmi\/activation\/Activatable\n+\n+-class name java\/rmi\/activation\/ActivateFailedException\n+\n+-class name java\/rmi\/activation\/ActivationDesc\n+\n+-class name java\/rmi\/activation\/ActivationException\n+\n+-class name java\/rmi\/activation\/ActivationGroup\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc$CommandEnvironment\n+\n+-class name java\/rmi\/activation\/ActivationGroupID\n+\n+-class name java\/rmi\/activation\/ActivationGroup_Stub\n+\n+-class name java\/rmi\/activation\/ActivationID\n+\n+-class name java\/rmi\/activation\/ActivationInstantiator\n+\n+-class name java\/rmi\/activation\/ActivationMonitor\n+\n+-class name java\/rmi\/activation\/ActivationSystem\n+\n+-class name java\/rmi\/activation\/Activator\n+\n+-class name java\/rmi\/activation\/UnknownGroupException\n+\n+-class name java\/rmi\/activation\/UnknownObjectException\n+\n+class name java\/rmi\/dgc\/VMID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ObjID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/RemoteObject\n+header extends java\/lang\/Object implements java\/rmi\/Remote,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ServerCloneException\n+header extends java\/lang\/CloneNotSupportedException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/UID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.rmi-H.sym.txt","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/script\/ScriptException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.scripting-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/auth\/kerberos\/DelegationPermission\n+header extends java\/security\/BasicPermission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/EncryptionKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosCredMessage\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable flags 31\n+innerclass innerClass java\/util\/Base64$Encoder outerClass java\/util\/Base64 innerClassName Encoder flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosTicket\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable,javax\/security\/auth\/Refreshable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KeyTab\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/ServicePermission\n+header extends java\/security\/Permission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/GSSException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/Oid\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.jgss-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/sasl\/SaslException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.sasl-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/smartcardio\/ATR\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/Card\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardChannel\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardException\n+header extends java\/lang\/Exception flags 21\n+\n+class name javax\/smartcardio\/CardNotPresentException\n+header extends javax\/smartcardio\/CardException flags 21\n+\n+class name javax\/smartcardio\/CardPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/CardTerminal\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CommandAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/ResponseAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/TerminalFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/java.smartcardio-H.sym.txt","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/sql\/BatchUpdateException\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/sql\/ConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/JDBCType\n+header extends java\/lang\/Enum implements java\/sql\/SQLType flags 4031 signature Ljava\/lang\/Enum<Ljava\/sql\/JDBCType;>;Ljava\/sql\/SQLType;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/SQLWarning\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/ShardingKey\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/ShardingKeyBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/Statement\n+header extends java\/lang\/Object implements java\/sql\/Wrapper,java\/lang\/AutoCloseable flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/PooledConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/sql\/XAConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/java.sql-H.sym.txt","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.sql.rowset-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/catalog\/Catalog\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/xml\/catalog\/CatalogException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name javax\/xml\/catalog\/CatalogManager\n+header extends java\/lang\/Object flags 31\n+\n+class name javax\/xml\/catalog\/CatalogResolver\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,javax\/xml\/stream\/XMLResolver,javax\/xml\/transform\/URIResolver,org\/w3c\/dom\/ls\/LSResourceResolver flags 601\n+\n+class name javax\/xml\/datatype\/DatatypeFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/datatype\/Duration\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/namespace\/QName\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilder\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilderFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParser\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParserFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/stream\/XMLEventReader\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Ljava\/lang\/Object;>;\n+\n+class name javax\/xml\/stream\/XMLInputFactory\n+-method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory;\n+method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory; thrownTypes javax\/xml\/stream\/FactoryConfigurationError flags 9\n+\n+class name javax\/xml\/stream\/XMLStreamException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/Transformer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/TransformerException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/validation\/SchemaFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPath\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/xml\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPathNodes\n+header extends java\/lang\/Object implements java\/lang\/Iterable flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/Iterable<Lorg\/w3c\/dom\/Node;>;\n+\n+class name org\/w3c\/dom\/ElementTraversal\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/xml\/sax\/AttributeList\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/DocumentHandler\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/HandlerBase\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/DocumentHandler,org\/xml\/sax\/ErrorHandler flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/Parser\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/ext\/Attributes2Impl\n+header extends org\/xml\/sax\/helpers\/AttributesImpl implements org\/xml\/sax\/ext\/Attributes2 flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/AttributeListImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/AttributeList flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/AttributesImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/Attributes flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/ParserFactory\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/XMLFilterImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/XMLFilter,org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/ContentHandler,org\/xml\/sax\/ErrorHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/XMLReaderFactory\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml-H.sym.txt","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/crypto\/NodeSetData\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/Data,java\/lang\/Iterable flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/xml\/crypto\/Data;Ljava\/lang\/Iterable<TT;>;\n+\n+class name javax\/xml\/crypto\/dom\/DOMCryptoContext\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/XMLCryptoContext flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/SignatureMethod\n+field name RSA_PSS descriptor Ljava\/lang\/String; constantValue http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/XMLSignatureFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/dsig\/spec\/SignatureMethodParameterSpec flags 31\n+method name <init> descriptor (Ljava\/security\/spec\/PSSParameterSpec;)V flags 1\n+method name getPSSParameterSpec descriptor ()Ljava\/security\/spec\/PSSParameterSpec; flags 1\n+\n","filename":"make\/data\/symbols\/java.xml.crypto-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/java\/accessibility\/util\/AccessibilityListenerList\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/java\/accessibility\/util\/EventID\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/java\/accessibility\/util\/GUIInitializedListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/TopLevelWindowListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/Translator\n+header extends javax\/accessibility\/AccessibleContext implements javax\/accessibility\/Accessible,javax\/accessibility\/AccessibleComponent flags 21\n+\n","filename":"make\/data\/symbols\/jdk.accessibility-H.sym.txt","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/attach\/AgentInitializationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AgentLoadException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachNotSupportedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachOperationFailedException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachine\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachineDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/spi\/AttachProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.attach-H.sym.txt","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CaseTree\n+method name getLabels descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/CaseLabelTree;>; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+-method name getPermitsClause descriptor ()Ljava\/util\/List;\n+method name getPermitsClause descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/Tree;>;\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+method name getModule descriptor ()Lcom\/sun\/source\/tree\/ModuleTree; flags 1\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DefaultCaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/NoPreview;\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/GuardedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+method name getExpression descriptor ()Lcom\/sun\/source\/tree\/ExpressionTree; flags 401\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Tree$Kind\n+field name GUARDED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name PARENTHESIZED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name DEFAULT_CASE_LABEL descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/TreeScanner\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.compiler-H.sym.txt","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/dynalink\/CallSiteDescriptor\n+header extends jdk\/dynalink\/SecureLookupSupplier flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/DynamicLinker\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/StackWalker$StackFrame outerClass java\/lang\/StackWalker innerClassName StackFrame flags 609\n+innerclass innerClass java\/lang\/StackWalker$Option outerClass java\/lang\/StackWalker innerClassName Option flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NamedOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/Namespace\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/NamespaceOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NoSuchDynamicMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/dynalink\/Operation\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/RelinkableCallSite\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/SecureLookupSupplier\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/StandardNamespace\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Namespace flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardNamespace;>;Ljdk\/dynalink\/Namespace;\n+\n+class name jdk\/dynalink\/StandardOperation\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Operation flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardOperation;>;Ljdk\/dynalink\/Operation;\n+\n+class name jdk\/dynalink\/beans\/MissingMemberHandlerFactory\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocation\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocationTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinker\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinkerExporter\n+header extends java\/lang\/Object implements java\/util\/function\/Supplier flags 421 signature Ljava\/lang\/Object;Ljava\/util\/function\/Supplier<Ljava\/util\/List<Ljdk\/dynalink\/linker\/GuardingDynamicLinker;>;>;\n+\n+class name jdk\/dynalink\/linker\/GuardingTypeConverterFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/LinkRequest\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/LinkerServices\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/dynalink\/linker\/ConversionComparator$Comparison outerClass jdk\/dynalink\/linker\/ConversionComparator innerClassName Comparison flags 4019\n+\n+class name jdk\/dynalink\/linker\/MethodHandleTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/MethodTypeConversionStrategy\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/TypeBasedGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 601\n+\n+class name jdk\/dynalink\/linker\/support\/CompositeGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/DefaultInternalObjectFilter\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/MethodHandleTransformer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Guards\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Lookup\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/SimpleLinkRequest\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/LinkRequest flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/TypeUtilities\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name jdk\/dynalink\/support\/AbstractRelinkableCallSite\n+header extends java\/lang\/invoke\/MutableCallSite implements jdk\/dynalink\/RelinkableCallSite flags 421\n+\n+class name jdk\/dynalink\/support\/ChainedCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/support\/SimpleRelinkableCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+\n","filename":"make\/data\/symbols\/jdk.dynalink-H.sym.txt","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/net\/httpserver\/Filter\n+method name beforeHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+method name afterHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+\n+class name com\/sun\/net\/httpserver\/Headers\n+header extends java\/lang\/Object implements java\/util\/Map flags 21 signature Ljava\/lang\/Object;Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name com\/sun\/net\/httpserver\/HttpContext\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/net\/httpserver\/HttpPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/net\/httpserver\/HttpServer\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsConfigurator\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/net\/httpserver\/HttpsExchange\n+header extends com\/sun\/net\/httpserver\/HttpExchange flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsParameters\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsServer\n+header extends com\/sun\/net\/httpserver\/HttpServer flags 421\n+\n+class name com\/sun\/net\/httpserver\/spi\/HttpServerProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.httpserver-H.sym.txt","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/foreign\/CLinker\n+header extends java\/lang\/Object nestMembers jdk\/incubator\/foreign\/CLinker$TypeKind,jdk\/incubator\/foreign\/CLinker$VaList,jdk\/incubator\/foreign\/CLinker$VaList$Builder sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$TypeKind outerClass jdk\/incubator\/foreign\/CLinker innerClassName TypeKind flags 4019\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String;\n+-method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemorySegment;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String;\n+-method name allocateMemoryRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name freeMemoryRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V\n+method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljdk\/incubator\/foreign\/SegmentAllocator;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name downcallHandle descriptor (Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name allocateMemory descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name freeMemory descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name systemLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name copy descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name ofAddressRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljdk\/incubator\/foreign\/CLinker$VaList$Builder;>;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList$Builder\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+\n+class name jdk\/incubator\/foreign\/GroupLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup$Symbol\n+\n+-class name jdk\/incubator\/foreign\/MappedMemorySegments\n+\n+class name jdk\/incubator\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+-method name asSegmentRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSegmentRestricted descriptor (JLjava\/lang\/Runnable;Ljava\/lang\/Object;)Ljdk\/incubator\/foreign\/MemorySegment;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name asSegment descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name asSegment descriptor (JLjava\/lang\/Runnable;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isNative descriptor ()Z flags 401\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers jdk\/incubator\/foreign\/MemoryLayout$PathElement sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name ofPaddingBits descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name ofValueBits descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+-method name ofSequence descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofSequence descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofStruct descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+-method name ofUnion descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+method name sliceHandle descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/MethodHandle; flags 81\n+method name paddingLayout descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 9\n+method name valueLayout descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 9\n+method name sequenceLayout descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name sequenceLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name structLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+method name unionLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/MemoryLayout sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass java\/nio\/channels\/FileChannel$MapMode outerClass java\/nio\/channels\/FileChannel innerClassName MapMode flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name READ descriptor I\n+-field name WRITE descriptor I\n+-field name CLOSE descriptor I\n+-field name HANDOFF descriptor I\n+-field name ALL_ACCESS descriptor I\n+-field name SHARE descriptor I\n+-method name ownerThread descriptor ()Ljava\/lang\/Thread;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name withAccessModes descriptor (I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name hasAccessModes descriptor (I)Z\n+-method name accessModes descriptor ()I\n+-method name spliterator descriptor (Ljdk\/incubator\/foreign\/SequenceLayout;)Ljava\/util\/Spliterator;\n+-method name handoff descriptor (Ljava\/lang\/Thread;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name handoff descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name share descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name registerCleaner descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name ofNativeRestricted descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name isReadOnly descriptor ()Z flags 401\n+method name spliterator descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name elements descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name isNative descriptor ()Z flags 401\n+method name isLoaded descriptor ()Z flags 401\n+method name load descriptor ()V flags 401\n+method name unload descriptor ()V flags 401\n+method name force descriptor ()V flags 401\n+method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JJLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; thrownTypes java\/io\/IOException flags 9\n+method name globalNativeSegment descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+-class name jdk\/incubator\/foreign\/NativeScope\n+\n+class name jdk\/incubator\/foreign\/ResourceScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/foreign\/ResourceScope$Handle sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name isAlive descriptor ()Z flags 401\n+method name ownerThread descriptor ()Ljava\/lang\/Thread; flags 401\n+method name isImplicit descriptor ()Z flags 401\n+method name close descriptor ()V flags 401\n+method name addCloseAction descriptor (Ljava\/lang\/Runnable;)V flags 401\n+method name acquire descriptor ()Ljdk\/incubator\/foreign\/ResourceScope$Handle; flags 401\n+method name release descriptor (Ljdk\/incubator\/foreign\/ResourceScope$Handle;)V flags 401\n+method name newConfinedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newConfinedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newImplicitScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name globalScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+\n+class name jdk\/incubator\/foreign\/ResourceScope$Handle\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/ResourceScope sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+\n+class name jdk\/incubator\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name arenaAllocator descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name arenaAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofSegment descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofScope descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+\n+class name jdk\/incubator\/foreign\/SequenceLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/SymbolLookup\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/MemoryAddress;>;\n+method name loaderLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n","filename":"make\/data\/symbols\/jdk.incubator.foreign-H.sym.txt","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/vector\/ByteVector\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/ShortVector\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[II)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[II)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/VectorOperators\n+field name UNSIGNED_LT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_LE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+\n","filename":"make\/data\/symbols\/jdk.incubator.vector-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jartool-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/javadoc\/doclet\/Reporter\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+method name getStandardWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+method name getDiagnosticWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+method name print descriptor (Ljavax\/tools\/Diagnostic$Kind;Ljavax\/tools\/FileObject;IIILjava\/lang\/String;)V flags 1\n+\n+class name jdk\/javadoc\/doclet\/StandardDoclet\n+header extends java\/lang\/Object implements jdk\/javadoc\/doclet\/Doclet flags 21\n+innerclass innerClass jdk\/javadoc\/doclet\/Doclet$Option outerClass jdk\/javadoc\/doclet\/Doclet innerClassName Option flags 609\n+method name getLocale descriptor ()Ljava\/util\/Locale; flags 1\n+method name getReporter descriptor ()Ljdk\/javadoc\/doclet\/Reporter; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.javadoc-H.sym.txt","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/jconsole\/JConsolePlugin\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.jconsole-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/NativeMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"make\/data\/symbols\/jdk.jdi-H.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jfr\/consumer\/RecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/Snippet$SubKind\n+-field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind;\n+field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind; flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+method name interactiveTerminal descriptor (Z)Ljdk\/jshell\/tool\/JavaShellToolBuilder; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jshell-H.sym.txt","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name netscape\/javascript\/JSException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jsobject-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/HotSpotDiagnosticMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"make\/data\/symbols\/jdk.management-H.sym.txt","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/management\/jfr\/RemoteRecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.management.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"make\/data\/symbols\/jdk.net-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/sctp\/AbstractNotificationHandler\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/NotificationHandler flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/nio\/sctp\/NotificationHandler<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/Association\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/nio\/sctp\/HandlerResult\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/sctp\/HandlerResult;>;\n+\n+class name com\/sun\/nio\/sctp\/IllegalReceiveException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/IllegalUnbindException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/InvalidStreamException\n+header extends java\/lang\/IllegalArgumentException flags 21\n+\n+class name com\/sun\/nio\/sctp\/MessageInfo\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/nio\/sctp\/Notification\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/nio\/sctp\/NotificationHandler\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/nio\/sctp\/SctpChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpMultiChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpServerChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpSocketOption\n+header extends java\/lang\/Object implements java\/net\/SocketOption flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/net\/SocketOption<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/SendFailedNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n+class name com\/sun\/nio\/sctp\/ShutdownNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n","filename":"make\/data\/symbols\/jdk.sctp-H.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/auth\/LdapPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/NTDomainPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTNumericCredential\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/NTSid\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidDomainPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidPrimaryGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidUserPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/PrincipalComparator\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/security\/auth\/UnixNumericGroupPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixNumericUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/callback\/TextCallbackHandler\n+header extends java\/lang\/Object implements javax\/security\/auth\/callback\/CallbackHandler flags 21\n+\n+class name com\/sun\/security\/auth\/login\/ConfigFile\n+header extends javax\/security\/auth\/login\/Configuration flags 21\n+\n+class name com\/sun\/security\/auth\/module\/JndiLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/KeyStoreLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/Krb5LoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/LdapLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTSystem\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/module\/UnixLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/UnixSystem\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.security.auth-H.sym.txt","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/jgss\/AuthorizationDataEntry\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSContext\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSContext flags 601\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSCredential\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSCredential flags 601\n+\n+class name com\/sun\/security\/jgss\/GSSUtil\n+header extends java\/lang\/Object flags 21\n+-method name <init> descriptor ()V\n+\n+class name com\/sun\/security\/jgss\/InquireSecContextPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n+class name com\/sun\/security\/jgss\/InquireType\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/security\/jgss\/InquireType;>;\n+\n","filename":"make\/data\/symbols\/jdk.security.jgss-H.sym.txt","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/file\/ExtendedCopyOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/CopyOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedCopyOption;>;Ljava\/nio\/file\/CopyOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedOpenOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/OpenOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedOpenOption;>;Ljava\/nio\/file\/OpenOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name com\/sun\/nio\/file\/SensitivityWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/SensitivityWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name sun\/misc\/SignalHandler\n+header extends java\/lang\/Object flags 601 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name sun\/misc\/Unsafe\n+-method name defineAnonymousClass descriptor (Ljava\/lang\/Class;[B[Ljava\/lang\/Object;)Ljava\/lang\/Class;\n+\n+class name sun\/reflect\/ReflectionFactory\n+header extends java\/lang\/Object flags 21 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n","filename":"make\/data\/symbols\/jdk.unsupported-H.sym.txt","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name org\/w3c\/dom\/css\/CSS2Properties\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSCharsetRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSFontFaceRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSImportRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSMediaRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPageRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPrimitiveValue\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRule\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRuleList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleDeclaration\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleSheet\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/StyleSheet flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSUnknownRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValue\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValueList\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/Counter\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/DOMImplementationCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/css\/DocumentCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/DocumentStyle flags 601\n+\n+class name org\/w3c\/dom\/css\/ElementCSSInlineStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/RGBColor\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/Rect\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/ViewCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/views\/AbstractView flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAnchorElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAppletElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBodyElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLButtonElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLCollection\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDOMImplementation\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDirectoryElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDivElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDocument\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Document flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Element flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFieldSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFormElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadingElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHtmlElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLImageElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLInputElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIsIndexElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLIElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLabelElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLegendElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLinkElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMapElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMenuElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMetaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLModElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLObjectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptGroupElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParagraphElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParamElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLPreElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLQuoteElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLScriptElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLSelectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLStyleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCaptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCellElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableColElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableRowElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableSectionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTextAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTitleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLUListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/DocumentStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/LinkStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/MediaList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheet\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheetList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathEvaluator\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name org\/w3c\/dom\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNSResolver\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNamespace\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Node flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathResult\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/jdk.xml.dom-H.sym.txt","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-generate platforms 7:8:9:A:B:C:D:E:F:G\n+generate platforms 7:8:9:A:B:C:D:E:F:G:H\n@@ -43,0 +43,1 @@\n+platform version H base G files java.base-H.sym.txt:java.compiler-H.sym.txt:java.datatransfer-H.sym.txt:java.desktop-H.sym.txt:java.instrument-H.sym.txt:java.logging-H.sym.txt:java.management-H.sym.txt:java.management.rmi-H.sym.txt:java.naming-H.sym.txt:java.rmi-H.sym.txt:java.scripting-H.sym.txt:java.security.jgss-H.sym.txt:java.security.sasl-H.sym.txt:java.smartcardio-H.sym.txt:java.sql-H.sym.txt:java.sql.rowset-H.sym.txt:java.xml-H.sym.txt:java.xml.crypto-H.sym.txt:jdk.accessibility-H.sym.txt:jdk.attach-H.sym.txt:jdk.compiler-H.sym.txt:jdk.dynalink-H.sym.txt:jdk.httpserver-H.sym.txt:jdk.incubator.foreign-H.sym.txt:jdk.incubator.vector-H.sym.txt:jdk.jartool-H.sym.txt:jdk.javadoc-H.sym.txt:jdk.jconsole-H.sym.txt:jdk.jdi-H.sym.txt:jdk.jfr-H.sym.txt:jdk.jshell-H.sym.txt:jdk.jsobject-H.sym.txt:jdk.management-H.sym.txt:jdk.management.jfr-H.sym.txt:jdk.net-H.sym.txt:jdk.sctp-H.sym.txt:jdk.security.auth-H.sym.txt:jdk.security.jgss-H.sym.txt:jdk.unsupported-H.sym.txt:jdk.xml.dom-H.sym.txt\n","filename":"make\/data\/symbols\/symbols","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+      cdsProtectionDomain.cpp \\\n@@ -121,0 +122,3 @@\n+      dumpTimeSharedClassInfo.cpp \\\n+      lambdaProxyClassDictionary.cpp \\\n+      runTimeSharedClassInfo.cpp \\\n@@ -186,1 +190,0 @@\n-      biasedLocking.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+  BUILD_LIBJVM_ad_$(HOTSPOT_TARGET_CPU_ARCH).cpp_CXXFLAGS := -Wno-nonnull\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_16\" assert-keyword=\"true\" jdk-15=\"true\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" assert-keyword=\"true\" project-jdk-type=\"JavaSDK\">\n","filename":"make\/ide\/idea\/jdk\/template\/misc.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+ * @author Guy Abossolo Foh\n@@ -285,1 +286,1 @@\n-        String dtd_home = System.getProperty(\"dtd_home\") + File.separator;\n+        String dtd_home = System.getProperty(\"dtd_home\");\n@@ -294,1 +295,1 @@\n-            mapping = new PublicMapping(dtd_home, \"public.map\");\n+            mapping = new PublicMapping(dtd_home + File.separator, \"public.map\");\n@@ -299,1 +300,1 @@\n-            System.err.println(\"Could not open DTD file \"+argv[0]);\n+            System.err.println(\"Could not open DTD file \" + argv[0]);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/dtdbuilder\/DTDBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,18 +63,0 @@\n-################################################################################\n-\n-ifeq ($(call isTargetOs, windows), true)\n-\n-  $(eval $(call SetupNativeCompilation, BUILD_LIBTIMEOUT_HANDLER, \\\n-        NAME := timeoutHandler, \\\n-        SRC := $(FH_BASEDIR)\/src\/windows\/native\/libtimeoutHandler, \\\n-        OBJECT_DIR := $(FH_SUPPORT)\/libtimeoutHandler, \\\n-        OUTPUT_DIR := $(FH_SUPPORT), \\\n-        CFLAGS := $(CFLAGS_JDKLIB), \\\n-        LDFLAGS := $(LDFLAGS_JDKLIB), \\\n-        OPTIMIZATION := LOW, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBTIMEOUT_HANDLER)\n-\n-endif\n-\n@@ -102,4 +84,0 @@\n-# Add the dir of the dll to the path on windows\n-ifeq ($(call isTargetOs, windows), true)\n-  export PATH := $(PATH);$(FH_SUPPORT)\n-endif\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1298,1 +1298,1 @@\n- bool is_CAS(int opcode, bool maybe_volatile);\n+  bool is_CAS(int opcode, bool maybe_volatile);\n@@ -2466,4 +2466,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2541,1 +2537,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -2582,0 +2578,33 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n+  \/\/ test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java\n+  \/\/ failed due to C2 compilation failure with\n+  \/\/ \"COMPILE SKIPPED: failed spill-split-recycle sanity check\".\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  if (!PreserveFramePointer) {\n+    \/\/ When PreserveFramePointer is off, frame pointer is allocatable,\n+    \/\/ but different from other SOC registers, it is excluded from\n+    \/\/ fatproj's mask because its save type is No-Save. Decrease 1 to\n+    \/\/ ensure high pressure at fatproj when PreserveFramePointer is off.\n+    \/\/ See check_pressure_at_fatproj().\n+    default_int_pressure_threshold--;\n+  }\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n@@ -3795,4 +3824,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3869,4 +3894,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -5485,0 +5506,9 @@\n+operand pReg()\n+%{\n+  constraint(ALLOC_IN_RC(pr_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -8894,5 +8924,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n@@ -16655,2 +16680,2 @@\n-                              iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                              iRegINoSp tmp3, rFlagsReg cr)\n+                             iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                             iRegINoSp tmp3, rFlagsReg cr)\n@@ -16659,1 +16684,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -16678,1 +16703,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n@@ -16686,2 +16711,2 @@\n-                           $result$$Register, $tmp1$$Register, $tmp2$$Register,\n-                           $tmp3$$Register);\n+                            $result$$Register, $tmp1$$Register, $tmp2$$Register,\n+                            $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1853,1 +1853,1 @@\n-    BasicType bt = vector_element_basic_type(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -1868,1 +1868,1 @@\n-    BasicType bt = vector_element_basic_type(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -5299,0 +5299,169 @@\n+\n+\/\/ vector mask reductions\n+\n+instruct vmask_truecount8B(iRegINoSp dst, vecD src, vecD tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount16B(iRegINoSp dst, vecX src, vecX tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_LT8B(iRegINoSp dst, vecD src, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  ins_cost(7 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (4I\/4S\/2I)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, Matcher::vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() == 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":171,"deletions":2,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2246,0 +2246,148 @@\n+dnl\n+dnl VMASK_TRUECOUNT($1,     $2 )\n+dnl VMASK_TRUECOUNT(suffix, reg)\n+define(`VMASK_TRUECOUNT', `\n+instruct vmask_truecount$1(iRegINoSp dst, $2 src, $2 tmp) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"addv $tmp, $src\\n\\t\"\n+            \"umov $dst, $tmp, B, 0\\t# vector ($1)\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    __ addv(as_FloatRegister($tmp$$reg), __ T$1, as_FloatRegister($src$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+define(`ARGLIST',\n+`ifelse($1, `_LT8B', `iRegINoSp dst, vecD src, rFlagsReg cr', `iRegINoSp dst, vecD src')')\n+dnl\n+dnl VMASK_FIRSTTRUE_D($1,     $2,   $3,   $4  )\n+dnl VMASK_FIRSTTRUE_D(suffix, cond, cost, size)\n+define(`VMASK_FIRSTTRUE_D', `\n+instruct vmask_firsttrue$1(ARGLIST($1)) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n+            n->in(1)->bottom_type()->is_vect()->length() $2 8);\n+  match(Set dst (VectorMaskFirstTrue src));dnl\n+ifelse($1, `_LT8B', `\n+  effect(KILL cr);')\n+  ins_cost($3 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector ($4)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);dnl\n+ifelse(`$1', `_LT8B', `\n+    __ movw(rscratch1, vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+undefine(ARGLIST)dnl\n+dnl\n+\/\/ vector mask reductions\n+VMASK_TRUECOUNT(8B,  vecD)\n+VMASK_TRUECOUNT(16B, vecX)\n+VMASK_FIRSTTRUE_D(_LT8B, <,  7, 4I\/4S\/2I)\n+VMASK_FIRSTTRUE_D(8B,    ==, 4, 8B)\n+\n+instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  ins_cost(6 * INSN_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label FIRST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, zr);\n+    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8);\n+\n+    \/\/ Reverse the bits and count the leading zero bytes.\n+    __ bind(FIRST_TRUE_INDEX);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by counting the leading zero bytes and\n+    \/\/ substracting it by 7 (VLENGTH - 1).\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ movw(rscratch1, 7);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n+  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+  match(Set dst (VectorMaskLastTrue src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    Label LAST_TRUE_INDEX;\n+\n+    \/\/ Try to compute the result from higher 64 bits.\n+    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 16 - 1);\n+    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+    \/\/ Compute the result from the lower 64 bits.\n+    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n+    __ movw(rscratch1, 8 - 1);\n+\n+    \/\/ Count the leading zero bytes and substract it by 15 (VLENGTH - 1).\n+    __ bind(LAST_TRUE_INDEX);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -90,12 +90,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n@@ -206,0 +194,3 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n@@ -231,1 +222,1 @@\n-                         vector_element_basic_type(this), $mem->opcode(),\n+                         Matcher::vector_element_basic_type(this), $mem->opcode(),\n@@ -245,1 +236,1 @@\n-                         vector_element_basic_type(this, $src), $mem->opcode(),\n+                         Matcher::vector_element_basic_type(this, $src), $mem->opcode(),\n@@ -550,1 +541,1 @@\n-    BasicType bt = vector_element_basic_type(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -570,1 +561,1 @@\n-    BasicType bt = vector_element_basic_type(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -1778,0 +1769,39 @@\n+\/\/ Intrisics for String.indexOf(char)\n+\n+\n+instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), true \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), false \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -77,12 +77,0 @@\n-  static inline BasicType vector_element_basic_type(const MachNode* n) {\n-    const TypeVect* vt = n->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n-  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n-    int def_idx = use->operand_index(opnd);\n-    Node* def = use->in(def_idx);\n-    const TypeVect* vt = def->bottom_type()->is_vect();\n-    return vt->element_basic_type();\n-  }\n-\n@@ -193,0 +181,3 @@\n+      case Op_VectorMaskTrueCount:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskFirstTrue:\n@@ -922,0 +913,26 @@\n+\/\/ Intrisics for String.indexOf(char)\n+\n+dnl\n+define(`STRING_INDEXOF_CHAR', `\n+instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+\n+  format %{ \"String$2 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n+                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), $3 \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}')dnl\n+dnl                 $1 $2      $3\n+STRING_INDEXOF_CHAR(L, Latin1, true)\n+STRING_INDEXOF_CHAR(U, UTF16,  false)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -137,1 +137,10 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n+\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -159,0 +168,47 @@\n+\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n+\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n+\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n+\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n+\/\/ the absolute value of the immediate as for uimm24.\n+void Assembler::add_sub_immediate(Instruction_aarch64 &current_insn,\n+                                  Register Rd, Register Rn, unsigned uimm, int op,\n+                                  int negated_op) {\n+  bool sets_flags = op & 1;   \/\/ this op sets flags\n+  union {\n+    unsigned u;\n+    int imm;\n+  };\n+  u = uimm;\n+  bool shift = false;\n+  bool neg = imm < 0;\n+  if (neg) {\n+    imm = -imm;\n+    op = negated_op;\n+  }\n+  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n+  if (imm >= (1 << 11)\n+      && ((imm >> 12) << 12 == imm)) {\n+    imm >>= 12;\n+    shift = true;\n+  }\n+  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n+\n+  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n+  \/\/ with S unset they use sp.\n+  if (sets_flags)\n+    zrf(Rd, 0);\n+  else\n+    srf(Rd, 0);\n+\n+  srf(Rn, 5);\n+}\n+\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -263,37 +319,0 @@\n-\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n-\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n-\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n-\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n-\/\/ the absolute value of the immediate as for uimm24.\n-void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                                  int negated_op) {\n-  bool sets_flags = op & 1;   \/\/ this op sets flags\n-  union {\n-    unsigned u;\n-    int imm;\n-  };\n-  u = uimm;\n-  bool shift = false;\n-  bool neg = imm < 0;\n-  if (neg) {\n-    imm = -imm;\n-    op = negated_op;\n-  }\n-  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n-  if (imm >= (1 << 11)\n-      && ((imm >> 12) << 12 == imm)) {\n-    imm >>= 12;\n-    shift = true;\n-  }\n-  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n-\n-  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n-  \/\/ with S unset they use sp.\n-  if (sets_flags)\n-    zrf(Rd, 0);\n-  else\n-    srf(Rd, 0);\n-\n-  srf(Rn, 5);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":57,"deletions":38,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n@@ -252,1 +251,0 @@\n-    mask <<= lsb;\n@@ -254,1 +252,0 @@\n-    assert_cond((bits & mask) == 0);\n@@ -256,0 +253,3 @@\n+    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n+    mask <<= lsb;\n+    assert_cond((bits & mask) == 0);\n@@ -316,1 +316,1 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n@@ -697,40 +697,8 @@\n-  Instruction_aarch64* current;\n-\n-  void set_current(Instruction_aarch64* i) { current = i; }\n-\n-  void f(unsigned val, int msb, int lsb) {\n-    current->f(val, msb, lsb);\n-  }\n-  void f(unsigned val, int msb) {\n-    current->f(val, msb, msb);\n-  }\n-  void sf(int64_t val, int msb, int lsb) {\n-    current->sf(val, msb, lsb);\n-  }\n-  void rf(Register reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void srf(Register reg, int lsb) {\n-    current->srf(reg, lsb);\n-  }\n-  void zrf(Register reg, int lsb) {\n-    current->zrf(reg, lsb);\n-  }\n-  void rf(FloatRegister reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void prf(PRegister reg, int lsb) {\n-    current->prf(reg, lsb);\n-  }\n-  void pgrf(PRegister reg, int lsb) {\n-    current->pgrf(reg, lsb);\n-  }\n-  void fixed(unsigned value, unsigned mask) {\n-    current->fixed(value, mask);\n-  }\n-\n-  void emit() {\n-    emit_long(current->get_insn());\n-    assert_cond(current->get_bits() == 0xffffffff);\n-    current = NULL;\n-  }\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -767,2 +735,2 @@\n-  void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                         int negated_op);\n+  void add_sub_immediate(Instruction_aarch64 &current_insn, Register Rd, Register Rn,\n+                         unsigned uimm, int op, int negated_op);\n@@ -780,1 +748,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);                    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);      \\\n@@ -793,1 +761,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);     \\\n@@ -1095,1 +1063,1 @@\n-           Register rt = (Register)0b11111) {\n+           Register rt = as_Register(0b11111)) {\n@@ -1364,1 +1332,1 @@\n-    rf((Register)Rt, 0);                                                \\\n+    rf(as_Register(Rt), 0);                                             \\\n@@ -1378,1 +1346,1 @@\n-    rf(Rn, 5), rf((Register)Rt, 0);                                     \\\n+    rf(Rn, 5), rf(as_Register(Rt), 0);                                  \\\n@@ -1411,1 +1379,1 @@\n-      adr.encode_nontemporal_pair(current);\n+      adr.encode_nontemporal_pair(&current_insn);\n@@ -1413,1 +1381,1 @@\n-      adr.encode_pair(current);\n+      adr.encode_pair(&current_insn);\n@@ -1439,1 +1407,2 @@\n-    ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \\\n+    ld_st1(size, p1, V, L,                                              \\\n+           as_Register(Rt1), as_Register(Rt2), adr, no_allocate);       \\\n@@ -1474,1 +1443,1 @@\n-    adr.encode(current);\n+    adr.encode(&current_insn);\n@@ -1502,1 +1471,1 @@\n-    ld_st2((Register)pfop, adr, size, op);                      \\\n+    ld_st2(as_Register(pfop), adr, size, op);                   \\\n@@ -1513,1 +1482,1 @@\n-    ld_st2((Register)Rt, adr, size, op, 1);             \\\n+    ld_st2(as_Register(Rt), adr, size, op, 1);          \\\n@@ -1550,1 +1519,1 @@\n-  void op_shifted_reg(unsigned decode,\n+  void op_shifted_reg(Instruction_aarch64 &current_insn, unsigned decode,\n@@ -1561,8 +1530,8 @@\n-#define INSN(NAME, size, op, N)                                 \\\n-  void NAME(Register Rd, Register Rn, Register Rm,              \\\n-            enum shift_kind kind = LSL, unsigned shift = 0) {   \\\n-    starti;                                                     \\\n-    guarantee(size == 1 || shift < 32, \"incorrect shift\");      \\\n-    f(N, 21);                                                   \\\n-    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \\\n-    op_shifted_reg(0b01010, kind, shift, size, op);             \\\n+#define INSN(NAME, size, op, N)                                         \\\n+  void NAME(Register Rd, Register Rn, Register Rm,                      \\\n+            enum shift_kind kind = LSL, unsigned shift = 0) {           \\\n+    starti;                                                             \\\n+    guarantee(size == 1 || shift < 32, \"incorrect shift\");              \\\n+    f(N, 21);                                                           \\\n+    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1588,1 +1557,1 @@\n-    op_shifted_reg(0b01010, kind, shift, size, op);                     \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1635,1 +1604,1 @@\n-    op_shifted_reg(0b01011, kind, shift, size, op);     \\\n+    op_shifted_reg(current_insn, 0b01011, kind, shift, size, op);      \\\n@@ -1656,1 +1625,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1659,1 +1628,1 @@\n-  void add_sub_extended_reg(unsigned op, unsigned decode,\n+  void add_sub_extended_reg(Instruction_aarch64 &current_insn, unsigned op, unsigned decode,\n@@ -1679,1 +1648,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1780,1 +1749,1 @@\n-  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \\\n+  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) {    \\\n@@ -1796,1 +1765,1 @@\n-  void data_processing(unsigned op29, unsigned opcode,\n+  void data_processing(Instruction_aarch64 &current_insn, unsigned op29, unsigned opcode,\n@@ -1804,5 +1773,5 @@\n-#define INSN(NAME, op29, opcode2, opcode)       \\\n-  void NAME(Register Rd, Register Rn) {         \\\n-    starti;                                     \\\n-    f(opcode2, 20, 16);                         \\\n-    data_processing(op29, opcode, Rd, Rn);      \\\n+#define INSN(NAME, op29, opcode2, opcode)                       \\\n+  void NAME(Register Rd, Register Rn) {                         \\\n+    starti;                                                     \\\n+    f(opcode2, 20, 16);                                         \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1827,5 +1796,5 @@\n-#define INSN(NAME, op29, opcode)                        \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    starti;                                             \\\n-    rf(Rm, 16);                                         \\\n-    data_processing(op29, opcode, Rd, Rn);              \\\n+#define INSN(NAME, op29, opcode)                                \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {            \\\n+    starti;                                                     \\\n+    rf(Rm, 16);                                                 \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1876,3 +1845,3 @@\n-#define INSN(NAME, op54, op31, o0)                      \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \\\n+#define INSN(NAME, op54, op31, o0)                                      \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {                    \\\n+    data_processing(op54, op31, o0, Rd, Rn, Rm, as_Register(31));       \\\n@@ -2057,1 +2026,1 @@\n-    float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \\\n+    float_int_convert(op31, type, rmode, opcode, Rd, as_Register(Vn));  \\\n@@ -2068,1 +2037,1 @@\n-  \/\/ INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n+  INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n@@ -2074,1 +2043,1 @@\n-    float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \\\n+    float_int_convert(op31, type, rmode, opcode, as_Register(Vd), Rn);  \\\n@@ -2129,1 +2098,1 @@\n-                     FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {\n+                     FloatRegister Vn, FloatRegister Vm = as_FloatRegister(0)) {\n@@ -2259,4 +2228,4 @@\n-#define INSN(NAME, op)                                            \\\n-  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {   \\\n-    ld_st2((Register)Rt, adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n-  }                                                                      \\\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {  \\\n+    ld_st2(as_Register(Rt), adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n+  }\n@@ -3248,0 +3217,64 @@\n+\/\/ Integer comparisons (SVE)\n+#define INSN(NAME, cond)                                                                          \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n+    starti;                                                                                       \\\n+    assert(T != Q, \"invalid size\");                                                               \\\n+    f(0b00100100, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);        \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 1, 4), prf(Pd, 0);                                          \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b1010);  \/\/ Compare signed equal to vector\n+  INSN(sve_cmpne, 0b1011);  \/\/ Compare not equal to vector\n+  INSN(sve_cmpge, 0b1000);  \/\/ Compare signed greater than or equal to vector\n+  INSN(sve_cmpgt, 0b1001);  \/\/ Compare signed greater than vector\n+#undef INSN\n+\n+\/\/ Predicate counted loop (SVE) (32-bit variants are not included)\n+#define INSN(NAME, decode)                                                \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, Register Rn, Register Rm) {  \\\n+    starti;                                                               \\\n+    assert(T != Q, \"invalid register variant\");                           \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(1, 21),                        \\\n+    zrf(Rm, 16), f(0, 15, 13), f(1, 12), f(decode >> 1, 11, 10),          \\\n+    zrf(Rn, 5), f(decode & 1, 4), prf(Pd, 0);                             \\\n+  }\n+\n+  INSN(sve_whilelt, 0b010);  \/\/ While incrementing signed scalar less than scalar\n+  INSN(sve_whilele, 0b011);  \/\/ While incrementing signed scalar less than or equal to scalar\n+  INSN(sve_whilelo, 0b110);  \/\/ While incrementing unsigned scalar lower than scalar\n+  INSN(sve_whilels, 0b111);  \/\/ While incrementing unsigned scalar lower than or the same as scalar\n+#undef INSN\n+\n+  \/\/ Predicate scan (SVE)\n+\n+  \/\/ Break after the first true condition\n+  void sve_brka(PRegister pd, PRegister pg, PRegister pn, bool isMerge) {\n+    starti;\n+    f(0b00100101, 31, 24), f(0b00, 23, 22), f(0b01000001, 21, 14),\n+    prf(pg, 10), f(0b0, 9), prf(pn, 5), f(isMerge ? 1 : 0, 4), prf(pd, 0);\n+  }\n+\n+\/\/ Element count and increment scalar (SVE)\n+#define INSN(NAME, TYPE)                                                             \\\n+  void NAME(Register Xdn, unsigned imm4 = 1, int pattern = 0b11111) {                \\\n+    starti;                                                                          \\\n+    f(0b00000100, 31, 24), f(TYPE, 23, 22), f(0b10, 21, 20);                         \\\n+    f(imm4 - 1, 19, 16), f(0b11100, 15, 11), f(0, 10), f(pattern, 9, 5), rf(Xdn, 0); \\\n+  }\n+\n+  INSN(sve_cntb, B);  \/\/ Set scalar to multiple of 8-bit predicate constraint element count\n+  INSN(sve_cnth, H);  \/\/ Set scalar to multiple of 16-bit predicate constraint element count\n+  INSN(sve_cntw, S);  \/\/ Set scalar to multiple of 32-bit predicate constraint element count\n+  INSN(sve_cntd, D);  \/\/ Set scalar to multiple of 64-bit predicate constraint element count\n+#undef INSN\n+\n+  \/\/ Predicate count and increment scalar (SVE)\n+\n+  \/\/ Set scalar to the number of Active predicate elements that are TRUE\n+  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n+    prf(pg, 5), rf(rd, 0);\n+  }\n+\n@@ -3268,1 +3301,2 @@\n-  assem->emit();\n+  assem->emit_int32(insn);\n+  assert_cond(get_bits() == 0xffffffff);\n@@ -3271,0 +3305,9 @@\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -3278,2 +3321,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":138,"deletions":97,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_4_release_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_8_release_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_4_seq_cst_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_cmpxchg_8_seq_cst_impl;\n","filename":"src\/hotspot\/cpu\/aarch64\/atomic_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,2 +364,4 @@\n-  __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n-  __ incrementw(Address(rscratch2));\n+  if (PrintC1Statistics) {\n+    __ lea(rscratch2, ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+    __ incrementw(Address(rscratch2));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -787,1 +787,1 @@\n-void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool \/* unaligned *\/) {\n+void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n@@ -944,1 +944,1 @@\n-void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool \/* unaligned *\/) {\n+void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -2580,4 +2580,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -2586,1 +2582,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n@@ -2840,1 +2836,1 @@\n-        __ ldr(tmp, mdo_addr);\n+        __ str(tmp, mdo_addr);\n@@ -2914,1 +2910,1 @@\n-            \/*pop_fpu_stack*\/false, \/*unaligned*\/false, \/*wide*\/false);\n+            \/*pop_fpu_stack*\/false, \/*wide*\/false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -334,5 +334,0 @@\n-  \/\/ Need a scratch register for biased locking\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -347,1 +342,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -64,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -85,5 +84,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &slow_case);\n-  }\n-\n@@ -125,4 +119,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    lea(rscratch2, ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-    addmw(Address(rscratch2, 0), 1, rscratch1);\n-  }\n@@ -139,6 +129,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -150,4 +134,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -182,7 +164,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -63,1 +62,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -543,0 +543,69 @@\n+void C2_MacroAssembler::string_indexof_char_sve(Register str1, Register cnt1,\n+                                                Register ch, Register result,\n+                                                FloatRegister ztmp1,\n+                                                FloatRegister ztmp2,\n+                                                PRegister tmp_pg,\n+                                                PRegister tmp_pdn, bool isL)\n+{\n+  \/\/ Note that `tmp_pdn` should *NOT* be used as governing predicate register.\n+  assert(tmp_pg->is_governing(),\n+         \"this register has to be a governing predicate register\");\n+\n+  Label LOOP, MATCH, DONE, NOMATCH;\n+  Register vec_len = rscratch1;\n+  Register idx = rscratch2;\n+\n+  SIMD_RegVariant T = (isL == true) ? B : H;\n+\n+  cbz(cnt1, NOMATCH);\n+\n+  \/\/ Assign the particular char throughout the vector.\n+  sve_dup(ztmp2, T, ch);\n+  if (isL) {\n+    sve_cntb(vec_len);\n+  } else {\n+    sve_cnth(vec_len);\n+  }\n+  mov(idx, 0);\n+\n+  \/\/ Generate a predicate to control the reading of input string.\n+  sve_whilelt(tmp_pg, T, idx, cnt1);\n+\n+  BIND(LOOP);\n+    \/\/ Read a vector of 8- or 16-bit data depending on the string type. Note\n+    \/\/ that inactive elements indicated by the predicate register won't cause\n+    \/\/ a data read from memory to the destination vector.\n+    if (isL) {\n+      sve_ld1b(ztmp1, T, tmp_pg, Address(str1, idx));\n+    } else {\n+      sve_ld1h(ztmp1, T, tmp_pg, Address(str1, idx, Address::lsl(1)));\n+    }\n+    add(idx, idx, vec_len);\n+\n+    \/\/ Perform the comparison. An element of the destination predicate is set\n+    \/\/ to active if the particular char is matched.\n+    sve_cmpeq(tmp_pdn, T, tmp_pg, ztmp1, ztmp2);\n+\n+    \/\/ Branch if the particular char is found.\n+    br(NE, MATCH);\n+\n+    sve_whilelt(tmp_pg, T, idx, cnt1);\n+\n+    \/\/ Loop back if the particular char not found.\n+    br(MI, LOOP);\n+\n+  BIND(NOMATCH);\n+    mov(result, -1);\n+    b(DONE);\n+\n+  BIND(MATCH);\n+    \/\/ Undo the index increment.\n+    sub(idx, idx, vec_len);\n+\n+    \/\/ Crop the vector to find its location.\n+    sve_brka(tmp_pdn, tmp_pg, tmp_pdn, false \/* isMerge *\/);\n+    add(result, idx, -1);\n+    sve_incp(result, T, tmp_pdn);\n+  BIND(DONE);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -49,2 +49,7 @@\n-                           Register ch, Register result,\n-                           Register tmp1, Register tmp2, Register tmp3);\n+                            Register ch, Register result,\n+                            Register tmp1, Register tmp2, Register tmp3);\n+\n+  void string_indexof_char_sve(Register str1, Register cnt1,\n+                               Register ch, Register result,\n+                               FloatRegister ztmp1, FloatRegister ztmp2,\n+                               PRegister pgtmp, PRegister ptmp, bool isL);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                32);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  24);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  const Register (*to_Register)(int) = as_Register;\n@@ -50,1 +51,1 @@\n-  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n+  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n@@ -54,1 +55,1 @@\n-  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n+  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n@@ -58,1 +59,1 @@\n-  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n+  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                                thread->get_thread_name(), frame.sp(), nm->verified_entry_point());\n+                                thread->name(), frame.sp(), nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -757,4 +756,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, done, &slow_case);\n-    }\n-\n@@ -772,11 +767,1 @@\n-    if (PrintBiasedLockingStatistics) {\n-      Label fast;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, fast, &fail);\n-      bind(fast);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-      b(done);\n-      bind(fail);\n-    } else {\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n-    }\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n@@ -819,6 +804,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      br(Assembler::NE, slow_case);\n-      atomic_incw(Address((address)BiasedLocking::fast_path_entry_count_addr()),\n-                  rscratch2, rscratch1, tmp);\n-    }\n@@ -875,4 +854,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3838,5 +3665,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":178,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -108,14 +108,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg is killed.\n-  \/\/ tmp_reg must be supplied and must not be rscratch1 or rscratch2\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n-\n@@ -850,2 +836,0 @@\n-  void load_prototype_header(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-inline Register as_Register(int encoding) {\n+inline const Register as_Register(int encoding) {\n@@ -56,1 +56,1 @@\n-  inline friend Register as_Register(int encoding);\n+  inline friend const Register as_Register(int encoding);\n@@ -245,0 +245,1 @@\n+    number_of_governing_registers = 8,\n@@ -260,0 +261,1 @@\n+  bool  is_governing() const      { return 0 <= (intptr_t)this && (intptr_t)this < number_of_governing_registers; }\n@@ -423,0 +425,4 @@\n+inline Register as_Register(FloatRegister reg) {\n+  return as_Register(reg->encoding());\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1776,4 +1776,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1927,5 +1923,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5686,0 +5686,1 @@\n+   *  c_rarg6   - isMIME\n@@ -5768,6 +5769,7 @@\n-    Register src   = c_rarg0;  \/\/ source array\n-    Register soff  = c_rarg1;  \/\/ source start offset\n-    Register send  = c_rarg2;  \/\/ source end offset\n-    Register dst   = c_rarg3;  \/\/ dest array\n-    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n-    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+    Register src    = c_rarg0;  \/\/ source array\n+    Register soff   = c_rarg1;  \/\/ source start offset\n+    Register send   = c_rarg2;  \/\/ source end offset\n+    Register dst    = c_rarg3;  \/\/ dest array\n+    Register doff   = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL  = c_rarg5;  \/\/ Base64 or URL character set\n+    Register isMIME = c_rarg6;  \/\/ Decoding MIME block - unused in this implementation\n@@ -5957,0 +5959,4 @@\n+      case memory_order_release:\n+        acquire = false;\n+        release = true;\n+        break;\n@@ -6038,0 +6044,14 @@\n+    AtomicStubMark mark_cmpxchg_4_release\n+      (_masm, &aarch64_atomic_cmpxchg_4_release_impl);\n+    gen_cas_entry(MacroAssembler::word, memory_order_release);\n+    AtomicStubMark mark_cmpxchg_8_release\n+      (_masm, &aarch64_atomic_cmpxchg_8_release_impl);\n+    gen_cas_entry(MacroAssembler::xword, memory_order_release);\n+\n+    AtomicStubMark mark_cmpxchg_4_seq_cst\n+      (_masm, &aarch64_atomic_cmpxchg_4_seq_cst_impl);\n+    gen_cas_entry(MacroAssembler::word, memory_order_seq_cst);\n+    AtomicStubMark mark_cmpxchg_8_seq_cst\n+      (_masm, &aarch64_atomic_cmpxchg_8_seq_cst_impl);\n+    gen_cas_entry(MacroAssembler::xword, memory_order_seq_cst);\n+\n@@ -7204,0 +7224,4 @@\n+DEFAULT_ATOMIC_OP(cmpxchg, 4, _release)\n+DEFAULT_ATOMIC_OP(cmpxchg, 8, _release)\n+DEFAULT_ATOMIC_OP(cmpxchg, 4, _seq_cst)\n+DEFAULT_ATOMIC_OP(cmpxchg, 8, _seq_cst)\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3556,5 +3556,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1004,4 +1004,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1058,1 +1054,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1103,0 +1099,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 12 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 30 : FLOATPRESSURE;\n+}\n+\n@@ -5457,1 +5463,0 @@\n-    \/\/ used by biased locking only. Requires a membar.\n@@ -8957,1 +8962,0 @@\n-  predicate(!(UseBiasedLocking && !UseOptoBiasInlining));\n@@ -8969,16 +8973,0 @@\n-instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,\n-                                  iRegP scratch, iRegP scratch3) %{\n-  match(Set pcc (FastLock object box));\n-  predicate(UseBiasedLocking && !UseOptoBiasInlining);\n-\n-  effect(TEMP scratch, TEMP scratch2, TEMP scratch3);\n-  ins_cost(DEFAULT_COST*5);\n-\n-  format %{ \"FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);\n-  %}\n-  ins_pipe(long_memory_op);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#define GENERATE_ADDRESS_IS_PREFERRED\n","filename":"src\/hotspot\/cpu\/arm\/c1_Defs_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    __ unlock_object(R2, R1, R0, Rtemp, *stub->entry());\n+    __ unlock_object(R2, R1, R0, *stub->entry());\n@@ -497,2 +497,1 @@\n-                            bool pop_fpu_stack, bool wide,\n-                            bool unaligned) {\n+                            bool pop_fpu_stack, bool wide) {\n@@ -698,1 +697,1 @@\n-                            bool wide, bool unaligned) {\n+                            bool wide) {\n@@ -2432,2 +2431,0 @@\n-  Register tmp = op->scratch_opr()->is_illegal() ? noreg :\n-                 op->scratch_opr()->as_pointer_register();\n@@ -2439,1 +2436,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n@@ -2444,1 +2441,1 @@\n-    __ unlock_object(hdr, obj, lock, tmp, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -415,8 +415,0 @@\n-  \/\/ Need a scratch register for biased locking on arm\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if(UseBiasedLocking) {\n-    scratch = new_pointer_register();\n-  } else {\n-    scratch = atomicLockOpr();\n-  }\n-\n@@ -429,1 +421,1 @@\n-  monitor_enter(obj.result(), lock, hdr, scratch,\n+  monitor_enter(obj.result(), lock, hdr, LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -93,5 +92,1 @@\n-  if(UseBiasedLocking && !len->is_valid()) {\n-    ldr(tmp, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    mov(tmp, (intptr_t)markWord::prototype().value());\n-  }\n+  mov(tmp, (intptr_t)markWord::prototype().value());\n@@ -190,3 +185,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj,\n-                                   Register disp_hdr, Register tmp1,\n-                                   Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -197,1 +190,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp1, tmp2);\n+  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n@@ -214,4 +207,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr\/*scratched*\/, tmp1, false, tmp2, done, slow_case);\n-  }\n-\n@@ -252,7 +241,0 @@\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics) {\n-    cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n@@ -264,5 +246,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj,\n-                                      Register disp_hdr, Register tmp,\n-                                      Label& slow_case) {\n-  \/\/ Note: this method is not using its 'tmp' argument\n-\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -277,5 +255,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n@@ -290,4 +263,2 @@\n-  if(!UseBiasedLocking) {\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-  }\n+  \/\/ load object\n+  ldr(obj, Address(disp_hdr, obj_offset));\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2, Register scratch3) {\n+void C2_MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2) {\n@@ -100,8 +100,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    assert(scratch3 != noreg, \"need extra temporary for -XX:-UseOptoBiasInlining\");\n-    biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);\n-    \/\/ Fall through if lock not biased otherwise branch to done\n-  }\n-\n-  \/\/ Invariant: Rmark loaded below does not contain biased lock pattern\n-\n@@ -151,4 +143,0 @@\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(Roop, Rscratch, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  void fast_lock(Register obj, Register box, Register scratch, Register scratch2, Register scratch3 = noreg);\n+  void fast_lock(Register obj, Register box, Register scratch, Register scratch2);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                30);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  12);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -893,5 +892,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(Robj, Rmark\/*scratched*\/, R0, false, Rtemp, done, slow_case);\n-    }\n-\n-\n@@ -915,6 +909,0 @@\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(al, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/!PRODUCT\n-\n@@ -965,7 +953,0 @@\n-\n-#ifndef PRODUCT\n-    if (PrintBiasedLockingStatistics) {\n-      cond_atomic_inc32(eq, BiasedLocking::fast_path_entry_count_addr());\n-    }\n-#endif \/\/ !PRODUCT\n-\n@@ -1013,4 +994,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(Robj, Rmark, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1291,215 +1290,0 @@\n-\n-\/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-\/\/ The slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-void MacroAssembler::biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                                 Register tmp, Label& slow_case, int* counter_addr) {\n-\n-  cas_for_lock_acquire(old_mark_reg, new_mark_reg, obj_reg, tmp, slow_case);\n-#ifdef ASSERT\n-  breakpoint(ne); \/\/ Fallthrough only on success\n-#endif\n-#ifndef PRODUCT\n-  if (counter_addr != NULL) {\n-    cond_atomic_inc32(al, counter_addr);\n-  }\n-#endif \/\/ !PRODUCT\n-}\n-\n-void MacroAssembler::biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Register tmp2,\n-                                          Label& done, Label& slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  \/\/ obj_reg must be preserved (at least) if the bias locking fails\n-  \/\/ tmp_reg is a temporary register\n-  \/\/ swap_reg was used as a temporary but contained a value\n-  \/\/   that was used afterwards in some call pathes. Callers\n-  \/\/   have been fixed so that swap_reg no longer needs to be\n-  \/\/   saved.\n-  \/\/ Rtemp in no longer scratched\n-\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, swap_reg, tmp_reg, tmp2);\n-  guarantee(swap_reg!=tmp_reg, \"invariant\");\n-  assert(tmp_reg != noreg, \"must supply tmp_reg\");\n-\n-#ifndef PRODUCT\n-  if (PrintBiasedLockingStatistics && (counters == NULL)) {\n-    counters = BiasedLocking::counters();\n-  }\n-#endif\n-\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-\n-  \/\/ On MP platform loads could return 'stale' values in some cases.\n-  \/\/ That is acceptable since either CAS or slow case path is taken in the worst case.\n-\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-\n-  b(cas_label, ne);\n-\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_klass(tmp_reg, obj_reg);\n-  ldr(tmp_reg, Address(tmp_reg, Klass::prototype_header_offset()));\n-  orr(tmp_reg, tmp_reg, Rthread);\n-  eor(tmp_reg, tmp_reg, swap_reg);\n-\n-  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n-\n-#ifndef PRODUCT\n-  if (counters != NULL) {\n-    cond_atomic_inc32(eq, counters->biased_lock_entry_count_addr());\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  b(done, eq);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  tst(tmp_reg, markWord::biased_lock_mask_in_place);\n-  b(try_revoke_bias, ne);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  tst(tmp_reg, markWord::epoch_mask_in_place);\n-  b(try_rebias, ne);\n-\n-  \/\/ tmp_reg has the age, epoch and pattern bits cleared\n-  \/\/ The remaining (owner) bits are (Thread ^ current_owner)\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-\n-  \/\/ Note that we know the owner is not ourself. Hence, success can\n-  \/\/ only happen when the owner bits is 0\n-\n-  \/\/ until the assembler can be made smarter, we need to make some assumptions about the values\n-  \/\/ so we can optimize this:\n-  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n-\n-  mov(swap_reg, AsmOperand(swap_reg, lsl, 23));\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n-\n-  orr(tmp_reg, swap_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->anonymously_biased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_rebias);\n-\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Set them to Rthread.\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  orr(tmp_reg, tmp_reg, Rthread); \/\/ new mark\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, slow_case,\n-        (counters != NULL) ? counters->rebiased_lock_entry_count_addr() : NULL);\n-\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-\n-  \/\/ tmp_reg low (not owner) bits are (age: 0 | pattern&epoch: prototype^swap_reg)\n-\n-  eor(tmp_reg, tmp_reg, swap_reg); \/\/ OK except for owner bits (age preserved !)\n-\n-  \/\/ owner bits 'random'. Clear them\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsl, 23));\n-  mov(tmp_reg, AsmOperand(tmp_reg, lsr, 23));\n-\n-  biased_locking_enter_with_cas(obj_reg, swap_reg, tmp_reg, tmp2, cas_label,\n-        (counters != NULL) ? counters->revoked_lock_entry_count_addr() : NULL);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-\n-  bind(cas_label);\n-}\n-\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register tmp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(tmp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-  andr(tmp_reg, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markWord::biased_lock_pattern);\n-  b(done, eq);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":216,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -362,23 +360,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be supplied.\n-  \/\/ tmp_reg must be supplied.\n-  \/\/ Done label is branched to with condition code EQ set if the lock is\n-  \/\/ biased and we acquired it. Slow case label is branched to with\n-  \/\/ condition code NE set if the lock is biased but we failed to acquire\n-  \/\/ it. Otherwise fall through.\n-  \/\/ Notes:\n-  \/\/ - swap_reg and tmp_reg are scratched\n-  \/\/ - Rtemp was (implicitly) scratched and can now be specified as the tmp2\n-  void biased_locking_enter(Register obj_reg, Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Register tmp2,\n-                            Label& done, Label& slow_case,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit(Register obj_reg, Register temp_reg, Label& done);\n-\n-  \/\/ Building block for CAS cases of biased locking: makes CAS and records statistics.\n-  \/\/ Optional slow_case label is used to transfer control if CAS fails. Otherwise leaves condition codes set.\n-  void biased_locking_enter_with_cas(Register obj_reg, Register old_mark_reg, Register new_mark_reg,\n-                                     Register tmp, Label& slow_case, int* counter_addr);\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -865,5 +865,0 @@\n-    if (UseBiasedLocking) {\n-      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n-    }\n-\n@@ -1154,1 +1149,1 @@\n-  Label slow_lock, slow_lock_biased, lock_done, fast_lock;\n+  Label slow_lock, lock_done, fast_lock;\n@@ -1161,4 +1156,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_enter(sync_obj, tmp, disp_hdr\/*scratched*\/, false, Rtemp, lock_done, slow_lock_biased);\n-    }\n-\n@@ -1246,6 +1237,0 @@\n-    if(UseBiasedLocking) {\n-      __ biased_locking_exit(sync_obj, Rtemp, unlock_done);\n-      \/\/ disp_hdr may not have been saved on entry with biased locking\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n@@ -1307,5 +1292,0 @@\n-    if(UseBiasedLocking) {\n-      __ bind(slow_lock_biased);\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3970,5 +3970,1 @@\n-    if (UseBiasedLocking) {\n-      __ ldr(Rtemp, Address(Rklass, Klass::prototype_header_offset()));\n-    } else {\n-      __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n-    }\n+    __ mov_slow(Rtemp, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,2 +97,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,13 +351,0 @@\n-\n-bool VM_Version::use_biased_locking() {\n-  get_os_cpu_info();\n-  \/\/ The cost of CAS on uniprocessor ARM v6 and later is low compared to the\n-  \/\/ overhead related to slightly longer Biased Locking execution path.\n-  \/\/ Testing shows no improvement when running with Biased Locking enabled\n-  \/\/ on an ARMv6 and higher uniprocessor systems.  The situation is different on\n-  \/\/ ARMv5 and MP systems.\n-  \/\/\n-  \/\/ Therefore the Biased Locking is enabled on ARMv5 and ARM MP only.\n-  \/\/\n-  return (!os::is_MP() && (arm_arch() > 5)) ? false : true;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -827,0 +827,4 @@\n+\n+    \/\/ xxpermx\n+    XXPERMX_PREFIX_OPCODE = PREFIX_PRIMARY_OPCODE | (1u << PRE_TYPE_SHIFT),\n+    XXPERMX_SUFFIX_OPCODE = (34u << OPCODE_SHIFT),\n@@ -2351,0 +2355,1 @@\n+  inline void xxpermx(  VectorSRegister d, VectorSRegister a, VectorSRegister b, VectorSRegister c, int ui3);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,0 +145,5 @@\n+inline void Assembler::xxpermx( VectorSRegister d, VectorSRegister a, VectorSRegister b, VectorSRegister c, int ui3) {\n+  emit_int32(XXPERMX_PREFIX_OPCODE | uimm(ui3, 3));\n+  emit_int32(XXPERMX_SUFFIX_OPCODE | vsrt(d) | vsra(a) | vsrb(b) | vsrc(c));\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -494,6 +494,8 @@\n-  const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n-  const Register tmp = R3, tmp2 = R4;\n-  int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n-  __ lwz(tmp2, simm16_offs, tmp);\n-  __ addi(tmp2, tmp2, 1);\n-  __ stw(tmp2, simm16_offs, tmp);\n+  if (PrintC1Statistics) {\n+    const address counter = (address)&Runtime1::_arraycopy_slowcase_cnt;\n+    const Register tmp = R3, tmp2 = R4;\n+    int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);\n+    __ lwz(tmp2, simm16_offs, tmp);\n+    __ addi(tmp2, tmp2, 1);\n+    __ stw(tmp2, simm16_offs, tmp);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -717,1 +717,1 @@\n-int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {\n+int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide) {\n@@ -797,1 +797,1 @@\n-int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {\n+int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide) {\n@@ -968,1 +968,1 @@\n-    offset = store(tmp, base, addr->disp(), type, wide, false);\n+    offset = store(tmp, base, addr->disp(), type, wide);\n@@ -1123,1 +1123,1 @@\n-                            LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {\n+                            LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -1173,1 +1173,1 @@\n-    offset = load(src, disp_value, to_reg, type, wide, unaligned);\n+    offset = load(src, disp_value, to_reg, type, wide);\n@@ -1175,1 +1175,0 @@\n-    assert(!unaligned, \"unexpected\");\n@@ -1196,2 +1195,1 @@\n-  bool unaligned = addr.disp() % 8 != 0;\n-  load(addr.base(), addr.disp(), dest, dest->type(), true \/*wide*\/, unaligned);\n+  load(addr.base(), addr.disp(), dest, dest->type(), true \/*wide*\/);\n@@ -1208,2 +1206,2 @@\n-  bool unaligned = addr.disp() % 8 != 0;\n-  store(from_reg, addr.base(), addr.disp(), from_reg->type(), true \/*wide*\/, unaligned);\n+\n+  store(from_reg, addr.base(), addr.disp(), from_reg->type(), true \/*wide*\/);\n@@ -1245,1 +1243,1 @@\n-                            bool wide, bool unaligned) {\n+                            bool wide) {\n@@ -1302,1 +1300,1 @@\n-    offset = store(from_reg, src, disp_value, type, wide, unaligned);\n+    offset = store(from_reg, src, disp_value, type, wide);\n@@ -1304,1 +1302,0 @@\n-    assert(!unaligned, \"unexpected\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  int store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned);\n+  int store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide);\n@@ -44,1 +44,1 @@\n-  int load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned);\n+  int load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,6 +312,1 @@\n-  if ((t == T_LONG || t == T_DOUBLE) &&\n-      (in_bytes(offset_from_sp) % 8 != 0)) {\n-    __ unaligned_move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));\n-  } else {\n-    __ move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));\n-  }\n+  __ move(item, new LIR_Address(sp_opr, in_bytes(offset_from_sp), t));\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -118,4 +117,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(CCR0, Roop, Rmark, Rscratch, R0, done, &slow_int);\n-  }\n-\n@@ -167,6 +162,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load the object out of the BasicObjectLock.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-    biased_locking_exit(CCR0, Roop, R0, done);\n-  }\n@@ -177,5 +166,4 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n-    verify_oop(Roop, FILE_AND_LINE);\n-  }\n+\n+  \/\/ Load object.\n+  ld(Roop, BasicObjectLock::obj_offset_in_bytes(), Rbox);\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -225,5 +213,1 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    ld(t1, in_bytes(Klass::prototype_header_offset()), klass);\n-  } else {\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                28);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  26);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -946,4 +946,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &slow_case);\n-    }\n-\n@@ -1051,7 +1047,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ The object address from the monitor is in object.\n-      ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-      biased_locking_exit(CCR0, object, displaced_header, free_slot);\n-    }\n-\n@@ -1073,1 +1062,1 @@\n-    if (!UseBiasedLocking) { ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor); }\n+    ld(object, BasicObjectLock::obj_offset_in_bytes(), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -109,0 +108,4 @@\n+void MacroAssembler::align_prefix() {\n+  if (is_aligned(offset() + BytesPerInstWord, 64)) { nop(); }\n+}\n+\n@@ -2076,212 +2079,0 @@\n-\/\/ Supports temp2_reg = R0.\n-void MacroAssembler::biased_locking_enter(ConditionRegister cr_reg, Register obj_reg,\n-                                          Register mark_reg, Register temp_reg,\n-                                          Register temp2_reg, Label& done, Label* slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-#ifdef ASSERT\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-#endif\n-\n-  Label cas_label;\n-\n-  \/\/ Branch to done if fast path fails and no slow_case provided.\n-  Label *slow_case_int = (slow_case != NULL) ? slow_case : &done;\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::total_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-\n-  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  bne(cr_reg, cas_label);\n-\n-  load_klass(temp_reg, obj_reg);\n-\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, R16_thread, temp_reg);\n-  xorr(temp_reg, mark_reg, temp_reg);\n-  andr(temp_reg, temp_reg, temp2_reg);\n-  cmpdi(cr_reg, temp_reg, 0);\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::biased_lock_entry_count_addr());\n-    lwzx(mark_reg, temp2_reg);\n-    addi(mark_reg, mark_reg, 1);\n-    stwx(mark_reg, temp2_reg);\n-    \/\/ restore mark_reg\n-    ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-    bind(l);\n-  }\n-  beq(cr_reg, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp2_reg, 0);\n-  bne(cr_reg, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-\n-  int shift_amount = 64 - markWord::epoch_shift;\n-  \/\/ rotate epoch bits to right (little) end and set other bits to 0\n-  \/\/ [ big part | epoch | little part ] -> [ 0..0 | epoch ]\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n-  \/\/ branch if epoch bits are != 0, i.e. they differ, because the epoch has been incremented\n-  bne(CCR0, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n-                                markWord::age_mask_in_place |\n-                                markWord::epoch_mask_in_place));\n-  orr(temp_reg, R16_thread, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-           \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-           \/*where=*\/obj_reg,\n-           MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-           noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::anonymously_biased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  load_klass(temp_reg, obj_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp2_reg, R16_thread, temp2_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  orr(temp_reg, temp2_reg, temp_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-                 noreg, slow_case_int); \/\/ bail out if failed\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (PrintBiasedLockingStatistics) {\n-    load_const(temp2_reg, (address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_klass(temp_reg, obj_reg);\n-  ld(temp_reg, in_bytes(Klass::prototype_header_offset()), temp_reg);\n-  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n-  orr(temp_reg, temp_reg, temp2_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ CmpxchgX sets cr_reg to cmpX(temp2_reg, mark_reg).\n-  cmpxchgd(\/*flag=*\/cr_reg, \/*current_value=*\/temp2_reg,\n-                 \/*compare_value=*\/mark_reg, \/*exchange_value=*\/temp_reg,\n-                 \/*where=*\/obj_reg,\n-                 MacroAssembler::MemBarAcq,\n-                 MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n-  ld(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    Label l;\n-    bne(cr_reg, l);\n-    load_const(temp2_reg, (address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg);\n-    lwzx(temp_reg, temp2_reg);\n-    addi(temp_reg, temp_reg, 1);\n-    stwx(temp_reg, temp2_reg);\n-    bind(l);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit (ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-\n-  ld(temp_reg, 0, mark_addr);\n-  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n-  beq(cr_reg, done);\n-}\n-\n@@ -2698,1 +2489,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2705,1 +2495,1 @@\n-  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -2723,4 +2513,4 @@\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);      \/\/ Reload in transaction, conflicts need to be tracked.\n-  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n-  beq(flag, DONE_LABEL);                                    \/\/ all done if unlocked\n+  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);   \/\/ Reload in transaction, conflicts need to be tracked.\n+  andi(R0, mark_word, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);             \/\/ bits = 01 unlocked\n+  beq(flag, DONE_LABEL);                                 \/\/ all done if unlocked\n@@ -2840,1 +2630,0 @@\n-                                               bool try_bias,\n@@ -2861,4 +2650,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(flag, oop, displaced_header, temp, current_header, cont);\n-  }\n-\n@@ -2967,1 +2752,1 @@\n-                                                 bool try_bias, bool use_rtm) {\n+                                                 bool use_rtm) {\n@@ -2973,4 +2758,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(flag, oop, current_header, cont);\n-  }\n-\n@@ -2979,1 +2760,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -2981,6 +2761,6 @@\n-    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);      \/\/ fetch markword\n-    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n-    bne(flag, L_regular_unlock);                                   \/\/ else RegularLock\n-    tend_();                                                       \/\/ otherwise end...\n-    b(cont);                                                       \/\/ ... and we're done\n+    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);   \/\/ fetch markword\n+    andi(R0, current_header, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                  \/\/ bits = 01 unlocked\n+    bne(flag, L_regular_unlock);                                \/\/ else RegularLock\n+    tend_();                                                    \/\/ otherwise end...\n+    b(cont);                                                    \/\/ ... and we're done\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":16,"deletions":236,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -91,0 +91,10 @@\n+  \/\/ Align prefix opcode to make sure it's not on the last word of a\n+  \/\/ 64-byte block.\n+  \/\/\n+  \/\/ Note: do not call align_prefix() in a .ad file (e.g. ppc.ad).  Instead\n+  \/\/ add ins_alignment(2) to the instruct definition and implement the\n+  \/\/ compute_padding() method of the instruct node to use\n+  \/\/ compute_prefix_padding().  See loadConI32Node::compute_padding() in\n+  \/\/ ppc.ad for an example.\n+  void align_prefix();\n+\n@@ -592,18 +602,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(ConditionRegister cr_reg, Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(ConditionRegister cr_reg, Register mark_addr, Register temp_reg, Label& done);\n-\n@@ -658,1 +650,0 @@\n-                                 bool try_bias = UseBiasedLocking,\n@@ -666,1 +657,1 @@\n-                                   bool try_bias = UseBiasedLocking, bool use_rtm = false);\n+                                   bool use_rtm = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2198,4 +2198,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2277,1 +2273,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -2368,0 +2364,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 26 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 28 : FLOATPRESSURE;\n+}\n+\n@@ -12122,2 +12128,1 @@\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0,\n-                                 UseBiasedLocking && !UseOptoBiasInlining);\n+                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n@@ -12141,1 +12146,0 @@\n-                                 \/*Biased Locking*\/ false,\n@@ -12144,1 +12148,1 @@\n-                                 \/*TM*\/ true, ra_->C->profile_rtm());\n+                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n@@ -12161,1 +12165,0 @@\n-                                   UseBiasedLocking && !UseOptoBiasInlining,\n@@ -12179,1 +12182,1 @@\n-                                   \/*Biased Locking*\/ false, \/*TM*\/ true);\n+                                   \/*RTM*\/ true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2157,8 +2157,0 @@\n-#   ifdef ASSERT\n-    if (UseBiasedLocking) {\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ std(r_box, 0, r_box);\n-    }\n-#   endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3646,0 +3646,4 @@\n+\/\/ For P10 (or later) only\n+#define VALID_B64 0x80\n+#define VB64(x) (VALID_B64 | x)\n+\n@@ -3648,0 +3652,2 @@\n+#define BLK_OFFSETOF(x) (offsetof(constant_block, x))\n+\n@@ -3663,89 +3669,117 @@\n-    static const signed char VEC_ALIGN offsetLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0,   0, PLS, DIG,  UC,  UC,  LC,  LC,\n-      0,   0,   0,   0,   0,   0,   0,   0 ) };\n-\n-    static const signed char VEC_ALIGN offsetLUT_URL_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0,   0, HYP, DIG,  UC,  UC,  LC,  LC,\n-      0,   0,   0,   0,   0,   0,   0,   0 ) };\n-\n-    static const unsigned char VEC_ALIGN maskLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      \/* 0        *\/ (unsigned char)0b10101000,\n-      \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000,\n-      \/* 10       *\/ (unsigned char)0b11110000,\n-      \/* 11       *\/ (unsigned char)0b01010100,\n-      \/* 12 .. 14 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000, (unsigned char)0b01010000,\n-      \/* 15       *\/ (unsigned char)0b01010100 ) };\n-\n-    static const unsigned char VEC_ALIGN maskLUT_URL_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      \/* 0        *\/ (unsigned char)0b10101000,\n-      \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000,\n-      \/* 10       *\/ (unsigned char)0b11110000,\n-      \/* 11 .. 12 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000,\n-      \/* 13       *\/ (unsigned char)0b01010100,\n-      \/* 14       *\/ (unsigned char)0b01010000,\n-      \/* 15       *\/ (unsigned char)0b01110000 ) };\n-\n-    static const unsigned char VEC_ALIGN bitposLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, (unsigned char)0x80,\n-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ) };\n-\n-    static const unsigned char VEC_ALIGN pack_lshift_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2 ) };\n-\n-    static const unsigned char VEC_ALIGN pack_rshift_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0 ) };\n-\n-    \/\/ The first 4 index values are \"don't care\" because\n-    \/\/ we only use the first 12 bytes of the vector,\n-    \/\/ which are decoded from 16 bytes of Base64 characters.\n-    static const unsigned char VEC_ALIGN pack_permute_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-       0, 0, 0, 0,\n-       0,  1,  2,\n-       4,  5,  6,\n-       8,  9, 10,\n-      12, 13, 14 ) };\n-\n-    static const unsigned char VEC_ALIGN p10_pack_permute_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-       0,  0,  0,  0,  7,  6,  5,  4,\n-       3,  2, 15, 14, 13, 12, 11, 10 ) };\n-\n-    \/\/ loop_unrolls needs to be a power of two so that the rounding can be\n-    \/\/ done using a mask.\n-    \/\/\n-    \/\/ The amount of loop unrolling was determined by running a benchmark\n-    \/\/ that decodes a 20k block of Base64 data on a Power9 machine:\n-    \/\/ loop_unrolls = 1 :\n-    \/\/ (min, avg, max) = (108639.215, 110530.479, 110779.920), stdev = 568.437\n-    \/\/ loop_unrolls = 2 :\n-    \/\/ (min, avg, max) = (108259.029, 110174.202, 110399.642), stdev = 561.729\n-    \/\/ loop_unrolls = 4 :\n-    \/\/ (min, avg, max) = (106514.175, 108373.110, 108514.786), stdev = 392.237\n-    \/\/ loop_unrolls = 8 :\n-    \/\/ (min, avg, max) = (106281.283, 108316.668, 108539.953), stdev = 553.938\n-    \/\/ loop_unrolls = 16 :\n-    \/\/ (min, avg, max) = (108580.768, 110631.161, 110766.237), stdev = 430.510\n-    \/\/\n-    \/\/ Comparing only the max values, there's no reason to go past\n-    \/\/ loop_unrolls = 1.  Performance at loop_unrolls = 16 is similar but\n-    \/\/ has the disadvantage of requiring a larger minimum block of data to\n-    \/\/ work with.  A value of 1 gives a minimum of (16 + 12) = 28 bytes\n-    \/\/ before the intrinsic will decode any data.  See the reason for the\n-    \/\/ +12 in the following logic.\n-    const unsigned loop_unrolls = 1;\n-\n-    const unsigned vec_size = 16; \/\/ size of vector registers in bytes\n-    const unsigned block_size = vec_size * loop_unrolls;  \/\/ number of bytes to process in each pass through the loop\n-    const unsigned block_size_shift = exact_log2(block_size);\n+    typedef struct {\n+      signed char offsetLUT_val[16];\n+      signed char offsetLUT_URL_val[16];\n+      unsigned char maskLUT_val[16];\n+      unsigned char maskLUT_URL_val[16];\n+      unsigned char bitposLUT_val[16];\n+      unsigned char table_32_47_val[16];\n+      unsigned char table_32_47_URL_val[16];\n+      unsigned char table_48_63_val[16];\n+      unsigned char table_64_79_val[16];\n+      unsigned char table_80_95_val[16];\n+      unsigned char table_80_95_URL_val[16];\n+      unsigned char table_96_111_val[16];\n+      unsigned char table_112_127_val[16];\n+      unsigned char pack_lshift_val[16];\n+      unsigned char pack_rshift_val[16];\n+      unsigned char pack_permute_val[16];\n+    } constant_block;\n+\n+    static const constant_block VEC_ALIGN const_block = {\n+\n+      .offsetLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0,   0, PLS, DIG,  UC,  UC,  LC,  LC,\n+        0,   0,   0,   0,   0,   0,   0,   0 ) },\n+\n+      .offsetLUT_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0,   0, HYP, DIG,  UC,  UC,  LC,  LC,\n+        0,   0,   0,   0,   0,   0,   0,   0 ) },\n+\n+      .maskLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        \/* 0        *\/ (unsigned char)0b10101000,\n+        \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000,\n+        \/* 10       *\/ (unsigned char)0b11110000,\n+        \/* 11       *\/ (unsigned char)0b01010100,\n+        \/* 12 .. 14 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000, (unsigned char)0b01010000,\n+        \/* 15       *\/ (unsigned char)0b01010100 ) },\n+\n+      .maskLUT_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        \/* 0        *\/ (unsigned char)0b10101000,\n+        \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000,\n+        \/* 10       *\/ (unsigned char)0b11110000,\n+        \/* 11 .. 12 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000,\n+        \/* 13       *\/ (unsigned char)0b01010100,\n+        \/* 14       *\/ (unsigned char)0b01010000,\n+        \/* 15       *\/ (unsigned char)0b01110000 ) },\n+\n+      .bitposLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, (unsigned char)0x80,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ) },\n+\n+      \/\/ In the following table_*_val constants, a 0 value means the\n+      \/\/ character is not in the Base64 character set\n+      .table_32_47_val = {\n+        ARRAY_TO_LXV_ORDER (\n+         \/* space .. '*' = 0 *\/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \/* '+' = 62 *\/ VB64(62), \/* ',' .. '.' = 0 *\/ 0, 0, 0, \/* '\/' = 63 *\/ VB64(63) ) },\n+\n+      .table_32_47_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* space .. ',' = 0 *\/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \/* '-' = 62 *\/ VB64(62), \/* '.' .. '\/' *\/ 0, 0 ) },\n+\n+      .table_48_63_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* '0' .. '9' = 52 .. 61 *\/ VB64(52), VB64(53), VB64(54), VB64(55), VB64(56), VB64(57), VB64(58), VB64(59), VB64(60), VB64(61),\n+         \/* ':' .. '?' = 0 *\/ 0, 0, 0, 0, 0, 0 ) },\n+\n+      .table_64_79_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* '@' = 0 *\/ 0, \/* 'A' .. 'O' = 0 .. 14 *\/ VB64(0), VB64(1), VB64(2), VB64(3), VB64(4), VB64(5), VB64(6), VB64(7), VB64(8),\n+         VB64(9), VB64(10), VB64(11), VB64(12), VB64(13), VB64(14) ) },\n+\n+      .table_80_95_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'P' .. 'Z' = 15 .. 25 *\/ VB64(15), VB64(16), VB64(17), VB64(18), VB64(19), VB64(20), VB64(21), VB64(22),\n+        VB64(23), VB64(24), VB64(25), \/* '[' .. '_' = 0 *\/ 0, 0, 0, 0, 0 ) },\n+\n+      .table_80_95_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'P' .. 'Z' = 15 .. 25 *\/ VB64(15), VB64(16), VB64(17), VB64(18), VB64(19), VB64(20), VB64(21), VB64(22),\n+        VB64(23), VB64(24), VB64(25), \/* '[' .. '^' = 0 *\/ 0, 0, 0, 0, \/* '_' = 63 *\/ VB64(63) ) },\n+\n+      .table_96_111_val = {\n+        ARRAY_TO_LXV_ORDER(\/* '`' = 0 *\/ 0, \/* 'a' .. 'o' = 26 .. 40 *\/ VB64(26), VB64(27), VB64(28), VB64(29), VB64(30), VB64(31),\n+        VB64(32), VB64(33), VB64(34), VB64(35), VB64(36), VB64(37), VB64(38), VB64(39), VB64(40) ) },\n+\n+      .table_112_127_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'p' .. 'z' = 41 .. 51 *\/ VB64(41), VB64(42), VB64(43), VB64(44), VB64(45), VB64(46), VB64(47), VB64(48),\n+        VB64(49), VB64(50), VB64(51), \/* '{' .. DEL = 0 *\/ 0, 0, 0, 0, 0 ) },\n+\n+      .pack_lshift_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2 ) },\n+\n+      .pack_rshift_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0 ) },\n+\n+      \/\/ The first 4 index values are \"don't care\" because\n+      \/\/ we only use the first 12 bytes of the vector,\n+      \/\/ which are decoded from 16 bytes of Base64 characters.\n+      .pack_permute_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         0, 0, 0, 0,\n+         0,  1,  2,\n+         4,  5,  6,\n+         8,  9, 10,\n+        12, 13, 14 ) }\n+    };\n+\n+    const unsigned block_size = 16;  \/\/ number of bytes to process in each pass through the loop\n+    const unsigned block_size_shift = 4;\n@@ -3760,0 +3794,1 @@\n+    Register isMIME = R9_ARG7; \/\/ boolean, if non-zero indicates use of RFC 2045 MIME encoding - not used\n@@ -3777,2 +3812,0 @@\n-    \/\/ P10+\n-    VectorRegister  vec_0x3fs               = VR4; \/\/ safe to reuse pack_rshift's register\n@@ -3788,2 +3821,9 @@\n-    \/\/ Variables for lookup\n-    \/\/ VR\n+    \/\/ P10 (or later) VSR lookup constants\n+    VectorSRegister table_32_47             = VSR0;\n+    VectorSRegister table_48_63             = VSR1;\n+    VectorSRegister table_64_79             = VSR2;\n+    VectorSRegister table_80_95             = VSR3;\n+    VectorSRegister table_96_111            = VSR4;\n+    VectorSRegister table_112_127           = VSR6;\n+\n+    \/\/ Data read in and later converted\n@@ -3791,0 +3831,4 @@\n+    \/\/ Variable for testing Base64 validity\n+    VectorRegister  non_match               = VR10;\n+\n+    \/\/ P9 VR Variables for lookup\n@@ -3794,1 +3838,0 @@\n-    VectorRegister  non_match               = VR10;\n@@ -3796,1 +3839,1 @@\n-    \/\/ VSR\n+    \/\/ P9 VSR lookup variables\n@@ -3801,0 +3844,4 @@\n+    \/\/ P10 (or later) VSR lookup variables\n+    VectorSRegister  xlate_a                = VSR7;\n+    VectorSRegister  xlate_b                = VSR8;\n+\n@@ -3805,1 +3852,1 @@\n-    VectorRegister  gathered                = VR9;  \/\/ reuse offsets's register\n+    VectorRegister  gathered                = VR10; \/\/ reuse non_match's register\n@@ -3807,1 +3854,1 @@\n-    Label not_URL, calculate_size, unrolled_loop_start, unrolled_loop_exit, return_zero;\n+    Label not_URL, calculate_size, loop_start, loop_exit, return_zero;\n@@ -3826,1 +3873,1 @@\n-    \/\/ Load CTR with the number of passes through the unrolled loop\n+    \/\/ Load CTR with the number of passes through the loop\n@@ -3838,12 +3885,5 @@\n-    __ load_const_optimized(const_ptr, (address)&bitposLUT_val, tmp_reg);\n-    __ lxv(bitposLUT, 0, const_ptr);\n-    if (PowerArchitecturePPC64 >= 10) {\n-        __ load_const_optimized(const_ptr, (address)&p10_pack_permute_val, tmp_reg);\n-    } else {\n-        __ load_const_optimized(const_ptr, (address)&pack_rshift_val, tmp_reg);\n-        __ lxv(pack_rshift->to_vsr(), 0, const_ptr);\n-        __ load_const_optimized(const_ptr, (address)&pack_lshift_val, tmp_reg);\n-        __ lxv(pack_lshift->to_vsr(), 0, const_ptr);\n-        __ load_const_optimized(const_ptr, (address)&pack_permute_val, tmp_reg);\n-    }\n-    __ lxv(pack_permute, 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&const_block, tmp_reg);\n+    __ lxv(bitposLUT, BLK_OFFSETOF(bitposLUT_val), const_ptr);\n+    __ lxv(pack_rshift->to_vsr(), BLK_OFFSETOF(pack_rshift_val), const_ptr);\n+    __ lxv(pack_lshift->to_vsr(), BLK_OFFSETOF(pack_lshift_val), const_ptr);\n+    __ lxv(pack_permute, BLK_OFFSETOF(pack_permute_val), const_ptr);\n@@ -3853,1 +3893,0 @@\n-    __ xxspltib(vec_4s->to_vsr(), 4);\n@@ -3855,1 +3894,0 @@\n-    __ xxspltib(vec_0xfs, 0xf);\n@@ -3857,1 +3895,17 @@\n-        __ xxspltib(vec_0x3fs->to_vsr(), 0x3f);\n+      \/\/ Using VALID_B64 for the offsets effectively strips the upper bit\n+      \/\/ of each byte that was selected from the table.  Setting the upper\n+      \/\/ bit gives us a way to distinguish between the 6-bit value of 0\n+      \/\/ from an error code of 0, which will happen if the character is\n+      \/\/ outside the range of the lookup, or is an illegal Base64\n+      \/\/ character, such as %.\n+      __ xxspltib(offsets->to_vsr(), VALID_B64);\n+\n+      __ lxv(table_48_63, BLK_OFFSETOF(table_48_63_val), const_ptr);\n+      __ lxv(table_64_79, BLK_OFFSETOF(table_64_79_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_val), const_ptr);\n+      __ lxv(table_96_111, BLK_OFFSETOF(table_96_111_val), const_ptr);\n+      __ lxv(table_112_127, BLK_OFFSETOF(table_112_127_val), const_ptr);\n+    } else {\n+      __ xxspltib(vec_4s->to_vsr(), 4);\n+      __ xxspltib(vec_0xfs, 0xf);\n+      __ lxv(bitposLUT, BLK_OFFSETOF(bitposLUT_val), const_ptr);\n@@ -3866,6 +3920,9 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_URL_val, tmp_reg);\n-    __ lxv(offsetLUT, 0, const_ptr);\n-    __ load_const_optimized(const_ptr, (address)&maskLUT_URL_val, tmp_reg);\n-    __ lxv(maskLUT, 0, const_ptr);\n-    __ xxspltib(vec_special_case_char->to_vsr(), '_');\n-    __ xxspltib(vec_special_case_offset, (unsigned char)US);\n+    if (PowerArchitecturePPC64 >= 10) {\n+      __ lxv(table_32_47, BLK_OFFSETOF(table_32_47_URL_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_URL_val), const_ptr);\n+    } else {\n+      __ lxv(offsetLUT, BLK_OFFSETOF(offsetLUT_URL_val), const_ptr);\n+      __ lxv(maskLUT, BLK_OFFSETOF(maskLUT_URL_val), const_ptr);\n+      __ xxspltib(vec_special_case_char->to_vsr(), '_');\n+      __ xxspltib(vec_special_case_offset, (unsigned char)US);\n+    }\n@@ -3876,6 +3933,9 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_val, tmp_reg);\n-    __ lxv(offsetLUT, 0, const_ptr);\n-    __ load_const_optimized(const_ptr, (address)&maskLUT_val, tmp_reg);\n-    __ lxv(maskLUT, 0, const_ptr);\n-    __ xxspltib(vec_special_case_char->to_vsr(), '\/');\n-    __ xxspltib(vec_special_case_offset, (unsigned char)SLS);\n+    if (PowerArchitecturePPC64 >= 10) {\n+      __ lxv(table_32_47, BLK_OFFSETOF(table_32_47_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_val), const_ptr);\n+    } else {\n+      __ lxv(offsetLUT, BLK_OFFSETOF(offsetLUT_val), const_ptr);\n+      __ lxv(maskLUT, BLK_OFFSETOF(maskLUT_val), const_ptr);\n+      __ xxspltib(vec_special_case_char->to_vsr(), '\/');\n+      __ xxspltib(vec_special_case_offset, (unsigned char)SLS);\n+    }\n@@ -3892,160 +3952,2 @@\n-    __ bind(unrolled_loop_start);\n-    for (unsigned unroll_cnt=0; unroll_cnt < loop_unrolls; unroll_cnt++) {\n-        \/\/ We can use a static displacement in the load since it's always a\n-        \/\/ multiple of 16, which is a requirement of lxv\/stxv.  This saves\n-        \/\/ an addi instruction.\n-        __ lxv(input->to_vsr(), unroll_cnt * 16, in);\n-        \/\/\n-        \/\/ Lookup\n-        \/\/\n-        \/\/ Isolate the upper 4 bits of each character by shifting it right 4 bits\n-        __ vsrb(higher_nibble, input, vec_4s);\n-        \/\/ Isolate the lower 4 bits by masking\n-        __ xxland(lower_nibble, input->to_vsr(), vec_0xfs);\n-\n-        \/\/ Get the offset (the value to subtract from the byte) by using\n-        \/\/ a lookup table indexed by the upper 4 bits of the character\n-        __ xxperm(offsets->to_vsr(), offsetLUT, higher_nibble->to_vsr());\n-\n-        \/\/ Find out which elements are the special case character (isURL ? '\/' : '-')\n-        __ vcmpequb(eq_special_case_char, input, vec_special_case_char);\n-\n-        \/\/ For each character in the input which is a special case\n-        \/\/ character, replace its offset with one that is special for that\n-        \/\/ character.\n-        __ xxsel(offsets->to_vsr(), offsets->to_vsr(), vec_special_case_offset, eq_special_case_char->to_vsr());\n-\n-        \/\/ Use the lower_nibble to select a mask \"M\" from the lookup table.\n-        __ xxperm(M, maskLUT, lower_nibble);\n-\n-        \/\/ \"bit\" is used to isolate which of the bits in M is relevant.\n-        __ xxperm(bit, bitposLUT, higher_nibble->to_vsr());\n-\n-        \/\/ Each element of non_match correspond to one each of the 16 input\n-        \/\/ characters.  Those elements that become 0x00 after the xxland\n-        \/\/ instuction are invalid Base64 characters.\n-        __ xxland(non_match->to_vsr(), M, bit);\n-\n-        \/\/ Compare each element to zero\n-        \/\/\n-        \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n-        \/\/ Any element comparing equal to zero means there is an error in\n-        \/\/ that element.  Note that the comparison result register\n-        \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n-        __ vcmpequb_(non_match, non_match, vec_0s);\n-        __ bne_predict_not_taken(CCR6, unrolled_loop_exit);\n-\n-        \/\/ The Base64 characters had no errors, so add the offsets\n-        __ vaddubm(input, input, offsets);\n-\n-        \/\/ Pack\n-        \/\/\n-        \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n-        \/\/ binary data, the first line of each of the cells (except for\n-        \/\/ the constants) uses the bit-field nomenclature from the\n-        \/\/ above-linked paper, whereas the second line is more specific\n-        \/\/ about which exact bits are present, and is constructed using the\n-        \/\/ Power ISA 3.x document style, where:\n-        \/\/\n-        \/\/ * The specifier after the colon depicts which bits are there.\n-        \/\/ * The bit numbering is big endian style (bit 0 is the most\n-        \/\/   significant).\n-        \/\/ * || is a concatenate operator.\n-        \/\/ * Strings of 0's are a field of zeros with the shown length, and\n-        \/\/   likewise for strings of 1's.\n-\n-        if (PowerArchitecturePPC64 >= 10) {\n-            \/\/ Note that only e8..e15 are shown here because the extract bit\n-            \/\/ pattern is the same in e0..e7.\n-            \/\/\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-            \/\/ |    Vector     |     e8      |          e9          |         e10          |     e11     |     e12     |         e13          |         e14          |     e15     |\n-            \/\/ |    Element    |             |                      |                      |             |             |                      |                      |             |\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-            \/\/ | after vaddudb |  00hhhhhh   |       00gggggg       |       00ffffff       |  00eeeeee   |  00dddddd   |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n-            \/\/ |               | 00||b5:2..7 | 00||b4:4..7||b5:0..1 | 00||b3:6..7||b4:0..3 | 00||b3:0..5 | 00||b2:2..7 | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ |  after xxbrd  |  00aaaaaa   |       00bbbbbb       |       00cccccc       |  00dddddd   |  00eeeeee   |       00ffffff       |       00gggggg       |  00hhhhhh   |\n-            \/\/ |               | 00||b0:0..5 | 00||b0:6..7||b1:0..3 | 00||b1:4..7||b2:0..1 | 00||b2:2..7 | 00||b3:0..5 | 00||b3:6..7||b4:0..3 | 00||b4:4..7||b5:0..1 | 00||b5:2..7 |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ |   vec_0x3fs   |  00111111   |       00111111       |       00111111       |  00111111   |  00111111   |       00111111       |       00111111       |  00111111   |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ | after vpextd  |  00000000   |       00000000       |       aaaaaabb       |  bbbbcccc   |  ccdddddd   |       eeeeeeff       |       ffffgggg       |  gghhhhhh   |\n-            \/\/ |               |  00000000   |       00000000       |       b0:0..7        |   b1:0..7   |   b2:0..7   |       b3:0..7        |       b4:0..7        |   b5:0..7   |\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-\n-            __ xxbrd(input->to_vsr(), input->to_vsr());\n-            __ vpextd(gathered, input, vec_0x3fs);\n-\n-            \/\/ Final rearrangement of bytes into their correct positions.\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |      Vector      | e0 | e1 | e2 | e3 | e4  | e5  | e6  | e7  | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n-            \/\/ |     Elements     |    |    |    |    |     |     |     |     |    |    |     |     |     |     |     |     |\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |   after vpextd   | 0  | 0  | b6 | b7 | b8  | b9  | b10 | b11 | 0  | 0  | b0  | b1  | b2  | b3  | b4  | b5  |\n-            \/\/ +------------------+----+----+----+----+-----+-----+-----+-----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | p10_pack_permute | 0  | 0  | 0  | 0  |  7  |  6  |  5  |  4  | 3  | 2  | 15  | 14  | 13  | 12  | 11  | 10  |\n-            \/\/ +------------------+----+----+----+----+-----+-----+-----+-----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ |   after xxperm   | 0  | 0  | 0  | 0  | b11 | b10 | b9  | b8  | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-\n-        } else {\n-            \/\/ Note that only e12..e15 are shown here because the shifting\n-            \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n-            \/\/ e0..e3.\n-            \/\/\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n-            \/\/ |       Element        |                 |                      |                      |             |\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n-            \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n-            \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n-            \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n-            \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n-            \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/\n-            \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n-            \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n-            \/\/ but should be:\n-            \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n-            \/\/\n-            __ vslb(l, input, pack_lshift);\n-            \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n-            \/\/ element numbers, discarding element 0.  This means it actually\n-            \/\/ shifts to the right (not left) according to the order of the\n-            \/\/ table above.\n-            __ vslo(l, l, vec_8s);\n-            __ vsrb(r, input, pack_rshift);\n-            __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n-\n-            \/\/ Final rearrangement of bytes into their correct positions.\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n-            \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n-            \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n-            \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ xx bytes are not used to form the final data\n-            \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n-            \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n-            \/\/ overwritten on the next iteration.\n-        }\n-        __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n+    __ bind(loop_start);\n+    __ lxv(input->to_vsr(), 0, in); \/\/ offset=0\n@@ -4053,8 +3955,42 @@\n-        \/\/ We cannot use a static displacement on the store, since it's a\n-        \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n-        \/\/ writes 16 bytes, even though only the first 12 are valid data.\n-        __ stxv(gathered->to_vsr(), 0, out);\n-        __ addi(out, out, 12);\n-    }\n-    __ addi(in, in, 16 * loop_unrolls);\n-    __ bdnz(unrolled_loop_start);\n+    \/\/\n+    \/\/ Lookup\n+    \/\/\n+    if (PowerArchitecturePPC64 >= 10) {\n+      \/\/ Use xxpermx to do a lookup of each Base64 character in the\n+      \/\/ input vector and translate it to a 6-bit value + 0x80.\n+      \/\/ Characters which are not valid Base64 characters will result\n+      \/\/ in a zero in the corresponding byte.\n+      \/\/\n+      \/\/ Note that due to align(32) call above, the xxpermx instructions do\n+      \/\/ not require align_prefix() calls, since the final xxpermx\n+      \/\/ prefix+opcode is at byte 24.\n+      __ xxpermx(xlate_a, table_32_47, table_48_63, input->to_vsr(), 1);    \/\/ offset=4\n+      __ xxpermx(xlate_b, table_64_79, table_80_95, input->to_vsr(), 2);    \/\/ offset=12\n+      __ xxlor(xlate_b, xlate_a, xlate_b);                                  \/\/ offset=20\n+      __ xxpermx(xlate_a, table_96_111, table_112_127, input->to_vsr(), 3); \/\/ offset=24\n+      __ xxlor(input->to_vsr(), xlate_a, xlate_b);\n+      \/\/ Check for non-Base64 characters by comparing each byte to zero.\n+      __ vcmpequb_(non_match, input, vec_0s);\n+    } else {\n+      \/\/ Isolate the upper 4 bits of each character by shifting it right 4 bits\n+      __ vsrb(higher_nibble, input, vec_4s);\n+      \/\/ Isolate the lower 4 bits by masking\n+      __ xxland(lower_nibble, input->to_vsr(), vec_0xfs);\n+\n+      \/\/ Get the offset (the value to subtract from the byte) by using\n+      \/\/ a lookup table indexed by the upper 4 bits of the character\n+      __ xxperm(offsets->to_vsr(), offsetLUT, higher_nibble->to_vsr());\n+\n+      \/\/ Find out which elements are the special case character (isURL ? '\/' : '-')\n+      __ vcmpequb(eq_special_case_char, input, vec_special_case_char);\n+\n+      \/\/ For each character in the input which is a special case\n+      \/\/ character, replace its offset with one that is special for that\n+      \/\/ character.\n+      __ xxsel(offsets->to_vsr(), offsets->to_vsr(), vec_special_case_offset, eq_special_case_char->to_vsr());\n+\n+      \/\/ Use the lower_nibble to select a mask \"M\" from the lookup table.\n+      __ xxperm(M, maskLUT, lower_nibble);\n+\n+      \/\/ \"bit\" is used to isolate which of the bits in M is relevant.\n+      __ xxperm(bit, bitposLUT, higher_nibble->to_vsr());\n@@ -4062,1 +3998,104 @@\n-    __ bind(unrolled_loop_exit);\n+      \/\/ Each element of non_match correspond to one each of the 16 input\n+      \/\/ characters.  Those elements that become 0x00 after the xxland\n+      \/\/ instuction are invalid Base64 characters.\n+      __ xxland(non_match->to_vsr(), M, bit);\n+\n+      \/\/ Compare each element to zero\n+      \/\/\n+      __ vcmpequb_(non_match, non_match, vec_0s);\n+    }\n+    \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n+    \/\/ Any element comparing equal to zero means there is an error in\n+    \/\/ that element.  Note that the comparison result register\n+    \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n+    __ bne_predict_not_taken(CCR6, loop_exit);\n+\n+    \/\/ The Base64 characters had no errors, so add the offsets, which in\n+    \/\/ the case of Power10 is a constant vector of all 0x80's (see earlier\n+    \/\/ comment where the offsets register is loaded).\n+    __ vaddubm(input, input, offsets);\n+\n+    \/\/ Pack\n+    \/\/\n+    \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n+    \/\/ binary data, the first line of each of the cells (except for\n+    \/\/ the constants) uses the bit-field nomenclature from the\n+    \/\/ above-linked paper, whereas the second line is more specific\n+    \/\/ about which exact bits are present, and is constructed using the\n+    \/\/ Power ISA 3.x document style, where:\n+    \/\/\n+    \/\/ * The specifier after the colon depicts which bits are there.\n+    \/\/ * The bit numbering is big endian style (bit 0 is the most\n+    \/\/   significant).\n+    \/\/ * || is a concatenate operator.\n+    \/\/ * Strings of 0's are a field of zeros with the shown length, and\n+    \/\/   likewise for strings of 1's.\n+\n+    \/\/ Note that only e12..e15 are shown here because the shifting\n+    \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n+    \/\/ e0..e3.\n+    \/\/\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n+    \/\/ |       Element        |                 |                      |                      |             |\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n+    \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n+    \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n+    \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n+    \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n+    \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/\n+    \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n+    \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n+    \/\/ but should be:\n+    \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n+    \/\/\n+    __ vslb(l, input, pack_lshift);\n+    \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n+    \/\/ element numbers, discarding element 0.  This means it actually\n+    \/\/ shifts to the right (not left) according to the order of the\n+    \/\/ table above.\n+    __ vslo(l, l, vec_8s);\n+    __ vsrb(r, input, pack_rshift);\n+    __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n+\n+    \/\/ Final rearrangement of bytes into their correct positions.\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n+    \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n+    \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+    \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n+    \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+    \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ xx bytes are not used to form the final data\n+    \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n+    \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n+    \/\/ overwritten on the next iteration.\n+    __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n+\n+    \/\/ We cannot use a static displacement on the store, since it's a\n+    \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n+    \/\/ writes 16 bytes, even though only the first 12 are valid data.\n+    __ stxv(gathered->to_vsr(), 0, out);\n+    __ addi(out, out, 12);\n+    __ addi(in, in, 16);\n+    __ bdnz(loop_start);\n+\n+    __ bind(loop_exit);\n@@ -4190,4 +4229,6 @@\n-\/\/ lower 32 bytes of the lookup operation.  Power10 and beyond can save the\n-\/\/ compare instruction, because the comparison is done within xxpermx\n-\/\/ itself. TODO: use xxpermx,xxpermx,vor on P10 when instruction prefixes are\n-\/\/ available in assembler_ppc.*\n+\/\/ lower 32 bytes of the lookup operation.\n+\/\/\n+\/\/ Note: it's tempting to use a xxpermx,xxpermx,vor sequence here on\n+\/\/ Power10 (or later), but experiments doing so on Power10 yielded a slight\n+\/\/ performance drop, perhaps due to the need for xxpermx instruction\n+\/\/ prefixes.\n@@ -4285,1 +4326,0 @@\n-    #define BLK_OFFSETOF(x) (offsetof(constant_block, x))\n@@ -4308,1 +4348,1 @@\n-    Register num_blocks     = R11; \/\/ number of blocks to be processed by the unrolled loop\n+    Register num_blocks     = R11; \/\/ number of blocks to be processed by the loop\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":340,"deletions":300,"binary":false,"changes":640,"status":"modified"},{"patch":"@@ -3796,5 +3796,1 @@\n-    if (UseBiasedLocking) {\n-      __ ld(Rscratch, in_bytes(Klass::prototype_header_offset()), RinstanceKlass);\n-    } else {\n-      __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n-    }\n+    __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,5 +381,1 @@\n-    \/\/ If CPU or OS do not support TM:\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n+    \/\/ If CPU or OS do not support RTM:\n@@ -402,2 +398,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -547,21 +541,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention. With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -96,3 +96,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -457,2 +457,4 @@\n-  __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n-  __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  if (PrintC1Statistics) {\n+    __ load_const_optimized(Z_R1_scratch, (address)&Runtime1::_arraycopy_slowcase_cnt);\n+    __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -882,1 +882,1 @@\n-                            CodeEmitInfo* info, bool wide, bool unaligned) {\n+                            CodeEmitInfo* info, bool wide) {\n@@ -1082,1 +1082,1 @@\n-                            bool wide, bool unaligned) {\n+                            bool wide) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -100,4 +99,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(obj, hdr, Z_R1_scratch, Z_R0_scratch, done, &slow_case);\n-  }\n-\n@@ -113,7 +108,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Unimplemented();\n-#if 0\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-#endif\n-  }\n@@ -153,6 +141,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -163,4 +145,2 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ Load object.\n-    z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ Load object.\n+  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n@@ -196,7 +176,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1);\n-    z_lg(t1, Address(klass, Klass::prototype_header_offset()));\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t.\n-    load_const_optimized(t1, (intx)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t.\n+  load_const_optimized(t1, (intx)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-define_pd_global(intx, FLOATPRESSURE,                15);\n@@ -50,1 +49,0 @@\n-define_pd_global(intx, INTPRESSURE,                  10); \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1008,4 +1007,0 @@\n-  if (UseBiasedLocking) {\n-    biased_locking_enter(object, displaced_header, Z_R1, Z_R0, done, &slow_case);\n-  }\n-\n@@ -1119,6 +1114,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ The object address from the monitor is in object.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    biased_locking_exit(object, displaced_header, done);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3131,188 +3130,1 @@\n-\/\/ Semantics are dependent on the slow_case label:\n-\/\/   If the slow_case label is not NULL, failure to biased-lock the object\n-\/\/   transfers control to the location of the slow_case label. If the\n-\/\/   object could be biased-locked, control is transferred to the done label.\n-\/\/   The condition code is unpredictable.\n-\/\/\n-\/\/   If the slow_case label is NULL, failure to biased-lock the object results\n-\/\/   in a transfer of control to the done label with a condition code of not_equal.\n-\/\/   If the biased-lock could be successfully obtained, control is transfered to\n-\/\/   the done label with a condition code of equal.\n-\/\/   It is mandatory to react on the condition code At the done label.\n-\/\/\n-void MacroAssembler::biased_locking_enter(Register  obj_reg,\n-                                          Register  mark_reg,\n-                                          Register  temp_reg,\n-                                          Register  temp2_reg,    \/\/ May be Z_RO!\n-                                          Label    &done,\n-                                          Label    *slow_case) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);\n-\n-  Label cas_label; \/\/ Try, if implemented, CAS locking. Fall thru to slow path otherwise.\n-\n-  BLOCK_COMMENT(\"biased_locking_enter {\");\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid.\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits.\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n-         \"biased locking makes assumptions about bit layout\");\n-  z_lr(temp_reg, mark_reg);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_brne(cas_label);  \/\/ Try cas if object is not biased, i.e. cannot be biased locked.\n-\n-  load_prototype_header(temp_reg, obj_reg);\n-  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n-\n-  z_ogr(temp_reg, Z_thread);\n-  z_xgr(temp_reg, mark_reg);\n-  z_ngr(temp_reg, temp2_reg);\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);\n-    \/\/ Restore mark_reg.\n-    z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);\n-  }\n-  branch_optimized(Assembler::bcondEqual, done);  \/\/ Biased lock obtained, return success.\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-  Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n-  z_brnaz(try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n-  z_brnaz(try_rebias);\n-\n-  \/\/----------------------------------------------------------------------------\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n-         markWord::epoch_mask_in_place);\n-  z_lgr(temp_reg, Z_thread);\n-  z_llgfr(mark_reg, mark_reg);\n-  z_ogr(temp_reg, mark_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),\n-                         temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case); \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  branch_optimized(Assembler::bcondAlways, done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-\n-  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-  load_prototype_header(temp_reg, obj_reg);\n-  z_llgfr(mark_reg, mark_reg);\n-\n-  z_ogr(temp_reg, Z_thread);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-\n-  if (PrintBiasedLockingStatistics) {\n-    increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-  if (slow_case != NULL) {\n-    branch_optimized(Assembler::bcondNotEqual, *slow_case);  \/\/ Biased lock not obtained, need to go the long way.\n-  }\n-  z_bru(done);           \/\/ Biased lock status given in condition code.\n-\n-  \/\/----------------------------------------------------------------------------\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  load_prototype_header(temp_reg, obj_reg);\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  z_csg(mark_reg, temp_reg, 0, obj_reg);\n-\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (PrintBiasedLockingStatistics) {\n-    \/\/ z_cgr(mark_reg, temp2_reg);\n-    increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);\n-  }\n-\n-  bind(cas_label);\n-  BLOCK_COMMENT(\"} biased_locking_enter\");\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label& done) {\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  BLOCK_COMMENT(\"biased_locking_exit {\");\n-\n-  z_lg(temp_reg, 0, mark_addr);\n-  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n-\n-  z_chi(temp_reg, markWord::biased_lock_pattern);\n-  z_bre(done);\n-  BLOCK_COMMENT(\"} biased_locking_exit\");\n-}\n-\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3337,4 +3149,0 @@\n-  if (try_bias) {\n-    biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);\n-  }\n-\n@@ -3405,1 +3213,1 @@\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {\n+void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n@@ -3415,4 +3223,0 @@\n-  if (try_bias) {\n-    biased_locking_exit(oop, currentHeader, done);\n-  }\n-\n@@ -3836,6 +3640,0 @@\n-void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {\n-  assert_different_registers(Rheader, Rsrc_oop);\n-  load_klass(Rheader, Rsrc_oop);\n-  z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":204,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -721,20 +721,3 @@\n-  \/\/ Biased locking support\n-  \/\/ Upon entry,obj_reg must contain the target object, and mark_reg\n-  \/\/ must contain the target object's header.\n-  \/\/ Destroys mark_reg if an attempt is made to bias an anonymously\n-  \/\/ biased lock. In this case a failure will go either to the slow\n-  \/\/ case or fall through with the notEqual condition code set with\n-  \/\/ the expectation that the slow case in the runtime will be called.\n-  \/\/ In the fall-through case where the CAS-based lock is done,\n-  \/\/ mark_reg is not destroyed.\n-  void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,\n-                            Register temp2_reg, Label& done, Label* slow_case = NULL);\n-  \/\/ Upon entry, the base register of mark_addr must contain the oop.\n-  \/\/ Destroys temp_reg.\n-  \/\/ If allow_delay_slot_filling is set to true, the next instruction\n-  \/\/ emitted after this one will go in an annulled delay slot if the\n-  \/\/ biased locking exit case failed.\n-  void biased_locking_exit(Register mark_addr, Register temp_reg, Label& done);\n-\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias = UseBiasedLocking);\n+\n+  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n+  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n@@ -785,1 +768,0 @@\n-  void load_prototype_header(Register Rheader, Register Rsrc_oop);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1557,4 +1557,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1612,1 +1608,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1668,0 +1664,11 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n+  return (INTPRESSURE == -1) ? 10 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 15 : FLOATPRESSURE;\n+}\n+\n@@ -9812,2 +9819,1 @@\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                             UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n@@ -9821,1 +9827,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);  \/\/ emitted code depends on UseBiasedLocking being on\/off.\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n@@ -9823,2 +9829,1 @@\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                               UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1876,7 +1876,0 @@\n-#ifdef ASSERT\n-    if (UseBiasedLocking)\n-      \/\/ Making the box point to itself will make it clear it went unused\n-      \/\/ but also be obviously invalid.\n-      __ z_stg(r_box, 0, r_box);\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3815,8 +3815,2 @@\n-    if (UseBiasedLocking) {\n-      Register prototype = RobjectFields;\n-      __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));\n-      __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));\n-    } else {\n-      __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n-                     (long)markWord::prototype().value());\n-    }\n+    __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n+                   (long)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -3761,0 +3760,9 @@\n+void Assembler::vpermb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8D);\n+  emit_operand(dst, src);\n+}\n+\n@@ -3833,0 +3841,16 @@\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n+\n+void Assembler::evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), ctl->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x83, (unsigned char)(0xC0 | encode));\n+}\n+\n@@ -4131,0 +4155,9 @@\n+void Assembler::vpmaskmovd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert((VM_Version::supports_avx2() && vector_len == AVX_256bit), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8C);\n+  emit_operand(dst, src);\n+}\n+\n@@ -4552,0 +4585,9 @@\n+void Assembler::vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+       vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+       vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = simd_prefix_and_encode(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x04, (0xC0 | encode));\n+}\n+\n@@ -4860,0 +4902,9 @@\n+void Assembler::evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x26, (0xC0 | encode));\n+}\n+\n@@ -6542,0 +6593,7 @@\n+void Assembler::vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xD8, (0xC0 | encode));\n+}\n+\n@@ -6633,0 +6691,9 @@\n+void Assembler::vpmulhuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert((vector_len == AVX_128bit && VM_Version::supports_avx()) ||\n+         (vector_len == AVX_256bit && VM_Version::supports_avx2()) ||\n+         (vector_len == AVX_512bit && VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE4, (0xC0 | encode));\n+}\n+\n@@ -7405,0 +7472,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -7422,0 +7493,1 @@\n+PRAGMA_DIAG_POP\n@@ -9407,0 +9479,7 @@\n+void Assembler::shrxl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class BiasedLockingCounters;\n-\n@@ -1693,0 +1691,1 @@\n+  void vpermb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -1702,0 +1701,2 @@\n+  void evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n@@ -1750,0 +1751,1 @@\n+  void vpmaskmovd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -1815,0 +1817,2 @@\n+  void vpmaddubsw(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+\n@@ -1882,0 +1886,2 @@\n+  void evptestmb(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2143,0 +2149,1 @@\n+  void shrxl(Register dst, Register src1, Register src2);\n@@ -2247,0 +2254,1 @@\n+  void vpsubusb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2267,0 +2275,1 @@\n+  void vpmulhuw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -546,1 +546,3 @@\n-  __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  if (PrintC1Statistics) {\n+    __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool \/* unaligned *\/) {\n+void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n@@ -1181,1 +1181,1 @@\n-void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool \/* unaligned *\/) {\n+void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide) {\n@@ -3515,4 +3515,0 @@\n-    Register scratch = noreg;\n-    if (UseBiasedLocking) {\n-      scratch = op->scratch_opr()->as_register();\n-    }\n@@ -3521,1 +3517,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -291,5 +291,0 @@\n-  \/\/ Need a scratch register for biased locking on x86\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (UseBiasedLocking) {\n-    scratch = new_register(T_INT);\n-  }\n@@ -304,1 +299,1 @@\n-  monitor_enter(obj.result(), lock, syncTempOpr(), scratch,\n+  monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -41,1 +40,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register scratch, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n@@ -64,5 +63,0 @@\n-  if (UseBiasedLocking) {\n-    assert(scratch != noreg, \"should have scratch register at this point\");\n-    biased_locking_enter(disp_hdr, obj, hdr, scratch, rklass_decode_tmp, false, done, &slow_case);\n-  }\n-\n@@ -81,4 +75,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)BiasedLocking::fast_path_entry_count_addr()));\n-  }\n@@ -119,6 +109,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-    biased_locking_exit(obj, hdr, done);\n-  }\n-\n@@ -131,4 +115,3 @@\n-  if (!UseBiasedLocking) {\n-    \/\/ load object\n-    movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n-  }\n+  \/\/ load object\n+  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));\n+\n@@ -162,8 +145,2 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  \/\/ This assumes that all prototype bits fit in an int32_t\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  \/\/ scratch : scratch register, contents destroyed\n@@ -54,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register scratch, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -321,1 +321,5 @@\n-\n+\/\/\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -421,0 +425,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -237,1 +236,0 @@\n-  assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -247,1 +245,1 @@\n-  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n@@ -262,2 +260,2 @@\n-  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);         \/\/ bits = 01 unlocked\n@@ -450,1 +448,0 @@\n-                                 BiasedLockingCounters* counters,\n@@ -465,4 +462,0 @@\n-  if (counters != NULL) {\n-    atomic_incl(ExternalAddress((address)counters->total_entry_count_addr()), scrReg);\n-  }\n-\n@@ -476,3 +469,0 @@\n-  \/\/ * biased\n-  \/\/    -- by Self\n-  \/\/    -- by other\n@@ -496,10 +486,0 @@\n-  \/\/ it's stack-locked, biased or neutral\n-  \/\/ TODO: optimize away redundant LDs of obj->mark and improve the markword triage\n-  \/\/ order to reduce the number of conditional branches in the most common cases.\n-  \/\/ Beware -- there's a subtle invariant that fetch of the markword\n-  \/\/ at [FETCH], below, will never observe a biased encoding (*101b).\n-  \/\/ If this invariant is not held we risk exclusion (safety) failure.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_enter(boxReg, objReg, tmpReg, scrReg, cx1Reg, false, DONE_LABEL, NULL, counters);\n-  }\n-\n@@ -515,1 +495,1 @@\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n@@ -523,4 +503,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -536,4 +512,0 @@\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::equal,\n-               ExternalAddress((address)counters->fast_path_entry_count_addr()));\n-  }\n@@ -662,6 +634,0 @@\n-  \/\/ Critically, the biased locking test must have precedence over\n-  \/\/ and appear before the (box->dhw == 0) recursive stack-lock test.\n-  if (UseBiasedLocking && !UseOptoBiasInlining) {\n-    biased_locking_exit(objReg, tmpReg, DONE_LABEL);\n-  }\n-\n@@ -670,1 +636,0 @@\n-    assert(!UseBiasedLocking, \"Biased locking is not supported with RTM locking\");\n@@ -673,2 +638,2 @@\n-    andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n-    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+    andptr(tmpReg, markWord::lock_mask_in_place);                     \/\/ look at 2 lock bits\n+    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 01 unlocked\n@@ -741,1 +706,1 @@\n-  \/\/ It's not inflated and it's not recursively stack-locked and it's not biased.\n+  \/\/ It's not inflated and it's not recursively stack-locked.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":7,"deletions":42,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-                 BiasedLockingCounters* counters,\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 13);\n-define_pd_global(intx,  FLOATPRESSURE,               14);\n@@ -61,2 +59,0 @@\n-define_pd_global(intx,  INTPRESSURE,                 6);\n-define_pd_global(intx,  FLOATPRESSURE,               6);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -230,0 +230,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -243,0 +247,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-                               jth->get_thread_name(), callers_rsp, nm->verified_entry_point());\n+                               jth->name(), callers_rsp, nm->verified_entry_point());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -847,1 +847,1 @@\n-    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/, false \/*unaligned*\/);\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false \/*wide*\/);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -543,0 +547,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1208,2 +1207,1 @@\n-    const Register tmp_reg = rbx; \/\/ Will be passed to biased_locking_enter to avoid a\n-                                  \/\/ problematic case where tmp_reg = no_reg.\n+    const Register tmp_reg = rbx;\n@@ -1230,4 +1228,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);\n-    }\n-\n@@ -1248,4 +1242,0 @@\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1288,5 +1278,0 @@\n-\n-    if (PrintBiasedLockingStatistics) {\n-      cond_inc32(Assembler::zero,\n-                 ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));\n-    }\n@@ -1344,4 +1329,0 @@\n-    if (UseBiasedLocking) {\n-      biased_locking_exit(obj_reg, header_reg, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1283,194 +1282,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          Register tmp_reg2,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert(swap_reg == rax, \"swap_reg must be rax for cmpxchgq\");\n-  assert(tmp_reg != noreg, \"tmp_reg must be supplied\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  NOT_LP64( Address saved_mark_addr(lock_reg, 0); )\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL) {\n-    counters = BiasedLocking::counters();\n-  }\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    movptr(swap_reg, mark_addr);\n-  }\n-  movptr(tmp_reg, swap_reg);\n-  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::notEqual, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-#ifndef _LP64\n-  \/\/ Note that because there is no current thread register on x86_32 we\n-  \/\/ need to store off the mark word we read out of the object to\n-  \/\/ avoid reloading it and needing to recheck invariants below. This\n-  \/\/ store is unfortunate but it makes the overall code shorter and\n-  \/\/ simpler.\n-  movptr(saved_mark_addr, swap_reg);\n-#endif\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-  xorptr(tmp_reg, swap_reg);\n-  Register header_reg = tmp_reg;\n-#else\n-  xorptr(tmp_reg, swap_reg);\n-  get_thread(swap_reg);\n-  xorptr(swap_reg, tmp_reg);\n-  Register header_reg = swap_reg;\n-#endif\n-  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->biased_lock_entry_count_addr()));\n-  }\n-  jcc(Assembler::equal, done);\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  testptr(header_reg, markWord::biased_lock_mask_in_place);\n-  jcc(Assembler::notZero, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  testptr(header_reg, markWord::epoch_mask_in_place);\n-  jccb(Assembler::notZero, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  andptr(swap_reg,\n-         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-#ifdef _LP64\n-  movptr(tmp_reg, swap_reg);\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(tmp_reg);\n-  orptr(tmp_reg, swap_reg);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, this means that\n-  \/\/ another thread succeeded in biasing it toward itself and we\n-  \/\/ need to revoke that bias. The revocation will occur in the\n-  \/\/ interpreter runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->anonymously_biased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-#ifdef _LP64\n-  orptr(tmp_reg, r15_thread);\n-#else\n-  get_thread(swap_reg);\n-  orptr(tmp_reg, swap_reg);\n-  movptr(swap_reg, saved_mark_addr);\n-#endif\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ If the biasing toward our thread failed, then another thread\n-  \/\/ succeeded in biasing it toward itself and we need to revoke that\n-  \/\/ bias. The revocation will occur in the runtime in the slow case.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->rebiased_lock_entry_count_addr()));\n-  }\n-  if (slow_case != NULL) {\n-    jcc(Assembler::notZero, *slow_case);\n-  }\n-  jmp(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  NOT_LP64( movptr(swap_reg, saved_mark_addr); )\n-  load_prototype_header(tmp_reg, obj_reg, tmp_reg2);\n-  lock();\n-  cmpxchgptr(tmp_reg, mark_addr); \/\/ compare tmp_reg and swap_reg\n-  \/\/ Fall through to the normal CAS-based lock, because no matter what\n-  \/\/ the result of the above CAS, some thread must have succeeded in\n-  \/\/ removing the bias bit from the object's header.\n-  if (counters != NULL) {\n-    cond_inc32(Assembler::zero,\n-               ExternalAddress((address) counters->revoked_lock_entry_count_addr()));\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markWord::biased_lock_pattern);\n-  jcc(Assembler::equal, done);\n-}\n-\n@@ -4735,5 +4540,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {\n-  load_klass(dst, src, tmp);\n-  movptr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":200,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -359,2 +359,0 @@\n-  void load_prototype_header(Register dst, Register src, Register tmp);\n-\n@@ -676,15 +674,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg must be rax, and is killed.\n-  \/\/ tmp_reg is optional. If it is supplied (i.e., != noreg) it will\n-  \/\/ be killed; if not supplied, push\/pop will be used internally to\n-  \/\/ allocate a temporary (inefficient, avoid if possible).\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            Register tmp_reg2, bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ Check if biased and fall through to runtime if so\n-    __ testptr(result, markWord::biased_lock_bit_in_place);\n-    __ jcc(Assembler::notZero, slowCase);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1826,5 +1826,0 @@\n-    if (UseBiasedLocking) {\n-      \/\/ Note that oop_handle_reg is trashed during this call\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1863,5 +1858,0 @@\n-\n-    if (UseBiasedLocking) {\n-      \/\/ Re-fetch oop_handle_reg as we trashed it above\n-      __ movptr(oop_handle_reg, Address(rsp, wordSize));\n-    }\n@@ -1996,4 +1986,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, rbx, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -363,0 +367,1 @@\n+PRAGMA_DIAG_POP\n@@ -2073,4 +2078,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -2227,5 +2228,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5290,4 +5290,4 @@\n-  \/\/base64 character set\n-  address base64_charset_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64_charset\");\n+  address base64_shuffle_addr()\n+  {\n+    __ align(64, (unsigned long long)__ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"shuffle_base64\");\n@@ -5295,32 +5295,10 @@\n-    __ emit_data64(0x0000004200000041, relocInfo::none);\n-    __ emit_data64(0x0000004400000043, relocInfo::none);\n-    __ emit_data64(0x0000004600000045, relocInfo::none);\n-    __ emit_data64(0x0000004800000047, relocInfo::none);\n-    __ emit_data64(0x0000004a00000049, relocInfo::none);\n-    __ emit_data64(0x0000004c0000004b, relocInfo::none);\n-    __ emit_data64(0x0000004e0000004d, relocInfo::none);\n-    __ emit_data64(0x000000500000004f, relocInfo::none);\n-    __ emit_data64(0x0000005200000051, relocInfo::none);\n-    __ emit_data64(0x0000005400000053, relocInfo::none);\n-    __ emit_data64(0x0000005600000055, relocInfo::none);\n-    __ emit_data64(0x0000005800000057, relocInfo::none);\n-    __ emit_data64(0x0000005a00000059, relocInfo::none);\n-    __ emit_data64(0x0000006200000061, relocInfo::none);\n-    __ emit_data64(0x0000006400000063, relocInfo::none);\n-    __ emit_data64(0x0000006600000065, relocInfo::none);\n-    __ emit_data64(0x0000006800000067, relocInfo::none);\n-    __ emit_data64(0x0000006a00000069, relocInfo::none);\n-    __ emit_data64(0x0000006c0000006b, relocInfo::none);\n-    __ emit_data64(0x0000006e0000006d, relocInfo::none);\n-    __ emit_data64(0x000000700000006f, relocInfo::none);\n-    __ emit_data64(0x0000007200000071, relocInfo::none);\n-    __ emit_data64(0x0000007400000073, relocInfo::none);\n-    __ emit_data64(0x0000007600000075, relocInfo::none);\n-    __ emit_data64(0x0000007800000077, relocInfo::none);\n-    __ emit_data64(0x0000007a00000079, relocInfo::none);\n-    __ emit_data64(0x0000003100000030, relocInfo::none);\n-    __ emit_data64(0x0000003300000032, relocInfo::none);\n-    __ emit_data64(0x0000003500000034, relocInfo::none);\n-    __ emit_data64(0x0000003700000036, relocInfo::none);\n-    __ emit_data64(0x0000003900000038, relocInfo::none);\n-    __ emit_data64(0x0000002f0000002b, relocInfo::none);\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0405030401020001, relocInfo::none);\n+    __ emit_data64(0x0a0b090a07080607, relocInfo::none);\n+    __ emit_data64(0x10110f100d0e0c0d, relocInfo::none);\n+    __ emit_data64(0x1617151613141213, relocInfo::none);\n+    __ emit_data64(0x1c1d1b1c191a1819, relocInfo::none);\n+    __ emit_data64(0x222321221f201e1f, relocInfo::none);\n+    __ emit_data64(0x2829272825262425, relocInfo::none);\n+    __ emit_data64(0x2e2f2d2e2b2c2a2b, relocInfo::none);\n@@ -5330,4 +5308,4 @@\n-  \/\/base64 url character set\n-  address base64url_charset_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"base64url_charset\");\n+  address base64_avx2_shuffle_addr()\n+  {\n+    __ align(32);\n+    StubCodeMark mark(this, \"StubRoutines\", \"avx2_shuffle_base64\");\n@@ -5335,32 +5313,6 @@\n-    __ emit_data64(0x0000004200000041, relocInfo::none);\n-    __ emit_data64(0x0000004400000043, relocInfo::none);\n-    __ emit_data64(0x0000004600000045, relocInfo::none);\n-    __ emit_data64(0x0000004800000047, relocInfo::none);\n-    __ emit_data64(0x0000004a00000049, relocInfo::none);\n-    __ emit_data64(0x0000004c0000004b, relocInfo::none);\n-    __ emit_data64(0x0000004e0000004d, relocInfo::none);\n-    __ emit_data64(0x000000500000004f, relocInfo::none);\n-    __ emit_data64(0x0000005200000051, relocInfo::none);\n-    __ emit_data64(0x0000005400000053, relocInfo::none);\n-    __ emit_data64(0x0000005600000055, relocInfo::none);\n-    __ emit_data64(0x0000005800000057, relocInfo::none);\n-    __ emit_data64(0x0000005a00000059, relocInfo::none);\n-    __ emit_data64(0x0000006200000061, relocInfo::none);\n-    __ emit_data64(0x0000006400000063, relocInfo::none);\n-    __ emit_data64(0x0000006600000065, relocInfo::none);\n-    __ emit_data64(0x0000006800000067, relocInfo::none);\n-    __ emit_data64(0x0000006a00000069, relocInfo::none);\n-    __ emit_data64(0x0000006c0000006b, relocInfo::none);\n-    __ emit_data64(0x0000006e0000006d, relocInfo::none);\n-    __ emit_data64(0x000000700000006f, relocInfo::none);\n-    __ emit_data64(0x0000007200000071, relocInfo::none);\n-    __ emit_data64(0x0000007400000073, relocInfo::none);\n-    __ emit_data64(0x0000007600000075, relocInfo::none);\n-    __ emit_data64(0x0000007800000077, relocInfo::none);\n-    __ emit_data64(0x0000007a00000079, relocInfo::none);\n-    __ emit_data64(0x0000003100000030, relocInfo::none);\n-    __ emit_data64(0x0000003300000032, relocInfo::none);\n-    __ emit_data64(0x0000003500000034, relocInfo::none);\n-    __ emit_data64(0x0000003700000036, relocInfo::none);\n-    __ emit_data64(0x0000003900000038, relocInfo::none);\n-    __ emit_data64(0x0000005f0000002d, relocInfo::none);\n+    __ emit_data64(0x0809070805060405, relocInfo::none);\n+    __ emit_data64(0x0e0f0d0e0b0c0a0b, relocInfo::none);\n+    __ emit_data64(0x0405030401020001, relocInfo::none);\n+    __ emit_data64(0x0a0b090a07080607, relocInfo::none);\n+    return start;\n+  }\n@@ -5368,0 +5320,9 @@\n+  address base64_avx2_input_mask_addr()\n+  {\n+    __ align(32);\n+    StubCodeMark mark(this, \"StubRoutines\", \"avx2_input_mask_base64\");\n+    address start = __ pc();\n+    __ emit_data64(0x8000000000000000, relocInfo::none);\n+    __ emit_data64(0x8000000080000000, relocInfo::none);\n+    __ emit_data64(0x8000000080000000, relocInfo::none);\n+    __ emit_data64(0x8000000080000000, relocInfo::none);\n@@ -5371,3 +5332,4 @@\n-  address base64_bswap_mask_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"bswap_mask_base64\");\n+  address base64_avx2_lut_addr()\n+  {\n+    __ align(32);\n+    StubCodeMark mark(this, \"StubRoutines\", \"avx2_lut_base64\");\n@@ -5375,8 +5337,12 @@\n-    __ emit_data64(0x0504038002010080, relocInfo::none);\n-    __ emit_data64(0x0b0a098008070680, relocInfo::none);\n-    __ emit_data64(0x0908078006050480, relocInfo::none);\n-    __ emit_data64(0x0f0e0d800c0b0a80, relocInfo::none);\n-    __ emit_data64(0x0605048003020180, relocInfo::none);\n-    __ emit_data64(0x0c0b0a8009080780, relocInfo::none);\n-    __ emit_data64(0x0504038002010080, relocInfo::none);\n-    __ emit_data64(0x0b0a098008070680, relocInfo::none);\n+    __ emit_data64(0xfcfcfcfcfcfc4741, relocInfo::none);\n+    __ emit_data64(0x0000f0edfcfcfcfc, relocInfo::none);\n+    __ emit_data64(0xfcfcfcfcfcfc4741, relocInfo::none);\n+    __ emit_data64(0x0000f0edfcfcfcfc, relocInfo::none);\n+\n+    \/\/ URL LUT\n+    __ emit_data64(0xfcfcfcfcfcfc4741, relocInfo::none);\n+    __ emit_data64(0x000020effcfcfcfc, relocInfo::none);\n+    __ emit_data64(0xfcfcfcfcfcfc4741, relocInfo::none);\n+    __ emit_data64(0x000020effcfcfcfc, relocInfo::none);\n+    return start;\n+  }\n@@ -5384,0 +5350,24 @@\n+  address base64_encoding_table_addr()\n+  {\n+    __ align(64, (unsigned long long)__ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"encoding_table_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0, \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x4847464544434241, relocInfo::none);\n+    __ emit_data64(0x504f4e4d4c4b4a49, relocInfo::none);\n+    __ emit_data64(0x5857565554535251, relocInfo::none);\n+    __ emit_data64(0x6665646362615a59, relocInfo::none);\n+    __ emit_data64(0x6e6d6c6b6a696867, relocInfo::none);\n+    __ emit_data64(0x767574737271706f, relocInfo::none);\n+    __ emit_data64(0x333231307a797877, relocInfo::none);\n+    __ emit_data64(0x2f2b393837363534, relocInfo::none);\n+\n+    \/\/ URL table\n+    __ emit_data64(0x4847464544434241, relocInfo::none);\n+    __ emit_data64(0x504f4e4d4c4b4a49, relocInfo::none);\n+    __ emit_data64(0x5857565554535251, relocInfo::none);\n+    __ emit_data64(0x6665646362615a59, relocInfo::none);\n+    __ emit_data64(0x6e6d6c6b6a696867, relocInfo::none);\n+    __ emit_data64(0x767574737271706f, relocInfo::none);\n+    __ emit_data64(0x333231307a797877, relocInfo::none);\n+    __ emit_data64(0x5f2d393837363534, relocInfo::none);\n@@ -5387,1 +5377,6 @@\n-  address base64_right_shift_mask_addr() {\n+  \/\/ Code for generating Base64 encoding.\n+  \/\/ Intrinsic function prototype in Base64.java:\n+  \/\/ private void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp,\n+  \/\/ boolean isURL) {\n+  address generate_base64_encodeBlock()\n+  {\n@@ -5389,1 +5384,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"right_shift_mask\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"implEncode\");\n@@ -5391,8 +5386,360 @@\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n-    __ emit_data64(0x0006000400020000, relocInfo::none);\n+    __ enter();\n+\n+    \/\/ Save callee-saved registers before using them\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+\n+    \/\/ arguments\n+    const Register source = c_rarg0;       \/\/ Source Array\n+    const Register start_offset = c_rarg1; \/\/ start offset\n+    const Register end_offset = c_rarg2;   \/\/ end offset\n+    const Register dest = c_rarg3;   \/\/ destination array\n+\n+#ifndef _WIN64\n+    const Register dp = c_rarg4;    \/\/ Position for writing to dest array\n+    const Register isURL = c_rarg5; \/\/ Base64 or URL character set\n+#else\n+    const Address dp_mem(rbp, 6 * wordSize); \/\/ length is on stack on Win64\n+    const Address isURL_mem(rbp, 7 * wordSize);\n+    const Register isURL = r10; \/\/ pick the volatile windows register\n+    const Register dp = r12;\n+    __ movl(dp, dp_mem);\n+    __ movl(isURL, isURL_mem);\n+#endif\n+\n+    const Register length = r14;\n+    const Register encode_table = r13;\n+    Label L_process3, L_exit, L_processdata, L_vbmiLoop, L_not512, L_32byteLoop;\n+\n+    \/\/ calculate length from offsets\n+    __ movl(length, end_offset);\n+    __ subl(length, start_offset);\n+    __ cmpl(length, 0);\n+    __ jcc(Assembler::lessEqual, L_exit);\n+\n+    \/\/ Code for 512-bit VBMI encoding.  Encodes 48 input bytes into 64\n+    \/\/ output bytes. We read 64 input bytes and ignore the last 16, so be\n+    \/\/ sure not to read past the end of the input buffer.\n+    if (VM_Version::supports_avx512_vbmi()) {\n+      __ cmpl(length, 64); \/\/ Do not overrun input buffer.\n+      __ jcc(Assembler::below, L_not512);\n+\n+      __ shll(isURL, 6); \/\/ index into decode table based on isURL\n+      __ lea(encode_table, ExternalAddress(StubRoutines::x86::base64_encoding_table_addr()));\n+      __ addptr(encode_table, isURL);\n+      __ shrl(isURL, 6); \/\/ restore isURL\n+\n+      __ mov64(rax, 0x3036242a1016040aull); \/\/ Shifts\n+      __ evmovdquq(xmm3, ExternalAddress(StubRoutines::x86::base64_shuffle_addr()), Assembler::AVX_512bit, r15);\n+      __ evmovdquq(xmm2, Address(encode_table, 0), Assembler::AVX_512bit);\n+      __ evpbroadcastq(xmm1, rax, Assembler::AVX_512bit);\n+\n+      __ align(32);\n+      __ BIND(L_vbmiLoop);\n+\n+      __ vpermb(xmm0, xmm3, Address(source, start_offset), Assembler::AVX_512bit);\n+      __ subl(length, 48);\n+\n+      \/\/ Put the input bytes into the proper lanes for writing, then\n+      \/\/ encode them.\n+      __ evpmultishiftqb(xmm0, xmm1, xmm0, Assembler::AVX_512bit);\n+      __ vpermb(xmm0, xmm0, xmm2, Assembler::AVX_512bit);\n+\n+      \/\/ Write to destination\n+      __ evmovdquq(Address(dest, dp), xmm0, Assembler::AVX_512bit);\n+\n+      __ addptr(dest, 64);\n+      __ addptr(source, 48);\n+      __ cmpl(length, 64);\n+      __ jcc(Assembler::aboveEqual, L_vbmiLoop);\n+\n+      __ vzeroupper();\n+    }\n+\n+    __ BIND(L_not512);\n+    if (VM_Version::supports_avx2()\n+        && VM_Version::supports_avx512vlbw()) {\n+      \/*\n+      ** This AVX2 encoder is based off the paper at:\n+      **      https:\/\/dl.acm.org\/doi\/10.1145\/3132709\n+      **\n+      ** We use AVX2 SIMD instructions to encode 24 bytes into 32\n+      ** output bytes.\n+      **\n+      *\/\n+      \/\/ Lengths under 32 bytes are done with scalar routine\n+      __ cmpl(length, 31);\n+      __ jcc(Assembler::belowEqual, L_process3);\n+\n+      \/\/ Set up supporting constant table data\n+      __ vmovdqu(xmm9, ExternalAddress(StubRoutines::x86::base64_avx2_shuffle_addr()), rax);\n+      \/\/ 6-bit mask for 2nd and 4th (and multiples) 6-bit values\n+      __ movl(rax, 0x0fc0fc00);\n+      __ vmovdqu(xmm1, ExternalAddress(StubRoutines::x86::base64_avx2_input_mask_addr()), rax);\n+      __ evpbroadcastd(xmm8, rax, Assembler::AVX_256bit);\n+\n+      \/\/ Multiplication constant for \"shifting\" right by 6 and 10\n+      \/\/ bits\n+      __ movl(rax, 0x04000040);\n+\n+      __ subl(length, 24);\n+      __ evpbroadcastd(xmm7, rax, Assembler::AVX_256bit);\n+\n+      \/\/ For the first load, we mask off reading of the first 4\n+      \/\/ bytes into the register. This is so we can get 4 3-byte\n+      \/\/ chunks into each lane of the register, avoiding having to\n+      \/\/ handle end conditions.  We then shuffle these bytes into a\n+      \/\/ specific order so that manipulation is easier.\n+      \/\/\n+      \/\/ The initial read loads the XMM register like this:\n+      \/\/\n+      \/\/ Lower 128-bit lane:\n+      \/\/ +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n+      \/\/ | XX | XX | XX | XX | A0 | A1 | A2 | B0 | B1 | B2 | C0 | C1\n+      \/\/ | C2 | D0 | D1 | D2 |\n+      \/\/ +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n+      \/\/\n+      \/\/ Upper 128-bit lane:\n+      \/\/ +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n+      \/\/ | E0 | E1 | E2 | F0 | F1 | F2 | G0 | G1 | G2 | H0 | H1 | H2\n+      \/\/ | XX | XX | XX | XX |\n+      \/\/ +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n+      \/\/\n+      \/\/ Where A0 is the first input byte, B0 is the fourth, etc.\n+      \/\/ The alphabetical significance denotes the 3 bytes to be\n+      \/\/ consumed and encoded into 4 bytes.\n+      \/\/\n+      \/\/ We then shuffle the register so each 32-bit word contains\n+      \/\/ the sequence:\n+      \/\/    A1 A0 A2 A1, B1, B0, B2, B1, etc.\n+      \/\/ Each of these byte sequences are then manipulated into 4\n+      \/\/ 6-bit values ready for encoding.\n+      \/\/\n+      \/\/ If we focus on one set of 3-byte chunks, changing the\n+      \/\/ nomenclature such that A0 => a, A1 => b, and A2 => c, we\n+      \/\/ shuffle such that each 24-bit chunk contains:\n+      \/\/\n+      \/\/ b7 b6 b5 b4 b3 b2 b1 b0 | a7 a6 a5 a4 a3 a2 a1 a0 | c7 c6\n+      \/\/ c5 c4 c3 c2 c1 c0 | b7 b6 b5 b4 b3 b2 b1 b0\n+      \/\/ Explain this step.\n+      \/\/ b3 b2 b1 b0 c5 c4 c3 c2 | c1 c0 d5 d4 d3 d2 d1 d0 | a5 a4\n+      \/\/ a3 a2 a1 a0 b5 b4 | b3 b2 b1 b0 c5 c4 c3 c2\n+      \/\/\n+      \/\/ W first and off all but bits 4-9 and 16-21 (c5..c0 and\n+      \/\/ a5..a0) and shift them using a vector multiplication\n+      \/\/ operation (vpmulhuw) which effectively shifts c right by 6\n+      \/\/ bits and a right by 10 bits.  We similarly mask bits 10-15\n+      \/\/ (d5..d0) and 22-27 (b5..b0) and shift them left by 8 and 4\n+      \/\/ bits respecively.  This is done using vpmullw.  We end up\n+      \/\/ with 4 6-bit values, thus splitting the 3 input bytes,\n+      \/\/ ready for encoding:\n+      \/\/    0 0 d5..d0 0 0 c5..c0 0 0 b5..b0 0 0 a5..a0\n+      \/\/\n+      \/\/ For translation, we recognize that there are 5 distinct\n+      \/\/ ranges of legal Base64 characters as below:\n+      \/\/\n+      \/\/   +-------------+-------------+------------+\n+      \/\/   | 6-bit value | ASCII range |   offset   |\n+      \/\/   +-------------+-------------+------------+\n+      \/\/   |    0..25    |    A..Z     |     65     |\n+      \/\/   |   26..51    |    a..z     |     71     |\n+      \/\/   |   52..61    |    0..9     |     -4     |\n+      \/\/   |     62      |   + or -    | -19 or -17 |\n+      \/\/   |     63      |   \/ or _    | -16 or 32  |\n+      \/\/   +-------------+-------------+------------+\n+      \/\/\n+      \/\/ We note that vpshufb does a parallel lookup in a\n+      \/\/ destination register using the lower 4 bits of bytes from a\n+      \/\/ source register.  If we use a saturated subtraction and\n+      \/\/ subtract 51 from each 6-bit value, bytes from [0,51]\n+      \/\/ saturate to 0, and [52,63] map to a range of [1,12].  We\n+      \/\/ distinguish the [0,25] and [26,51] ranges by assigning a\n+      \/\/ value of 13 for all 6-bit values less than 26.  We end up\n+      \/\/ with:\n+      \/\/\n+      \/\/   +-------------+-------------+------------+\n+      \/\/   | 6-bit value |   Reduced   |   offset   |\n+      \/\/   +-------------+-------------+------------+\n+      \/\/   |    0..25    |     13      |     65     |\n+      \/\/   |   26..51    |      0      |     71     |\n+      \/\/   |   52..61    |    0..9     |     -4     |\n+      \/\/   |     62      |     11      | -19 or -17 |\n+      \/\/   |     63      |     12      | -16 or 32  |\n+      \/\/   +-------------+-------------+------------+\n+      \/\/\n+      \/\/ We then use a final vpshufb to add the appropriate offset,\n+      \/\/ translating the bytes.\n+      \/\/\n+      \/\/ Load input bytes - only 28 bytes.  Mask the first load to\n+      \/\/ not load into the full register.\n+      __ vpmaskmovd(xmm1, xmm1, Address(source, start_offset, Address::times_1, -4), Assembler::AVX_256bit);\n+\n+      \/\/ Move 3-byte chunks of input (12 bytes) into 16 bytes,\n+      \/\/ ordering by:\n+      \/\/   1, 0, 2, 1; 4, 3, 5, 4; etc.  This groups 6-bit chunks\n+      \/\/   for easy masking\n+      __ vpshufb(xmm1, xmm1, xmm9, Assembler::AVX_256bit);\n+\n+      __ addl(start_offset, 24);\n+\n+      \/\/ Load masking register for first and third (and multiples)\n+      \/\/ 6-bit values.\n+      __ movl(rax, 0x003f03f0);\n+      __ evpbroadcastd(xmm6, rax, Assembler::AVX_256bit);\n+      \/\/ Multiplication constant for \"shifting\" left by 4 and 8 bits\n+      __ movl(rax, 0x01000010);\n+      __ evpbroadcastd(xmm5, rax, Assembler::AVX_256bit);\n+\n+      \/\/ Isolate 6-bit chunks of interest\n+      __ vpand(xmm0, xmm8, xmm1, Assembler::AVX_256bit);\n+\n+      \/\/ Load constants for encoding\n+      __ movl(rax, 0x19191919);\n+      __ evpbroadcastd(xmm3, rax, Assembler::AVX_256bit);\n+      __ movl(rax, 0x33333333);\n+      __ evpbroadcastd(xmm4, rax, Assembler::AVX_256bit);\n+\n+      \/\/ Shift output bytes 0 and 2 into proper lanes\n+      __ vpmulhuw(xmm2, xmm0, xmm7, Assembler::AVX_256bit);\n+\n+      \/\/ Mask and shift output bytes 1 and 3 into proper lanes and\n+      \/\/ combine\n+      __ vpand(xmm0, xmm6, xmm1, Assembler::AVX_256bit);\n+      __ vpmullw(xmm0, xmm5, xmm0, Assembler::AVX_256bit);\n+      __ vpor(xmm0, xmm0, xmm2, Assembler::AVX_256bit);\n+\n+      \/\/ Find out which are 0..25.  This indicates which input\n+      \/\/ values fall in the range of 'A'-'Z', which require an\n+      \/\/ additional offset (see comments above)\n+      __ vpcmpgtb(xmm2, xmm0, xmm3, Assembler::AVX_256bit);\n+      __ vpsubusb(xmm1, xmm0, xmm4, Assembler::AVX_256bit);\n+      __ vpsubb(xmm1, xmm1, xmm2, Assembler::AVX_256bit);\n+\n+      \/\/ Load the proper lookup table\n+      __ lea(r11, ExternalAddress(StubRoutines::x86::base64_avx2_lut_addr()));\n+      __ movl(r15, isURL);\n+      __ shll(r15, 5);\n+      __ vmovdqu(xmm2, Address(r11, r15));\n+\n+      \/\/ Shuffle the offsets based on the range calculation done\n+      \/\/ above. This allows us to add the correct offset to the\n+      \/\/ 6-bit value corresponding to the range documented above.\n+      __ vpshufb(xmm1, xmm2, xmm1, Assembler::AVX_256bit);\n+      __ vpaddb(xmm0, xmm1, xmm0, Assembler::AVX_256bit);\n+\n+      \/\/ Store the encoded bytes\n+      __ vmovdqu(Address(dest, dp), xmm0);\n+      __ addl(dp, 32);\n+\n+      __ cmpl(length, 31);\n+      __ jcc(Assembler::belowEqual, L_process3);\n+\n+      __ align(32);\n+      __ BIND(L_32byteLoop);\n+\n+      \/\/ Get next 32 bytes\n+      __ vmovdqu(xmm1, Address(source, start_offset, Address::times_1, -4));\n+\n+      __ subl(length, 24);\n+      __ addl(start_offset, 24);\n+\n+      \/\/ This logic is identical to the above, with only constant\n+      \/\/ register loads removed.  Shuffle the input, mask off 6-bit\n+      \/\/ chunks, shift them into place, then add the offset to\n+      \/\/ encode.\n+      __ vpshufb(xmm1, xmm1, xmm9, Assembler::AVX_256bit);\n+\n+      __ vpand(xmm0, xmm8, xmm1, Assembler::AVX_256bit);\n+      __ vpmulhuw(xmm10, xmm0, xmm7, Assembler::AVX_256bit);\n+      __ vpand(xmm0, xmm6, xmm1, Assembler::AVX_256bit);\n+      __ vpmullw(xmm0, xmm5, xmm0, Assembler::AVX_256bit);\n+      __ vpor(xmm0, xmm0, xmm10, Assembler::AVX_256bit);\n+      __ vpcmpgtb(xmm10, xmm0, xmm3, Assembler::AVX_256bit);\n+      __ vpsubusb(xmm1, xmm0, xmm4, Assembler::AVX_256bit);\n+      __ vpsubb(xmm1, xmm1, xmm10, Assembler::AVX_256bit);\n+      __ vpshufb(xmm1, xmm2, xmm1, Assembler::AVX_256bit);\n+      __ vpaddb(xmm0, xmm1, xmm0, Assembler::AVX_256bit);\n+\n+      \/\/ Store the encoded bytes\n+      __ vmovdqu(Address(dest, dp), xmm0);\n+      __ addl(dp, 32);\n+\n+      __ cmpl(length, 31);\n+      __ jcc(Assembler::above, L_32byteLoop);\n+\n+      __ BIND(L_process3);\n+      __ vzeroupper();\n+    } else {\n+      __ BIND(L_process3);\n+    }\n+\n+    __ cmpl(length, 3);\n+    __ jcc(Assembler::below, L_exit);\n+\n+    \/\/ Load the encoding table based on isURL\n+    __ lea(r11, ExternalAddress(StubRoutines::x86::base64_encoding_table_addr()));\n+    __ movl(r15, isURL);\n+    __ shll(r15, 6);\n+    __ addptr(r11, r15);\n+\n+    __ BIND(L_processdata);\n+\n+    \/\/ Load 3 bytes\n+    __ load_unsigned_byte(r15, Address(source, start_offset));\n+    __ load_unsigned_byte(r10, Address(source, start_offset, Address::times_1, 1));\n+    __ load_unsigned_byte(r13, Address(source, start_offset, Address::times_1, 2));\n+\n+    \/\/ Build a 32-bit word with bytes 1, 2, 0, 1\n+    __ movl(rax, r10);\n+    __ shll(r10, 24);\n+    __ orl(rax, r10);\n+\n+    __ subl(length, 3);\n+\n+    __ shll(r15, 8);\n+    __ shll(r13, 16);\n+    __ orl(rax, r15);\n+\n+    __ addl(start_offset, 3);\n+\n+    __ orl(rax, r13);\n+    \/\/ At this point, rax contains | byte1 | byte2 | byte0 | byte1\n+    \/\/ r13 has byte2 << 16 - need low-order 6 bits to translate.\n+    \/\/ This translated byte is the fourth output byte.\n+    __ shrl(r13, 16);\n+    __ andl(r13, 0x3f);\n+\n+    \/\/ The high-order 6 bits of r15 (byte0) is translated.\n+    \/\/ The translated byte is the first output byte.\n+    __ shrl(r15, 10);\n+\n+    __ load_unsigned_byte(r13, Address(r11, r13));\n+    __ load_unsigned_byte(r15, Address(r11, r15));\n+\n+    __ movb(Address(dest, dp, Address::times_1, 3), r13);\n+\n+    \/\/ Extract high-order 4 bits of byte1 and low-order 2 bits of byte0.\n+    \/\/ This translated byte is the second output byte.\n+    __ shrl(rax, 4);\n+    __ movl(r10, rax);\n+    __ andl(rax, 0x3f);\n+\n+    __ movb(Address(dest, dp, Address::times_1, 0), r15);\n+\n+    __ load_unsigned_byte(rax, Address(r11, rax));\n+\n+    \/\/ Extract low-order 2 bits of byte1 and high-order 4 bits of byte2.\n+    \/\/ This translated byte is the third output byte.\n+    __ shrl(r10, 18);\n+    __ andl(r10, 0x3f);\n+\n+    __ load_unsigned_byte(r10, Address(r11, r10));\n+\n+    __ movb(Address(dest, dp, Address::times_1, 1), rax);\n+    __ movb(Address(dest, dp, Address::times_1, 2), r10);\n+\n+    __ addl(dp, 4);\n+    __ cmpl(length, 3);\n+    __ jcc(Assembler::aboveEqual, L_processdata);\n@@ -5400,0 +5747,7 @@\n+    __ BIND(L_exit);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+    __ leave();\n+    __ ret(0);\n@@ -5403,3 +5757,4 @@\n-  address base64_left_shift_mask_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"left_shift_mask\");\n+  \/\/ base64 AVX512vbmi tables\n+  address base64_vbmi_lookup_lo_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64\");\n@@ -5407,8 +5762,12 @@\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n-    __ emit_data64(0x0000000200040000, relocInfo::none);\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x3f8080803e808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n+    return start;\n+  }\n@@ -5416,0 +5775,30 @@\n+  address base64_vbmi_lookup_hi_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x8080808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n+    return start;\n+  }\n+  address base64_vbmi_lookup_lo_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_lo_base64url\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x8080808080808080, relocInfo::none);\n+    __ emit_data64(0x80803e8080808080, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0x8080808080803d3c, relocInfo::none);\n@@ -5419,3 +5808,3 @@\n-  address base64_and_mask_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"and_mask\");\n+  address base64_vbmi_lookup_hi_url_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_hi_base64url\");\n@@ -5423,8 +5812,10 @@\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n-    __ emit_data64(0x3f003f003f000000, relocInfo::none);\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x0605040302010080, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3f80808080191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1a80, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0x8080808080333231, relocInfo::none);\n@@ -5434,3 +5825,70 @@\n-  address base64_gather_mask_addr() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"gather_mask\");\n+  address base64_vbmi_pack_vec_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"pack_vec_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_0_1_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_0_1_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x090a040506000102, relocInfo::none);\n+    __ emit_data64(0x161011120c0d0e08, relocInfo::none);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_1_2_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_1_2_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x1c1d1e18191a1415, relocInfo::none);\n+    __ emit_data64(0x292a242526202122, relocInfo::none);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_vbmi_join_2_3_addr() {\n+    __ align(64, (unsigned long long) __ pc());\n+    StubCodeMark mark(this, \"StubRoutines\", \"join_2_3_base64\");\n+    address start = __ pc();\n+    assert(((unsigned long long)start & 0x3f) == 0,\n+           \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+    __ emit_data64(0x363031322c2d2e28, relocInfo::none);\n+    __ emit_data64(0x3c3d3e38393a3435, relocInfo::none);\n+    __ emit_data64(0x494a444546404142, relocInfo::none);\n+    __ emit_data64(0x565051524c4d4e48, relocInfo::none);\n+    __ emit_data64(0x5c5d5e58595a5455, relocInfo::none);\n+    __ emit_data64(0x696a646566606162, relocInfo::none);\n+    __ emit_data64(0x767071726c6d6e68, relocInfo::none);\n+    __ emit_data64(0x7c7d7e78797a7475, relocInfo::none);\n+    return start;\n+  }\n+\n+  address base64_decoding_table_addr() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"decoding_table_base64\");\n@@ -5439,0 +5897,65 @@\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0x3fffffff3effffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0xffffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+    \/\/ URL table\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffff3effffffffff, relocInfo::none);\n+    __ emit_data64(0x3b3a393837363534, relocInfo::none);\n+    __ emit_data64(0xffffffffffff3d3c, relocInfo::none);\n+    __ emit_data64(0x06050403020100ff, relocInfo::none);\n+    __ emit_data64(0x0e0d0c0b0a090807, relocInfo::none);\n+    __ emit_data64(0x161514131211100f, relocInfo::none);\n+    __ emit_data64(0x3fffffffff191817, relocInfo::none);\n+    __ emit_data64(0x201f1e1d1c1b1aff, relocInfo::none);\n+    __ emit_data64(0x2827262524232221, relocInfo::none);\n+    __ emit_data64(0x302f2e2d2c2b2a29, relocInfo::none);\n+    __ emit_data64(0xffffffffff333231, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+    __ emit_data64(0xffffffffffffffff, relocInfo::none);\n@@ -5442,1 +5965,5 @@\n-\/\/ Code for generating Base64 encoding.\n+\n+\/\/ Code for generating Base64 decoding.\n+\/\/\n+\/\/ Based on the article (and associated code) from https:\/\/arxiv.org\/abs\/1910.05109.\n+\/\/\n@@ -5444,2 +5971,2 @@\n-\/\/ private void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {\n-  address generate_base64_encodeBlock() {\n+\/\/ private void decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, isMIME) {\n+  address generate_base64_decodeBlock() {\n@@ -5447,1 +5974,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"implEncode\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"implDecode\");\n@@ -5456,0 +5983,1 @@\n+    __ push(rbx);\n@@ -5462,0 +5990,1 @@\n+    const Register isMIME = rbx;\n@@ -5466,0 +5995,1 @@\n+    __ movl(isMIME, Address(rbp, 2 * wordSize));\n@@ -5473,0 +6003,1 @@\n+    __ movl(isMIME, Address(rbp, 8 * wordSize));\n@@ -5475,0 +6006,28 @@\n+    const XMMRegister lookup_lo = xmm5;\n+    const XMMRegister lookup_hi = xmm6;\n+    const XMMRegister errorvec = xmm7;\n+    const XMMRegister pack16_op = xmm9;\n+    const XMMRegister pack32_op = xmm8;\n+    const XMMRegister input0 = xmm3;\n+    const XMMRegister input1 = xmm20;\n+    const XMMRegister input2 = xmm21;\n+    const XMMRegister input3 = xmm19;\n+    const XMMRegister join01 = xmm12;\n+    const XMMRegister join12 = xmm11;\n+    const XMMRegister join23 = xmm10;\n+    const XMMRegister translated0 = xmm2;\n+    const XMMRegister translated1 = xmm1;\n+    const XMMRegister translated2 = xmm0;\n+    const XMMRegister translated3 = xmm4;\n+\n+    const XMMRegister merged0 = xmm2;\n+    const XMMRegister merged1 = xmm1;\n+    const XMMRegister merged2 = xmm0;\n+    const XMMRegister merged3 = xmm4;\n+    const XMMRegister merge_ab_bc0 = xmm2;\n+    const XMMRegister merge_ab_bc1 = xmm1;\n+    const XMMRegister merge_ab_bc2 = xmm0;\n+    const XMMRegister merge_ab_bc3 = xmm4;\n+\n+    const XMMRegister pack24bits = xmm4;\n+\n@@ -5476,1 +6035,12 @@\n-    Label L_process80, L_process32, L_process3, L_exit, L_processdata;\n+    const Register output_size = r13;\n+    const Register output_mask = r15;\n+    const KRegister input_mask = k1;\n+\n+    const XMMRegister input_initial_valid_b64 = xmm0;\n+    const XMMRegister tmp = xmm10;\n+    const XMMRegister mask = xmm0;\n+    const XMMRegister invalid_b64 = xmm1;\n+\n+    Label L_process256, L_process64, L_process64Loop, L_exit, L_processdata, L_loadURL;\n+    Label L_continue, L_finalBit, L_padding, L_donePadding, L_bruteForce;\n+    Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n@@ -5481,0 +6051,288 @@\n+    __ push(dest);          \/\/ Save for return value calc\n+\n+    \/\/ If AVX512 VBMI not supported, just compile non-AVX code\n+    if(VM_Version::supports_avx512_vbmi() &&\n+       VM_Version::supports_avx512bw()) {\n+      __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n+      __ jcc(Assembler::lessEqual, L_bruteForce);\n+\n+      __ cmpl(isMIME, 0);\n+      __ jcc(Assembler::notEqual, L_bruteForce);\n+\n+      \/\/ Load lookup tables based on isURL\n+      __ cmpl(isURL, 0);\n+      __ jcc(Assembler::notZero, L_loadURL);\n+\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ BIND(L_continue);\n+\n+      __ movl(r15, 0x01400140);\n+      __ evpbroadcastd(pack16_op, r15, Assembler::AVX_512bit);\n+\n+      __ movl(r15, 0x00011000);\n+      __ evpbroadcastd(pack32_op, r15, Assembler::AVX_512bit);\n+\n+      __ cmpl(length, 0xff);\n+      __ jcc(Assembler::lessEqual, L_process64);\n+\n+      \/\/ load masks required for decoding data\n+      __ BIND(L_processdata);\n+      __ evmovdquq(join01, ExternalAddress(StubRoutines::x86::base64_vbmi_join_0_1_addr()), Assembler::AVX_512bit,r13);\n+      __ evmovdquq(join12, ExternalAddress(StubRoutines::x86::base64_vbmi_join_1_2_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(join23, ExternalAddress(StubRoutines::x86::base64_vbmi_join_2_3_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ align(32);\n+      __ BIND(L_process256);\n+      \/\/ Grab input data\n+      __ evmovdquq(input0, Address(source, start_offset, Address::times_1, 0x00), Assembler::AVX_512bit);\n+      __ evmovdquq(input1, Address(source, start_offset, Address::times_1, 0x40), Assembler::AVX_512bit);\n+      __ evmovdquq(input2, Address(source, start_offset, Address::times_1, 0x80), Assembler::AVX_512bit);\n+      __ evmovdquq(input3, Address(source, start_offset, Address::times_1, 0xc0), Assembler::AVX_512bit);\n+\n+      \/\/ Copy the low part of the lookup table into the destination of the permutation\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated1, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated2, lookup_lo, Assembler::AVX_512bit);\n+      __ evmovdquq(translated3, lookup_lo, Assembler::AVX_512bit);\n+\n+      \/\/ Translate the base64 input into \"decoded\" bytes\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated1, input1, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated2, input2, lookup_hi, Assembler::AVX_512bit);\n+      __ evpermt2b(translated3, input3, lookup_hi, Assembler::AVX_512bit);\n+\n+      \/\/ OR all of the translations together to check for errors (high-order bit of byte set)\n+      __ vpternlogd(input0, 0xfe, input1, input2, Assembler::AVX_512bit);\n+\n+      __ vpternlogd(input3, 0xfe, translated0, translated1, Assembler::AVX_512bit);\n+      __ vpternlogd(input0, 0xfe, translated2, translated3, Assembler::AVX_512bit);\n+      __ vpor(errorvec, input3, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check if there was an error - if so, try 64-byte chunks\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_process64);\n+\n+      \/\/ The merging and shuffling happens here\n+      \/\/ We multiply each byte pair [00dddddd | 00cccccc | 00bbbbbb | 00aaaaaa]\n+      \/\/ Multiply [00cccccc] by 2^6 added to [00dddddd] to get [0000cccc | ccdddddd]\n+      \/\/ The pack16_op is a vector of 0x01400140, so multiply D by 1 and C by 0x40\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc1, translated1, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc2, translated2, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddubsw(merge_ab_bc3, translated3, pack16_op, Assembler::AVX_512bit);\n+\n+      \/\/ Now do the same with packed 16-bit values.\n+      \/\/ We start with [0000cccc | ccdddddd | 0000aaaa | aabbbbbb]\n+      \/\/ pack32_op is 0x00011000 (2^12, 1), so this multiplies [0000aaaa | aabbbbbb] by 2^12\n+      \/\/ and adds [0000cccc | ccdddddd] to yield [00000000 | aaaaaabb | bbbbcccc | ccdddddd]\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged1, merge_ab_bc1, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged2, merge_ab_bc2, pack32_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged3, merge_ab_bc3, pack32_op, Assembler::AVX_512bit);\n+\n+      \/\/ The join vectors specify which byte from which vector goes into the outputs\n+      \/\/ One of every 4 bytes in the extended vector is zero, so we pack them into their\n+      \/\/ final positions in the register for storing (256 bytes in, 192 bytes out)\n+      __ evpermt2b(merged0, join01, merged1, Assembler::AVX_512bit);\n+      __ evpermt2b(merged1, join12, merged2, Assembler::AVX_512bit);\n+      __ evpermt2b(merged2, join23, merged3, Assembler::AVX_512bit);\n+\n+      \/\/ Store result\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x00), merged0, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x40), merged1, Assembler::AVX_512bit);\n+      __ evmovdquq(Address(dest, dp, Address::times_1, 0x80), merged2, Assembler::AVX_512bit);\n+\n+      __ addptr(source, 0x100);\n+      __ addptr(dest, 0xc0);\n+      __ subl(length, 0x100);\n+      __ cmpl(length, 64 * 4);\n+      __ jcc(Assembler::greaterEqual, L_process256);\n+\n+      \/\/ At this point, we've decoded 64 * 4 * n bytes.\n+      \/\/ The remaining length will be <= 64 * 4 - 1.\n+      \/\/ UNLESS there was an error decoding the first 256-byte chunk.  In this\n+      \/\/ case, the length will be arbitrarily long.\n+      \/\/\n+      \/\/ Note that this will be the path for MIME-encoded strings.\n+\n+      __ BIND(L_process64);\n+\n+      __ evmovdquq(pack24bits, ExternalAddress(StubRoutines::x86::base64_vbmi_pack_vec_addr()), Assembler::AVX_512bit, r13);\n+\n+      __ cmpl(length, 63);\n+      __ jcc(Assembler::lessEqual, L_finalBit);\n+\n+      __ align(32);\n+      __ BIND(L_process64Loop);\n+\n+      \/\/ Handle first 64-byte block\n+\n+      __ evmovdquq(input0, Address(source, start_offset), Assembler::AVX_512bit);\n+      __ evmovdquq(translated0, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(translated0, input0, lookup_hi, Assembler::AVX_512bit);\n+\n+      __ vpor(errorvec, translated0, input0, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error and bomb out before updating dest\n+      __ evpmovb2m(k3, errorvec, Assembler::AVX_512bit);\n+      __ kortestql(k3, k3);\n+      __ jcc(Assembler::notZero, L_exit);\n+\n+      \/\/ Pack output register, selecting correct byte ordering\n+      __ vpmaddubsw(merge_ab_bc0, translated0, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(merged0, merge_ab_bc0, pack32_op, Assembler::AVX_512bit);\n+      __ vpermb(merged0, pack24bits, merged0, Assembler::AVX_512bit);\n+\n+      __ evmovdquq(Address(dest, dp), merged0, Assembler::AVX_512bit);\n+\n+      __ subl(length, 64);\n+      __ addptr(source, 64);\n+      __ addptr(dest, 48);\n+\n+      __ cmpl(length, 64);\n+      __ jcc(Assembler::greaterEqual, L_process64Loop);\n+\n+      __ cmpl(length, 0);\n+      __ jcc(Assembler::lessEqual, L_exit);\n+\n+      __ BIND(L_finalBit);\n+      \/\/ Now have 1 to 63 bytes left to decode\n+\n+      \/\/ I was going to let Java take care of the final fragment\n+      \/\/ however it will repeatedly call this routine for every 4 bytes\n+      \/\/ of input data, so handle the rest here.\n+      __ movq(rax, -1);\n+      __ bzhiq(rax, rax, length);    \/\/ Input mask in rax\n+\n+      __ movl(output_size, length);\n+      __ shrl(output_size, 2);   \/\/ Find (len \/ 4) * 3 (output length)\n+      __ lea(output_size, Address(output_size, output_size, Address::times_2, 0));\n+      \/\/ output_size in r13\n+\n+      \/\/ Strip pad characters, if any, and adjust length and mask\n+      __ cmpb(Address(source, length, Address::times_1, -1), '=');\n+      __ jcc(Assembler::equal, L_padding);\n+\n+      __ BIND(L_donePadding);\n+\n+      \/\/ Output size is (64 - output_size), output mask is (all 1s >> output_size).\n+      __ kmovql(input_mask, rax);\n+      __ movq(output_mask, -1);\n+      __ bzhiq(output_mask, output_mask, output_size);\n+\n+      \/\/ Load initial input with all valid base64 characters.  Will be used\n+      \/\/ in merging source bytes to avoid masking when determining if an error occurred.\n+      __ movl(rax, 0x61616161);\n+      __ evpbroadcastd(input_initial_valid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ A register containing all invalid base64 decoded values\n+      __ movl(rax, 0x80808080);\n+      __ evpbroadcastd(invalid_b64, rax, Assembler::AVX_512bit);\n+\n+      \/\/ input_mask is in k1\n+      \/\/ output_size is in r13\n+      \/\/ output_mask is in r15\n+      \/\/ zmm0 - free\n+      \/\/ zmm1 - 0x00011000\n+      \/\/ zmm2 - 0x01400140\n+      \/\/ zmm3 - errorvec\n+      \/\/ zmm4 - pack vector\n+      \/\/ zmm5 - lookup_lo\n+      \/\/ zmm6 - lookup_hi\n+      \/\/ zmm7 - errorvec\n+      \/\/ zmm8 - 0x61616161\n+      \/\/ zmm9 - 0x80808080\n+\n+      \/\/ Load only the bytes from source, merging into our \"fully-valid\" register\n+      __ evmovdqub(input_initial_valid_b64, input_mask, Address(source, start_offset, Address::times_1, 0x0), true, Assembler::AVX_512bit);\n+\n+      \/\/ Decode all bytes within our merged input\n+      __ evmovdquq(tmp, lookup_lo, Assembler::AVX_512bit);\n+      __ evpermt2b(tmp, input_initial_valid_b64, lookup_hi, Assembler::AVX_512bit);\n+      __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+\n+      \/\/ Check for error.  Compare (decoded | initial) to all invalid.\n+      \/\/ If any bytes have their high-order bit set, then we have an error.\n+      __ evptestmb(k2, mask, invalid_b64, Assembler::AVX_512bit);\n+      __ kortestql(k2, k2);\n+\n+      \/\/ If we have an error, use the brute force loop to decode what we can (4-byte chunks).\n+      __ jcc(Assembler::notZero, L_bruteForce);\n+\n+      \/\/ Shuffle output bytes\n+      __ vpmaddubsw(tmp, tmp, pack16_op, Assembler::AVX_512bit);\n+      __ vpmaddwd(tmp, tmp, pack32_op, Assembler::AVX_512bit);\n+\n+      __ vpermb(tmp, pack24bits, tmp, Assembler::AVX_512bit);\n+      __ kmovql(k1, output_mask);\n+      __ evmovdqub(Address(dest, dp), k1, tmp, true, Assembler::AVX_512bit);\n+\n+      __ addptr(dest, output_size);\n+\n+      __ BIND(L_exit);\n+      __ vzeroupper();\n+      __ pop(rax);             \/\/ Get original dest value\n+      __ subptr(dest, rax);      \/\/ Number of bytes converted\n+      __ movptr(rax, dest);\n+      __ pop(rbx);\n+      __ pop(r15);\n+      __ pop(r14);\n+      __ pop(r13);\n+      __ pop(r12);\n+      __ leave();\n+      __ ret(0);\n+\n+      __ BIND(L_loadURL);\n+      __ evmovdquq(lookup_lo, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_lo_url_addr()), Assembler::AVX_512bit, r13);\n+      __ evmovdquq(lookup_hi, ExternalAddress(StubRoutines::x86::base64_vbmi_lookup_hi_url_addr()), Assembler::AVX_512bit, r13);\n+      __ jmp(L_continue);\n+\n+      __ BIND(L_padding);\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+\n+      __ cmpb(Address(source, length, Address::times_1, -2), '=');\n+      __ jcc(Assembler::notEqual, L_donePadding);\n+\n+      __ decrementq(output_size, 1);\n+      __ shrq(rax, 1);\n+      __ jmp(L_donePadding);\n+\n+      __ align(32);\n+      __ BIND(L_bruteForce);\n+    }   \/\/ End of if(avx512_vbmi)\n+\n+    \/\/ Use non-AVX code to decode 4-byte chunks into 3 bytes of output\n+\n+    \/\/ Register state (Linux):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rdi - src\n+    \/\/ rsi - sp\n+    \/\/ rdx - sl\n+    \/\/ rcx - dst\n+    \/\/ r8 - dp\n+    \/\/ r9 - isURL\n+\n+    \/\/ Register state (Windows):\n+    \/\/ r12-15 - saved on stack\n+    \/\/ rcx - src\n+    \/\/ rdx - sp\n+    \/\/ r8 - sl\n+    \/\/ r9 - dst\n+    \/\/ r12 - dp\n+    \/\/ r10 - isURL\n+\n+    \/\/ Registers (common):\n+    \/\/ length (r14) - bytes in src\n+\n+    const Register decode_table = r11;\n+    const Register out_byte_count = rbx;\n+    const Register byte1 = r13;\n+    const Register byte2 = r15;\n+    const Register byte3 = WINDOWS_ONLY(r8) NOT_WINDOWS(rdx);\n+    const Register byte4 = WINDOWS_ONLY(r10) NOT_WINDOWS(r9);\n+\n+    __ shrl(length, 2);    \/\/ Multiple of 4 bytes only - length is # 4-byte chunks\n@@ -5482,1 +6340,1 @@\n-    __ jcc(Assembler::lessEqual, L_exit);\n+    __ jcc(Assembler::lessEqual, L_exit_no_vzero);\n@@ -5484,5 +6342,3 @@\n-    __ lea(r11, ExternalAddress(StubRoutines::x86::base64_charset_addr()));\n-    \/\/ check if base64 charset(isURL=0) or base64 url charset(isURL=1) needs to be loaded\n-    __ cmpl(isURL, 0);\n-    __ jcc(Assembler::equal, L_processdata);\n-    __ lea(r11, ExternalAddress(StubRoutines::x86::base64url_charset_addr()));\n+    __ shll(isURL, 8);    \/\/ index into decode table based on isURL\n+    __ lea(decode_table, ExternalAddress(StubRoutines::x86::base64_decoding_table_addr()));\n+    __ addptr(decode_table, isURL);\n@@ -5490,187 +6346,44 @@\n-    \/\/ load masks required for encoding data\n-    __ BIND(L_processdata);\n-    __ movdqu(xmm16, ExternalAddress(StubRoutines::x86::base64_gather_mask_addr()));\n-    \/\/ Set 64 bits of K register.\n-    __ evpcmpeqb(k3, xmm16, xmm16, Assembler::AVX_512bit);\n-    __ evmovdquq(xmm12, ExternalAddress(StubRoutines::x86::base64_bswap_mask_addr()), Assembler::AVX_256bit, r13);\n-    __ evmovdquq(xmm13, ExternalAddress(StubRoutines::x86::base64_right_shift_mask_addr()), Assembler::AVX_512bit, r13);\n-    __ evmovdquq(xmm14, ExternalAddress(StubRoutines::x86::base64_left_shift_mask_addr()), Assembler::AVX_512bit, r13);\n-    __ evmovdquq(xmm15, ExternalAddress(StubRoutines::x86::base64_and_mask_addr()), Assembler::AVX_512bit, r13);\n-\n-    \/\/ Vector Base64 implementation, producing 96 bytes of encoded data\n-    __ BIND(L_process80);\n-    __ cmpl(length, 80);\n-    __ jcc(Assembler::below, L_process32);\n-    __ evmovdquq(xmm0, Address(source, start_offset, Address::times_1, 0), Assembler::AVX_256bit);\n-    __ evmovdquq(xmm1, Address(source, start_offset, Address::times_1, 24), Assembler::AVX_256bit);\n-    __ evmovdquq(xmm2, Address(source, start_offset, Address::times_1, 48), Assembler::AVX_256bit);\n-\n-    \/\/permute the input data in such a manner that we have continuity of the source\n-    __ vpermq(xmm3, xmm0, 148, Assembler::AVX_256bit);\n-    __ vpermq(xmm4, xmm1, 148, Assembler::AVX_256bit);\n-    __ vpermq(xmm5, xmm2, 148, Assembler::AVX_256bit);\n-\n-    \/\/shuffle input and group 3 bytes of data and to it add 0 as the 4th byte.\n-    \/\/we can deal with 12 bytes at a time in a 128 bit register\n-    __ vpshufb(xmm3, xmm3, xmm12, Assembler::AVX_256bit);\n-    __ vpshufb(xmm4, xmm4, xmm12, Assembler::AVX_256bit);\n-    __ vpshufb(xmm5, xmm5, xmm12, Assembler::AVX_256bit);\n-\n-    \/\/convert byte to word. Each 128 bit register will have 6 bytes for processing\n-    __ vpmovzxbw(xmm3, xmm3, Assembler::AVX_512bit);\n-    __ vpmovzxbw(xmm4, xmm4, Assembler::AVX_512bit);\n-    __ vpmovzxbw(xmm5, xmm5, Assembler::AVX_512bit);\n-\n-    \/\/ Extract bits in the following pattern 6, 4+2, 2+4, 6 to convert 3, 8 bit numbers to 4, 6 bit numbers\n-    __ evpsrlvw(xmm0, xmm3, xmm13,  Assembler::AVX_512bit);\n-    __ evpsrlvw(xmm1, xmm4, xmm13, Assembler::AVX_512bit);\n-    __ evpsrlvw(xmm2, xmm5, xmm13, Assembler::AVX_512bit);\n-\n-    __ evpsllvw(xmm3, xmm3, xmm14, Assembler::AVX_512bit);\n-    __ evpsllvw(xmm4, xmm4, xmm14, Assembler::AVX_512bit);\n-    __ evpsllvw(xmm5, xmm5, xmm14, Assembler::AVX_512bit);\n-\n-    __ vpsrlq(xmm0, xmm0, 8, Assembler::AVX_512bit);\n-    __ vpsrlq(xmm1, xmm1, 8, Assembler::AVX_512bit);\n-    __ vpsrlq(xmm2, xmm2, 8, Assembler::AVX_512bit);\n-\n-    __ vpsllq(xmm3, xmm3, 8, Assembler::AVX_512bit);\n-    __ vpsllq(xmm4, xmm4, 8, Assembler::AVX_512bit);\n-    __ vpsllq(xmm5, xmm5, 8, Assembler::AVX_512bit);\n-\n-    __ vpandq(xmm3, xmm3, xmm15, Assembler::AVX_512bit);\n-    __ vpandq(xmm4, xmm4, xmm15, Assembler::AVX_512bit);\n-    __ vpandq(xmm5, xmm5, xmm15, Assembler::AVX_512bit);\n-\n-    \/\/ Get the final 4*6 bits base64 encoding\n-    __ vporq(xmm3, xmm3, xmm0, Assembler::AVX_512bit);\n-    __ vporq(xmm4, xmm4, xmm1, Assembler::AVX_512bit);\n-    __ vporq(xmm5, xmm5, xmm2, Assembler::AVX_512bit);\n-\n-    \/\/ Shift\n-    __ vpsrlq(xmm3, xmm3, 8, Assembler::AVX_512bit);\n-    __ vpsrlq(xmm4, xmm4, 8, Assembler::AVX_512bit);\n-    __ vpsrlq(xmm5, xmm5, 8, Assembler::AVX_512bit);\n-\n-    \/\/ look up 6 bits in the base64 character set to fetch the encoding\n-    \/\/ we are converting word to dword as gather instructions need dword indices for looking up encoding\n-    __ vextracti64x4(xmm6, xmm3, 0);\n-    __ vpmovzxwd(xmm0, xmm6, Assembler::AVX_512bit);\n-    __ vextracti64x4(xmm6, xmm3, 1);\n-    __ vpmovzxwd(xmm1, xmm6, Assembler::AVX_512bit);\n-\n-    __ vextracti64x4(xmm6, xmm4, 0);\n-    __ vpmovzxwd(xmm2, xmm6, Assembler::AVX_512bit);\n-    __ vextracti64x4(xmm6, xmm4, 1);\n-    __ vpmovzxwd(xmm3, xmm6, Assembler::AVX_512bit);\n-\n-    __ vextracti64x4(xmm4, xmm5, 0);\n-    __ vpmovzxwd(xmm6, xmm4, Assembler::AVX_512bit);\n-\n-    __ vextracti64x4(xmm4, xmm5, 1);\n-    __ vpmovzxwd(xmm7, xmm4, Assembler::AVX_512bit);\n-\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm4, k2, Address(r11, xmm0, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm5, k2, Address(r11, xmm1, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm8, k2, Address(r11, xmm2, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm9, k2, Address(r11, xmm3, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm10, k2, Address(r11, xmm6, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm11, k2, Address(r11, xmm7, Address::times_4, 0), Assembler::AVX_512bit);\n-\n-    \/\/Down convert dword to byte. Final output is 16*6 = 96 bytes long\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 0), xmm4, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 16), xmm5, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 32), xmm8, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 48), xmm9, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 64), xmm10, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 80), xmm11, Assembler::AVX_512bit);\n-\n-    __ addq(dest, 96);\n-    __ addq(source, 72);\n-    __ subq(length, 72);\n-    __ jmp(L_process80);\n-\n-    \/\/ Vector Base64 implementation generating 32 bytes of encoded data\n-    __ BIND(L_process32);\n-    __ cmpl(length, 32);\n-    __ jcc(Assembler::below, L_process3);\n-    __ evmovdquq(xmm0, Address(source, start_offset), Assembler::AVX_256bit);\n-    __ vpermq(xmm0, xmm0, 148, Assembler::AVX_256bit);\n-    __ vpshufb(xmm6, xmm0, xmm12, Assembler::AVX_256bit);\n-    __ vpmovzxbw(xmm6, xmm6, Assembler::AVX_512bit);\n-    __ evpsrlvw(xmm2, xmm6, xmm13, Assembler::AVX_512bit);\n-    __ evpsllvw(xmm3, xmm6, xmm14, Assembler::AVX_512bit);\n-\n-    __ vpsrlq(xmm2, xmm2, 8, Assembler::AVX_512bit);\n-    __ vpsllq(xmm3, xmm3, 8, Assembler::AVX_512bit);\n-    __ vpandq(xmm3, xmm3, xmm15, Assembler::AVX_512bit);\n-    __ vporq(xmm1, xmm2, xmm3, Assembler::AVX_512bit);\n-    __ vpsrlq(xmm1, xmm1, 8, Assembler::AVX_512bit);\n-    __ vextracti64x4(xmm9, xmm1, 0);\n-    __ vpmovzxwd(xmm6, xmm9, Assembler::AVX_512bit);\n-    __ vextracti64x4(xmm9, xmm1, 1);\n-    __ vpmovzxwd(xmm5, xmm9,  Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm8, k2, Address(r11, xmm6, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ kmovql(k2, k3);\n-    __ evpgatherdd(xmm10, k2, Address(r11, xmm5, Address::times_4, 0), Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 0), xmm8, Assembler::AVX_512bit);\n-    __ evpmovdb(Address(dest, dp, Address::times_1, 16), xmm10, Assembler::AVX_512bit);\n-    __ subq(length, 24);\n-    __ addq(dest, 32);\n-    __ addq(source, 24);\n-    __ jmp(L_process32);\n-\n-    \/\/ Scalar data processing takes 3 bytes at a time and produces 4 bytes of encoded data\n-    \/* This code corresponds to the scalar version of the following snippet in Base64.java\n-    ** int bits = (src[sp0++] & 0xff) << 16 |(src[sp0++] & 0xff) << 8 |(src[sp0++] & 0xff);\n-    ** dst[dp0++] = (byte)base64[(bits >> > 18) & 0x3f];\n-    ** dst[dp0++] = (byte)base64[(bits >> > 12) & 0x3f];\n-    ** dst[dp0++] = (byte)base64[(bits >> > 6) & 0x3f];\n-    ** dst[dp0++] = (byte)base64[bits & 0x3f];*\/\n-    __ BIND(L_process3);\n-    __ cmpl(length, 3);\n-    __ jcc(Assembler::below, L_exit);\n-    \/\/ Read 1 byte at a time\n-    __ movzbl(rax, Address(source, start_offset));\n-    __ shll(rax, 0x10);\n-    __ movl(r15, rax);\n-    __ movzbl(rax, Address(source, start_offset, Address::times_1, 1));\n-    __ shll(rax, 0x8);\n-    __ movzwl(rax, rax);\n-    __ orl(r15, rax);\n-    __ movzbl(rax, Address(source, start_offset, Address::times_1, 2));\n-    __ orl(rax, r15);\n-    \/\/ Save 3 bytes read in r15\n-    __ movl(r15, rax);\n-    __ shrl(rax, 0x12);\n-    __ andl(rax, 0x3f);\n-    \/\/ rax contains the index, r11 contains base64 lookup table\n-    __ movb(rax, Address(r11, rax, Address::times_4));\n-    \/\/ Write the encoded byte to destination\n-    __ movb(Address(dest, dp, Address::times_1, 0), rax);\n-    __ movl(rax, r15);\n-    __ shrl(rax, 0xc);\n-    __ andl(rax, 0x3f);\n-    __ movb(rax, Address(r11, rax, Address::times_4));\n-    __ movb(Address(dest, dp, Address::times_1, 1), rax);\n-    __ movl(rax, r15);\n-    __ shrl(rax, 0x6);\n-    __ andl(rax, 0x3f);\n-    __ movb(rax, Address(r11, rax, Address::times_4));\n-    __ movb(Address(dest, dp, Address::times_1, 2), rax);\n-    __ movl(rax, r15);\n-    __ andl(rax, 0x3f);\n-    __ movb(rax, Address(r11, rax, Address::times_4));\n-    __ movb(Address(dest, dp, Address::times_1, 3), rax);\n-    __ subl(length, 3);\n-    __ addq(dest, 4);\n-    __ addq(source, 3);\n-    __ jmp(L_process3);\n-    __ BIND(L_exit);\n+    __ jmp(L_bottomLoop);\n+\n+    __ align(32);\n+    __ BIND(L_forceLoop);\n+    __ shll(byte1, 18);\n+    __ shll(byte2, 12);\n+    __ shll(byte3, 6);\n+    __ orl(byte1, byte2);\n+    __ orl(byte1, byte3);\n+    __ orl(byte1, byte4);\n+\n+    __ addptr(source, 4);\n+\n+    __ movb(Address(dest, dp, Address::times_1, 2), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 1), byte1);\n+    __ shrl(byte1, 8);\n+    __ movb(Address(dest, dp, Address::times_1, 0), byte1);\n+\n+    __ addptr(dest, 3);\n+    __ decrementl(length, 1);\n+    __ jcc(Assembler::zero, L_exit_no_vzero);\n+\n+    __ BIND(L_bottomLoop);\n+    __ load_unsigned_byte(byte1, Address(source, start_offset, Address::times_1, 0x00));\n+    __ load_unsigned_byte(byte2, Address(source, start_offset, Address::times_1, 0x01));\n+    __ load_signed_byte(byte1, Address(decode_table, byte1));\n+    __ load_signed_byte(byte2, Address(decode_table, byte2));\n+    __ load_unsigned_byte(byte3, Address(source, start_offset, Address::times_1, 0x02));\n+    __ load_unsigned_byte(byte4, Address(source, start_offset, Address::times_1, 0x03));\n+    __ load_signed_byte(byte3, Address(decode_table, byte3));\n+    __ load_signed_byte(byte4, Address(decode_table, byte4));\n+\n+    __ mov(rax, byte1);\n+    __ orl(rax, byte2);\n+    __ orl(rax, byte3);\n+    __ orl(rax, byte4);\n+    __ jcc(Assembler::positive, L_forceLoop);\n+\n+    __ BIND(L_exit_no_vzero);\n+    __ pop(rax);             \/\/ Get original dest value\n+    __ subptr(dest, rax);      \/\/ Number of bytes converted\n+    __ movptr(rax, dest);\n+    __ pop(rbx);\n@@ -5683,0 +6396,1 @@\n+\n@@ -5686,0 +6400,1 @@\n+\n@@ -6963,0 +7678,1 @@\n+\n@@ -6964,7 +7680,20 @@\n-      StubRoutines::x86::_and_mask = base64_and_mask_addr();\n-      StubRoutines::x86::_bswap_mask = base64_bswap_mask_addr();\n-      StubRoutines::x86::_base64_charset = base64_charset_addr();\n-      StubRoutines::x86::_url_charset = base64url_charset_addr();\n-      StubRoutines::x86::_gather_mask = base64_gather_mask_addr();\n-      StubRoutines::x86::_left_shift_mask = base64_left_shift_mask_addr();\n-      StubRoutines::x86::_right_shift_mask = base64_right_shift_mask_addr();\n+      if(VM_Version::supports_avx2() &&\n+         VM_Version::supports_avx512bw() &&\n+         VM_Version::supports_avx512vl()) {\n+        StubRoutines::x86::_avx2_shuffle_base64 = base64_avx2_shuffle_addr();\n+        StubRoutines::x86::_avx2_input_mask_base64 = base64_avx2_input_mask_addr();\n+        StubRoutines::x86::_avx2_lut_base64 = base64_avx2_lut_addr();\n+      }\n+      StubRoutines::x86::_encoding_table_base64 = base64_encoding_table_addr();\n+      if (VM_Version::supports_avx512_vbmi()) {\n+        StubRoutines::x86::_shuffle_base64 = base64_shuffle_addr();\n+        StubRoutines::x86::_lookup_lo_base64 = base64_vbmi_lookup_lo_addr();\n+        StubRoutines::x86::_lookup_hi_base64 = base64_vbmi_lookup_hi_addr();\n+        StubRoutines::x86::_lookup_lo_base64url = base64_vbmi_lookup_lo_url_addr();\n+        StubRoutines::x86::_lookup_hi_base64url = base64_vbmi_lookup_hi_url_addr();\n+        StubRoutines::x86::_pack_vec_base64 = base64_vbmi_pack_vec_addr();\n+        StubRoutines::x86::_join_0_1_base64 = base64_vbmi_join_0_1_addr();\n+        StubRoutines::x86::_join_1_2_base64 = base64_vbmi_join_1_2_addr();\n+        StubRoutines::x86::_join_2_3_base64 = base64_vbmi_join_2_3_addr();\n+      }\n+      StubRoutines::x86::_decoding_table_base64 = base64_decoding_table_addr();\n@@ -6972,0 +7701,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1053,"deletions":323,"binary":false,"changes":1376,"status":"modified"},{"patch":"@@ -68,7 +68,5 @@\n-address StubRoutines::x86::_bswap_mask = NULL;\n-address StubRoutines::x86::_base64_charset = NULL;\n-address StubRoutines::x86::_gather_mask = NULL;\n-address StubRoutines::x86::_right_shift_mask = NULL;\n-address StubRoutines::x86::_left_shift_mask = NULL;\n-address StubRoutines::x86::_and_mask = NULL;\n-address StubRoutines::x86::_url_charset = NULL;\n+address StubRoutines::x86::_encoding_table_base64 = NULL;\n+address StubRoutines::x86::_shuffle_base64 = NULL;\n+address StubRoutines::x86::_avx2_shuffle_base64 = NULL;\n+address StubRoutines::x86::_avx2_input_mask_base64 = NULL;\n+address StubRoutines::x86::_avx2_lut_base64 = NULL;\n@@ -76,0 +74,9 @@\n+address StubRoutines::x86::_lookup_lo_base64 = NULL;\n+address StubRoutines::x86::_lookup_hi_base64 = NULL;\n+address StubRoutines::x86::_lookup_lo_base64url = NULL;\n+address StubRoutines::x86::_lookup_hi_base64url = NULL;\n+address StubRoutines::x86::_pack_vec_base64 = NULL;\n+address StubRoutines::x86::_join_0_1_base64 = NULL;\n+address StubRoutines::x86::_join_1_2_base64 = NULL;\n+address StubRoutines::x86::_join_2_3_base64 = NULL;\n+address StubRoutines::x86::_decoding_table_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -187,7 +187,14 @@\n-  static address _base64_charset;\n-  static address _bswap_mask;\n-  static address _gather_mask;\n-  static address _right_shift_mask;\n-  static address _left_shift_mask;\n-  static address _and_mask;\n-  static address _url_charset;\n+  static address _encoding_table_base64;\n+  static address _shuffle_base64;\n+  static address _avx2_shuffle_base64;\n+  static address _avx2_input_mask_base64;\n+  static address _avx2_lut_base64;\n+  static address _lookup_lo_base64;\n+  static address _lookup_hi_base64;\n+  static address _lookup_lo_base64url;\n+  static address _lookup_hi_base64url;\n+  static address _pack_vec_base64;\n+  static address _join_0_1_base64;\n+  static address _join_1_2_base64;\n+  static address _join_2_3_base64;\n+  static address _decoding_table_base64;\n@@ -331,7 +338,5 @@\n-  static address base64_charset_addr() { return _base64_charset; }\n-  static address base64url_charset_addr() { return _url_charset; }\n-  static address base64_bswap_mask_addr() { return _bswap_mask; }\n-  static address base64_gather_mask_addr() { return _gather_mask; }\n-  static address base64_right_shift_mask_addr() { return _right_shift_mask; }\n-  static address base64_left_shift_mask_addr() { return _left_shift_mask; }\n-  static address base64_and_mask_addr() { return _and_mask; }\n+  static address base64_encoding_table_addr() { return _encoding_table_base64; }\n+  static address base64_shuffle_addr() { return _shuffle_base64; }\n+  static address base64_avx2_shuffle_addr() { return _avx2_shuffle_base64; }\n+  static address base64_avx2_input_mask_addr() { return _avx2_input_mask_base64; }\n+  static address base64_avx2_lut_addr() { return _avx2_lut_base64; }\n@@ -339,0 +344,9 @@\n+  static address base64_vbmi_lookup_lo_addr() { return _lookup_lo_base64; }\n+  static address base64_vbmi_lookup_hi_addr() { return _lookup_hi_base64; }\n+  static address base64_vbmi_lookup_lo_url_addr() { return _lookup_lo_base64url; }\n+  static address base64_vbmi_lookup_hi_url_addr() { return _lookup_hi_base64url; }\n+  static address base64_vbmi_pack_vec_addr() { return _pack_vec_base64; }\n+  static address base64_vbmi_join_0_1_addr() { return _join_0_1_base64; }\n+  static address base64_vbmi_join_1_2_addr() { return _join_1_2_base64; }\n+  static address base64_vbmi_join_2_3_addr() { return _join_2_3_base64; }\n+  static address base64_decoding_table_addr() { return _decoding_table_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4026,9 +4026,3 @@\n-    if (UseBiasedLocking) {\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-    } else {\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),\n-                (intptr_t)markWord::prototype().value()); \/\/ header\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-    }\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+              (intptr_t)markWord::prototype().value()); \/\/ header\n+    __ pop(rcx);   \/\/ get saved klass back in the register.\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -590,0 +590,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax and for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -782,0 +786,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1024,4 +1024,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n-    \/\/ VM_Version_init() is executed after UseBiasedLocking is used\n-    \/\/ in Thread::allocate().\n@@ -1035,2 +1031,0 @@\n-      \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-      \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1074,2 +1068,0 @@\n-    \/\/ Can't continue because UseRTMLocking affects UseBiasedLocking flag\n-    \/\/ setting during arguments processing. See use_biased_locking().\n@@ -1748,21 +1740,0 @@\n-bool VM_Version::use_biased_locking() {\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM locking is most useful when there is high lock contention and\n-  \/\/ low data contention.  With high lock contention the lock is usually\n-  \/\/ inflated and biased locking is not suitable for that case.\n-  \/\/ RTM locking code requires that biased locking is off.\n-  \/\/ Note: we can't switch off UseBiasedLocking in get_processor_features()\n-  \/\/ because it is used by Thread::allocate() which is called before\n-  \/\/ VM_Version::initialize().\n-  if (UseRTMLocking && UseBiasedLocking) {\n-    if (FLAG_IS_DEFAULT(UseBiasedLocking)) {\n-      FLAG_SET_DEFAULT(UseBiasedLocking, false);\n-    } else {\n-      warning(\"Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.\" );\n-      UseBiasedLocking = false;\n-    }\n-  }\n-#endif\n-  return UseBiasedLocking;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -750,3 +750,0 @@\n-  \/\/ Override Abstract_VM_Version implementation\n-  static bool use_biased_locking();\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1219,33 +1219,0 @@\n-\n-inline uint vector_length(const Node* n) {\n-  const TypeVect* vt = n->bottom_type()->is_vect();\n-  return vt->length();\n-}\n-\n-inline uint vector_length(const MachNode* use, MachOper* opnd) {\n-  uint def_idx = use->operand_index(opnd);\n-  Node* def = use->in(def_idx);\n-  return def->bottom_type()->is_vect()->length();\n-}\n-\n-inline uint vector_length_in_bytes(const Node* n) {\n-  const TypeVect* vt = n->bottom_type()->is_vect();\n-  return vt->length_in_bytes();\n-}\n-\n-inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n-  uint def_idx = use->operand_index(opnd);\n-  Node* def = use->in(def_idx);\n-  return def->bottom_type()->is_vect()->length_in_bytes();\n-}\n-\n-inline BasicType vector_element_basic_type(const Node *n) {\n-  return n->bottom_type()->is_vect()->element_basic_type();\n-}\n-\n-inline BasicType vector_element_basic_type(const MachNode *use, MachOper* opnd) {\n-  uint def_idx = use->operand_index(opnd);\n-  Node* def = use->in(def_idx);\n-  return def->bottom_type()->is_vect()->element_basic_type();\n-}\n-\n@@ -1268,1 +1235,1 @@\n-  return vector_length_encoding(vector_length_in_bytes(n));\n+  return vector_length_encoding(Matcher::vector_length_in_bytes(n));\n@@ -1876,1 +1843,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1880,0 +1847,8 @@\n+    case MoveF2VL_rule:\n+    case MoveF2LEG_rule:\n+    case MoveVL2F_rule:\n+    case MoveLEG2F_rule:\n+    case MoveD2VL_rule:\n+    case MoveD2LEG_rule:\n+    case MoveVL2D_rule:\n+    case MoveLEG2D_rule:\n@@ -1906,12 +1881,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n@@ -3341,1 +3304,1 @@\n-  predicate(vector_length_in_bytes(n) == vector_length_in_bytes(n->in(1))); \/\/ dst == src\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))); \/\/ dst == src\n@@ -3353,1 +3316,1 @@\n-            (vector_length_in_bytes(n->in(1)) < vector_length_in_bytes(n))); \/\/ src < dst\n+            (Matcher::vector_length_in_bytes(n->in(1)) < Matcher::vector_length_in_bytes(n))); \/\/ src < dst\n@@ -3359,2 +3322,2 @@\n-    assert(vector_length_in_bytes(this)       <= 16, \"required\");\n-    assert(vector_length_in_bytes(this, $src) <=  8, \"required\");\n+    assert(Matcher::vector_length_in_bytes(this)       <= 16, \"required\");\n+    assert(Matcher::vector_length_in_bytes(this, $src) <=  8, \"required\");\n@@ -3362,1 +3325,1 @@\n-    int src_vlen_in_bytes = vector_length_in_bytes(this, $src);\n+    int src_vlen_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n@@ -3376,2 +3339,2 @@\n-            (vector_length_in_bytes(n->in(1)) == 4) && \/\/ src\n-            (vector_length_in_bytes(n->in(1)) < vector_length_in_bytes(n))); \/\/ src < dst\n+            (Matcher::vector_length_in_bytes(n->in(1)) == 4) && \/\/ src\n+            (Matcher::vector_length_in_bytes(n->in(1)) < Matcher::vector_length_in_bytes(n))); \/\/ src < dst\n@@ -3391,2 +3354,2 @@\n-            (vector_length_in_bytes(n->in(1)) > 4) && \/\/ src\n-            (vector_length_in_bytes(n->in(1)) < vector_length_in_bytes(n))); \/\/ src < dst\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 4) && \/\/ src\n+            (Matcher::vector_length_in_bytes(n->in(1)) < Matcher::vector_length_in_bytes(n))); \/\/ src < dst\n@@ -3397,1 +3360,1 @@\n-    switch (vector_length_in_bytes(this, $src)) {\n+    switch (Matcher::vector_length_in_bytes(this, $src)) {\n@@ -3408,1 +3371,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) > vector_length_in_bytes(n)); \/\/ src > dst\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > Matcher::vector_length_in_bytes(n)); \/\/ src > dst\n@@ -3413,1 +3376,1 @@\n-    switch (vector_length_in_bytes(this)) {\n+    switch (Matcher::vector_length_in_bytes(this)) {\n@@ -3462,1 +3425,1 @@\n-  predicate(vector_length(n) < 8);\n+  predicate(Matcher::vector_length(n) < 8);\n@@ -3474,1 +3437,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -3485,1 +3448,1 @@\n-  predicate(vector_length(n) < 8);\n+  predicate(Matcher::vector_length(n) < 8);\n@@ -3497,1 +3460,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -3575,1 +3538,1 @@\n-    switch (vector_length_in_bytes(this)) {\n+    switch (Matcher::vector_length_in_bytes(this)) {\n@@ -3593,1 +3556,1 @@\n-    switch (vector_length_in_bytes(this, $src)) {\n+    switch (Matcher::vector_length_in_bytes(this, $src)) {\n@@ -3610,1 +3573,1 @@\n-  predicate(vector_length_in_bytes(n) <= 32);\n+  predicate(Matcher::vector_length_in_bytes(n) <= 32);\n@@ -3618,1 +3581,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -3620,1 +3583,1 @@\n-    assert(vector_length_in_bytes(this) >= 16, \"sanity\");\n+    assert(Matcher::vector_length_in_bytes(this) >= 16, \"sanity\");\n@@ -3635,1 +3598,1 @@\n-  predicate(vector_length_in_bytes(n) == 64);\n+  predicate(Matcher::vector_length_in_bytes(n) == 64);\n@@ -3643,1 +3606,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -3665,1 +3628,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this, $src);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n@@ -3667,1 +3630,1 @@\n-    assert(vector_length_in_bytes(this, $src) >= 16, \"sanity\");\n+    assert(Matcher::vector_length_in_bytes(this, $src) >= 16, \"sanity\");\n@@ -3684,1 +3647,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3724,1 +3687,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3749,1 +3712,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3767,1 +3730,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3806,1 +3769,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3830,1 +3793,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3847,1 +3810,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3871,1 +3834,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3888,1 +3851,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3910,1 +3873,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3943,1 +3906,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3967,1 +3930,1 @@\n-  predicate(vector_length(n) <= 4);\n+  predicate(Matcher::vector_length(n) <= 4);\n@@ -3972,1 +3935,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -3996,1 +3959,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -4024,1 +3987,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4042,1 +4005,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4061,1 +4024,1 @@\n-    int vlen = vector_length(this);\n+    int vlen = Matcher::vector_length(this);\n@@ -4090,1 +4053,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4109,1 +4072,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4126,1 +4089,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4144,1 +4107,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4163,1 +4126,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4180,1 +4143,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -4194,1 +4157,1 @@\n-  predicate(vector_length_in_bytes(n) < 32);\n+  predicate(Matcher::vector_length_in_bytes(n) < 32);\n@@ -4199,1 +4162,1 @@\n-    assert(vector_length_in_bytes(this) >= 8, \"required\");\n+    assert(Matcher::vector_length_in_bytes(this) >= 8, \"required\");\n@@ -4201,1 +4164,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -4204,1 +4167,1 @@\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4212,1 +4175,1 @@\n-  predicate(vector_length_in_bytes(n) == 32);\n+  predicate(Matcher::vector_length_in_bytes(n) == 32);\n@@ -4218,1 +4181,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -4223,1 +4186,1 @@\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4235,1 +4198,1 @@\n-  predicate(vector_length_in_bytes(n) == 64);\n+  predicate(Matcher::vector_length_in_bytes(n) == 64);\n@@ -4242,1 +4205,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -4247,1 +4210,1 @@\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4260,1 +4223,1 @@\n-  predicate(vector_length(n) == 2);\n+  predicate(Matcher::vector_length(n) == 2);\n@@ -4265,2 +4228,2 @@\n-    assert(vector_element_basic_type(this) == T_LONG, \"\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_LONG, \"\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4274,1 +4237,1 @@\n-  predicate(vector_length(n) == 4);\n+  predicate(Matcher::vector_length(n) == 4);\n@@ -4279,2 +4242,2 @@\n-    assert(vector_element_basic_type(this) == T_LONG, \"\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_LONG, \"\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4293,1 +4256,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -4298,2 +4261,2 @@\n-    assert(vector_element_basic_type(this) == T_LONG, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_LONG, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4312,1 +4275,1 @@\n-  predicate(vector_length(n) < 8);\n+  predicate(Matcher::vector_length(n) < 8);\n@@ -4318,2 +4281,2 @@\n-    assert(vector_element_basic_type(this) == T_FLOAT, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_FLOAT, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4327,1 +4290,1 @@\n-  predicate(vector_length(n) >= 8);\n+  predicate(Matcher::vector_length(n) >= 8);\n@@ -4332,2 +4295,2 @@\n-    assert(vector_element_basic_type(this) == T_FLOAT, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_FLOAT, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4335,1 +4298,1 @@\n-    int vlen = vector_length(this);\n+    int vlen = Matcher::vector_length(this);\n@@ -4356,1 +4319,1 @@\n-  predicate(vector_length(n) == 2);\n+  predicate(Matcher::vector_length(n) == 2);\n@@ -4362,2 +4325,2 @@\n-    assert(vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4372,1 +4335,1 @@\n-  predicate(vector_length(n) == 4);\n+  predicate(Matcher::vector_length(n) == 4);\n@@ -4377,2 +4340,2 @@\n-    assert(vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4392,1 +4355,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -4397,2 +4360,2 @@\n-    assert(vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n-    assert($idx$$constant < (int)vector_length(this), \"out of bounds\");\n+    assert(Matcher::vector_element_basic_type(this) == T_DOUBLE, \"sanity\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this), \"out of bounds\");\n@@ -4416,1 +4379,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_INT); \/\/ src2\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_INT); \/\/ src2\n@@ -4428,1 +4391,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4438,1 +4401,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG && !VM_Version::supports_avx512dq());\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG && !VM_Version::supports_avx512dq());\n@@ -4450,1 +4413,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4457,1 +4420,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG && VM_Version::supports_avx512dq());\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_LONG && VM_Version::supports_avx512dq());\n@@ -4469,1 +4432,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4479,1 +4442,1 @@\n-  predicate(vector_length(n->in(2)) <= 4); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) <= 4); \/\/ src\n@@ -4486,1 +4449,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4493,1 +4456,1 @@\n-  predicate(vector_length(n->in(2)) == 8); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) == 8); \/\/ src\n@@ -4500,1 +4463,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4507,1 +4470,1 @@\n-  predicate(vector_length(n->in(2)) == 16); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) == 16); \/\/ src\n@@ -4514,1 +4477,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4523,1 +4486,1 @@\n-  predicate(vector_length(n->in(2)) == 2); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) == 2); \/\/ src\n@@ -4530,1 +4493,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4537,1 +4500,1 @@\n-  predicate(vector_length(n->in(2)) == 4); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) == 4); \/\/ src\n@@ -4544,1 +4507,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4551,1 +4514,1 @@\n-  predicate(vector_length(n->in(2)) == 8); \/\/ src\n+  predicate(Matcher::vector_length(n->in(2)) == 8); \/\/ src\n@@ -4558,1 +4521,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4568,1 +4531,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && !VM_Version::supports_avx512bw());\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE && !VM_Version::supports_avx512bw());\n@@ -4579,1 +4542,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4586,1 +4549,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && VM_Version::supports_avx512bw());\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE && VM_Version::supports_avx512bw());\n@@ -4597,1 +4560,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4607,1 +4570,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_SHORT); \/\/ src2\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_SHORT); \/\/ src2\n@@ -4619,1 +4582,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4628,2 +4591,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) <= 32); \/\/ src2\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE &&\n+            Matcher::vector_length(n->in(2)) <= 32); \/\/ src2\n@@ -4635,1 +4598,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4642,2 +4605,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) == 64); \/\/ src2\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_BYTE &&\n+            Matcher::vector_length(n->in(2)) == 64); \/\/ src2\n@@ -4649,1 +4612,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4659,1 +4622,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -4662,1 +4625,1 @@\n-            vector_length(n->in(2)) == 2);\n+            Matcher::vector_length(n->in(2)) == 2);\n@@ -4671,1 +4634,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4680,1 +4643,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -4683,1 +4646,1 @@\n-            vector_length(n->in(2)) >= 4);\n+            Matcher::vector_length(n->in(2)) >= 4);\n@@ -4692,1 +4655,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4701,2 +4664,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_FLOAT &&\n-            vector_length(n->in(2)) == 2);\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) == 2);\n@@ -4711,1 +4674,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4721,2 +4684,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_FLOAT &&\n-            vector_length(n->in(2)) >= 4);\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n@@ -4731,1 +4694,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4743,1 +4706,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -4746,1 +4709,1 @@\n-            vector_length(n->in(2)) == 2);\n+            Matcher::vector_length(n->in(2)) == 2);\n@@ -4755,1 +4718,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4765,1 +4728,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -4768,1 +4731,1 @@\n-            vector_length(n->in(2)) >= 4);\n+            Matcher::vector_length(n->in(2)) >= 4);\n@@ -4777,1 +4740,1 @@\n-    int vlen = vector_length(this, $src2);\n+    int vlen = Matcher::vector_length(this, $src2);\n@@ -4788,2 +4751,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n-            vector_length(n->in(2)) == 2);\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) == 2);\n@@ -4798,1 +4761,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4808,2 +4771,2 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n-            vector_length(n->in(2)) >= 4);\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n@@ -4818,1 +4781,1 @@\n-    int vlen = vector_length(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4853,1 +4816,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -4887,1 +4850,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -4922,1 +4885,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -4956,1 +4919,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -4990,1 +4953,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5024,1 +4987,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5060,1 +5023,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5095,1 +5058,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5129,1 +5092,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5164,1 +5127,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5198,1 +5161,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5232,1 +5195,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5246,2 +5209,2 @@\n-  predicate(vector_length(n) == 4 ||\n-            vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 4 ||\n+            Matcher::vector_length(n) == 8);\n@@ -5264,1 +5227,1 @@\n-  predicate(vector_length(n) == 16 && UseAVX <= 1);\n+  predicate(Matcher::vector_length(n) == 16 && UseAVX <= 1);\n@@ -5287,1 +5250,1 @@\n-  predicate(vector_length(n) == 16 && UseAVX > 1);\n+  predicate(Matcher::vector_length(n) == 16 && UseAVX > 1);\n@@ -5305,1 +5268,1 @@\n-  predicate(vector_length(n) == 32);\n+  predicate(Matcher::vector_length(n) == 32);\n@@ -5331,1 +5294,1 @@\n-  predicate(vector_length(n) == 64);\n+  predicate(Matcher::vector_length(n) == 64);\n@@ -5381,1 +5344,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5416,1 +5379,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5441,1 +5404,1 @@\n-              (vector_length_in_bytes(n->in(1)) > 8));\n+              (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5453,1 +5416,1 @@\n-  predicate(vector_length(n) == 2 && !VM_Version::supports_avx512dq());\n+  predicate(Matcher::vector_length(n) == 2 && !VM_Version::supports_avx512dq());\n@@ -5479,1 +5442,1 @@\n-  predicate(vector_length(n) == 4 && !VM_Version::supports_avx512dq());\n+  predicate(Matcher::vector_length(n) == 4 && !VM_Version::supports_avx512dq());\n@@ -5527,1 +5490,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5561,1 +5524,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5572,1 +5535,1 @@\n-  predicate(vector_length(n) == 8);\n+  predicate(Matcher::vector_length(n) == 8);\n@@ -5590,1 +5553,1 @@\n-  predicate(vector_length(n) == 4);\n+  predicate(Matcher::vector_length(n) == 4);\n@@ -5633,1 +5596,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5667,1 +5630,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -5681,1 +5644,1 @@\n-  predicate(is_integral_type(vector_element_basic_type(n)) && vector_element_basic_type(n) != T_LONG && \/\/ T_BYTE, T_SHORT, T_INT\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_element_basic_type(n) != T_LONG && \/\/ T_BYTE, T_SHORT, T_INT\n@@ -5690,1 +5653,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5697,1 +5660,1 @@\n-  predicate(is_integral_type(vector_element_basic_type(n)) && vector_element_basic_type(n) != T_LONG && \/\/ T_BYTE, T_SHORT, T_INT\n+  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_element_basic_type(n) != T_LONG && \/\/ T_BYTE, T_SHORT, T_INT\n@@ -5705,1 +5668,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5714,1 +5677,1 @@\n-  predicate(vector_length_in_bytes(n) == 16 && vector_element_basic_type(n) == T_LONG &&\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 && Matcher::vector_element_basic_type(n) == T_LONG &&\n@@ -5724,1 +5687,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5733,1 +5696,1 @@\n-  predicate(vector_length_in_bytes(n) <= 32 && vector_element_basic_type(n) == T_LONG &&\n+  predicate(Matcher::vector_length_in_bytes(n) <= 32 && Matcher::vector_element_basic_type(n) == T_LONG &&\n@@ -5742,1 +5705,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5751,2 +5714,2 @@\n-  predicate((vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()) &&\n-            vector_element_basic_type(n) == T_LONG);\n+  predicate((Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()) &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -5761,1 +5724,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5771,2 +5734,2 @@\n-  predicate(vector_length_in_bytes(n) <= 32 &&\n-            is_floating_point_type(vector_element_basic_type(n)) && \/\/ T_FLOAT, T_DOUBLE\n+  predicate(Matcher::vector_length_in_bytes(n) <= 32 &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n)) && \/\/ T_FLOAT, T_DOUBLE\n@@ -5783,1 +5746,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5793,2 +5756,2 @@\n-  predicate(vector_length_in_bytes(n) == 64 &&\n-            is_floating_point_type(vector_element_basic_type(n))); \/\/ T_FLOAT, T_DOUBLE\n+  predicate(Matcher::vector_length_in_bytes(n) == 64 &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n))); \/\/ T_FLOAT, T_DOUBLE\n@@ -5804,1 +5767,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -5851,1 +5814,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) > 8);\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n@@ -5875,1 +5838,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) > 8);\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n@@ -5902,1 +5865,1 @@\n-  predicate(vector_length(n) <= 8 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) <= 8 && VectorNode::is_vshift_cnt(n->in(2)));\n@@ -5922,1 +5885,1 @@\n-  predicate(vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n@@ -5947,1 +5910,1 @@\n-  predicate(vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n@@ -5968,1 +5931,1 @@\n-  predicate(vector_length(n) == 32 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 32 && VectorNode::is_vshift_cnt(n->in(2)));\n@@ -5993,1 +5956,1 @@\n-  predicate(vector_length(n) == 64 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 64 && VectorNode::is_vshift_cnt(n->in(2)));\n@@ -6038,1 +6001,1 @@\n-      int vlen = vector_length(this);\n+      int vlen = Matcher::vector_length(this);\n@@ -6069,1 +6032,1 @@\n-      int vlen = vector_length(this);\n+      int vlen = Matcher::vector_length(this);\n@@ -6095,1 +6058,1 @@\n-      int vlen = vector_length(this);\n+      int vlen = Matcher::vector_length(this);\n@@ -6122,1 +6085,1 @@\n-      assert(vector_length(this) == 2, \"\");\n+      assert(Matcher::vector_length(this) == 2, \"\");\n@@ -6141,1 +6104,1 @@\n-      assert(vector_length(this) == 2, \"\");\n+      assert(Matcher::vector_length(this) == 2, \"\");\n@@ -6157,1 +6120,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -6194,1 +6157,1 @@\n-  predicate(vector_length(n) <= 8 &&\n+  predicate(Matcher::vector_length(n) <= 8 &&\n@@ -6214,1 +6177,1 @@\n-  predicate(vector_length(n) == 16 &&\n+  predicate(Matcher::vector_length(n) == 16 &&\n@@ -6242,1 +6205,1 @@\n-  predicate(vector_length(n) == 32 &&\n+  predicate(Matcher::vector_length(n) == 32 &&\n@@ -6278,1 +6241,1 @@\n-  predicate(vector_length(n) <= 32 &&\n+  predicate(Matcher::vector_length(n) <= 32 &&\n@@ -6297,1 +6260,1 @@\n-  predicate(vector_length(n) == 64 &&\n+  predicate(Matcher::vector_length(n) == 64 &&\n@@ -6321,1 +6284,1 @@\n-  predicate(vector_length(n) <= 8 &&\n+  predicate(Matcher::vector_length(n) <= 8 &&\n@@ -6346,1 +6309,1 @@\n-  predicate(vector_length(n) == 16 &&\n+  predicate(Matcher::vector_length(n) == 16 &&\n@@ -6436,1 +6399,1 @@\n-  predicate(vector_length(n) <= 4 &&\n+  predicate(Matcher::vector_length(n) <= 4 &&\n@@ -6489,1 +6452,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -6524,1 +6487,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -6559,1 +6522,1 @@\n-            (vector_length_in_bytes(n->in(1)) > 8));\n+            (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n@@ -6577,1 +6540,1 @@\n-    BasicType to_elem_bt = vector_element_basic_type(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n@@ -6606,2 +6569,2 @@\n-            vector_length(n->in(1)) <= 8 && \/\/ src\n-            vector_element_basic_type(n) == T_BYTE);\n+            Matcher::vector_length(n->in(1)) <= 8 && \/\/ src\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -6622,2 +6585,2 @@\n-            vector_length(n->in(1)) == 16 && \/\/ src\n-            vector_element_basic_type(n) == T_BYTE);\n+            Matcher::vector_length(n->in(1)) == 16 && \/\/ src\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -6630,1 +6593,1 @@\n-    int vlen_enc = vector_length_encoding(vector_length_in_bytes(this, $src));\n+    int vlen_enc = vector_length_encoding(Matcher::vector_length_in_bytes(this, $src));\n@@ -6640,1 +6603,1 @@\n-            (vector_length_in_bytes(n) >= vector_length_in_bytes(n->in(1)))); \/\/ dst >= src\n+            (Matcher::vector_length_in_bytes(n) >= Matcher::vector_length_in_bytes(n->in(1)))); \/\/ dst >= src\n@@ -6644,1 +6607,1 @@\n-    BasicType to_elem_bt = vector_element_basic_type(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n@@ -6677,2 +6640,2 @@\n-            (vector_length_in_bytes(n->in(1)) <= 16) &&\n-            (vector_length_in_bytes(n) < vector_length_in_bytes(n->in(1)))); \/\/ dst < src\n+            (Matcher::vector_length_in_bytes(n->in(1)) <= 16) &&\n+            (Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)))); \/\/ dst < src\n@@ -6685,1 +6648,1 @@\n-    BasicType to_elem_bt = vector_element_basic_type(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n@@ -6703,2 +6666,2 @@\n-            (vector_length_in_bytes(n->in(1)) == 32) &&\n-            (vector_length_in_bytes(n) < vector_length_in_bytes(n->in(1)))); \/\/ dst < src\n+            (Matcher::vector_length_in_bytes(n->in(1)) == 32) &&\n+            (Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)))); \/\/ dst < src\n@@ -6711,1 +6674,1 @@\n-    BasicType to_elem_bt = vector_element_basic_type(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n@@ -6731,1 +6694,1 @@\n-            (vector_length_in_bytes(n) >= vector_length_in_bytes(n->in(1)))); \/\/ dst >= src\n+            (Matcher::vector_length_in_bytes(n) >= Matcher::vector_length_in_bytes(n->in(1)))); \/\/ dst >= src\n@@ -6737,1 +6700,1 @@\n-    BasicType dst_elem_bt = vector_element_basic_type(this);\n+    BasicType dst_elem_bt = Matcher::vector_element_basic_type(this);\n@@ -6770,1 +6733,1 @@\n-  predicate((vector_element_basic_type(n) == T_BYTE || vector_element_basic_type(n) == T_SHORT) &&\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE || Matcher::vector_element_basic_type(n) == T_SHORT) &&\n@@ -6778,2 +6741,2 @@\n-    int vlen = vector_length_in_bytes(this, $src);\n-    BasicType to_elem_bt  = vector_element_basic_type(this);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src);\n+    BasicType to_elem_bt  = Matcher::vector_element_basic_type(this);\n@@ -6802,3 +6765,3 @@\n-            (vector_element_basic_type(n) == T_INT ||\n-             vector_element_basic_type(n) == T_FLOAT ||\n-             vector_element_basic_type(n) == T_DOUBLE));\n+            (Matcher::vector_element_basic_type(n) == T_INT ||\n+             Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+             Matcher::vector_element_basic_type(n) == T_DOUBLE));\n@@ -6808,2 +6771,2 @@\n-    BasicType to_elem_bt = vector_element_basic_type(this);\n-    int vlen = vector_length_in_bytes(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src);\n@@ -6861,1 +6824,1 @@\n-  predicate(vector_element_basic_type(n) == T_DOUBLE);\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -6872,1 +6835,1 @@\n-  predicate(vector_element_basic_type(n) == T_FLOAT);\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n@@ -6885,3 +6848,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n-            vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n-            is_floating_point_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1 T_FLOAT, T_DOUBLE\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n+            is_floating_point_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1 T_FLOAT, T_DOUBLE\n@@ -6893,1 +6856,1 @@\n-    if (vector_element_basic_type(this, $src1) == T_FLOAT) {\n+    if (Matcher::vector_element_basic_type(this, $src1) == T_FLOAT) {\n@@ -6903,2 +6866,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n-            is_floating_point_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1 T_FLOAT, T_DOUBLE\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+            is_floating_point_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1 T_FLOAT, T_DOUBLE\n@@ -6912,1 +6875,1 @@\n-    if (vector_element_basic_type(this, $src1) == T_FLOAT) {\n+    if (Matcher::vector_element_basic_type(this, $src1) == T_FLOAT) {\n@@ -6926,3 +6889,3 @@\n-            vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n-            vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n-            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 32 && \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n@@ -6935,1 +6898,1 @@\n-    Assembler::Width ww = widthForType(vector_element_basic_type(this, $src1));\n+    Assembler::Width ww = widthForType(Matcher::vector_element_basic_type(this, $src1));\n@@ -6944,3 +6907,3 @@\n-            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n-            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n-            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n@@ -6951,1 +6914,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -6953,1 +6916,1 @@\n-    BasicType bt = vector_element_basic_type(this, $src1);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -6963,2 +6926,2 @@\n-            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n-            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n+            is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n@@ -6969,1 +6932,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -6971,1 +6934,1 @@\n-    BasicType bt = vector_element_basic_type(this, $src1);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -6981,2 +6944,2 @@\n-             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n-             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+             Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(Matcher::vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n@@ -6994,1 +6957,1 @@\n-    BasicType src1_elem_bt = vector_element_basic_type(this, $src1);\n+    BasicType src1_elem_bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -7026,1 +6989,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) <= 16); \/\/ src\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) <= 16); \/\/ src\n@@ -7034,1 +6997,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7036,1 +6999,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this, $src);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n@@ -7043,2 +7006,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)) == 32 || \/\/ src\n-            vector_length_in_bytes(n->in(1)) == 64);  \/\/ src\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) == 32 || \/\/ src\n+            Matcher::vector_length_in_bytes(n->in(1)) == 64);  \/\/ src\n@@ -7053,1 +7016,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7055,1 +7018,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this, $src);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n@@ -7064,1 +7027,1 @@\n-  predicate(vector_length(n->in(1)) <= 2); \/\/ src\n+  predicate(Matcher::vector_length(n->in(1)) <= 2); \/\/ src\n@@ -7069,1 +7032,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7077,2 +7040,2 @@\n-  predicate(vector_length(n->in(1)) == 4 || \/\/ src\n-            vector_length(n->in(1)) == 8);  \/\/ src\n+  predicate(Matcher::vector_length(n->in(1)) == 4 || \/\/ src\n+            Matcher::vector_length(n->in(1)) == 8);  \/\/ src\n@@ -7083,1 +7046,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7093,1 +7056,1 @@\n-  predicate(vector_length(n->in(1)) <= 4);\n+  predicate(Matcher::vector_length(n->in(1)) <= 4);\n@@ -7098,1 +7061,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7106,2 +7069,2 @@\n-  predicate(vector_length(n->in(1)\/*src*\/) == 8 ||\n-            vector_length(n->in(1)\/*src*\/) == 16);\n+  predicate(Matcher::vector_length(n->in(1)\/*src*\/) == 8 ||\n+            Matcher::vector_length(n->in(1)\/*src*\/) == 16);\n@@ -7112,1 +7075,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7121,1 +7084,1 @@\n-  predicate(vector_length(n->in(1)) == 2); \/\/ src\n+  predicate(Matcher::vector_length(n->in(1)) == 2); \/\/ src\n@@ -7125,1 +7088,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7133,2 +7096,2 @@\n-  predicate(vector_length(n->in(1)) == 4 || \/\/ src\n-            vector_length(n->in(1)) == 8);  \/\/ src\n+  predicate(Matcher::vector_length(n->in(1)) == 4 || \/\/ src\n+            Matcher::vector_length(n->in(1)) == 8);  \/\/ src\n@@ -7139,1 +7102,1 @@\n-    assert($idx$$constant < (int)vector_length(this, $src), \"out of bounds\");\n+    assert($idx$$constant < (int)Matcher::vector_length(this, $src), \"out of bounds\");\n@@ -7167,2 +7130,2 @@\n-            vector_length_in_bytes(n) <= 32 &&\n-            is_integral_type(vector_element_basic_type(n)));\n+            Matcher::vector_length_in_bytes(n) <= 32 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7180,2 +7143,2 @@\n-            vector_length_in_bytes(n) <= 32 &&\n-            !is_integral_type(vector_element_basic_type(n)));\n+            Matcher::vector_length_in_bytes(n) <= 32 &&\n+            !is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7192,1 +7155,1 @@\n-  predicate(vector_length_in_bytes(n) == 64);\n+  predicate(Matcher::vector_length_in_bytes(n) == 64);\n@@ -7198,1 +7161,1 @@\n-     BasicType elem_bt = vector_element_basic_type(this);\n+     BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -7211,1 +7174,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -7226,1 +7189,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -7241,1 +7204,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -7269,1 +7232,1 @@\n-  predicate(vector_length(n) != 4); \/\/ handled by 1-operand instruction vabsneg4F\n+  predicate(Matcher::vector_length(n) != 4); \/\/ handled by 1-operand instruction vabsneg4F\n@@ -7277,1 +7240,1 @@\n-    int vlen = vector_length(this);\n+    int vlen = Matcher::vector_length(this);\n@@ -7290,1 +7253,1 @@\n-  predicate(vector_length(n) == 4);\n+  predicate(Matcher::vector_length(n) == 4);\n@@ -7310,1 +7273,1 @@\n-    uint vlen = vector_length(this);\n+    uint vlen = Matcher::vector_length(this);\n@@ -7326,2 +7289,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)) >= 4 &&\n-            vector_length_in_bytes(n->in(1)) < 16 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n@@ -7333,1 +7296,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7342,2 +7305,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)) >= 16 &&\n-            vector_length_in_bytes(n->in(1)) <  64 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <  64 &&\n@@ -7349,1 +7312,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7358,1 +7321,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) == 64 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) == 64 &&\n@@ -7364,1 +7327,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7373,2 +7336,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)) >= 4 &&\n-            vector_length_in_bytes(n->in(1)) < 16 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n@@ -7380,1 +7343,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7389,2 +7352,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)) >= 16 &&\n-            vector_length_in_bytes(n->in(1)) < 64  &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64  &&\n@@ -7396,1 +7359,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7405,1 +7368,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) == 64 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) == 64 &&\n@@ -7411,1 +7374,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7420,2 +7383,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n-            vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n@@ -7427,1 +7390,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7434,2 +7397,2 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n-            vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n@@ -7440,1 +7403,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7447,1 +7410,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 &&\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) == 64 &&\n@@ -7453,1 +7416,1 @@\n-    int vlen = vector_length_in_bytes(this, $src1);\n+    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n@@ -7468,2 +7431,2 @@\n-    int vlen_in_bytes = vector_length_in_bytes(this);\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -7482,2 +7445,2 @@\n-    int vlen_in_bytes = vector_length_in_bytes(this);\n-    BasicType elem_bt = vector_element_basic_type(this);\n+    int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n@@ -7493,1 +7456,1 @@\n-  predicate(vector_length(n) < 64 || VM_Version::supports_avx512vlbw());\n+  predicate(Matcher::vector_length(n) < 64 || VM_Version::supports_avx512vlbw());\n@@ -7498,1 +7461,1 @@\n-    if (vector_length_in_bytes(this) <= 16) {\n+    if (Matcher::vector_length_in_bytes(this) <= 16) {\n@@ -7510,1 +7473,1 @@\n-  predicate(vector_length(n) <= 8);\n+  predicate(Matcher::vector_length(n) <= 8);\n@@ -7522,1 +7485,1 @@\n-  predicate(vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n+  predicate(Matcher::vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n@@ -7549,1 +7512,1 @@\n-  predicate (vector_length(n) <= 4 && UseAVX <= 2);\n+  predicate(Matcher::vector_length(n) <= 4 && UseAVX <= 2);\n@@ -7562,1 +7525,1 @@\n-  predicate(vector_length(n) == 8 && UseAVX <= 2);\n+  predicate(Matcher::vector_length(n) == 8 && UseAVX <= 2);\n@@ -7593,1 +7556,1 @@\n-  predicate(vector_length(n) == 2 && UseAVX <= 2);\n+  predicate(Matcher::vector_length(n) == 2 && UseAVX <= 2);\n@@ -7607,1 +7570,1 @@\n-  predicate(vector_length(n) == 4 && UseAVX <= 2);\n+  predicate(Matcher::vector_length(n) == 4 && UseAVX <= 2);\n@@ -7640,2 +7603,2 @@\n-  predicate((vector_length(n) == vector_length(n->in(1))) &&\n-            (vector_length_in_bytes(n) == vector_length_in_bytes(n->in(1))));\n+  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n+            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n@@ -7654,1 +7617,1 @@\n-  predicate(vector_element_basic_type(n) == T_BYTE);\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -7659,1 +7622,1 @@\n-     int vlen_in_bytes = vector_length_in_bytes(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -7670,1 +7633,1 @@\n-  predicate(vector_element_basic_type(n) == T_BYTE);\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -7680,2 +7643,2 @@\n-  predicate(vector_element_basic_type(n) == T_BYTE &&\n-            vector_length(n) < 32);\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            Matcher::vector_length(n) < 32);\n@@ -7692,2 +7655,2 @@\n-  predicate(vector_element_basic_type(n) == T_BYTE &&\n-            vector_length(n) == 32 && !VM_Version::supports_avx512_vbmi());\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            Matcher::vector_length(n) == 32 && !VM_Version::supports_avx512_vbmi());\n@@ -7714,2 +7677,2 @@\n-  predicate(vector_element_basic_type(n) == T_BYTE &&\n-            vector_length(n) >= 32 && VM_Version::supports_avx512_vbmi());\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            Matcher::vector_length(n) >= 32 && VM_Version::supports_avx512_vbmi());\n@@ -7728,2 +7691,2 @@\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n-            vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n+            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -7736,1 +7699,1 @@\n-    int vlen_in_bytes = vector_length_in_bytes(this);\n+    int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -7770,2 +7733,2 @@\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n-            vector_length(n) <= 8 && !VM_Version::supports_avx512bw());\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n+            Matcher::vector_length(n) <= 8 && !VM_Version::supports_avx512bw());\n@@ -7782,2 +7745,2 @@\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n-            vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n+            Matcher::vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n@@ -7804,1 +7767,1 @@\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n@@ -7819,1 +7782,1 @@\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n@@ -7836,2 +7799,2 @@\n-  predicate((vector_element_basic_type(n) == T_INT || vector_element_basic_type(n) == T_FLOAT) &&\n-            vector_length(n) == 4 && UseAVX < 2);\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n+            Matcher::vector_length(n) == 4 && UseAVX < 2);\n@@ -7866,2 +7829,2 @@\n- predicate((vector_element_basic_type(n) == T_INT || vector_element_basic_type(n) == T_FLOAT) &&\n-           vector_length(n) == 4 && UseAVX < 2);\n+ predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n+           Matcher::vector_length(n) == 4 && UseAVX < 2);\n@@ -7878,1 +7841,1 @@\n-  predicate((vector_element_basic_type(n) == T_INT || vector_element_basic_type(n) == T_FLOAT) &&\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n@@ -7890,1 +7853,1 @@\n-  predicate((vector_element_basic_type(n) == T_INT || vector_element_basic_type(n) == T_FLOAT) &&\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n@@ -7907,2 +7870,2 @@\n-  predicate(is_double_word_type(vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            vector_length(n) < 8 && !VM_Version::supports_avx512vl());\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            Matcher::vector_length(n) < 8 && !VM_Version::supports_avx512vl());\n@@ -7934,2 +7897,2 @@\n-  predicate(is_double_word_type(vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            vector_length(n) < 8 && !VM_Version::supports_avx512vl());\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            Matcher::vector_length(n) < 8 && !VM_Version::supports_avx512vl());\n@@ -7948,2 +7911,2 @@\n-  predicate(is_double_word_type(vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n@@ -7962,2 +7925,2 @@\n-  predicate(is_double_word_type(vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n@@ -7994,1 +7957,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) > 8);\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n@@ -8019,1 +7982,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)) > 8);\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n@@ -8097,1 +8060,1 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) > 8);\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(1)) > 8);\n@@ -8144,1 +8107,1 @@\n-    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+    assert(Matcher::vector_element_basic_type(this, $src1) == Matcher::vector_element_basic_type(this, $src2), \"mismatch\");\n@@ -8148,1 +8111,1 @@\n-    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8216,1 +8179,1 @@\n-    int mask_len = vector_length(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8232,1 +8195,1 @@\n-    int mask_len = vector_length(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8247,1 +8210,1 @@\n-    int mask_len = vector_length(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8263,1 +8226,1 @@\n-    int mask_len = vector_length(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":380,"deletions":417,"binary":false,"changes":797,"status":"modified"},{"patch":"@@ -1443,0 +1443,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 6 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 6 : FLOATPRESSURE;\n+}\n+\n@@ -5014,0 +5024,83 @@\n+\/\/ Dummy reg-to-reg vector moves. Removed during post-selection cleanup.\n+\/\/ Load Float\n+instruct MoveF2LEG(legRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveLEG2F(regF dst, legRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveF2VL(vlRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveVL2F(regF dst, vlRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\n+\n+\/\/ Load Double\n+instruct MoveD2LEG(legRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveLEG2D(regD dst, legRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveD2VL(vlRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveVL2D(regD dst, vlRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n@@ -5759,40 +5852,0 @@\n-\/\/ Load Float\n-instruct MoveF2LEG(legRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveLEG2F(regF dst, legRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveD2LEG(legRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveLEG2D(regD dst, legRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -6428,20 +6481,0 @@\n-\/\/ Load Double\n-instruct MoveD2VL(vlRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveVL2D(regD dst, vlRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -6461,19 +6494,0 @@\n-\/\/ Load Float\n-instruct MoveF2VL(vlRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveVL2F(regF dst, vlRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n@@ -13668,1 +13682,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -13683,1 +13697,1 @@\n-                 $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":95,"deletions":81,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+extern RegMask _FLOAT_REG_mask;\n@@ -353,0 +354,1 @@\n+RegMask _FLOAT_REG_mask;\n@@ -428,0 +430,4 @@\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+\n@@ -1761,0 +1767,14 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n+}\n+\n@@ -4803,0 +4823,81 @@\n+\/\/ Dummy reg-to-reg vector moves. Removed during post-selection cleanup.\n+\/\/ Load Float\n+instruct MoveF2VL(vlRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveF2LEG(legRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveVL2F(regF dst, vlRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveLEG2F(regF dst, legRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveD2VL(vlRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveD2LEG(legRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveVL2D(regD dst, vlRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveLEG2D(regD dst, legRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n@@ -5216,40 +5317,0 @@\n-\/\/ Load Float\n-instruct MoveF2VL(vlRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveF2LEG(legRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveVL2F(regF dst, vlRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveLEG2F(regF dst, legRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -5283,39 +5344,0 @@\n-\/\/ Load Double\n-instruct MoveD2VL(vlRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveD2LEG(legRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveVL2D(regD dst, vlRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveLEG2D(regD dst, legRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n@@ -12908,1 +12930,1 @@\n-                 _counters, _rtm_counters, _stack_rtm_counters,\n+                 _rtm_counters, _stack_rtm_counters,\n@@ -12923,1 +12945,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":103,"deletions":81,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    get_interpreterState()->set_thread(thread->as_Java_thread());\n+    get_interpreterState()->set_thread(JavaThread::cast(thread));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -817,0 +817,1 @@\n+  ResourceMark rm;\n@@ -818,0 +819,1 @@\n+\n@@ -819,1 +821,4 @@\n-    ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    int limit = 3;\n+    do {\n+      ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    } while (ret == EAGAIN && limit-- > 0);\n@@ -824,2 +829,2 @@\n-    log_info(os, thread)(\"Thread started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n-      (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+    log_info(os, thread)(\"Thread \\\"%s\\\" started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n+                         thread->name(), (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -828,2 +833,2 @@\n-    log_warning(os, thread)(\"Failed to start thread - pthread_create failed (%d=%s) for attributes: %s.\",\n-      ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+    log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - pthread_create failed (%d=%s) for attributes: %s.\",\n+                            thread->name(), ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -2515,5 +2520,0 @@\n-bool os::bind_to_processor(uint processor_id) {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n-\n@@ -2668,3 +2668,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -634,0 +634,2 @@\n+\n+    ResourceMark rm;\n@@ -635,1 +637,5 @@\n-    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    int ret = 0;\n+    int limit = 3;\n+    do {\n+      ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    } while (ret == EAGAIN && limit-- > 0);\n@@ -639,2 +645,2 @@\n-      log_info(os, thread)(\"Thread started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n-        (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_info(os, thread)(\"Thread \\\"%s\\\" started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n+                           thread->name(), (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -642,2 +648,2 @@\n-      log_warning(os, thread)(\"Failed to start thread - pthread_create failed (%s) for attributes: %s.\",\n-        os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - pthread_create failed (%s) for attributes: %s.\",\n+                              thread->name(), os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -2168,5 +2174,0 @@\n-bool os::bind_to_processor(uint processor_id) {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n-\n@@ -2358,3 +2359,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -866,0 +866,1 @@\n+    ResourceMark rm;\n@@ -867,1 +868,5 @@\n-    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    int ret = 0;\n+    int limit = 3;\n+    do {\n+      ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    } while (ret == EAGAIN && limit-- > 0);\n@@ -871,2 +876,2 @@\n-      log_info(os, thread)(\"Thread started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n-        (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_info(os, thread)(\"Thread \\\"%s\\\" started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n+                           thread->name(), (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -874,2 +879,2 @@\n-      log_warning(os, thread)(\"Failed to start thread - pthread_create failed (%s) for attributes: %s.\",\n-        os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - pthread_create failed (%s) for attributes: %s.\",\n+                              thread->name(), os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -1671,0 +1676,3 @@\n+#ifndef EM_LOONGARCH\n+  #define EM_LOONGARCH  258               \/* LoongArch *\/\n+#endif\n@@ -1698,0 +1706,1 @@\n+    {EM_LOONGARCH,   EM_LOONGARCH, ELFCLASS64, ELFDATA2LSB, (char*)\"LoongArch\"},\n@@ -1734,0 +1743,2 @@\n+#elif  (defined LOONGARCH)\n+  static  Elf32_Half running_arch_code=EM_LOONGARCH;\n@@ -1736,1 +1747,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -2140,10 +2151,1 @@\n-void os::Linux::print_process_memory_info(outputStream* st) {\n-\n-  st->print_cr(\"Process Memory:\");\n-\n-  \/\/ Print virtual and resident set size; peak values; swap; and for\n-  \/\/  rss its components if the kernel is recent enough.\n-  ssize_t vmsize = -1, vmpeak = -1, vmswap = -1,\n-      vmrss = -1, vmhwm = -1, rssanon = -1, rssfile = -1, rssshmem = -1;\n-  const int num_values = 8;\n-  int num_found = 0;\n+bool os::Linux::query_process_memory_info(os::Linux::meminfo_t* info) {\n@@ -2151,0 +2153,2 @@\n+  const int num_values = sizeof(os::Linux::meminfo_t) \/ sizeof(size_t);\n+  int num_found = 0;\n@@ -2152,0 +2156,2 @@\n+  info->vmsize = info->vmpeak = info->vmrss = info->vmhwm = info->vmswap =\n+      info->rssanon = info->rssfile = info->rssshmem = -1;\n@@ -2154,8 +2160,8 @@\n-      if ( (vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &vmsize) == 1) ||\n-           (vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &vmpeak) == 1) ||\n-           (vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &vmswap) == 1) ||\n-           (vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &vmhwm) == 1) ||\n-           (vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &vmrss) == 1) ||\n-           (rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &rssanon) == 1) ||\n-           (rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &rssfile) == 1) ||\n-           (rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &rssshmem) == 1)\n+      if ( (info->vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &info->vmsize) == 1) ||\n+           (info->vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &info->vmpeak) == 1) ||\n+           (info->vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &info->vmswap) == 1) ||\n+           (info->vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &info->vmhwm) == 1) ||\n+           (info->vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &info->vmrss) == 1) ||\n+           (info->rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &info->rssanon) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &info->rssfile) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &info->rssshmem) == 1)  \/\/ Needs Linux 4.5\n@@ -2168,0 +2174,6 @@\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void os::Linux::print_process_memory_info(outputStream* st) {\n@@ -2169,3 +2181,9 @@\n-    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmsize, vmpeak);\n-    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmrss, vmhwm);\n-    if (rssanon != -1) { \/\/ requires kernel >= 4.5\n+  st->print_cr(\"Process Memory:\");\n+\n+  \/\/ Print virtual and resident set size; peak values; swap; and for\n+  \/\/  rss its components if the kernel is recent enough.\n+  meminfo_t info;\n+  if (query_process_memory_info(&info)) {\n+    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmsize, info.vmpeak);\n+    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmrss, info.vmhwm);\n+    if (info.rssanon != -1) { \/\/ requires kernel >= 4.5\n@@ -2173,1 +2191,1 @@\n-                  rssanon, rssfile, rssshmem);\n+                info.rssanon, info.rssfile, info.rssshmem);\n@@ -2176,2 +2194,2 @@\n-    if (vmswap != -1) { \/\/ requires kernel >= 2.6.34\n-      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", vmswap);\n+    if (info.vmswap != -1) { \/\/ requires kernel >= 2.6.34\n+      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", info.vmswap);\n@@ -2198,1 +2216,1 @@\n-    might_have_wrapped = (vmrss * K) > UINT_MAX && (vmrss * K) > (total_allocated + UINT_MAX);\n+    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n@@ -4788,5 +4806,0 @@\n-bool os::bind_to_processor(uint processor_id) {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n-\n@@ -4971,3 +4984,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":50,"deletions":39,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -177,0 +177,17 @@\n+  \/\/ Output structure for query_process_memory_info()\n+  struct meminfo_t {\n+    ssize_t vmsize;     \/\/ current virtual size\n+    ssize_t vmpeak;     \/\/ peak virtual size\n+    ssize_t vmrss;      \/\/ current resident set size\n+    ssize_t vmhwm;      \/\/ peak resident set size\n+    ssize_t vmswap;     \/\/ swapped out\n+    ssize_t rssanon;    \/\/ resident set size (anonymous mappings, needs 4.5)\n+    ssize_t rssfile;    \/\/ resident set size (file mappings, needs 4.5)\n+    ssize_t rssshmem;   \/\/ resident set size (shared mappings, needs 4.5)\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n+  \/\/ fields will contain -1.\n+  static bool query_process_memory_info(meminfo_t* info);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"trimCHeapDCmd.hpp\"\n+\n+#include <malloc.h>\n+\n+void TrimCLibcHeapDCmd::execute(DCmdSource source, TRAPS) {\n+#ifdef __GLIBC__\n+  stringStream ss_report(1024); \/\/ Note: before calling trim\n+\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+  \/\/ Query memory before...\n+  bool have_info1 = os::Linux::query_process_memory_info(&info1);\n+\n+  _output->print_cr(\"Attempting trim...\");\n+  ::malloc_trim(0);\n+  _output->print_cr(\"Done.\");\n+\n+  \/\/ ...and after trim.\n+  bool have_info2 = os::Linux::query_process_memory_info(&info2);\n+\n+  \/\/ Print report both to output stream as well to UL\n+  bool wrote_something = false;\n+  if (have_info1 && have_info2) {\n+    if (info1.vmsize != -1 && info2.vmsize != -1) {\n+      ss_report.print_cr(\"Virtual size before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmsize, info2.vmsize, (info2.vmsize - info1.vmsize));\n+      wrote_something = true;\n+    }\n+    if (info1.vmrss != -1 && info2.vmrss != -1) {\n+      ss_report.print_cr(\"RSS before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmrss, info2.vmrss, (info2.vmrss - info1.vmrss));\n+      wrote_something = true;\n+    }\n+    if (info1.vmswap != -1 && info2.vmswap != -1) {\n+      ss_report.print_cr(\"Swap before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmswap, info2.vmswap, (info2.vmswap - info1.vmswap));\n+      wrote_something = true;\n+    }\n+  }\n+  if (!wrote_something) {\n+    ss_report.print_raw(\"No details available.\");\n+  }\n+\n+  _output->print_raw(ss_report.base());\n+  log_info(os)(\"malloc_trim:\\n%s\", ss_report.base());\n+#else\n+  _output->print_cr(\"Not available.\");\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_TRIMCHEAPDCMD_HPP\n+#define OS_LINUX_TRIMCHEAPDCMD_HPP\n+\n+#include \"services\/diagnosticCommand.hpp\"\n+\n+class outputStream;\n+\n+class TrimCLibcHeapDCmd : public DCmd {\n+public:\n+  TrimCLibcHeapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"System.trim_native_heap\";\n+  }\n+  static const char* description() {\n+    return \"Attempts to free up memory by trimming the C-heap.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", NULL };\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#endif \/\/ OS_LINUX_TRIMCHEAPDCMD_HPP\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -746,8 +746,13 @@\n-  HANDLE thread_handle =\n-    (HANDLE)_beginthreadex(NULL,\n-                           (unsigned)stack_size,\n-                           (unsigned (__stdcall *)(void*)) thread_native_entry,\n-                           thread,\n-                           initflag,\n-                           &thread_id);\n-\n+  HANDLE thread_handle;\n+  int limit = 3;\n+  do {\n+    thread_handle =\n+      (HANDLE)_beginthreadex(NULL,\n+                             (unsigned)stack_size,\n+                             (unsigned (__stdcall *)(void*)) thread_native_entry,\n+                             thread,\n+                             initflag,\n+                             &thread_id);\n+  } while (thread_handle == NULL && errno == EAGAIN && limit-- > 0);\n+\n+  ResourceMark rm;\n@@ -756,2 +761,3 @@\n-    log_info(os, thread)(\"Thread started (tid: %u, attributes: %s)\",\n-      thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n+    log_info(os, thread)(\"Thread \\\"%s\\\" started (tid: %u, attributes: %s)\",\n+                         thread->name(), thread_id,\n+                         describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n@@ -759,2 +765,2 @@\n-    log_warning(os, thread)(\"Failed to start thread - _beginthreadex failed (%s) for attributes: %s.\",\n-      os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n+    log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - _beginthreadex failed (%s) for attributes: %s.\",\n+                            thread->name(), os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n@@ -888,0 +894,9 @@\n+\/\/ For dynamic lookup of SetThreadDescription API\n+typedef HRESULT (WINAPI *SetThreadDescriptionFnPtr)(HANDLE, PCWSTR);\n+typedef HRESULT (WINAPI *GetThreadDescriptionFnPtr)(HANDLE, PWSTR*);\n+static SetThreadDescriptionFnPtr _SetThreadDescription = NULL;\n+DEBUG_ONLY(static GetThreadDescriptionFnPtr _GetThreadDescription = NULL;)\n+\n+\/\/ forward decl.\n+static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path);\n+\n@@ -890,0 +905,45 @@\n+  \/\/ From Windows 10 and Windows 2016 server, we have a direct API\n+  \/\/ for setting the thread name\/description:\n+  \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/processthreadsapi\/nf-processthreadsapi-setthreaddescription\n+\n+  if (_SetThreadDescription != NULL) {\n+    \/\/ SetThreadDescription takes a PCWSTR but we have conversion routines that produce\n+    \/\/ LPWSTR. The only difference is that PCWSTR is a pointer to const WCHAR.\n+    LPWSTR unicode_name;\n+    errno_t err = convert_to_unicode(name, &unicode_name);\n+    if (err == ERROR_SUCCESS) {\n+      HANDLE current = GetCurrentThread();\n+      HRESULT hr = _SetThreadDescription(current, unicode_name);\n+      if (FAILED(hr)) {\n+        log_debug(os, thread)(\"set_native_thread_name: SetThreadDescription failed - falling back to debugger method\");\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+      } else {\n+        log_trace(os, thread)(\"set_native_thread_name: SetThreadDescription succeeded - new name: %s\", name);\n+\n+#ifdef ASSERT\n+        \/\/ For verification purposes in a debug build we read the thread name back and check it.\n+        PWSTR thread_name;\n+        HRESULT hr2 = _GetThreadDescription(current, &thread_name);\n+        if (FAILED(hr2)) {\n+          log_debug(os, thread)(\"set_native_thread_name: GetThreadDescription failed!\");\n+        } else {\n+          int res = CompareStringW(LOCALE_USER_DEFAULT,\n+                                   0, \/\/ no special comparison rules\n+                                   unicode_name,\n+                                   -1, \/\/ null-terminated\n+                                   thread_name,\n+                                   -1  \/\/ null-terminated\n+                                   );\n+          assert(res == CSTR_EQUAL,\n+                 \"Name strings were not the same - set: %ls, but read: %ls\", unicode_name, thread_name);\n+          LocalFree(thread_name);\n+        }\n+#endif\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+        return;\n+      }\n+    } else {\n+      log_debug(os, thread)(\"set_native_thread_name: convert_to_unicode failed - falling back to debugger method\");\n+    }\n+  }\n+\n@@ -898,0 +958,1 @@\n+    log_debug(os, thread)(\"set_native_thread_name: no debugger present so unable to set thread name\");\n@@ -919,5 +980,0 @@\n-bool os::bind_to_processor(uint processor_id) {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n-\n@@ -2236,1 +2292,1 @@\n-    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n+    JavaThread::cast(thread)->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->PC_NAME);\n@@ -2530,1 +2586,1 @@\n-    JavaThread* thread = t->as_Java_thread();\n+    JavaThread* thread = JavaThread::cast(t);\n@@ -4196,0 +4252,1 @@\n+\n@@ -4314,0 +4371,18 @@\n+  \/\/ Lookup SetThreadDescription - the docs state we must use runtime-linking of\n+  \/\/ kernelbase.dll, so that is what we do.\n+  HINSTANCE _kernelbase = LoadLibrary(TEXT(\"kernelbase.dll\"));\n+  if (_kernelbase != NULL) {\n+    _SetThreadDescription =\n+      reinterpret_cast<SetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"SetThreadDescription\"));\n+#ifdef ASSERT\n+    _GetThreadDescription =\n+      reinterpret_cast<GetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"GetThreadDescription\"));\n+#endif\n+  }\n+  log_info(os, thread)(\"The SetThreadDescription API is%s available.\", _SetThreadDescription == NULL ? \" not\" : \"\");\n+\n+\n@@ -4735,3 +4810,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= _O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? _O_TRUNC : _O_EXCL;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":95,"deletions":22,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/debug.hpp\"\n+\n@@ -67,1 +69,1 @@\n-  if (order == memory_order_relaxed) {\n+  if (order == memory_order_conservative) {\n@@ -69,0 +71,1 @@\n+    FULL_MEM_BARRIER;\n@@ -71,0 +74,1 @@\n+    FULL_MEM_BARRIER;\n@@ -73,0 +77,23 @@\n+    STATIC_ASSERT (\n+       \/\/ The modes that align with C++11 are intended to\n+       \/\/ follow the same semantics.\n+       memory_order_relaxed == __ATOMIC_RELAXED &&\n+       memory_order_acquire == __ATOMIC_ACQUIRE &&\n+       memory_order_release == __ATOMIC_RELEASE &&\n+       memory_order_acq_rel == __ATOMIC_ACQ_REL &&\n+       memory_order_seq_cst == __ATOMIC_SEQ_CST);\n+\n+    \/\/ Some sanity checking on the memory order. It makes no\n+    \/\/ sense to have a release operation for a store that never\n+    \/\/ happens.\n+    int failure_memory_order;\n+    switch (order) {\n+    case memory_order_release:\n+      failure_memory_order = memory_order_relaxed; break;\n+    case memory_order_acq_rel:\n+      failure_memory_order = memory_order_acquire; break;\n+    default:\n+      failure_memory_order = order;\n+    }\n+    assert(failure_memory_order <= order, \"must be\");\n+\n@@ -74,1 +101,0 @@\n-    FULL_MEM_BARRIER;\n@@ -76,2 +102,1 @@\n-                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-    FULL_MEM_BARRIER;\n+                              order, failure_memory_order);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomic_bsd_aarch64.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -115,1 +115,49 @@\n-        .globl aarch64_atomic_cmpxchg_1_relaxed_default_impl\n+        .globl aarch64_atomic_cmpxchg_4_release_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_4_release_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    w3, [x0]\n+        cmp     w3, w1\n+        b.ne    1f\n+        stlxr   w8, w2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     w0, w3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_8_release_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_8_release_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    x3, [x0]\n+        cmp     x3, x1\n+        b.ne    1f\n+        stlxr   w8, x2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     x0, x3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_4_seq_cst_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_4_seq_cst_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldaxr   w3, [x0]\n+        cmp     w3, w1\n+        b.ne    1f\n+        stlxr   w8, w2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     w0, w3\n+        ret\n+\n+        .globl aarch64_atomic_cmpxchg_8_seq_cst_default_impl\n+        .align 5\n+aarch64_atomic_cmpxchg_8_seq_cst_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldaxr   x3, [x0]\n+        cmp     x3, x1\n+        b.ne    1f\n+        stlxr   w8, x2, [x0]\n+        cbnz    w8, 0b\n+1:      mov     x0, x3\n+        ret\n+\n+.globl aarch64_atomic_cmpxchg_1_relaxed_default_impl\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -154,0 +154,5 @@\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_4_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_4_seq_cst_impl; break;\n@@ -172,0 +177,5 @@\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_8_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_8_seq_cst_impl; break;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-    st->print_cr(\"  %-3s = \" INTPTR_FORMAT, as_Register(r)->name(), reg_area[r]);\n+    st->print(\"  %-3s = \", as_Register(r)->name());\n@@ -473,1 +473,0 @@\n-    st->cr();\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,2 +121,1 @@\n-  \/\/ Warning:  in LP64, Amalloc_4 is really Amalloc_8\n-  void *Amalloc_4(size_t x) {\n+  void *AmallocWords(size_t x) {\n","filename":"src\/hotspot\/share\/adlc\/arena.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  _bin = (bucket*)_arena->AmallocWords(sizeof(bucket) * _size);\n@@ -118,1 +118,1 @@\n-    nb->_keyvals = (const void**)_arena->Amalloc_4( sizeof(void *)*nb->_max*2 );\n+    nb->_keyvals = (const void**)_arena->AmallocWords( sizeof(void *)*nb->_max*2 );\n@@ -141,1 +141,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n+  _bin = (bucket*)_arena->AmallocWords(sizeof(bucket)*_size);\n@@ -145,1 +145,1 @@\n-    _bin[i]._keyvals=(const void**)_arena->Amalloc_4( sizeof(void *)*_bin[i]._max*2);\n+    _bin[i]._keyvals=(const void**)_arena->AmallocWords( sizeof(void *)*_bin[i]._max*2);\n@@ -198,1 +198,1 @@\n-      b->_keyvals = (const void**)_arena->Amalloc_4( sizeof(void *)*b->_max*2 );\n+      b->_keyvals = (const void**)_arena->AmallocWords( sizeof(void *)*b->_max*2 );\n","filename":"src\/hotspot\/share\/adlc\/dict2.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  AD.addInclude(AD._CPP_file, \"runtime\/biasedLocking.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1345,0 +1345,3 @@\n+  for (int i = 0; i <= max_position; i++) {\n+    fprintf(fp, \"        inst%d->set_removed();\\n\", i);\n+  }\n@@ -1529,1 +1532,0 @@\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_counters = _counters;\\n\", cnt);\n@@ -3944,1 +3946,0 @@\n-    fprintf(fp_cpp, \"%s node->_counters = _leaf->as_FastLock()->counters();\\n\", indent);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  Label(const Label&) { ShouldNotReachHere(); }\n+  NONCOPYABLE(Label);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,5 @@\n-  void emit_int32(int32_t x) { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }\n+  void emit_int32(int32_t x) {\n+    address curr = end();\n+    *((int32_t*) curr) = x;\n+    set_end(curr + sizeof(int32_t));\n+  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,37 +48,0 @@\n-\n-\/\/\n-\/\/ Macros for use in defining Register instances.  We'd like to be\n-\/\/ able to simply define const instances of the RegisterImpl* for each\n-\/\/ of the registers needed on a system in a header file.  However many\n-\/\/ compilers don't handle this very well and end up producing a\n-\/\/ private definition in every file which includes the header file.\n-\/\/ Along with the static constructors necessary for initialization it\n-\/\/ can consume a significant amount of space in the result library.\n-\/\/\n-\/\/ The following macros allow us to declare the instance in a .hpp and\n-\/\/ produce an enumeration value which has the same number.  Then in a\n-\/\/ .cpp the the register instance can be defined using the enumeration\n-\/\/ value.  This avoids the use of static constructors and multiple\n-\/\/ definitions per .cpp.  In addition #defines for the register can be\n-\/\/ produced so that the constant registers can be inlined.  These\n-\/\/ macros should not be used inside other macros, because you may get\n-\/\/ multiple evaluations of the macros which can give bad results.\n-\/\/\n-\/\/ Here are some example uses and expansions.  Note that the macro\n-\/\/ invocation is terminated with a ;.\n-\/\/\n-\/\/ CONSTANT_REGISTER_DECLARATION(Register, G0, 0);\n-\/\/\n-\/\/ extern const Register G0 ;\n-\/\/ enum { G0_RegisterEnumValue = 0 } ;\n-\/\/\n-\/\/ REGISTER_DECLARATION(Register, Gmethod, G5);\n-\/\/\n-\/\/ extern const Register Gmethod ;\n-\/\/ enum { Gmethod_RegisterEnumValue = G5_RegisterEnumValue } ;\n-\/\/\n-\/\/ REGISTER_DEFINITION(Register, G0);\n-\/\/\n-\/\/ const Register G0 = ( ( Register ) G0_RegisterEnumValue ) ;\n-\/\/\n-\n@@ -87,2 +50,2 @@\n-#define CONSTANT_REGISTER_DECLARATION(type, name, value) \\\n-extern const type name;                                  \\\n+#define CONSTANT_REGISTER_DECLARATION(type, name, value)        \\\n+const type name = ((type)value);                                \\\n@@ -91,3 +54,2 @@\n-#define REGISTER_DECLARATION(type, name, value) \\\n-extern const type name;                         \\\n-enum { name##_##type##EnumValue = value##_##type##EnumValue }\n+#define REGISTER_DECLARATION(type, name, value)                 \\\n+const type name = ((type)value)\n@@ -95,2 +57,1 @@\n-#define REGISTER_DEFINITION(type, name) \\\n-const type name = ((type)name##_##type##EnumValue)\n+#define REGISTER_DEFINITION(type, name)\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":6,"deletions":45,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-          if (compilation()->profile_branches() || compilation()->count_backedges()) {\n+          if (compilation()->profile_branches() || compilation()->is_profiling()) {\n@@ -860,160 +860,5 @@\n-\n-static bool match_index_and_scale(Instruction*  instr,\n-                                  Instruction** index,\n-                                  int*          log2_scale) {\n-  \/\/ Skip conversion ops. This works only on 32bit because of the implicit l2i that the\n-  \/\/ unsafe performs.\n-#ifndef _LP64\n-  Convert* convert = instr->as_Convert();\n-  if (convert != NULL && convert->op() == Bytecodes::_i2l) {\n-    assert(convert->value()->type() == intType, \"invalid input type\");\n-    instr = convert->value();\n-  }\n-#endif\n-\n-  ShiftOp* shift = instr->as_ShiftOp();\n-  if (shift != NULL) {\n-    if (shift->op() == Bytecodes::_lshl) {\n-      assert(shift->x()->type() == longType, \"invalid input type\");\n-    } else {\n-#ifndef _LP64\n-      if (shift->op() == Bytecodes::_ishl) {\n-        assert(shift->x()->type() == intType, \"invalid input type\");\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-\n-\n-    \/\/ Constant shift value?\n-    Constant* con = shift->y()->as_Constant();\n-    if (con == NULL) return false;\n-    \/\/ Well-known type and value?\n-    IntConstant* val = con->type()->as_IntConstant();\n-    assert(val != NULL, \"Should be an int constant\");\n-\n-    *index = shift->x();\n-    int tmp_scale = val->value();\n-    if (tmp_scale >= 0 && tmp_scale < 4) {\n-      *log2_scale = tmp_scale;\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  ArithmeticOp* arith = instr->as_ArithmeticOp();\n-  if (arith != NULL) {\n-    \/\/ See if either arg is a known constant\n-    Constant* con = arith->x()->as_Constant();\n-    if (con != NULL) {\n-      *index = arith->y();\n-    } else {\n-      con = arith->y()->as_Constant();\n-      if (con == NULL) return false;\n-      *index = arith->x();\n-    }\n-    long const_value;\n-    \/\/ Check for integer multiply\n-    if (arith->op() == Bytecodes::_lmul) {\n-      assert((*index)->type() == longType, \"invalid input type\");\n-      LongConstant* val = con->type()->as_LongConstant();\n-      assert(val != NULL, \"expecting a long constant\");\n-      const_value = val->value();\n-    } else {\n-#ifndef _LP64\n-      if (arith->op() == Bytecodes::_imul) {\n-        assert((*index)->type() == intType, \"invalid input type\");\n-        IntConstant* val = con->type()->as_IntConstant();\n-        assert(val != NULL, \"expecting an int constant\");\n-        const_value = val->value();\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-    switch (const_value) {\n-    case 1: *log2_scale = 0; return true;\n-    case 2: *log2_scale = 1; return true;\n-    case 4: *log2_scale = 2; return true;\n-    case 8: *log2_scale = 3; return true;\n-    default:            return false;\n-    }\n-  }\n-\n-  \/\/ Unknown instruction sequence; don't touch it\n-  return false;\n-}\n-\n-\n-static bool match(UnsafeRawOp* x,\n-                  Instruction** base,\n-                  Instruction** index,\n-                  int*          log2_scale) {\n-  ArithmeticOp* root = x->base()->as_ArithmeticOp();\n-  if (root == NULL) return false;\n-  \/\/ Limit ourselves to addition for now\n-  if (root->op() != Bytecodes::_ladd) return false;\n-\n-  bool match_found = false;\n-  \/\/ Try to find shift or scale op\n-  if (match_index_and_scale(root->y(), index, log2_scale)) {\n-    *base = root->x();\n-    match_found = true;\n-  } else if (match_index_and_scale(root->x(), index, log2_scale)) {\n-    *base = root->y();\n-    match_found = true;\n-  } else if (NOT_LP64(root->y()->as_Convert() != NULL) LP64_ONLY(false)) {\n-    \/\/ Skipping i2l works only on 32bit because of the implicit l2i that the unsafe performs.\n-    \/\/ 64bit needs a real sign-extending conversion.\n-    Convert* convert = root->y()->as_Convert();\n-    if (convert->op() == Bytecodes::_i2l) {\n-      assert(convert->value()->type() == intType, \"should be an int\");\n-      \/\/ pick base and index, setting scale at 1\n-      *base  = root->x();\n-      *index = convert->value();\n-      *log2_scale = 0;\n-      match_found = true;\n-    }\n-  }\n-  \/\/ The default solution\n-  if (!match_found) {\n-    *base = root->x();\n-    *index = root->y();\n-    *log2_scale = 0;\n-  }\n-\n-  \/\/ If the value is pinned then it will be always be computed so\n-  \/\/ there's no profit to reshaping the expression.\n-  return !root->is_pinned();\n-}\n-\n-\n-void Canonicalizer::do_UnsafeRawOp(UnsafeRawOp* x) {\n-  Instruction* base = NULL;\n-  Instruction* index = NULL;\n-  int          log2_scale;\n-\n-  if (match(x, &base, &index, &log2_scale)) {\n-    x->set_base(base);\n-    x->set_index(index);\n-    x->set_log2_scale(log2_scale);\n-    if (PrintUnsafeOptimization) {\n-      tty->print_cr(\"Canonicalizer: UnsafeRawOp id %d: base = id %d, index = id %d, log2_scale = %d\",\n-                    x->id(), x->base()->id(), x->index()->id(), x->log2_scale());\n-    }\n-  }\n-}\n-\n-void Canonicalizer::do_RoundFP(RoundFP* x) {}\n-void Canonicalizer::do_UnsafeGetRaw(UnsafeGetRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n-void Canonicalizer::do_UnsafePutRaw(UnsafePutRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n-void Canonicalizer::do_UnsafeGetObject(UnsafeGetObject* x) {}\n-void Canonicalizer::do_UnsafePutObject(UnsafePutObject* x) {}\n-void Canonicalizer::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}\n-void Canonicalizer::do_ProfileCall(ProfileCall* x) {}\n+void Canonicalizer::do_RoundFP        (RoundFP*         x) {}\n+void Canonicalizer::do_UnsafeGet      (UnsafeGet*       x) {}\n+void Canonicalizer::do_UnsafePut      (UnsafePut*       x) {}\n+void Canonicalizer::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {}\n+void Canonicalizer::do_ProfileCall    (ProfileCall*     x) {}\n@@ -1021,2 +866,2 @@\n-void Canonicalizer::do_ProfileInvoke(ProfileInvoke* x) {}\n-void Canonicalizer::do_RuntimeCall(RuntimeCall* x) {}\n+void Canonicalizer::do_ProfileInvoke  (ProfileInvoke*   x) {}\n+void Canonicalizer::do_RuntimeCall    (RuntimeCall*     x) {}\n@@ -1025,1 +870,1 @@\n-void Canonicalizer::do_Assert(Assert* x) {}\n+void Canonicalizer::do_Assert         (Assert*          x) {}\n@@ -1027,1 +872,1 @@\n-void Canonicalizer::do_MemBar(MemBar* x) {}\n+void Canonicalizer::do_MemBar         (MemBar*          x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":10,"deletions":165,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-  void do_UnsafeRawOp(UnsafeRawOp* x);\n-\n-  void unsafe_raw_match(UnsafeRawOp* x,\n-                        Instruction** base,\n-                        Instruction** index,\n-                        int* scale);\n@@ -102,5 +96,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  virtual bool is_range_check_stub() const       { return false; }\n-  virtual bool is_divbyzero_stub() const         { return false; }\n@@ -70,9 +68,1 @@\n-  virtual void visit(LIR_OpVisitState* visit) {\n-#ifndef PRODUCT\n-    if (LIRTracePeephole && Verbose) {\n-      tty->print(\"no visitor for \");\n-      print_name(tty);\n-      tty->cr();\n-    }\n-#endif\n-  }\n+  virtual void visit(LIR_OpVisitState* visit) = 0;\n@@ -184,1 +174,0 @@\n-  virtual bool is_range_check_stub() const       { return true; }\n@@ -227,1 +216,0 @@\n-  virtual bool is_divbyzero_stub() const         { return true; }\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-  bool count_invocations() { return is_profiling(); }\n-  bool count_backedges()   { return is_profiling(); }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"c1\/c1_Defs.hpp\"\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Defs.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -3054,1 +3054,1 @@\n-  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges() || RangeCheckElimination) {\n+  if (std_entry->number_of_preds() > 0 || is_profiling() || RangeCheckElimination) {\n@@ -3141,4 +3141,5 @@\n-      get = append(new UnsafeGetRaw(as_BasicType(local->type()), e,\n-                                    append(new Constant(new IntConstant(offset))),\n-                                    0,\n-                                    true \/*unaligned*\/, true \/*wide*\/));\n+      Value off_val = append(new Constant(new IntConstant(offset)));\n+      get = append(new UnsafeGet(as_BasicType(local->type()), e,\n+                                 off_val,\n+                                 false\/*is_volatile*\/,\n+                                 true\/*is_raw*\/));\n@@ -3471,44 +3472,44 @@\n-  case vmIntrinsics::_getReference       : append_unsafe_get_obj(callee, T_OBJECT,  false); return;\n-  case vmIntrinsics::_getBoolean         : append_unsafe_get_obj(callee, T_BOOLEAN, false); return;\n-  case vmIntrinsics::_getByte            : append_unsafe_get_obj(callee, T_BYTE,    false); return;\n-  case vmIntrinsics::_getShort           : append_unsafe_get_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_getChar            : append_unsafe_get_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_getInt             : append_unsafe_get_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_getLong            : append_unsafe_get_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_getFloat           : append_unsafe_get_obj(callee, T_FLOAT,   false); return;\n-  case vmIntrinsics::_getDouble          : append_unsafe_get_obj(callee, T_DOUBLE,  false); return;\n-  case vmIntrinsics::_putReference       : append_unsafe_put_obj(callee, T_OBJECT,  false); return;\n-  case vmIntrinsics::_putBoolean         : append_unsafe_put_obj(callee, T_BOOLEAN, false); return;\n-  case vmIntrinsics::_putByte            : append_unsafe_put_obj(callee, T_BYTE,    false); return;\n-  case vmIntrinsics::_putShort           : append_unsafe_put_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_putChar            : append_unsafe_put_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_putInt             : append_unsafe_put_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_putLong            : append_unsafe_put_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_putFloat           : append_unsafe_put_obj(callee, T_FLOAT,   false); return;\n-  case vmIntrinsics::_putDouble          : append_unsafe_put_obj(callee, T_DOUBLE,  false); return;\n-  case vmIntrinsics::_getShortUnaligned  : append_unsafe_get_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_getCharUnaligned   : append_unsafe_get_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_getIntUnaligned    : append_unsafe_get_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_getLongUnaligned   : append_unsafe_get_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_putShortUnaligned  : append_unsafe_put_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_putCharUnaligned   : append_unsafe_put_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_putIntUnaligned    : append_unsafe_put_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_putLongUnaligned   : append_unsafe_put_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_getReferenceVolatile  : append_unsafe_get_obj(callee, T_OBJECT,  true); return;\n-  case vmIntrinsics::_getBooleanVolatile : append_unsafe_get_obj(callee, T_BOOLEAN, true); return;\n-  case vmIntrinsics::_getByteVolatile    : append_unsafe_get_obj(callee, T_BYTE,    true); return;\n-  case vmIntrinsics::_getShortVolatile   : append_unsafe_get_obj(callee, T_SHORT,   true); return;\n-  case vmIntrinsics::_getCharVolatile    : append_unsafe_get_obj(callee, T_CHAR,    true); return;\n-  case vmIntrinsics::_getIntVolatile     : append_unsafe_get_obj(callee, T_INT,     true); return;\n-  case vmIntrinsics::_getLongVolatile    : append_unsafe_get_obj(callee, T_LONG,    true); return;\n-  case vmIntrinsics::_getFloatVolatile   : append_unsafe_get_obj(callee, T_FLOAT,   true); return;\n-  case vmIntrinsics::_getDoubleVolatile  : append_unsafe_get_obj(callee, T_DOUBLE,  true); return;\n-  case vmIntrinsics::_putReferenceVolatile : append_unsafe_put_obj(callee, T_OBJECT,  true); return;\n-  case vmIntrinsics::_putBooleanVolatile : append_unsafe_put_obj(callee, T_BOOLEAN, true); return;\n-  case vmIntrinsics::_putByteVolatile    : append_unsafe_put_obj(callee, T_BYTE,    true); return;\n-  case vmIntrinsics::_putShortVolatile   : append_unsafe_put_obj(callee, T_SHORT,   true); return;\n-  case vmIntrinsics::_putCharVolatile    : append_unsafe_put_obj(callee, T_CHAR,    true); return;\n-  case vmIntrinsics::_putIntVolatile     : append_unsafe_put_obj(callee, T_INT,     true); return;\n-  case vmIntrinsics::_putLongVolatile    : append_unsafe_put_obj(callee, T_LONG,    true); return;\n-  case vmIntrinsics::_putFloatVolatile   : append_unsafe_put_obj(callee, T_FLOAT,   true); return;\n-  case vmIntrinsics::_putDoubleVolatile  : append_unsafe_put_obj(callee, T_DOUBLE,  true); return;\n+  case vmIntrinsics::_getReference           : append_unsafe_get(callee, T_OBJECT,  false); return;\n+  case vmIntrinsics::_getBoolean             : append_unsafe_get(callee, T_BOOLEAN, false); return;\n+  case vmIntrinsics::_getByte                : append_unsafe_get(callee, T_BYTE,    false); return;\n+  case vmIntrinsics::_getShort               : append_unsafe_get(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_getChar                : append_unsafe_get(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_getInt                 : append_unsafe_get(callee, T_INT,     false); return;\n+  case vmIntrinsics::_getLong                : append_unsafe_get(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_getFloat               : append_unsafe_get(callee, T_FLOAT,   false); return;\n+  case vmIntrinsics::_getDouble              : append_unsafe_get(callee, T_DOUBLE,  false); return;\n+  case vmIntrinsics::_putReference           : append_unsafe_put(callee, T_OBJECT,  false); return;\n+  case vmIntrinsics::_putBoolean             : append_unsafe_put(callee, T_BOOLEAN, false); return;\n+  case vmIntrinsics::_putByte                : append_unsafe_put(callee, T_BYTE,    false); return;\n+  case vmIntrinsics::_putShort               : append_unsafe_put(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_putChar                : append_unsafe_put(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_putInt                 : append_unsafe_put(callee, T_INT,     false); return;\n+  case vmIntrinsics::_putLong                : append_unsafe_put(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_putFloat               : append_unsafe_put(callee, T_FLOAT,   false); return;\n+  case vmIntrinsics::_putDouble              : append_unsafe_put(callee, T_DOUBLE,  false); return;\n+  case vmIntrinsics::_getShortUnaligned      : append_unsafe_get(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_getCharUnaligned       : append_unsafe_get(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_getIntUnaligned        : append_unsafe_get(callee, T_INT,     false); return;\n+  case vmIntrinsics::_getLongUnaligned       : append_unsafe_get(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_putShortUnaligned      : append_unsafe_put(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_putCharUnaligned       : append_unsafe_put(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_putIntUnaligned        : append_unsafe_put(callee, T_INT,     false); return;\n+  case vmIntrinsics::_putLongUnaligned       : append_unsafe_put(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_getReferenceVolatile   : append_unsafe_get(callee, T_OBJECT,  true); return;\n+  case vmIntrinsics::_getBooleanVolatile     : append_unsafe_get(callee, T_BOOLEAN, true); return;\n+  case vmIntrinsics::_getByteVolatile        : append_unsafe_get(callee, T_BYTE,    true); return;\n+  case vmIntrinsics::_getShortVolatile       : append_unsafe_get(callee, T_SHORT,   true); return;\n+  case vmIntrinsics::_getCharVolatile        : append_unsafe_get(callee, T_CHAR,    true); return;\n+  case vmIntrinsics::_getIntVolatile         : append_unsafe_get(callee, T_INT,     true); return;\n+  case vmIntrinsics::_getLongVolatile        : append_unsafe_get(callee, T_LONG,    true); return;\n+  case vmIntrinsics::_getFloatVolatile       : append_unsafe_get(callee, T_FLOAT,   true); return;\n+  case vmIntrinsics::_getDoubleVolatile      : append_unsafe_get(callee, T_DOUBLE,  true); return;\n+  case vmIntrinsics::_putReferenceVolatile   : append_unsafe_put(callee, T_OBJECT,  true); return;\n+  case vmIntrinsics::_putBooleanVolatile     : append_unsafe_put(callee, T_BOOLEAN, true); return;\n+  case vmIntrinsics::_putByteVolatile        : append_unsafe_put(callee, T_BYTE,    true); return;\n+  case vmIntrinsics::_putShortVolatile       : append_unsafe_put(callee, T_SHORT,   true); return;\n+  case vmIntrinsics::_putCharVolatile        : append_unsafe_put(callee, T_CHAR,    true); return;\n+  case vmIntrinsics::_putIntVolatile         : append_unsafe_put(callee, T_INT,     true); return;\n+  case vmIntrinsics::_putLongVolatile        : append_unsafe_put(callee, T_LONG,    true); return;\n+  case vmIntrinsics::_putFloatVolatile       : append_unsafe_put(callee, T_FLOAT,   true); return;\n+  case vmIntrinsics::_putDoubleVolatile      : append_unsafe_put(callee, T_DOUBLE,  true); return;\n@@ -3519,6 +3520,6 @@\n-  case vmIntrinsics::_getAndAddLong      : append_unsafe_get_and_set_obj(callee, true); return;\n-  case vmIntrinsics::_getAndSetInt       :\n-  case vmIntrinsics::_getAndSetLong      :\n-  case vmIntrinsics::_getAndSetReference : append_unsafe_get_and_set_obj(callee, false); return;\n-  case vmIntrinsics::_getCharStringU     : append_char_access(callee, false); return;\n-  case vmIntrinsics::_putCharStringU     : append_char_access(callee, true); return;\n+  case vmIntrinsics::_getAndAddLong          : append_unsafe_get_and_set(callee, true); return;\n+  case vmIntrinsics::_getAndSetInt           :\n+  case vmIntrinsics::_getAndSetLong          :\n+  case vmIntrinsics::_getAndSetReference     : append_unsafe_get_and_set(callee, false); return;\n+  case vmIntrinsics::_getCharStringU         : append_char_access(callee, false); return;\n+  case vmIntrinsics::_putCharStringU         : append_char_access(callee, true); return;\n@@ -4202,1 +4203,1 @@\n-void GraphBuilder::append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile) {\n+void GraphBuilder::append_unsafe_get(ciMethod* callee, BasicType t, bool is_volatile) {\n@@ -4209,1 +4210,1 @@\n-  Instruction* op = append(new UnsafeGetObject(t, args->at(1), offset, is_volatile));\n+  Instruction* op = append(new UnsafeGet(t, args->at(1), offset, is_volatile));\n@@ -4215,1 +4216,1 @@\n-void GraphBuilder::append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile) {\n+void GraphBuilder::append_unsafe_put(ciMethod* callee, BasicType t, bool is_volatile) {\n@@ -4227,1 +4228,1 @@\n-  Instruction* op = append(new UnsafePutObject(t, args->at(1), offset, val, is_volatile));\n+  Instruction* op = append(new UnsafePut(t, args->at(1), offset, val, is_volatile));\n@@ -4232,18 +4233,0 @@\n-\n-void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafeGetRaw(t, args->at(1), false));\n-  push(op->type(), op);\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n-void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafePutRaw(t, args->at(1), args->at(2)));\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n@@ -4337,1 +4320,1 @@\n-void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {\n+void GraphBuilder::append_unsafe_get_and_set(ciMethod* callee, bool is_add) {\n@@ -4345,1 +4328,1 @@\n-  Instruction* op = append(new UnsafeGetAndSetObject(t, args->at(1), offset, args->at(3), is_add));\n+  Instruction* op = append(new UnsafeGetAndSet(t, args->at(1), offset, args->at(3), is_add));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":62,"deletions":79,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -376,4 +376,2 @@\n-  void append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile);\n-  void append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile);\n-  void append_unsafe_get_raw(ciMethod* callee, BasicType t);\n-  void append_unsafe_put_raw(ciMethod* callee, BasicType t);\n+  void append_unsafe_get(ciMethod* callee, BasicType t, bool is_volatile);\n+  void append_unsafe_put(ciMethod* callee, BasicType t, bool is_volatile);\n@@ -381,1 +379,1 @@\n-  void append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add);\n+  void append_unsafe_get_and_set(ciMethod* callee, bool is_add);\n@@ -392,2 +390,0 @@\n-  bool count_invocations()     { return _compilation->count_invocations();     }\n-  bool count_backedges()       { return _compilation->count_backedges();       }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -98,7 +98,3 @@\n-class     UnsafeRawOp;\n-class       UnsafeGetRaw;\n-class       UnsafePutRaw;\n-class     UnsafeObjectOp;\n-class       UnsafeGetObject;\n-class       UnsafePutObject;\n-class         UnsafeGetAndSetObject;\n+class     UnsafeGet;\n+class     UnsafePut;\n+class     UnsafeGetAndSet;\n@@ -198,5 +194,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;\n-  virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;\n+  virtual void do_UnsafeGet      (UnsafeGet*       x) = 0;\n+  virtual void do_UnsafePut      (UnsafePut*       x) = 0;\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x) = 0;\n@@ -2196,1 +2190,4 @@\n-  BasicType _basic_type;    \/\/ ValueType can not express byte-sized integers\n+  Value _object;                                 \/\/ Object to be fetched from or mutated\n+  Value _offset;                                 \/\/ Offset within object\n+  bool  _is_volatile;                            \/\/ true if volatile - dl\/JSR166\n+  BasicType _basic_type;                         \/\/ ValueType can not express byte-sized integers\n@@ -2200,3 +2197,3 @@\n-  UnsafeOp(BasicType basic_type, bool is_put)\n-  : Instruction(is_put ? voidType : as_ValueType(basic_type))\n-  , _basic_type(basic_type)\n+  UnsafeOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)\n+    : Instruction(is_put ? voidType : as_ValueType(basic_type)),\n+    _object(object), _offset(offset), _is_volatile(is_volatile), _basic_type(basic_type)\n@@ -2213,0 +2210,3 @@\n+  Value object()                                 { return _object; }\n+  Value offset()                                 { return _offset; }\n+  bool  is_volatile()                            { return _is_volatile; }\n@@ -2215,47 +2215,2 @@\n-  virtual void input_values_do(ValueVisitor* f)   { }\n-};\n-\n-\n-BASE(UnsafeRawOp, UnsafeOp)\n- private:\n-  Value _base;                                   \/\/ Base address (a Java long)\n-  Value _index;                                  \/\/ Index if computed by optimizer; initialized to NULL\n-  int   _log2_scale;                             \/\/ Scale factor: 0, 1, 2, or 3.\n-                                                 \/\/ Indicates log2 of number of bytes (1, 2, 4, or 8)\n-                                                 \/\/ to scale index by.\n-\n- protected:\n-  UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(addr)\n-  , _index(NULL)\n-  , _log2_scale(0)\n-  {\n-    \/\/ Can not use ASSERT_VALUES because index may be NULL\n-    assert(addr != NULL && addr->type()->is_long(), \"just checking\");\n-  }\n-\n-  UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(base)\n-  , _index(index)\n-  , _log2_scale(log2_scale)\n-  {\n-  }\n-\n- public:\n-  \/\/ accessors\n-  Value base()                                   { return _base; }\n-  Value index()                                  { return _index; }\n-  bool  has_index()                              { return (_index != NULL); }\n-  int   log2_scale()                             { return _log2_scale; }\n-\n-  \/\/ setters\n-  void set_base (Value base)                     { _base  = base; }\n-  void set_index(Value index)                    { _index = index; }\n-  void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n-                                                   f->visit(&_base);\n-                                                   if (has_index()) f->visit(&_index); }\n+  virtual void input_values_do(ValueVisitor* f)   { f->visit(&_object);\n+                                                    f->visit(&_offset); }\n@@ -2264,2 +2219,1 @@\n-\n-LEAF(UnsafeGetRaw, UnsafeRawOp)\n+LEAF(UnsafeGet, UnsafeOp)\n@@ -2267,2 +2221,1 @@\n- bool _may_be_unaligned, _is_wide;  \/\/ For OSREntry\n-\n+  bool _is_raw;\n@@ -2270,25 +2223,2 @@\n- UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, addr, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n- UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n-  bool may_be_unaligned()                         { return _may_be_unaligned; }\n-  bool is_wide()                                  { return _is_wide; }\n-};\n-\n-\n-LEAF(UnsafePutRaw, UnsafeRawOp)\n- private:\n-  Value _value;                                  \/\/ Value to be stored\n-\n- public:\n-  UnsafePutRaw(BasicType basic_type, Value addr, Value value)\n-  : UnsafeRawOp(basic_type, addr, true)\n-  , _value(value)\n+  UnsafeGet(BasicType basic_type, Value object, Value offset, bool is_volatile)\n+  : UnsafeOp(basic_type, object, offset, false, is_volatile)\n@@ -2296,1 +2226,0 @@\n-    assert(value != NULL, \"just checking\");\n@@ -2298,0 +2227,1 @@\n+    _is_raw = false;\n@@ -2299,4 +2229,2 @@\n-\n-  UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, true)\n-  , _value(value)\n+  UnsafeGet(BasicType basic_type, Value object, Value offset, bool is_volatile, bool is_raw)\n+  : UnsafeOp(basic_type, object, offset, false, is_volatile), _is_raw(is_raw)\n@@ -2304,1 +2232,0 @@\n-    assert(value != NULL, \"just checking\");\n@@ -2309,27 +2236,1 @@\n-  Value value()                                  { return _value; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);\n-                                                   f->visit(&_value); }\n-};\n-\n-\n-BASE(UnsafeObjectOp, UnsafeOp)\n- private:\n-  Value _object;                                 \/\/ Object to be fetched from or mutated\n-  Value _offset;                                 \/\/ Offset within object\n-  bool  _is_volatile;                            \/\/ true if volatile - dl\/JSR166\n- public:\n-  UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)\n-    : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)\n-  {\n-  }\n-\n-  \/\/ accessors\n-  Value object()                                 { return _object; }\n-  Value offset()                                 { return _offset; }\n-  bool  is_volatile()                            { return _is_volatile; }\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n-                                                   f->visit(&_object);\n-                                                   f->visit(&_offset); }\n+  bool is_raw()                             { return _is_raw; }\n@@ -2339,11 +2240,1 @@\n-LEAF(UnsafeGetObject, UnsafeObjectOp)\n- public:\n-  UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)\n-  : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)\n-  {\n-    ASSERT_VALUES\n-  }\n-};\n-\n-\n-LEAF(UnsafePutObject, UnsafeObjectOp)\n+LEAF(UnsafePut, UnsafeOp)\n@@ -2353,2 +2244,2 @@\n-  UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)\n-  : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)\n+  UnsafePut(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)\n+  : UnsafeOp(basic_type, object, offset, true, is_volatile)\n@@ -2364,1 +2255,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);\n+  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n@@ -2368,1 +2259,1 @@\n-LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)\n+LEAF(UnsafeGetAndSet, UnsafeOp)\n@@ -2373,2 +2264,2 @@\n-  UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)\n-  : UnsafeObjectOp(basic_type, object, offset, false, false)\n+  UnsafeGetAndSet(BasicType basic_type, Value object, Value offset, Value value, bool is_add)\n+  : UnsafeOp(basic_type, object, offset, false, false)\n@@ -2386,1 +2277,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);\n+  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":34,"deletions":143,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -266,16 +266,0 @@\n-  output()->print(\".(\");\n-}\n-\n-void InstructionPrinter::print_unsafe_raw_op(UnsafeRawOp* op, const char* name) {\n-  print_unsafe_op(op, name);\n-  output()->print(\"base \");\n-  print_value(op->base());\n-  if (op->has_index()) {\n-    output()->print(\", index \"); print_value(op->index());\n-    output()->print(\", log2_scale %d\", op->log2_scale());\n-  }\n-}\n-\n-\n-void InstructionPrinter::print_unsafe_object_op(UnsafeObjectOp* op, const char* name) {\n-  print_unsafe_op(op, name);\n@@ -812,11 +796,2 @@\n-\n-void InstructionPrinter::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafeGetRaw\");\n-  output()->put(')');\n-}\n-\n-\n-void InstructionPrinter::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafePutRaw\");\n-  output()->print(\", value \");\n-  print_value(x->value());\n+void InstructionPrinter::do_UnsafeGet(UnsafeGet* x) {\n+  print_unsafe_op(x, x->is_raw() ? \"UnsafeGet (raw)\" : \"UnsafeGet\");\n@@ -826,9 +801,2 @@\n-\n-void InstructionPrinter::do_UnsafeGetObject(UnsafeGetObject* x) {\n-  print_unsafe_object_op(x, \"UnsafeGetObject\");\n-  output()->put(')');\n-}\n-\n-\n-void InstructionPrinter::do_UnsafePutObject(UnsafePutObject* x) {\n-  print_unsafe_object_op(x, \"UnsafePutObject\");\n+void InstructionPrinter::do_UnsafePut(UnsafePut* x) {\n+  print_unsafe_op(x, \"UnsafePut\");\n@@ -840,2 +808,2 @@\n-void InstructionPrinter::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {\n-  print_unsafe_object_op(x, x->is_add()?\"UnsafeGetAndSetObject (add)\":\"UnsafeGetAndSetObject\");\n+void InstructionPrinter::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {\n+  print_unsafe_op(x, x->is_add()?\"UnsafeGetAndSet (add)\":\"UnsafeGetAndSet\");\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,2 +77,0 @@\n-  void print_unsafe_raw_op(UnsafeRawOp* op, const char* name);\n-  void print_unsafe_object_op(UnsafeObjectOp* op, const char* name);\n@@ -126,5 +124,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -406,1 +406,0 @@\n-    case lir_backwardbranch_target:    \/\/ result and info always invalid\n@@ -1640,1 +1639,0 @@\n-     case lir_backwardbranch_target: s = \"backbranch\";    break;\n@@ -1784,2 +1782,0 @@\n-    case lir_move_unaligned:\n-      return \"unaligned move\";\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -891,1 +891,0 @@\n-      , lir_backwardbranch_target\n@@ -1022,1 +1021,0 @@\n-  lir_move_unaligned,\n@@ -2077,3 +2075,0 @@\n-  void unaligned_move(LIR_Address* src, LIR_Opr dst) { append(new LIR_Op1(lir_move, LIR_OprFact::address(src), dst, dst->type(), lir_patch_none, NULL, lir_move_unaligned)); }\n-  void unaligned_move(LIR_Opr src, LIR_Address* dst) { append(new LIR_Op1(lir_move, src, LIR_OprFact::address(dst), src->type(), lir_patch_none, NULL, lir_move_unaligned)); }\n-  void unaligned_move(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_move, src, dst, dst->type(), lir_patch_none, NULL, lir_move_unaligned)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -512,1 +512,0 @@\n-                op->move_kind() == lir_move_unaligned,\n@@ -774,1 +773,1 @@\n-void LIR_Assembler::move_op(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool unaligned, bool wide) {\n+void LIR_Assembler::move_op(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide) {\n@@ -783,1 +782,1 @@\n-      reg2mem(src, dest, type, patch_code, info, pop_fpu_stack, wide, unaligned);\n+      reg2mem(src, dest, type, patch_code, info, pop_fpu_stack, wide);\n@@ -812,2 +811,1 @@\n-    mem2reg(src, dest, type, patch_code, info, wide, unaligned);\n-\n+    mem2reg(src, dest, type, patch_code, info, wide);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-                   bool pop_fpu_stack, bool wide, bool unaligned);\n+                   bool pop_fpu_stack, bool wide);\n@@ -177,1 +177,1 @@\n-                   CodeEmitInfo* info, bool wide, bool unaligned);\n+                   CodeEmitInfo* info, bool wide);\n@@ -217,1 +217,1 @@\n-               LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool unaligned, bool wide);\n+               LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,16 +488,0 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n@@ -1862,0 +1846,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -1863,11 +1853,0 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n@@ -1875,0 +1854,2 @@\n+  length.load_item();\n+  oobef.load_item();\n@@ -1877,10 +1858,15 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n-    } else {\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+\n+  LIR_Opr len = length.result();\n+  LIR_Opr zero = NULL;\n+  if (type == T_INT) {\n+    zero = LIR_OprFact::intConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::intConst(length.result()->as_jint());\n@@ -1888,1 +1874,0 @@\n-    __ move(index.result(), result);\n@@ -1890,2 +1875,5 @@\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n+    assert(type == T_LONG, \"sanity check\");\n+    zero = LIR_OprFact::longConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::longConst(length.result()->as_jlong());\n+    }\n@@ -1893,0 +1881,28 @@\n+  \/\/ C1 can not handle the case that comparing index with constant value while condition\n+  \/\/ is neither lir_cond_equal nor lir_cond_notEqual, see LIR_Assembler::comp_op.\n+  LIR_Opr zero_reg = new_register(type);\n+  __ move(zero, zero_reg);\n+#if defined(X86) && !defined(_LP64)\n+  \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+  LIR_Opr index_copy = new_register(index.type());\n+  \/\/ index >= 0\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_less, index_copy, zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_greaterEqual, index_copy, len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#else\n+  \/\/ index >= 0\n+  __ cmp(lir_cond_less, index.result(), zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ cmp(lir_cond_greaterEqual, index.result(), len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#endif\n+  __ move(index.result(), result);\n@@ -1895,1 +1911,0 @@\n-\n@@ -2076,181 +2091,0 @@\n-\/\/ Here UnsafeGetRaw may have x->base() and x->index() be int or long\n-\/\/ on both 64 and 32 bits. Expecting x->base() to be always long on 64bit.\n-void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  LIRItem base(x->base(), this);\n-  LIRItem idx(this);\n-\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_nonconstant();\n-  }\n-\n-  LIR_Opr reg = rlock_result(x, x->basic_type());\n-\n-  int   log2_scale = 0;\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  assert(!x->has_index() || idx.value() == x->index(), \"should match\");\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      LIR_Opr long_index_op = index_op;\n-      if (index_op->is_constant()) {\n-        long_index_op = new_register(T_LONG);\n-        __ move(index_op, long_index_op);\n-      }\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, long_index_op, index_op);\n-    } else {\n-      assert(x->index()->type()->tag() == intTag, \"must be\");\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints.\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || index_op->type() == T_INT, \"index should be an int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      if (!index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-      }\n-    } else {\n-      assert(index_op->type() == T_LONG, \"must be\");\n-      if (index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ move(idx.result(), index_op);\n-      }\n-    }\n-  }\n-  \/\/ At this point base is a long non-constant\n-  \/\/ Index is a long register or a int constant.\n-  \/\/ We allow the constant to stay an int because that would allow us a more compact encoding by\n-  \/\/ embedding an immediate offset in the address expression. If we have a long constant, we have to\n-  \/\/ move it into a register first.\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a long non-constant\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && index_op->is_constant()) ||\n-                            (index_op->type() == T_LONG && !index_op->is_constant()), \"unexpected index type\");\n-#endif\n-\n-  BasicType dst_type = x->basic_type();\n-\n-  LIR_Address* addr;\n-  if (index_op->is_constant()) {\n-    assert(log2_scale == 0, \"must not have a scale\");\n-    assert(index_op->type() == T_INT, \"only int constants supported\");\n-    addr = new LIR_Address(base_op, index_op->as_jint(), dst_type);\n-  } else {\n-#ifdef X86\n-    addr = new LIR_Address(base_op, index_op, LIR_Address::Scale(log2_scale), 0, dst_type);\n-#elif defined(GENERATE_ADDRESS_IS_PREFERRED)\n-    addr = generate_address(base_op, index_op, log2_scale, 0, dst_type);\n-#else\n-    if (index_op->is_illegal() || log2_scale == 0) {\n-      addr = new LIR_Address(base_op, index_op, dst_type);\n-    } else {\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index_op, log2_scale, tmp);\n-      addr = new LIR_Address(base_op, tmp, dst_type);\n-    }\n-#endif\n-  }\n-\n-  if (x->may_be_unaligned() && (dst_type == T_LONG || dst_type == T_DOUBLE)) {\n-    __ unaligned_move(addr, reg);\n-  } else {\n-    if (dst_type == T_OBJECT && x->is_wide()) {\n-      __ move_wide(addr, reg);\n-    } else {\n-      __ move(addr, reg);\n-    }\n-  }\n-}\n-\n-\n-void LIRGenerator::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  int  log2_scale = 0;\n-  BasicType type = x->basic_type();\n-\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  LIRItem base(x->base(), this);\n-  LIRItem value(x->value(), this);\n-  LIRItem idx(this);\n-\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_item();\n-  }\n-\n-  if (type == T_BYTE || type == T_BOOLEAN) {\n-    value.load_byte_item();\n-  } else {\n-    value.load_item();\n-  }\n-\n-  set_no_result(x);\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-\n-#ifdef GENERATE_ADDRESS_IS_PREFERRED\n-  LIR_Address* addr = generate_address(base_op, index_op, log2_scale, 0, x->basic_type());\n-#else\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints and not constants\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && !index_op->is_constant()), \"index should be an non-constant int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      index_op = new_register(T_LONG);\n-      __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index are long and non-constant\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a non-constant long\");\n-  assert(!x->has_index() || (index_op->type() == T_LONG && !index_op->is_constant()), \"index must be a non-constant long\");\n-#endif\n-\n-  if (log2_scale != 0) {\n-    \/\/ temporary fix (platform dependent code without shift on Intel would be better)\n-    \/\/ TODO: ARM also allows embedded shift in the address\n-    LIR_Opr tmp = new_pointer_register();\n-    if (TwoOperandLIRForm) {\n-      __ move(index_op, tmp);\n-      index_op = tmp;\n-    }\n-    __ shift_left(index_op, log2_scale, tmp);\n-    if (!TwoOperandLIRForm) {\n-      index_op = tmp;\n-    }\n-  }\n-\n-  LIR_Address* addr = new LIR_Address(base_op, index_op, x->basic_type());\n-#endif \/\/ !GENERATE_ADDRESS_IS_PREFERRED\n-  __ move(value.result(), addr);\n-}\n-\n@@ -2258,1 +2092,1 @@\n-void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {\n+void LIRGenerator::do_UnsafeGet(UnsafeGet* x) {\n@@ -2279,2 +2113,18 @@\n-  access_load_at(decorators, type,\n-                 src, off.result(), result);\n+  if (!x->is_raw()) {\n+    access_load_at(decorators, type, src, off.result(), result);\n+  } else {\n+    \/\/ Currently it is only used in GraphBuilder::setup_osr_entry_block.\n+    \/\/ It reads the value from [src + offset] directly.\n+#ifdef _LP64\n+    LIR_Opr offset = new_register(T_LONG);\n+    __ convert(Bytecodes::_i2l, off.result(), offset);\n+#else\n+    LIR_Opr offset = off.result();\n+#endif\n+    LIR_Address* addr = new LIR_Address(src.result(), offset, type);\n+    if (type == T_LONG || type == T_DOUBLE) {\n+      __ move(addr, result);\n+    } else {\n+      access_load(IN_NATIVE, type, LIR_OprFact::address(addr), result);\n+    }\n+  }\n@@ -2284,1 +2134,1 @@\n-void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {\n+void LIRGenerator::do_UnsafePut(UnsafePut* x) {\n@@ -2310,1 +2160,1 @@\n-void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {\n+void LIRGenerator::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {\n@@ -2843,5 +2693,1 @@\n-        if (addr->type() == T_LONG || addr->type() == T_DOUBLE) {\n-          __ unaligned_move(param->result(), addr);\n-        } else {\n-          __ move(param->result(), addr);\n-        }\n+        __ move(param->result(), addr);\n@@ -3118,2 +2964,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n@@ -3352,1 +3202,1 @@\n-  if (compilation()->count_backedges()) {\n+  if (compilation()->is_profiling()) {\n@@ -3645,5 +3495,1 @@\n-      if (addr->type() == T_LONG || addr->type() == T_DOUBLE) {\n-        __ unaligned_move(arg, addr);\n-      } else {\n-        __ move(arg, addr);\n-      }\n+      __ move(arg, addr);\n@@ -3687,5 +3533,1 @@\n-      if (addr->type() == T_LONG || addr->type() == T_DOUBLE) {\n-        __ unaligned_move(arg->result(), addr);\n-      } else {\n-        __ move(arg->result(), addr);\n-      }\n+      __ move(arg->result(), addr);\n@@ -3740,7 +3582,0 @@\n-\n-LIR_Opr LIRGenerator::maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*& null_check_info) {\n-  if (x->check_boolean()) {\n-    value = mask_boolean(array, value, null_check_info);\n-  }\n-  return value;\n-}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":87,"deletions":252,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  void do_NIOCheckIndex(Intrinsic* x);\n+  void do_PreconditionsCheckIndex(Intrinsic* x, BasicType type);\n@@ -351,2 +351,0 @@\n-  \/\/ For java.nio.Buffer.checkIndex\n-  void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n@@ -402,1 +400,1 @@\n-    if (compilation()->count_invocations()) {\n+    if (compilation()->is_profiling()) {\n@@ -407,1 +405,1 @@\n-    if (compilation()->count_backedges()) {\n+    if (compilation()->is_profiling()) {\n@@ -413,1 +411,1 @@\n-    if (compilation()->count_backedges()) {\n+    if (compilation()->is_profiling()) {\n@@ -433,3 +431,0 @@\n-  void bind_block_entry(BlockBegin* block);\n-  void start_block(BlockBegin* block);\n-\n@@ -474,1 +469,0 @@\n-  void do_ClassIDIntrinsic(Intrinsic* x);\n@@ -487,1 +481,0 @@\n-  LIR_Opr maybe_mask_boolean(StoreIndexed* x, LIR_Opr array, LIR_Opr value, CodeEmitInfo*& null_check_info);\n@@ -586,5 +579,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"c1\/c1_ValueSet.inline.hpp\"\n+#include \"c1\/c1_ValueSet.hpp\"\n@@ -532,5 +532,3 @@\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  void do_UnsafeGetObject(UnsafeGetObject* x);\n-  void do_UnsafePutObject(UnsafePutObject* x);\n-  void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  void do_UnsafeGet      (UnsafeGet*       x);\n+  void do_UnsafePut      (UnsafePut*       x);\n+  void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n@@ -717,5 +715,3 @@\n-void NullCheckVisitor::do_UnsafeGetRaw   (UnsafeGetRaw*    x) {}\n-void NullCheckVisitor::do_UnsafePutRaw   (UnsafePutRaw*    x) {}\n-void NullCheckVisitor::do_UnsafeGetObject(UnsafeGetObject* x) {}\n-void NullCheckVisitor::do_UnsafePutObject(UnsafePutObject* x) {}\n-void NullCheckVisitor::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}\n+void NullCheckVisitor::do_UnsafeGet      (UnsafeGet*       x) {}\n+void NullCheckVisitor::do_UnsafePut      (UnsafePut*       x) {}\n+void NullCheckVisitor::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -133,2 +133,0 @@\n-    void do_UnsafePutRaw   (UnsafePutRaw*    x) { \/* nothing to do *\/ };\n-    void do_UnsafePutObject(UnsafePutObject* x) { \/* nothing to do *\/ };\n@@ -163,3 +161,3 @@\n-    void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ };\n-    void do_UnsafeGetObject(UnsafeGetObject* x) { \/* nothing to do *\/ };\n-    void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) { \/* nothing to do *\/ };\n+    void do_UnsafePut      (UnsafePut*       x) { \/* nothing to do *\/ };\n+    void do_UnsafeGet      (UnsafeGet*       x) { \/* nothing to do *\/ };\n+    void do_UnsafeGetAndSet(UnsafeGetAndSet* x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -351,2 +350,5 @@\n-  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_instance_slowcase_cnt++;\n+  }\n+#endif\n@@ -366,1 +368,5 @@\n-  NOT_PRODUCT(_new_type_array_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_type_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -384,2 +390,5 @@\n-  NOT_PRODUCT(_new_object_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_object_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -403,2 +412,5 @@\n-  NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)\n-\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _new_multi_array_slowcase_cnt++;\n+  }\n+#endif\n@@ -656,1 +668,5 @@\n-  NOT_PRODUCT(_throw_range_check_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_range_check_exception_count++;\n+  }\n+#endif\n@@ -666,1 +682,5 @@\n-  NOT_PRODUCT(_throw_index_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_index_exception_count++;\n+  }\n+#endif\n@@ -674,1 +694,5 @@\n-  NOT_PRODUCT(_throw_div0_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_div0_exception_count++;\n+  }\n+#endif\n@@ -680,1 +704,5 @@\n-  NOT_PRODUCT(_throw_null_pointer_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_null_pointer_exception_count++;\n+  }\n+#endif\n@@ -686,1 +714,5 @@\n-  NOT_PRODUCT(_throw_class_cast_exception_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_class_cast_exception_count++;\n+  }\n+#endif\n@@ -694,1 +726,5 @@\n-  NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _throw_incompatible_class_change_error_count++;\n+  }\n+#endif\n@@ -701,1 +737,5 @@\n-  NOT_PRODUCT(_monitorenter_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorenter_slowcase_cnt++;\n+  }\n+#endif\n@@ -711,1 +751,5 @@\n-  NOT_PRODUCT(_monitorexit_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _monitorexit_slowcase_cnt++;\n+  }\n+#endif\n@@ -863,1 +907,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++;)\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n@@ -1258,1 +1306,5 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++);\n+#ifndef PRODUCT\n+  if (PrintC1Statistics) {\n+    _patch_code_slowcase_cnt++;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":70,"deletions":18,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"c1\/c1_ValueSet.inline.hpp\"\n+#include \"c1\/c1_ValueSet.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,5 +157,3 @@\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x) { kill_memory(); }\n-  void do_UnsafePutObject(UnsafePutObject* x) { kill_memory(); }\n-  void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) { kill_memory(); }\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ }\n-  void do_UnsafeGetObject(UnsafeGetObject* x) {\n+  void do_UnsafePut      (UnsafePut*       x) { kill_memory(); }\n+  void do_UnsafeGetAndSet(UnsafeGetAndSet* x) { kill_memory(); }\n+  void do_UnsafeGet      (UnsafeGet*       x) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"c1\/c1_ValueSet.hpp\"\n-\n","filename":"src\/hotspot\/share\/c1\/c1_ValueSet.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -42,1 +43,1 @@\n-  ValueSet();\n+  ValueSet() : _map(Instruction::number_of_instructions()) {}\n@@ -44,9 +45,13 @@\n-  ValueSet* copy();\n-  bool contains(Value x);\n-  void put     (Value x);\n-  void remove  (Value x);\n-  bool set_intersect(ValueSet* other);\n-  void set_union(ValueSet* other);\n-  void clear   ();\n-  void set_from(ValueSet* other);\n-  bool equals  (ValueSet* other);\n+  ValueSet* copy() {\n+    ValueSet* res = new ValueSet();\n+    res->_map.set_from(_map);\n+    return res;\n+  }\n+  bool contains(Value x)              { return _map.at(x->id()); }\n+  void put(Value x)                   { _map.set_bit(x->id()); }\n+  void remove(Value x)                { _map.clear_bit(x->id()); }\n+  bool set_intersect(ValueSet* other) { return _map.set_intersection_with_result(other->_map); }\n+  void set_union(ValueSet* other)     { _map.set_union(other->_map); }\n+  void clear()                        { _map.clear(); }\n+  void set_from(ValueSet* other)      { _map.set_from(other->_map); }\n+  bool equals(ValueSet* other)        { return _map.is_same(other->_map); }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueSet.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_C1_C1_VALUESET_INLINE_HPP\n-#define SHARE_C1_C1_VALUESET_INLINE_HPP\n-\n-#include \"c1\/c1_ValueSet.hpp\"\n-\n-#include \"c1\/c1_Instruction.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-\n-inline ValueSet::ValueSet() : _map(Instruction::number_of_instructions()) {\n-}\n-\n-inline ValueSet* ValueSet::copy() {\n-  ValueSet* res = new ValueSet();\n-  res->_map.set_from(_map);\n-  return res;\n-}\n-\n-inline bool ValueSet::contains(Value x) {\n-  return _map.at(x->id());\n-}\n-\n-inline void ValueSet::put(Value x) {\n-  _map.set_bit(x->id());\n-}\n-\n-inline void ValueSet::remove(Value x) {\n-  _map.clear_bit(x->id());\n-}\n-\n-inline bool ValueSet::set_intersect(ValueSet* other) {\n-  return _map.set_intersection_with_result(other->_map);\n-}\n-\n-inline void ValueSet::set_union(ValueSet* other) {\n-  _map.set_union(other->_map);\n-}\n-\n-inline void ValueSet::clear() {\n-  _map.clear();\n-}\n-\n-inline void ValueSet::set_from(ValueSet* other) {\n-  _map.set_from(other->_map);\n-}\n-\n-inline bool ValueSet::equals(ValueSet* other) {\n-  return _map.is_same(other->_map);\n-}\n-\n-#endif \/\/ SHARE_C1_C1_VALUESET_INLINE_HPP\n","filename":"src\/hotspot\/share\/c1\/c1_ValueSet.inline.hpp","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -83,6 +83,0 @@\n-ValueType* ValueType::join(ValueType* y) const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class     IntInterval;\n@@ -56,2 +55,0 @@\n-class     MethodDataType;\n-class       MethodDataConstant;\n@@ -135,1 +132,0 @@\n-  bool is_method_data()                          { return as_MethodDataType() != NULL; }\n@@ -158,1 +154,0 @@\n-  virtual MethodDataType*   as_MethodDataType()  { return NULL; }\n@@ -161,1 +156,0 @@\n-\n@@ -170,1 +164,0 @@\n-  virtual MethodDataConstant* as_MethodDataConstant() { return NULL; }\n@@ -177,1 +170,0 @@\n-  ValueType* join(ValueType* y) const;\n@@ -218,19 +210,0 @@\n-class IntInterval: public IntType {\n- private:\n-  jint _beg;\n-  jint _end;\n-\n- public:\n-  IntInterval(jint beg, jint end) {\n-    assert(beg <= end, \"illegal interval\");\n-    _beg = beg;\n-    _end = end;\n-  }\n-\n-  jint beg() const                               { return _beg; }\n-  jint end() const                               { return _end; }\n-\n-  virtual bool is_interval() const               { return true; }\n-};\n-\n-\n@@ -454,22 +427,0 @@\n-class MethodDataType: public MetadataType {\n- public:\n-  virtual MethodDataType* as_MethodDataType()           { return this; }\n-};\n-\n-\n-class MethodDataConstant: public MethodDataType {\n- private:\n-  ciMethodData* _value;\n-\n- public:\n-  MethodDataConstant(ciMethodData* value)               { _value = value; }\n-\n-  ciMethodData* value() const                           { return _value; }\n-\n-  virtual bool is_constant() const                      { return true; }\n-\n-  virtual MethodDataConstant* as_MethodDataConstant()   { return this; }\n-  virtual ciMetadata* constant_value() const            { return _value; }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n-          \"Intrinsify java.nio.Buffer.checkIndex\")                          \\\n-                                                                            \\\n@@ -203,3 +200,0 @@\n-  develop(bool, LIRTracePeephole, false,                                    \\\n-          \"Trace peephole optimizer\")                                       \\\n-                                                                            \\\n@@ -300,6 +294,0 @@\n-  develop(bool, OptimizeUnsafes, true,                                      \\\n-          \"Optimize raw unsafe ops\")                                        \\\n-                                                                            \\\n-  develop(bool, PrintUnsafeOptimization, false,                             \\\n-          \"Print optimization of raw unsafe ops\")                           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  _src_obj_table(INITIAL_TABLE_SIZE),\n+  _src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -193,0 +193,3 @@\n+  if (_shared_rs.is_reserved()) {\n+    _shared_rs.release();\n+  }\n@@ -231,1 +234,1 @@\n-    \/\/ See RunTimeSharedClassInfo::get_for()\n+    \/\/ See RunTimeClassInfo::get_for()\n@@ -322,1 +325,1 @@\n-  \/\/ size of the symbol table and two dictionaries, plus the RunTimeSharedClassInfo's\n+  \/\/ size of the symbol table and two dictionaries, plus the RunTimeClassInfo's\n@@ -466,1 +469,1 @@\n-  SourceObjInfo* p = _src_obj_table.add_if_absent(src_obj, src_info, &created);\n+  SourceObjInfo* p = _src_obj_table.put_if_absent(src_obj, src_info, &created);\n@@ -468,1 +471,1 @@\n-    if (_src_obj_table.maybe_grow(MAX_TABLE_SIZE)) {\n+    if (_src_obj_table.maybe_grow()) {\n@@ -635,2 +638,2 @@\n-    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeSharedClassInfo*\n-    \/\/ without building another hashtable. See RunTimeSharedClassInfo::get_for()\n+    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeClassInfo*\n+    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\n@@ -662,1 +665,1 @@\n-  SourceObjInfo* p = _src_obj_table.lookup(src_obj);\n+  SourceObjInfo* p = _src_obj_table.get(src_obj);\n@@ -1080,1 +1083,1 @@\n-    _total_closed_heap_region_size = mapinfo->write_archive_heap_regions(\n+    _total_closed_heap_region_size = mapinfo->write_heap_regions(\n@@ -1083,3 +1086,3 @@\n-                                        MetaspaceShared::first_closed_archive_heap_region,\n-                                        MetaspaceShared::max_closed_archive_heap_region);\n-    _total_open_heap_region_size = mapinfo->write_archive_heap_regions(\n+                                        MetaspaceShared::first_closed_heap_region,\n+                                        MetaspaceShared::max_closed_heap_region);\n+    _total_open_heap_region_size = mapinfo->write_heap_regions(\n@@ -1088,2 +1091,2 @@\n-                                        MetaspaceShared::first_open_archive_heap_region,\n-                                        MetaspaceShared::max_open_archive_heap_region);\n+                                        MetaspaceShared::first_open_heap_region,\n+                                        MetaspaceShared::max_open_heap_region);\n@@ -1155,1 +1158,1 @@\n-void ArchiveBuilder::print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n+void ArchiveBuilder::print_heap_region_stats(GrowableArray<MemRegion>* regions,\n@@ -1157,1 +1160,1 @@\n-  int arr_len = heap_mem == NULL ? 0 : heap_mem->length();\n+  int arr_len = regions == NULL ? 0 : regions->length();\n@@ -1159,2 +1162,2 @@\n-      char* start = (char*)heap_mem->at(i).start();\n-      size_t size = heap_mem->at(i).byte_size();\n+      char* start = (char*)regions->at(i).start();\n+      size_t size = regions->at(i).byte_size();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -182,2 +182,2 @@\n-    bool do_entry(address key, const SourceObjInfo* value) {\n-      delete value->ref();\n+    bool do_entry(address key, const SourceObjInfo& value) {\n+      delete value.ref();\n@@ -202,1 +202,1 @@\n-  KVHashtable<address, SourceObjInfo, mtClassShared> _src_obj_table;\n+  ResizeableResourceHashtable<address, SourceObjInfo, ResourceObj::C_HEAP, mtClassShared> _src_obj_table;\n@@ -219,1 +219,1 @@\n-  void print_heap_region_stats(GrowableArray<MemRegion> *heap_mem,\n+  void print_heap_region_stats(GrowableArray<MemRegion>* regions,\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -310,1 +311,1 @@\n-  if (CompressedOops::is_null(o) || !HeapShared::open_archive_heap_region_mapped()) {\n+  if (CompressedOops::is_null(o) || !HeapShared::open_regions_mapped()) {\n@@ -315,1 +316,1 @@\n-    assert(HeapShared::open_archive_heap_region_mapped(),\n+    assert(HeapShared::open_regions_mapped(),\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+\n+  static void reset_map_and_vs() {\n+    _ptrmap = nullptr;\n+    _vs = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/cdsProtectionDomain.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+OopHandle CDSProtectionDomain::_shared_protection_domains;\n+OopHandle CDSProtectionDomain::_shared_jar_urls;\n+OopHandle CDSProtectionDomain::_shared_jar_manifests;\n+\n+\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n+\/\/ the given InstanceKlass.\n+\/\/ Returns the ProtectionDomain for the InstanceKlass.\n+Handle CDSProtectionDomain::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n+  Handle pd;\n+\n+  if (ik != NULL) {\n+    int index = ik->shared_classpath_index();\n+    assert(index >= 0, \"Sanity\");\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n+    Symbol* class_name = ik->name();\n+\n+    if (ent->is_modules_image()) {\n+      \/\/ For shared app\/platform classes originated from the run-time image:\n+      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n+      \/\/   for fast access by the VM.\n+      \/\/ all packages from module image are already created during VM bootstrap in\n+      \/\/ Modules::define_module().\n+      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n+      ModuleEntry* mod_entry = pkg_entry->module();\n+      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n+    } else {\n+      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n+      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n+      \/\/   as the shared classpath table in the shared archive (see\n+      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n+      \/\/\n+      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n+      \/\/\n+      \/\/     index = k->shared_classpath_index():\n+      \/\/\n+      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n+      \/\/\n+      \/\/   k's protection domain is:\n+      \/\/\n+      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n+      \/\/\n+      \/\/   and k's Package is initialized using\n+      \/\/\n+      \/\/     manifest = _shared_jar_manifests[index];\n+      \/\/     url = _shared_jar_urls[index];\n+      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      \/\/\n+      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n+      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n+      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n+      Handle url = get_shared_jar_url(index, CHECK_(pd));\n+      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n+      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n+        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n+          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n+          \/\/ in the shared class path.\n+          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+          if (pkg_entry != NULL) {\n+            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n+          }\n+        }\n+      } else {\n+        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n+      }\n+      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n+    }\n+  }\n+  return pd;\n+}\n+\n+Handle CDSProtectionDomain::get_package_name(Symbol* class_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Handle pkgname_string;\n+  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n+  if (pkg != NULL) { \/\/ Package prefix found\n+    const char* pkgname = pkg->as_klass_external_name();\n+    pkgname_string = java_lang_String::create_from_str(pkgname,\n+                                                       CHECK_(pkgname_string));\n+  }\n+  return pkgname_string;\n+}\n+\n+PackageEntry* CDSProtectionDomain::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n+  PackageEntry* pkg_entry = ik->package();\n+  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n+    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n+    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n+    return pkg_entry;\n+  }\n+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n+  if (pkg_name != NULL) {\n+    pkg_entry = SystemDictionaryShared::class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n+  } else {\n+    pkg_entry = NULL;\n+  }\n+  return pkg_entry;\n+}\n+\n+\/\/ Define Package for shared app classes from JAR file and also checks for\n+\/\/ package sealing (all done in Java code)\n+\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n+void CDSProtectionDomain::define_shared_package(Symbol*  class_name,\n+                                                   Handle class_loader,\n+                                                   Handle manifest,\n+                                                   Handle url,\n+                                                   TRAPS) {\n+  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n+  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n+  Handle pkgname_string = get_package_name(class_name, CHECK);\n+  if (pkgname_string.not_null()) {\n+    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n+    JavaValue result(T_OBJECT);\n+    JavaCallArguments args(3);\n+    args.set_receiver(class_loader);\n+    args.push_oop(pkgname_string);\n+    args.push_oop(manifest);\n+    args.push_oop(url);\n+    JavaCalls::call_virtual(&result, app_classLoader_klass,\n+                            vmSymbols::defineOrCheckPackage_name(),\n+                            vmSymbols::defineOrCheckPackage_signature(),\n+                            &args,\n+                            CHECK);\n+  }\n+}\n+\n+Handle CDSProtectionDomain::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n+  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n+  typeArrayHandle bufhandle(THREAD, buf);\n+  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n+                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n+                      vmSymbols::byte_array_void_signature(),\n+                      bufhandle, CHECK_NH);\n+  \/\/ manifest = new Manifest(ByteArrayInputStream)\n+  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n+                      vmSymbols::input_stream_void_signature(),\n+                      bais, CHECK_NH);\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n+  Handle manifest;\n+  if (shared_jar_manifest(shared_path_index) == NULL) {\n+    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n+    size_t size = (size_t)ent->manifest_size();\n+    if (size == 0) {\n+      return Handle();\n+    }\n+\n+    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n+    const char* src = ent->manifest();\n+    assert(src != NULL, \"No Manifest data\");\n+    manifest = create_jar_manifest(src, size, CHECK_NH);\n+    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n+  }\n+  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n+  assert(manifest.not_null(), \"sanity\");\n+  return manifest;\n+}\n+\n+Handle CDSProtectionDomain::get_shared_jar_url(int shared_path_index, TRAPS) {\n+  Handle url_h;\n+  if (shared_jar_url(shared_path_index) == NULL) {\n+    JavaValue result(T_OBJECT);\n+    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n+    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n+    Klass* classLoaders_klass =\n+        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+    JavaCalls::call_static(&result, classLoaders_klass,\n+                           vmSymbols::toFileURL_name(),\n+                           vmSymbols::toFileURL_signature(),\n+                           path_string, CHECK_(url_h));\n+\n+    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n+  }\n+\n+  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n+  assert(url_h.not_null(), \"sanity\");\n+  return url_h;\n+}\n+\n+\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n+Handle CDSProtectionDomain::get_protection_domain_from_classloader(Handle class_loader,\n+                                                                      Handle url, TRAPS) {\n+  \/\/ CodeSource cs = new CodeSource(url, null);\n+  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n+                  vmSymbols::url_code_signer_array_void_signature(),\n+                  url, Handle(), CHECK_NH);\n+\n+  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n+  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n+  JavaValue obj_result(T_OBJECT);\n+  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n+                          vmSymbols::getProtectionDomain_name(),\n+                          vmSymbols::getProtectionDomain_signature(),\n+                          cs, CHECK_NH);\n+  return Handle(THREAD, obj_result.get_oop());\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                            int shared_path_index,\n+                                                            Handle url,\n+                                                            TRAPS) {\n+  Handle protection_domain;\n+  if (shared_protection_domain(shared_path_index) == NULL) {\n+    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n+    atomic_set_shared_protection_domain(shared_path_index, pd());\n+  }\n+\n+  \/\/ Acquire from the cache because if another thread beats the current one to\n+  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n+  \/\/ needs to get the updated protection_domain from the cache.\n+  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n+Handle CDSProtectionDomain::get_shared_protection_domain(Handle class_loader,\n+                                                         ModuleEntry* mod, TRAPS) {\n+  ClassLoaderData *loader_data = mod->loader_data();\n+  if (mod->shared_protection_domain() == NULL) {\n+    Symbol* location = mod->location();\n+    if (location != NULL) {\n+      Handle location_string = java_lang_String::create_from_symbol(\n+                                     location, CHECK_NH);\n+      Handle url;\n+      JavaValue result(T_OBJECT);\n+      if (location->starts_with(\"jrt:\/\")) {\n+        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n+                                                vmSymbols::string_void_signature(),\n+                                                location_string, CHECK_NH);\n+      } else {\n+        Klass* classLoaders_klass =\n+          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n+        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n+                               vmSymbols::toFileURL_signature(),\n+                               location_string, CHECK_NH);\n+        url = Handle(THREAD, result.get_oop());\n+      }\n+\n+      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n+                                                         CHECK_NH);\n+      mod->set_shared_protection_domain(loader_data, pd);\n+    }\n+  }\n+\n+  Handle protection_domain(THREAD, mod->shared_protection_domain());\n+  assert(protection_domain.not_null(), \"sanity\");\n+  return protection_domain;\n+}\n+\n+void CDSProtectionDomain::atomic_set_array_index(OopHandle array, int index, oop o) {\n+  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n+  \/\/ The important thing here is that all threads pick up the same result.\n+  \/\/ It doesn't matter which racing thread wins, as long as only one\n+  \/\/ result is used by all threads, and all future queries.\n+  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n+}\n+\n+oop CDSProtectionDomain::shared_protection_domain(int index) {\n+  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_protection_domain_array(int size, TRAPS) {\n+  if (_shared_protection_domains.resolve() == NULL) {\n+    oop spd = oopFactory::new_objArray(\n+        vmClasses::ProtectionDomain_klass(), size, CHECK);\n+    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_url(int index) {\n+  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_url_array(int size, TRAPS) {\n+  if (_shared_jar_urls.resolve() == NULL) {\n+    oop sju = oopFactory::new_objArray(\n+        vmClasses::URL_klass(), size, CHECK);\n+    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n+  }\n+}\n+\n+oop CDSProtectionDomain::shared_jar_manifest(int index) {\n+  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n+}\n+\n+void CDSProtectionDomain::allocate_shared_jar_manifest_array(int size, TRAPS) {\n+  if (_shared_jar_manifests.resolve() == NULL) {\n+    oop sjm = oopFactory::new_objArray(\n+        vmClasses::Jar_Manifest_klass(), size, CHECK);\n+    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#define SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+class PackageEntry;\n+class ModuleEntry;\n+\n+\/\/ CDS security\n+class CDSProtectionDomain : AllStatic {\n+  \/\/ See init_security_info for more info.\n+  static OopHandle _shared_protection_domains;\n+  static OopHandle _shared_jar_urls;\n+  static OopHandle _shared_jar_manifests;\n+\n+public:\n+  \/\/ Package handling:\n+  \/\/\n+  \/\/ 1. For named modules in the runtime image\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n+  \/\/                  to get packages in named modules for shared classes.\n+  \/\/                  Package for non-shared classes in named module is also\n+  \/\/                  handled using JVM_GetSystemPackage(s).\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared app classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n+  \/\/                  to define package for shared platform classes from named\n+  \/\/                  modules.\n+  \/\/\n+  \/\/ 2. For unnamed modules\n+  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n+  \/\/                  get packages for shared boot classes in unnamed modules.\n+  \/\/\n+  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n+  \/\/                  with with the manifest and url from archived data.\n+  \/\/\n+  \/\/    PLATFORM  classes: No package is defined.\n+  \/\/\n+  \/\/ The following two define_shared_package() functions are used to define\n+  \/\/ package for shared APP and PLATFORM classes.\n+  static Handle        get_package_name(Symbol*  class_name, TRAPS);\n+  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n+  static void define_shared_package(Symbol*  class_name,\n+                                    Handle class_loader,\n+                                    Handle manifest,\n+                                    Handle url,\n+                                    TRAPS);\n+  static Handle create_jar_manifest(const char* man, size_t size, TRAPS);\n+  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n+  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n+  static Handle get_protection_domain_from_classloader(Handle class_loader,\n+                                                       Handle url, TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             int shared_path_index,\n+                                             Handle url,\n+                                             TRAPS);\n+  static Handle get_shared_protection_domain(Handle class_loader,\n+                                             ModuleEntry* mod, TRAPS);\n+  static void atomic_set_array_index(OopHandle array, int index, oop o);\n+  static oop shared_protection_domain(int index);\n+  static void allocate_shared_protection_domain_array(int size, TRAPS);\n+  static oop shared_jar_url(int index);\n+  static void allocate_shared_jar_url_array(int size, TRAPS);\n+  static oop shared_jar_manifest(int index);\n+  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n+  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n+\n+  static void allocate_shared_data_arrays(int size, TRAPS) {\n+    allocate_shared_protection_domain_array(size, CHECK);\n+    allocate_shared_jar_url_array(size, CHECK);\n+    allocate_shared_jar_manifest_array(size, CHECK);\n+  }\n+  static void atomic_set_shared_protection_domain(int index, oop pd) {\n+    atomic_set_array_index(_shared_protection_domains, index, pd);\n+  }\n+  static void atomic_set_shared_jar_url(int index, oop url) {\n+    atomic_set_array_index(_shared_jar_urls, index, url);\n+  }\n+  static void atomic_set_shared_jar_manifest(int index, oop man) {\n+    atomic_set_array_index(_shared_jar_manifests, index, man);\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_CDSPROTECTIONDOMAIN_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n@@ -88,1 +88,1 @@\n-  if (_file) {\n+  if (_file != NULL) {\n@@ -92,0 +92,2 @@\n+  delete _indy_items;\n+  delete _interfaces;\n@@ -467,1 +469,1 @@\n-  bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n+  bool added = SystemDictionaryShared::add_unregistered_class_for_static_archive(THREAD, k);\n@@ -508,1 +510,1 @@\n-bool ClassListParser::is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS) {\n+bool ClassListParser::is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS) {\n@@ -615,1 +617,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n@@ -617,1 +618,1 @@\n-    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle ext_class_name = java_lang_String::externalize_classname(class_name_symbol, CHECK_NULL);\n@@ -645,2 +646,3 @@\n-    InstanceKlass** old_ptr = table()->lookup(id);\n-    if (old_ptr != NULL) {\n+    bool created;\n+    id2klass_table()->put_if_absent(id, ik, &created);\n+    if (!created) {\n@@ -649,1 +651,3 @@\n-    table()->add(id, ik);\n+    if (id2klass_table()->maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n+    }\n@@ -660,1 +664,1 @@\n-  InstanceKlass** klass_ptr = table()->lookup(id);\n+  InstanceKlass** klass_ptr = id2klass_table()->get(id);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -36,0 +36,1 @@\n+class constantPoolHandle;\n@@ -69,1 +70,3 @@\n-  typedef KVHashtable<int, InstanceKlass*, mtInternal> ID2KlassTable;\n+  \/\/ Must be C_HEAP allocated -- we don't want nested resource allocations.\n+  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+                                      ResourceObj::C_HEAP, mtClassShared> ID2KlassTable;\n@@ -83,1 +86,3 @@\n-  static const int INITIAL_TABLE_SIZE = 1987;\n+  \/\/ Use a small initial size in debug build to test resizing logic\n+  static const int INITIAL_TABLE_SIZE = DEBUG_ONLY(17) NOT_DEBUG(1987);\n+  static const int MAX_TABLE_SIZE = 61333;\n@@ -109,1 +114,1 @@\n-  ID2KlassTable* table() {\n+  ID2KlassTable* id2klass_table() {\n@@ -115,1 +120,1 @@\n-  bool is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS);\n+  bool is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS);\n@@ -164,1 +169,1 @@\n-    if (_id2klass_table.lookup(id) == NULL) {\n+    if (!id2klass_table()->contains(id)) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+\n+DumpTimeClassInfo DumpTimeClassInfo::clone() {\n+  DumpTimeClassInfo clone;\n+  clone._klass = _klass;\n+  clone._nest_host = _nest_host;\n+  clone._failed_verification = _failed_verification;\n+  clone._is_archived_lambda_proxy = _is_archived_lambda_proxy;\n+  clone._has_checked_exclusion = _has_checked_exclusion;\n+  clone._id = _id;\n+  clone._clsfile_size = _clsfile_size;\n+  clone._clsfile_crc32 = _clsfile_crc32;\n+  clone._excluded = _excluded;\n+  clone._is_early_klass = _is_early_klass;\n+  clone._verifier_constraints = NULL;\n+  clone._verifier_constraint_flags = NULL;\n+  clone._loader_constraints = NULL;\n+  int clone_num_verifier_constraints = num_verifier_constraints();\n+  if (clone_num_verifier_constraints > 0) {\n+    clone._verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(clone_num_verifier_constraints, mtClass);\n+    clone._verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(clone_num_verifier_constraints, mtClass);\n+    for (int i = 0; i < clone_num_verifier_constraints; i++) {\n+      clone._verifier_constraints->append(_verifier_constraints->at(i));\n+      clone._verifier_constraint_flags->append(_verifier_constraint_flags->at(i));\n+    }\n+  }\n+  int clone_num_loader_constraints = num_loader_constraints();\n+  if (clone_num_loader_constraints > 0) {\n+    clone._loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(clone_num_loader_constraints, mtClass);\n+    for (int i = 0; i < clone_num_loader_constraints; i++) {\n+      clone._loader_constraints->append(_loader_constraints->at(i));\n+    }\n+  }\n+  return clone;\n+}\n+\n+void DumpTimeClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n+  if (_verifier_constraints == NULL) {\n+    _verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+  }\n+  if (_verifier_constraint_flags == NULL) {\n+    _verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n+  }\n+  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n+  for (int i = 0; i < vc_array->length(); i++) {\n+    DTVerifierConstraint* p = vc_array->adr_at(i);\n+    if (name == p->_name && from_name == p->_from_name) {\n+      return;\n+    }\n+  }\n+  DTVerifierConstraint cons(name, from_name);\n+  vc_array->append(cons);\n+\n+  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n+  char c = 0;\n+  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n+  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n+  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n+  vcflags_array->append(c);\n+\n+  if (log_is_enabled(Trace, cds, verification)) {\n+    ResourceMark rm;\n+    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n+                                 k->external_name(), from_name->as_klass_external_name(),\n+                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  }\n+}\n+\n+static char get_loader_type_by(oop  loader) {\n+  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n+  if (SystemDictionary::is_boot_class_loader(loader)) {\n+    return (char)ClassLoader::BOOT_LOADER;\n+  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+    return (char)ClassLoader::PLATFORM_LOADER;\n+  } else {\n+    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n+    return (char)ClassLoader::APP_LOADER;\n+  }\n+}\n+\n+void DumpTimeClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n+  assert(loader1 != loader2, \"sanity\");\n+  LogTarget(Info, class, loader, constraints) log;\n+  if (_loader_constraints == NULL) {\n+    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n+  }\n+  char lt1 = get_loader_type_by(loader1());\n+  char lt2 = get_loader_type_by(loader2());\n+  DTLoaderConstraint lc(name, lt1, lt2);\n+  for (int i = 0; i < _loader_constraints->length(); i++) {\n+    DTLoaderConstraint dt = _loader_constraints->at(i);\n+    if (lc.equals(dt)) {\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n+                  _klass->external_name(), name->as_C_string(),\n+                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n+      }\n+      return;\n+    }\n+  }\n+  _loader_constraints->append(lc);\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n+    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n+              _klass->external_name(), name->as_C_string(),\n+              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n+              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n+              _loader_constraints->length());\n+  }\n+}\n+\n+bool DumpTimeClassInfo::is_builtin() {\n+  return SystemDictionaryShared::is_builtin(_klass);\n+}\n+\n+DumpTimeClassInfo* DumpTimeSharedClassTable::find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n+  bool created = false;\n+  DumpTimeClassInfo* p;\n+  if (!dump_in_progress) {\n+    p = put_if_absent(k, &created);\n+  } else {\n+    p = get(k);\n+  }\n+  if (created) {\n+    assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n+           \"no new classes can be loaded while dumping archive\");\n+    p->_klass = k;\n+  } else {\n+    if (!dump_in_progress) {\n+      assert(p->_klass == k, \"Sanity\");\n+    }\n+  }\n+  return p;\n+}\n+\n+class CountClassByCategory : StackObj {\n+  DumpTimeSharedClassTable* _table;\n+public:\n+  CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      if (info.is_builtin()) {\n+        _table->inc_builtin_count();\n+      } else {\n+        _table->inc_unregistered_count();\n+      }\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void DumpTimeSharedClassTable::update_counts() {\n+  _builtin_count = 0;\n+  _unregistered_count = 0;\n+  CountClassByCategory counter(this);\n+  iterate(&counter);\n+}\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#define SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class DumpTimeClassInfo: public CHeapObj<mtClass> {\n+  bool                         _excluded;\n+  bool                         _is_early_klass;\n+  bool                         _has_checked_exclusion;\n+public:\n+  struct DTLoaderConstraint {\n+    Symbol* _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n+      _name->increment_refcount();\n+    }\n+    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    bool equals(const DTLoaderConstraint& t) {\n+      return t._name == _name &&\n+             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n+              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n+    }\n+  };\n+\n+  struct DTVerifierConstraint {\n+    Symbol* _name;\n+    Symbol* _from_name;\n+    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n+      _name->increment_refcount();\n+      _from_name->increment_refcount();\n+    }\n+  };\n+\n+  InstanceKlass*               _klass;\n+  InstanceKlass*               _nest_host;\n+  bool                         _failed_verification;\n+  bool                         _is_archived_lambda_proxy;\n+  int                          _id;\n+  int                          _clsfile_size;\n+  int                          _clsfile_crc32;\n+  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n+  GrowableArray<char>*                 _verifier_constraint_flags;\n+  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n+\n+  DumpTimeClassInfo() {\n+    _klass = NULL;\n+    _nest_host = NULL;\n+    _failed_verification = false;\n+    _is_archived_lambda_proxy = false;\n+    _has_checked_exclusion = false;\n+    _id = -1;\n+    _clsfile_size = -1;\n+    _clsfile_crc32 = -1;\n+    _excluded = false;\n+    _is_early_klass = JvmtiExport::is_early_phase();\n+    _verifier_constraints = NULL;\n+    _verifier_constraint_flags = NULL;\n+    _loader_constraints = NULL;\n+  }\n+\n+  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n+         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n+  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n+\n+  bool is_builtin();\n+\n+  int num_verifier_constraints() {\n+    if (_verifier_constraint_flags != NULL) {\n+      return _verifier_constraint_flags->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  int num_loader_constraints() {\n+    if (_loader_constraints != NULL) {\n+      return _loader_constraints->length();\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_klass);\n+    it->push(&_nest_host);\n+    if (_verifier_constraints != NULL) {\n+      for (int i = 0; i < _verifier_constraints->length(); i++) {\n+        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n+        it->push(&cons->_name);\n+        it->push(&cons->_from_name);\n+      }\n+    }\n+    if (_loader_constraints != NULL) {\n+      for (int i = 0; i < _loader_constraints->length(); i++) {\n+        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n+        it->push(&lc->_name);\n+      }\n+    }\n+  }\n+\n+  bool is_excluded() {\n+    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n+    return _excluded || _failed_verification || _klass == NULL;\n+  }\n+\n+  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n+  bool is_early_klass() {\n+    return _is_early_klass;\n+  }\n+\n+  \/\/ simple accessors\n+  void set_excluded()                               { _excluded = true; }\n+  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n+  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n+  bool failed_verification() const                  { return _failed_verification; }\n+  void set_failed_verification()                    { _failed_verification = true; }\n+  InstanceKlass* nest_host() const                  { return _nest_host; }\n+  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n+  DumpTimeClassInfo clone();\n+};\n+\n+\n+inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n+  if (DumpSharedSpaces) {\n+    \/\/ Deterministic archive contents\n+    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n+    return primitive_hash<uintx>(delta);\n+  } else {\n+    \/\/ Deterministic archive is not possible because classes can be loaded\n+    \/\/ in multiple threads.\n+    return primitive_hash<InstanceKlass*>(k);\n+  }\n+}\n+\n+class DumpTimeSharedClassTable: public ResourceHashtable<\n+  InstanceKlass*,\n+  DumpTimeClassInfo,\n+  &DumpTimeSharedClassTable_hash,\n+  primitive_equals<InstanceKlass*>,\n+  15889, \/\/ prime number\n+  ResourceObj::C_HEAP>\n+{\n+  int _builtin_count;\n+  int _unregistered_count;\n+public:\n+  DumpTimeSharedClassTable() {\n+    _builtin_count = 0;\n+    _unregistered_count = 0;\n+  }\n+  DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress);\n+  void inc_builtin_count()      { _builtin_count++; }\n+  void inc_unregistered_count() { _unregistered_count++; }\n+  void update_counts();\n+  int count_of(bool is_builtin) const {\n+    if (is_builtin) {\n+      return _builtin_count;\n+    } else {\n+      return _unregistered_count;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARED_CDS_DUMPTIMESHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -86,0 +86,1 @@\n+  void post_dump();\n@@ -115,0 +116,3 @@\n+    \/\/ save dumptime tables\n+    SystemDictionaryShared::clone_dumptime_tables();\n+\n@@ -161,0 +165,5 @@\n+    post_dump();\n+\n+    \/\/ Restore dumptime tables\n+    SystemDictionaryShared::restore_dumptime_tables();\n+\n@@ -197,0 +206,4 @@\n+void DynamicArchiveBuilder::post_dump() {\n+  ArchivePtrMarker::reset_map_and_vs();\n+}\n+\n@@ -260,2 +273,8 @@\n-  ik->vtable().initialize_vtable();\n-  ik->itable().initialize_itable();\n+  if (ik->is_linked()) {\n+    \/\/ If the class has already been linked, we must relayout the i\/v tables, whose order depends\n+    \/\/ on the method sorting order.\n+    \/\/ If the class is unlinked, we cannot layout the i\/v tables yet. This is OK, as the\n+    \/\/ i\/v tables will be initialized at runtime after bytecode verification.\n+    ik->vtable().initialize_vtable();\n+    ik->itable().initialize_itable();\n+  }\n@@ -322,1 +341,1 @@\n-    if (SystemDictionaryShared::empty_dumptime_table()) {\n+    if (SystemDictionaryShared::is_dumptime_table_empty()) {\n@@ -336,1 +355,1 @@\n-void DynamicArchive::prepare_for_dynamic_dumping_at_exit() {\n+void DynamicArchive::prepare_for_dynamic_dumping() {\n@@ -339,1 +358,1 @@\n-  MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+  MetaspaceShared::link_shared_classes(THREAD);\n@@ -341,1 +360,1 @@\n-    log_error(cds)(\"ArchiveClassesAtExit has failed\");\n+    log_error(cds)(\"Dynamic dump has failed\");\n@@ -350,2 +369,0 @@\n-bool DynamicArchive::_has_been_dumped_once = false;\n-\n@@ -355,15 +372,5 @@\n-  \/\/ During dynamic archive dumping, some of the data structures are overwritten so\n-  \/\/ we cannot dump the dynamic archive again. TODO: this should be fixed.\n-  if (has_been_dumped_once()) {\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-        \"Dynamic dump has been done, and should only be done once\");\n-  } else {\n-    \/\/ prevent multiple dumps.\n-    set_has_been_dumped_once();\n-    ArchiveClassesAtExit = archive_name;\n-    if (Arguments::init_shared_archive_paths()) {\n-      dump();\n-    } else {\n-      ArchiveClassesAtExit = nullptr;\n-      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-              \"Could not setup SharedDynamicArchivePath\");\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n+    prepare_for_dynamic_dumping();\n+    if (DynamicDumpSharedSpaces) {\n+      dump(CHECK);\n@@ -371,1 +378,1 @@\n-    \/\/ prevent do dynamic dump at exit.\n+  } else {\n@@ -373,4 +380,8 @@\n-    if (!Arguments::init_shared_archive_paths()) {\n-      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-             \"Could not restore SharedDynamicArchivePath\");\n-    }\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not setup SharedDynamicArchivePath\");\n+  }\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not restore SharedDynamicArchivePath\");\n@@ -380,1 +391,1 @@\n-void DynamicArchive::dump() {\n+void DynamicArchive::dump(TRAPS) {\n@@ -386,0 +397,3 @@\n+  \/\/ copy shared path table to saved.\n+  FileMapInfo::clone_shared_path_table(CHECK);\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":43,"deletions":29,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  static bool _has_been_dumped_once;\n@@ -63,1 +62,1 @@\n-  static void prepare_for_dynamic_dumping_at_exit();\n+  static void prepare_for_dynamic_dumping();\n@@ -65,3 +64,1 @@\n-  static void dump();\n-  static bool has_been_dumped_once() { return _has_been_dumped_once; }\n-  static void set_has_been_dumped_once() { _has_been_dumped_once = true; }\n+  static void dump(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -243,0 +244,1 @@\n+  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n@@ -296,0 +298,1 @@\n+  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -478,0 +481,18 @@\n+  _saved_shared_path_table_array = array;\n+}\n+\n+void FileMapInfo::clone_shared_path_table(TRAPS) {\n+  Arguments::assert_is_dumping_archive();\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+  ClassPathEntry* jrt = ClassLoader::get_jrt_entry();\n+\n+  assert(jrt != NULL,\n+         \"No modular java runtime image present when allocating the CDS classpath entry table\");\n+\n+  if (_saved_shared_path_table_array != NULL) {\n+    MetadataFactory::free_array<u8>(loader_data, _saved_shared_path_table_array);\n+    _saved_shared_path_table_array = NULL;\n+  }\n+\n+  copy_shared_path_table(loader_data, CHECK);\n@@ -503,2 +524,1 @@\n-\n-  copy_shared_path_table(loader_data, CHECK);\n+  clone_shared_path_table(CHECK);\n@@ -720,1 +740,1 @@\n-\n+  JavaThread* current = JavaThread::current();\n@@ -722,0 +742,1 @@\n+  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n@@ -724,3 +745,14 @@\n-    struct stat st;\n-    if (os::stat(path, &st) == 0) {\n-      path_array->append(path);\n+    if (!non_jar_in_cp) {\n+      struct stat st;\n+      if (os::stat(path, &st) == 0) {\n+        path_array->append(path);\n+      }\n+    } else {\n+      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n+      if (canonical_path != NULL) {\n+        char* error_msg = NULL;\n+        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n+        if (zip != NULL && error_msg == NULL) {\n+          path_array->append(path);\n+        }\n+      }\n@@ -1377,1 +1409,1 @@\n-\/\/ produces the 'heap_mem' array.\n+\/\/ produces the 'regions' array.\n@@ -1383,1 +1415,1 @@\n-\/\/ the 'heap_mem' array may contain more than one consolidated MemRegions. When\n+\/\/ the 'regions' array may contain more than one consolidated MemRegions. When\n@@ -1406,3 +1438,3 @@\n-size_t FileMapInfo::write_archive_heap_regions(GrowableArray<MemRegion> *heap_mem,\n-                                               GrowableArray<ArchiveHeapOopmapInfo> *oopmaps,\n-                                               int first_region_id, int max_num_regions) {\n+size_t FileMapInfo::write_heap_regions(GrowableArray<MemRegion>* regions,\n+                                       GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                                       int first_region_id, int max_num_regions) {\n@@ -1411,2 +1443,2 @@\n-  int arr_len = heap_mem == NULL ? 0 : heap_mem->length();\n-  if(arr_len > max_num_regions) {\n+  int arr_len = regions == NULL ? 0 : regions->length();\n+  if (arr_len > max_num_regions) {\n@@ -1425,2 +1457,2 @@\n-      start = (char*)heap_mem->at(i).start();\n-      size = heap_mem->at(i).byte_size();\n+      start = (char*)regions->at(i).start();\n+      size = regions->at(i).byte_size();\n@@ -1737,4 +1769,4 @@\n-static MemRegion *closed_archive_heap_ranges = NULL;\n-static MemRegion *open_archive_heap_ranges = NULL;\n-static int num_closed_archive_heap_ranges = 0;\n-static int num_open_archive_heap_ranges = 0;\n+static MemRegion *closed_heap_regions = NULL;\n+static MemRegion *open_heap_regions = NULL;\n+static int num_closed_heap_regions = 0;\n+static int num_open_heap_regions = 0;\n@@ -1744,1 +1776,1 @@\n-  return (space_at(MetaspaceShared::first_closed_archive_heap_region)->used() > 0);\n+  return (space_at(MetaspaceShared::first_closed_heap_region)->used() > 0);\n@@ -1755,1 +1787,1 @@\n-  for (int i = MetaspaceShared::first_closed_archive_heap_region;\n+  for (int i = MetaspaceShared::first_closed_heap_region;\n@@ -1870,1 +1902,1 @@\n-  FileMapRegion* si = space_at(MetaspaceShared::first_closed_archive_heap_region);\n+  FileMapRegion* si = space_at(MetaspaceShared::first_closed_heap_region);\n@@ -1889,14 +1921,13 @@\n-  \/\/ Map the closed_archive_heap regions, GC does not write into the regions.\n-  if (map_heap_data(&closed_archive_heap_ranges,\n-                    MetaspaceShared::first_closed_archive_heap_region,\n-                    MetaspaceShared::max_closed_archive_heap_region,\n-                    &num_closed_archive_heap_ranges)) {\n-    HeapShared::set_closed_archive_heap_region_mapped();\n-\n-    \/\/ Now, map open_archive heap regions, GC can write into the regions.\n-    if (map_heap_data(&open_archive_heap_ranges,\n-                      MetaspaceShared::first_open_archive_heap_region,\n-                      MetaspaceShared::max_open_archive_heap_region,\n-                      &num_open_archive_heap_ranges,\n-                      true \/* open *\/)) {\n-      HeapShared::set_open_archive_heap_region_mapped();\n+  \/\/ Map the closed heap regions: GC does not write into these regions.\n+  if (map_heap_regions(MetaspaceShared::first_closed_heap_region,\n+                       MetaspaceShared::max_closed_heap_region,\n+                       \/*is_open_archive=*\/ false,\n+                       &closed_heap_regions, &num_closed_heap_regions)) {\n+    HeapShared::set_closed_regions_mapped();\n+\n+    \/\/ Now, map the open heap regions: GC can write into these regions.\n+    if (map_heap_regions(MetaspaceShared::first_open_heap_region,\n+                         MetaspaceShared::max_open_heap_region,\n+                         \/*is_open_archive=*\/ true,\n+                         &open_heap_regions, &num_open_heap_regions)) {\n+      HeapShared::set_open_regions_mapped();\n@@ -1913,3 +1944,3 @@\n-  if (!HeapShared::closed_archive_heap_region_mapped()) {\n-    assert(closed_archive_heap_ranges == NULL &&\n-           num_closed_archive_heap_ranges == 0, \"sanity\");\n+  if (!HeapShared::closed_regions_mapped()) {\n+    assert(closed_heap_regions == NULL &&\n+           num_closed_heap_regions == 0, \"sanity\");\n@@ -1918,2 +1949,2 @@\n-  if (!HeapShared::open_archive_heap_region_mapped()) {\n-    assert(open_archive_heap_ranges == NULL && num_open_archive_heap_ranges == 0, \"sanity\");\n+  if (!HeapShared::open_regions_mapped()) {\n+    assert(open_heap_regions == NULL && num_open_heap_regions == 0, \"sanity\");\n@@ -1924,2 +1955,2 @@\n-bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,\n-                                int max, int* num, bool is_open_archive) {\n+bool FileMapInfo::map_heap_regions(int first, int max,  bool is_open_archive,\n+                                   MemRegion** regions_ret, int* num_regions_ret) {\n@@ -1937,1 +1968,1 @@\n-  int region_num = 0;\n+  int num_regions = 0;\n@@ -1945,2 +1976,2 @@\n-      regions[region_num] = MemRegion(start, size \/ HeapWordSize);\n-      region_num ++;\n+      regions[num_regions] = MemRegion(start, size \/ HeapWordSize);\n+      num_regions ++;\n@@ -1952,1 +1983,1 @@\n-  if (region_num == 0) {\n+  if (num_regions == 0) {\n@@ -1956,2 +1987,2 @@\n-  \/\/ Check that ranges are within the java heap\n-  if (!G1CollectedHeap::heap()->check_archive_addresses(regions, region_num)) {\n+  \/\/ Check that regions are within the java heap\n+  if (!G1CollectedHeap::heap()->check_archive_addresses(regions, num_regions)) {\n@@ -1964,1 +1995,1 @@\n-             regions, region_num, is_open_archive)) {\n+             regions, num_regions, is_open_archive)) {\n@@ -1972,1 +2003,1 @@\n-  for (int i = 0; i < region_num; i++) {\n+  for (int i = 0; i < num_regions; i++) {\n@@ -1980,1 +2011,1 @@\n-      dealloc_archive_heap_regions(regions, region_num);\n+      dealloc_heap_regions(regions, num_regions);\n@@ -1989,1 +2020,1 @@\n-      dealloc_archive_heap_regions(regions, region_num);\n+      dealloc_heap_regions(regions, num_regions);\n@@ -1997,2 +2028,2 @@\n-  *heap_mem = regions;\n-  *num = region_num;\n+  *regions_ret = regions;\n+  *num_regions_ret = num_regions;\n@@ -2002,1 +2033,1 @@\n-void FileMapInfo::patch_archived_heap_embedded_pointers() {\n+void FileMapInfo::patch_heap_embedded_pointers() {\n@@ -2008,3 +2039,3 @@\n-  patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,\n-                                        num_closed_archive_heap_ranges,\n-                                        MetaspaceShared::first_closed_archive_heap_region);\n+  patch_heap_embedded_pointers(closed_heap_regions,\n+                               num_closed_heap_regions,\n+                               MetaspaceShared::first_closed_heap_region);\n@@ -2012,3 +2043,3 @@\n-  patch_archived_heap_embedded_pointers(open_archive_heap_ranges,\n-                                        num_open_archive_heap_ranges,\n-                                        MetaspaceShared::first_open_archive_heap_region);\n+  patch_heap_embedded_pointers(open_heap_regions,\n+                               num_open_heap_regions,\n+                               MetaspaceShared::first_open_heap_region);\n@@ -2017,2 +2048,2 @@\n-void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,\n-                                                        int first_region_idx) {\n+void FileMapInfo::patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n+                                               int first_region_idx) {\n@@ -2023,1 +2054,1 @@\n-  for (int i=0; i<num_ranges; i++) {\n+  for (int i=0; i<num_regions; i++) {\n@@ -2025,2 +2056,2 @@\n-    HeapShared::patch_archived_heap_embedded_pointers(\n-      ranges[i],\n+    HeapShared::patch_embedded_pointers(\n+      regions[i],\n@@ -2037,6 +2068,6 @@\n-  \/\/ Note that closed_archive_heap_ranges may be non-NULL even if no ranges were found.\n-  if (num_closed_archive_heap_ranges != 0) {\n-    assert(closed_archive_heap_ranges != NULL,\n-           \"Null closed_archive_heap_ranges array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(closed_archive_heap_ranges,\n-                                                  num_closed_archive_heap_ranges);\n+  \/\/ Note that closed_heap_regions may be non-NULL even if no regions were found.\n+  if (num_closed_heap_regions != 0) {\n+    assert(closed_heap_regions != NULL,\n+           \"Null closed_heap_regions array with non-zero count\");\n+    G1CollectedHeap::heap()->fill_archive_regions(closed_heap_regions,\n+                                                  num_closed_heap_regions);\n@@ -2046,4 +2077,4 @@\n-  if (num_open_archive_heap_ranges != 0) {\n-    assert(open_archive_heap_ranges != NULL, \"NULL open_archive_heap_ranges array with non-zero count\");\n-    G1CollectedHeap::heap()->fill_archive_regions(open_archive_heap_ranges,\n-                                                  num_open_archive_heap_ranges);\n+  if (num_open_heap_regions != 0) {\n+    assert(open_heap_regions != NULL, \"NULL open_heap_regions array with non-zero count\");\n+    G1CollectedHeap::heap()->fill_archive_regions(open_heap_regions,\n+                                                  num_open_heap_regions);\n@@ -2060,2 +2091,2 @@\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(open_archive_heap_ranges,\n-                                                               num_open_archive_heap_ranges);\n+    G1CollectedHeap::heap()->populate_archive_regions_bot_part(open_heap_regions,\n+                                                               num_open_heap_regions);\n@@ -2066,1 +2097,1 @@\n-void FileMapInfo::dealloc_archive_heap_regions(MemRegion* regions, int num) {\n+void FileMapInfo::dealloc_heap_regions(MemRegion* regions, int num) {\n@@ -2068,1 +2099,1 @@\n-    assert(regions != NULL, \"Null archive ranges array with non-zero count\");\n+    assert(regions != NULL, \"Null archive regions array with non-zero count\");\n@@ -2140,0 +2171,1 @@\n+Array<u8>*      FileMapInfo::_saved_shared_path_table_array = NULL;\n@@ -2331,4 +2363,4 @@\n-    map_info->dealloc_archive_heap_regions(open_archive_heap_ranges,\n-                                           num_open_archive_heap_ranges);\n-    map_info->dealloc_archive_heap_regions(closed_archive_heap_ranges,\n-                                           num_closed_archive_heap_ranges);\n+    map_info->dealloc_heap_regions(open_heap_regions,\n+                                   num_open_heap_regions);\n+    map_info->dealloc_heap_regions(closed_heap_regions,\n+                                   num_closed_heap_regions);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":117,"deletions":85,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n@@ -275,0 +276,1 @@\n+  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n@@ -347,0 +349,1 @@\n+  static Array<u8>*            _saved_shared_path_table_array;  \/\/ remember the table array for cleanup\n@@ -369,0 +372,1 @@\n+    assert(_saved_shared_path_table.size() >= 0, \"Sanity check\");\n@@ -459,3 +463,3 @@\n-  size_t write_archive_heap_regions(GrowableArray<MemRegion> *heap_mem,\n-                                    GrowableArray<ArchiveHeapOopmapInfo> *oopmaps,\n-                                    int first_region_id, int max_num_regions);\n+  size_t write_heap_regions(GrowableArray<MemRegion>* regions,\n+                            GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                            int first_region_id, int max_num_regions);\n@@ -469,3 +473,3 @@\n-  void  patch_archived_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;\n-  void  patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,\n-                                              int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;\n+  void  patch_heap_embedded_pointers() NOT_CDS_JAVA_HEAP_RETURN;\n+  void  patch_heap_embedded_pointers(MemRegion* regions, int num_regions,\n+                                     int first_region_idx) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -498,0 +502,1 @@\n+  static void clone_shared_path_table(TRAPS);\n@@ -568,2 +573,2 @@\n-  bool  map_heap_data(MemRegion **heap_mem, int first, int max, int* num,\n-                      bool is_open = false) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  bool  map_heap_regions(int first, int max, bool is_open_archive,\n+                         MemRegion** regions_ret, int* num_regions_ret) NOT_CDS_JAVA_HEAP_RETURN_(false);\n@@ -571,1 +576,1 @@\n-  void  dealloc_archive_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;\n+  void  dealloc_heap_regions(MemRegion* regions, int num) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -70,3 +70,2 @@\n-bool HeapShared::_closed_archive_heap_region_mapped = false;\n-bool HeapShared::_open_archive_heap_region_mapped = false;\n-bool HeapShared::_archive_heap_region_fixed = false;\n+bool HeapShared::_closed_regions_mapped = false;\n+bool HeapShared::_open_regions_mapped = false;\n@@ -120,0 +119,8 @@\n+#ifdef ASSERT\n+bool HeapShared::is_archived_object_during_dumptime(oop p) {\n+  assert(HeapShared::is_heap_object_archiving_allowed(), \"must be\");\n+  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n+  return Universe::heap()->is_archived_object(p);\n+}\n+#endif\n+\n@@ -125,1 +132,1 @@\n-void HeapShared::fixup_mapped_heap_regions() {\n+void HeapShared::fixup_mapped_regions() {\n@@ -128,1 +135,0 @@\n-  set_archive_heap_region_fixed();\n@@ -140,2 +146,0 @@\n-  assert(!p->mark().has_bias_pattern(),\n-         \"this object should never have been locked\");  \/\/ so identity_hash won't safepoin\n@@ -218,1 +222,1 @@\n-  assert(open_archive_heap_region_mapped(), \"must be\");\n+  assert(open_regions_mapped(), \"must be\");\n@@ -243,1 +247,1 @@\n-  if (open_archive_heap_region_mapped()) {\n+  if (open_regions_mapped()) {\n@@ -252,1 +256,1 @@\n-oop HeapShared::archive_heap_object(oop obj) {\n+oop HeapShared::archive_object(oop obj) {\n@@ -338,2 +342,2 @@\n-void HeapShared::archive_java_heap_objects(GrowableArray<MemRegion>* closed,\n-                                           GrowableArray<MemRegion>* open) {\n+void HeapShared::archive_objects(GrowableArray<MemRegion>* closed_regions,\n+                                 GrowableArray<MemRegion>* open_regions) {\n@@ -352,1 +356,1 @@\n-    copy_closed_archive_heap_objects(closed);\n+    copy_closed_objects(closed_regions);\n@@ -355,1 +359,1 @@\n-    copy_open_archive_heap_objects(open);\n+    copy_open_objects(open_regions);\n@@ -363,2 +367,1 @@\n-void HeapShared::copy_closed_archive_heap_objects(\n-                                    GrowableArray<MemRegion> * closed_archive) {\n+void HeapShared::copy_closed_objects(GrowableArray<MemRegion>* closed_regions) {\n@@ -377,1 +380,1 @@\n-  G1CollectedHeap::heap()->end_archive_alloc_range(closed_archive,\n+  G1CollectedHeap::heap()->end_archive_alloc_range(closed_regions,\n@@ -381,2 +384,1 @@\n-void HeapShared::copy_open_archive_heap_objects(\n-                                    GrowableArray<MemRegion> * open_archive) {\n+void HeapShared::copy_open_objects(GrowableArray<MemRegion>* open_regions) {\n@@ -405,1 +407,1 @@\n-  G1CollectedHeap::heap()->end_archive_alloc_range(open_archive,\n+  G1CollectedHeap::heap()->end_archive_alloc_range(open_regions,\n@@ -419,5 +421,1 @@\n-    if (UseBiasedLocking) {\n-      oopDesc::set_mark(mem, k->prototype_header());\n-    } else {\n-      oopDesc::set_mark(mem, markWord::prototype());\n-    }\n+    oopDesc::set_mark(mem, markWord::prototype());\n@@ -886,1 +884,1 @@\n-      assert(!HeapShared::is_archived_object(obj),\n+      assert(!HeapShared::is_archived_object_during_dumptime(obj),\n@@ -905,1 +903,1 @@\n-      assert(HeapShared::is_archived_object(archived), \"must be\");\n+      assert(HeapShared::is_archived_object_during_dumptime(archived), \"must be\");\n@@ -917,1 +915,1 @@\n-void HeapShared::check_closed_archive_heap_region_object(InstanceKlass* k) {\n+void HeapShared::check_closed_region_object(InstanceKlass* k) {\n@@ -961,1 +959,1 @@\n-  assert(!is_archived_object(orig_obj), \"sanity\");\n+  assert(!is_archived_object_during_dumptime(orig_obj), \"sanity\");\n@@ -999,1 +997,1 @@\n-    archived_obj = archive_heap_object(orig_obj);\n+    archived_obj = archive_object(orig_obj);\n@@ -1040,1 +1038,1 @@\n-    check_closed_archive_heap_region_object(InstanceKlass::cast(orig_k));\n+    check_closed_region_object(InstanceKlass::cast(orig_k));\n@@ -1179,1 +1177,1 @@\n-      assert(is_archived_object(obj), \"must be\");\n+      assert(is_archived_object_during_dumptime(obj), \"must be\");\n@@ -1182,1 +1180,1 @@\n-      assert(!is_archived_object(obj), \"must be\");\n+      assert(!is_archived_object_during_dumptime(obj), \"must be\");\n@@ -1442,2 +1440,4 @@\n-void HeapShared::patch_archived_heap_embedded_pointers(MemRegion region, address oopmap,\n-                                                       size_t oopmap_size_in_bits) {\n+\/\/ Patch all the non-null pointers that are embedded in the archived heap objects\n+\/\/ in this region\n+void HeapShared::patch_embedded_pointers(MemRegion region, address oopmap,\n+                                         size_t oopmap_size_in_bits) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -146,3 +146,2 @@\n-  static bool _closed_archive_heap_region_mapped;\n-  static bool _open_archive_heap_region_mapped;\n-  static bool _archive_heap_region_fixed;\n+  static bool _closed_regions_mapped;\n+  static bool _open_regions_mapped;\n@@ -203,1 +202,1 @@\n-  static void check_closed_archive_heap_region_object(InstanceKlass* k);\n+  static void check_closed_region_object(InstanceKlass* k);\n@@ -300,1 +299,1 @@\n-  static oop archive_heap_object(oop obj);\n+  static oop archive_object(oop obj);\n@@ -304,11 +303,4 @@\n-  static void set_archive_heap_region_fixed() {\n-    _archive_heap_region_fixed = true;\n-  }\n-  static bool archive_heap_region_fixed() {\n-    return _archive_heap_region_fixed;\n-  }\n-\n-  static void archive_java_heap_objects(GrowableArray<MemRegion> *closed,\n-                                        GrowableArray<MemRegion> *open);\n-  static void copy_closed_archive_heap_objects(GrowableArray<MemRegion> * closed_archive);\n-  static void copy_open_archive_heap_objects(GrowableArray<MemRegion> * open_archive);\n+  static void archive_objects(GrowableArray<MemRegion>* closed_regions,\n+                              GrowableArray<MemRegion>* open_regions);\n+  static void copy_closed_objects(GrowableArray<MemRegion>* closed_regions);\n+  static void copy_open_objects(GrowableArray<MemRegion>* open_regions);\n@@ -360,2 +352,2 @@\n-    CDS_JAVA_HEAP_ONLY(return (idx >= MetaspaceShared::first_closed_archive_heap_region &&\n-                               idx <= MetaspaceShared::last_open_archive_heap_region);)\n+    CDS_JAVA_HEAP_ONLY(return (idx >= MetaspaceShared::first_closed_heap_region &&\n+                               idx <= MetaspaceShared::last_open_heap_region);)\n@@ -365,2 +357,2 @@\n-  static void set_closed_archive_heap_region_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_closed_archive_heap_region_mapped = true;)\n+  static void set_closed_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(_closed_regions_mapped = true;)\n@@ -369,2 +361,2 @@\n-  static bool closed_archive_heap_region_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _closed_archive_heap_region_mapped;)\n+  static bool closed_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(return _closed_regions_mapped;)\n@@ -373,2 +365,2 @@\n-  static void set_open_archive_heap_region_mapped() {\n-    CDS_JAVA_HEAP_ONLY(_open_archive_heap_region_mapped = true;)\n+  static void set_open_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(_open_regions_mapped = true;)\n@@ -377,2 +369,2 @@\n-  static bool open_archive_heap_region_mapped() {\n-    CDS_JAVA_HEAP_ONLY(return _open_archive_heap_region_mapped;)\n+  static bool open_regions_mapped() {\n+    CDS_JAVA_HEAP_ONLY(return _open_regions_mapped;)\n@@ -382,1 +374,1 @@\n-    return closed_archive_heap_region_mapped() && open_archive_heap_region_mapped();\n+    return closed_regions_mapped() && open_regions_mapped();\n@@ -385,1 +377,1 @@\n-  static void fixup_mapped_heap_regions() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void fixup_mapped_regions() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -387,1 +379,1 @@\n-  inline static bool is_archived_object(oop p) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_archived_object_during_dumptime(oop p) NOT_CDS_JAVA_HEAP_RETURN_(false);\n@@ -400,2 +392,2 @@\n-  static void patch_archived_heap_embedded_pointers(MemRegion mem, address  oopmap,\n-                                                    size_t oopmap_in_bits) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void patch_embedded_pointers(MemRegion region, address oopmap,\n+                                      size_t oopmap_in_bits) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":23,"deletions":31,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -36,4 +34,0 @@\n-bool HeapShared::is_archived_object(oop p) {\n-  return Universe::heap()->is_archived_object(p);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+\n+DumpTimeLambdaProxyClassInfo DumpTimeLambdaProxyClassInfo::clone() {\n+  DumpTimeLambdaProxyClassInfo res;\n+  res._proxy_klasses = NULL;\n+  if (_proxy_klasses != NULL && _proxy_klasses->length() > 0) {\n+    int num_proxy_klasses = _proxy_klasses->length();\n+    res._proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(num_proxy_klasses, mtClassShared);\n+    for (int i = 0; i < num_proxy_klasses; i++) {\n+      res._proxy_klasses->append(_proxy_klasses->at(i));\n+    }\n+  }\n+  return res;\n+}\n+\n+void LambdaProxyClassKey::mark_pointers() {\n+  ArchivePtrMarker::mark_pointer(&_caller_ik);\n+  ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n+  ArchivePtrMarker::mark_pointer(&_invoked_name);\n+  ArchivePtrMarker::mark_pointer(&_invoked_type);\n+  ArchivePtrMarker::mark_pointer(&_member_method);\n+  ArchivePtrMarker::mark_pointer(&_method_type);\n+}\n+\n+unsigned int LambdaProxyClassKey::hash() const {\n+  return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n+         SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n+}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#define SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n+\n+class LambdaProxyClassKey {\n+  InstanceKlass* _caller_ik;\n+  Symbol*        _invoked_name;\n+  Symbol*        _invoked_type;\n+  Symbol*        _method_type;\n+  Method*        _member_method;\n+  Symbol*        _instantiated_method_type;\n+\n+public:\n+  LambdaProxyClassKey(InstanceKlass* caller_ik,\n+                      Symbol*        invoked_name,\n+                      Symbol*        invoked_type,\n+                      Symbol*        method_type,\n+                      Method*        member_method,\n+                      Symbol*        instantiated_method_type) :\n+    _caller_ik(caller_ik),\n+    _invoked_name(invoked_name),\n+    _invoked_type(invoked_type),\n+    _method_type(method_type),\n+    _member_method(member_method),\n+    _instantiated_method_type(instantiated_method_type) {}\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_caller_ik);\n+    it->push(&_invoked_name);\n+    it->push(&_invoked_type);\n+    it->push(&_method_type);\n+    it->push(&_member_method);\n+    it->push(&_instantiated_method_type);\n+  }\n+\n+  bool equals(LambdaProxyClassKey const& other) const {\n+    return _caller_ik == other._caller_ik &&\n+           _invoked_name == other._invoked_name &&\n+           _invoked_type == other._invoked_type &&\n+           _method_type == other._method_type &&\n+           _member_method == other._member_method &&\n+           _instantiated_method_type == other._instantiated_method_type;\n+  }\n+\n+  void mark_pointers();\n+  unsigned int hash() const;\n+\n+  static unsigned int dumptime_hash(Symbol* sym)  {\n+    if (sym == NULL) {\n+      \/\/ _invoked_name maybe NULL\n+      return 0;\n+    }\n+    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  }\n+\n+  unsigned int dumptime_hash() const {\n+    return dumptime_hash(_caller_ik->name()) +\n+           dumptime_hash(_invoked_name) +\n+           dumptime_hash(_invoked_type) +\n+           dumptime_hash(_method_type) +\n+           dumptime_hash(_instantiated_method_type);\n+  }\n+\n+  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n+    return (key.dumptime_hash());\n+  }\n+\n+  static inline bool DUMPTIME_EQUALS(\n+      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n+    return (k1.equals(k2));\n+  }\n+\n+  InstanceKlass* caller_ik() const { return _caller_ik; }\n+};\n+\n+class DumpTimeLambdaProxyClassInfo {\n+public:\n+  GrowableArray<InstanceKlass*>* _proxy_klasses;\n+  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n+  void add_proxy_klass(InstanceKlass* proxy_klass) {\n+    if (_proxy_klasses == NULL) {\n+      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(5, mtClassShared);\n+    }\n+    assert(_proxy_klasses != NULL, \"sanity\");\n+    _proxy_klasses->append(proxy_klass);\n+  }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it) {\n+    for (int i=0; i<_proxy_klasses->length(); i++) {\n+      it->push(_proxy_klasses->adr_at(i));\n+    }\n+  }\n+  DumpTimeLambdaProxyClassInfo clone(); \/\/ copy ctor will cause implicitly-declared\n+};\n+\n+class RunTimeLambdaProxyClassInfo {\n+  LambdaProxyClassKey _key;\n+  InstanceKlass* _proxy_klass_head;\n+public:\n+  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+    _key(key), _proxy_klass_head(proxy_klass_head) {}\n+\n+  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+\n+  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n+    return (value->_key.equals(*key));\n+  }\n+  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    _key = key;\n+    _key.mark_pointers();\n+    _proxy_klass_head = info._proxy_klasses->at(0);\n+    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n+  }\n+\n+  unsigned int hash() const {\n+    return _key.hash();\n+  }\n+  LambdaProxyClassKey key() const {\n+    return _key;\n+  }\n+};\n+\n+class DumpTimeLambdaProxyClassDictionary\n+  : public ResourceHashtable<LambdaProxyClassKey,\n+                             DumpTimeLambdaProxyClassInfo,\n+                             LambdaProxyClassKey::DUMPTIME_HASH,\n+                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n+                             137, \/\/ prime number\n+                             ResourceObj::C_HEAP> {\n+public:\n+  DumpTimeLambdaProxyClassDictionary() : _count(0) {}\n+  int _count;\n+};\n+\n+class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n+  LambdaProxyClassKey*,\n+  const RunTimeLambdaProxyClassInfo*,\n+  RunTimeLambdaProxyClassInfo::EQUALS> {};\n+\n+#endif \/\/ SHARED_CDS_LAMBDAPROXYCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -72,0 +73,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -115,1 +117,1 @@\n-\/\/ The ca0\/ca1 and oa0\/oa1 regions are populated inside HeapShared::archive_java_heap_objects.\n+\/\/ The ca0\/ca1 and oa0\/oa1 regions are populated inside HeapShared::archive_objects.\n@@ -249,1 +251,1 @@\n-      SystemDictionaryShared::allocate_shared_data_arrays(size, CHECK);\n+      CDSProtectionDomain::allocate_shared_data_arrays(size, CHECK);\n@@ -393,1 +395,1 @@\n-    if (ik->can_be_verified_at_dumptime()) {\n+    if (ik->can_be_verified_at_dumptime() && ik->is_linked()) {\n@@ -404,2 +406,2 @@\n-  GrowableArray<MemRegion> *_closed_archive_heap_regions;\n-  GrowableArray<MemRegion> *_open_archive_heap_regions;\n+  GrowableArray<MemRegion> *_closed_heap_regions;\n+  GrowableArray<MemRegion> *_open_heap_regions;\n@@ -407,2 +409,2 @@\n-  GrowableArray<ArchiveHeapOopmapInfo> *_closed_archive_heap_oopmaps;\n-  GrowableArray<ArchiveHeapOopmapInfo> *_open_archive_heap_oopmaps;\n+  GrowableArray<ArchiveHeapOopmapInfo> *_closed_heap_oopmaps;\n+  GrowableArray<ArchiveHeapOopmapInfo> *_open_heap_oopmaps;\n@@ -411,2 +413,2 @@\n-  void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_archive_heap_oopmaps(GrowableArray<MemRegion>* regions,\n+  void dump_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n@@ -424,4 +426,4 @@\n-    _closed_archive_heap_regions(NULL),\n-    _open_archive_heap_regions(NULL),\n-    _closed_archive_heap_oopmaps(NULL),\n-    _open_archive_heap_oopmaps(NULL) {}\n+    _closed_heap_regions(NULL),\n+    _open_heap_regions(NULL),\n+    _closed_heap_oopmaps(NULL),\n+    _open_heap_oopmaps(NULL) {}\n@@ -473,1 +475,1 @@\n-  dump_archive_heap_oopmaps();\n+  dump_heap_oopmaps();\n@@ -531,4 +533,4 @@\n-                        _closed_archive_heap_regions,\n-                        _open_archive_heap_regions,\n-                        _closed_archive_heap_oopmaps,\n-                        _open_archive_heap_oopmaps);\n+                        _closed_heap_regions,\n+                        _open_heap_regions,\n+                        _closed_heap_oopmaps,\n+                        _open_heap_oopmaps);\n@@ -572,4 +574,20 @@\n-bool MetaspaceShared::linking_required(InstanceKlass* ik) {\n-  \/\/ For static CDS dump, do not link old classes.\n-  \/\/ For dynamic CDS dump, only link classes loaded by the builtin class loaders.\n-  return DumpSharedSpaces ? ik->can_be_verified_at_dumptime() : !ik->is_shared_unregistered_class();\n+\/\/ Check if we can eagerly link this class at dump time, so we can avoid the\n+\/\/ runtime linking overhead (especially verification)\n+bool MetaspaceShared::may_be_eagerly_linked(InstanceKlass* ik) {\n+  if (!ik->can_be_verified_at_dumptime()) {\n+    \/\/ For old classes, try to leave them in the unlinked state, so\n+    \/\/ we can still store them in the archive. They must be\n+    \/\/ linked\/verified at runtime.\n+    return false;\n+  }\n+  if (DynamicDumpSharedSpaces && ik->is_shared_unregistered_class()) {\n+    \/\/ Linking of unregistered classes at this stage may cause more\n+    \/\/ classes to be resolved, resulting in calls to ClassLoader.loadClass()\n+    \/\/ that may not be expected by custom class loaders.\n+    \/\/\n+    \/\/ It's OK to do this for the built-in loaders as we know they can\n+    \/\/ tolerate this. (Note that unregistered classes are loaded by the NULL\n+    \/\/ loader during DumpSharedSpaces).\n+    return false;\n+  }\n+  return true;\n@@ -593,1 +611,1 @@\n-void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {\n+void MetaspaceShared::link_shared_classes(TRAPS) {\n@@ -615,1 +633,1 @@\n-          if (linking_required(ik)) {\n+          if (may_be_eagerly_linked(ik)) {\n@@ -703,1 +721,1 @@\n-  SystemDictionaryShared::create_jar_manifest(dummy, strlen(dummy), CHECK);\n+  CDSProtectionDomain::create_jar_manifest(dummy, strlen(dummy), CHECK);\n@@ -727,1 +745,1 @@\n-  link_and_cleanup_shared_classes(CHECK);\n+  link_shared_classes(CHECK);\n@@ -810,5 +828,4 @@\n-  \/\/ See FileMapInfo::write_archive_heap_regions() for details.\n-  _closed_archive_heap_regions = new GrowableArray<MemRegion>(2);\n-  _open_archive_heap_regions = new GrowableArray<MemRegion>(2);\n-  HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,\n-                                        _open_archive_heap_regions);\n+  \/\/ See FileMapInfo::write_heap_regions() for details.\n+  _closed_heap_regions = new GrowableArray<MemRegion>(2);\n+  _open_heap_regions = new GrowableArray<MemRegion>(2);\n+  HeapShared::archive_objects(_closed_heap_regions, _open_heap_regions);\n@@ -819,1 +836,1 @@\n-void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {\n+void VM_PopulateDumpSharedSpace::dump_heap_oopmaps() {\n@@ -821,2 +838,2 @@\n-    _closed_archive_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);\n+    _closed_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n+    dump_heap_oopmaps(_closed_heap_regions, _closed_heap_oopmaps);\n@@ -824,2 +841,2 @@\n-    _open_archive_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);\n+    _open_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n+    dump_heap_oopmaps(_open_heap_regions, _open_heap_oopmaps);\n@@ -829,2 +846,2 @@\n-void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                                           GrowableArray<ArchiveHeapOopmapInfo>* oopmaps) {\n+void VM_PopulateDumpSharedSpace::dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n+                                                   GrowableArray<ArchiveHeapOopmapInfo>* oopmaps) {\n@@ -1385,1 +1402,1 @@\n-  static_mapinfo->patch_archived_heap_embedded_pointers();\n+  static_mapinfo->patch_heap_embedded_pointers();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":56,"deletions":39,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    rw = 0,  \/\/ read-write shared space in the heap\n-    ro = 1,  \/\/ read-only shared space in the heap\n+    rw = 0,  \/\/ read-write shared space\n+    ro = 1,  \/\/ read-only shared space\n@@ -68,8 +68,8 @@\n-    first_closed_archive_heap_region = bm + 1,\n-    max_closed_archive_heap_region = 2,\n-    last_closed_archive_heap_region = first_closed_archive_heap_region + max_closed_archive_heap_region - 1,\n-    first_open_archive_heap_region = last_closed_archive_heap_region + 1,\n-    max_open_archive_heap_region = 2,\n-    last_open_archive_heap_region = first_open_archive_heap_region + max_open_archive_heap_region - 1,\n-\n-    last_valid_region = last_open_archive_heap_region,\n+    first_closed_heap_region = bm + 1,\n+    max_closed_heap_region = 2,\n+    last_closed_heap_region = first_closed_heap_region + max_closed_heap_region - 1,\n+    first_open_heap_region = last_closed_heap_region + 1,\n+    max_open_heap_region = 2,\n+    last_open_heap_region = first_open_heap_region + max_open_heap_region - 1,\n+\n+    last_valid_region = last_open_heap_region,\n@@ -104,1 +104,0 @@\n-  static bool map_shared_spaces(FileMapInfo* mapinfo) NOT_CDS_RETURN_(false);\n@@ -108,1 +107,1 @@\n-  \/\/ mapped shared heap regions.)\n+  \/\/ mapped heap regions.)\n@@ -113,4 +112,0 @@\n-  static address shared_metaspace_top() {\n-    return (address)MetaspaceObj::shared_metaspace_top();\n-  }\n-\n@@ -137,1 +132,1 @@\n-  static void link_and_cleanup_shared_classes(TRAPS) NOT_CDS_RETURN;\n+  static void link_shared_classes(TRAPS) NOT_CDS_RETURN;\n@@ -139,1 +134,1 @@\n-  static bool linking_required(InstanceKlass* ik) NOT_CDS_RETURN_(false);\n+  static bool may_be_eagerly_linked(InstanceKlass* ik) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n+\n+void RunTimeClassInfo::init(DumpTimeClassInfo& info) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  assert(builder->is_in_buffer_space(info._klass), \"must be\");\n+  _klass = info._klass;\n+  if (!SystemDictionaryShared::is_builtin(_klass)) {\n+    CrcInfo* c = crc();\n+    c->_clsfile_size = info._clsfile_size;\n+    c->_clsfile_crc32 = info._clsfile_crc32;\n+  }\n+  _num_verifier_constraints = info.num_verifier_constraints();\n+  _num_loader_constraints   = info.num_loader_constraints();\n+  int i;\n+  if (_num_verifier_constraints > 0) {\n+    RTVerifierConstraint* vf_constraints = verifier_constraints();\n+    char* flags = verifier_constraint_flags();\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n+      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n+    }\n+    for (i = 0; i < _num_verifier_constraints; i++) {\n+      flags[i] = info._verifier_constraint_flags->at(i);\n+    }\n+  }\n+\n+  if (_num_loader_constraints > 0) {\n+    RTLoaderConstraint* ld_constraints = loader_constraints();\n+    for (i = 0; i < _num_loader_constraints; i++) {\n+      ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n+      ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n+      ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n+    }\n+  }\n+\n+  if (_klass->is_hidden()) {\n+    InstanceKlass* n_h = info.nest_host();\n+    set_nest_host(n_h);\n+  }\n+  ArchivePtrMarker::mark_pointer(&_klass);\n+}\n+\n+size_t RunTimeClassInfo::crc_size(InstanceKlass* klass) {\n+  if (!SystemDictionaryShared::is_builtin(klass)) {\n+    return sizeof(CrcInfo);\n+  } else {\n+    return 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_SHAREDCLASSINFO_HPP\n+#define SHARED_CDS_SHAREDCLASSINFO_HPP\n+#include \"classfile\/compactHashtable.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class Method;\n+class Symbol;\n+\n+class RunTimeClassInfo {\n+public:\n+  struct CrcInfo {\n+    int _clsfile_size;\n+    int _clsfile_crc32;\n+  };\n+\n+  \/\/ This is different than  DumpTimeClassInfo::DTVerifierConstraint. We use\n+  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n+  struct RTVerifierConstraint {\n+    u4 _name;\n+    u4 _from_name;\n+    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n+    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n+  };\n+\n+  struct RTLoaderConstraint {\n+    u4   _name;\n+    char _loader_type1;\n+    char _loader_type2;\n+    Symbol* constraint_name() {\n+      return (Symbol*)(SharedBaseAddress + _name);\n+    }\n+  };\n+\n+  InstanceKlass* _klass;\n+  int _num_verifier_constraints;\n+  int _num_loader_constraints;\n+\n+  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*       _nest_host\n+  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+\n+private:\n+  static size_t header_size_size() {\n+    return sizeof(RunTimeClassInfo);\n+  }\n+  static size_t verifier_constraints_size(int num_verifier_constraints) {\n+    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+  }\n+  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n+    return sizeof(char) * num_verifier_constraints;\n+  }\n+  static size_t loader_constraints_size(int num_loader_constraints) {\n+    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+  }\n+  static size_t nest_host_size(InstanceKlass* klass) {\n+    if (klass->is_hidden()) {\n+      return sizeof(InstanceKlass*);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  static size_t crc_size(InstanceKlass* klass);\n+public:\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+    return header_size_size() +\n+           crc_size(klass) +\n+           nest_host_size(klass) +\n+           loader_constraints_size(num_loader_constraints) +\n+           verifier_constraints_size(num_verifier_constraints) +\n+           verifier_constraint_flags_size(num_verifier_constraints);\n+  }\n+\n+private:\n+  size_t crc_offset() const {\n+    return header_size_size();\n+  }\n+\n+  size_t nest_host_offset() const {\n+      return crc_offset() + crc_size(_klass);\n+  }\n+\n+  size_t loader_constraints_offset() const  {\n+    return nest_host_offset() + nest_host_size(_klass);\n+  }\n+  size_t verifier_constraints_offset() const {\n+    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n+  }\n+  size_t verifier_constraint_flags_offset() const {\n+    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n+  }\n+\n+  void check_verifier_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n+  }\n+\n+  void check_loader_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n+  }\n+\n+public:\n+  CrcInfo* crc() const {\n+    assert(crc_size(_klass) > 0, \"must be\");\n+    return (CrcInfo*)(address(this) + crc_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraints() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n+  }\n+  RTVerifierConstraint* verifier_constraint_at(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraints() + i;\n+  }\n+\n+  char* verifier_constraint_flags() {\n+    assert(_num_verifier_constraints > 0, \"sanity\");\n+    return (char*)(address(this) + verifier_constraint_flags_offset());\n+  }\n+\n+  InstanceKlass** nest_host_addr() {\n+    assert(_klass->is_hidden(), \"sanity\");\n+    return (InstanceKlass**)(address(this) + nest_host_offset());\n+  }\n+  InstanceKlass* nest_host() {\n+    return *nest_host_addr();\n+  }\n+  void set_nest_host(InstanceKlass* k) {\n+    *nest_host_addr() = k;\n+    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  }\n+\n+  RTLoaderConstraint* loader_constraints() {\n+    assert(_num_loader_constraints > 0, \"sanity\");\n+    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  }\n+\n+  RTLoaderConstraint* loader_constraint_at(int i) {\n+    check_loader_constraint_offset(i);\n+    return loader_constraints() + i;\n+  }\n+\n+  void init(DumpTimeClassInfo& info);\n+\n+  bool matches(int clsfile_size, int clsfile_crc32) const {\n+    return crc()->_clsfile_size  == clsfile_size &&\n+           crc()->_clsfile_crc32 == clsfile_crc32;\n+  }\n+\n+  char verifier_constraint_flag(int i) {\n+    check_verifier_constraint_offset(i);\n+    return verifier_constraint_flags()[i];\n+  }\n+\n+private:\n+  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n+  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n+  \/\/ lookup of InstanceKlass* -> RunTimeClassInfo* without\n+  \/\/ building a new hashtable.\n+  \/\/\n+  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeClassInfo*\n+  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n+  \/\/                               0x0110   fields from Klass ...\n+  static RunTimeClassInfo** info_pointer_addr(InstanceKlass* klass) {\n+    return &((RunTimeClassInfo**)klass)[-1];\n+  }\n+\n+public:\n+  static RunTimeClassInfo* get_for(InstanceKlass* klass) {\n+    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    return *info_pointer_addr(klass);\n+  }\n+  static void set_for(InstanceKlass* klass, RunTimeClassInfo* record) {\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n+    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n+    *info_pointer_addr(klass) = record;\n+    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n+  }\n+\n+  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n+  static inline bool EQUALS(\n+       const RunTimeClassInfo* value, Symbol* key, int len_unused) {\n+    return (value->_klass->name() == key);\n+  }\n+};\n+\n+class RunTimeSharedDictionary : public OffsetCompactHashtable<\n+  Symbol*,\n+  const RunTimeClassInfo*,\n+  RunTimeClassInfo::EQUALS> {};\n+#endif \/\/ SHARED_CDS_SHAREDCLASSINFO_HPP\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -140,0 +140,2 @@\n+#define JAVA_18_VERSION                   62\n+\n@@ -693,2 +695,3 @@\n-            \/\/ Method name and signature are verified above, when iterating NameAndType_info.\n-            \/\/ Need only to be sure signature is non-zero length and the right type.\n+            \/\/ Method name and signature are individually verified above, when iterating\n+            \/\/ NameAndType_info.  Need to check here that signature is non-zero length and\n+            \/\/ the right type.\n@@ -699,1 +702,1 @@\n-          \/\/ 4509014: If a class method name begins with '<', it must be \"<init>\"\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -701,8 +704,10 @@\n-          if (tag == JVM_CONSTANT_Methodref &&\n-              name_len != 0 &&\n-              name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-              name != vmSymbols::object_initializer_name()) {\n-            classfile_parse_error(\n-              \"Bad method name at constant pool index %u in class file %s\",\n-              name_ref_index, THREAD);\n-            return;\n+          if (tag == JVM_CONSTANT_Methodref && name_len != 0 &&\n+              name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n+            if (name != vmSymbols::object_initializer_name()) {\n+              classfile_parse_error(\n+                \"Bad method name at constant pool index %u in class file %s\",\n+                name_ref_index, THREAD);\n+              return;\n+            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n+            }\n@@ -2082,1 +2087,0 @@\n-      ik->set_prototype_header(markWord::prototype());\n@@ -2295,0 +2299,1 @@\n+    verify_legal_name_with_signature(name, signature, CHECK_NULL);\n@@ -5044,0 +5049,26 @@\n+\/\/ Check that the signature is compatible with the method name.  For example,\n+\/\/ check that <init> has a void signature.\n+void ClassFileParser::verify_legal_name_with_signature(const Symbol* name,\n+                                                       const Symbol* signature,\n+                                                       TRAPS) const {\n+  if (!_need_verify) {\n+    return;\n+  }\n+\n+  \/\/ Class initializers cannot have args for class format version >= 51.\n+  if (name == vmSymbols::class_initializer_name() &&\n+      signature != vmSymbols::void_method_signature() &&\n+      _major_version >= JAVA_7_VERSION) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+    return;\n+  }\n+\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+      sig_length > 0 &&\n+      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n+  }\n+}\n+\n@@ -5055,8 +5086,0 @@\n-  \/\/ Class initializers cannot have args for class format version >= 51.\n-  if (name == vmSymbols::class_initializer_name() &&\n-      signature != vmSymbols::void_method_signature() &&\n-      _major_version >= JAVA_7_VERSION) {\n-    throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    return 0;\n-  }\n-\n@@ -5085,11 +5108,4 @@\n-      if (name->utf8_length() > 0 && name->char_at(0) == JVM_SIGNATURE_SPECIAL) {\n-        \/\/ All internal methods must return void\n-        if ((length == 1) && (p[0] == JVM_SIGNATURE_VOID)) {\n-          return args_size;\n-        }\n-      } else {\n-        \/\/ Now we better just have a return value\n-        nextp = skip_over_field_signature(p, true, length, CHECK_0);\n-        if (nextp && ((int)length == (nextp - p))) {\n-          return args_size;\n-        }\n+      \/\/ Now we better just have a return value\n+      nextp = skip_over_field_signature(p, true, length, CHECK_0);\n+      if (nextp && ((int)length == (nextp - p))) {\n+        return args_size;\n@@ -5100,1 +5116,1 @@\n-  throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n+  throwIllegalSignature(\"Method\", name, signature, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":48,"deletions":32,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -465,0 +465,3 @@\n+  void verify_legal_name_with_signature(const Symbol* name,\n+                                        const Symbol* signature,\n+                                        TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+#if INCLUDE_CDS\n+      ClassLoaderExt::set_has_non_jar_in_classpath();\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n@@ -260,0 +259,1 @@\n+  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,0 +553,15 @@\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n+  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n+  \/\/ jmethod_ids may access them after the associated classes and class loader\n+  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n+  \/\/ does not prevent the VM from unloading the class from which the ID has\n+  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n+  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n+  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ from the VM side without knowing when native code is going to stop using\n+  \/\/ them.\n+  if (_jmethod_ids != NULL) {\n+    Method::clear_jmethod_ids(this);\n+  }\n+\n@@ -697,14 +712,1 @@\n-  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n-  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n-  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n-  \/\/ jmethod_ids may access them after the associated classes and class loader\n-  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n-  \/\/ does not prevent the VM from unloading the class from which the ID has\n-  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n-  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n-  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n-  \/\/ from the VM side without knowing when native code is going to stop using\n-  \/\/ them.\n-  if (_jmethod_ids != NULL) {\n-    Method::clear_jmethod_ids(this);\n-  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-    return (unsigned)((uintptr_t)this >> 3);\n+    return (unsigned)((uintptr_t)this >> LogBytesPerWord);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+bool ClassLoaderExt::_has_non_jar_in_classpath = false;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static bool _has_non_jar_in_classpath;\n@@ -110,0 +111,4 @@\n+  static bool has_non_jar_in_classpath() {\n+    return _has_non_jar_in_classpath;\n+  }\n+\n@@ -118,1 +123,4 @@\n-#endif\n+  static void set_has_non_jar_in_classpath() {\n+    _has_non_jar_in_classpath = true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -130,1 +131,2 @@\n-objArrayHandle names, typeArrayHandle enabled, TRAPS) {\n+                                    objArrayHandle names,\n+                                    typeArrayHandle enabled, TRAPS) {\n@@ -138,2 +140,2 @@\n-    Handle s = java_lang_String::create_from_str(p->name(), CHECK);\n-    s = java_lang_String::char_converter(s, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, CHECK);\n+    TempNewSymbol name = SymbolTable::new_symbol(p->name());\n+    Handle s = java_lang_String::externalize_classname(name, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaAssertions.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -472,64 +473,3 @@\n-Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {\n-  oop          obj    = java_string();\n-  \/\/ Typical usage is to convert all '\/' to '.' in string.\n-  typeArrayOop value  = java_lang_String::value(obj);\n-  int          length = java_lang_String::length(obj, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(obj);\n-\n-  \/\/ First check if any from_char exist\n-  int index; \/\/ Declared outside, used later\n-  for (index = 0; index < length; index++) {\n-    jchar c = !is_latin1 ? value->char_at(index) :\n-                  ((jchar) value->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      break;\n-    }\n-  }\n-  if (index == length) {\n-    \/\/ No from_char, so do not copy.\n-    return java_string;\n-  }\n-\n-  \/\/ Check if result string will be latin1\n-  bool to_is_latin1 = false;\n-\n-  \/\/ Replacement char must be latin1\n-  if (CompactStrings && UNICODE::is_latin1(to_char)) {\n-    if (is_latin1) {\n-      \/\/ Source string is latin1 as well\n-      to_is_latin1 = true;\n-    } else if (!UNICODE::is_latin1(from_char)) {\n-      \/\/ We are replacing an UTF16 char. Scan string to\n-      \/\/ check if result can be latin1 encoded.\n-      to_is_latin1 = true;\n-      for (index = 0; index < length; index++) {\n-        jchar c = value->char_at(index);\n-        if (c != from_char && !UNICODE::is_latin1(c)) {\n-          to_is_latin1 = false;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Create new UNICODE (or byte) buffer. Must handlize value because GC\n-  \/\/ may happen during String and char array creation.\n-  typeArrayHandle h_value(THREAD, value);\n-  Handle string = basic_create(length, to_is_latin1, CHECK_NH);\n-  typeArrayOop from_buffer = h_value();\n-  typeArrayOop to_buffer = java_lang_String::value(string());\n-\n-  \/\/ Copy contents\n-  for (index = 0; index < length; index++) {\n-    jchar c = (!is_latin1) ? from_buffer->char_at(index) :\n-                    ((jchar) from_buffer->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      c = to_char;\n-    }\n-    if (!to_is_latin1) {\n-      to_buffer->char_at_put(index, c);\n-    } else {\n-      to_buffer->byte_at_put(index, (jbyte) c);\n-    }\n-  }\n-  return string;\n+Handle java_lang_String::externalize_classname(Symbol* java_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  return create_from_str(java_name->as_klass_external_name(), THREAD);\n@@ -566,1 +506,1 @@\n-unsigned int java_lang_String::hash_code(oop java_string) {\n+inline unsigned int java_lang_String::hash_code_impl(oop java_string, bool update) {\n@@ -593,4 +533,6 @@\n-  if (hash != 0) {\n-    java_string->int_field_put(_hash_offset, hash);\n-  } else {\n-    java_string->bool_field_put(_hashIsZero_offset, true);\n+  if (update) {\n+    if (hash != 0) {\n+      java_string->int_field_put(_hash_offset, hash);\n+    } else {\n+      java_string->bool_field_put(_hashIsZero_offset, true);\n+    }\n@@ -601,0 +543,9 @@\n+unsigned int java_lang_String::hash_code(oop java_string) {\n+  return hash_code_impl(java_string, \/*update=*\/true);\n+}\n+\n+unsigned int java_lang_String::hash_code_noupdate(oop java_string) {\n+  return hash_code_impl(java_string, \/*update=*\/false);\n+}\n+\n+\n@@ -869,8 +820,5 @@\n-  if (HeapShared::is_archived_object(mirror())) {\n-    \/\/ Archive the String field and update the pointer.\n-    oop s = mirror()->obj_field(fd->offset());\n-    oop archived_s = StringTable::create_archived_string(s);\n-    mirror()->obj_field_put(fd->offset(), archived_s);\n-  } else {\n-    guarantee(false, \"Unexpected\");\n-  }\n+  assert(HeapShared::is_archived_object_during_dumptime(mirror()), \"must be\");\n+  \/\/ Archive the String field and update the pointer.\n+  oop s = mirror()->obj_field(fd->offset());\n+  oop archived_s = StringTable::create_archived_string(s);\n+  mirror()->obj_field_put(fd->offset(), archived_s);\n@@ -958,1 +906,1 @@\n-    if (HeapShared::open_archive_heap_region_mapped()) {\n+    if (HeapShared::open_regions_mapped()) {\n@@ -1209,1 +1157,1 @@\n-      oop archived_m = HeapShared::archive_heap_object(m);\n+      oop archived_m = HeapShared::archive_object(m);\n@@ -1268,1 +1216,1 @@\n-  oop archived_mirror = HeapShared::archive_heap_object(mirror);\n+  oop archived_mirror = HeapShared::archive_object(mirror);\n@@ -1395,1 +1343,1 @@\n-  assert(HeapShared::is_archived_object(m), \"must be archived mirror object\");\n+  assert(Universe::heap()->is_archived_object(m), \"must be archived mirror object\");\n@@ -4650,20 +4598,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":29,"deletions":101,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -131,0 +130,2 @@\n+  static inline unsigned int hash_code_impl(oop java_string, bool update);\n+\n@@ -149,1 +150,0 @@\n-  static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);\n@@ -227,0 +227,1 @@\n+  static unsigned int hash_code_noupdate(oop java_string);\n@@ -232,4 +233,2 @@\n-  \/\/ Conversion between '.' and '\/' formats\n-  static Handle externalize_classname(Handle java_string, TRAPS) {\n-    return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);\n-  }\n+  \/\/ Conversion between '.' and '\/' formats, and allocate a String from the result.\n+  static Handle externalize_classname(Symbol* java_name, TRAPS);\n@@ -1587,10 +1586,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-   Thread *_thread;\n+   JavaThread* _thread;\n@@ -50,1 +50,1 @@\n-   SeenThread(Thread *thread) {\n+   SeenThread(JavaThread* thread) {\n@@ -55,2 +55,2 @@\n-   Thread* thread()                const { return _thread;}\n-   void set_thread(Thread *thread) { _thread = thread; }\n+   JavaThread* thread()          const { return _thread;}\n+   void set_thread(JavaThread* thread) { _thread = thread; }\n@@ -58,3 +58,3 @@\n-   SeenThread* next()              const { return _stnext;}\n-   void set_next(SeenThread *seen) { _stnext = seen; }\n-   void set_prev(SeenThread *seen) { _stprev = seen; }\n+   SeenThread* next()        const { return _stnext;}\n+   void set_next(SeenThread* seen) { _stnext = seen; }\n+   void set_prev(SeenThread* seen) { _stprev = seen; }\n@@ -110,1 +110,1 @@\n-void PlaceholderEntry::add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+void PlaceholderEntry::add_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -131,1 +131,1 @@\n-bool PlaceholderEntry::check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+bool PlaceholderEntry::check_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -149,1 +149,1 @@\n-bool PlaceholderEntry::remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+bool PlaceholderEntry::remove_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action) {\n@@ -291,1 +291,1 @@\n-                                                 Thread* thread) {\n+                                                 JavaThread* thread) {\n@@ -324,1 +324,1 @@\n-                                       Thread* thread) {\n+                                       JavaThread* thread) {\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                                 Thread* thread);\n+                                 JavaThread* thread);\n@@ -97,1 +97,1 @@\n-                       classloadAction action, Thread* thread);\n+                       classloadAction action, JavaThread* thread);\n@@ -119,1 +119,1 @@\n-  Thread*           _definer;       \/\/ owner of define token\n+  JavaThread*       _definer;       \/\/ owner of define token\n@@ -133,2 +133,2 @@\n-  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n-  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  void add_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n+  bool remove_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n@@ -149,2 +149,2 @@\n-  Thread*            definer()             const {return _definer; }\n-  void               set_definer(Thread* definer) { _definer = definer; }\n+  JavaThread*        definer()             const {return _definer; }\n+  void               set_definer(JavaThread* definer) { _definer = definer; }\n@@ -161,1 +161,1 @@\n-  SeenThread*        defineThreadQ()        const { return _defineThreadQ; }\n+  SeenThread*        defineThreadQ()       const { return _defineThreadQ; }\n@@ -191,1 +191,1 @@\n-  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  bool check_seen_thread(JavaThread* thread, PlaceholderTable::classloadAction action);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  NONCOPYABLE(verification_type_info);\n@@ -48,1 +49,0 @@\n-  verification_type_info(const verification_type_info&) {}\n@@ -172,0 +172,2 @@\n+  NONCOPYABLE(stack_map_frame);\n+\n@@ -177,1 +179,0 @@\n-  stack_map_frame(const stack_map_frame&) {}\n@@ -904,0 +905,1 @@\n+  NONCOPYABLE(stack_map_table);\n@@ -908,1 +910,0 @@\n-  stack_map_table(const stack_map_table&) {}\n@@ -936,0 +937,1 @@\n+  NONCOPYABLE(stack_map_table_attribute);\n@@ -940,1 +942,0 @@\n-  stack_map_table_attribute(const stack_map_table_attribute&) {}\n","filename":"src\/hotspot\/share\/classfile\/stackMapTableFormat.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -600,1 +601,10 @@\n-  GrowableArray<oop>* _oops;\n+  static unsigned string_hash(oop const& str) {\n+    return java_lang_String::hash_code_noupdate(str);\n+  }\n+  static bool string_equals(oop const& a, oop const& b) {\n+    return java_lang_String::equals(a, b);\n+  }\n+\n+  ResizeableResourceHashtable<oop, bool,\n+                              ResourceObj::C_HEAP, mtInternal,\n+                              string_hash, string_equals> _table;\n@@ -603,1 +613,1 @@\n-  VerifyCompStrings(GrowableArray<oop>* oops) : _oops(oops), _errors(0) {}\n+  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1), _errors(0) {}\n@@ -609,7 +619,5 @@\n-    int len = _oops->length();\n-    for (int i = 0; i < len; i++) {\n-      bool eq = java_lang_String::equals(s, _oops->at(i));\n-      assert(!eq, \"Duplicate strings\");\n-      if (eq) {\n-        _errors++;\n-      }\n+    bool created;\n+    _table.put_if_absent(s, true, &created);\n+    assert(created, \"Duplicate strings\");\n+    if (!created) {\n+      _errors++;\n@@ -617,1 +625,0 @@\n-    _oops->push(s);\n@@ -624,5 +631,1 @@\n-  GrowableArray<oop>* oops =\n-    new (ResourceObj::C_HEAP, mtInternal)\n-      GrowableArray<oop>((int)_current_size, mtInternal);\n-\n-  VerifyCompStrings vcs(oops);\n+  VerifyCompStrings vcs;\n@@ -632,1 +635,0 @@\n-  delete oops;\n@@ -721,1 +723,1 @@\n-  assert(!HeapShared::is_archived_object(s), \"sanity\");\n+  assert(!HeapShared::is_archived_object_during_dumptime(s), \"sanity\");\n@@ -725,1 +727,1 @@\n-  typeArrayOop new_v = (typeArrayOop)HeapShared::archive_heap_object(v);\n+  typeArrayOop new_v = (typeArrayOop)HeapShared::archive_object(v);\n@@ -729,1 +731,1 @@\n-  new_s = HeapShared::archive_heap_object(s);\n+  new_s = HeapShared::archive_object(s);\n@@ -780,1 +782,1 @@\n-  } else if (!HeapShared::closed_archive_heap_region_mapped()) {\n+  } else if (!HeapShared::closed_regions_mapped()) {\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -158,1 +157,0 @@\n-  if (AlwaysLockClassLoader) return false;\n@@ -1312,1 +1310,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);\n@@ -1314,1 +1311,1 @@\n-    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle string = java_lang_String::externalize_classname(class_name, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,5 +205,0 @@\n-protected:\n-  \/\/ Returns the class loader data to be used when looking up\/updating the\n-  \/\/ system dictionary.\n-  static ClassLoaderData *class_loader_data(Handle class_loader);\n-\n@@ -214,0 +209,4 @@\n+  \/\/ Returns the class loader data to be used when looking up\/updating the\n+  \/\/ system dictionary.\n+  static ClassLoaderData *class_loader_data(Handle class_loader);\n+\n@@ -223,1 +222,0 @@\n-public:\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -63,1 +66,0 @@\n-#include \"prims\/jvmtiExport.hpp\"\n@@ -73,0 +75,13 @@\n+DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = NULL;\n+DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = NULL;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+\/\/ SystemDictionaries in the base layer static archive\n+RunTimeSharedDictionary SystemDictionaryShared::_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_unregistered_dictionary;\n+\/\/ SystemDictionaries in the top layer dynamic archive\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_builtin_dictionary;\n+RunTimeSharedDictionary SystemDictionaryShared::_dynamic_unregistered_dictionary;\n+\n+LambdaProxyClassDictionary SystemDictionaryShared::_lambda_proxy_class_dictionary;\n+LambdaProxyClassDictionary SystemDictionaryShared::_dynamic_lambda_proxy_class_dictionary;\n@@ -74,3 +89,0 @@\n-OopHandle SystemDictionaryShared::_shared_protection_domains;\n-OopHandle SystemDictionaryShared::_shared_jar_urls;\n-OopHandle SystemDictionaryShared::_shared_jar_manifests;\n@@ -80,80 +92,4 @@\n-class DumpTimeSharedClassInfo: public CHeapObj<mtClass> {\n-  bool                         _excluded;\n-  bool                         _is_early_klass;\n-  bool                         _has_checked_exclusion;\n-public:\n-  struct DTLoaderConstraint {\n-    Symbol* _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {\n-      _name->increment_refcount();\n-    }\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n-    bool equals(const DTLoaderConstraint& t) {\n-      return t._name == _name &&\n-             ((t._loader_type1 == _loader_type1 && t._loader_type2 == _loader_type2) ||\n-              (t._loader_type2 == _loader_type1 && t._loader_type1 == _loader_type2));\n-    }\n-  };\n-\n-  struct DTVerifierConstraint {\n-    Symbol* _name;\n-    Symbol* _from_name;\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n-    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n-      _name->increment_refcount();\n-      _from_name->increment_refcount();\n-    }\n-  };\n-\n-  InstanceKlass*               _klass;\n-  InstanceKlass*               _nest_host;\n-  bool                         _failed_verification;\n-  bool                         _is_archived_lambda_proxy;\n-  int                          _id;\n-  int                          _clsfile_size;\n-  int                          _clsfile_crc32;\n-  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n-  GrowableArray<char>*                 _verifier_constraint_flags;\n-  GrowableArray<DTLoaderConstraint>* _loader_constraints;\n-\n-  DumpTimeSharedClassInfo() {\n-    _klass = NULL;\n-    _nest_host = NULL;\n-    _failed_verification = false;\n-    _is_archived_lambda_proxy = false;\n-    _has_checked_exclusion = false;\n-    _id = -1;\n-    _clsfile_size = -1;\n-    _clsfile_crc32 = -1;\n-    _excluded = false;\n-    _is_early_klass = JvmtiExport::is_early_phase();\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-  }\n-\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n-  void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);\n-\n-  bool is_builtin() {\n-    return SystemDictionaryShared::is_builtin(_klass);\n-  }\n-\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n-\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n-  }\n+InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n+                 Symbol* class_name, Handle class_loader, TRAPS) {\n+  assert(UseSharedSpaces, \"must be\");\n+  InstanceKlass* ik = find_builtin_class(class_name);\n@@ -161,15 +97,8 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_klass);\n-    it->push(&_nest_host);\n-    if (_verifier_constraints != NULL) {\n-      for (int i = 0; i < _verifier_constraints->length(); i++) {\n-        DTVerifierConstraint* cons = _verifier_constraints->adr_at(i);\n-        it->push(&cons->_name);\n-        it->push(&cons->_from_name);\n-      }\n-    }\n-    if (_loader_constraints != NULL) {\n-      for (int i = 0; i < _loader_constraints->length(); i++) {\n-        DTLoaderConstraint* lc = _loader_constraints->adr_at(i);\n-        it->push(&lc->_name);\n-      }\n+  if (ik != NULL && !ik->shared_loading_failed()) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+      SharedClassLoadingMark slm(THREAD, ik);\n+      PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n+      Handle protection_domain =\n+        CDSProtectionDomain::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n+      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n@@ -178,31 +107,1 @@\n-\n-  bool is_excluded() {\n-    \/\/ _klass may become NULL due to DynamicArchiveBuilder::set_to_null\n-    return _excluded || _failed_verification || _klass == NULL;\n-  }\n-\n-  \/\/ Was this class loaded while JvmtiExport::is_early_phase()==true\n-  bool is_early_klass() {\n-    return _is_early_klass;\n-  }\n-\n-  \/\/ simple accessors\n-  void set_excluded()                               { _excluded = true; }\n-  bool has_checked_exclusion() const                { return _has_checked_exclusion; }\n-  void set_has_checked_exclusion()                  { _has_checked_exclusion = true; }\n-  bool failed_verification() const                  { return _failed_verification; }\n-  void set_failed_verification()                    { _failed_verification = true; }\n-  InstanceKlass* nest_host() const                  { return _nest_host; }\n-  void set_nest_host(InstanceKlass* nest_host)      { _nest_host = nest_host; }\n-};\n-\n-inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n-  if (DumpSharedSpaces) {\n-    \/\/ Deterministic archive contents\n-    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n-    return primitive_hash<uintx>(delta);\n-  } else {\n-    \/\/ Deterministic archive is not possible because classes can be loaded\n-    \/\/ in multiple threads.\n-    return primitive_hash<InstanceKlass*>(k);\n-  }\n+  return NULL;\n@@ -211,52 +110,8 @@\n-class DumpTimeSharedClassTable: public ResourceHashtable<\n-  InstanceKlass*,\n-  DumpTimeSharedClassInfo,\n-  &DumpTimeSharedClassTable_hash,\n-  primitive_equals<InstanceKlass*>,\n-  15889, \/\/ prime number\n-  ResourceObj::C_HEAP>\n-{\n-  int _builtin_count;\n-  int _unregistered_count;\n-public:\n-  DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k, bool dump_in_progress) {\n-    bool created = false;\n-    DumpTimeSharedClassInfo* p;\n-    if (!dump_in_progress) {\n-      p = put_if_absent(k, &created);\n-    } else {\n-      p = get(k);\n-    }\n-    if (created) {\n-      assert(!SystemDictionaryShared::no_class_loading_should_happen(),\n-             \"no new classes can be loaded while dumping archive\");\n-      p->_klass = k;\n-    } else {\n-      if (!dump_in_progress) {\n-        assert(p->_klass == k, \"Sanity\");\n-      }\n-    }\n-    return p;\n-  }\n-\n-  class CountClassByCategory : StackObj {\n-    DumpTimeSharedClassTable* _table;\n-  public:\n-    CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}\n-    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n-      if (!info.is_excluded()) {\n-        if (info.is_builtin()) {\n-          ++ _table->_builtin_count;\n-        } else {\n-          ++ _table->_unregistered_count;\n-        }\n-      }\n-      return true; \/\/ keep on iterating\n-    }\n-  };\n-\n-  void update_counts() {\n-    _builtin_count = 0;\n-    _unregistered_count = 0;\n-    CountClassByCategory counter(this);\n-    iterate(&counter);\n+\/\/ This function is called for loading only UNREGISTERED classes\n+InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n+                                                          Handle class_loader,\n+                                                          Handle protection_domain,\n+                                                          const ClassFileStream* cfs,\n+                                                          TRAPS) {\n+  if (!UseSharedSpaces) {\n+    return NULL;\n@@ -264,7 +119,2 @@\n-\n-  int count_of(bool is_builtin) const {\n-    if (is_builtin) {\n-      return _builtin_count;\n-    } else {\n-      return _unregistered_count;\n-    }\n+  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n+    return NULL;\n@@ -272,65 +122,5 @@\n-};\n-\n-class LambdaProxyClassKey {\n-  InstanceKlass* _caller_ik;\n-  Symbol*        _invoked_name;\n-  Symbol*        _invoked_type;\n-  Symbol*        _method_type;\n-  Method*        _member_method;\n-  Symbol*        _instantiated_method_type;\n-\n-public:\n-  LambdaProxyClassKey(InstanceKlass* caller_ik,\n-                      Symbol*        invoked_name,\n-                      Symbol*        invoked_type,\n-                      Symbol*        method_type,\n-                      Method*        member_method,\n-                      Symbol*        instantiated_method_type) :\n-    _caller_ik(caller_ik),\n-    _invoked_name(invoked_name),\n-    _invoked_type(invoked_type),\n-    _method_type(method_type),\n-    _member_method(member_method),\n-    _instantiated_method_type(instantiated_method_type) {}\n-\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_caller_ik);\n-    it->push(&_invoked_name);\n-    it->push(&_invoked_type);\n-    it->push(&_method_type);\n-    it->push(&_member_method);\n-    it->push(&_instantiated_method_type);\n-  }\n-\n-  void mark_pointers() {\n-    ArchivePtrMarker::mark_pointer(&_caller_ik);\n-    ArchivePtrMarker::mark_pointer(&_instantiated_method_type);\n-    ArchivePtrMarker::mark_pointer(&_invoked_name);\n-    ArchivePtrMarker::mark_pointer(&_invoked_type);\n-    ArchivePtrMarker::mark_pointer(&_member_method);\n-    ArchivePtrMarker::mark_pointer(&_method_type);\n-  }\n-\n-  bool equals(LambdaProxyClassKey const& other) const {\n-    return _caller_ik == other._caller_ik &&\n-           _invoked_name == other._invoked_name &&\n-           _invoked_type == other._invoked_type &&\n-           _method_type == other._method_type &&\n-           _member_method == other._member_method &&\n-           _instantiated_method_type == other._instantiated_method_type;\n-  }\n-\n-  unsigned int hash() const {\n-    return SystemDictionaryShared::hash_for_shared_dictionary((address)_caller_ik) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_name) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_invoked_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_method_type) +\n-           SystemDictionaryShared::hash_for_shared_dictionary((address)_instantiated_method_type);\n-  }\n-\n-  static unsigned int dumptime_hash(Symbol* sym)  {\n-    if (sym == NULL) {\n-      \/\/ _invoked_name maybe NULL\n-      return 0;\n-    }\n-    return java_lang_String::hash_code((const jbyte*)sym->bytes(), sym->utf8_length());\n+  if (class_loader.is_null() ||\n+      SystemDictionary::is_system_class_loader(class_loader()) ||\n+      SystemDictionary::is_platform_class_loader(class_loader())) {\n+    \/\/ Do nothing for the BUILTIN loaders.\n+    return NULL;\n@@ -339,6 +129,3 @@\n-  unsigned int dumptime_hash() const {\n-    return dumptime_hash(_caller_ik->name()) +\n-           dumptime_hash(_invoked_name) +\n-           dumptime_hash(_invoked_type) +\n-           dumptime_hash(_method_type) +\n-           dumptime_hash(_instantiated_method_type);\n+  const RunTimeClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n+  if (record == NULL) {\n+    return NULL;\n@@ -347,3 +134,2 @@\n-  static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const& key) {\n-    return (key.dumptime_hash());\n-  }\n+  int clsfile_size  = cfs->length();\n+  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n@@ -351,3 +137,2 @@\n-  static inline bool DUMPTIME_EQUALS(\n-      LambdaProxyClassKey const& k1, LambdaProxyClassKey const& k2) {\n-    return (k1.equals(k2));\n+  if (!record->matches(clsfile_size, clsfile_crc32)) {\n+    return NULL;\n@@ -356,2 +141,4 @@\n-  InstanceKlass* caller_ik() const { return _caller_ik; }\n-};\n+  return acquire_class_for_current_thread(record->_klass, class_loader,\n+                                          protection_domain, cfs,\n+                                          THREAD);\n+}\n@@ -359,0 +146,7 @@\n+InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n+                   InstanceKlass *ik,\n+                   Handle class_loader,\n+                   Handle protection_domain,\n+                   const ClassFileStream *cfs,\n+                   TRAPS) {\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n@@ -360,7 +154,6 @@\n-class DumpTimeLambdaProxyClassInfo {\n-public:\n-  GrowableArray<InstanceKlass*>* _proxy_klasses;\n-  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n-  void add_proxy_klass(InstanceKlass* proxy_klass) {\n-    if (_proxy_klasses == NULL) {\n-      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+  {\n+    MutexLocker mu(THREAD, SharedDictionary_lock);\n+    if (ik->class_loader_data() != NULL) {\n+      \/\/    ik is already loaded (by this loader or by a different loader)\n+      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n+      return NULL;\n@@ -368,3 +161,0 @@\n-    assert(_proxy_klasses != NULL, \"sanity\");\n-    _proxy_klasses->append(proxy_klass);\n-  }\n@@ -372,4 +162,2 @@\n-  void metaspace_pointers_do(MetaspaceClosure* it) {\n-    for (int i=0; i<_proxy_klasses->length(); i++) {\n-      it->push(_proxy_klasses->adr_at(i));\n-    }\n+    \/\/ No other thread has acquired this yet, so give it to *this thread*\n+    ik->set_class_loader_data(loader_data);\n@@ -377,1 +165,0 @@\n-};\n@@ -379,8 +166,3 @@\n-class RunTimeLambdaProxyClassInfo {\n-  LambdaProxyClassKey _key;\n-  InstanceKlass* _proxy_klass_head;\n-public:\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n-    _key(key), _proxy_klass_head(proxy_klass_head) {}\n-\n-  InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }\n+  \/\/ No longer holding SharedDictionary_lock\n+  \/\/ No need to lock, as <ik> can be held only by a single thread.\n+  loader_data->add_class(ik);\n@@ -388,11 +170,2 @@\n-  \/\/ Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n-    return (value->_key.equals(*key));\n-  }\n-  void init(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n-    _key = key;\n-    _key.mark_pointers();\n-    _proxy_klass_head = info._proxy_klasses->at(0);\n-    ArchivePtrMarker::mark_pointer(&_proxy_klass_head);\n-  }\n+  \/\/ Get the package entry.\n+  PackageEntry* pkg_entry = CDSProtectionDomain::get_package_entry_from_class(ik, class_loader);\n@@ -400,5 +173,6 @@\n-  unsigned int hash() const {\n-    return _key.hash();\n-  }\n-  LambdaProxyClassKey key() const {\n-    return _key;\n+  \/\/ Load and check super\/interfaces, restore unsharable info\n+  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n+                                                  cfs, pkg_entry, THREAD);\n+  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n+    \/\/ TODO: clean up <ik> so it can be used again\n+    return NULL;\n@@ -406,6 +180,0 @@\n-};\n-\n-class LambdaProxyClassDictionary : public OffsetCompactHashtable<\n-  LambdaProxyClassKey*,\n-  const RunTimeLambdaProxyClassInfo*,\n-  RunTimeLambdaProxyClassInfo::EQUALS> {};\n@@ -413,3 +181,2 @@\n-LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n-\n-LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n+  return shared_klass;\n+}\n@@ -417,10 +184,4 @@\n-class DumpTimeLambdaProxyClassDictionary\n-  : public ResourceHashtable<LambdaProxyClassKey,\n-                             DumpTimeLambdaProxyClassInfo,\n-                             LambdaProxyClassKey::DUMPTIME_HASH,\n-                             LambdaProxyClassKey::DUMPTIME_EQUALS,\n-                             137, \/\/ prime number\n-                             ResourceObj::C_HEAP> {\n-public:\n-  int _count;\n-};\n+void SystemDictionaryShared::start_dumping() {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  _dump_in_progress = true;\n+}\n@@ -428,1 +189,4 @@\n-DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  return find_or_allocate_info_for_locked(k);\n+}\n@@ -430,2 +194,1 @@\n-static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey key,\n-                                                           InstanceKlass* proxy_klass) {\n+DumpTimeClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n@@ -433,14 +196,2 @@\n-  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n-    _dumptime_lambda_proxy_class_dictionary =\n-      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n-  }\n-  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-  if (lambda_info == NULL) {\n-    DumpTimeLambdaProxyClassInfo info;\n-    info.add_proxy_klass(proxy_klass);\n-    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n-    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n-    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n-    ++_dumptime_lambda_proxy_class_dictionary->_count;\n-  } else {\n-    lambda_info->add_proxy_klass(proxy_klass);\n+  if (_dumptime_table == NULL) {\n+    _dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n@@ -448,0 +199,1 @@\n+  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n@@ -450,51 +202,6 @@\n-class RunTimeSharedClassInfo {\n-public:\n-  struct CrcInfo {\n-    int _clsfile_size;\n-    int _clsfile_crc32;\n-  };\n-\n-  \/\/ This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use\n-  \/\/ u4 instead of Symbol* to save space on 64-bit CPU.\n-  struct RTVerifierConstraint {\n-    u4 _name;\n-    u4 _from_name;\n-    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n-    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n-  };\n-\n-  struct RTLoaderConstraint {\n-    u4   _name;\n-    char _loader_type1;\n-    char _loader_type2;\n-    Symbol* constraint_name() {\n-      return (Symbol*)(SharedBaseAddress + _name);\n-    }\n-  };\n-\n-  InstanceKlass* _klass;\n-  int _num_verifier_constraints;\n-  int _num_loader_constraints;\n-\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n-\n-private:\n-  static size_t header_size_size() {\n-    return sizeof(RunTimeSharedClassInfo);\n-  }\n-  static size_t crc_size(InstanceKlass* klass) {\n-    if (!SystemDictionaryShared::is_builtin(klass)) {\n-      return sizeof(CrcInfo);\n-    } else {\n-      return 0;\n-    }\n-  }\n-  static size_t verifier_constraints_size(int num_verifier_constraints) {\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n-  }\n-  static size_t verifier_constraint_flags_size(int num_verifier_constraints) {\n-    return sizeof(char) * num_verifier_constraints;\n+bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n+    \/\/ We have reached a super type that's already in the base archive. Treat it\n+    \/\/ as \"not excluded\".\n+    assert(DynamicDumpSharedSpaces, \"must be\");\n+    return false;\n@@ -502,2 +209,4 @@\n-  static size_t loader_constraints_size(int num_loader_constraints) {\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+\n+  if (info == NULL) {\n+    info = _dumptime_table->get(k);\n+    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n@@ -505,5 +214,4 @@\n-  static size_t nest_host_size(InstanceKlass* klass) {\n-    if (klass->is_hidden()) {\n-      return sizeof(InstanceKlass*);\n-    } else {\n-      return 0;\n+\n+  if (!info->has_checked_exclusion()) {\n+    if (check_for_exclusion_impl(k)) {\n+      info->set_excluded();\n@@ -511,0 +219,1 @@\n+    info->set_has_checked_exclusion();\n@@ -513,9 +222,2 @@\n-public:\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n-    return header_size_size() +\n-           crc_size(klass) +\n-           nest_host_size(klass) +\n-           loader_constraints_size(num_loader_constraints) +\n-           verifier_constraints_size(num_verifier_constraints) +\n-           verifier_constraint_flags_size(num_verifier_constraints);\n-  }\n+  return info->is_excluded();\n+}\n@@ -523,4 +225,6 @@\n-private:\n-  size_t crc_offset() const {\n-    return header_size_size();\n-  }\n+\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n+bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n+  ResourceMark rm;\n+  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  return true;\n+}\n@@ -528,2 +232,6 @@\n-  size_t nest_host_offset() const {\n-      return crc_offset() + crc_size(_klass);\n+bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n+  while (k) {\n+    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n+      return true;\n+    }\n+    k = k->java_super();\n@@ -531,0 +239,2 @@\n+  return false;\n+}\n@@ -532,9 +242,4 @@\n-  size_t loader_constraints_offset() const  {\n-    return nest_host_offset() + nest_host_size(_klass);\n-  }\n-  size_t verifier_constraints_offset() const {\n-    return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);\n-  }\n-  size_t verifier_constraint_flags_offset() const {\n-    return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);\n-  }\n+bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n+}\n@@ -542,3 +247,4 @@\n-  void check_verifier_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_verifier_constraints, \"sanity\");\n-  }\n+bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n+  DumpTimeClassInfo* info = _dumptime_table->get(ik);\n+  return (info != NULL) ? info->is_early_klass() : false;\n+}\n@@ -546,2 +252,6 @@\n-  void check_loader_constraint_offset(int i) const {\n-    assert(0 <= i && i < _num_loader_constraints, \"sanity\");\n+bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n+  assert(ik->is_shared(), \"applicable to only a shared class\");\n+  if (ik->is_hidden()) {\n+    return true;\n+  } else {\n+    return false;\n@@ -549,0 +259,1 @@\n+}\n@@ -550,12 +261,3 @@\n-public:\n-  CrcInfo* crc() const {\n-    assert(crc_size(_klass) > 0, \"must be\");\n-    return (CrcInfo*)(address(this) + crc_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraints() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());\n-  }\n-  RTVerifierConstraint* verifier_constraint_at(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraints() + i;\n+bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n+  if (k->is_in_error_state()) {\n+    return warn_excluded(k, \"In error state\");\n@@ -563,4 +265,2 @@\n-\n-  char* verifier_constraint_flags() {\n-    assert(_num_verifier_constraints > 0, \"sanity\");\n-    return (char*)(address(this) + verifier_constraint_flags_offset());\n+  if (k->is_scratch_class()) {\n+    return warn_excluded(k, \"A scratch class\");\n@@ -568,4 +268,2 @@\n-\n-  InstanceKlass** nest_host_addr() {\n-    assert(_klass->is_hidden(), \"sanity\");\n-    return (InstanceKlass**)(address(this) + nest_host_offset());\n+  if (!k->is_loaded()) {\n+    return warn_excluded(k, \"Not in loaded state\");\n@@ -573,2 +271,2 @@\n-  InstanceKlass* nest_host() {\n-    return *nest_host_addr();\n+  if (has_been_redefined(k)) {\n+    return warn_excluded(k, \"Has been redefined\");\n@@ -576,3 +274,4 @@\n-  void set_nest_host(InstanceKlass* k) {\n-    *nest_host_addr() = k;\n-    ArchivePtrMarker::mark_pointer((address*)nest_host_addr());\n+  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n+    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n+    \/\/ agent during dump time).\n+    return warn_excluded(k, \"Unsupported location\");\n@@ -580,4 +279,5 @@\n-\n-  RTLoaderConstraint* loader_constraints() {\n-    assert(_num_loader_constraints > 0, \"sanity\");\n-    return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());\n+  if (k->signers() != NULL) {\n+    \/\/ We cannot include signed classes in the archive because the certificates\n+    \/\/ used during dump time may be different than those used during\n+    \/\/ runtime (due to expiration, etc).\n+    return warn_excluded(k, \"Signed JAR\");\n@@ -585,4 +285,6 @@\n-\n-  RTLoaderConstraint* loader_constraint_at(int i) {\n-    check_loader_constraint_offset(i);\n-    return loader_constraints() + i;\n+  if (is_jfr_event_class(k)) {\n+    \/\/ We cannot include JFR event classes because they need runtime-specific\n+    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n+    \/\/ There are only a small number of these classes, so it's not worthwhile to\n+    \/\/ support them and make CDS more complicated.\n+    return warn_excluded(k, \"JFR event class\");\n@@ -591,31 +293,3 @@\n-  void init(DumpTimeSharedClassInfo& info) {\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    assert(builder->is_in_buffer_space(info._klass), \"must be\");\n-    _klass = info._klass;\n-    if (!SystemDictionaryShared::is_builtin(_klass)) {\n-      CrcInfo* c = crc();\n-      c->_clsfile_size = info._clsfile_size;\n-      c->_clsfile_crc32 = info._clsfile_crc32;\n-    }\n-    _num_verifier_constraints = info.num_verifier_constraints();\n-    _num_loader_constraints   = info.num_loader_constraints();\n-    int i;\n-    if (_num_verifier_constraints > 0) {\n-      RTVerifierConstraint* vf_constraints = verifier_constraints();\n-      char* flags = verifier_constraint_flags();\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i)._name);\n-        vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i)._from_name);\n-      }\n-      for (i = 0; i < _num_verifier_constraints; i++) {\n-        flags[i] = info._verifier_constraint_flags->at(i);\n-      }\n-    }\n-\n-    if (_num_loader_constraints > 0) {\n-      RTLoaderConstraint* ld_constraints = loader_constraints();\n-      for (i = 0; i < _num_loader_constraints; i++) {\n-        ld_constraints[i]._name = builder->any_to_offset_u4(info._loader_constraints->at(i)._name);\n-        ld_constraints[i]._loader_type1 = info._loader_constraints->at(i)._loader_type1;\n-        ld_constraints[i]._loader_type2 = info._loader_constraints->at(i)._loader_type2;\n-      }\n+  if (!k->is_linked()) {\n+    if (has_class_failed_verification(k)) {\n+      return warn_excluded(k, \"Failed verification\");\n@@ -623,4 +297,9 @@\n-\n-    if (_klass->is_hidden()) {\n-      InstanceKlass* n_h = info.nest_host();\n-      set_nest_host(n_h);\n+  } else {\n+    if (!k->can_be_verified_at_dumptime()) {\n+      \/\/ We have an old class that has been linked (e.g., it's been executed during\n+      \/\/ dump time). This class has been verified using the old verifier, which\n+      \/\/ doesn't save the verification constraints, so check_verification_constraints()\n+      \/\/ won't work at runtime.\n+      \/\/ As a result, we cannot store this class. It must be loaded and fully verified\n+      \/\/ at runtime.\n+      return warn_excluded(k, \"Old class has been linked\");\n@@ -628,11 +307,0 @@\n-    ArchivePtrMarker::mark_pointer(&_klass);\n-  }\n-\n-  bool matches(int clsfile_size, int clsfile_crc32) const {\n-    return crc()->_clsfile_size  == clsfile_size &&\n-           crc()->_clsfile_crc32 == clsfile_crc32;\n-  }\n-\n-  char verifier_constraint_flag(int i) {\n-    check_verifier_constraint_offset(i);\n-    return verifier_constraint_flags()[i];\n@@ -641,23 +309,4 @@\n-private:\n-  \/\/ ArchiveBuilder::make_shallow_copy() has reserved a pointer immediately\n-  \/\/ before archived InstanceKlasses. We can use this slot to do a quick\n-  \/\/ lookup of InstanceKlass* -> RunTimeSharedClassInfo* without\n-  \/\/ building a new hashtable.\n-  \/\/\n-  \/\/  info_pointer_addr(klass) --> 0x0100   RunTimeSharedClassInfo*\n-  \/\/  InstanceKlass* klass     --> 0x0108   <C++ vtbl>\n-  \/\/                               0x0110   fields from Klass ...\n-  static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {\n-    return &((RunTimeSharedClassInfo**)klass)[-1];\n-  }\n-\n-public:\n-  static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n-    return *info_pointer_addr(klass);\n-  }\n-  static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(klass), \"must be\");\n-    assert(ArchiveBuilder::current()->is_in_buffer_space(record), \"must be\");\n-    *info_pointer_addr(klass) = record;\n-    ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));\n+  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n+    ResourceMark rm;\n+    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+    return true;\n@@ -666,4 +315,5 @@\n-  \/\/ Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS\n-  static inline bool EQUALS(\n-       const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {\n-    return (value->_klass->name() == key);\n+  InstanceKlass* super = k->java_super();\n+  if (super != NULL && check_for_exclusion(super, NULL)) {\n+    ResourceMark rm;\n+    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+    return true;\n@@ -671,45 +321,0 @@\n-};\n-\n-class RunTimeSharedDictionary : public OffsetCompactHashtable<\n-  Symbol*,\n-  const RunTimeSharedClassInfo*,\n-  RunTimeSharedClassInfo::EQUALS> {};\n-\n-static DumpTimeSharedClassTable* _dumptime_table = NULL;\n-\/\/ SystemDictionaries in the base layer static archive\n-static RunTimeSharedDictionary _builtin_dictionary;\n-static RunTimeSharedDictionary _unregistered_dictionary;\n-\/\/ SystemDictionaries in the top layer dynamic archive\n-static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n-static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n-\n-void SystemDictionaryShared::atomic_set_array_index(OopHandle array, int index, oop o) {\n-  \/\/ Benign race condition:  array.obj_at(index) may already be filled in.\n-  \/\/ The important thing here is that all threads pick up the same result.\n-  \/\/ It doesn't matter which racing thread wins, as long as only one\n-  \/\/ result is used by all threads, and all future queries.\n-  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n-}\n-\n-Handle SystemDictionaryShared::create_jar_manifest(const char* manifest_chars, size_t size, TRAPS) {\n-  typeArrayOop buf = oopFactory::new_byteArray((int)size, CHECK_NH);\n-  typeArrayHandle bufhandle(THREAD, buf);\n-  ArrayAccess<>::arraycopy_from_native(reinterpret_cast<const jbyte*>(manifest_chars),\n-                                         buf, typeArrayOopDesc::element_offset<jbyte>(0), size);\n-  Handle bais = JavaCalls::construct_new_instance(vmClasses::ByteArrayInputStream_klass(),\n-                      vmSymbols::byte_array_void_signature(),\n-                      bufhandle, CHECK_NH);\n-  \/\/ manifest = new Manifest(ByteArrayInputStream)\n-  Handle manifest = JavaCalls::construct_new_instance(vmClasses::Jar_Manifest_klass(),\n-                      vmSymbols::input_stream_void_signature(),\n-                      bais, CHECK_NH);\n-  return manifest;\n-}\n-\n-oop SystemDictionaryShared::shared_protection_domain(int index) {\n-  return ((objArrayOop)_shared_protection_domains.resolve())->obj_at(index);\n-}\n-\n-oop SystemDictionaryShared::shared_jar_url(int index) {\n-  return ((objArrayOop)_shared_jar_urls.resolve())->obj_at(index);\n-}\n@@ -717,148 +322,7 @@\n-oop SystemDictionaryShared::shared_jar_manifest(int index) {\n-  return ((objArrayOop)_shared_jar_manifests.resolve())->obj_at(index);\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {\n-  Handle manifest ;\n-  if (shared_jar_manifest(shared_path_index) == NULL) {\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n-    size_t size = (size_t)ent->manifest_size();\n-    if (size == 0) {\n-      return Handle();\n-    }\n-\n-    \/\/ ByteArrayInputStream bais = new ByteArrayInputStream(buf);\n-    const char* src = ent->manifest();\n-    assert(src != NULL, \"No Manifest data\");\n-    manifest = create_jar_manifest(src, size, CHECK_NH);\n-    atomic_set_shared_jar_manifest(shared_path_index, manifest());\n-  }\n-  manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));\n-  assert(manifest.not_null(), \"sanity\");\n-  return manifest;\n-}\n-\n-Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {\n-  Handle url_h;\n-  if (shared_jar_url(shared_path_index) == NULL) {\n-    JavaValue result(T_OBJECT);\n-    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n-    Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));\n-    Klass* classLoaders_klass =\n-        vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-    JavaCalls::call_static(&result, classLoaders_klass,\n-                           vmSymbols::toFileURL_name(),\n-                           vmSymbols::toFileURL_signature(),\n-                           path_string, CHECK_(url_h));\n-\n-    atomic_set_shared_jar_url(shared_path_index, result.get_oop());\n-  }\n-\n-  url_h = Handle(THREAD, shared_jar_url(shared_path_index));\n-  assert(url_h.not_null(), \"sanity\");\n-  return url_h;\n-}\n-\n-Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  Handle pkgname_string;\n-  TempNewSymbol pkg = ClassLoader::package_from_class_name(class_name);\n-  if (pkg != NULL) { \/\/ Package prefix found\n-    const char* pkgname = pkg->as_klass_external_name();\n-    pkgname_string = java_lang_String::create_from_str(pkgname,\n-                                                       CHECK_(pkgname_string));\n-  }\n-  return pkgname_string;\n-}\n-\n-\/\/ Define Package for shared app classes from JAR file and also checks for\n-\/\/ package sealing (all done in Java code)\n-\/\/ See http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar\/sealman.html\n-void SystemDictionaryShared::define_shared_package(Symbol*  class_name,\n-                                                   Handle class_loader,\n-                                                   Handle manifest,\n-                                                   Handle url,\n-                                                   TRAPS) {\n-  assert(SystemDictionary::is_system_class_loader(class_loader()), \"unexpected class loader\");\n-  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n-  Handle pkgname_string = get_package_name(class_name, CHECK);\n-  if (pkgname_string.not_null()) {\n-    Klass* app_classLoader_klass = vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();\n-    JavaValue result(T_OBJECT);\n-    JavaCallArguments args(3);\n-    args.set_receiver(class_loader);\n-    args.push_oop(pkgname_string);\n-    args.push_oop(manifest);\n-    args.push_oop(url);\n-    JavaCalls::call_virtual(&result, app_classLoader_klass,\n-                            vmSymbols::defineOrCheckPackage_name(),\n-                            vmSymbols::defineOrCheckPackage_signature(),\n-                            &args,\n-                            CHECK);\n-  }\n-}\n-\n-\/\/ Get the ProtectionDomain associated with the CodeSource from the classloader.\n-Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,\n-                                                                      Handle url, TRAPS) {\n-  \/\/ CodeSource cs = new CodeSource(url, null);\n-  Handle cs = JavaCalls::construct_new_instance(vmClasses::CodeSource_klass(),\n-                  vmSymbols::url_code_signer_array_void_signature(),\n-                  url, Handle(), CHECK_NH);\n-\n-  \/\/ protection_domain = SecureClassLoader.getProtectionDomain(cs);\n-  Klass* secureClassLoader_klass = vmClasses::SecureClassLoader_klass();\n-  JavaValue obj_result(T_OBJECT);\n-  JavaCalls::call_virtual(&obj_result, class_loader, secureClassLoader_klass,\n-                          vmSymbols::getProtectionDomain_name(),\n-                          vmSymbols::getProtectionDomain_signature(),\n-                          cs, CHECK_NH);\n-  return Handle(THREAD, obj_result.get_oop());\n-}\n-\n-\/\/ Returns the ProtectionDomain associated with the JAR file identified by the url.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            int shared_path_index,\n-                                                            Handle url,\n-                                                            TRAPS) {\n-  Handle protection_domain;\n-  if (shared_protection_domain(shared_path_index) == NULL) {\n-    Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);\n-    atomic_set_shared_protection_domain(shared_path_index, pd());\n-  }\n-\n-  \/\/ Acquire from the cache because if another thread beats the current one to\n-  \/\/ set the shared protection_domain and the atomic_set fails, the current thread\n-  \/\/ needs to get the updated protection_domain from the cache.\n-  protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Returns the ProtectionDomain associated with the moduleEntry.\n-Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,\n-                                                            ModuleEntry* mod, TRAPS) {\n-  ClassLoaderData *loader_data = mod->loader_data();\n-  if (mod->shared_protection_domain() == NULL) {\n-    Symbol* location = mod->location();\n-    if (location != NULL) {\n-      Handle location_string = java_lang_String::create_from_symbol(\n-                                     location, CHECK_NH);\n-      Handle url;\n-      JavaValue result(T_OBJECT);\n-      if (location->starts_with(\"jrt:\/\")) {\n-        url = JavaCalls::construct_new_instance(vmClasses::URL_klass(),\n-                                                vmSymbols::string_void_signature(),\n-                                                location_string, CHECK_NH);\n-      } else {\n-        Klass* classLoaders_klass =\n-          vmClasses::jdk_internal_loader_ClassLoaders_klass();\n-        JavaCalls::call_static(&result, classLoaders_klass, vmSymbols::toFileURL_name(),\n-                               vmSymbols::toFileURL_signature(),\n-                               location_string, CHECK_NH);\n-        url = Handle(THREAD, result.get_oop());\n-      }\n-\n-      Handle pd = get_protection_domain_from_classloader(class_loader, url,\n-                                                         CHECK_NH);\n-      mod->set_shared_protection_domain(loader_data, pd);\n+  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (check_for_exclusion(intf, NULL)) {\n+      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+      return true;\n@@ -868,69 +332,1 @@\n-  Handle protection_domain(THREAD, mod->shared_protection_domain());\n-  assert(protection_domain.not_null(), \"sanity\");\n-  return protection_domain;\n-}\n-\n-\/\/ Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with\n-\/\/ the given InstanceKlass.\n-\/\/ Returns the ProtectionDomain for the InstanceKlass.\n-Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {\n-  Handle pd;\n-\n-  if (ik != NULL) {\n-    int index = ik->shared_classpath_index();\n-    assert(index >= 0, \"Sanity\");\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n-    Symbol* class_name = ik->name();\n-\n-    if (ent->is_modules_image()) {\n-      \/\/ For shared app\/platform classes originated from the run-time image:\n-      \/\/   The ProtectionDomains are cached in the corresponding ModuleEntries\n-      \/\/   for fast access by the VM.\n-      \/\/ all packages from module image are already created during VM bootstrap in\n-      \/\/ Modules::define_module().\n-      assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n-      ModuleEntry* mod_entry = pkg_entry->module();\n-      pd = get_shared_protection_domain(class_loader, mod_entry, CHECK_(pd));\n-    } else {\n-      \/\/ For shared app\/platform classes originated from JAR files on the class path:\n-      \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n-      \/\/   as the shared classpath table in the shared archive (see\n-      \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n-      \/\/\n-      \/\/   If a shared InstanceKlass k is loaded from the class path, let\n-      \/\/\n-      \/\/     index = k->shared_classpath_index():\n-      \/\/\n-      \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n-      \/\/\n-      \/\/   k's protection domain is:\n-      \/\/\n-      \/\/     ProtectionDomain pd = _shared_protection_domains[index];\n-      \/\/\n-      \/\/   and k's Package is initialized using\n-      \/\/\n-      \/\/     manifest = _shared_jar_manifests[index];\n-      \/\/     url = _shared_jar_urls[index];\n-      \/\/     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      \/\/\n-      \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n-      \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n-      Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));\n-      Handle url = get_shared_jar_url(index, CHECK_(pd));\n-      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n-      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {\n-        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n-          \/\/ define_shared_package only needs to be called once for each package in a jar specified\n-          \/\/ in the shared class path.\n-          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-          if (pkg_entry != NULL) {\n-            pkg_entry->set_defined_by_cds_in_class_path(index_offset);\n-          }\n-        }\n-      } else {\n-        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));\n-      }\n-      pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));\n-    }\n-  }\n-  return pd;\n+  return false; \/\/ false == k should NOT be excluded\n@@ -1020,143 +416,5 @@\n-      if (k != NULL) {\n-        SharedClassLoadingMark slm(THREAD, k);\n-        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n-      }\n-    }\n-  }\n-  return k;\n-}\n-\n-PackageEntry* SystemDictionaryShared::get_package_entry_from_class(InstanceKlass* ik, Handle class_loader) {\n-  PackageEntry* pkg_entry = ik->package();\n-  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n-    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n-    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n-    return pkg_entry;\n-  }\n-  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(ik->name());\n-  if (pkg_name != NULL) {\n-    pkg_entry = class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n-  } else {\n-    pkg_entry = NULL;\n-  }\n-  return pkg_entry;\n-}\n-\n-InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(\n-                 Symbol* class_name, Handle class_loader, TRAPS) {\n-  assert(UseSharedSpaces, \"must be\");\n-  InstanceKlass* ik = find_builtin_class(class_name);\n-\n-  if (ik != NULL && !ik->shared_loading_failed()) {\n-    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n-        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n-      SharedClassLoadingMark slm(THREAD, ik);\n-      PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n-      Handle protection_domain =\n-        SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);\n-      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {\n-  if (_shared_protection_domains.resolve() == NULL) {\n-    oop spd = oopFactory::new_objArray(\n-        vmClasses::ProtectionDomain_klass(), size, CHECK);\n-    _shared_protection_domains = OopHandle(Universe::vm_global(), spd);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {\n-  if (_shared_jar_urls.resolve() == NULL) {\n-    oop sju = oopFactory::new_objArray(\n-        vmClasses::URL_klass(), size, CHECK);\n-    _shared_jar_urls = OopHandle(Universe::vm_global(), sju);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {\n-  if (_shared_jar_manifests.resolve() == NULL) {\n-    oop sjm = oopFactory::new_objArray(\n-        vmClasses::Jar_Manifest_klass(), size, CHECK);\n-    _shared_jar_manifests = OopHandle(Universe::vm_global(), sjm);\n-  }\n-}\n-\n-void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {\n-  allocate_shared_protection_domain_array(size, CHECK);\n-  allocate_shared_jar_url_array(size, CHECK);\n-  allocate_shared_jar_manifest_array(size, CHECK);\n-}\n-\n-\/\/ This function is called for loading only UNREGISTERED classes\n-InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,\n-                                                          Handle class_loader,\n-                                                          Handle protection_domain,\n-                                                          const ClassFileStream* cfs,\n-                                                          TRAPS) {\n-  if (!UseSharedSpaces) {\n-    return NULL;\n-  }\n-  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n-    return NULL;\n-  }\n-  if (class_loader.is_null() ||\n-      SystemDictionary::is_system_class_loader(class_loader()) ||\n-      SystemDictionary::is_platform_class_loader(class_loader())) {\n-    \/\/ Do nothing for the BUILTIN loaders.\n-    return NULL;\n-  }\n-\n-  const RunTimeSharedClassInfo* record = find_record(&_unregistered_dictionary, &_dynamic_unregistered_dictionary, class_name);\n-  if (record == NULL) {\n-    return NULL;\n-  }\n-\n-  int clsfile_size  = cfs->length();\n-  int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs->buffer(), cfs->length());\n-\n-  if (!record->matches(clsfile_size, clsfile_crc32)) {\n-    return NULL;\n-  }\n-\n-  return acquire_class_for_current_thread(record->_klass, class_loader,\n-                                          protection_domain, cfs,\n-                                          THREAD);\n-}\n-\n-InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(\n-                   InstanceKlass *ik,\n-                   Handle class_loader,\n-                   Handle protection_domain,\n-                   const ClassFileStream *cfs,\n-                   TRAPS) {\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n-\n-  {\n-    MutexLocker mu(THREAD, SharedDictionary_lock);\n-    if (ik->class_loader_data() != NULL) {\n-      \/\/    ik is already loaded (by this loader or by a different loader)\n-      \/\/ or ik is being loaded by a different thread (by this loader or by a different loader)\n-      return NULL;\n-    }\n-\n-    \/\/ No other thread has acquired this yet, so give it to *this thread*\n-    ik->set_class_loader_data(loader_data);\n-  }\n-\n-  \/\/ No longer holding SharedDictionary_lock\n-  \/\/ No need to lock, as <ik> can be held only by a single thread.\n-  loader_data->add_class(ik);\n-\n-  \/\/ Get the package entry.\n-  PackageEntry* pkg_entry = get_package_entry_from_class(ik, class_loader);\n-\n-  \/\/ Load and check super\/interfaces, restore unsharable info\n-  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n-                                                  cfs, pkg_entry, THREAD);\n-  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n-    \/\/ TODO: clean up <ik> so it can be used again\n-    return NULL;\n+      if (k != NULL) {\n+        SharedClassLoadingMark slm(THREAD, k);\n+        k = find_or_define_instance_class(name, class_loader, k, CHECK_NULL);\n+      }\n+    }\n@@ -1164,2 +422,1 @@\n-\n-  return shared_klass;\n+  return k;\n@@ -1168,2 +425,2 @@\n-class LoadedUnregisteredClassesTable : public ResourceHashtable<\n-  Symbol*, bool,\n+class UnregisteredClassesTable : public ResourceHashtable<\n+  Symbol*, InstanceKlass*,\n@@ -1172,1 +429,1 @@\n-  6661,                             \/\/ prime number\n+  15889, \/\/ prime number\n@@ -1175,1 +432,1 @@\n-static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n@@ -1177,6 +434,9 @@\n-bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* k) {\n-  \/\/ We don't allow duplicated unregistered classes of the same name.\n-  assert(DumpSharedSpaces, \"only when dumping\");\n-  Symbol* name = k->name();\n-  if (_loaded_unregistered_classes == NULL) {\n-    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* klass) {\n+  \/\/ We don't allow duplicated unregistered classes with the same name.\n+  \/\/ We only archive the first class with that name that succeeds putting\n+  \/\/ itself into the table.\n+  Arguments::assert_is_dumping_archive();\n+  MutexLocker ml(current, UnregisteredClassesTable_lock);\n+  Symbol* name = klass->name();\n+  if (_unregistered_classes_table == NULL) {\n+    _unregistered_classes_table = new (ResourceObj::C_HEAP, mtClass)UnregisteredClassesTable();\n@@ -1184,2 +444,2 @@\n-  bool created = false;\n-  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n+  bool created;\n+  InstanceKlass** v = _unregistered_classes_table->put_if_absent(name, klass, &created);\n@@ -1187,0 +447,9 @@\n+    name->increment_refcount();\n+  }\n+  return (klass == *v);\n+}\n+\n+\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n+bool SystemDictionaryShared::add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k) {\n+  assert(DumpSharedSpaces, \"only when dumping\");\n+  if (add_unregistered_class(current, k)) {\n@@ -1189,0 +458,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -1190,1 +462,0 @@\n-  return created;\n@@ -1232,18 +503,0 @@\n-void SystemDictionaryShared::start_dumping() {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  _dump_in_progress = true;\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-  return find_or_allocate_info_for_locked(k);\n-}\n-\n-DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n-  assert_lock_strong(DumpTimeTable_lock);\n-  if (_dumptime_table == NULL) {\n-    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n-  }\n-  return _dumptime_table->find_or_allocate_info_for(k, _dump_in_progress);\n-}\n-\n@@ -1253,1 +506,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1266,1 +519,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(k);\n+  DumpTimeClassInfo* p = _dumptime_table->get(k);\n@@ -1272,1 +525,1 @@\n-      DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n+      DumpTimeClassInfo::DTVerifierConstraint constraint = p->_verifier_constraints->at(i);\n@@ -1280,1 +533,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTVerifierConstraint, p->_verifier_constraints);\n@@ -1287,1 +540,1 @@\n-      DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n+      DumpTimeClassInfo::DTLoaderConstraint ld =  p->_loader_constraints->at(i);\n@@ -1292,1 +545,1 @@\n-    FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p->_loader_constraints);\n+    FREE_C_HEAP_ARRAY(DumpTimeClassInfo::DTLoaderConstraint, p->_loader_constraints);\n@@ -1298,48 +551,2 @@\n-bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {\n-  while (k) {\n-    if (k->name()->equals(\"jdk\/internal\/event\/Event\")) {\n-      return true;\n-    }\n-    k = k->java_super();\n-  }\n-  return false;\n-}\n-\n-bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n-}\n-\n-bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {\n-  assert(ik->is_shared(), \"applicable to only a shared class\");\n-  if (ik->is_hidden()) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool SystemDictionaryShared::is_early_klass(InstanceKlass* ik) {\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(ik);\n-  return (info != NULL) ? info->is_early_klass() : false;\n-}\n-\n-\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n-bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n-  ResourceMark rm;\n-  log_warning(cds)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n-  return true;\n-}\n-\n-bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info) {\n-  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n-    \/\/ We have reached a super type that's already in the base archive. Treat it\n-    \/\/ as \"not excluded\".\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n-    return false;\n-  }\n-\n-  if (info == NULL) {\n-    info = _dumptime_table->get(k);\n-    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n-  }\n+void SystemDictionaryShared::handle_class_unloading(InstanceKlass* klass) {\n+  remove_dumptime_info(klass);\n@@ -1347,3 +554,8 @@\n-  if (!info->has_checked_exclusion()) {\n-    if (check_for_exclusion_impl(k)) {\n-      info->set_excluded();\n+  if (_unregistered_classes_table != NULL) {\n+    \/\/ Remove the class from _unregistered_classes_table: keep the entry but\n+    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ added again.\n+    MutexLocker ml(Thread::current(), UnregisteredClassesTable_lock);\n+    InstanceKlass** v = _unregistered_classes_table->get(klass->name());\n+    if (v != NULL) {\n+      *v = NULL;\n@@ -1351,1 +563,0 @@\n-    info->set_has_checked_exclusion();\n@@ -1353,2 +564,0 @@\n-\n-  return info->is_excluded();\n@@ -1375,83 +584,0 @@\n-bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n-  if (k->is_in_error_state()) {\n-    return warn_excluded(k, \"In error state\");\n-  }\n-  if (has_been_redefined(k)) {\n-    return warn_excluded(k, \"Has been redefined\");\n-  }\n-  if (!k->is_hidden() && k->shared_classpath_index() < 0 && is_builtin(k)) {\n-    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n-    \/\/ agent during dump time).\n-    return warn_excluded(k, \"Unsupported location\");\n-  }\n-  if (k->signers() != NULL) {\n-    \/\/ We cannot include signed classes in the archive because the certificates\n-    \/\/ used during dump time may be different than those used during\n-    \/\/ runtime (due to expiration, etc).\n-    return warn_excluded(k, \"Signed JAR\");\n-  }\n-  if (is_jfr_event_class(k)) {\n-    \/\/ We cannot include JFR event classes because they need runtime-specific\n-    \/\/ instrumentation in order to work with -XX:FlightRecorderOptions:retransform=false.\n-    \/\/ There are only a small number of these classes, so it's not worthwhile to\n-    \/\/ support them and make CDS more complicated.\n-    return warn_excluded(k, \"JFR event class\");\n-  }\n-  if (k->init_state() < InstanceKlass::linked) {\n-    \/\/ In CDS dumping, we will attempt to link all classes. Those that fail to link will\n-    \/\/ be recorded in DumpTimeSharedClassInfo.\n-    Arguments::assert_is_dumping_archive();\n-\n-    \/\/ TODO -- rethink how this can be handled.\n-    \/\/ We should try to link ik, however, we can't do it here because\n-    \/\/ 1. We are at VM exit\n-    \/\/ 2. linking a class may cause other classes to be loaded, which means\n-    \/\/    a custom ClassLoader.loadClass() may be called, at a point where the\n-    \/\/    class loader doesn't expect it.\n-    if (has_class_failed_verification(k)) {\n-      return warn_excluded(k, \"Failed verification\");\n-    } else {\n-      if (k->can_be_verified_at_dumptime()) {\n-        return warn_excluded(k, \"Not linked\");\n-      }\n-    }\n-  }\n-  if (DynamicDumpSharedSpaces && k->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n-    \/\/ In order to support old classes during dynamic dump, class rewriting needs to\n-    \/\/ be reverted. This would result in more complex code and testing but not much gain.\n-    ResourceMark rm;\n-    log_warning(cds)(\"Pre JDK 6 class not supported by CDS: %u.%u %s\",\n-                     k->major_version(),  k->minor_version(), k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  if (!k->can_be_verified_at_dumptime() && k->is_linked()) {\n-    return warn_excluded(k, \"Old class has been linked\");\n-  }\n-\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n-    return true;\n-  }\n-\n-  InstanceKlass* super = k->java_super();\n-  if (super != NULL && check_for_exclusion(super, NULL)) {\n-    ResourceMark rm;\n-    log_warning(cds)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n-    return true;\n-  }\n-\n-  Array<InstanceKlass*>* interfaces = k->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    InstanceKlass* intf = interfaces->at(i);\n-    if (check_for_exclusion(intf, NULL)) {\n-      log_warning(cds)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n-      return true;\n-    }\n-  }\n-\n-  return false; \/\/ false == k should NOT be excluded\n-}\n-\n@@ -1462,1 +588,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(k);\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n@@ -1479,0 +605,42 @@\n+class UnregisteredClassesDuplicationChecker : StackObj {\n+  GrowableArray<InstanceKlass*> _list;\n+  Thread* _thread;\n+public:\n+  UnregisteredClassesDuplicationChecker() : _thread(Thread::current()) {}\n+\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!SystemDictionaryShared::is_builtin(k)) {\n+      _list.append(k);\n+    }\n+    return true;  \/\/ keep on iterating\n+  }\n+\n+  static int compare_by_loader(InstanceKlass** a, InstanceKlass** b) {\n+    ClassLoaderData* loader_a = a[0]->class_loader_data();\n+    ClassLoaderData* loader_b = b[0]->class_loader_data();\n+\n+    if (loader_a != loader_b) {\n+      return intx(loader_a) - intx(loader_b);\n+    } else {\n+      return intx(a[0]) - intx(b[0]);\n+    }\n+  }\n+\n+  void mark_duplicated_classes() {\n+    \/\/ Two loaders may load two identical or similar hierarchies of classes. If we\n+    \/\/ check for duplication in random order, we may end up excluding important base classes\n+    \/\/ in both hierarchies, causing most of the classes to be excluded.\n+    \/\/ We sort the classes by their loaders. This way we're likely to archive\n+    \/\/ all classes in the one of the two hierarchies.\n+    _list.sort(compare_by_loader);\n+    for (int i = 0; i < _list.length(); i++) {\n+      InstanceKlass* k = _list.at(i);\n+      bool i_am_first = SystemDictionaryShared::add_unregistered_class(_thread, k);\n+      if (!i_am_first) {\n+        SystemDictionaryShared::warn_excluded(k, \"Duplicated unregistered class\");\n+        SystemDictionaryShared::set_excluded_locked(k);\n+      }\n+    }\n+  }\n+};\n+\n@@ -1481,1 +649,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1490,0 +658,10 @@\n+\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Do this first -- if a base class is excluded due to duplication,\n+    \/\/ all of its subclasses will also be excluded by ExcludeDumpTimeSharedClasses\n+    ResourceMark rm;\n+    UnregisteredClassesDuplicationChecker dup_checker;\n+    _dumptime_table->iterate(&dup_checker);\n+    dup_checker.mark_duplicated_classes();\n+  }\n+\n@@ -1499,1 +677,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for_locked(k);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for_locked(k);\n@@ -1503,0 +681,9 @@\n+void SystemDictionaryShared::set_excluded_locked(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeClassInfo* info = find_or_allocate_info_for_locked(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n@@ -1505,1 +692,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1513,1 +700,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for(ik);\n+  DumpTimeClassInfo* p = find_or_allocate_info_for(ik);\n@@ -1526,1 +713,1 @@\n-  DumpTimeSharedClassInfo* p = _dumptime_table->get(ik);\n+  DumpTimeClassInfo* p = _dumptime_table->get(ik);\n@@ -1535,1 +722,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -1572,1 +759,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -1598,14 +785,6 @@\n-void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {\n-  if (_verifier_constraints == NULL) {\n-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n-  }\n-  if (_verifier_constraint_flags == NULL) {\n-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n-  }\n-  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n-  for (int i = 0; i < vc_array->length(); i++) {\n-    DTVerifierConstraint* p = vc_array->adr_at(i);\n-    if (name == p->_name && from_name == p->_from_name) {\n-      return;\n-    }\n+void SystemDictionaryShared::add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                           InstanceKlass* proxy_klass) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  if (_dumptime_lambda_proxy_class_dictionary == NULL) {\n+    _dumptime_lambda_proxy_class_dictionary =\n+      new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n@@ -1613,15 +792,10 @@\n-  DTVerifierConstraint cons(name, from_name);\n-  vc_array->append(cons);\n-\n-  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n-  char c = 0;\n-  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n-  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n-  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n-  vcflags_array->append(c);\n-\n-  if (log_is_enabled(Trace, cds, verification)) {\n-    ResourceMark rm;\n-    log_trace(cds, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+  DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+  if (lambda_info == NULL) {\n+    DumpTimeLambdaProxyClassInfo info;\n+    info.add_proxy_klass(proxy_klass);\n+    _dumptime_lambda_proxy_class_dictionary->put(key, info);\n+    \/\/lambda_info = _dumptime_lambda_proxy_class_dictionary->get(key);\n+    \/\/assert(lambda_info->_proxy_klass == proxy_klass, \"must be\"); \/\/ debug only -- remove\n+    ++_dumptime_lambda_proxy_class_dictionary->_count;\n+  } else {\n+    lambda_info->add_proxy_klass(proxy_klass);\n@@ -1651,1 +825,1 @@\n-  DumpTimeSharedClassInfo* info = _dumptime_table->get(lambda_ik);\n+  DumpTimeClassInfo* info = _dumptime_table->get(lambda_ik);\n@@ -1655,1 +829,1 @@\n-    \/\/ Set _is_archived_lambda_proxy in DumpTimeSharedClassInfo so that the lambda_ik\n+    \/\/ Set _is_archived_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n@@ -1716,1 +890,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(lambda_ik);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(lambda_ik);\n@@ -1726,1 +900,1 @@\n-    protection_domain = SystemDictionaryShared::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n+    protection_domain = CDSProtectionDomain::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);\n@@ -1766,58 +940,0 @@\n-static char get_loader_type_by(oop  loader) {\n-  assert(SystemDictionary::is_builtin_class_loader(loader), \"Must be built-in loader\");\n-  if (SystemDictionary::is_boot_class_loader(loader)) {\n-    return (char)ClassLoader::BOOT_LOADER;\n-  } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-    return (char)ClassLoader::PLATFORM_LOADER;\n-  } else {\n-    assert(SystemDictionary::is_system_class_loader(loader), \"Class loader mismatch\");\n-    return (char)ClassLoader::APP_LOADER;\n-  }\n-}\n-\n-static oop get_class_loader_by(char type) {\n-  if (type == (char)ClassLoader::BOOT_LOADER) {\n-    return (oop)NULL;\n-  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n-    return SystemDictionary::java_platform_loader();\n-  } else {\n-    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n-    return SystemDictionary::java_system_loader();\n-  }\n-}\n-\n-void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {\n-  assert(loader1 != loader2, \"sanity\");\n-  LogTarget(Info, class, loader, constraints) log;\n-  if (_loader_constraints == NULL) {\n-    _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n-  }\n-  char lt1 = get_loader_type_by(loader1());\n-  char lt2 = get_loader_type_by(loader2());\n-  DTLoaderConstraint lc(name, lt1, lt2);\n-  for (int i = 0; i < _loader_constraints->length(); i++) {\n-    DTLoaderConstraint dt = _loader_constraints->at(i);\n-    if (lc.equals(dt)) {\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-        log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]\",\n-                  _klass->external_name(), name->as_C_string(),\n-                  ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-                  ClassLoaderData::class_loader_data(loader2())->loader_name_and_id());\n-      }\n-      return;\n-    }\n-  }\n-  _loader_constraints->append(lc);\n-  if (log.is_enabled()) {\n-    ResourceMark rm;\n-    \/\/ Use loader[0]\/loader[1] to be consistent with the logs in loaderConstraints.cpp\n-    log.print(\"[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]\",\n-              _klass->external_name(), name->as_C_string(),\n-              ClassLoaderData::class_loader_data(loader1())->loader_name_and_id(),\n-              ClassLoaderData::class_loader_data(loader2())->loader_name_and_id(),\n-              _loader_constraints->length());\n-  }\n-}\n-\n@@ -1827,1 +943,1 @@\n-  RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);\n+  RunTimeClassInfo* record = RunTimeClassInfo::get_for(klass);\n@@ -1832,1 +948,1 @@\n-      RunTimeSharedClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n+      RunTimeClassInfo::RTVerifierConstraint* vc = record->verifier_constraint_at(i);\n@@ -1865,0 +981,11 @@\n+static oop get_class_loader_by(char type) {\n+  if (type == (char)ClassLoader::BOOT_LOADER) {\n+    return (oop)NULL;\n+  } else if (type == (char)ClassLoader::PLATFORM_LOADER) {\n+    return SystemDictionary::java_platform_loader();\n+  } else {\n+    assert (type == (char)ClassLoader::APP_LOADER, \"Sanity\");\n+    return SystemDictionary::java_system_loader();\n+  }\n+}\n+\n@@ -1925,1 +1052,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(klass);\n@@ -1941,1 +1068,1 @@\n-    RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);\n+    RunTimeClassInfo* info = RunTimeClassInfo::get_for(klass);\n@@ -1946,1 +1073,1 @@\n-        RunTimeSharedClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n+        RunTimeClassInfo::RTLoaderConstraint* lc = info->loader_constraint_at(i);\n@@ -2037,1 +1164,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2039,1 +1166,1 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n@@ -2146,1 +1273,1 @@\n-  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n@@ -2148,3 +1275,3 @@\n-      size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n-      RunTimeSharedClassInfo* record;\n-      record = (RunTimeSharedClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n+      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      RunTimeClassInfo* record;\n+      record = (RunTimeClassInfo*)ArchiveBuilder::ro_region_alloc(byte_size);\n@@ -2167,2 +1294,2 @@\n-      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeSharedClassInfo*\n-      RunTimeSharedClassInfo::set_for(info._klass, record);\n+      \/\/ Save this for quick runtime lookup of InstanceKlass* -> RunTimeClassInfo*\n+      RunTimeClassInfo::set_for(info._klass, record);\n@@ -2240,1 +1367,1 @@\n-const RunTimeSharedClassInfo*\n+const RunTimeClassInfo*\n@@ -2248,1 +1375,1 @@\n-  const RunTimeSharedClassInfo* record = NULL;\n+  const RunTimeClassInfo* record = NULL;\n@@ -2276,1 +1403,1 @@\n-  const RunTimeSharedClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n+  const RunTimeClassInfo* record = find_record(&_builtin_dictionary, &_dynamic_builtin_dictionary, name);\n@@ -2288,1 +1415,1 @@\n-  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  DumpTimeClassInfo* info = find_or_allocate_info_for(k);\n@@ -2316,1 +1443,1 @@\n-  void do_value(const RunTimeSharedClassInfo* record) {\n+  void do_value(const RunTimeClassInfo* record) {\n@@ -2397,1 +1524,1 @@\n-bool SystemDictionaryShared::empty_dumptime_table() {\n+bool SystemDictionaryShared::is_dumptime_table_empty() {\n@@ -2408,0 +1535,71 @@\n+class CloneDumpTimeClassTable: public StackObj {\n+  DumpTimeSharedClassTable* _table;\n+  DumpTimeSharedClassTable* _cloned_table;\n+ public:\n+  CloneDumpTimeClassTable(DumpTimeSharedClassTable* table, DumpTimeSharedClassTable* clone) :\n+                      _table(table), _cloned_table(clone) {\n+    assert(_table != NULL, \"_dumptime_table is NULL\");\n+    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+  }\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      bool created;\n+      _cloned_table->put_if_absent(k, info.clone(), &created);\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+class CloneDumpTimeLambdaProxyClassTable: StackObj {\n+  DumpTimeLambdaProxyClassDictionary* _table;\n+  DumpTimeLambdaProxyClassDictionary* _cloned_table;\n+ public:\n+  CloneDumpTimeLambdaProxyClassTable(DumpTimeLambdaProxyClassDictionary* table,\n+                                     DumpTimeLambdaProxyClassDictionary* clone) :\n+                      _table(table), _cloned_table(clone) {\n+    assert(_table != NULL, \"_dumptime_table is NULL\");\n+    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+  }\n+\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    assert_lock_strong(DumpTimeTable_lock);\n+    bool created;\n+    \/\/ make copies then store in _clone_table\n+    LambdaProxyClassKey keyCopy = key;\n+    _cloned_table->put_if_absent(keyCopy, info.clone(), &created);\n+    ++ _cloned_table->_count;\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void SystemDictionaryShared::clone_dumptime_tables() {\n+  Arguments::assert_is_dumping_archive();\n+  assert_lock_strong(DumpTimeTable_lock);\n+  if (_dumptime_table != NULL) {\n+    assert(_cloned_dumptime_table == NULL, \"_cloned_dumptime_table must be cleaned\");\n+    _cloned_dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n+    CloneDumpTimeClassTable copy_classes(_dumptime_table, _cloned_dumptime_table);\n+    _dumptime_table->iterate(&copy_classes);\n+    _cloned_dumptime_table->update_counts();\n+  }\n+  if (_dumptime_lambda_proxy_class_dictionary != NULL) {\n+    assert(_cloned_dumptime_lambda_proxy_class_dictionary == NULL,\n+           \"_cloned_dumptime_lambda_proxy_class_dictionary must be cleaned\");\n+    _cloned_dumptime_lambda_proxy_class_dictionary =\n+                                          new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n+    CloneDumpTimeLambdaProxyClassTable copy_proxy_classes(_dumptime_lambda_proxy_class_dictionary,\n+                                                          _cloned_dumptime_lambda_proxy_class_dictionary);\n+    _dumptime_lambda_proxy_class_dictionary->iterate(&copy_proxy_classes);\n+  }\n+}\n+\n+void SystemDictionaryShared::restore_dumptime_tables() {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  delete _dumptime_table;\n+  _dumptime_table = _cloned_dumptime_table;\n+  _cloned_dumptime_table = NULL;\n+  delete _dumptime_lambda_proxy_class_dictionary;\n+  _dumptime_lambda_proxy_class_dictionary = _cloned_dumptime_lambda_proxy_class_dictionary;\n+  _cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+}\n+\n@@ -2429,1 +1627,1 @@\n-  void do_value(const RunTimeSharedClassInfo* info) {\n+  void do_value(const RunTimeClassInfo* info) {\n@@ -2459,1 +1657,1 @@\n-  if (!HeapShared::open_archive_heap_region_mapped()) {\n+  if (!HeapShared::open_regions_mapped()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":435,"deletions":1237,"binary":false,"changes":1672,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -109,1 +112,1 @@\n-class DumpTimeSharedClassInfo;\n+class DumpTimeClassInfo;\n@@ -112,1 +115,1 @@\n-class RunTimeSharedClassInfo;\n+class RunTimeClassInfo;\n@@ -114,0 +117,2 @@\n+class DumpTimeLambdaProxyClassDictionary;\n+class LambdaProxyClassKey;\n@@ -142,7 +147,13 @@\n-  \/\/ These _shared_xxxs arrays are used to initialize the java.lang.Package and\n-  \/\/ java.security.ProtectionDomain objects associated with each shared class.\n-  \/\/\n-  \/\/ See SystemDictionaryShared::init_security_info for more info.\n-  static OopHandle _shared_protection_domains;\n-  static OopHandle _shared_jar_urls;\n-  static OopHandle _shared_jar_manifests;\n+\n+  static DumpTimeSharedClassTable* _dumptime_table;\n+  static DumpTimeSharedClassTable* _cloned_dumptime_table;\n+  static DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary;\n+  static DumpTimeLambdaProxyClassDictionary* _cloned_dumptime_lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the base layer static archive\n+  static RunTimeSharedDictionary _builtin_dictionary;\n+  static RunTimeSharedDictionary _unregistered_dictionary;\n+  static LambdaProxyClassDictionary _lambda_proxy_class_dictionary;\n+  \/\/ SystemDictionaries in the top layer dynamic archive\n+  static RunTimeSharedDictionary _dynamic_builtin_dictionary;\n+  static RunTimeSharedDictionary _dynamic_unregistered_dictionary;\n+  static LambdaProxyClassDictionary _dynamic_lambda_proxy_class_dictionary;\n@@ -154,66 +165,0 @@\n-  static Handle get_package_name(Symbol*  class_name, TRAPS);\n-\n-  static PackageEntry* get_package_entry_from_class(InstanceKlass* ik, Handle class_loader);\n-\n-\n-  \/\/ Package handling:\n-  \/\/\n-  \/\/ 1. For named modules in the runtime image\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces\n-  \/\/                  to get packages in named modules for shared classes.\n-  \/\/                  Package for non-shared classes in named module is also\n-  \/\/                  handled using JVM_GetSystemPackage(s).\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared app classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/    PLATFORM  classes: VM calls ClassLoaders.PlatformClassLoader::definePackage(String, Module)\n-  \/\/                  to define package for shared platform classes from named\n-  \/\/                  modules.\n-  \/\/\n-  \/\/ 2. For unnamed modules\n-  \/\/    BOOT classes: Reuses the existing JVM_GetSystemPackage(s) interfaces to\n-  \/\/                  get packages for shared boot classes in unnamed modules.\n-  \/\/\n-  \/\/    APP  classes: VM calls ClassLoaders.AppClassLoader::defineOrCheckPackage()\n-  \/\/                  with with the manifest and url from archived data.\n-  \/\/\n-  \/\/    PLATFORM  classes: No package is defined.\n-  \/\/\n-  \/\/ The following two define_shared_package() functions are used to define\n-  \/\/ package for shared APP and PLATFORM classes.\n-  static void define_shared_package(Symbol*  class_name,\n-                                    Handle class_loader,\n-                                    Handle manifest,\n-                                    Handle url,\n-                                    TRAPS);\n-\n-  static Handle get_shared_jar_manifest(int shared_path_index, TRAPS);\n-  static Handle get_shared_jar_url(int shared_path_index, TRAPS);\n-  static Handle get_protection_domain_from_classloader(Handle class_loader,\n-                                                       Handle url, TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             int shared_path_index,\n-                                             Handle url,\n-                                             TRAPS);\n-  static Handle get_shared_protection_domain(Handle class_loader,\n-                                             ModuleEntry* mod, TRAPS);\n-\n-  static void atomic_set_array_index(OopHandle array, int index, oop o);\n-\n-  static oop shared_protection_domain(int index);\n-  static void atomic_set_shared_protection_domain(int index, oop pd) {\n-    atomic_set_array_index(_shared_protection_domains, index, pd);\n-  }\n-  static void allocate_shared_protection_domain_array(int size, TRAPS);\n-  static oop shared_jar_url(int index);\n-  static void atomic_set_shared_jar_url(int index, oop url) {\n-    atomic_set_array_index(_shared_jar_urls, index, url);\n-  }\n-  static void allocate_shared_jar_url_array(int size, TRAPS);\n-  static oop shared_jar_manifest(int index);\n-  static void atomic_set_shared_jar_manifest(int index, oop man) {\n-    atomic_set_array_index(_shared_jar_manifests, index, man);\n-  }\n-  static void allocate_shared_jar_manifest_array(int size, TRAPS);\n@@ -226,2 +171,2 @@\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n-  static DumpTimeSharedClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for(InstanceKlass* k);\n+  static DumpTimeClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n@@ -233,1 +178,0 @@\n-  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -235,0 +179,1 @@\n+  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -248,1 +193,0 @@\n-  static Handle init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS);\n@@ -251,1 +195,1 @@\n-  static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n+  static const RunTimeClassInfo* find_record(RunTimeSharedDictionary* static_dict,\n@@ -268,1 +212,1 @@\n-  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n+  static bool add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k);\n@@ -273,1 +217,1 @@\n-  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n+  static void handle_class_unloading(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -310,0 +254,2 @@\n+  static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey& key,\n+                                                             InstanceKlass* proxy_klass) NOT_CDS_RETURN;\n@@ -325,0 +271,11 @@\n+  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n+\n+  \/\/ For repeatable dumping, we\n+  \/\/   1. clone DumpTimeSharedClassTable, same for DumpTimeLambdaProxyClassDictionary\n+  \/\/      clone SharedClassPathTable\n+  \/\/   2. do dumping\n+  \/\/   3. restore DumpTimeSharedClassTable, DumpTimeLambdaProxyClassDictionary and SharedClassPathTable\n+  \/\/      from cloned versions.\n+  static void clone_dumptime_tables();\n+  static void restore_dumptime_tables();\n+\n@@ -326,1 +283,1 @@\n-  static bool check_for_exclusion(InstanceKlass* k, DumpTimeSharedClassInfo* info);\n+  static bool check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n@@ -330,0 +287,2 @@\n+  static void set_excluded_locked(InstanceKlass* k);\n+  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -341,1 +300,1 @@\n-  static bool empty_dumptime_table() NOT_CDS_RETURN_(true);\n+  static bool is_dumptime_table_empty() NOT_CDS_RETURN_(true);\n@@ -343,1 +302,0 @@\n-  static Handle create_jar_manifest(const char* man, size_t size, TRAPS) NOT_CDS_RETURN_(Handle());\n@@ -345,1 +303,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":43,"deletions":86,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    \/\/ HeapShared::fixup_mapped_heap_regions() fills the empty\n+    \/\/ HeapShared::fixup_mapped_regions() fills the empty\n@@ -142,1 +142,1 @@\n-    HeapShared::fixup_mapped_heap_regions();\n+    HeapShared::fixup_mapped_regions();\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n@@ -470,5 +471,0 @@\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n@@ -460,1 +456,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -485,0 +486,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1080,6 +1080,0 @@\n-\/\/ Just marks the methods in this class as needing deoptimization\n-void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-}\n-\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  static void mark_for_evol_deoptimization(InstanceKlass* dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    return thread->as_Java_thread()->thread_state() == _thread_in_vm;\n+    return JavaThread::cast(thread)->thread_state() == _thread_in_vm;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1611,0 +1611,2 @@\n+    \/\/ Ensure the sweeper can't collect this nmethod until it become \"active\" with JvmtiThreadState::nmethods_do.\n+    mark_as_seen_on_stack();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,2 +272,1 @@\n-  \/\/ locate the owner and stack slot for the BasicLock so that we can\n-  \/\/ properly revoke the bias of the owner if necessary. They are\n+  \/\/ locate the owner and stack slot for the BasicLock. They are\n@@ -278,5 +277,2 @@\n-  \/\/ sharing between platforms. Note that currently biased locking\n-  \/\/ will never cause Class instances to be biased but this code\n-  \/\/ handles the static synchronized case as well.\n-  \/\/ JVMTI's GetLocalInstance() also uses these offsets to find the receiver\n-  \/\/ for non-static native wrapper frames.\n+  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+  \/\/ offsets to find the receiver for non-static native wrapper frames.\n@@ -739,1 +735,1 @@\n-  \/\/ UseBiasedLocking support\n+  \/\/ JVMTI's GetLocalInstance() support\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+volatile jint CompileBroker::_native_compilation_id = 0;\n@@ -798,8 +799,2 @@\n-  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n-  Handle thread_group(THREAD, Universe::system_thread_group());\n-  return JavaCalls::construct_new_instance(\n-                       vmClasses::Thread_klass(),\n-                       vmSymbols::threadgroup_string_void_signature(),\n-                       thread_group,\n-                       string,\n-                       CHECK_NH);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK_NH);\n+  return thread_oop;\n@@ -878,13 +873,12 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    switch (type) {\n-      case compiler_t:\n-        assert(comp != NULL, \"Compiler instance missing.\");\n-        if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n-          CompilerCounters* counters = new CompilerCounters();\n-          new_thread = new CompilerThread(queue, counters);\n-        }\n-        break;\n-      case sweeper_t:\n-        new_thread = new CodeCacheSweeperThread();\n-        break;\n+\n+  switch (type) {\n+    case compiler_t:\n+      assert(comp != NULL, \"Compiler instance missing.\");\n+      if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n+        CompilerCounters* counters = new CompilerCounters();\n+        new_thread = new CompilerThread(queue, counters);\n+      }\n+      break;\n+    case sweeper_t:\n+      new_thread = new CodeCacheSweeperThread();\n+      break;\n@@ -892,3 +886,3 @@\n-      case deoptimizer_t:\n-        new_thread = new DeoptimizeObjectsALotThread();\n-        break;\n+    case deoptimizer_t:\n+      new_thread = new DeoptimizeObjectsALotThread();\n+      break;\n@@ -896,20 +890,3 @@\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ At this point the new CompilerThread data-races with this startup\n-    \/\/ thread (which I believe is the primoridal thread and NOT the VM\n-    \/\/ thread).  This means Java bytecodes being executed at startup can\n-    \/\/ queue compile jobs which will run at whatever default priority the\n-    \/\/ newly created CompilerThread runs at.\n-\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails. But first release the\n-    \/\/ lock.\n-\n-    if (new_thread != NULL && new_thread->osthread() != NULL) {\n-\n-      java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), new_thread);\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -917,3 +894,5 @@\n-      \/\/ Note that this only sets the JavaThread _priority field, which by\n-      \/\/ definition is limited to Java priorities and not OS priorities.\n-      \/\/ The os-priority is set in the CompilerThread startup code itself\n+  \/\/ At this point the new CompilerThread data-races with this startup\n+  \/\/ thread (which is the main thread and NOT the VM thread).\n+  \/\/ This means Java bytecodes being executed at startup can\n+  \/\/ queue compile jobs which will run at whatever default priority the\n+  \/\/ newly created CompilerThread runs at.\n@@ -921,1 +900,0 @@\n-      java_lang_Thread::set_priority(JNIHandles::resolve_non_null(thread_handle), NearMaxPriority);\n@@ -923,4 +901,5 @@\n-      \/\/ Note that we cannot call os::set_priority because it expects Java\n-      \/\/ priorities and we are *explicitly* using OS priorities so that it's\n-      \/\/ possible to set the compiler thread priority higher than any Java\n-      \/\/ thread.\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. We will handle that failure below.\n+  \/\/ Also check new_thread so that static analysis is happy.\n+  if (new_thread != NULL && new_thread->osthread() != NULL) {\n+    Handle thread_oop(THREAD, JNIHandles::resolve_non_null(thread_handle));\n@@ -928,9 +907,3 @@\n-      int native_prio = CompilerThreadPriority;\n-      if (native_prio == -1) {\n-        if (UseCriticalCompilerThreadPriority) {\n-          native_prio = os::java_to_os_priority[CriticalPriority];\n-        } else {\n-          native_prio = os::java_to_os_priority[NearMaxPriority];\n-        }\n-      }\n-      os::set_native_priority(new_thread, native_prio);\n+    if (type == compiler_t) {\n+      CompilerThread::cast(new_thread)->set_compiler(comp);\n+    }\n@@ -938,1 +911,4 @@\n-      java_lang_Thread::set_daemon(JNIHandles::resolve_non_null(thread_handle));\n+    \/\/ Note that we cannot call os::set_priority because it expects Java\n+    \/\/ priorities and we are *explicitly* using OS priorities so that it's\n+    \/\/ possible to set the compiler thread priority higher than any Java\n+    \/\/ thread.\n@@ -940,3 +916,6 @@\n-      new_thread->set_threadObj(JNIHandles::resolve_non_null(thread_handle));\n-      if (type == compiler_t) {\n-        CompilerThread::cast(new_thread)->set_compiler(comp);\n+    int native_prio = CompilerThreadPriority;\n+    if (native_prio == -1) {\n+      if (UseCriticalCompilerThreadPriority) {\n+        native_prio = os::java_to_os_priority[CriticalPriority];\n+      } else {\n+        native_prio = os::java_to_os_priority[NearMaxPriority];\n@@ -944,2 +923,0 @@\n-      Threads::add(new_thread);\n-      Thread::start(new_thread);\n@@ -947,1 +924,1 @@\n-  }\n+    os::set_native_priority(new_thread, native_prio);\n@@ -949,6 +926,9 @@\n-  \/\/ First release lock before aborting VM.\n-  if (new_thread == NULL || new_thread->osthread() == NULL) {\n-    if (UseDynamicNumberOfCompilerThreads && type == compiler_t && comp->num_compiler_threads() > 0) {\n-      if (new_thread != NULL) {\n-        new_thread->smr_delete();\n-      }\n+    \/\/ Note that this only sets the JavaThread _priority field, which by\n+    \/\/ definition is limited to Java priorities and not OS priorities.\n+    JavaThread::start_internal_daemon(THREAD, new_thread, thread_oop, NearMaxPriority);\n+\n+  } else { \/\/ osthread initialization failure\n+    if (UseDynamicNumberOfCompilerThreads && type == compiler_t\n+        && comp->num_compiler_threads() > 0) {\n+      \/\/ The new thread is not known to Thread-SMR yet so we can just delete.\n+      delete new_thread;\n@@ -956,0 +936,3 @@\n+    } else {\n+      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                    os::native_thread_creation_failed_msg());\n@@ -957,2 +940,0 @@\n-    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                  os::native_thread_creation_failed_msg());\n@@ -961,1 +942,0 @@\n-  \/\/ Let go of Threads_lock before yielding\n@@ -1011,1 +991,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1013,1 +993,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1032,1 +1012,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1034,1 +1014,1 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->get_thread_name());\n+        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n@@ -1119,1 +1099,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1122,1 +1102,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n@@ -1140,1 +1120,1 @@\n-        ThreadsListHandle tlh;  \/\/ get_thread_name() depends on the TLH.\n+        ThreadsListHandle tlh;  \/\/ name() depends on the TLH.\n@@ -1143,1 +1123,1 @@\n-                      ct->get_thread_name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n+                      ct->name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n@@ -1279,1 +1259,1 @@\n-        vframeStream vfst(thread->as_Java_thread());\n+        vframeStream vfst(JavaThread::cast(thread));\n@@ -1612,1 +1592,1 @@\n-    return Atomic::add(&_compilation_id, 1);\n+    return Atomic::add(CICountNative ? &_native_compilation_id : &_compilation_id, 1);\n@@ -2498,0 +2478,2 @@\n+  } else if (CICountNative && method->is_native()) {\n+    last_compile_type = native_compile;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":69,"deletions":87,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  static volatile jint _native_compilation_id;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -344,0 +344,37 @@\n+static bool resolve_inlining_predicate(enum CompileCommand option, const methodHandle& method) {\n+  assert(option == CompileCommand::Inline || option == CompileCommand::DontInline, \"Sanity\");\n+  bool v1 = false;\n+  bool v2 = false;\n+  bool has_inline = CompilerOracle::has_option_value(method, CompileCommand::Inline, v1);\n+  bool has_dnotinline = CompilerOracle::has_option_value(method, CompileCommand::DontInline, v2);\n+  if (has_inline && has_dnotinline) {\n+    if (v1 && v2) {\n+      \/\/ Conflict options detected\n+      \/\/ Find the last one for that method and return the predicate accordingly\n+      \/\/ option_list lists options in reverse order. So the first option we find is the last which was specified.\n+      enum CompileCommand last_one = CompileCommand::Unknown;\n+      TypedMethodOptionMatcher* current = option_list;\n+      while (current != NULL) {\n+        last_one = current->option();\n+        if (last_one == CompileCommand::Inline || last_one == CompileCommand::DontInline) {\n+          if (current->matches(method)) {\n+            return last_one == option;\n+          }\n+        }\n+        current = current->next();\n+      }\n+      ShouldNotReachHere();\n+      return false;\n+    } else {\n+      \/\/ No conflicts\n+      return option == CompileCommand::Inline ? v1 : v2;\n+    }\n+  } else {\n+    if (option == CompileCommand::Inline) {\n+      return has_inline ? v1 : false;\n+    } else {\n+      return has_dnotinline ? v2 : false;\n+    }\n+  }\n+}\n+\n@@ -345,0 +382,5 @@\n+  \/\/ Special handling for Inline and DontInline since conflict options may be specified\n+  if (option == CompileCommand::Inline || option == CompileCommand::DontInline) {\n+    return resolve_inlining_predicate(option, method);\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+  develop(bool, CICountNative, false,                                       \\\n+          \"use a separate counter when assigning ids to native \"            \\\n+          \"compilations\")                                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -687,1 +687,1 @@\n-    st->print_raw(raw, (int) flen);\n+    st->print_raw(raw, flen);\n@@ -758,0 +758,11 @@\n+void* Disassembler::dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st) {\n+  int sz = buflen - offset;\n+  int written = jio_snprintf(&buf[offset], sz, \"%s%s\", hsdis_library_name, os::dll_file_extension());\n+  if (written < sz) { \/\/ written successfully, not truncated.\n+    if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n+    return os::dll_load(buf, ebuf, ebuflen);\n+  } else if (Verbose) {\n+    st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n+  }\n+  return NULL;\n+}\n@@ -807,8 +818,1 @@\n-    if (jvm_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-      strcpy(&buf[jvm_offset], hsdis_library_name);\n-      strcat(&buf[jvm_offset], os::dll_file_extension());\n-      if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-      _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-    } else {\n-      if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-    }\n+    _library = dll_load(buf, sizeof buf, jvm_offset, ebuf, sizeof ebuf, st);\n@@ -817,8 +821,1 @@\n-      if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-        strcpy(&buf[lib_offset], hsdis_library_name);\n-        strcat(&buf[lib_offset], os::dll_file_extension());\n-        if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-        _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-      } else {\n-        if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-      }\n+      _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -832,8 +829,1 @@\n-        if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-          strcpy(&buf[lib_offset], hsdis_library_name);\n-          strcat(&buf[lib_offset], os::dll_file_extension());\n-          if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-          _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-        } else {\n-          if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-        }\n+        _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -844,5 +834,1 @@\n-    \/\/ 4. hsdis-<arch>.so  (using LD_LIBRARY_PATH)\n-    strcpy(&buf[0], hsdis_library_name);\n-    strcat(&buf[0], os::dll_file_extension());\n-    if (Verbose) st->print_cr(\"Trying to load: %s via LD_LIBRARY_PATH or equivalent\", buf);\n-    _library = os::dll_load(buf, ebuf, sizeof ebuf);\n+    _library = dll_load(buf, sizeof buf, 0, ebuf, sizeof ebuf, st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static void* dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -296,2 +296,1 @@\n-  \/\/ Cast away constness:\n-  ((VirtualSpace)_virtual_space).print_on(st);\n+  _virtual_space.print_on(st);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-void G1Allocator::reuse_retained_old_region(G1EvacuationInfo& evacuation_info,\n+void G1Allocator::reuse_retained_old_region(G1EvacuationInfo* evacuation_info,\n@@ -123,1 +123,1 @@\n-    evacuation_info.set_alloc_regions_used_before(retained_region->used());\n+    evacuation_info->set_alloc_regions_used_before(retained_region->used());\n@@ -127,1 +127,1 @@\n-void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo& evacuation_info) {\n+void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo* evacuation_info) {\n@@ -143,1 +143,1 @@\n-void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo& evacuation_info) {\n+void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo* evacuation_info) {\n@@ -149,2 +149,2 @@\n-  evacuation_info.set_allocation_regions(survivor_region_count +\n-                                         old_gc_alloc_region()->count());\n+  evacuation_info->set_allocation_regions(survivor_region_count +\n+                                          old_gc_alloc_region()->count());\n@@ -432,1 +432,1 @@\n-  _g1h->g1mm()->update_sizes();\n+  _g1h->monitoring_support()->update_sizes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  void reuse_retained_old_region(G1EvacuationInfo& evacuation_info,\n+  void reuse_retained_old_region(G1EvacuationInfo* evacuation_info,\n@@ -108,2 +108,2 @@\n-  void init_gc_alloc_regions(G1EvacuationInfo& evacuation_info);\n-  void release_gc_alloc_regions(G1EvacuationInfo& evacuation_info);\n+  void init_gc_alloc_regions(G1EvacuationInfo* evacuation_info);\n+  void release_gc_alloc_regions(G1EvacuationInfo* evacuation_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -53,2 +55,6 @@\n-  \/\/ The remembered set needs the heap regions set up.\n-  HeapRegionRemSet::setup_remset_size();\n+  SpaceAlignment = HeapRegion::GrainBytes;\n+  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n+\n+  \/\/ We need to initialize card set configuration as soon as heap region size is\n+  \/\/ known as it depends on it and is used really early.\n+  initialize_card_set_configuration();\n@@ -58,1 +64,1 @@\n-    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RSetSparseRegionEntries);\n+    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RemSetArrayOfCardsEntries);\n@@ -60,3 +66,0 @@\n-\n-  SpaceAlignment = HeapRegion::GrainBytes;\n-  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n@@ -93,0 +96,2 @@\n+  } else if (strcmp(type, \"young-evac-fail\") == 0) {\n+    G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyYoungEvacFail);\n@@ -101,1 +106,1 @@\n-                            \"young-normal, concurrent-start, mixed, remark, cleanup and full\", type);\n+                            \"young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\", type);\n@@ -122,0 +127,34 @@\n+\n+void G1Arguments::initialize_card_set_configuration() {\n+  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  \/\/ Array of Cards card set container globals.\n+  const int LOG_M = 20;\n+  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n+    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n+  }\n+\n+  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n+  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n+  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+\n+  \/\/ Howl card set container globals.\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+                                                                     G1RemSetArrayOfCardsEntries,\n+                                                                     G1RemSetHowlMaxNumBuckets));\n+  }\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n+  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n+    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n+                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n+    vm_exit_during_initialization(buf);\n+  }\n+}\n+\n@@ -199,0 +238,8 @@\n+\n+  \/\/ Verify that the maximum parallelism isn't too high to eventually overflow\n+  \/\/ the refcount in G1CardSetContainer.\n+  uint max_parallel_refinement_threads = G1ConcRefinementThreads + G1DirtyCardQueueSet::num_par_ids();\n+  uint const divisor = 3;  \/\/ Safe divisor; we increment by 2 for each claim, but there is a small initial value.\n+  if (max_parallel_refinement_threads > UINTPTR_MAX \/ divisor) {\n+    vm_exit_during_initialization(\"Too large parallelism for remembered sets.\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  static void initialize_card_set_configuration();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,5 @@\n-  if (!_satb_mark_queue_set.is_active()) return;\n+  G1SATBMarkQueueSet& queue_set = G1BarrierSet::satb_mark_queue_set();\n+  if (!queue_set.is_active()) return;\n+\n+  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(Thread::current());\n+\n@@ -79,1 +83,1 @@\n-      enqueue(CompressedOops::decode_not_null(heap_oop));\n+      queue_set.enqueue_known_active(queue, CompressedOops::decode_not_null(heap_oop));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,5 +145,1 @@\n-  \/\/ If \"has_max_index\" is true, \"assumes \"max_index\" is the last valid one\n-  \/\/ in the array.\n-  inline HeapWord* block_at_or_preceding(const void* addr,\n-                                         bool has_max_index,\n-                                         size_t max_index) const;\n+  inline HeapWord* block_at_or_preceding(const void* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,6 +35,3 @@\n-  if (addr >= _hr->bottom() && addr < _hr->end()) {\n-    HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);\n-    return forward_to_block_containing_addr(q, addr);\n-  } else {\n-    return NULL;\n-  }\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  HeapWord* q = block_at_or_preceding(addr);\n+  return forward_to_block_containing_addr(q, addr);\n@@ -44,7 +41,4 @@\n-  if (addr >= _hr->bottom() && addr < _hr->end()) {\n-    HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);\n-    HeapWord* n = q + block_size(q);\n-    return forward_to_block_containing_addr_const(q, n, addr);\n-  } else {\n-    return NULL;\n-  }\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  HeapWord* q = block_at_or_preceding(addr);\n+  HeapWord* n = q + block_size(q);\n+  return forward_to_block_containing_addr_const(q, n, addr);\n@@ -113,3 +107,1 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr,\n-                                                               bool has_max_index,\n-                                                               size_t max_index) const {\n+inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr) const {\n@@ -120,5 +112,3 @@\n-  \/\/ We must make sure that the offset table entry we use is valid.  If\n-  \/\/ \"addr\" is past the end, start at the last known one and go forward.\n-  if (has_max_index) {\n-    index = MIN2(index, max_index);\n-  }\n+  \/\/ We must make sure that the offset table entry we use is valid.\n+  assert(index < _next_offset_index, \"Precondition\");\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,887 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1FromCardCache.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+G1CardSet::CardSetPtr G1CardSet::FullCardSet = (G1CardSet::CardSetPtr)-1;\n+\n+G1CardSetConfiguration::G1CardSetConfiguration() :\n+  _inline_ptr_bits_per_card(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift) {\n+\n+  \/\/ Array of Cards card set container size calculation\n+  _num_cards_in_array = G1RemSetArrayOfCardsEntries;\n+\n+  \/\/ Full card set container size calculation\n+  _max_cards_in_card_set = (uint)HeapRegion::CardsPerRegion;\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+  _cards_in_howl_threshold = _max_cards_in_card_set * (double)G1RemSetCoarsenHowlToFullPercent \/ 100;\n+\n+  \/\/ Howl card set container size calculation.\n+  _num_buckets_in_howl = G1RemSetHowlNumBuckets;\n+\n+  \/\/ Howl Bitmap card set container size calculation.\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * (double)G1RemSetCoarsenHowlBitmapToHowlFullPercent \/ 100;\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+G1CardSetConfiguration::G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                                               uint num_cards_in_array,\n+                                               double cards_in_bitmap_threshold,\n+                                               uint max_buckets_in_howl,\n+                                               double cards_in_howl_threshold,\n+                                               uint max_cards_in_cardset) :\n+  _inline_ptr_bits_per_card(inline_ptr_bits_per_card),\n+  _num_cards_in_array(num_cards_in_array),\n+  _max_cards_in_card_set(max_cards_in_cardset),\n+  _cards_in_howl_threshold(max_cards_in_cardset * cards_in_howl_threshold) {\n+\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+\n+  _num_buckets_in_howl = G1CardSetHowl::num_buckets(_max_cards_in_card_set, _num_cards_in_array, max_buckets_in_howl);\n+\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * cards_in_bitmap_threshold;\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+void G1CardSetConfiguration::log_configuration() {\n+  log_debug_p(gc, remset)(\"Card Set container configuration: \"\n+                          \"InlinePtr #elems %u size %zu \"\n+                          \"Array Of Cards #elems %u size %zu \"\n+                          \"Howl #buckets %u coarsen threshold %u \"\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n+                          num_cards_in_inline_ptr(), sizeof(void*),\n+                          num_cards_in_array(), G1CardSetArray::size_in_bytes(num_cards_in_array()),\n+                          num_buckets_in_howl(), cards_in_howl_threshold(),\n+                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold());\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr() const {\n+  return num_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr(uint bits_per_card) {\n+  return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+}\n+\n+G1CardSetAllocOptions* G1CardSetConfiguration::mem_object_alloc_options() {\n+  G1CardSetAllocOptions* result = NEW_C_HEAP_ARRAY(G1CardSetAllocOptions, num_mem_object_types(), mtGC);\n+\n+  result[0] = { (uint)CardSetHash::get_node_size() };\n+  result[1] = { (uint)G1CardSetArray::size_in_bytes(num_cards_in_array()), 2, 256 };\n+  result[2] = { (uint)G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), 2, 256 };\n+  result[3] = { (uint)G1CardSetHowl::size_in_bytes(num_buckets_in_howl()), 2, 256 };\n+\n+  return result;\n+}\n+\n+const char* G1CardSetConfiguration::mem_object_type_name_str(uint index) {\n+  const char* names[] = { \"Node\", \"Array\", \"Bitmap\", \"Howl\" };\n+  return names[index];\n+}\n+\n+void G1CardSetCoarsenStats::reset() {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = 0;\n+    _coarsen_collision[i] = 0;\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::subtract_from(G1CardSetCoarsenStats& other) {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = other._coarsen_from[i] - _coarsen_from[i];\n+    _coarsen_collision[i] = other._coarsen_collision[i] - _coarsen_collision[i];\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::record_coarsening(uint tag, bool collision) {\n+  assert(tag < ARRAY_SIZE(_coarsen_from), \"tag %u out of bounds\", tag);\n+  Atomic::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  if (collision) {\n+    Atomic::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::print_on(outputStream* out) {\n+  out->print_cr(\"Inline->AoC %zu (%zu) \"\n+                \"AoC->Howl %zu (%zu) \"\n+                \"Howl->Full %zu (%zu) \"\n+                \"Inline->AoC %zu (%zu) \"\n+                \"AoC->BitMap %zu (%zu) \"\n+                \"BitMap->Full %zu (%zu) \",\n+                _coarsen_from[0], _coarsen_collision[0],\n+                _coarsen_from[1], _coarsen_collision[1],\n+                \/\/ There is no BitMap at the first level so we can't .\n+                _coarsen_from[3], _coarsen_collision[3],\n+                _coarsen_from[4], _coarsen_collision[4],\n+                _coarsen_from[5], _coarsen_collision[5],\n+                _coarsen_from[6], _coarsen_collision[6]\n+               );\n+}\n+\n+class G1CardSetHashTable : public CHeapObj<mtGCCardSet> {\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  \/\/ Did we insert at least one element in the table?\n+  bool volatile _inserted_elem;\n+\n+  G1CardSetMemoryManager* _mm;\n+  CardSetHash _table;\n+\n+  class G1CardSetHashTableLookUp : public StackObj {\n+    uint _region_idx;\n+  public:\n+    explicit G1CardSetHashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n+\n+    uintx get_hash() const { return _region_idx; }\n+\n+    bool equals(G1CardSetHashTableValue* value, bool* is_dead) {\n+      *is_dead = false;\n+      return value->_region_idx == _region_idx;\n+    }\n+  };\n+\n+  class G1CardSetHashTableFound : public StackObj {\n+    G1CardSetHashTableValue* _value;\n+  public:\n+    void operator()(G1CardSetHashTableValue* value) {\n+      _value = value;\n+    }\n+\n+    G1CardSetHashTableValue* value() const { return _value; }\n+  };\n+\n+  class G1CardSetHashTableScan : public StackObj {\n+    G1CardSet::G1CardSetPtrIterator* _scan_f;\n+  public:\n+    explicit G1CardSetHashTableScan(G1CardSet::G1CardSetPtrIterator* f) : _scan_f(f) { }\n+\n+    bool operator()(G1CardSetHashTableValue* value) {\n+      _scan_f->do_cardsetptr(value->_region_idx, value->_num_occupied, value->_card_set);\n+      return true;\n+    }\n+  };\n+\n+\n+public:\n+  static const size_t InitialLogTableSize = 2;\n+\n+  G1CardSetHashTable(G1CardSetMemoryManager* mm,\n+                     size_t initial_log_table_size = InitialLogTableSize) :\n+    _inserted_elem(false),\n+    _mm(mm),\n+    _table(mm, initial_log_table_size) {\n+  }\n+\n+  ~G1CardSetHashTable() {\n+    reset();\n+  }\n+\n+  G1CardSetHashTableValue* get_or_add(uint region_idx, bool* should_grow) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value();\n+    }\n+\n+    G1CardSetHashTableValue value(region_idx, G1CardSetInlinePtr());\n+    bool inserted = _table.insert_get(Thread::current(), lookup, value, found, should_grow);\n+\n+    if (!_inserted_elem && inserted) {\n+      \/\/ It does not matter to us who is setting the flag so a regular atomic store\n+      \/\/ is sufficient.\n+      Atomic::store(&_inserted_elem, true);\n+    }\n+\n+    return found.value();\n+  }\n+\n+  CardSetPtr get(uint region_idx) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value()->_card_set;\n+    }\n+    return nullptr;\n+  }\n+\n+  void iterate_safepoint(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_safepoint_scan(cl);\n+  }\n+\n+  void iterate(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_scan(Thread::current(), cl);\n+  }\n+\n+  void reset() {\n+    if (Atomic::load(&_inserted_elem)) {\n+       _table.unsafe_reset(InitialLogTableSize);\n+      Atomic::store(&_inserted_elem, false);\n+    }\n+  }\n+\n+  void print(outputStream* os) {\n+    os->print(\"TBL \" PTR_FORMAT \" size %zu mem %zu \", p2i(&_table), _table.get_size_log2(Thread::current()), _table.get_mem_size(Thread::current()));\n+  }\n+\n+  void grow() {\n+    size_t new_limit = _table.get_size_log2(Thread::current()) + 1;\n+    _table.grow(Thread::current(), new_limit);\n+  }\n+\n+  size_t mem_size() {\n+    return sizeof(*this) +\n+      _table.get_mem_size(Thread::current()) - sizeof(_table);\n+  }\n+\n+  size_t log_table_size() { return _table.get_size_log2(Thread::current()); }\n+};\n+\n+void* G1CardSetHashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  return mm->allocate_node();\n+}\n+\n+void G1CardSetHashTableConfig::free_node(void* context, void* memory, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  mm->free_node(memory);\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::_coarsen_stats;\n+G1CardSetCoarsenStats G1CardSet::_last_coarsen_stats;\n+\n+G1CardSet::G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm) :\n+  _mm(mm),\n+  _config(config),\n+  _table(new G1CardSetHashTable(mm)),\n+  _num_occupied(0) {\n+}\n+\n+G1CardSet::~G1CardSet() {\n+  delete _table;\n+  _mm->flush();\n+}\n+\n+uint G1CardSet::card_set_type_to_mem_object_type(uintptr_t type) const {\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not allocate card set type %zu\", type);\n+\n+  return (uint)type;\n+}\n+\n+uint8_t* G1CardSet::allocate_mem_object(uintptr_t type) {\n+  return _mm->allocate(card_set_type_to_mem_object_type(type));\n+}\n+\n+void G1CardSet::free_mem_object(CardSetPtr card_set) {\n+  assert(card_set != G1CardSet::FreeCardSet, \"should not free Free card set\");\n+  assert(card_set != G1CardSet::FullCardSet, \"should not free Full card set\");\n+\n+  uintptr_t type = card_set_type(card_set);\n+  void* value = strip_card_set_type(card_set);\n+\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not free card set type %zu\", type);\n+\n+#ifdef ASSERT\n+  if (type == G1CardSet::CardSetArrayOfCards ||\n+      type == G1CardSet::CardSetBitMap ||\n+      type == G1CardSet::CardSetHowl) {\n+    G1CardSetContainer* card_set = (G1CardSetContainer*)value;\n+    assert((card_set->refcount() == 1), \"must be\");\n+  }\n+#endif\n+\n+  _mm->free(card_set_type_to_mem_object_type(type), value);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::acquire_card_set(CardSetPtr volatile* card_set_addr) {\n+  \/\/ Update reference counts under RCU critical section to avoid a\n+  \/\/ use-after-cleapup bug where we increment a reference count for\n+  \/\/ an object whose memory has already been cleaned up and reused.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  while (true) {\n+    \/\/ Get cardsetptr and increment refcount atomically wrt to memory reuse.\n+    CardSetPtr card_set = Atomic::load_acquire(card_set_addr);\n+    uint cs_type = card_set_type(card_set);\n+    if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+      return card_set;\n+    }\n+\n+    G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+\n+    if (card_set_on_heap->try_increment_refcount()) {\n+      assert(card_set_on_heap->refcount() >= 3, \"Smallest value is 3\");\n+      return card_set;\n+    }\n+  }\n+}\n+\n+bool G1CardSet::release_card_set(CardSetPtr card_set) {\n+  uint cs_type = card_set_type(card_set);\n+  if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+    return false;\n+  }\n+\n+  G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+  return card_set_on_heap->decrement_refcount() == 1;\n+}\n+\n+void G1CardSet::release_and_maybe_free_card_set(CardSetPtr card_set) {\n+  if (release_card_set(card_set)) {\n+    free_mem_object(card_set);\n+  }\n+}\n+\n+void G1CardSet::release_and_must_free_card_set(CardSetPtr card_set) {\n+  bool should_free = release_card_set(card_set);\n+  assert(should_free, \"should have been the only one having a reference\");\n+  free_mem_object(card_set);\n+}\n+\n+class G1ReleaseCardsets : public StackObj {\n+  G1CardSet* _card_set;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  void coarsen_to_full(CardSetPtr* card_set_addr) {\n+    while (true) {\n+      CardSetPtr cur_card_set = Atomic::load_acquire(card_set_addr);\n+      uint cs_type = G1CardSet::card_set_type(cur_card_set);\n+      if (cur_card_set == G1CardSet::FullCardSet) {\n+        return;\n+      }\n+\n+      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n+\n+      if (old_value == cur_card_set) {\n+        _card_set->release_and_maybe_free_card_set(cur_card_set);\n+        return;\n+      }\n+    }\n+  }\n+\n+public:\n+  explicit G1ReleaseCardsets(G1CardSet* card_set) : _card_set(card_set) { }\n+\n+  void operator ()(CardSetPtr* card_set_addr) {\n+    coarsen_to_full(card_set_addr);\n+  }\n+};\n+\n+G1AddCardResult G1CardSet::add_to_array(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetArray* array = card_set_ptr<G1CardSetArray>(card_set);\n+  return array->add(card_in_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_to_howl(CardSetPtr parent_card_set,\n+                                                uint card_region,\n+                                                uint card_in_region,\n+                                                bool increment_total) {\n+  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  uint bucket = _config->howl_bucket_index(card_in_region);\n+  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n+\n+  while (true) {\n+    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+      return Overflow;\n+    }\n+\n+    card_set = acquire_card_set(bucket_entry);\n+    add_result = add_to_card_set(bucket_entry, card_set, card_region, card_in_region);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(bucket_entry, card_set, card_in_region, true \/* within_howl *\/);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n+  }\n+\n+  if (to_transfer != nullptr) {\n+    transfer_cards_in_howl(parent_card_set, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+  return add_result;\n+}\n+\n+G1AddCardResult G1CardSet::add_to_bitmap(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetBitMap* bitmap = card_set_ptr<G1CardSetBitMap>(card_set);\n+  uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->num_cards_in_howl_bitmap());\n+}\n+\n+G1AddCardResult G1CardSet::add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetInlinePtr value(card_set_addr, card_set);\n+  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->num_cards_in_inline_ptr());\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n+  uint8_t* data = nullptr;\n+  CardSetPtr new_card_set;\n+  if (within_howl) {\n+    uint const size_in_bits = _config->num_cards_in_howl_bitmap();\n+    uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+    data = allocate_mem_object(CardSetBitMap);\n+    new (data) G1CardSetBitMap(card_offset, size_in_bits);\n+    new_card_set = make_card_set_ptr(data, CardSetBitMap);\n+  } else {\n+    data = allocate_mem_object(CardSetHowl);\n+    new (data) G1CardSetHowl(card_in_region, _config);\n+    new_card_set = make_card_set_ptr(data, CardSetHowl);\n+  }\n+  return new_card_set;\n+}\n+\n+bool G1CardSet::coarsen_card_set(volatile CardSetPtr* card_set_addr,\n+                                 CardSetPtr cur_card_set,\n+                                 uint card_in_region,\n+                                 bool within_howl) {\n+  CardSetPtr new_card_set = nullptr;\n+\n+  switch (card_set_type(cur_card_set)) {\n+    case CardSetArrayOfCards : {\n+      new_card_set = create_coarsened_array_of_cards(card_in_region, within_howl);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      new_card_set = FullCardSet;\n+      break;\n+    }\n+    case CardSetInlinePtr: {\n+      uint const size = _config->num_cards_in_array();\n+      uint8_t* data = allocate_mem_object(CardSetArrayOfCards);\n+      new (data) G1CardSetArray(card_in_region, size);\n+      new_card_set = make_card_set_ptr(data, CardSetArrayOfCards);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      new_card_set = FullCardSet; \/\/ anything will do at this point.\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, new_card_set); \/\/ Memory order?\n+  if (old_value == cur_card_set) {\n+    \/\/ Success. Indicate that the cards from the current card set must be transferred\n+    \/\/ by this caller.\n+    \/\/ Release the hash table reference to the card. The caller still holds the\n+    \/\/ reference to this card set, so it can never be released (and we do not need to\n+    \/\/ check its result).\n+    bool should_free = release_card_set(cur_card_set);\n+    assert(!should_free, \"must have had more than one reference\");\n+    \/\/ Free containers if cur_card_set is CardSetHowl\n+    if (card_set_type(cur_card_set) == CardSetHowl) {\n+      G1ReleaseCardsets rel(this);\n+      card_set_ptr<G1CardSetHowl>(cur_card_set)->iterate(rel, _config->num_buckets_in_howl());\n+    }\n+    return true;\n+  } else {\n+    \/\/ Somebody else beat us to coarsening that card set. Exit, but clean up first.\n+    if (new_card_set != FullCardSet) {\n+      assert(new_card_set != nullptr, \"must not be\");\n+      release_and_must_free_card_set(new_card_set);\n+    }\n+    return false;\n+  }\n+}\n+\n+class G1TransferCard : public StackObj {\n+  G1CardSet* _card_set;\n+  uint _region_idx;\n+public:\n+  G1TransferCard(G1CardSet* card_set, uint region_idx) : _card_set(card_set), _region_idx(region_idx) { }\n+\n+  void operator ()(uint card_idx) {\n+    _card_set->add_card(_region_idx, card_idx, false);\n+  }\n+};\n+\n+void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region) {\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap. \"Full\" contains all elements anyway.\n+  if (card_set_type(source_card_set) != CardSetHowl) {\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    assert(card_set_type(source_card_set) == CardSetHowl, \"must be\");\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ AoCS before.\n+    Atomic::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSet::transfer_cards_in_howl(CardSetPtr parent_card_set,\n+                                                     CardSetPtr source_card_set,\n+                                                     uint card_region) {\n+  assert(card_set_type(parent_card_set) == CardSetHowl, \"must be\");\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap.\n+  if (card_set_type(source_card_set) != CardSetBitMap) {\n+    \/\/ We only need to transfer from anything below CardSetBitMap.\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    uint diff = _config->num_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ bitmap before.\n+    \/\/ We add 1 element less because the values will be incremented\n+    \/\/ in G1CardSet::add_card for the current addition or where already incremented in\n+    \/\/ G1CardSet::add_to_howl after coarsening.\n+    diff -= 1;\n+\n+    G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+    Atomic::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+\n+    bool should_grow_table = false;\n+    G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+    Atomic::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+\n+    Atomic::add(&_num_occupied, diff, memory_order_relaxed);\n+  }\n+}\n+\n+G1AddCardResult G1CardSet::add_to_card_set(volatile CardSetPtr* card_set_addr, CardSetPtr card_set,  uint card_region, uint card_in_region, bool increment_total) {\n+  assert(card_set_addr != nullptr, \"Cannot add to empty cardset\");\n+\n+  G1AddCardResult add_result;\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      add_result = add_to_inline_ptr(card_set_addr, card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards : {\n+      add_result = add_to_array(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      add_result = add_to_bitmap(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      assert(CardSetHowl == card_set_type(FullCardSet), \"must be\");\n+      if (card_set == FullCardSet) {\n+        return Found;\n+      }\n+      add_result = add_to_howl(card_set, card_region, card_in_region, increment_total);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  return add_result;\n+}\n+\n+G1CardSetHashTableValue* G1CardSet::get_or_add_card_set(uint card_region, bool* should_grow_table) {\n+  return _table->get_or_add(card_region, should_grow_table);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::get_card_set(uint card_region) {\n+  return _table->get(card_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uint card_region, uint card_in_region, bool increment_total) {\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  bool should_grow_table = false;\n+  G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+  while (true) {\n+    card_set = acquire_card_set(&table_entry->_card_set);\n+    add_result = add_to_card_set(&table_entry->_card_set, card_set, card_region, card_in_region, increment_total);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(&table_entry->_card_set, card_set, card_in_region);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set), !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&table_entry->_num_occupied, memory_order_relaxed);\n+    Atomic::inc(&_num_occupied, memory_order_relaxed);\n+  }\n+  if (should_grow_table) {\n+    _table->grow();\n+  }\n+  if (to_transfer != nullptr) {\n+    transfer_cards(table_entry, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+\n+  return add_result;\n+}\n+\n+bool G1CardSet::contains_card(uint card_region, uint card_in_region) {\n+  assert(card_in_region < _config->max_cards_in_region(),\n+         \"Card %u is beyond max %u\", card_in_region, _config->max_cards_in_region());\n+\n+  \/\/ Protect the card set from reclamation.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    return false;\n+  } else if (card_set == FullCardSet) {\n+    \/\/ contains_card() is not a performance critical method so we do not hide that\n+    \/\/ case in the switch below.\n+    return true;\n+  }\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_in_region, _config->inline_ptr_bits_per_card());\n+    }\n+    case CardSetArrayOfCards :  return card_set_ptr<G1CardSetArray>(card_set)->contains(card_in_region);\n+    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->num_cards_in_howl_bitmap());\n+    case CardSetHowl: {\n+      G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(card_set);\n+\n+      return howling_array->contains(card_in_region, _config);\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    st->print(\"NULL card set\");\n+    return;\n+  } else if (card_set == FullCardSet) {\n+    st->print(\"FULL card set)\");\n+    return;\n+  }\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      st->print(\"InlinePtr not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards :  {\n+      st->print(\"AoC not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      st->print(\"BitMap not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      st->print(\"CardSetHowl not containing %u\", card_in_region);\n+      break;\n+    }\n+    default: st->print(\"Unknown card set type %u\", card_set_type(card_set)); ShouldNotReachHere(); break;\n+  }\n+}\n+\n+template <class CardVisitor>\n+void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found) {\n+  uint type = card_set_type(card_set);\n+  assert(type == CardSetInlinePtr || type == CardSetArrayOfCards,\n+         \"invalid card set type %d to transfer from\",\n+         card_set_type(card_set));\n+\n+  switch (type) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      return;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void G1CardSet::iterate_containers(G1CardSetPtrIterator* found, bool at_safepoint) {\n+  if (at_safepoint) {\n+    _table->iterate_safepoint(found);\n+  } else {\n+    _table->iterate(found);\n+  }\n+}\n+\n+template <typename Closure>\n+class G1ContainerCards {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCards(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) { return true; }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(_region_idx, card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    for (uint i = 0; i < length; i++) {\n+      _iter.do_card(_region_idx, card_idx);\n+    }\n+  }\n+};\n+\n+void G1CardSet::iterate_cards(G1CardSetCardIterator& iter) {\n+  G1CardSetMergeCardIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n+  iterate_containers(&cl);\n+}\n+\n+bool G1CardSet::occupancy_less_or_equal_to(size_t limit) const {\n+  return occupied() <= limit;\n+}\n+\n+bool G1CardSet::is_empty() const {\n+  return _num_occupied == 0;\n+}\n+\n+size_t G1CardSet::occupied() const {\n+  return _num_occupied;\n+}\n+\n+size_t G1CardSet::num_containers() {\n+  class GetNumberOfContainers : public G1CardSetPtrIterator {\n+  public:\n+    size_t _count;\n+\n+    GetNumberOfContainers() : G1CardSetPtrIterator(), _count(0) { }\n+\n+    void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) override {\n+      _count++;\n+    }\n+  } cl;\n+\n+  iterate_containers(&cl);\n+  return cl._count;\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::coarsen_stats() {\n+  return _coarsen_stats;\n+}\n+\n+void G1CardSet::print_coarsen_stats(outputStream* out) {\n+  _last_coarsen_stats.subtract_from(_coarsen_stats);\n+  out->print(\"Coarsening (recent): \");\n+  _last_coarsen_stats.print_on(out);\n+  out->print(\"Coarsening (all): \");\n+  _coarsen_stats.print_on(out);\n+}\n+\n+size_t G1CardSet::mem_size() const {\n+  return sizeof(*this) +\n+         _table->mem_size() +\n+         _mm->mem_size();\n+}\n+\n+size_t G1CardSet::wasted_mem_size() const {\n+  return _mm->wasted_mem_size();\n+}\n+\n+size_t G1CardSet::static_mem_size() {\n+  return sizeof(FullCardSet) + sizeof(_coarsen_stats);\n+}\n+\n+void G1CardSet::clear() {\n+  _table->reset();\n+  _num_occupied = 0;\n+  _mm->flush();\n+}\n+\n+void G1CardSet::print(outputStream* os) {\n+  _table->print(os);\n+  _mm->print(os);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":887,"deletions":0,"binary":false,"changes":887,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_HPP\n+#define SHARE_GC_G1_G1CARDSET_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/concurrentHashTable.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetAllocOptions;\n+class G1CardSetBufferList;\n+class G1CardSetHashTable;\n+class G1CardSetHashTableValue;\n+class G1CardSetMemoryManager;\n+class Mutex;\n+\n+\/\/ The result of an attempt to add a card to that card set.\n+enum G1AddCardResult {\n+  Overflow,  \/\/ The card set is more than full. The entry may have been added. Need\n+             \/\/ Coarsen and retry.\n+  Found,     \/\/ The card is already in the set.\n+  Added      \/\/ The card has been added to the set by this attempt.\n+};\n+\n+class G1CardSetConfiguration {\n+  uint _inline_ptr_bits_per_card;\n+  uint _num_cards_in_array;\n+  uint _num_cards_in_howl_bitmap;\n+  uint _num_buckets_in_howl;\n+  uint _max_cards_in_card_set;\n+  uint _cards_in_howl_threshold;\n+  uint _cards_in_howl_bitmap_threshold;\n+  uint _log2_num_cards_in_howl_bitmap;\n+  size_t _bitmap_hash_mask;\n+\n+  void log_configuration();\n+public:\n+\n+  \/\/ Initialize card set configuration from globals.\n+  G1CardSetConfiguration();\n+  \/\/ Initialize card set configuration from parameters.\n+  G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                         uint num_cards_in_array,\n+                         double cards_in_bitmap_threshold,\n+                         uint max_buckets_in_howl,\n+                         double cards_in_howl_threshold,\n+                         uint max_cards_in_cardset);\n+\n+  \/\/ Inline pointer configuration\n+  uint inline_ptr_bits_per_card() const { return _inline_ptr_bits_per_card; }\n+  uint num_cards_in_inline_ptr() const;\n+  static uint num_cards_in_inline_ptr(uint bits_per_card);\n+\n+  \/\/ Array of Cards configuration\n+  bool use_cards_in_array() const { return _num_cards_in_array != 0; } \/\/ Unused for now\n+  \/\/ Number of cards in \"Array of Cards\" set; 0 to disable.\n+  \/\/ Always coarsen to next level if full, so no specific threshold.\n+  uint num_cards_in_array() const { return _num_cards_in_array; }\n+\n+  \/\/ Bitmap within Howl card set container configuration\n+  bool use_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap != 0; } \/\/ Unused for now\n+  uint num_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap; }\n+  \/\/ (Approximate) Number of cards in bitmap to coarsen Howl Bitmap to Howl Full.\n+  uint cards_in_howl_bitmap_threshold() const { return _cards_in_howl_bitmap_threshold; }\n+  uint log2_num_cards_in_howl_bitmap() const {return _log2_num_cards_in_howl_bitmap;}\n+\n+  \/\/ Howl card set container configuration\n+  uint num_buckets_in_howl() const { return _num_buckets_in_howl; }\n+  \/\/ Threshold at which to turn howling arrays into Full.\n+  uint cards_in_howl_threshold() const { return _cards_in_howl_threshold; }\n+  uint howl_bitmap_offset(uint card_idx) const { return card_idx & _bitmap_hash_mask; }\n+  \/\/ Given a card index, return the bucket in the array of card sets.\n+  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_num_cards_in_howl_bitmap; }\n+\n+  \/\/ Full card configuration\n+  \/\/ Maximum number of cards in a non-full card set for a single region. Card sets\n+  \/\/ with more entries per region are coarsened to Full.\n+  uint max_cards_in_region() const { return _max_cards_in_card_set; }\n+\n+  \/\/ Memory object types configuration\n+  \/\/ Number of distinctly sized memory objects on the card set heap.\n+  \/\/ Currently contains CHT-Nodes, ArrayOfCards, BitMaps, Howl\n+  static constexpr uint num_mem_object_types() { return 4; }\n+  \/\/ Returns the memory allocation options for the memory objects on the card set heap. The returned\n+  \/\/ array must be freed by the caller.\n+  G1CardSetAllocOptions* mem_object_alloc_options();\n+\n+  \/\/ For a given memory object, get a descriptive name.\n+  static const char* mem_object_type_name_str(uint index);\n+};\n+\n+\/\/ Collects coarsening statistics: how many attempts of each kind and how many\n+\/\/ failed due to a competing thread doing the coarsening first.\n+class G1CardSetCoarsenStats {\n+public:\n+  \/\/ Number of entries in the statistics tables: since we index with the source\n+  \/\/ cardset of the coarsening, this is the total number of combinations of\n+  \/\/ card sets - 1.\n+  static constexpr size_t NumCoarsenCategories = 7;\n+  \/\/ Coarsening statistics for the possible CardSetPtr in the Howl card set\n+  \/\/ start from this offset.\n+  static constexpr size_t CoarsenHowlOffset = 4;\n+\n+private:\n+  \/\/ Indices are \"from\" indices.\n+  size_t _coarsen_from[NumCoarsenCategories];\n+  size_t _coarsen_collision[NumCoarsenCategories];\n+\n+public:\n+  G1CardSetCoarsenStats() { reset(); }\n+\n+  void reset();\n+\n+  void subtract_from(G1CardSetCoarsenStats& other);\n+\n+  \/\/ Record a coarsening for the given tag\/category. Collision should be true if\n+  \/\/ this coarsening lost the race to do the coarsening of that category.\n+  void record_coarsening(uint tag, bool collision);\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Sparse set of card indexes comprising a remembered set on the Java heap. Card\n+\/\/ size is assumed to be card table card size.\n+\/\/\n+\/\/ Technically it is implemented using a ConcurrentHashTable that stores a card\n+\/\/ set container for every region containing at least one card.\n+\/\/\n+\/\/ There are in total five different containers, encoded in the ConcurrentHashTable\n+\/\/ node as CardSetPtr. A CardSetPtr may cover the whole region or just a part of\n+\/\/ it.\n+\/\/ See its description below for more information.\n+class G1CardSet : public CHeapObj<mtGCCardSet> {\n+  friend class G1CardSetTest;\n+  friend class G1CardSetMtTestTask;\n+\n+  template <typename Closure, template <typename> class CardorRanges>\n+  friend class G1CardSetMergeCardIterator;\n+\n+  friend class G1TransferCard;\n+\n+  friend class G1ReleaseCardsets;\n+\n+  static G1CardSetCoarsenStats _coarsen_stats; \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats _last_coarsen_stats; \/\/ Coarsening statistics at last GC.\n+public:\n+  \/\/ Two lower bits are used to encode the card storage types\n+  static const uintptr_t CardSetPtrHeaderSize = 2;\n+\n+  \/\/ CardSetPtr represents the card storage type of a given covered area. It encodes\n+  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/\n+  \/\/ Possible encodings:\n+  \/\/\n+  \/\/ 0...00000 free               (Empty, should never happen)\n+  \/\/ 1...11111 full               All card indexes in the whole area this CardSetPtr covers are part of this container.\n+  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this CardSetPtr are encoded within the CardSetPtr.\n+  \/\/ X...XXX01 array of cards     The container is a contiguous array of card indexes.\n+  \/\/ X...XXX10 bitmap             The container uses a bitmap to determine whether a given index is part of this set.\n+  \/\/ X...XXX11 howl               This is a card set container containing an array of CardSetPtr, with each CardSetPtr\n+  \/\/                              limited to a sub-range of the original range. Currently only one level of this\n+  \/\/                              container is supported.\n+  typedef void* CardSetPtr;\n+  \/\/ Coarsening happens in the order below:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetHowl -> Full\n+  \/\/ Corsening of containers inside the CardSetHowl happens in the order:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetBitMap -> Full\n+  static const uintptr_t CardSetInlinePtr      = 0x0;\n+  static const uintptr_t CardSetArrayOfCards   = 0x1;\n+  static const uintptr_t CardSetBitMap         = 0x2;\n+  static const uintptr_t CardSetHowl           = 0x3;\n+\n+  \/\/ The special sentinel values\n+  static constexpr CardSetPtr FreeCardSet = nullptr;\n+  \/\/ Unfortunately we can't make (G1CardSet::CardSetPtr)-1 constexpr because\n+  \/\/ reinterpret_casts are forbidden in constexprs. Use a regular static instead.\n+  static CardSetPtr FullCardSet;\n+\n+  static const uintptr_t CardSetPtrTypeMask    = ((uintptr_t)1 << CardSetPtrHeaderSize) - 1;\n+\n+  static CardSetPtr strip_card_set_type(CardSetPtr ptr) { return (CardSetPtr)((uintptr_t)ptr & ~CardSetPtrTypeMask); }\n+\n+  static uint card_set_type(CardSetPtr ptr) { return (uintptr_t)ptr & CardSetPtrTypeMask; }\n+\n+  template <class T>\n+  static T* card_set_ptr(CardSetPtr ptr);\n+\n+private:\n+  G1CardSetMemoryManager* _mm;\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetHashTable* _table;\n+\n+  \/\/ Total number of cards in this card set. This is a best-effort value, i.e. there may\n+  \/\/ be (slightly) more cards in the card set than this value in reality.\n+  size_t _num_occupied;\n+\n+  CardSetPtr make_card_set_ptr(void* value, uintptr_t type);\n+\n+  CardSetPtr acquire_card_set(CardSetPtr volatile* card_set_addr);\n+  \/\/ Returns true if the card set should be released\n+  bool release_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free if needed.\n+  void release_and_maybe_free_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free (and it must be freeable).\n+  void release_and_must_free_card_set(CardSetPtr card_set);\n+\n+  \/\/ Coarsens the CardSet cur_card_set to the next level; tries to replace the\n+  \/\/ previous CardSet with a new one which includes the given card_in_region.\n+  \/\/ coarsen_card_set does not transfer cards from cur_card_set\n+  \/\/ to the new card_set. Transfer is achieved by transfer_cards.\n+  \/\/ Returns true if this was the thread that coarsened the CardSet (and added the card).\n+  bool coarsen_card_set(CardSetPtr volatile* card_set_addr,\n+                        CardSetPtr cur_card_set,\n+                        uint card_in_region, bool within_howl = false);\n+\n+  CardSetPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n+\n+  \/\/ Transfer entries from source_card_set to a recently installed coarser storage type\n+  \/\/ We only need to transfer anything finer than CardSetBitMap. \"Full\" contains\n+  \/\/ all elements anyway.\n+  void transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region);\n+  void transfer_cards_in_howl(CardSetPtr parent_card_set, CardSetPtr source_card_set, uint card_region);\n+\n+  G1AddCardResult add_to_card_set(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_region, uint card, bool increment_total = true);\n+\n+  G1AddCardResult add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_array(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_bitmap(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_howl(CardSetPtr parent_card_set, uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  G1CardSetHashTableValue* get_or_add_card_set(uint card_region, bool* should_grow_table);\n+  CardSetPtr get_card_set(uint card_region);\n+\n+  \/\/ Iterate over cards of a card set container during transfer of the cards from\n+  \/\/ one container to another. Executes\n+  \/\/\n+  \/\/     void operator ()(uint card_idx)\n+  \/\/\n+  \/\/ on the given class.\n+  template <class CardVisitor>\n+  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found);\n+\n+  \/\/ Iterate over the container, calling a method on every card or card range contained\n+  \/\/ in the card container.\n+  \/\/ For every container, first calls\n+  \/\/\n+  \/\/   void start_iterate(uint tag, uint region_idx);\n+  \/\/\n+  \/\/ Then for every card or card range it calls\n+  \/\/\n+  \/\/   void do_card(uint card_idx);\n+  \/\/   void do_card_range(uint card_idx, uint length);\n+  \/\/\n+  \/\/ where card_idx is the card index within that region_idx passed before in\n+  \/\/ start_iterate().\n+  \/\/\n+  template <class CardOrRangeVisitor>\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+\n+  uint card_set_type_to_mem_object_type(uintptr_t type) const;\n+  uint8_t* allocate_mem_object(uintptr_t type);\n+  void free_mem_object(CardSetPtr card_set);\n+\n+public:\n+  G1CardSetConfiguration* config() const { return _config; }\n+\n+  \/\/ Create a new remembered set for a particular heap region.\n+  G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm);\n+  virtual ~G1CardSet();\n+\n+  \/\/ Adds the given card to this set, returning an appropriate result. If added,\n+  \/\/ updates the total count.\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n+  \/\/ that is less or equal to the given occupancy.\n+  bool occupancy_less_or_equal_to(size_t limit) const;\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the number of cards contained in this remembered set.\n+  size_t occupied() const;\n+\n+  size_t num_containers();\n+\n+  static G1CardSetCoarsenStats coarsen_stats();\n+  static void print_coarsen_stats(outputStream* out);\n+\n+  \/\/ Returns size of the actual remembered set containers in bytes.\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+  \/\/ Returns the size of static data in bytes.\n+  static size_t static_mem_size();\n+\n+  \/\/ Clear the entire contents of this remembered set.\n+  void clear();\n+\n+  void print(outputStream* os);\n+\n+  \/\/ Various iterators - should be made inlineable somehow.\n+  class G1CardSetPtrIterator {\n+  public:\n+    virtual void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) = 0;\n+  };\n+\n+  void iterate_containers(G1CardSetPtrIterator* iter, bool safepoint = false);\n+\n+  class G1CardSetCardIterator {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(G1CardSetCardIterator& iter);\n+\n+  \/\/ Iterate all cards for card set merging. Must be a CardOrRangeVisitor as\n+  \/\/ explained above.\n+  template <class CardOrRangeVisitor>\n+  void iterate_for_merge(CardOrRangeVisitor& cl);\n+};\n+\n+class G1CardSetHashTableValue {\n+public:\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  const uint _region_idx;\n+  uint volatile _num_occupied;\n+  CardSetPtr volatile _card_set;\n+\n+  G1CardSetHashTableValue(uint region_idx, CardSetPtr card_set) : _region_idx(region_idx), _num_occupied(0), _card_set(card_set) { }\n+};\n+\n+class G1CardSetHashTableConfig : public StackObj {\n+public:\n+  using Value = G1CardSetHashTableValue;\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    *is_dead = false;\n+    return value._region_idx;\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value);\n+  static void free_node(void* context, void* memory, Value const& value);\n+};\n+\n+typedef ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet> CardSetHash;\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+template <class T>\n+inline T* G1CardSet::card_set_ptr(CardSetPtr ptr) {\n+  return (T*)strip_card_set_type(ptr);\n+}\n+\n+inline G1CardSet::CardSetPtr G1CardSet::make_card_set_ptr(void* value, uintptr_t type) {\n+  assert(card_set_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n+  return (CardSetPtr)((uintptr_t)value | type);\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found) {\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n+        card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case CardSetBitMap: {\n+      \/\/ There is no first-level bitmap spanning the whole area.\n+      ShouldNotReachHere();\n+      return;\n+    }\n+    case CardSetHowl: {\n+      assert(card_set_type(FullCardSet) == CardSetHowl, \"Must be\");\n+      if (card_set == FullCardSet) {\n+        if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n+          found(0, _config->max_cards_in_region());\n+        }\n+        return;\n+      }\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n+        card_set_ptr<G1CardSetHowl>(card_set)->iterate(found, _config);\n+      }\n+      return;\n+    }\n+  }\n+  log_error(gc)(\"Unkown card set type %u\", card_set_type(card_set));\n+  ShouldNotReachHere();\n+}\n+\n+template <typename Closure>\n+class G1ContainerCardsOrRanges {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCardsOrRanges(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) {\n+    return _iter.start_iterate(tag, _region_idx);\n+  }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    _iter.do_card_range(card_idx, length);\n+  }\n+};\n+\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1CardSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+\n+public:\n+\n+  G1CardSetMergeCardIterator(G1CardSet* card_set, Closure& iter) : _card_set(card_set), _iter(iter) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter, region_idx);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n+  iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+class G1CardSetInlinePtr : public StackObj {\n+  friend class G1CardSetContainersTest;\n+\n+  typedef G1CardSet::CardSetPtr CardSetPtr;\n+\n+  CardSetPtr volatile * _value_addr;\n+  CardSetPtr _value;\n+\n+  static const uint SizeFieldLen = 3;\n+  static const uint SizeFieldPos = 2;\n+  static const uint HeaderSize = G1CardSet::CardSetPtrHeaderSize + SizeFieldLen;\n+\n+  static const uint BitsInValue = sizeof(CardSetPtr) * BitsPerByte;\n+\n+  static const uintptr_t SizeFieldMask = (((uint)1 << SizeFieldLen) - 1) << SizeFieldPos;\n+\n+  static uint8_t card_pos_for(uint const idx, uint const bits_per_card) {\n+    return (idx * bits_per_card + HeaderSize);\n+  }\n+\n+  static CardSetPtr merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n+\n+  static uint card_at(CardSetPtr value, uint const idx, uint const bits_per_card) {\n+    uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+    uint result = ((uintptr_t)value >> card_pos) & (((uintptr_t)1 << bits_per_card) - 1);\n+    return result;\n+  }\n+public:\n+  G1CardSetInlinePtr() : _value_addr(nullptr), _value((CardSetPtr)G1CardSet::CardSetInlinePtr) { }\n+\n+  G1CardSetInlinePtr(CardSetPtr value) : _value_addr(nullptr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1CardSetInlinePtr(CardSetPtr volatile* value_addr, CardSetPtr value) : _value_addr(value_addr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1AddCardResult add(uint const card_idx, uint const bits_per_card, uint const max_cards_in_inline_ptr);\n+\n+  bool contains(uint const card_idx, uint const bits_per_card);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, uint const bits_per_card);\n+\n+  operator CardSetPtr () { return _value; }\n+\n+  static uint max_cards_in_inline_ptr(uint bits_per_card) {\n+    return (BitsInValue - HeaderSize) \/ bits_per_card;\n+  }\n+\n+  static uint num_cards_in(CardSetPtr value) {\n+    return ((uintptr_t)value & SizeFieldMask) >> SizeFieldPos;\n+  }\n+};\n+\n+\n+\/\/ Common base class for card set containers where the memory for the entries is\n+\/\/ managed on the (C-)heap. Depending on the current use, one of the two overlapping\n+\/\/ members are used:\n+\/\/\n+\/\/ While such an object is assigned to a card set container, we utilize the\n+\/\/ reference count for memory management.\n+\/\/\n+\/\/ In this case the object is one of three states:\n+\/\/ 1: Live: The object is visible to other threads, thus can\n+\/\/    safely be accessed by other threads (_ref_count >= 3).\n+\/\/ 2: Dead: The object is visible to only a single thread and may be\n+\/\/    safely reclaimed (_ref_count == 1).\n+\/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n+\/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n+\/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\/\/\n+\/\/ When such an object is on a free list, we reuse the same field for linking\n+\/\/ together those free objects.\n+\/\/\n+\/\/ All but inline pointers are of this kind. For those, card entries are stored\n+\/\/ directly in the CardSetPtr of the ConcurrentHashTable node.\n+class G1CardSetContainer {\n+private:\n+  union {\n+    G1CardSetContainer* _next;\n+    uintptr_t _ref_count;\n+  };\n+\n+public:\n+  G1CardSetContainer() : _ref_count(3) { }\n+\n+  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+\n+  bool try_increment_refcount();\n+\n+  \/\/ Decrement refcount potentially while racing increment, so we need\n+  \/\/ to check the value after attempting to decrement.\n+  uintptr_t decrement_refcount();\n+\n+  G1CardSetContainer* next() {\n+    return _next;\n+  }\n+\n+  G1CardSetContainer** next_addr() {\n+    return &_next;\n+  }\n+\n+  void set_next(G1CardSetContainer* next) {\n+    _next = next;\n+  }\n+};\n+\n+class G1CardSetArray : public G1CardSetContainer {\n+public:\n+  typedef uint16_t EntryDataType;\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+private:\n+  EntryCountType _size;\n+  EntryCountType volatile _num_entries;\n+  EntryDataType _data[2];\n+\n+  static const EntryCountType LockBitMask = (EntryCountType)1 << (sizeof(EntryCountType) * BitsPerByte - 1);\n+  static const EntryCountType EntryMask = LockBitMask - 1;\n+\n+  class G1CardSetArrayLocker : public StackObj {\n+    EntryCountType volatile* _value;\n+    EntryCountType volatile _original_value;\n+    bool _success;\n+  public:\n+    G1CardSetArrayLocker(EntryCountType volatile* value);\n+\n+    EntryCountType num_entries() const { return _original_value; }\n+    void inc_num_entries() { _success = true; }\n+\n+    ~G1CardSetArrayLocker() {\n+      assert(((_original_value + _success) & EntryMask) == (EntryCountType)(_original_value + _success), \"precondition!\" );\n+\n+      Atomic::release_store(_value, (EntryCountType)(_original_value + _success));\n+    }\n+  };\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _data);\n+  }\n+\n+public:\n+  G1CardSetArray(uint const card_in_region, EntryCountType num_elems);\n+\n+  G1AddCardResult add(uint card_idx);\n+\n+  bool contains(uint card_idx);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found);\n+\n+  size_t num_entries() const { return _num_entries & EntryMask; }\n+  size_t max_entries() const { return _size; }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetArray>(); }\n+\n+  static size_t size_in_bytes(size_t num_cards) {\n+    return header_size_in_bytes() + sizeof(EntryDataType) * num_cards;\n+  }\n+};\n+\n+class G1CardSetBitMap : public G1CardSetContainer {\n+  size_t _num_bits_set;\n+  BitMap::bm_word_t _bits[1];\n+\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _bits);\n+  }\n+\n+public:\n+  G1CardSetBitMap(uint const card_in_region, uint const size_in_bits);\n+\n+  G1AddCardResult add(uint card_idx, size_t threshold, size_t size_in_bits);\n+\n+  bool contains(uint card_idx, size_t size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return bm.at(card_idx);\n+  }\n+\n+  uint num_bits_set() const { return (uint)_num_bits_set; }\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, size_t const size_in_bits, uint offset);\n+\n+  uint next(uint const idx, size_t const size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return static_cast<uint>(bm.get_next_one_offset(idx));\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetBitMap>(); }\n+\n+  static size_t size_in_bytes(size_t size_in_bits) { return header_size_in_bytes() + BitMap::calc_size_in_words(size_in_bits) * BytesPerWord; }\n+};\n+\n+class G1CardSetHowl : public G1CardSetContainer {\n+public:\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+  EntryCountType volatile _num_entries;\n+private:\n+  CardSetPtr _buckets[2];\n+  \/\/ Do not add class member variables beyond this point\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _buckets);\n+  }\n+\n+  \/\/ Iterates over the given CardSetPtr with at index in this Howl card set,\n+  \/\/ applying a CardOrRangeVisitor on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+public:\n+  G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config);\n+\n+  CardSetPtr* get_card_set_addr(EntryCountType index) {\n+    return &_buckets[index];\n+  }\n+\n+  bool contains(uint card_idx, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set, applying a CardOrRangeVisitor\n+  \/\/ on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set. Calls\n+  \/\/\n+  \/\/   void operator ()(CardSetPtr* card_set_addr);\n+  \/\/\n+  \/\/ on all of them.\n+  template <class CardSetPtrVisitor>\n+  void iterate(CardSetPtrVisitor& found, uint num_card_sets);\n+\n+  static EntryCountType num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_buckets);\n+\n+  static EntryCountType bitmap_size(size_t size_in_bits, uint num_buckets) {\n+    EntryCountType num_cards = (EntryCountType)size_in_bits \/ num_buckets;\n+    return round_up_power_of_2(num_cards);\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetHowl>(); }\n+\n+  static size_t size_in_bytes(size_t num_arrays) {\n+    return header_size_in_bytes() + sizeof(CardSetPtr) * num_arrays;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+\n+inline G1CardSetInlinePtr::CardSetPtr G1CardSetInlinePtr::merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n+  assert((idx & (SizeFieldMask >> SizeFieldPos)) == idx, \"Index %u too large to fit into size field\", idx);\n+  assert(card_in_region < ((uint)1 << bits_per_card), \"Card %u too large to fit into card value field\", card_in_region);\n+\n+  uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+  assert(card_pos + bits_per_card < BitsInValue, \"Putting card at pos %u with %u bits would extend beyond pointer\", card_pos, bits_per_card);\n+\n+  \/\/ Check that we do not touch any fields we do not own.\n+  uintptr_t mask = ((((uintptr_t)1 << bits_per_card) - 1) << card_pos);\n+  assert(((uintptr_t)orig_value & mask) == 0, \"The bits in the new range should be empty; orig_value \" PTR_FORMAT \" mask \" PTR_FORMAT, p2i(orig_value), mask);\n+\n+  uintptr_t value = ((uintptr_t)(idx + 1) << SizeFieldPos) | ((uintptr_t)card_in_region << card_pos);\n+  uintptr_t res = (((uintptr_t)orig_value & ~SizeFieldMask) | value);\n+  return (CardSetPtr)res;\n+}\n+\n+inline G1AddCardResult G1CardSetInlinePtr::add(uint card_idx, uint bits_per_card, uint max_cards_in_inline_ptr) {\n+  assert(_value_addr != nullptr, \"No value address available, cannot add to set.\");\n+\n+  while (true) {\n+    uint num_elems = num_cards_in(_value);\n+    \/\/ Check if the card is already stored in the pointer.\n+    if (contains(card_idx, bits_per_card)) {\n+      return Found;\n+    }\n+    \/\/ Check if there is actually enough space.\n+    if (num_elems >= max_cards_in_inline_ptr) {\n+      return Overflow;\n+    }\n+    CardSetPtr new_value = merge(_value, card_idx, num_elems, bits_per_card);\n+    CardSetPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    if (_value == old_value) {\n+      return Added;\n+    }\n+    \/\/ Update values and retry.\n+    _value = old_value;\n+    \/\/ The value of the pointer may have changed to something different than\n+    \/\/ an inline card set. Exit then instead of overwriting.\n+    if (G1CardSet::card_set_type(_value) != G1CardSet::CardSetInlinePtr) {\n+      return Overflow;\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetInlinePtr::contains(uint card_idx, uint bits_per_card) {\n+  uint num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  \/\/ Check if the card is already stored in the pointer.\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    if ((value & card_mask) == card_idx) {\n+      return true;\n+    }\n+    value >>= bits_per_card;\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetInlinePtr::iterate(CardVisitor& found, uint bits_per_card) {\n+  uint const num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    found(value & card_mask);\n+    value >>= bits_per_card;\n+  }\n+}\n+\n+inline bool G1CardSetContainer::try_increment_refcount() {\n+  uintptr_t old_value = refcount();\n+  while (true) {\n+    if (old_value < 3 || (old_value & 0x1) == 0) {  \/\/ reclaimed,  reference counts are odd numbers starting at 3\n+      return false; \/\/ dead, can't revive.\n+    }\n+\n+    uintptr_t new_value = old_value + 2;\n+    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    if (ref_count == old_value) {\n+      return true;\n+    }\n+    old_value = ref_count;\n+  }\n+}\n+\n+inline uintptr_t G1CardSetContainer::decrement_refcount() {\n+  uintptr_t old_value = refcount();\n+  assert((old_value & 0x1) != 0 && old_value >= 3, \"precondition\");\n+  return Atomic::sub(&_ref_count, 2u);\n+}\n+\n+inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_elems) :\n+  G1CardSetContainer(),\n+  _size(num_elems),\n+  _num_entries(1) {\n+  assert(_size > 0, \"CardSetArray of size 0 not supported.\");\n+  assert(_size < LockBitMask, \"Only support CardSetArray of size %u or smaller.\", LockBitMask - 1);\n+  _data[0] = card_in_region;\n+}\n+\n+inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(EntryCountType volatile* value) :\n+  _value(value),\n+  _success(false) {\n+  SpinYield s;\n+  EntryCountType original_value = (*_value) & EntryMask;\n+  while (true) {\n+    EntryCountType old_value = Atomic::cmpxchg(_value,\n+                                               original_value,\n+                                               (EntryCountType)(original_value | LockBitMask));\n+    if (old_value == original_value) {\n+      \/\/ Succeeded locking the array.\n+      _original_value = original_value;\n+      break;\n+    }\n+    \/\/ Failed. Retry (with the lock bit stripped again).\n+    original_value = old_value & EntryMask;\n+    s.wait();\n+  }\n+}\n+\n+inline G1AddCardResult G1CardSetArray::add(uint card_idx) {\n+  assert(card_idx < (1u << (sizeof(_data[0]) * BitsPerByte)),\n+         \"Card index %u does not fit card element.\", card_idx);\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType idx = 0;\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Since we did not find the card, lock.\n+  G1CardSetArrayLocker x(&_num_entries);\n+\n+  \/\/ Reload number of entries from the G1CardSetArrayLocker as it might have changed.\n+  \/\/ It already read the actual value with the necessary synchronization.\n+  num_entries = x.num_entries();\n+  \/\/ Look if the elements added while waiting for the lock are the same as our card.\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Check if there is space left.\n+  if (num_entries == _size) {\n+    return Overflow;\n+  }\n+\n+  _data[num_entries] = card_idx;\n+\n+  x.inc_num_entries();\n+\n+  return Added;\n+}\n+\n+inline bool G1CardSetArray::contains(uint card_idx) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+void G1CardSetArray::iterate(CardVisitor& found) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    found(_data[idx]);\n+  }\n+}\n+\n+inline G1CardSetBitMap::G1CardSetBitMap(uint card_in_region, uint size_in_bits) :\n+  G1CardSetContainer(), _num_bits_set(1) {\n+  assert(size_in_bits % (sizeof(_bits[0]) * BitsPerByte) == 0,\n+         \"Size %u should be aligned to bitmap word size.\", size_in_bits);\n+  BitMapView bm(_bits, size_in_bits);\n+  bm.clear();\n+  bm.set_bit(card_in_region);\n+}\n+\n+inline G1AddCardResult G1CardSetBitMap::add(uint card_idx, size_t threshold, size_t size_in_bits) {\n+  BitMapView bm(_bits, size_in_bits);\n+  if (_num_bits_set >= threshold) {\n+    return bm.at(card_idx) ? Found : Overflow;\n+  }\n+  if (bm.par_set_bit(card_idx)) {\n+    Atomic::inc(&_num_bits_set, memory_order_relaxed);\n+    return Added;\n+  }\n+  return Found;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetBitMap::iterate(CardVisitor& found, size_t size_in_bits, uint offset) {\n+  BitMapView bm(_bits, size_in_bits);\n+  BitMap::idx_t idx = bm.get_next_one_offset(0);\n+  while (idx != size_in_bits) {\n+    found((offset | (uint)idx));\n+    idx = bm.get_next_one_offset(idx + 1);\n+  }\n+}\n+\n+inline G1CardSetHowl::G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config) :\n+  G1CardSetContainer(),\n+  _num_entries((config->num_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n+  EntryCountType num_buckets = config->num_buckets_in_howl();\n+  EntryCountType bucket = config->howl_bucket_index(card_in_region);\n+  for (uint i = 0; i < num_buckets; ++i) {\n+    _buckets[i] = G1CardSetInlinePtr();\n+    if (i == bucket) {\n+      G1CardSetInlinePtr value(&_buckets[i], _buckets[i]);\n+      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->num_cards_in_inline_ptr());\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetHowl::contains(uint card_idx, G1CardSetConfiguration* config) {\n+  EntryCountType bucket = config->howl_bucket_index(card_idx);\n+  CardSetPtr* array_entry = get_card_set_addr(bucket);\n+  CardSetPtr card_set = Atomic::load_acquire(array_entry);\n+\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetArrayOfCards : {\n+      return G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->contains(card_idx);\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      uint card_offset = config->howl_bitmap_offset(card_idx);\n+      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->num_cards_in_howl_bitmap());\n+    }\n+    case G1CardSet::CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_idx, config->inline_ptr_bits_per_card());\n+    }\n+    case G1CardSet::CardSetHowl: {\/\/ Fullcard set entry\n+      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  for (uint i = 0; i < config->num_buckets_in_howl(); ++i) {\n+    iterate_cardset(_buckets[i], i, found, config);\n+  }\n+}\n+\n+template <class CardSetPtrVisitor>\n+inline void G1CardSetHowl::iterate(CardSetPtrVisitor& found, uint num_card_sets) {\n+  for (uint i = 0; i < num_card_sets; ++i) {\n+    found(&_buckets[i]);\n+  }\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlArrayOfCards)) {\n+        G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlBitmap)) {\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->num_cards_in_howl_bitmap(), offset);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetHowl: { \/\/ actually FullCardSet\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlFull)) {\n+        assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        for (uint i = 0; i < config->max_cards_in_region(); i++) {\n+          found((offset | (uint)i));\n+        }\n+      }\n+      return;\n+    }\n+  }\n+}\n+\n+inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_num_buckets) {\n+  size_t size_bitmap_bytes = BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n+  \/\/ Ensure that in the worst case arrays consume half the memory size\n+  \/\/ of storing the entire bitmap\n+  size_t max_size_arrays_bytes = size_bitmap_bytes \/ 2;\n+  size_t size_array_bytes = num_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n+  size_t num_arrays = max_size_arrays_bytes \/ size_array_bytes;\n+  \/\/ We use shifts and masks for indexing the array. So round down to the next\n+  \/\/ power of two to not use more than expected memory.\n+  num_arrays = round_down_power_of_2(MAX2((size_t)1, MIN2(num_arrays, max_num_buckets)));\n+  return (EntryCountType)num_arrays;\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"heapRegionRemSet.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+\n+constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n+\n+const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1CardSetMemoryStats used = _total_used;\n+  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_buffers[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1CardSetFreePool::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1CardSetFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1CardSetFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1CardSetFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_card_set_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class G1CardSetBuffer;\n+\n+\/\/ Task handling deallocation of free card set memory.\n+class G1CardSetFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total card set memory usage.\n+  G1CardSetMemoryStats _total_used;\n+\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess card set memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_card_set_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1CardSetFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                        G1CardSetMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1CardSetBuffer::G1CardSetBuffer(uint elem_size, uint num_instances, G1CardSetBuffer* next) :\n+    _elem_size(elem_size), _num_elems(num_instances), _next(next), _next_allocate(0) {\n+\n+  _buffer = NEW_C_HEAP_ARRAY(char, (size_t)_num_elems * elem_size, mtGCCardSet);\n+}\n+\n+G1CardSetBuffer::~G1CardSetBuffer() {\n+  FREE_C_HEAP_ARRAY(mtGCCardSet, _buffer);\n+}\n+\n+void* G1CardSetBuffer::get_new_buffer_elem() {\n+  if (_next_allocate >= _num_elems) {\n+    return nullptr;\n+  }\n+  uint result = Atomic::fetch_and_add(&_next_allocate, 1u, memory_order_relaxed);\n+  if (result >= _num_elems) {\n+    return nullptr;\n+  }\n+  void* r = _buffer + (uint)result * _elem_size;\n+  return r;\n+}\n+\n+void G1CardSetBufferList::bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size) {\n+  _list.prepend(first, last);\n+  Atomic::add(&_num_buffers, num, memory_order_relaxed);\n+  Atomic::add(&_mem_size, mem_size, memory_order_relaxed);\n+}\n+\n+void G1CardSetBufferList::print_on(outputStream* out, const char* prefix) {\n+  out->print_cr(\"%s: buffers %zu size %zu\", prefix, Atomic::load(&_num_buffers), Atomic::load(&_mem_size));\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get() {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop();\n+  if (result != nullptr) {\n+    Atomic::dec(&_num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get_all(size_t& num_buffers, size_t& mem_size) {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop_all();\n+  num_buffers = Atomic::load(&_num_buffers);\n+  mem_size = Atomic::load(&_mem_size);\n+\n+  if (result != nullptr) {\n+    Atomic::sub(&_num_buffers, num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, mem_size, memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+void G1CardSetBufferList::free_all() {\n+  size_t num_freed = 0;\n+  size_t mem_size_freed = 0;\n+  G1CardSetBuffer* cur;\n+\n+  while ((cur = _list.pop()) != nullptr) {\n+    mem_size_freed += cur->mem_size();\n+    num_freed++;\n+    delete cur;\n+  }\n+\n+  Atomic::sub(&_num_buffers, num_freed, memory_order_relaxed);\n+  Atomic::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n+}\n+\n+template <class Elem>\n+G1CardSetAllocator<Elem>::G1CardSetAllocator(const char* name,\n+                                             const G1CardSetAllocOptions& buffer_options,\n+                                             G1CardSetBufferList* free_buffer_list) :\n+  _alloc_options(buffer_options),\n+  _first(nullptr),\n+  _last(nullptr),\n+  _num_buffers(0),\n+  _mem_size(0),\n+  _free_buffer_list(free_buffer_list),\n+  _transfer_lock(false),\n+  _free_nodes_list(),\n+  _pending_nodes_list(),\n+  _num_pending_nodes(0),\n+  _num_free_nodes(0),\n+  _num_allocated_nodes(0),\n+  _num_available_nodes(0)\n+{\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"Element instance size %u for allocator %s too small\",\n+         elem_size(), name);\n+  assert(_free_buffer_list != nullptr, \"precondition!\");\n+}\n+\n+template <class Elem>\n+bool G1CardSetAllocator<Elem>::try_transfer_pending() {\n+  \/\/ Attempt to claim the lock.\n+  if (Atomic::load_acquire(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+    return false;\n+  }\n+  \/\/ Have the lock; perform the transfer.\n+\n+  \/\/ Claim all the pending nodes.\n+  G1CardSetContainer* first = _pending_nodes_list.pop_all();\n+\n+  if (first != nullptr) {\n+    \/\/ Prepare to add the claimed nodes, and update _num_pending_nodes.\n+    G1CardSetContainer* last = first;\n+    Atomic::load_acquire(&_num_pending_nodes);\n+\n+    uint count = 1;\n+    for (G1CardSetContainer* next = first->next(); next != nullptr; next = next->next()) {\n+      last = next;\n+      ++count;\n+    }\n+\n+    Atomic::sub(&_num_pending_nodes, count);\n+\n+    \/\/ Wait for any in-progress pops to avoid ABA for them.\n+    GlobalCounter::write_synchronize();\n+    \/\/ Add synchronized nodes to _free_node_list.\n+    \/\/ Update count first so there can be no underflow in allocate().\n+    Atomic::add(&_num_free_nodes, count);\n+    _free_nodes_list.prepend(*first, *last);\n+  }\n+  Atomic::release_store(&_transfer_lock, false);\n+  return true;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::free(Elem* elem) {\n+  assert(elem != nullptr, \"precondition\");\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"size mismatch\");\n+  \/\/ Desired minimum transfer batch size.  There is relatively little\n+  \/\/ importance to the specific number.  It shouldn't be too big, else\n+  \/\/ we're wasting space when the release rate is low.  If the release\n+  \/\/ rate is high, we might accumulate more than this before being\n+  \/\/ able to start a new transfer, but that's okay.  Also note that\n+  \/\/ the allocation rate and the release rate are going to be fairly\n+  \/\/ similar, due to how the buffers are used. - kbarret\n+  uint const trigger_transfer = 10;\n+\n+  uint pending_count = Atomic::add(&_num_pending_nodes, 1u, memory_order_relaxed);\n+\n+  G1CardSetContainer* node =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(elem));\n+\n+  node->set_next(nullptr);\n+  assert(node->next() == nullptr, \"precondition\");\n+\n+  _pending_nodes_list.push(*node);\n+\n+  if (pending_count > trigger_transfer) {\n+    try_transfer_pending();\n+  }\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::drop_all() {\n+  _free_nodes_list.pop_all();\n+  _pending_nodes_list.pop_all();\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+\n+  if (cur != nullptr) {\n+    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+\n+    G1CardSetBuffer* first = cur;\n+#ifdef ASSERT\n+    \/\/ Check list consistency.\n+    G1CardSetBuffer* last = cur;\n+    uint num_buffers = 0;\n+    size_t mem_size = 0;\n+    while (cur != nullptr) {\n+      mem_size += cur->mem_size();\n+      num_buffers++;\n+\n+      G1CardSetBuffer* next = cur->next();\n+      last = cur;\n+      cur = next;\n+    }\n+#endif\n+    assert(num_buffers == _num_buffers, \"Buffer count inconsistent %u %u\", num_buffers, _num_buffers);\n+    assert(mem_size == _mem_size, \"Memory size inconsistent\");\n+    assert(last == _last, \"Inconsistent last element\");\n+\n+    _free_buffer_list->bulk_add(*first, *_last, _num_buffers, _mem_size);\n+  }\n+\n+  _first = nullptr;\n+  _last = nullptr;\n+  _num_available_nodes = 0;\n+  _num_allocated_nodes = 0;\n+  _num_pending_nodes = 0;\n+  _num_buffers = 0;\n+  _mem_size = 0;\n+  _num_free_nodes = 0;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::print(outputStream* os) {\n+  os->print(\"MA \" PTR_FORMAT \": %u elems pending (allocated %u available %u) used %.3f highest %u buffers %u size %zu \",\n+                p2i(this), _num_pending_nodes, _num_allocated_nodes, _num_available_nodes, percent_of(_num_allocated_nodes - _num_pending_nodes, _num_available_nodes), _first != nullptr ? _first->num_elems() : 0, _num_buffers, mem_size());\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats(void(*fn)(const void*,uint,size_t&,size_t&), const void* context) {\n+  clear();\n+  for (uint i = 0; i < num_pools(); i++) {\n+    fn(context, i, _num_mem_sizes[i], _num_buffers[i]);\n+  }\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+static void collect_mem_sizes(const void* context, uint i, size_t& mem_size, size_t& num_buffers) {\n+  ((G1CardSetFreePool*)context)->get_size(i, mem_size, num_buffers);\n+}\n+\n+void G1CardSetFreePool::get_size(uint i, size_t& mem_size, size_t& num_buffers) const {\n+  mem_size = _free_lists[i].mem_size();\n+  num_buffers = _free_lists[i].num_buffers();\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  return G1CardSetMemoryStats(collect_mem_sizes, this);\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+G1CardSetMemoryManager::G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                                               G1CardSetFreePool* free_list_pool) : _config(config) {\n+\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+                                 _config->num_mem_object_types(),\n+                                 mtGC);\n+  G1CardSetAllocOptions* alloc_options = _config->mem_object_alloc_options();\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n+                                                                 alloc_options[i],\n+                                                                 free_list_pool->free_list(i));\n+  }\n+  FREE_C_HEAP_ARRAY(size_t, alloc_options);\n+}\n+\n+uint G1CardSetMemoryManager::num_mem_object_types() const {\n+  return _config->num_mem_object_types();\n+}\n+\n+\n+G1CardSetMemoryManager::~G1CardSetMemoryManager() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].~G1CardSetAllocator();\n+  }\n+  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>, _allocators);\n+}\n+\n+void G1CardSetMemoryManager::free(uint type, void* value) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  _allocators[type].free((G1CardSetContainer*)value);\n+}\n+\n+void G1CardSetMemoryManager::flush() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].drop_all();\n+  }\n+}\n+\n+void G1CardSetMemoryManager::print(outputStream* os) {\n+  os->print_cr(\"MM \" PTR_FORMAT \" size %zu\", p2i(this), sizeof(*this));\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].print(os);\n+  }\n+}\n+\n+size_t G1CardSetMemoryManager::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].mem_size();\n+  }\n+  return sizeof(*this) -\n+    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n+    result;\n+}\n+\n+size_t G1CardSetMemoryManager::wasted_mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].wasted_mem_size();\n+  }\n+  return result;\n+}\n+\n+G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1CardSetMemoryStats result;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result._num_mem_sizes[i] += _allocators[i].mem_size();\n+    result._num_buffers[i] += _allocators[i].num_buffers();\n+  }\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetConfiguration;\n+class outputStream;\n+\n+\/\/ Collects G1CardSetAllocator options\/heuristics. Called by G1CardSetAllocator\n+\/\/ to determine the next size of the allocated G1CardSetBuffer.\n+class G1CardSetAllocOptions {\n+  uint _elem_size;\n+  uint _initial_num_elems;\n+  \/\/ Defines a limit to the number of elements in the buffer\n+  uint _max_num_elems;\n+\n+  uint exponential_expand(uint prev_num_elems) {\n+    return clamp(prev_num_elems * 2, _initial_num_elems, _max_num_elems);\n+  }\n+\n+public:\n+  static const uint BufferAlignment = 8;\n+  static const uint MinimumBufferSize = 8;\n+  static const uint MaximumBufferSize =  UINT_MAX \/ 2;\n+\n+  G1CardSetAllocOptions(uint elem_size, uint initial_num_elems = MinimumBufferSize, uint max_num_elems = MaximumBufferSize) :\n+    _elem_size(align_up(elem_size, BufferAlignment)),\n+    _initial_num_elems(initial_num_elems),\n+    _max_num_elems(max_num_elems) {\n+  }\n+\n+  uint next_num_elems(uint prev_num_elems) {\n+    return exponential_expand(prev_num_elems);\n+  }\n+\n+  uint elem_size () const {return _elem_size;}\n+};\n+\n+\/\/ A single buffer\/arena containing _num_elems blocks of memory of _elem_size.\n+\/\/ G1CardSetBuffers can be linked together using a singly linked list.\n+class G1CardSetBuffer : public CHeapObj<mtGCCardSet> {\n+  uint _elem_size;\n+  uint _num_elems;\n+\n+  G1CardSetBuffer* volatile _next;\n+\n+  char* _buffer;  \/\/ Actual data.\n+\n+  \/\/ Index into the next free block to allocate into. Full if equal (or larger)\n+  \/\/ to _num_elems (can be larger because we atomically increment this value and\n+  \/\/ check only afterwards if the allocation has been successful).\n+  uint volatile _next_allocate;\n+\n+public:\n+  G1CardSetBuffer(uint elem_size, uint num_elems, G1CardSetBuffer* next);\n+  ~G1CardSetBuffer();\n+\n+  G1CardSetBuffer* volatile* next_addr() { return &_next; }\n+\n+  void* get_new_buffer_elem();\n+\n+  uint num_elems() const { return _num_elems; }\n+\n+  G1CardSetBuffer* next() const { return _next; }\n+\n+  void set_next(G1CardSetBuffer* next) {\n+    assert(next != this, \" loop condition\");\n+    _next = next;\n+  }\n+\n+  void reset(G1CardSetBuffer* next) {\n+    _next_allocate = 0;\n+    assert(next != this, \" loop condition\");\n+    set_next(next);\n+    memset((void*)_buffer, 0, (size_t)_num_elems * _elem_size);\n+  }\n+\n+  uint elem_size() const { return _elem_size; }\n+\n+  size_t mem_size() const { return sizeof(*this) + (size_t)_num_elems * _elem_size; }\n+\n+  bool is_full() const { return _next_allocate >= _num_elems; }\n+};\n+\n+\/\/ Set of (free) G1CardSetBuffers. The assumed usage is that allocation\n+\/\/ to it and removal of elements is strictly separate, but every action may be\n+\/\/ performed by multiple threads at the same time.\n+\/\/ Counts and memory usage are current on a best-effort basis if accessed concurrently.\n+class G1CardSetBufferList {\n+  static G1CardSetBuffer* volatile* next_ptr(G1CardSetBuffer& node) {\n+    return node.next_addr();\n+  }\n+  typedef LockFreeStack<G1CardSetBuffer, &next_ptr> NodeStack;\n+\n+  NodeStack _list;\n+\n+  volatile size_t _num_buffers;\n+  volatile size_t _mem_size;\n+\n+public:\n+  G1CardSetBufferList() : _list(), _num_buffers(0), _mem_size(0) { }\n+  ~G1CardSetBufferList() { free_all(); }\n+\n+  void bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size);\n+  void add(G1CardSetBuffer& elem) { _list.prepend(elem); }\n+\n+  G1CardSetBuffer* get();\n+  G1CardSetBuffer* get_all(size_t& num_buffers, size_t& mem_size);\n+\n+  \/\/ Give back all memory to the OS.\n+  void free_all();\n+\n+  void print_on(outputStream* out, const char* prefix = \"\");\n+\n+  size_t num_buffers() const { return Atomic::load(&_num_buffers); }\n+  size_t mem_size() const { return Atomic::load(&_mem_size); }\n+};\n+\n+\/\/ Arena-like allocator for (card set) heap memory objects (Elem elements).\n+\/\/\n+\/\/ Actual allocation from the C heap occurs on G1CardSetBuffer basis, i.e. sets\n+\/\/ of elements. The assumed allocation pattern for these G1CardSetBuffer elements\n+\/\/ is assumed to be strictly two-phased:\n+\/\/\n+\/\/ - in the first phase, G1CardSetBuffers are allocated from the C heap (or a free\n+\/\/ list given at initialization time). This allocation may occur in parallel. This\n+\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n+\/\/\n+\/\/ - in the second phase, G1CardSetBuffers are given back in bulk to the free list.\n+\/\/ This is typically done during a GC pause.\n+\/\/\n+\/\/ Some third party is responsible for giving back memory from the free list to\n+\/\/ the operating system.\n+\/\/\n+\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n+\/\/ may occur by multiple threads at once.\n+\/\/\n+\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n+\/\/ only then trying to bump-allocate from the current G1CardSetBuffer. If there is\n+\/\/ none, this class allocates a new G1CardSetBuffer (allocated from the C heap,\n+\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n+\/\/\n+\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainers\n+\/\/ within all G1CardSetBuffer instances allocated so far. It uses a separate\n+\/\/ pending list and global synchronization to avoid the ABA problem when the\n+\/\/ user frees a memory object.\n+\/\/\n+\/\/ The class also manages a few counters for statistics using atomic operations.\n+\/\/ Their values are only consistent within each other with extra global\n+\/\/ synchronization.\n+\/\/\n+\/\/ Since it is expected that every CardSet (and in extension each region) has its\n+\/\/ own set of allocators, there is intentionally no padding between them to save\n+\/\/ memory.\n+template <class Elem>\n+class G1CardSetAllocator {\n+  \/\/ G1CardSetBuffer management.\n+\n+  \/\/ G1CardSetAllocOptions provides parameters for allocation buffer\n+  \/\/ sizing and expansion.\n+  G1CardSetAllocOptions _alloc_options;\n+\n+  G1CardSetBuffer* volatile _first;       \/\/ The (start of the) list of all buffers.\n+  G1CardSetBuffer* _last;                 \/\/ The last element of the list of all buffers.\n+  volatile uint _num_buffers;             \/\/ Number of assigned buffers to this allocator.\n+  volatile size_t _mem_size;              \/\/ Memory used by all buffers.\n+\n+  G1CardSetBufferList* _free_buffer_list; \/\/ The global free buffer list to\n+                                          \/\/ preferentially get new buffers from.\n+\n+  \/\/ G1CardSetContainer node management within the G1CardSetBuffers allocated\n+  \/\/ by this allocator.\n+\n+  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& node);\n+  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> NodeStack;\n+\n+  volatile bool _transfer_lock;\n+  NodeStack _free_nodes_list;\n+  NodeStack _pending_nodes_list;\n+\n+  volatile uint _num_pending_nodes;   \/\/ Number of nodes in the pending list.\n+  volatile uint _num_free_nodes;      \/\/ Number of nodes in the free list.\n+\n+  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n+  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n+\n+  \/\/ Try to transfer nodes from _pending_nodes_list to _free_nodes_list, with a\n+  \/\/ synchronization delay for any in-progress pops from the _free_nodes_list\n+  \/\/ to solve ABA here.\n+  bool try_transfer_pending();\n+\n+  uint num_free_elems() const;\n+\n+  G1CardSetBuffer* create_new_buffer(G1CardSetBuffer* const prev);\n+\n+  uint elem_size() const { return _alloc_options.elem_size(); }\n+\n+public:\n+  G1CardSetAllocator(const char* name,\n+                     const G1CardSetAllocOptions& buffer_options,\n+                     G1CardSetBufferList* free_buffer_list);\n+  ~G1CardSetAllocator() {\n+    drop_all();\n+  }\n+\n+  Elem* allocate();\n+  void free(Elem* elem);\n+\n+  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ be called in a globally synchronized area.\n+  void drop_all();\n+\n+  uint num_buffers() const;\n+\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      num_buffers() * sizeof(G1CardSetBuffer) + (size_t)_num_available_nodes * elem_size();\n+  }\n+\n+  size_t wasted_mem_size() const {\n+    return ((size_t)_num_available_nodes - (_num_allocated_nodes - _num_pending_nodes)) * elem_size();\n+  }\n+\n+  void print(outputStream* os);\n+};\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+  \/\/ For every element in the set (indicated by i), call fn to provide the\n+  \/\/ memory size and number of buffers for that i'th buffer list.\n+  G1CardSetMemoryStats(void (*fn)(const void* context, uint i, size_t& mem_size, size_t& num_buffers), const void* context);\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  \/\/ Return sizes for free list i in this free list pool.\n+  void get_size(uint i, size_t& mem_size, size_t& num_buffers) const;\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+class G1CardSetMemoryManager : public CHeapObj<mtGCCardSet> {\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+\n+  uint num_mem_object_types() const;\n+public:\n+  G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                         G1CardSetFreePool* free_list_pool);\n+\n+  virtual ~G1CardSetMemoryManager();\n+\n+  \/\/ Allocate and free a memory object of given type.\n+  inline uint8_t* allocate(uint type);\n+  void free(uint type, void* value);\n+\n+  \/\/ Allocate and free a hash table node.\n+  inline uint8_t* allocate_node();\n+  inline void free_node(void* value);\n+\n+  void flush();\n+\n+  void print(outputStream* os);\n+\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+\n+  G1CardSetMemoryStats memory_stats() const;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+template <class Elem>\n+G1CardSetContainer* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainer& node) {\n+  return node.next_addr();\n+}\n+\n+template <class Elem>\n+G1CardSetBuffer* G1CardSetAllocator<Elem>::create_new_buffer(G1CardSetBuffer* const prev) {\n+\n+  \/\/ Take an existing buffer if available.\n+  G1CardSetBuffer* next = _free_buffer_list->get();\n+  if (next == nullptr) {\n+    uint prev_num_elems = (prev != nullptr) ? prev->num_elems() : 0;\n+    uint num_elems = _alloc_options.next_num_elems(prev_num_elems);\n+    next = new G1CardSetBuffer(elem_size(), num_elems, prev);\n+  } else {\n+    assert(elem_size() == next->elem_size() , \"Mismatch %d != %d Elem %zu\", elem_size(), next->elem_size(), sizeof(Elem));\n+    next->reset(prev);\n+  }\n+\n+  \/\/ Install it as current allocation buffer.\n+  G1CardSetBuffer* old = Atomic::cmpxchg(&_first, prev, next);\n+  if (old != prev) {\n+    \/\/ Somebody else installed the buffer, use that one.\n+    delete next;\n+    return old;\n+  } else {\n+    \/\/ Did we install the first element in the list? If so, this is also the last.\n+    if (prev == nullptr) {\n+      _last = next;\n+    }\n+    \/\/ Successfully installed the buffer into the list.\n+    Atomic::inc(&_num_buffers, memory_order_relaxed);\n+    Atomic::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n+    Atomic::add(&_num_available_nodes, next->num_elems(), memory_order_relaxed);\n+    return next;\n+  }\n+}\n+\n+template <class Elem>\n+Elem* G1CardSetAllocator<Elem>::allocate() {\n+  assert(elem_size() > 0, \"instance size not set.\");\n+\n+  if (num_free_elems() > 0) {\n+    \/\/ Pop under critical section to deal with ABA problem\n+    \/\/ Other solutions to the same problem are more complicated (ref counting, HP)\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+\n+    G1CardSetContainer* node = _free_nodes_list.pop();\n+    if (node != nullptr) {\n+      Elem* elem = reinterpret_cast<Elem*>(reinterpret_cast<char*>(node));\n+      Atomic::sub(&_num_free_nodes, 1u);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+  }\n+\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+  if (cur == nullptr) {\n+    cur = create_new_buffer(cur);\n+  }\n+\n+  while (true) {\n+    Elem* elem = (Elem*)cur->get_new_buffer_elem();\n+    if (elem != nullptr) {\n+      Atomic::inc(&_num_allocated_nodes, memory_order_relaxed);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+    \/\/ The buffer is full. Next round.\n+    assert(cur->is_full(), \"must be\");\n+    cur = create_new_buffer(cur);\n+  }\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate(uint type) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  return (uint8_t*)_allocators[type].allocate();\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate_node() {\n+  return allocate(0);\n+}\n+\n+inline void G1CardSetMemoryManager::free_node(void* value) {\n+  free(0, value);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_buffers() const {\n+  return Atomic::load(&_num_buffers);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_free_elems() const {\n+  return Atomic::load(&_num_free_nodes);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-  inline size_t mark_region_dirty(size_t start_card_index, size_t num_cards);\n+  inline size_t mark_range_dirty(size_t start_card_index, size_t num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline size_t G1CardTable::mark_region_dirty(size_t start_card_index, size_t num_cards) {\n+inline size_t G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -71,1 +72,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -150,1 +151,1 @@\n-  return new HeapRegion(hrs_index, bot(), mr);\n+  return new HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n@@ -349,1 +350,1 @@\n-    g1mm()->update_sizes();\n+    monitoring_support()->update_sizes();\n@@ -982,1 +983,5 @@\n-void G1CollectedHeap::print_hrm_post_compaction() {\n+void G1CollectedHeap::print_heap_after_full_collection() {\n+  \/\/ Post collection region logging.\n+  \/\/ We should do this after we potentially resize the heap so\n+  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n+  \/\/ the compaction events.\n@@ -1026,0 +1031,3 @@\n+  if (!VerifyBeforeGC) {\n+    return;\n+  }\n@@ -1071,0 +1079,3 @@\n+  if (!VerifyAfterGC) {\n+    return;\n+  }\n@@ -1094,11 +1105,0 @@\n-void G1CollectedHeap::print_heap_after_full_collection(G1HeapTransition* heap_transition) {\n-  \/\/ Post collection logging.\n-  \/\/ We should do this after we potentially resize the heap so\n-  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n-  \/\/ the compaction events.\n-  print_hrm_post_compaction();\n-  heap_transition->print();\n-  print_heap_after_gc();\n-  print_heap_regions();\n-}\n-\n@@ -1439,0 +1439,1 @@\n+  _free_card_set_memory_task(NULL),\n@@ -1458,1 +1459,1 @@\n-  _g1mm(NULL),\n+  _monitoring_support(nullptr),\n@@ -1475,0 +1476,1 @@\n+  _card_set_config(),\n@@ -1480,1 +1482,1 @@\n-  _regions_failed_evacuation(NULL),\n+  _regions_failed_evacuation(mtGC),\n@@ -1744,0 +1746,3 @@\n+  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_card_set_memory_task);\n+\n@@ -1767,1 +1772,1 @@\n-  _g1mm = new G1MonitoringSupport(this);\n+  _monitoring_support = new G1MonitoringSupport(this);\n@@ -1773,1 +1778,1 @@\n-  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+  _regions_failed_evacuation.resize(max_regions());\n@@ -1780,0 +1785,4 @@\n+bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n+  return _cm_thread->should_terminate();\n+}\n+\n@@ -1842,0 +1851,2 @@\n+                           \/\/ We discover with the gc worker threads during Remark, so both\n+                           \/\/ thread counts must be considered for discovery.\n@@ -2569,3 +2580,0 @@\n-  \/\/ This summary needs to be printed before incrementing total collections.\n-  rem_set()->print_periodic_summary_info(\"Before GC RS summary\", total_collections());\n-\n@@ -2577,18 +2585,0 @@\n-\n-  \/\/ Fill TLAB's and such\n-  {\n-    Ticks start = Ticks::now();\n-    ensure_parsability(true);\n-    Tickspan dt = Ticks::now() - start;\n-    phase_times()->record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);\n-  }\n-\n-  if (!full) {\n-    \/\/ Flush dirty card queues to qset, so later phases don't need to account\n-    \/\/ for partially filled per-thread queues and such.  Not needed for full\n-    \/\/ collections, which ignore those logs.\n-    Ticks start = Ticks::now();\n-    G1BarrierSet::dirty_card_queue_set().concatenate_logs();\n-    Tickspan dt = Ticks::now() - start;\n-    phase_times()->record_concatenate_dirty_card_logs_time_ms(dt.seconds() * MILLIUNITS);\n-  }\n@@ -2604,3 +2594,0 @@\n-  \/\/ We are at the end of the GC. Total collections has already been increased.\n-  rem_set()->print_periodic_summary_info(\"After GC RS summary\", total_collections() - 1);\n-\n@@ -2611,5 +2598,0 @@\n-  double start = os::elapsedTime();\n-  resize_all_tlabs();\n-  phase_times()->record_resize_tlab_time_ms((os::elapsedTime() - start) * 1000.0);\n-\n-  MemoryService::track_memory_usage();\n@@ -2620,3 +2602,0 @@\n-  \/\/ Print NUMA statistics.\n-  _numa->print_statistics();\n-\n@@ -2624,0 +2603,3 @@\n+\n+  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                               &_collection_set_candidates_card_set_stats);\n@@ -2808,1 +2790,4 @@\n-void G1CollectedHeap::calculate_collection_set(G1EvacuationInfo& evacuation_info, double target_pause_time_ms) {\n+void G1CollectedHeap::calculate_collection_set(G1EvacuationInfo* evacuation_info, double target_pause_time_ms) {\n+  \/\/ Forget the current allocation region (we might even choose it to be part\n+  \/\/ of the collection set!) before finalizing the collection set.\n+  _allocator->release_mutator_alloc_regions();\n@@ -2811,1 +2796,1 @@\n-  evacuation_info.set_collectionset_regions(collection_set()->region_length() +\n+  evacuation_info->set_collectionset_regions(collection_set()->region_length() +\n@@ -2834,0 +2819,6 @@\n+  if (!VerifyBeforeGC) {\n+    return;\n+  }\n+  Ticks start = Ticks::now();\n+  _verifier->verify_region_sets_optional();\n+  _verifier->verify_dirty_young_regions();\n@@ -2842,0 +2833,1 @@\n+  phase_times()->record_verify_before_time_ms((Ticks::now() - start).seconds() * MILLIUNITS);\n@@ -2845,0 +2837,8 @@\n+  if (!VerifyAfterGC) {\n+    return;\n+  }\n+  Ticks start = Ticks::now();\n+  \/\/ Inject evacuation failure tag into type if needed.\n+  if (evacuation_failed()) {\n+    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+  }\n@@ -2853,0 +2853,2 @@\n+  _verifier->verify_region_sets_optional();\n+  phase_times()->record_verify_after_time_ms((Ticks::now() - start).seconds() * MILLIUNITS);\n@@ -2868,11 +2870,0 @@\n-void G1CollectedHeap::set_young_gc_name(char* young_gc_name) {\n-  G1GCPauseType pause_type =\n-    \/\/ The strings for all Concurrent Start pauses are the same, so the parameter\n-    \/\/ does not matter here.\n-    collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/);\n-  snprintf(young_gc_name,\n-           MaxYoungGCNameLength,\n-           \"Pause Young (%s)\",\n-           G1GCPauseTypeHelper::to_string(pause_type));\n-}\n-\n@@ -2891,4 +2882,7 @@\n-void G1CollectedHeap::gc_tracer_report_gc_start() {\n-  _gc_timer_stw->register_gc_start();\n-  _gc_tracer_stw->report_gc_start(gc_cause(), _gc_timer_stw->gc_start());\n-}\n+\/\/ GCTraceTime wrapper that constructs the message according to GC pause type and\n+\/\/ GC cause.\n+\/\/ The code relies on the fact that GCTraceTimeWrapper stores the string passed\n+\/\/ initially as a reference only, so that we can modify it as needed.\n+class G1YoungGCTraceTime {\n+  G1GCPauseType _pause_type;\n+  GCCause::Cause _pause_cause;\n@@ -2896,4 +2890,2 @@\n-void G1CollectedHeap::gc_tracer_report_gc_end(bool concurrent_operation_is_full_mark,\n-                                              G1EvacuationInfo& evacuation_info) {\n-  _gc_tracer_stw->report_evacuation_info(&evacuation_info);\n-  _gc_tracer_stw->report_tenuring_threshold(_policy->tenuring_threshold());\n+  static const uint MaxYoungGCNameLength = 128;\n+  char _young_gc_name_data[MaxYoungGCNameLength];\n@@ -2901,4 +2893,1 @@\n-  _gc_timer_stw->register_gc_end();\n-  _gc_tracer_stw->report_gc_end(_gc_timer_stw->gc_end(),\n-  _gc_timer_stw->time_partitions());\n-}\n+  GCTraceTime(Info, gc) _tt;\n@@ -2906,5 +2895,9 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper(double target_pause_time_ms) {\n-  GCIdMark gc_id_mark;\n-\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-  ResourceMark rm;\n+  const char* update_young_gc_name() {\n+    snprintf(_young_gc_name_data,\n+             MaxYoungGCNameLength,\n+             \"Pause Young (%s) (%s)%s\",\n+             G1GCPauseTypeHelper::to_string(_pause_type),\n+             GCCause::to_string(_pause_cause),\n+             G1CollectedHeap::heap()->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+    return _young_gc_name_data;\n+  }\n@@ -2912,1 +2905,11 @@\n-  policy()->note_gc_start();\n+public:\n+  G1YoungGCTraceTime(GCCause::Cause cause) :\n+    \/\/ Take snapshot of current pause type at start as it may be modified during gc.\n+    \/\/ The strings for all Concurrent Start pauses are the same, so the parameter\n+    \/\/ does not matter here.\n+    _pause_type(G1CollectedHeap::heap()->collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/)),\n+    _pause_cause(cause),\n+    \/\/ Fake a \"no cause\" and manually add the correct string in update_young_gc_name()\n+    \/\/ to make the string look more natural.\n+    _tt(update_young_gc_name(), NULL, GCCause::_no_gc, true) {\n+  }\n@@ -2914,1 +2917,4 @@\n-  gc_tracer_report_gc_start();\n+  ~G1YoungGCTraceTime() {\n+    update_young_gc_name();\n+  }\n+};\n@@ -2916,1 +2922,2 @@\n-  wait_for_root_region_scanning();\n+class G1YoungGCVerifierMark : public StackObj {\n+  G1HeapVerifier::G1VerifyType _type;\n@@ -2918,3 +2925,10 @@\n-  print_heap_before_gc();\n-  print_heap_regions();\n-  trace_heap_before_gc(_gc_tracer_stw);\n+  static G1HeapVerifier::G1VerifyType young_collection_verify_type() {\n+    G1CollectorState* state = G1CollectedHeap::heap()->collector_state();\n+    if (state->in_concurrent_start_gc()) {\n+      return G1HeapVerifier::G1VerifyConcurrentStart;\n+    } else if (state->in_young_only_phase()) {\n+      return G1HeapVerifier::G1VerifyYoungNormal;\n+    } else {\n+      return G1HeapVerifier::G1VerifyMixed;\n+    }\n+  }\n@@ -2922,2 +2936,4 @@\n-  _verifier->verify_region_sets_optional();\n-  _verifier->verify_dirty_young_regions();\n+public:\n+  G1YoungGCVerifierMark() : _type(young_collection_verify_type()) {\n+    G1CollectedHeap::heap()->verify_before_young_collection(_type);\n+  }\n@@ -2925,6 +2941,2 @@\n-  \/\/ We should not be doing concurrent start unless the concurrent mark thread is running\n-  if (!_cm_thread->should_terminate()) {\n-    \/\/ This call will decide whether this pause is a concurrent start\n-    \/\/ pause. If it is, in_concurrent_start_gc() will return true\n-    \/\/ for the duration of this pause.\n-    policy()->decide_on_conc_mark_initiation();\n+  ~G1YoungGCVerifierMark() {\n+    G1CollectedHeap::heap()->verify_after_young_collection(_type);\n@@ -2932,0 +2944,1 @@\n+};\n@@ -2933,5 +2946,5 @@\n-  \/\/ We do not allow concurrent start to be piggy-backed on a mixed GC.\n-  assert(!collector_state()->in_concurrent_start_gc() ||\n-         collector_state()->in_young_only_phase(), \"sanity\");\n-  \/\/ We also do not allow mixed GCs during marking.\n-  assert(!collector_state()->mark_or_rebuild_in_progress() || collector_state()->in_young_only_phase(), \"sanity\");\n+class G1YoungGCNotifyPauseMark : public StackObj {\n+public:\n+  G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_start(); }\n+  ~G1YoungGCNotifyPauseMark() { G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(); }\n+};\n@@ -2939,5 +2952,6 @@\n-  \/\/ Record whether this pause may need to trigger a concurrent operation. Later,\n-  \/\/ when we signal the G1ConcurrentMarkThread, the collector state has already\n-  \/\/ been reset for the next pause.\n-  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n-  bool concurrent_operation_is_full_mark = false;\n+G1HeapPrinterMark::G1HeapPrinterMark(G1CollectedHeap* g1h) : _g1h(g1h), _heap_transition(g1h) {\n+  \/\/ This summary needs to be printed before incrementing total collections.\n+  _g1h->rem_set()->print_periodic_summary_info(\"Before GC RS summary\", _g1h->total_collections());\n+  _g1h->print_heap_before_gc();\n+  _g1h->print_heap_regions();\n+}\n@@ -2945,3 +2959,5 @@\n-  \/\/ Inner scope for scope based logging, timers, and stats collection\n-  {\n-    G1EvacuationInfo evacuation_info;\n+G1HeapPrinterMark::~G1HeapPrinterMark() {\n+  _g1h->policy()->print_age_table();\n+  _g1h->rem_set()->print_coarsen_stats();\n+  \/\/ We are at the end of the GC. Total collections has already been increased.\n+  _g1h->rem_set()->print_periodic_summary_info(\"After GC RS summary\", _g1h->total_collections() - 1);\n@@ -2949,1 +2965,6 @@\n-    GCTraceCPUTime tcpu;\n+  _heap_transition.print();\n+  _g1h->print_heap_regions();\n+  _g1h->print_heap_after_gc();\n+  \/\/ Print NUMA statistics.\n+  _g1h->numa()->print_statistics();\n+}\n@@ -2951,2 +2972,2 @@\n-    char young_gc_name[MaxYoungGCNameLength];\n-    set_young_gc_name(young_gc_name);\n+G1JFRTracerMark::G1JFRTracerMark(STWGCTimer* timer, GCTracer* tracer) :\n+  _timer(timer), _tracer(tracer) {\n@@ -2954,1 +2975,4 @@\n-    GCTraceTime(Info, gc) tm(young_gc_name, NULL, gc_cause(), true);\n+  _timer->register_gc_start();\n+  _tracer->report_gc_start(G1CollectedHeap::heap()->gc_cause(), _timer->gc_start());\n+  G1CollectedHeap::heap()->trace_heap_before_gc(_tracer);\n+}\n@@ -2956,5 +2980,5 @@\n-    uint active_workers = WorkerPolicy::calc_active_workers(workers()->total_workers(),\n-                                                            workers()->active_workers(),\n-                                                            Threads::number_of_non_daemon_threads());\n-    active_workers = workers()->update_active_workers(active_workers);\n-    log_info(gc,task)(\"Using %u workers of %u for evacuation\", active_workers, workers()->total_workers());\n+G1JFRTracerMark::~G1JFRTracerMark() {\n+  G1CollectedHeap::heap()->trace_heap_after_gc(_tracer);\n+  _timer->register_gc_end();\n+  _tracer->report_gc_end(_timer->gc_end(), _timer->time_partitions());\n+}\n@@ -2962,3 +2986,2 @@\n-    G1MonitoringScope ms(g1mm(),\n-                         false \/* full_gc *\/,\n-                         collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n+class G1YoungGCJFRTracerMark : public G1JFRTracerMark {\n+  G1EvacuationInfo _evacuation_info;\n@@ -2966,1 +2989,1 @@\n-    G1HeapTransition heap_transition(this);\n+  G1NewTracer* tracer() const { return (G1NewTracer*)_tracer; }\n@@ -2968,2 +2991,1 @@\n-    {\n-      IsGCActiveMark x;\n+public:\n@@ -2971,1 +2993,1 @@\n-      gc_prologue(false);\n+  G1EvacuationInfo* evacuation_info() { return &_evacuation_info; }\n@@ -2973,2 +2995,2 @@\n-      G1HeapVerifier::G1VerifyType verify_type = young_collection_verify_type();\n-      verify_before_young_collection(verify_type);\n+  G1YoungGCJFRTracerMark(STWGCTimer* gc_timer_stw, G1NewTracer* gc_tracer_stw, GCCause::Cause cause) :\n+    G1JFRTracerMark(gc_timer_stw, gc_tracer_stw), _evacuation_info() { }\n@@ -2976,4 +2998,3 @@\n-      {\n-        \/\/ The elapsed time induced by the start time below deliberately elides\n-        \/\/ the possible verification above.\n-        double sample_start_time_sec = os::elapsedTime();\n+  void report_pause_type(G1GCPauseType type) {\n+    tracer()->report_young_gc_pause(type);\n+  }\n@@ -2981,4 +3002,2 @@\n-        \/\/ Please see comment in g1CollectedHeap.hpp and\n-        \/\/ G1CollectedHeap::ref_processing_init() to see how\n-        \/\/ reference processing currently works in G1.\n-        _ref_processor_stw->enable_discovery();\n+  ~G1YoungGCJFRTracerMark() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -2986,5 +3005,4 @@\n-        \/\/ We want to temporarily turn off discovery by the\n-        \/\/ CM ref processor, if necessary, and turn it back on\n-        \/\/ on again later if we do. Using a scoped\n-        \/\/ NoRefDiscovery object will do this.\n-        NoRefDiscovery no_cm_discovery(_ref_processor_cm);\n+    tracer()->report_evacuation_info(&_evacuation_info);\n+    tracer()->report_tenuring_threshold(g1h->policy()->tenuring_threshold());\n+  }\n+};\n@@ -2992,1 +3010,7 @@\n-        policy()->record_collection_pause_start(sample_start_time_sec);\n+void G1CollectedHeap::set_young_collection_default_active_worker_threads(){\n+  uint active_workers = WorkerPolicy::calc_active_workers(workers()->total_workers(),\n+                                                          workers()->active_workers(),\n+                                                          Threads::number_of_non_daemon_threads());\n+  active_workers = workers()->update_active_workers(active_workers);\n+  log_info(gc,task)(\"Using %u workers of %u for evacuation\", active_workers, workers()->total_workers());\n+}\n@@ -2994,3 +3018,2 @@\n-        \/\/ Forget the current allocation region (we might even choose it to be part\n-        \/\/ of the collection set!).\n-        _allocator->release_mutator_alloc_regions();\n+void G1CollectedHeap::prepare_tlabs_for_mutator() {\n+  Ticks start = Ticks::now();\n@@ -2998,1 +3021,2 @@\n-        calculate_collection_set(evacuation_info, target_pause_time_ms);\n+  _survivor_evac_stats.adjust_desired_plab_sz();\n+  _old_evac_stats.adjust_desired_plab_sz();\n@@ -3000,7 +3024,1 @@\n-        G1RedirtyCardsQueueSet rdcqs(G1BarrierSet::dirty_card_queue_set().allocator());\n-        G1ParScanThreadStateSet per_thread_states(this,\n-                                                  &rdcqs,\n-                                                  workers()->active_workers(),\n-                                                  collection_set()->young_region_length(),\n-                                                  collection_set()->optional_region_length());\n-        pre_evacuate_collection_set(evacuation_info, &per_thread_states);\n+  allocate_dummy_regions();\n@@ -3008,3 +3026,1 @@\n-        bool may_do_optional_evacuation = _collection_set.optional_region_length() != 0;\n-        \/\/ Actually do the work...\n-        evacuate_initial_collection_set(&per_thread_states, may_do_optional_evacuation);\n+  _allocator->init_mutator_alloc_regions();\n@@ -3012,4 +3028,8 @@\n-        if (may_do_optional_evacuation) {\n-          evacuate_optional_collection_set(&per_thread_states);\n-        }\n-        post_evacuate_collection_set(evacuation_info, &rdcqs, &per_thread_states);\n+  resize_all_tlabs();\n+\n+  phase_times()->record_resize_tlab_time_ms((Ticks::now() - start).seconds() * 1000.0);\n+}\n+\n+void G1CollectedHeap::retire_tlabs() {\n+  ensure_parsability(true);\n+}\n@@ -3017,1 +3037,2 @@\n-        start_new_collection_set();\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(double target_pause_time_ms) {\n+  ResourceMark rm;\n@@ -3019,2 +3040,3 @@\n-        _survivor_evac_stats.adjust_desired_plab_sz();\n-        _old_evac_stats.adjust_desired_plab_sz();\n+  IsGCActiveMark active_gc_mark;\n+  GCIdMark gc_id_mark;\n+  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n@@ -3022,1 +3044,1 @@\n-        allocate_dummy_regions();\n+  GCTraceCPUTime tcpu;\n@@ -3024,1 +3046,6 @@\n-        _allocator->init_mutator_alloc_regions();\n+  policy()->decide_on_concurrent_start_pause();\n+  \/\/ Record whether this pause may need to trigger a concurrent operation. Later,\n+  \/\/ when we signal the G1ConcurrentMarkThread, the collector state has already\n+  \/\/ been reset for the next pause.\n+  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n+  bool concurrent_operation_is_full_mark = false;\n@@ -3026,1 +3053,3 @@\n-        expand_heap_after_young_collection();\n+  \/\/ Verification may use the gang workers, so they must be set up before.\n+  \/\/ Individual parallel phases may override this.\n+  set_young_collection_default_active_worker_threads();\n@@ -3028,3 +3057,17 @@\n-        \/\/ Refine the type of a concurrent mark operation now that we did the\n-        \/\/ evacuation, eventually aborting it.\n-        concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n+  {\n+    \/\/ Do timing\/tracing\/statistics\/pre- and post-logging\/verification work not\n+    \/\/ directly related to the collection. They should not be accounted for in\n+    \/\/ collection work timing.\n+\n+    \/\/ The G1YoungGCTraceTime message depends on collector state, so must come after\n+    \/\/ determining collector state.\n+    G1YoungGCTraceTime tm(gc_cause());\n+\n+    \/\/ Young GC internal pause timing\n+    G1YoungGCNotifyPauseMark npm;\n+    \/\/ JFR\n+    G1YoungGCJFRTracerMark jtm(_gc_timer_stw, _gc_tracer_stw, gc_cause());\n+    \/\/ JStat\/MXBeans\n+    G1MonitoringScope ms(monitoring_support(),\n+                         false \/* full_gc *\/,\n+                         collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n@@ -3032,3 +3075,1 @@\n-        \/\/ Need to report the collection pause now since record_collection_pause_end()\n-        \/\/ modifies it to the next state.\n-        _gc_tracer_stw->report_young_gc_pause(collector_state()->young_gc_pause_type(concurrent_operation_is_full_mark));\n+    G1HeapPrinterMark hpm(this);\n@@ -3036,4 +3077,4 @@\n-        double sample_end_time_sec = os::elapsedTime();\n-        double pause_time_ms = (sample_end_time_sec - sample_start_time_sec) * MILLIUNITS;\n-        policy()->record_collection_pause_end(pause_time_ms, concurrent_operation_is_full_mark);\n-      }\n+    \/\/ Wait for root region scan here to make sure that it is done before any\n+    \/\/ use of the STW work gang to maximize cpu use (i.e. all cores are available\n+    \/\/ just to do that).\n+    wait_for_root_region_scanning();\n@@ -3041,1 +3082,3 @@\n-      verify_after_young_collection(verify_type);\n+    G1YoungGCVerifierMark vm;\n+    {\n+      \/\/ Actual collection work starts and is executed (only) in this scope.\n@@ -3043,2 +3086,4 @@\n-      gc_epilogue(false);\n-    }\n+      \/\/ Young GC internal collection timing. The elapsed time recorded in the\n+      \/\/ policy for the collection deliberately elides verification (and some\n+      \/\/ other trivial setup above).\n+      policy()->record_young_collection_start();\n@@ -3046,4 +3091,1 @@\n-    \/\/ Print the remainder of the GC log output.\n-    if (evacuation_failed()) {\n-      log_info(gc)(\"To-space exhausted\");\n-    }\n+      calculate_collection_set(jtm.evacuation_info(), target_pause_time_ms);\n@@ -3051,2 +3093,7 @@\n-    policy()->print_phases();\n-    heap_transition.print();\n+      G1RedirtyCardsQueueSet rdcqs(G1BarrierSet::dirty_card_queue_set().allocator());\n+      G1ParScanThreadStateSet per_thread_states(this,\n+                                                &rdcqs,\n+                                                workers()->active_workers(),\n+                                                collection_set()->young_region_length(),\n+                                                collection_set()->optional_region_length());\n+      pre_evacuate_collection_set(jtm.evacuation_info(), &per_thread_states);\n@@ -3054,2 +3101,3 @@\n-    _hrm.verify_optional();\n-    _verifier->verify_region_sets_optional();\n+      bool may_do_optional_evacuation = _collection_set.optional_region_length() != 0;\n+      \/\/ Actually do the work...\n+      evacuate_initial_collection_set(&per_thread_states, may_do_optional_evacuation);\n@@ -3057,2 +3105,4 @@\n-    TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n-    TASKQUEUE_STATS_ONLY(reset_taskqueue_stats());\n+      if (may_do_optional_evacuation) {\n+        evacuate_optional_collection_set(&per_thread_states);\n+      }\n+      post_evacuate_collection_set(jtm.evacuation_info(), &rdcqs, &per_thread_states);\n@@ -3060,3 +3110,3 @@\n-    print_heap_after_gc();\n-    print_heap_regions();\n-    trace_heap_after_gc(_gc_tracer_stw);\n+      \/\/ Refine the type of a concurrent mark operation now that we did the\n+      \/\/ evacuation, eventually aborting it.\n+      concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n@@ -3064,5 +3114,3 @@\n-    \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-    \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-    \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-    \/\/ before any GC notifications are raised.\n-    g1mm()->update_sizes();\n+      \/\/ Need to report the collection pause now since record_collection_pause_end()\n+      \/\/ modifies it to the next state.\n+      jtm.report_pause_type(collector_state()->young_gc_pause_type(concurrent_operation_is_full_mark));\n@@ -3070,1 +3118,4 @@\n-    gc_tracer_report_gc_end(concurrent_operation_is_full_mark, evacuation_info);\n+      policy()->record_young_collection_end(concurrent_operation_is_full_mark);\n+    }\n+    TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+    TASKQUEUE_STATS_ONLY(reset_taskqueue_stats());\n@@ -3075,1 +3126,0 @@\n-\n@@ -3204,23 +3254,0 @@\n-\/\/ Serial drain queue closure. Called as the 'complete_gc'\n-\/\/ closure for each discovered list in some of the\n-\/\/ reference processing phases.\n-\n-class G1STWDrainQueueClosure: public VoidClosure {\n-protected:\n-  G1CollectedHeap* _g1h;\n-  G1ParScanThreadState* _par_scan_state;\n-\n-  G1ParScanThreadState*   par_scan_state() { return _par_scan_state; }\n-\n-public:\n-  G1STWDrainQueueClosure(G1CollectedHeap* g1h, G1ParScanThreadState* pss) :\n-    _g1h(g1h),\n-    _par_scan_state(pss)\n-  { }\n-\n-  void do_void() {\n-    G1ParScanThreadState* const pss = par_scan_state();\n-    pss->trim_queue();\n-  }\n-};\n-\n@@ -3244,1 +3271,4 @@\n-    _pss.state_for_worker(index)->set_ref_discoverer(nullptr);\n+\n+    G1ParScanThreadState* pss = _pss.state_for_worker(index);\n+    pss->set_ref_discoverer(nullptr);\n+\n@@ -3246,2 +3276,2 @@\n-    G1CopyingKeepAliveClosure keep_alive(&_g1h, _pss.state_for_worker(index));\n-    G1ParEvacuateFollowersClosure complete_gc(&_g1h, _pss.state_for_worker(index), &_task_queues, _tm == RefProcThreadModel::Single ? nullptr : &_terminator, G1GCPhaseTimes::ObjCopy);\n+    G1CopyingKeepAliveClosure keep_alive(&_g1h, pss);\n+    G1ParEvacuateFollowersClosure complete_gc(&_g1h, pss, &_task_queues, _tm == RefProcThreadModel::Single ? nullptr : &_terminator, G1GCPhaseTimes::ObjCopy);\n@@ -3249,0 +3279,3 @@\n+\n+    \/\/ We have completed copying any necessary live referent objects.\n+    assert(pss->queue_is_empty(), \"both queue and overflow should be empty\");\n@@ -3259,1 +3292,1 @@\n-  double ref_proc_start = os::elapsedTime();\n+  Ticks start = Ticks::now();\n@@ -3264,11 +3297,0 @@\n-  \/\/ Use only a single queue for this PSS.\n-  G1ParScanThreadState*          pss = per_thread_states->state_for_worker(0);\n-  pss->set_ref_discoverer(NULL);\n-  assert(pss->queue_is_empty(), \"pre-condition\");\n-\n-  \/\/ Setup the soft refs policy...\n-  rp->setup_policy(false);\n-\n-  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n-\n-  ReferenceProcessorStats stats;\n@@ -3276,6 +3298,0 @@\n-\n-  \/\/ Parallel reference processing\n-  assert(no_of_gc_workers <= rp->max_num_queues(),\n-         \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n-         no_of_gc_workers,  rp->max_num_queues());\n-\n@@ -3283,0 +3299,1 @@\n+\n@@ -3284,1 +3301,2 @@\n-  stats = rp->process_discovered_references(task, pt);\n+  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n+  ReferenceProcessorStats stats = rp->process_discovered_references(task, pt);\n@@ -3288,3 +3306,0 @@\n-  \/\/ We have completed copying any necessary live referent objects.\n-  assert(pss->queue_is_empty(), \"both queue and overflow should be empty\");\n-\n@@ -3293,1 +3308,0 @@\n-  assert(!rp->discovery_enabled(), \"Postcondition\");\n@@ -3296,2 +3310,1 @@\n-  double ref_proc_time = os::elapsedTime() - ref_proc_start;\n-  phase_times()->record_ref_proc_time(ref_proc_time * 1000.0);\n+  phase_times()->record_ref_proc_time((Ticks::now() - start).seconds() * MILLIUNITS);\n@@ -3322,0 +3335,9 @@\n+bool G1CollectedHeap::should_sample_collection_set_candidates() const {\n+  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n+  return candidates != NULL && candidates->num_remaining() > 0;\n+}\n+\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+  _collection_set_candidates_card_set_stats = stats;\n+}\n+\n@@ -3329,0 +3351,11 @@\n+    G1CardSetMemoryStats _card_set_stats;\n+\n+    void sample_card_set_size(HeapRegion* hr) {\n+      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n+      \/\/ the policy to give back memory to the OS keep the most recent amount of\n+      \/\/ memory for these regions.\n+      if (hr->is_young() || hr->is_starts_humongous()) {\n+        _card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n+      }\n+    }\n+\n@@ -3401,0 +3434,2 @@\n+      sample_card_set_size(hr);\n+\n@@ -3431,0 +3466,4 @@\n+\n+    G1CardSetMemoryStats card_set_stats() const {\n+      return _card_set_stats;\n+    }\n@@ -3437,0 +3476,3 @@\n+\n+  G1CardSetMemoryStats _all_card_set_stats;\n+\n@@ -3448,0 +3490,3 @@\n+\n+    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    _all_card_set_stats.add(cl.card_set_stats());\n@@ -3465,0 +3510,4 @@\n+\n+  G1CardSetMemoryStats all_card_set_stats() const {\n+    return _all_card_set_stats;\n+  }\n@@ -3467,1 +3516,6 @@\n-void G1CollectedHeap::pre_evacuate_collection_set(G1EvacuationInfo& evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n+void G1CollectedHeap::pre_evacuate_collection_set(G1EvacuationInfo* evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n+  \/\/ Please see comment in g1CollectedHeap.hpp and\n+  \/\/ G1CollectedHeap::ref_processing_init() to see how\n+  \/\/ reference processing currently works in G1.\n+  _ref_processor_stw->start_discovery(false \/* always_clear *\/);\n+\n@@ -3473,1 +3527,18 @@\n-  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n+  gc_prologue(false);\n+\n+  {\n+    Ticks start = Ticks::now();\n+    retire_tlabs();\n+    phase_times()->record_prepare_tlab_time_ms((Ticks::now() - start).seconds() * 1000.0);\n+  }\n+\n+  {\n+    \/\/ Flush dirty card queues to qset, so later phases don't need to account\n+    \/\/ for partially filled per-thread queues and such.\n+    Ticks start = Ticks::now();\n+    G1BarrierSet::dirty_card_queue_set().concatenate_logs();\n+    Tickspan dt = Ticks::now() - start;\n+    phase_times()->record_concatenate_dirty_card_logs_time_ms(dt.seconds() * MILLIUNITS);\n+  }\n+\n+  _regions_failed_evacuation.clear();\n@@ -3492,0 +3563,2 @@\n+    _young_gen_card_set_stats = g1_prep_task.all_card_set_stats();\n+\n@@ -3701,1 +3774,1 @@\n-  const double gc_start_time_ms = phase_times()->cur_collection_start_sec() * 1000.0;\n+  const double collection_start_time_ms = phase_times()->cur_collection_start_sec() * 1000.0;\n@@ -3705,1 +3778,1 @@\n-    double time_used_ms = os::elapsedTime() * 1000.0 - gc_start_time_ms;\n+    double time_used_ms = os::elapsedTime() * 1000.0 - collection_start_time_ms;\n@@ -3733,1 +3806,1 @@\n-void G1CollectedHeap::post_evacuate_collection_set(G1EvacuationInfo& evacuation_info,\n+void G1CollectedHeap::post_evacuate_collection_set(G1EvacuationInfo* evacuation_info,\n@@ -3754,1 +3827,1 @@\n-  post_evacuate_cleanup_2(&_preserved_marks_set, rdcqs, &evacuation_info, per_thread_states->surviving_young_words());\n+  post_evacuate_cleanup_2(&_preserved_marks_set, rdcqs, evacuation_info, per_thread_states->surviving_young_words());\n@@ -3762,2 +3835,4 @@\n-  evacuation_info.set_collectionset_used_before(collection_set()->bytes_used_before());\n-  evacuation_info.set_bytes_used(_bytes_used_during_gc);\n+  evacuation_info->set_collectionset_used_before(collection_set()->bytes_used_before());\n+  evacuation_info->set_bytes_used(_bytes_used_during_gc);\n+\n+  start_new_collection_set();\n@@ -3765,1 +3840,5 @@\n-  policy()->print_age_table();\n+  prepare_tlabs_for_mutator();\n+\n+  gc_epilogue(false);\n+\n+  expand_heap_after_young_collection();\n@@ -4078,1 +4157,1 @@\n-  g1mm()->update_eden_size();\n+  monitoring_support()->update_eden_size();\n@@ -4165,2 +4244,6 @@\n-  template <class T> void do_oop_work(T* p) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n+public:\n+  RegisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :\n+    _g1h(g1h), _nm(nm) {}\n+\n+  void do_oop(oop* p) {\n+    oop heap_oop = RawAccess<>::oop_load(p);\n@@ -4180,6 +4263,1 @@\n-public:\n-  RegisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :\n-    _g1h(g1h), _nm(nm) {}\n-\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n@@ -4192,2 +4270,6 @@\n-  template <class T> void do_oop_work(T* p) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n+public:\n+  UnregisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :\n+    _g1h(g1h), _nm(nm) {}\n+\n+  void do_oop(oop* p) {\n+    oop heap_oop = RawAccess<>::oop_load(p);\n@@ -4206,6 +4288,1 @@\n-public:\n-  UnregisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :\n-    _g1h(g1h), _nm(nm) {}\n-\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n@@ -4280,1 +4357,1 @@\n-  _g1mm->initialize_serviceability();\n+  _monitoring_support->initialize_serviceability();\n@@ -4284,1 +4361,1 @@\n-  return _g1mm->memory_usage();\n+  return _monitoring_support->memory_usage();\n@@ -4288,1 +4365,1 @@\n-  return _g1mm->memory_managers();\n+  return _monitoring_support->memory_managers();\n@@ -4292,1 +4369,1 @@\n-  return _g1mm->memory_pools();\n+  return _monitoring_support->memory_pools();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":355,"deletions":278,"binary":false,"changes":633,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"utilities\/bitMap.hpp\"\n@@ -68,0 +71,1 @@\n+class G1CardSetFreeMemoryTask;\n@@ -145,0 +149,2 @@\n+  friend class G1YoungGCVerifierMark;\n+\n@@ -152,0 +158,1 @@\n+  friend class G1HeapPrinterMark;\n@@ -160,0 +167,1 @@\n+  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n@@ -175,0 +183,5 @@\n+  \/\/ Young gen memory statistics before GC.\n+  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  \/\/ Collection set candidates memory statistics after GC.\n+  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+\n@@ -238,1 +251,1 @@\n-  G1MonitoringSupport* _g1mm;\n+  G1MonitoringSupport* _monitoring_support;\n@@ -269,0 +282,3 @@\n+  bool should_sample_collection_set_candidates() const;\n+  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n+\n@@ -307,4 +323,0 @@\n-  \/\/ If the HR printer is active, dump the state of the regions in the\n-  \/\/ heap after a compaction.\n-  void print_hrm_post_compaction();\n-\n@@ -386,5 +398,0 @@\n-  static const uint MaxYoungGCNameLength = 128;\n-  \/\/ Sets given young_gc_name to the canonical young gc pause string. Young_gc_name\n-  \/\/ must be at least of length MaxYoungGCNameLength.\n-  void set_young_gc_name(char* young_gc_name);\n-\n@@ -399,3 +406,0 @@\n-  void gc_tracer_report_gc_start();\n-  void gc_tracer_report_gc_end(bool concurrent_operation_is_full_mark, G1EvacuationInfo& evacuation_info);\n-\n@@ -532,1 +536,1 @@\n-  void print_heap_after_full_collection(G1HeapTransition* heap_transition);\n+  void print_heap_after_full_collection();\n@@ -576,3 +580,3 @@\n-  G1MonitoringSupport* g1mm() {\n-    assert(_g1mm != NULL, \"should have been initialized\");\n-    return _g1mm;\n+  G1MonitoringSupport* monitoring_support() {\n+    assert(_monitoring_support != nullptr, \"should have been initialized\");\n+    return _monitoring_support;\n@@ -798,0 +802,6 @@\n+  void set_young_collection_default_active_worker_threads();\n+\n+  void prepare_tlabs_for_mutator();\n+\n+  void retire_tlabs();\n+\n@@ -802,1 +812,1 @@\n-  void calculate_collection_set(G1EvacuationInfo& evacuation_info, double target_pause_time_ms);\n+  void calculate_collection_set(G1EvacuationInfo* evacuation_info, double target_pause_time_ms);\n@@ -828,2 +838,2 @@\n-  void pre_evacuate_collection_set(G1EvacuationInfo& evacuation_info, G1ParScanThreadStateSet* pss);\n-  void post_evacuate_collection_set(G1EvacuationInfo& evacuation_info,\n+  void pre_evacuate_collection_set(G1EvacuationInfo* evacuation_info, G1ParScanThreadStateSet* pss);\n+  void post_evacuate_collection_set(G1EvacuationInfo* evacuation_info,\n@@ -842,0 +852,2 @@\n+  \/\/ Global card set configuration\n+  G1CardSetConfiguration _card_set_config;\n@@ -871,1 +883,1 @@\n-  volatile bool* _regions_failed_evacuation;\n+  CHeapBitMap _regions_failed_evacuation;\n@@ -916,3 +928,1 @@\n-  \/\/ G1 has 2 instances of the reference processor class. One\n-  \/\/ (_ref_processor_cm) handles reference object discovery\n-  \/\/ and subsequent processing during concurrent marking cycles.\n+  \/\/ G1 has 2 instances of the reference processor class.\n@@ -920,3 +930,3 @@\n-  \/\/ The other (_ref_processor_stw) handles reference object\n-  \/\/ discovery and processing during full GCs and incremental\n-  \/\/ evacuation pauses.\n+  \/\/ One (_ref_processor_cm) handles reference object discovery and subsequent\n+  \/\/ processing during concurrent marking cycles. Discovery is enabled\/disabled\n+  \/\/ at the start\/end of a concurrent marking cycle.\n@@ -924,7 +934,2 @@\n-  \/\/ During an incremental pause, reference discovery will be\n-  \/\/ temporarily disabled for _ref_processor_cm and will be\n-  \/\/ enabled for _ref_processor_stw. At the end of the evacuation\n-  \/\/ pause references discovered by _ref_processor_stw will be\n-  \/\/ processed and discovery will be disabled. The previous\n-  \/\/ setting for reference object discovery for _ref_processor_cm\n-  \/\/ will be re-instated.\n+  \/\/ The other (_ref_processor_stw) handles reference object discovery and\n+  \/\/ processing during incremental evacuation pauses and full GC pauses.\n@@ -932,4 +937,1 @@\n-  \/\/ At the start of marking:\n-  \/\/  * Discovery by the CM ref processor is verified to be inactive\n-  \/\/    and it's discovered lists are empty.\n-  \/\/  * Discovery by the CM ref processor is then enabled.\n+  \/\/ ## Incremental evacuation pauses\n@@ -937,3 +939,5 @@\n-  \/\/ At the end of marking:\n-  \/\/  * Any references on the CM ref processor's discovered\n-  \/\/    lists are processed (possibly MT).\n+  \/\/ STW ref processor discovery is enabled\/disabled at the start\/end of an\n+  \/\/ incremental evacuation pause. No particular handling of the CM ref\n+  \/\/ processor is needed, apart from treating the discovered references as\n+  \/\/ roots; CM discovery does not need to be temporarily disabled as all\n+  \/\/ marking threads are paused during incremental evacuation pauses.\n@@ -941,10 +945,1 @@\n-  \/\/ At the start of full GC we:\n-  \/\/  * Disable discovery by the CM ref processor and\n-  \/\/    empty CM ref processor's discovered lists\n-  \/\/    (without processing any entries).\n-  \/\/  * Verify that the STW ref processor is inactive and it's\n-  \/\/    discovered lists are empty.\n-  \/\/  * Temporarily set STW ref processor discovery as single threaded.\n-  \/\/  * Temporarily clear the STW ref processor's _is_alive_non_header\n-  \/\/    field.\n-  \/\/  * Finally enable discovery by the STW ref processor.\n+  \/\/ ## Full GC pauses\n@@ -952,10 +947,5 @@\n-  \/\/ The STW ref processor is used to record any discovered\n-  \/\/ references during the full GC.\n-  \/\/\n-  \/\/ At the end of a full GC we:\n-  \/\/  * Enqueue any reference objects discovered by the STW ref processor\n-  \/\/    that have non-live referents. This has the side-effect of\n-  \/\/    making the STW ref processor inactive by disabling discovery.\n-  \/\/  * Verify that the CM ref processor is still inactive\n-  \/\/    and no references have been placed on it's discovered\n-  \/\/    lists (also checked as a precondition during concurrent start).\n+  \/\/ We abort any ongoing concurrent marking cycle, disable CM discovery, and\n+  \/\/ temporarily substitute a new closure for the STW ref processor's\n+  \/\/ _is_alive_non_header field (old value is restored after the full GC). Then\n+  \/\/ STW ref processor discovery is enabled, and marking & compaction\n+  \/\/ commences.\n@@ -1015,0 +1005,3 @@\n+  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n+  bool concurrent_mark_is_terminating() const;\n+\n@@ -1486,0 +1479,22 @@\n+\/\/ Scoped object that performs common pre- and post-gc heap printing operations.\n+class G1HeapPrinterMark : public StackObj {\n+  G1CollectedHeap* _g1h;\n+  G1HeapTransition _heap_transition;\n+\n+public:\n+  G1HeapPrinterMark(G1CollectedHeap* g1h);\n+  ~G1HeapPrinterMark();\n+};\n+\n+\/\/ Scoped object that performs common pre- and post-gc operations related to\n+\/\/ JFR events.\n+class G1JFRTracerMark : public StackObj {\n+protected:\n+  STWGCTimer* _timer;\n+  GCTracer* _tracer;\n+\n+public:\n+  G1JFRTracerMark(STWGCTimer* timer, GCTracer* tracer);\n+  ~G1JFRTracerMark();\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":76,"deletions":61,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -198,3 +199,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  return Atomic::load(&_regions_failed_evacuation[region_idx]);\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n@@ -208,4 +207,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  volatile bool* region_failed_addr = &_regions_failed_evacuation[region_idx];\n-  bool result = !Atomic::load(region_failed_addr) && !Atomic::cmpxchg(region_failed_addr, false, true, memory_order_relaxed);\n+  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -42,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -379,1 +380,1 @@\n-  _max_num_tasks(ParallelGCThreads),\n+  _max_num_tasks(MAX2(ConcGCThreads, ParallelGCThreads)),\n@@ -718,3 +719,1 @@\n-  \/\/ enable (\"weak\") refs discovery\n-  rp->enable_discovery();\n-  rp->setup_policy(false); \/\/ snapshot the soft ref policy to be used in this cycle\n+  rp->start_discovery(false \/* always_clear *\/);\n@@ -1127,1 +1126,1 @@\n-    weak_refs_work(false \/* clear_all_soft_refs *\/);\n+    weak_refs_work();\n@@ -1313,1 +1312,1 @@\n-  _g1h->g1mm()->update_sizes();\n+  _g1h->monitoring_support()->update_sizes();\n@@ -1494,1 +1493,1 @@\n-void G1ConcurrentMark::weak_refs_work(bool clear_all_soft_refs) {\n+void G1ConcurrentMark::weak_refs_work() {\n@@ -1508,2 +1507,0 @@\n-    \/\/ Set the soft reference policy\n-    rp->setup_policy(clear_all_soft_refs);\n@@ -1695,1 +1692,1 @@\n-        thread->as_Java_thread()->nmethods_do(&_code_cl);\n+        JavaThread::cast(thread)->nmethods_do(&_code_cl);\n@@ -2950,1 +2947,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::fl_mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -365,2 +365,1 @@\n-  void weak_refs_work_parallel_part(BoolObjectClosure* is_alive, bool purged_classes);\n-  void weak_refs_work(bool clear_all_soft_refs);\n+  void weak_refs_work();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -48,1 +48,0 @@\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n@@ -50,0 +49,1 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n@@ -134,2 +134,2 @@\n-\/\/ the _completed queue, using the LockFreeQueue::try_pop() underneath.\n-\/\/ It has a restriction that it may return NULL when there are objects\n+\/\/ the _completed queue, using the NonblockingQueue::try_pop() underneath.\n+\/\/ It has a limitation that it may return NULL when there are objects\n@@ -138,1 +138,0 @@\n-  using Status = LockFreeQueuePopStatus;\n@@ -140,0 +139,1 @@\n+  BufferNode* result = NULL;\n@@ -150,13 +150,1 @@\n-    Pair<Status, BufferNode*> pop_result = _completed.try_pop();\n-    switch (pop_result.first) {\n-      case Status::success:\n-        return pop_result.second;\n-      case Status::operation_in_progress:\n-        \/\/ Returning NULL instead retrying, in order to mitigate the\n-        \/\/ chance of spinning for a long time. In the case of getting a\n-        \/\/ buffer to refine, it is also OK to return NULL when there is\n-        \/\/ an interfering concurrent push\/append operation.\n-        return NULL;\n-      case Status::lost_race:\n-        break;  \/\/ Try again.\n-    }\n+    if (_completed.try_pop(&result)) return result;\n@@ -180,2 +168,3 @@\n-  BufferNode* cur = _completed.top();\n-  for ( ; cur != NULL; cur = cur->next()) {\n+  for (BufferNode* cur = _completed.first();\n+       !_completed.is_end(cur);\n+       cur = cur->next()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"utilities\/lockFreeQueue.hpp\"\n+#include \"utilities\/nonblockingQueue.hpp\"\n@@ -167,3 +167,3 @@\n-  \/\/ LockFreeQueue has inner padding of one cache line.\n-  LockFreeQueue<BufferNode, &BufferNode::next_ptr> _completed;\n-  \/\/ Add a trailer padding after LockFreeQueue.\n+  \/\/ NonblockingQueue has inner padding of one cache line.\n+  NonblockingQueue<BufferNode, &BufferNode::next_ptr> _completed;\n+  \/\/ Add a trailer padding after NonblockingQueue.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -117,1 +116,1 @@\n-    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximum_compaction),\n+    _scope(heap->monitoring_support(), explicit_gc, clear_soft_refs, do_maximum_compaction),\n@@ -174,3 +173,0 @@\n-  _heap->print_heap_before_gc();\n-  _heap->print_heap_regions();\n-\n@@ -181,0 +177,1 @@\n+  _heap->retire_tlabs();\n@@ -186,6 +183,1 @@\n-  reference_processor()->enable_discovery();\n-  reference_processor()->setup_policy(scope()->should_clear_soft_refs());\n-\n-  \/\/ We should save the marks of the currently locked biased monitors.\n-  \/\/ The marking doesn't preserve the marks of biased objects.\n-  BiasedLocking::preserve_marks();\n+  reference_processor()->start_discovery(scope()->should_clear_soft_refs());\n@@ -219,2 +211,0 @@\n-  BiasedLocking::restore_marks();\n-\n@@ -227,0 +217,2 @@\n+  _heap->resize_all_tlabs();\n+\n@@ -231,2 +223,0 @@\n-\n-  _heap->print_heap_after_full_collection(scope()->heap_transition());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,4 +111,1 @@\n-      \/\/ since it will be restored by preserved marks. There is an exception\n-      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n-      \/\/ even if the mark-word is used. This is no problem since\n-      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      \/\/ since it will be restored by preserved marks.\n@@ -119,3 +116,2 @@\n-      assert(object->mark() == markWord::prototype_for_klass(object->klass()) || \/\/ Correct mark\n-             object->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-             (UseBiasedLocking && object->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n+             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -123,1 +119,1 @@\n-             p2i(object), object->mark().value(), markWord::prototype_for_klass(object->klass()).value());\n+             p2i(object), object->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -83,3 +83,2 @@\n-    assert(obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ Correct mark\n-           obj->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-           (UseBiasedLocking && obj->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n+    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n+           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n@@ -87,1 +86,1 @@\n-           p2i(obj), obj->mark().value(), markWord::prototype_for_klass(obj->klass()).value());\n+           p2i(obj), obj->mark().value(), markWord::prototype().value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,10 @@\n+G1FullGCJFRTracerMark::G1FullGCJFRTracerMark(STWGCTimer* timer, GCTracer* tracer)\n+  : G1JFRTracerMark(timer, tracer) {\n+\n+  G1CollectedHeap::heap()->pre_full_gc_dump(_timer);\n+}\n+\n+G1FullGCJFRTracerMark::~G1FullGCJFRTracerMark() {\n+  G1CollectedHeap::heap()->post_full_gc_dump(_timer);\n+}\n+\n@@ -41,0 +51,1 @@\n+    _tracer_mark(&_timer, &_tracer),\n@@ -43,1 +54,1 @@\n-    _heap_transition(_g1h),\n+    _heap_printer(_g1h),\n@@ -46,18 +57,1 @@\n-                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) {\n-  _timer.register_gc_start();\n-  _tracer.report_gc_start(_g1h->gc_cause(), _timer.gc_start());\n-  _g1h->pre_full_gc_dump(&_timer);\n-  _g1h->trace_heap_before_gc(&_tracer);\n-}\n-\n-G1FullGCScope::~G1FullGCScope() {\n-  \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-  \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-  \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-  \/\/ before any GC notifications are raised.\n-  _g1h->g1mm()->update_sizes();\n-  _g1h->trace_heap_after_gc(&_tracer);\n-  _g1h->post_full_gc_dump(&_timer);\n-  _timer.register_gc_end();\n-  _tracer.report_gc_end(_timer.gc_end(), _timer.time_partitions());\n-}\n+                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) { }\n@@ -81,4 +75,0 @@\n-G1HeapTransition* G1FullGCScope::heap_transition() {\n-  return &_heap_transition;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -42,0 +42,7 @@\n+class G1FullGCJFRTracerMark : public G1JFRTracerMark {\n+public:\n+\n+  G1FullGCJFRTracerMark(STWGCTimer* timer, GCTracer* tracer);\n+  ~G1FullGCJFRTracerMark();\n+};\n+\n@@ -53,0 +60,1 @@\n+  G1FullGCJFRTracerMark   _tracer_mark;\n@@ -55,1 +63,1 @@\n-  G1HeapTransition        _heap_transition;\n+  G1HeapPrinterMark       _heap_printer;\n@@ -63,1 +71,0 @@\n-  ~G1FullGCScope();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+constexpr const char* G1GCPhaseTimes::GCMergeRSWorkItemsStrings[];\n+\n@@ -74,4 +76,3 @@\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[MergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -80,4 +81,3 @@\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[OptMergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -137,0 +137,2 @@\n+  _gc_par_phases[SampleCollectionSetCandidates] = new WorkerDataArray<double>(\"SampleCandidates\", \"Sample CSet Candidates (ms):\", max_gc_threads);\n+\n@@ -173,0 +175,1 @@\n+  _recorded_sample_collection_set_candidates_time_ms = 0.0;\n@@ -192,1 +195,1 @@\n-void G1GCPhaseTimes::note_gc_start() {\n+void G1GCPhaseTimes::record_gc_pause_start() {\n@@ -211,1 +214,1 @@\n-void G1GCPhaseTimes::note_gc_end() {\n+void G1GCPhaseTimes::record_gc_pause_end() {\n@@ -452,0 +455,1 @@\n+                        _recorded_sample_collection_set_candidates_time_ms +\n@@ -475,0 +479,2 @@\n+  debug_time(\"Sample Collection Set Candidates\", _recorded_sample_collection_set_candidates_time_ms);\n+  trace_phase(_gc_par_phases[RedirtyCards]);\n@@ -488,0 +494,3 @@\n+  if (G1CollectedHeap::heap()->should_sample_collection_set_candidates()) {\n+    debug_phase(_gc_par_phases[SampleCollectionSetCandidates], 1);\n+  }\n@@ -513,2 +522,3 @@\n-  note_gc_end();\n-\n+  \/\/ Check if some time has been recorded for verification and only then print\n+  \/\/ the message. We do not use Verify*GC here to print because VerifyGCType\n+  \/\/ further limits actual verification.\n@@ -526,0 +536,1 @@\n+  \/\/ See above comment on the _cur_verify_before_time_ms check.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    SampleCollectionSetCandidates,\n@@ -100,5 +101,11 @@\n-  enum GCMergeRSWorkTimes {\n-    MergeRSMergedSparse,\n-    MergeRSMergedFine,\n-    MergeRSMergedCoarse,\n-    MergeRSDirtyCards\n+  enum GCMergeRSWorkItems : uint {\n+    MergeRSMergedInline = 0,\n+    MergeRSMergedArrayOfCards,\n+    MergeRSMergedHowl,\n+    MergeRSMergedFull,\n+    MergeRSHowlInline,\n+    MergeRSHowlArrayOfCards,\n+    MergeRSHowlBitmap,\n+    MergeRSHowlFull,\n+    MergeRSDirtyCards,\n+    MergeRSContainersSentinel\n@@ -107,0 +114,5 @@\n+  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersSentinel] =\n+    { \"Merged Inline\", \"Merged ArrayOfCards\", \"Merged Howl\", \"Merged Full\",\n+      \"Merged Howl Inline\", \"Merged Howl ArrayOfCards\", \"Merged Howl BitMap\", \"Merged Howl Full\",\n+      \"Dirty Cards\" };\n+\n@@ -176,0 +188,2 @@\n+  double _recorded_sample_collection_set_candidates_time_ms;\n+\n@@ -195,1 +209,0 @@\n-  void note_gc_end();\n@@ -223,1 +236,2 @@\n-  void note_gc_start();\n+  void record_gc_pause_start();\n+  void record_gc_pause_end();\n@@ -332,0 +346,4 @@\n+  void record_sample_collection_set_candidates_time_ms(double time_ms) {\n+    _recorded_sample_collection_set_candidates_time_ms = time_ms;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return (_enabled_verification_types & type) == type;\n+  return (_enabled_verification_types & type) != 0;\n@@ -607,3 +607,1 @@\n-double G1HeapVerifier::verify(G1VerifyType type, VerifyOption vo, const char* msg) {\n-  double verify_time_ms = 0.0;\n-\n+void G1HeapVerifier::verify(G1VerifyType type, VerifyOption vo, const char* msg) {\n@@ -611,1 +609,0 @@\n-    double verify_start = os::elapsedTime();\n@@ -614,1 +611,0 @@\n-    verify_time_ms = (os::elapsedTime() - verify_start) * 1000;\n@@ -616,2 +612,0 @@\n-\n-  return verify_time_ms;\n@@ -621,4 +615,1 @@\n-  if (VerifyBeforeGC) {\n-    double verify_time_ms = verify(type, VerifyOption_G1UsePrevMarking, \"Before GC\");\n-    _g1h->phase_times()->record_verify_before_time_ms(verify_time_ms);\n-  }\n+  verify(type, VerifyOption_G1UsePrevMarking, \"Before GC\");\n@@ -628,4 +619,1 @@\n-  if (VerifyAfterGC) {\n-    double verify_time_ms = verify(type, VerifyOption_G1UsePrevMarking, \"After GC\");\n-    _g1h->phase_times()->record_verify_after_time_ms(verify_time_ms);\n-  }\n+  verify(type, VerifyOption_G1UsePrevMarking, \"After GC\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -48,3 +49,4 @@\n-    G1VerifyRemark          =  8, \/\/ -XX:VerifyGCType=remark\n-    G1VerifyCleanup         = 16, \/\/ -XX:VerifyGCType=cleanup\n-    G1VerifyFull            = 32, \/\/ -XX:VerifyGCType=full\n+    G1VerifyYoungEvacFail   =  8, \/\/ -XX:VerifyGCType=young-evac-fail\n+    G1VerifyRemark          = 16, \/\/ -XX:VerifyGCType=remark\n+    G1VerifyCleanup         = 32, \/\/ -XX:VerifyGCType=cleanup\n+    G1VerifyFull            = 64, \/\/ -XX:VerifyGCType=full\n@@ -81,1 +83,1 @@\n-  double verify(G1VerifyType type, VerifyOption vo, const char* msg);\n+  void verify(G1VerifyType type, VerifyOption vo, const char* msg);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  _g1mm(g1h->g1mm()) {\n+  _g1mm(g1h->monitoring_support()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MemoryPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  G1MonitoringSupport* _g1mm;\n+  G1MonitoringSupport* _monitoring_support;\n@@ -39,1 +39,1 @@\n-  G1GenerationCounters(G1MonitoringSupport* g1mm,\n+  G1GenerationCounters(G1MonitoringSupport* monitoring_support,\n@@ -44,1 +44,2 @@\n-                       max_capacity, curr_capacity), _g1mm(g1mm) { }\n+                       max_capacity, curr_capacity),\n+    _monitoring_support(monitoring_support) { }\n@@ -51,2 +52,2 @@\n-  G1YoungGenerationCounters(G1MonitoringSupport* g1mm, const char* name, size_t max_size)\n-  : G1GenerationCounters(g1mm, name, 0 \/* ordinal *\/, 3 \/* spaces *\/,\n+  G1YoungGenerationCounters(G1MonitoringSupport* monitoring_support, const char* name, size_t max_size)\n+  : G1GenerationCounters(monitoring_support, name, 0 \/* ordinal *\/, 3 \/* spaces *\/,\n@@ -63,1 +64,1 @@\n-              G1MonitoringSupport::pad_capacity(_g1mm->young_gen_committed(), 3);\n+              G1MonitoringSupport::pad_capacity(_monitoring_support->young_gen_committed(), 3);\n@@ -70,2 +71,2 @@\n-  G1OldGenerationCounters(G1MonitoringSupport* g1mm, const char* name, size_t max_size)\n-  : G1GenerationCounters(g1mm, name, 1 \/* ordinal *\/, 1 \/* spaces *\/,\n+  G1OldGenerationCounters(G1MonitoringSupport* monitoring_support, const char* name, size_t max_size)\n+  : G1GenerationCounters(monitoring_support, name, 1 \/* ordinal *\/, 1 \/* spaces *\/,\n@@ -82,1 +83,1 @@\n-              G1MonitoringSupport::pad_capacity(_g1mm->old_gen_committed());\n+              G1MonitoringSupport::pad_capacity(_monitoring_support->old_gen_committed());\n@@ -345,3 +346,4 @@\n-G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected) :\n-  _tcs(full_gc ? g1mm->_full_collection_counters : g1mm->_incremental_collection_counters),\n-  _tms(full_gc ? &g1mm->_full_gc_memory_manager : &g1mm->_incremental_memory_manager,\n+G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* monitoring_support, bool full_gc, bool all_memory_pools_affected) :\n+  _monitoring_support(monitoring_support),\n+  _tcs(full_gc ? monitoring_support->_full_collection_counters : monitoring_support->_incremental_collection_counters),\n+  _tms(full_gc ? &monitoring_support->_full_gc_memory_manager : &monitoring_support->_incremental_memory_manager,\n@@ -350,0 +352,6 @@\n+\n+G1MonitoringScope::~G1MonitoringScope() {\n+  _monitoring_support->update_sizes();\n+  \/\/ Needs to be called after updating pool sizes.\n+  MemoryService::track_memory_usage();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  G1MonitoringSupport* _monitoring_support;\n@@ -244,1 +245,2 @@\n-  G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected);\n+  G1MonitoringScope(G1MonitoringSupport* monitoring_support, bool full_gc, bool all_memory_pools_affected);\n+  ~G1MonitoringScope();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -36,0 +37,3 @@\n+  \/\/ Ensure no GC safepoints while we're doing the checks, to avoid data races.\n+  SuspendibleThreadSetJoiner sts;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -53,0 +53,2 @@\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+\n@@ -114,2 +116,2 @@\n-void G1Policy::note_gc_start() {\n-  phase_times()->note_gc_start();\n+void G1Policy::record_young_gc_pause_start() {\n+  phase_times()->record_gc_pause_start();\n@@ -518,1 +520,2 @@\n-void G1Policy::record_collection_pause_start(double start_time_sec) {\n+void G1Policy::record_young_collection_start() {\n+  Ticks now = Ticks::now();\n@@ -529,1 +532,1 @@\n-  phase_times()->record_cur_collection_start_sec(start_time_sec);\n+  phase_times()->record_cur_collection_start_sec(now.seconds());\n@@ -629,1 +632,1 @@\n-void G1Policy::record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark) {\n@@ -632,1 +635,0 @@\n-  double end_time_sec = os::elapsedTime();\n@@ -634,0 +636,2 @@\n+  double end_time_sec = Ticks::now().seconds();\n+  double pause_time_ms = (end_time_sec - start_time_sec) * 1000.0;\n@@ -890,1 +894,2 @@\n-void G1Policy::print_phases() {\n+void G1Policy::record_young_gc_pause_end() {\n+  phase_times()->record_gc_pause_end();\n@@ -1044,1 +1049,1 @@\n-void G1Policy::decide_on_conc_mark_initiation() {\n+void G1Policy::decide_on_concurrent_start_pause() {\n@@ -1054,0 +1059,6 @@\n+  \/\/ We should not be starting a concurrent start pause if the concurrent mark\n+  \/\/ thread is terminating.\n+  if (_g1h->concurrent_mark_is_terminating()) {\n+    return;\n+  }\n+\n@@ -1102,0 +1113,6 @@\n+  \/\/ Result consistency checks.\n+  \/\/ We do not allow concurrent start to be piggy-backed on a mixed GC.\n+  assert(!collector_state()->in_concurrent_start_gc() ||\n+         collector_state()->in_young_only_phase(), \"sanity\");\n+  \/\/ We also do not allow mixed GCs during marking.\n+  assert(!collector_state()->mark_or_rebuild_in_progress() || collector_state()->in_young_only_phase(), \"sanity\");\n@@ -1488,1 +1505,1 @@\n-  note_start_adding_survivor_regions();\n+  start_adding_survivor_regions();\n@@ -1504,1 +1521,1 @@\n-  note_stop_adding_survivor_regions();\n+  stop_adding_survivor_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -304,1 +304,3 @@\n-  void note_gc_start();\n+  \/\/ Record the start and end of the young gc pause.\n+  void record_young_gc_pause_start();\n+  void record_young_gc_pause_end();\n@@ -312,3 +314,3 @@\n-  \/\/ Record the start and end of an evacuation pause.\n-  void record_collection_pause_start(double start_time_sec);\n-  void record_collection_pause_end(double pause_time_ms, bool concurrent_operation_is_full_mark);\n+  \/\/ Record the start and end of the actual collection part of the evacuation pause.\n+  void record_young_collection_start();\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark);\n@@ -331,2 +333,0 @@\n-  void print_phases();\n-\n@@ -376,7 +376,7 @@\n-  \/\/ This is called at the very beginning of an evacuation pause (it\n-  \/\/ has to be the first thing that the pause does). If\n-  \/\/ initiate_conc_mark_if_possible() is true, and the concurrent\n-  \/\/ marking thread has completed its work during the previous cycle,\n-  \/\/ it will set in_concurrent_start_gc() to so that the pause does\n-  \/\/ the concurrent start work and start a marking cycle.\n-  void decide_on_conc_mark_initiation();\n+  \/\/ Decide whether this garbage collection pause should be a concurrent start\n+  \/\/ pause and update the collector state accordingly.\n+  \/\/ We decide on a concurrent start pause if initiate_conc_mark_if_possible() is\n+  \/\/ true, the concurrent marking thread has completed its work for the previous\n+  \/\/ cycle, and we are not shutting down the VM.\n+  \/\/ This must be called at the very beginning of an evacuation pause.\n+  void decide_on_concurrent_start_pause();\n@@ -430,1 +430,1 @@\n-  void note_start_adding_survivor_regions() {\n+  void start_adding_survivor_regions() {\n@@ -434,1 +434,1 @@\n-  void note_stop_adding_survivor_regions() {\n+  void stop_adding_survivor_regions() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -384,3 +384,1 @@\n-    if (!_region_scan_chunks[chunk_idx]) {\n-      _region_scan_chunks[chunk_idx] = true;\n-    }\n+    _region_scan_chunks[chunk_idx] = true;\n@@ -1064,1 +1062,1 @@\n-\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ Small ring buffer used for prefetching cards for write from the card\n@@ -1066,1 +1064,1 @@\n-template <class T, bool for_write>\n+template <class T>\n@@ -1099,5 +1097,1 @@\n-    if (for_write) {\n-      Prefetch::write(elem, 0);\n-    } else {\n-      Prefetch::read(elem, 0);\n-    }\n+    Prefetch::write(elem, 0);\n@@ -1114,1 +1108,27 @@\n-  \/\/ Visitor for remembered sets, dropping entries onto the card table.\n+  class G1MergeCardSetStats {\n+    size_t _merged[G1GCPhaseTimes::MergeRSContainersSentinel];\n+\n+  public:\n+    G1MergeCardSetStats() {\n+      for (uint i = 0; i < ARRAY_SIZE(_merged); i++) {\n+        _merged[i] = 0;\n+      }\n+    }\n+\n+    void inc_card_set_merged(uint tag) {\n+      assert(tag < ARRAY_SIZE(_merged), \"tag out of bounds %u\", tag);\n+      _merged[tag]++;\n+    }\n+\n+    void inc_cards_dirty(size_t increment = 1) {\n+      _merged[G1GCPhaseTimes::MergeRSDirtyCards] += increment;\n+    }\n+\n+    size_t merged(uint i) const { return _merged[i]; }\n+  };\n+\n+  \/\/ Visitor for remembered sets. Several methods of it are called by a region's\n+  \/\/ card set iterator to drop card set remembered set entries onto the card.\n+  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ all region's remembered sets.\n+  \/\/\n@@ -1124,5 +1144,1 @@\n-    uint _merged_sparse;\n-    uint _merged_fine;\n-    uint _merged_coarse;\n-\n-    size_t _cards_dirty;\n+    G1MergeCardSetStats _stats;\n@@ -1134,1 +1150,1 @@\n-    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue> {\n@@ -1141,1 +1157,1 @@\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue>(G1CardTable::dirty_card_val()),\n@@ -1163,1 +1179,1 @@\n-        _cards_dirty++;\n+        _stats.inc_cards_dirty();\n@@ -1168,4 +1184,0 @@\n-    void start_iterate(uint const region_idx) {\n-      _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n-    }\n-\n@@ -1173,0 +1185,1 @@\n+\n@@ -1176,4 +1189,1 @@\n-      _merged_sparse(0),\n-      _merged_fine(0),\n-      _merged_coarse(0),\n-      _cards_dirty(0),\n+      _stats(),\n@@ -1181,2 +1191,1 @@\n-      _merge_card_set_cache(this) {\n-    }\n+      _merge_card_set_cache(this) { }\n@@ -1191,24 +1200,7 @@\n-    void next_coarse_prt(uint const region_idx) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_coarse++;\n-\n-      start_iterate(region_idx);\n-      _cards_dirty += _ct->mark_region_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n-      _scan_state->set_chunk_region_dirty(_region_base_idx);\n-    }\n-\n-    void next_fine_prt(uint const region_idx, BitMap* bm) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_fine++;\n-\n-      start_iterate(region_idx);\n-      BitMap::idx_t cur = bm->get_next_one_offset(0);\n-      while (cur != bm->size()) {\n-        do_card((uint)cur);\n-        cur = bm->get_next_one_offset(cur + 1);\n+    \/\/ Returns whether the given region actually needs iteration.\n+    bool start_iterate(uint const tag, uint const region_idx) {\n+      assert(tag < G1GCPhaseTimes::MergeRSDirtyCards, \"invalid tag %u\", tag);\n+      if (remember_if_interesting(region_idx)) {\n+        _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+        _stats.inc_card_set_merged(tag);\n+        return true;\n@@ -1216,0 +1208,1 @@\n+      return false;\n@@ -1218,11 +1211,6 @@\n-    void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_sparse++;\n-\n-      start_iterate(region_idx);\n-      for (uint i = 0; i < num_cards; i++) {\n-        do_card(cards[i]);\n-      }\n+    void do_card_range(uint const start_card_idx, uint const length) {\n+      assert(start_card_idx == 0, \"must be\");\n+      assert(length == HeapRegion::CardsPerRegion, \"must be\");\n+      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      _stats.inc_cards_dirty(num_dirtied);\n+      _scan_state->set_chunk_region_dirty(_region_base_idx);\n@@ -1231,1 +1219,1 @@\n-    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ Helper to merge the cards in the card set for the given region onto the card\n@@ -1245,1 +1233,1 @@\n-    void dump_rem_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(HeapRegion* r) {\n@@ -1250,1 +1238,1 @@\n-        rem_set->iterate_prts(*this);\n+        rem_set->iterate_for_merge(*this);\n@@ -1258,1 +1246,1 @@\n-      dump_rem_set_for_region(r);\n+      merge_card_set_for_region(r);\n@@ -1263,5 +1251,1 @@\n-    size_t merged_sparse() const { return _merged_sparse; }\n-    size_t merged_fine() const { return _merged_fine; }\n-    size_t merged_coarse() const { return _merged_coarse; }\n-\n-    size_t cards_dirty() const { return _cards_dirty; }\n+    G1MergeCardSetStats stats() const { return _stats; }\n@@ -1273,1 +1257,2 @@\n-    G1MergeCardSetClosure _cl;\n+    G1RemSetScanState* _scan_state;\n+    G1MergeCardSetStats _merge_stats;\n@@ -1276,1 +1261,1 @@\n-    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }\n+    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _scan_state(scan_state), _merge_stats() { }\n@@ -1290,1 +1275,6 @@\n-      _cl.dump_rem_set_for_region(r);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        cl.merge_card_set_for_region(r);\n+        stats = cl.stats();\n+      }\n@@ -1310,5 +1300,1 @@\n-    size_t merged_sparse() const { return _cl.merged_sparse(); }\n-    size_t merged_fine() const { return _cl.merged_fine(); }\n-    size_t merged_coarse() const { return _cl.merged_coarse(); }\n-\n-    size_t cards_dirty() const { return _cl.cards_dirty(); }\n+    size_t merged(uint i) const { return _merge_stats.merged(i); }\n@@ -1319,1 +1305,0 @@\n-    friend class G1MergeLogBufferCardsCache;\n@@ -1327,17 +1312,0 @@\n-    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n-      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n-\n-    public:\n-      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n-        \/\/ Initially set dummy card value to Clean to avoid any actual work if we\n-        \/\/ try to process it.\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n-        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n-\n-      ~G1MergeLogBufferCardsCache() {\n-        for (uint i = 0; i < CacheSize; i++) {\n-          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n-        }\n-      }\n-    } _merge_log_buffer_cache;\n-\n@@ -1358,2 +1326,1 @@\n-      _cards_skipped(0),\n-      _merge_log_buffer_cache(this)\n+      _cards_skipped(0)\n@@ -1376,2 +1343,1 @@\n-        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n-        process_card(to_process);\n+        process_card(card_ptr);\n@@ -1445,4 +1411,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+      }\n@@ -1454,2 +1419,6 @@\n-      G1MergeCardSetClosure cl(_scan_state);\n-      g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+        stats = cl.stats();\n+      }\n@@ -1457,4 +1426,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+      }\n@@ -1489,1 +1457,3 @@\n-  size_t num_visited_cards = _scan_state->num_visited_cards();\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1491,1 +1461,1 @@\n-  size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+    size_t num_visited_cards = _scan_state->num_visited_cards();\n@@ -1493,10 +1463,13 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  size_t total_old_region_cards =\n-    (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n-\n-  log_debug(gc,remset)(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n-                       num_visited_cards,\n-                       total_dirty_region_cards,\n-                       percent_of(num_visited_cards, total_dirty_region_cards),\n-                       total_old_region_cards,\n-                       percent_of(num_visited_cards, total_old_region_cards));\n+    size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    size_t total_old_region_cards =\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+\n+    ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n+                num_visited_cards,\n+                total_dirty_region_cards,\n+                percent_of(num_visited_cards, total_dirty_region_cards),\n+                total_old_region_cards,\n+                percent_of(num_visited_cards, total_old_region_cards));\n+  }\n@@ -1534,3 +1507,1 @@\n-  if (log_is_enabled(Debug, gc, remset)) {\n-    print_merge_heap_roots_stats();\n-  }\n+  print_merge_heap_roots_stats();\n@@ -1551,0 +1522,9 @@\n+void G1RemSet::print_coarsen_stats() {\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+\n+    G1CardSet::print_coarsen_stats(&ls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":109,"deletions":129,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -110,0 +110,4 @@\n+  \/\/ Cleans the card table from temporary duplicate detection information.\n+  void cleanup_after_scan_heap_roots();\n+  \/\/ Print coarsening stats.\n+  void print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -34,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -51,0 +52,1 @@\n+\n@@ -53,1 +55,1 @@\n-  _num_coarsenings = HeapRegionRemSet::n_coarsenings();\n+  _coarsenings = HeapRegionRemSet::coarsen_stats();\n@@ -71,1 +73,1 @@\n-  _num_coarsenings(0),\n+  _coarsenings(),\n@@ -91,1 +93,1 @@\n-  _num_coarsenings = other->num_coarsenings();\n+  _coarsenings = other->_coarsenings;\n@@ -102,1 +104,1 @@\n-  _num_coarsenings = other->num_coarsenings() - _num_coarsenings;\n+  _coarsenings.subtract_from(other->_coarsenings);\n@@ -115,0 +117,1 @@\n+  size_t _rs_wasted_mem_size;\n@@ -118,0 +121,1 @@\n+  size_t _amount_tracked;\n@@ -139,0 +143,1 @@\n+  size_t amount_tracked() const { return _amount_tracked; }\n@@ -142,2 +147,2 @@\n-  RegionTypeCounter(const char* name) : _name(name), _rs_mem_size(0), _cards_occupied(0),\n-    _amount(0), _code_root_mem_size(0), _code_root_elems(0) { }\n+  RegionTypeCounter(const char* name) : _name(name), _rs_wasted_mem_size(0), _rs_mem_size(0), _cards_occupied(0),\n+    _amount(0), _amount_tracked(0), _code_root_mem_size(0), _code_root_elems(0) { }\n@@ -145,2 +150,3 @@\n-  void add(size_t rs_mem_size, size_t cards_occupied, size_t code_root_mem_size,\n-    size_t code_root_elems) {\n+  void add(size_t rs_wasted_mem_size, size_t rs_mem_size, size_t cards_occupied,\n+           size_t code_root_mem_size, size_t code_root_elems, bool tracked) {\n+    _rs_wasted_mem_size += rs_wasted_mem_size;\n@@ -152,0 +158,1 @@\n+    _amount_tracked += tracked ? 1 : 0;\n@@ -154,0 +161,1 @@\n+  size_t rs_wasted_mem_size() const { return _rs_wasted_mem_size; }\n@@ -161,4 +169,5 @@\n-    out->print_cr(\"    \" SIZE_FORMAT_W(8) \"%s (%5.1f%%) by \" SIZE_FORMAT \" %s regions\",\n-        byte_size_in_proper_unit(rs_mem_size()),\n-        proper_unit_for_byte_size(rs_mem_size()),\n-        rs_mem_size_percent_of(total), amount(), _name);\n+    out->print_cr(\"    \" SIZE_FORMAT_W(8) \" (%5.1f%%) by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions wasted \" SIZE_FORMAT,\n+                  rs_mem_size(), rs_mem_size_percent_of(total),\n+                  amount_tracked(), amount(),\n+                  _name, rs_wasted_mem_size());\n@@ -168,2 +177,4 @@\n-    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" %s regions\",\n-        cards_occupied(), cards_occupied_percent_of(total), amount(), _name);\n+    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions\",\n+                  cards_occupied(), cards_occupied_percent_of(total),\n+                  amount_tracked(), amount(), _name);\n@@ -198,0 +209,1 @@\n+  size_t total_rs_wasted_mem_sz() const     { return _all.rs_wasted_mem_size(); }\n@@ -225,0 +237,1 @@\n+    size_t rs_wasted_mem_sz = hrrs->wasted_mem_size();\n@@ -252,2 +265,4 @@\n-    current->add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n-    _all.add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n+    current->add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+                 code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n+    _all.add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+             code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n@@ -262,6 +277,5 @@\n-    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT \"%s.\"\n-                  \" Max = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(total_rs_mem_sz()),\n-                  proper_unit_for_byte_size(total_rs_mem_sz()),\n-                  byte_size_in_proper_unit(max_rs_mem_sz()),\n-                  proper_unit_for_byte_size(max_rs_mem_sz()));\n+    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT\n+                  \" Max = \" SIZE_FORMAT \" wasted = \" SIZE_FORMAT,\n+                  total_rs_mem_sz(),\n+                  max_rs_mem_sz(),\n+                  total_rs_wasted_mem_sz());\n@@ -272,7 +286,0 @@\n-    out->print_cr(\"   Static structures = \" SIZE_FORMAT \"%s,\"\n-                  \" free_lists = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(HeapRegionRemSet::static_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::static_mem_size()),\n-                  byte_size_in_proper_unit(HeapRegionRemSet::fl_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::fl_mem_size()));\n-\n@@ -288,1 +295,1 @@\n-                  \"size = \" SIZE_FORMAT \"%s, occupied = \" SIZE_FORMAT \"%s.\",\n+                  \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n@@ -290,4 +297,6 @@\n-                  byte_size_in_proper_unit(rem_set->mem_size()),\n-                  proper_unit_for_byte_size(rem_set->mem_size()),\n-                  byte_size_in_proper_unit(rem_set->occupied()),\n-                  proper_unit_for_byte_size(rem_set->occupied()));\n+                  rem_set->mem_size(),\n+                  rem_set->occupied());\n+\n+    HeapRegionRemSet::print_static_mem_size(out);\n+    G1CardSetFreePool::free_list_pool()->print_on(out);\n+\n@@ -322,1 +331,2 @@\n-  out->print_cr(\"  Did \" SIZE_FORMAT \" coarsenings.\", num_coarsenings());\n+  out->print(\"Coarsening: \");\n+  _coarsenings.print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n@@ -36,1 +37,1 @@\n-  size_t _num_coarsenings;\n+  G1CardSetCoarsenStats _coarsenings;\n@@ -68,4 +69,0 @@\n-\n-  size_t num_coarsenings() const {\n-    return _num_coarsenings;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    _monitor(Mutex::nonleaf,\n+    _monitor(Mutex::leaf,\n@@ -74,1 +74,1 @@\n-void G1ServiceThread::schedule(G1ServiceTask* task, jlong delay_ms) {\n+void G1ServiceThread::schedule(G1ServiceTask* task, jlong delay_ms, bool notify) {\n@@ -82,1 +82,1 @@\n-  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n@@ -84,0 +84,3 @@\n+  if (notify) {\n+    ml.notify();\n+  }\n@@ -90,17 +93,1 @@\n-  schedule(task, delay_ms);\n-  notify();\n-}\n-\n-int64_t G1ServiceThread::time_to_next_task_ms() {\n-  assert(_monitor.owned_by_self(), \"Must be owner of lock\");\n-  assert(!_task_queue.is_empty(), \"Should not be called for empty list\");\n-\n-  jlong time_diff = _task_queue.peek()->time() - os::elapsed_counter();\n-  if (time_diff < 0) {\n-    \/\/ Run without sleeping.\n-    return 0;\n-  }\n-\n-  \/\/ Return sleep time in milliseconds. Using ceil to make sure we never\n-  \/\/ schedule a task too early.\n-  return (int64_t) ceil(TimeHelper::counter_to_millis(time_diff));\n+  schedule(task, delay_ms, true \/* notify *\/);\n@@ -109,10 +96,1 @@\n-void G1ServiceThread::notify() {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  ml.notify();\n-}\n-\n-void G1ServiceThread::sleep_before_next_cycle() {\n-  if (should_terminate()) {\n-    return;\n-  }\n-\n+G1ServiceTask* G1ServiceThread::wait_for_task() {\n@@ -120,9 +98,20 @@\n-  if (_task_queue.is_empty()) {\n-    \/\/ Sleep until new task is registered if no tasks available.\n-    log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n-    ml.wait(0);\n-  } else {\n-    int64_t sleep_ms = time_to_next_task_ms();\n-    if (sleep_ms > 0) {\n-      log_trace(gc, task)(\"G1 Service Thread (wait) %1.3fs\", sleep_ms \/ 1000.0);\n-      ml.wait(sleep_ms);\n+  while (!should_terminate()) {\n+    if (_task_queue.is_empty()) {\n+      log_trace(gc, task)(\"G1 Service Thread (wait for new tasks)\");\n+      ml.wait();\n+    } else {\n+      G1ServiceTask* task = _task_queue.front();\n+      jlong scheduled = task->time();\n+      jlong now = os::elapsed_counter();\n+      if (scheduled <= now) {\n+        _task_queue.remove_front();\n+        return task;\n+      } else {\n+        \/\/ Round up to try not to wake up early, and to avoid round down to\n+        \/\/ zero (which has special meaning of wait forever) by conversion.\n+        double delay = ceil(TimeHelper::counter_to_millis(scheduled - now));\n+        log_trace(gc, task)(\"G1 Service Thread (wait %1.3fs)\", (delay \/ 1000.0));\n+        int64_t delay_ms = static_cast<int64_t>(delay);\n+        assert(delay_ms > 0, \"invariant\");\n+        ml.wait(delay_ms);\n+      }\n@@ -131,9 +120,1 @@\n-}\n-\n-G1ServiceTask* G1ServiceThread::pop_due_task() {\n-  MutexLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (_task_queue.is_empty() || time_to_next_task_ms() != 0) {\n-    return NULL;\n-  }\n-\n-  return _task_queue.pop();\n+  return nullptr;               \/\/ Return nullptr when terminating.\n@@ -143,1 +124,1 @@\n-  double start = os::elapsedTime();\n+  jlong start = os::elapsed_counter();\n@@ -146,1 +127,7 @@\n-  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run)\", task->name());\n+  assert(task->time() <= start,\n+         \"task run early: \" JLONG_FORMAT \" > \" JLONG_FORMAT,\n+         task->time(), start);\n+  log_debug(gc, task, start)(\"G1 Service Thread (%s) (run %1.3fms after schedule)\",\n+                             task->name(),\n+                             TimeHelper::counter_to_millis(start - task->time()));\n+\n@@ -149,4 +136,4 @@\n-  double duration = os::elapsedTime() - start;\n-  double vduration = os::elapsedVTime() - vstart;\n-  log_debug(gc, task)(\"G1 Service Thread (%s) (run) %1.3fms (cpu: %1.3fms)\",\n-                      task->name(), duration * MILLIUNITS, vduration * MILLIUNITS);\n+  log_debug(gc, task)(\"G1 Service Thread (%s) (run: %1.3fms) (cpu: %1.3fms)\",\n+                      task->name(),\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      (os::elapsedVTime() - vstart) * MILLIUNITS);\n@@ -156,7 +143,4 @@\n-  while (!should_terminate()) {\n-    G1ServiceTask* task = pop_due_task();\n-    if (task != NULL) {\n-      run_task(task);\n-    }\n-\n-    sleep_before_next_cycle();\n+  while (true) {\n+    G1ServiceTask* task = wait_for_task();\n+    if (task == nullptr) break;\n+    run_task(task);\n@@ -164,1 +148,1 @@\n-\n+  assert(should_terminate(), \"invariant\");\n@@ -169,1 +153,2 @@\n-  notify();\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  ml.notify();\n@@ -189,1 +174,2 @@\n-  _service_thread->schedule(this, delay_ms);\n+  \/\/ No need to notify, since we *are* the service thread.\n+  _service_thread->schedule(this, delay_ms, false \/* notify *\/);\n@@ -215,1 +201,1 @@\n-G1ServiceTask* G1ServiceTaskQueue::pop() {\n+void G1ServiceTaskQueue::remove_front() {\n@@ -221,2 +207,0 @@\n-\n-  return task;\n@@ -225,1 +209,1 @@\n-G1ServiceTask* G1ServiceTaskQueue::peek() {\n+G1ServiceTask* G1ServiceTaskQueue::front() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":53,"deletions":69,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,5 @@\n-  G1ServiceTask* pop();\n-  G1ServiceTask* peek();\n+\n+  \/\/ precondition: !is_empty().\n+  G1ServiceTask* front();\n+  \/\/ precondition: !is_empty().\n+  void remove_front();\n@@ -110,5 +113,3 @@\n-  \/\/ Returns the time in milliseconds until the next task is due.\n-  \/\/ Used both to determine if there are tasks ready to run and\n-  \/\/ how long to sleep when nothing is ready.\n-  int64_t time_to_next_task_ms();\n-  void sleep_before_next_cycle();\n+  \/\/ Return the next ready task, waiting until a task is ready.\n+  \/\/ Instead returns nullptr if termination requested.\n+  G1ServiceTask* wait_for_task();\n@@ -116,1 +117,0 @@\n-  G1ServiceTask* pop_due_task();\n@@ -121,5 +121,1 @@\n-  void schedule(G1ServiceTask* task, jlong delay);\n-\n-  \/\/ Notify a change to the service thread. Used to either stop\n-  \/\/ the service or to force check for new tasks.\n-  void notify();\n+  void schedule(G1ServiceTask* task, jlong delay, bool notify);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  _terminating = g1h->_cm_thread->should_terminate();\n+  _terminating = g1h->concurrent_mark_is_terminating();\n@@ -173,1 +173,1 @@\n-  TraceCollectorStats tcs(g1h->g1mm()->conc_collection_counters());\n+  TraceCollectorStats tcs(g1h->monitoring_support()->conc_collection_counters());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -44,0 +46,3 @@\n+  if (SampleCollectionSetCandidatesTask::should_execute()) {\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n+  }\n@@ -67,0 +72,26 @@\n+bool G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::should_execute() {\n+  return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n+}\n+\n+double G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::worker_cost() const {\n+  return should_execute() ? 1.0 : AlmostNoWork;\n+}\n+\n+class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+public:\n+  G1CardSetMemoryStats _total;\n+\n+  bool do_heap_region(HeapRegion* r) override {\n+    _total.add(r->rem_set()->card_set_memory_stats());\n+    return false;\n+  }\n+};\n+\n+void G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::do_work(uint worker_id) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+  G1SampleCollectionSetCandidatesClosure cl;\n+  g1h->collection_set()->candidates()->iterate(&cl);\n+  g1h->set_collection_set_candidates_stats(cl._total);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/ - Sample Collection Set Candidates (s)\n@@ -46,0 +47,1 @@\n+  class SampleCollectionSetCandidatesTask;\n@@ -71,0 +73,10 @@\n+class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n+public:\n+  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n+\n+  static bool should_execute();\n+\n+  double worker_cost() const override;\n+  void do_work(uint worker_id) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,2 +133,2 @@\n-          \"Each time the rset update queue increases by this amount \"       \\\n-          \"activate the next refinement thread if available. \"              \\\n+          \"Each time the remembered set update queue increases by this \"    \\\n+          \"amount activate the next refinement thread if available. \"       \\\n@@ -141,1 +141,2 @@\n-          \"process RS update buffers during the collection pause.\")         \\\n+          \"processing remembered set update buffers during the collection \" \\\n+          \"pause.\")                                                         \\\n@@ -156,20 +157,34 @@\n-  develop(intx, G1RSetRegionEntriesBase, 256,                               \\\n-          \"Max number of regions in a fine-grain table per MB.\")            \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetRegionEntries, 0,                                     \\\n-          \"Max number of regions for which we keep bitmaps.\"                \\\n-          \"Will be set ergonomically by default\")                           \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \\\n-                                                                            \\\n-  develop(intx, G1RSetSparseRegionEntriesBase, 4,                           \\\n-          \"Max number of entries per region in a sparse table \"             \\\n-          \"per MB.\")                                                        \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetSparseRegionEntries, 0,                               \\\n-          \"Max number of entries per region in a sparse table.\"             \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \\\n+  develop(uint, G1RemSetArrayOfCardsEntriesBase, 4,                         \\\n+          \"Maximum number of entries per region in the Array of Cards \"     \\\n+          \"card set container per MB of a heap region.\")                    \\\n+          range(1, 65536)                                                   \\\n+                                                                            \\\n+  product(uint, G1RemSetArrayOfCardsEntries, 0,  EXPERIMENTAL,              \\\n+          \"Maximum number of entries per Array of Cards card set \"          \\\n+          \"container. Will be set ergonomically by default.\")               \\\n+          range(0, 65536)                                                   \\\n+          constraint(G1RemSetArrayOfCardsEntriesConstraintFunc,AfterErgo)   \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlMaxNumBuckets, 8, EXPERIMENTAL,                 \\\n+          \"Maximum number of buckets per Howl card set container. The \"     \\\n+          \"default gives at worst bitmaps of size 8k. This showed to be a \" \\\n+          \"good tradeoff between bitmap size (waste) and cacheability of \"  \\\n+          \"the bucket array. Must be a power of two.\")                      \\\n+          range(1, 1024)                                                    \\\n+          constraint(G1RemSetHowlMaxNumBucketsConstraintFunc,AfterErgo)     \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlNumBuckets, 0, EXPERIMENTAL,                    \\\n+          \"Number of buckets per Howl card set container. Must be a power \" \\\n+          \"of two. Will be set ergonomically by default.\")                  \\\n+          range(0, 1024)                                                    \\\n+          constraint(G1RemSetHowlNumBucketsConstraintFunc,AfterErgo)        \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlBitmapToHowlFullPercent, 90, EXPERIMENTAL, \\\n+          \"Percentage at which to coarsen a Howl bitmap to Howl full card \" \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlToFullPercent, 90, EXPERIMENTAL,         \\\n+          \"Percentage at which to coarsen a Howl card set to Full card \"    \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n@@ -193,1 +208,1 @@\n-          \"The number of parallel rem set update threads. \"                 \\\n+          \"The number of parallel remembered set update threads. \"          \\\n@@ -312,0 +327,16 @@\n+  product(uint, G1RemSetFreeMemoryRescheduleDelayMillis, 10, EXPERIMENTAL,  \\\n+          \"Time after which the card set free memory task reschedules \"     \\\n+          \"itself if there is work remaining.\")                             \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryStepDurationMillis, 1, EXPERIMENTAL,    \\\n+          \"The amount of time that the free memory task should spend \"      \\\n+          \"before a pause of G1RemSetFreeMemoryRescheduleDelayMillis \"      \\\n+          \"length.\")                                                        \\\n+          range(1e-3, 1e+6)                                                 \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryKeepExcessRatio, 0.1, EXPERIMENTAL,     \\\n+          \"The percentage of free card set memory that G1 should keep as \"  \\\n+          \"percentage of the currently used memory.\")                       \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":56,"deletions":25,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -229,1 +229,2 @@\n-                       MemRegion mr) :\n+                       MemRegion mr,\n+                       G1CardSetConfiguration* config) :\n@@ -255,1 +256,1 @@\n-  _rem_set = new HeapRegionRemSet(bot, this);\n+  _rem_set = new HeapRegionRemSet(this, config);\n@@ -613,0 +614,2 @@\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -617,1 +620,0 @@\n-          LogStream ls(log.error());\n@@ -735,55 +737,0 @@\n-  HeapWord* the_end = end();\n-  \/\/ Do some extra BOT consistency checking for addresses in the\n-  \/\/ range [top, end). BOT look-ups in this range should yield\n-  \/\/ top. No point in doing that if top == end (there's nothing there).\n-  if (p < the_end) {\n-    \/\/ Look up top\n-    HeapWord* addr_1 = p;\n-    HeapWord* b_start_1 = block_start_const(addr_1);\n-    if (b_start_1 != p) {\n-      log_error(gc, verify)(\"BOT look up for top: \" PTR_FORMAT \" \"\n-                            \" yielded \" PTR_FORMAT \", expecting \" PTR_FORMAT,\n-                            p2i(addr_1), p2i(b_start_1), p2i(p));\n-      *failures = true;\n-      return;\n-    }\n-\n-    \/\/ Look up top + 1\n-    HeapWord* addr_2 = p + 1;\n-    if (addr_2 < the_end) {\n-      HeapWord* b_start_2 = block_start_const(addr_2);\n-      if (b_start_2 != p) {\n-        log_error(gc, verify)(\"BOT look up for top + 1: \" PTR_FORMAT \" \"\n-                              \" yielded \" PTR_FORMAT \", expecting \" PTR_FORMAT,\n-                              p2i(addr_2), p2i(b_start_2), p2i(p));\n-        *failures = true;\n-        return;\n-      }\n-    }\n-\n-    \/\/ Look up an address between top and end\n-    size_t diff = pointer_delta(the_end, p) \/ 2;\n-    HeapWord* addr_3 = p + diff;\n-    if (addr_3 < the_end) {\n-      HeapWord* b_start_3 = block_start_const(addr_3);\n-      if (b_start_3 != p) {\n-        log_error(gc, verify)(\"BOT look up for top + diff: \" PTR_FORMAT \" \"\n-                              \" yielded \" PTR_FORMAT \", expecting \" PTR_FORMAT,\n-                              p2i(addr_3), p2i(b_start_3), p2i(p));\n-        *failures = true;\n-        return;\n-      }\n-    }\n-\n-    \/\/ Look up end - 1\n-    HeapWord* addr_4 = the_end - 1;\n-    HeapWord* b_start_4 = block_start_const(addr_4);\n-    if (b_start_4 != p) {\n-      log_error(gc, verify)(\"BOT look up for end - 1: \" PTR_FORMAT \" \"\n-                            \" yielded \" PTR_FORMAT \", expecting \" PTR_FORMAT,\n-                            p2i(addr_4), p2i(b_start_4), p2i(p));\n-      *failures = true;\n-      return;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":6,"deletions":59,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+class G1CardSetConfiguration;\n+class G1CardSetMemoryManager;\n@@ -284,1 +286,4 @@\n-  HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);\n+  HeapRegion(uint hrm_index,\n+             G1BlockOffsetTable* bot,\n+             MemRegion mr,\n+             G1CardSetConfiguration* config);\n@@ -448,0 +453,1 @@\n+  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include <cstdio>\n+\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.inline.hpp\"\n@@ -47,346 +48,8 @@\n-PerRegionTable* PerRegionTable::alloc(HeapRegion* hr) {\n-  PerRegionTable* fl = _free_list;\n-  while (fl != NULL) {\n-    PerRegionTable* nxt = fl->next();\n-    PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, nxt);\n-    if (res == fl) {\n-      fl->init(hr, true);\n-      return fl;\n-    } else {\n-      fl = _free_list;\n-    }\n-  }\n-  assert(fl == NULL, \"Loop condition.\");\n-  return new PerRegionTable(hr);\n-}\n-\n-PerRegionTable* volatile PerRegionTable::_free_list = NULL;\n-\n-size_t OtherRegionsTable::_max_fine_entries = 0;\n-size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;\n-size_t OtherRegionsTable::_fine_eviction_stride = 0;\n-size_t OtherRegionsTable::_fine_eviction_sample_size = 0;\n-\n-OtherRegionsTable::OtherRegionsTable(Mutex* m) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _m(m),\n-  _num_occupied(0),\n-  _coarse_map(mtGC),\n-  _has_coarse_entries(false),\n-  _fine_grain_regions(NULL),\n-  _n_fine_entries(0),\n-  _first_all_fine_prts(NULL),\n-  _last_all_fine_prts(NULL),\n-  _fine_eviction_start(0),\n-  _sparse_table()\n-{\n-  typedef PerRegionTable* PerRegionTablePtr;\n-\n-  if (_max_fine_entries == 0) {\n-    assert(_mod_max_fine_entries_mask == 0, \"Both or none.\");\n-    size_t max_entries_log = (size_t)log2i(G1RSetRegionEntries);\n-    _max_fine_entries = (size_t)1 << max_entries_log;\n-    _mod_max_fine_entries_mask = _max_fine_entries - 1;\n-\n-    assert(_fine_eviction_sample_size == 0\n-           && _fine_eviction_stride == 0, \"All init at same time.\");\n-    _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);\n-    _fine_eviction_stride = _max_fine_entries \/ _fine_eviction_sample_size;\n-  }\n-\n-  _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);\n-  for (size_t i = 0; i < _max_fine_entries; i++) {\n-    _fine_grain_regions[i] = NULL;\n-  }\n-}\n-\n-void OtherRegionsTable::link_to_all(PerRegionTable* prt) {\n-  \/\/ We always append to the beginning of the list for convenience;\n-  \/\/ the order of entries in this list does not matter.\n-  if (_first_all_fine_prts != NULL) {\n-    prt->set_next(_first_all_fine_prts);\n-  } else {\n-    \/\/ this is the first element we insert. Adjust the \"last\" pointer\n-    _last_all_fine_prts = prt;\n-    assert(prt->next() == NULL, \"just checking\");\n-  }\n-  _first_all_fine_prts = prt;\n-\n-  assert(_first_all_fine_prts == prt, \"just checking\");\n-  assert((_first_all_fine_prts == NULL && _last_all_fine_prts == NULL) ||\n-         (_first_all_fine_prts != NULL && _last_all_fine_prts != NULL),\n-         \"just checking\");\n-  assert(_last_all_fine_prts == NULL || _last_all_fine_prts->next() == NULL,\n-         \"just checking\");\n-}\n-\n-CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {\n-  assert(hr->is_in_reserved(within_region),\n-         \"HeapWord \" PTR_FORMAT \" is outside of region %u [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(within_region), hr->hrm_index(), p2i(hr->bottom()), p2i(hr->end()));\n-  CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n-  return result;\n-}\n-\n-void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {\n-  \/\/ Note that this may be a continued H region.\n-  HeapRegion* from_hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr->hrm_index();\n-\n-  \/\/ If the region is already coarsened, return.\n-  if (is_region_coarsened(from_hrm_ind)) {\n-    assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-    return;\n-  }\n-\n-  size_t num_added_by_coarsening = 0;\n-  \/\/ Otherwise find a per-region table to add it to.\n-  size_t ind = from_hrm_ind & _mod_max_fine_entries_mask;\n-  PerRegionTable* prt = find_region_table(ind, from_hr);\n-  if (prt == NULL) {\n-    MutexLocker x(_m, Mutex::_no_safepoint_check_flag);\n-\n-    \/\/ Rechecking if the region is coarsened, while holding the lock.\n-    if (is_region_coarsened(from_hrm_ind)) {\n-      assert(contains_reference_locked(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-      return;\n-    }\n-\n-    \/\/ Confirm that it's really not there...\n-    prt = find_region_table(ind, from_hr);\n-    if (prt == NULL) {\n-\n-      CardIdx_t card_index = card_within_region(from, from_hr);\n-\n-      SparsePRT::AddCardResult result = _sparse_table.add_card(from_hrm_ind, card_index);\n-      if (result != SparsePRT::overflow) {\n-        if (result == SparsePRT::added) {\n-          Atomic::inc(&_num_occupied, memory_order_relaxed);\n-        }\n-        assert(contains_reference_locked(from), \"We just added \" PTR_FORMAT \" to the Sparse table\", p2i(from));\n-        return;\n-      }\n-\n-      \/\/ Sparse PRT returned overflow (sparse table is full)\n-\n-      if (_n_fine_entries == _max_fine_entries) {\n-        prt = delete_region_table(num_added_by_coarsening);\n-        \/\/ There is no need to clear the links to the 'all' list here:\n-        \/\/ prt will be reused immediately, i.e. remain in the 'all' list.\n-        prt->init(from_hr, false \/* clear_links_to_all_list *\/);\n-      } else {\n-        prt = PerRegionTable::alloc(from_hr);\n-        link_to_all(prt);\n-      }\n-\n-      PerRegionTable* first_prt = _fine_grain_regions[ind];\n-      prt->set_collision_list_next(first_prt);\n-      \/\/ The assignment into _fine_grain_regions allows the prt to\n-      \/\/ start being used concurrently. In addition to\n-      \/\/ collision_list_next which must be visible (else concurrent\n-      \/\/ parsing of the list, if any, may fail to see other entries),\n-      \/\/ the content of the prt must be visible (else for instance\n-      \/\/ some mark bits may not yet seem cleared or a 'later' update\n-      \/\/ performed by a concurrent thread could be undone when the\n-      \/\/ zeroing becomes visible). This requires store ordering.\n-      Atomic::release_store(&_fine_grain_regions[ind], prt);\n-      _n_fine_entries++;\n-\n-      \/\/ Transfer from sparse to fine-grain. The cards from the sparse table\n-      \/\/ were already added to the total in _num_occupied.\n-      SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);\n-      assert(sprt_entry != NULL, \"There should have been an entry\");\n-      for (int i = 0; i < sprt_entry->num_valid_cards(); i++) {\n-        CardIdx_t c = sprt_entry->card(i);\n-        prt->add_card(c);\n-      }\n-      \/\/ Now we can delete the sparse entry.\n-      bool res = _sparse_table.delete_entry(from_hrm_ind);\n-      assert(res, \"It should have been there.\");\n-    }\n-    assert(prt != NULL && prt->hr() == from_hr, \"consequence\");\n-  }\n-  \/\/ Note that we can't assert \"prt->hr() == from_hr\", because of the\n-  \/\/ possibility of concurrent reuse.  But see head comment of\n-  \/\/ OtherRegionsTable for why this is OK.\n-  assert(prt != NULL, \"Inv\");\n-\n-  if (prt->add_reference(from)) {\n-    num_added_by_coarsening++;\n-  }\n-  Atomic::add(&_num_occupied, num_added_by_coarsening, memory_order_relaxed);\n-  assert(contains_reference(from), \"We just added \" PTR_FORMAT \" to the PRT (%d)\", p2i(from), prt->contains_reference(from));\n-}\n-\n-PerRegionTable*\n-OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {\n-  assert(ind < _max_fine_entries, \"Preconditions.\");\n-  PerRegionTable* prt = _fine_grain_regions[ind];\n-  while (prt != NULL && prt->hr() != hr) {\n-    prt = prt->collision_list_next();\n-  }\n-  \/\/ Loop postcondition is the method postcondition.\n-  return prt;\n-}\n-\n-jint OtherRegionsTable::_n_coarsenings = 0;\n-\n-PerRegionTable* OtherRegionsTable::delete_region_table(size_t& added_by_deleted) {\n-  assert(_m->owned_by_self(), \"Precondition\");\n-  assert(_n_fine_entries == _max_fine_entries, \"Precondition\");\n-  PerRegionTable* max = NULL;\n-  jint max_occ = 0;\n-  PerRegionTable** max_prev = NULL;\n-\n-  size_t i = _fine_eviction_start;\n-  for (size_t k = 0; k < _fine_eviction_sample_size; k++) {\n-    size_t ii = i;\n-    \/\/ Make sure we get a non-NULL sample.\n-    while (_fine_grain_regions[ii] == NULL) {\n-      ii++;\n-      if (ii == _max_fine_entries) ii = 0;\n-      guarantee(ii != i, \"We must find one.\");\n-    }\n-    PerRegionTable** prev = &_fine_grain_regions[ii];\n-    PerRegionTable* cur = *prev;\n-    while (cur != NULL) {\n-      jint cur_occ = cur->occupied();\n-      if (max == NULL || cur_occ > max_occ) {\n-        max = cur;\n-        max_prev = prev;\n-        max_occ = cur_occ;\n-      }\n-      prev = cur->collision_list_next_addr();\n-      cur = cur->collision_list_next();\n-    }\n-    i = i + _fine_eviction_stride;\n-    if (i >= _n_fine_entries) i = i - _n_fine_entries;\n-  }\n-\n-  _fine_eviction_start++;\n-\n-  if (_fine_eviction_start >= _n_fine_entries) {\n-    _fine_eviction_start -= _n_fine_entries;\n-  }\n-\n-  guarantee(max != NULL, \"Since _n_fine_entries > 0\");\n-  guarantee(max_prev != NULL, \"Since max != NULL.\");\n-\n-  \/\/ Ensure the corresponding coarse bit is set.\n-  size_t max_hrm_index = (size_t) max->hr()->hrm_index();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.at_put(max_hrm_index, true);\n-  } else {\n-    \/\/ This will lazily initialize an uninitialized bitmap\n-    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_reserved_regions());\n-    assert(!_coarse_map.at(max_hrm_index), \"No coarse entries\");\n-    _coarse_map.at_put(max_hrm_index, true);\n-    \/\/ Release store guarantees that the bitmap has initialized before any\n-    \/\/ concurrent reader will ever see _has_coarse_entries is true\n-    \/\/ (when read with load_acquire)\n-    Atomic::release_store(&_has_coarse_entries, true);\n-  }\n-\n-  added_by_deleted = HeapRegion::CardsPerRegion - max_occ;\n-  \/\/ Unsplice.\n-  *max_prev = max->collision_list_next();\n-  Atomic::inc(&_n_coarsenings);\n-  _n_fine_entries--;\n-  return max;\n-}\n-\n-bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {\n-  return occupied() <= limit;\n-}\n-\n-bool OtherRegionsTable::is_empty() const {\n-  return occupied() == 0;\n-}\n-\n-size_t OtherRegionsTable::occupied() const {\n-  return _num_occupied;\n-}\n-\n-size_t OtherRegionsTable::mem_size() const {\n-  size_t sum = 0;\n-  \/\/ all PRTs are of the same size so it is sufficient to query only one of them.\n-  if (_first_all_fine_prts != NULL) {\n-    assert(_last_all_fine_prts != NULL &&\n-      _first_all_fine_prts->mem_size() == _last_all_fine_prts->mem_size(), \"check that mem_size() is constant\");\n-    sum += _first_all_fine_prts->mem_size() * _n_fine_entries;\n-  }\n-  sum += (sizeof(PerRegionTable*) * _max_fine_entries);\n-  sum += (_coarse_map.size_in_words() * HeapWordSize);\n-  sum += (_sparse_table.mem_size());\n-  sum += sizeof(OtherRegionsTable) - sizeof(_sparse_table); \/\/ Avoid double counting above.\n-  return sum;\n-}\n-\n-size_t OtherRegionsTable::static_mem_size() {\n-  return G1FromCardCache::static_mem_size();\n-}\n-\n-size_t OtherRegionsTable::fl_mem_size() {\n-  return PerRegionTable::fl_mem_size();\n-}\n-\n-void OtherRegionsTable::clear() {\n-  \/\/ if there are no entries, skip this step\n-  if (_first_all_fine_prts != NULL) {\n-    guarantee(_first_all_fine_prts != NULL && _last_all_fine_prts != NULL, \"just checking\");\n-    PerRegionTable::bulk_free(_first_all_fine_prts, _last_all_fine_prts);\n-    memset(_fine_grain_regions, 0, _max_fine_entries * sizeof(_fine_grain_regions[0]));\n-  } else {\n-    guarantee(_first_all_fine_prts == NULL && _last_all_fine_prts == NULL, \"just checking\");\n-  }\n-\n-  _first_all_fine_prts = _last_all_fine_prts = NULL;\n-  _sparse_table.clear();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.clear();\n-  }\n-  _n_fine_entries = 0;\n-  Atomic::store(&_has_coarse_entries, false);\n-\n-  _num_occupied = 0;\n-}\n-\n-bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {\n-  \/\/ Cast away const in this case.\n-  MutexLocker x((Mutex*)_m, Mutex::_no_safepoint_check_flag);\n-  return contains_reference_locked(from);\n-}\n-\n-bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {\n-  HeapRegion* hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t hr_ind = (RegionIdx_t) hr->hrm_index();\n-  \/\/ Is this region in the coarse map?\n-  if (is_region_coarsened(hr_ind)) return true;\n-\n-  PerRegionTable* prt = find_region_table(hr_ind & _mod_max_fine_entries_mask,\n-                                          hr);\n-  if (prt != NULL) {\n-    return prt->contains_reference(from);\n-  } else {\n-    CardIdx_t card_index = card_within_region(from, hr);\n-    return _sparse_table.contains_card(hr_ind, card_index);\n-  }\n-}\n-\n-\/\/ A load_acquire on _has_coarse_entries - coupled with the release_store in\n-\/\/ delete_region_table - guarantees we don't access _coarse_map before\n-\/\/ it's been properly initialized.\n-bool OtherRegionsTable::is_region_coarsened(RegionIdx_t from_hrm_ind) const {\n-  return Atomic::load_acquire(&_has_coarse_entries) && _coarse_map.at(from_hrm_ind);\n-}\n-\n-HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,\n-                                   HeapRegion* hr)\n-  : _bot(bot),\n-    _code_roots(),\n-    _m(Mutex::leaf, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Mutex::_safepoint_check_never),\n-    _other_regions(&_m),\n-    _hr(hr),\n-    _state(Untracked)\n-{\n-}\n+HeapRegionRemSet::HeapRegionRemSet(HeapRegion* hr,\n+                                   G1CardSetConfiguration* config) :\n+  _m(Mutex::leaf + 1, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Monitor::_safepoint_check_never),\n+  _code_roots(),\n+  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _hr(hr),\n+  _state(Untracked) { }\n@@ -398,14 +61,0 @@\n-void HeapRegionRemSet::setup_remset_size() {\n-  const int LOG_M = 20;\n-  guarantee(HeapRegion::LogOfHRGrainBytes >= LOG_M, \"Code assumes the region size >= 1M, but is \" SIZE_FORMAT \"B\", HeapRegion::GrainBytes);\n-\n-  int region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;\n-  if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {\n-    G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * ((size_t)1 << (region_size_log_mb + 1));\n-  }\n-  if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {\n-    G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);\n-  }\n-  guarantee(G1RSetSparseRegionEntries > 0 && G1RSetRegionEntries > 0 , \"Sanity\");\n-}\n-\n@@ -422,1 +71,1 @@\n-  _other_regions.clear();\n+  _card_set.clear();\n@@ -427,0 +76,4 @@\n+void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":15,"deletions":362,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -34,240 +36,1 @@\n-\/\/ Remembered set for a heap region.  Represent a set of \"cards\" that\n-\/\/ contain pointers into the owner heap region.  Cards are defined somewhat\n-\/\/ abstractly, in terms of what the \"BlockOffsetTable\" in use can parse.\n-\n-class G1CollectedHeap;\n-class G1BlockOffsetTable;\n-class G1CardLiveData;\n-class HeapRegion;\n-class PerRegionTable;\n-class SparsePRT;\n-class nmethod;\n-\n-\/\/ The \"_coarse_map\" is a bitmap with one bit for each region, where set\n-\/\/ bits indicate that the corresponding region may contain some pointer\n-\/\/ into the owning region.\n-\n-\/\/ The \"_fine_grain_entries\" array is an open hash table of PerRegionTables\n-\/\/ (PRTs), indicating regions for which we're keeping the RS as a set of\n-\/\/ cards.  The strategy is to cap the size of the fine-grain table,\n-\/\/ deleting an entry and setting the corresponding coarse-grained bit when\n-\/\/ we would overflow this cap.\n-\n-\/\/ We use a mixture of locking and lock-free techniques here.  We allow\n-\/\/ threads to locate PRTs without locking, but threads attempting to alter\n-\/\/ a bucket list obtain a lock.  This means that any failing attempt to\n-\/\/ find a PRT must be retried with the lock.  It might seem dangerous that\n-\/\/ a read can find a PRT that is concurrently deleted.  This is all right,\n-\/\/ because:\n-\/\/\n-\/\/   1) We only actually free PRT's at safe points (though we reuse them at\n-\/\/      other times).\n-\/\/   2) We find PRT's in an attempt to add entries.  If a PRT is deleted,\n-\/\/      it's _coarse_map bit is set, so the that we were attempting to add\n-\/\/      is represented.  If a deleted PRT is re-used, a thread adding a bit,\n-\/\/      thinking the PRT is for a different region, does no harm.\n-\n-class OtherRegionsTable {\n-  G1CollectedHeap* _g1h;\n-  Mutex*           _m;\n-\n-  size_t volatile _num_occupied;\n-\n-  \/\/ These are protected by \"_m\".\n-  CHeapBitMap   _coarse_map;\n-  bool volatile _has_coarse_entries;\n-  static jint   _n_coarsenings;\n-\n-  PerRegionTable** _fine_grain_regions;\n-  size_t           _n_fine_entries;\n-\n-  \/\/ The fine grain remembered sets are linked together using\n-  \/\/ their 'next' fields.\n-  \/\/ This allows fast bulk freeing of all the fine grain remembered\n-  \/\/ set entries, and fast finding of all of them without iterating\n-  \/\/ over the _fine_grain_regions table.\n-  PerRegionTable * _first_all_fine_prts;\n-  PerRegionTable * _last_all_fine_prts;\n-\n-  \/\/ Used to sample a subset of the fine grain PRTs to determine which\n-  \/\/ PRT to evict and coarsen.\n-  size_t        _fine_eviction_start;\n-  static size_t _fine_eviction_stride;\n-  static size_t _fine_eviction_sample_size;\n-\n-  SparsePRT   _sparse_table;\n-\n-  \/\/ These are static after init.\n-  static size_t _max_fine_entries;\n-  static size_t _mod_max_fine_entries_mask;\n-\n-  \/\/ Requires \"prt\" to be the first element of the bucket list appropriate\n-  \/\/ for \"hr\".  If this list contains an entry for \"hr\", return it,\n-  \/\/ otherwise return \"NULL\".\n-  PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;\n-\n-  \/\/ Find, delete, and return a candidate PerRegionTable, if any exists,\n-  \/\/ adding the deleted region to the coarse bitmap.  Requires the caller\n-  \/\/ to hold _m, and the fine-grain table to be full.\n-  PerRegionTable* delete_region_table(size_t& added_by_deleted);\n-\n-  \/\/ link\/add the given fine grain remembered set into the \"all\" list\n-  void link_to_all(PerRegionTable * prt);\n-\n-  bool contains_reference_locked(OopOrNarrowOopStar from) const;\n-\n-public:\n-  \/\/ Create a new remembered set. The given mutex is used to ensure consistency.\n-  OtherRegionsTable(Mutex* m);\n-\n-  template <class Closure>\n-  void iterate(Closure& v);\n-\n-  \/\/ Returns the card index of the given within_region pointer relative to the bottom\n-  \/\/ of the given heap region.\n-  static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);\n-  \/\/ Adds the reference from \"from to this remembered set.\n-  void add_reference(OopOrNarrowOopStar from, uint tid);\n-\n-  \/\/ Returns whether the remembered set contains the given reference.\n-  bool contains_reference(OopOrNarrowOopStar from) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n-  \/\/ that is less or equal than the given occupancy.\n-  bool occupancy_less_or_equal_than(size_t limit) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n-  bool is_empty() const;\n-\n-  \/\/ Returns the number of cards contained in this remembered set.\n-  size_t occupied() const;\n-\n-  static jint n_coarsenings() { return _n_coarsenings; }\n-\n-  \/\/ Returns size of the actual remembered set containers in bytes.\n-  size_t mem_size() const;\n-  \/\/ Returns the size of static data in bytes.\n-  static size_t static_mem_size();\n-  \/\/ Returns the size of the free list content in bytes.\n-  static size_t fl_mem_size();\n-\n-  \/\/ Clear the entire contents of this remembered set.\n-  void clear();\n-\n-  \/\/ Safe for use by concurrent readers outside _m\n-  bool is_region_coarsened(RegionIdx_t from_hrm_ind) const;\n-};\n-\n-class PerRegionTable: public CHeapObj<mtGC> {\n-  friend class OtherRegionsTable;\n-\n-  HeapRegion*     _hr;\n-  CHeapBitMap     _bm;\n-  jint            _occupied;\n-\n-  \/\/ next pointer for free\/allocated 'all' list\n-  PerRegionTable* _next;\n-\n-  \/\/ next pointer in collision list\n-  PerRegionTable * _collision_list_next;\n-\n-  \/\/ Global free list of PRTs\n-  static PerRegionTable* volatile _free_list;\n-\n-protected:\n-  PerRegionTable(HeapRegion* hr) :\n-    _hr(hr),\n-    _bm(HeapRegion::CardsPerRegion, mtGC),\n-    _occupied(0),\n-    _next(NULL),\n-    _collision_list_next(NULL)\n-  {}\n-\n-public:\n-  \/\/ We need access in order to union things into the base table.\n-  BitMap* bm() { return &_bm; }\n-\n-  HeapRegion* hr() const { return Atomic::load_acquire(&_hr); }\n-\n-  jint occupied() const {\n-    return _occupied;\n-  }\n-\n-  void init(HeapRegion* hr, bool clear_links_to_all_list);\n-\n-  inline bool add_reference(OopOrNarrowOopStar from);\n-\n-  inline bool add_card(CardIdx_t from_card_index);\n-\n-  \/\/ (Destructively) union the bitmap of the current table into the given\n-  \/\/ bitmap (which is assumed to be of the same size.)\n-  void union_bitmap_into(BitMap* bm) {\n-    bm->set_union(_bm);\n-  }\n-\n-  \/\/ Mem size in bytes.\n-  size_t mem_size() const {\n-    return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;\n-  }\n-\n-  \/\/ Requires \"from\" to be in \"hr()\".\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    assert(hr()->is_in_reserved(from), \"Precondition.\");\n-    size_t card_ind = pointer_delta(from, hr()->bottom(),\n-                                    G1CardTable::card_size);\n-    return _bm.at(card_ind);\n-  }\n-\n-  \/\/ Bulk-free the PRTs from prt to last, assumes that they are\n-  \/\/ linked together using their _next field.\n-  static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {\n-    while (true) {\n-      PerRegionTable* fl = _free_list;\n-      last->set_next(fl);\n-      PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, prt);\n-      if (res == fl) {\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-\n-  static void free(PerRegionTable* prt) {\n-    bulk_free(prt, prt);\n-  }\n-\n-  \/\/ Returns an initialized PerRegionTable instance.\n-  static PerRegionTable* alloc(HeapRegion* hr);\n-\n-  PerRegionTable* next() const { return _next; }\n-  void set_next(PerRegionTable* next) { _next = next; }\n-\n-  \/\/ Accessor and Modification routines for the pointer for the\n-  \/\/ singly linked collision list that links the PRTs within the\n-  \/\/ OtherRegionsTable::_fine_grain_regions hash table.\n-  \/\/\n-\n-  PerRegionTable* collision_list_next() const {\n-    return _collision_list_next;\n-  }\n-\n-  void set_collision_list_next(PerRegionTable* next) {\n-    _collision_list_next = next;\n-  }\n-\n-  PerRegionTable** collision_list_next_addr() {\n-    return &_collision_list_next;\n-  }\n-\n-  static size_t fl_mem_size() {\n-    PerRegionTable* cur = _free_list;\n-    size_t res = 0;\n-    while (cur != NULL) {\n-      res += cur->mem_size();\n-      cur = cur->next();\n-    }\n-    return res;\n-  }\n-\n-  static void test_fl_mem_size();\n-};\n+class outputStream;\n@@ -278,3 +41,1 @@\n-private:\n-  G1BlockOffsetTable* _bot;\n-\n+  Mutex _m;\n@@ -285,1 +46,1 @@\n-  Mutex _m;\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -287,1 +48,2 @@\n-  OtherRegionsTable _other_regions;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -291,0 +53,1 @@\n+  inline void split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const;\n@@ -294,1 +57,1 @@\n-  HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);\n+  HeapRegionRemSet(HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -297,1 +60,3 @@\n-  static void setup_remset_size();\n+  bool cardset_is_empty() const {\n+    return _card_set.is_empty();\n+  }\n@@ -300,1 +65,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.is_empty();\n+    return (strong_code_roots_list_length() == 0) && cardset_is_empty();\n@@ -304,1 +69,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.occupancy_less_or_equal_than(occ);\n+    return (strong_code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n@@ -307,8 +72,5 @@\n-  \/\/ For each PRT in the card (remembered) set call one of the following methods\n-  \/\/ of the given closure:\n-  \/\/\n-  \/\/ set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs\n-  \/\/ set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs\n-  \/\/ set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs\n-  template <class Closure>\n-  inline void iterate_prts(Closure& cl);\n+  \/\/ Iterate the card based remembered set for merging them into the card table.\n+  \/\/ The passed closure must be a CardOrRangeVisitor; we use a template parameter\n+  \/\/ to pass it in to facilitate inlining as much as possible.\n+  template <class CardOrRangeVisitor>\n+  inline void iterate_for_merge(CardOrRangeVisitor& cl);\n@@ -317,1 +79,1 @@\n-    return _other_regions.occupied();\n+    return _card_set.occupied();\n@@ -320,1 +82,2 @@\n-  static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }\n+  \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats coarsen_stats() { return G1CardSet::coarsen_stats(); }\n@@ -342,8 +105,3 @@\n-  void set_state_empty() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n-    if (_state == Untracked) {\n-      return;\n-    }\n-    clear_fcc();\n-    _state = Untracked;\n-  }\n+  inline void set_state_empty();\n+  inline void set_state_updating();\n+  inline void set_state_complete();\n@@ -351,27 +109,1 @@\n-  void set_state_updating() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(), \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n-    clear_fcc();\n-    _state = Updating;\n-  }\n-\n-  void set_state_complete() {\n-    clear_fcc();\n-    _state = Complete;\n-  }\n-\n-  void add_reference(OopOrNarrowOopStar from, uint tid) {\n-    RemSetState state = _state;\n-    if (state == Untracked) {\n-      return;\n-    }\n-\n-    uint cur_idx = _hr->hrm_index();\n-    uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n-\n-    if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n-      assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n-      return;\n-    }\n-\n-    _other_regions.add_reference(from, tid);\n-  }\n+  inline void add_reference(OopOrNarrowOopStar from, uint tid);\n@@ -384,2 +116,4 @@\n-  \/\/ The actual # of bytes this hr_remset takes up.\n-  \/\/ Note also includes the strong code root set.\n+  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+\n+  \/\/ The actual # of bytes this hr_remset takes up. Also includes the strong code\n+  \/\/ root set.\n@@ -387,5 +121,2 @@\n-    MutexLocker x(&_m, Mutex::_no_safepoint_check_flag);\n-    return _other_regions.mem_size()\n-      \/\/ This correction is necessary because the above includes the second\n-      \/\/ part.\n-      + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))\n+    return _card_set.mem_size()\n+      + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n@@ -395,0 +126,4 @@\n+  size_t wasted_mem_size() {\n+    return _card_set.wasted_mem_size();\n+  }\n+\n@@ -398,1 +133,1 @@\n-    return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n@@ -401,5 +136,1 @@\n-  \/\/ Returns the memory occupancy of all free_list data structures associated\n-  \/\/ with remembered sets.\n-  static size_t fl_mem_size() {\n-    return OtherRegionsTable::fl_mem_size();\n-  }\n+  static void print_static_mem_size(outputStream* out);\n@@ -407,3 +138,3 @@\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    return _other_regions.contains_reference(from);\n-  }\n+  inline bool contains_reference(OopOrNarrowOopStar from);\n+\n+  inline void print_info(outputStream* st, OopOrNarrowOopStar from);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":43,"deletions":312,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -35,3 +36,8 @@\n-template <class Closure>\n-inline void HeapRegionRemSet::iterate_prts(Closure& cl) {\n-  _other_regions.iterate(cl);\n+void HeapRegionRemSet::set_state_empty() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(),\n+            \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n+  if (_state == Untracked) {\n+    return;\n+  }\n+  clear_fcc();\n+  _state = Untracked;\n@@ -40,6 +46,5 @@\n-inline bool PerRegionTable::add_card(CardIdx_t from_card_index) {\n-  if (_bm.par_set_bit(from_card_index)) {\n-    Atomic::inc(&_occupied, memory_order_relaxed);\n-    return true;\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_updating() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(),\n+            \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n+  clear_fcc();\n+  _state = Updating;\n@@ -48,13 +53,3 @@\n-inline bool PerRegionTable::add_reference(OopOrNarrowOopStar from) {\n-  \/\/ Must make this robust in case \"from\" is not in \"_hr\", because of\n-  \/\/ concurrency.\n-\n-  HeapRegion* loc_hr = hr();\n-  \/\/ If the test below fails, then this table was reused concurrently\n-  \/\/ with this operation.  This is OK, since the old table was coarsened,\n-  \/\/ and adding a bit to the new table is never incorrect.\n-  if (loc_hr->is_in_reserved(from)) {\n-    CardIdx_t from_card = OtherRegionsTable::card_within_region(from, loc_hr);\n-    return add_card(from_card);\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_complete() {\n+  clear_fcc();\n+  _state = Complete;\n@@ -63,10 +58,4 @@\n-inline void PerRegionTable::init(HeapRegion* hr, bool clear_links_to_all_list) {\n-  if (clear_links_to_all_list) {\n-    set_next(NULL);\n-  }\n-  _collision_list_next = NULL;\n-  _occupied = 0;\n-  _bm.clear();\n-  \/\/ Make sure that the bitmap clearing above has been finished before publishing\n-  \/\/ this PRT to concurrent threads.\n-  Atomic::release_store(&_hr, hr);\n+\n+template <class CardOrRangeVisitor>\n+inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  _card_set.iterate_for_merge(cl);\n@@ -75,15 +64,10 @@\n-template <class Closure>\n-void OtherRegionsTable::iterate(Closure& cl) {\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    BitMap::idx_t cur = _coarse_map.get_next_one_offset(0);\n-    while (cur != _coarse_map.size()) {\n-      cl.next_coarse_prt((uint)cur);\n-      cur = _coarse_map.get_next_one_offset(cur + 1);\n-    }\n-  }\n-  {\n-    PerRegionTable* cur = _first_all_fine_prts;\n-    while (cur != NULL) {\n-      cl.next_fine_prt(cur->hr()->hrm_index(), cur->bm());\n-      cur = cur->next();\n-    }\n+void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n+  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n+  card_region = hr->hrm_index();\n+  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+}\n+\n+void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+  RemSetState state = _state;\n+  if (state == Untracked) {\n+    return;\n@@ -91,6 +75,9 @@\n-  {\n-    SparsePRTBucketIter iter(&_sparse_table);\n-    SparsePRTEntry* cur;\n-    while (iter.has_next(cur)) {\n-      cl.next_sparse_prt(cur->r_ind(), cur->cards(), cur->num_valid_cards());\n-    }\n+\n+  uint cur_idx = _hr->hrm_index();\n+  uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n+\n+  if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n+    \/\/ We can't check whether the card is in the remembered set - the card container\n+    \/\/ may be coarsened just now.\n+    \/\/assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n+   return;\n@@ -98,0 +85,25 @@\n+\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.add_card(card_region, card_within_region);\n+}\n+\n+bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  return _card_set.contains_card(card_region, card_within_region);\n+}\n+\n+void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.print_info(st, card_region, card_within_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetArrayOfCardsEntriesConstraintFunc(uint value, bool verbose) {\n@@ -34,1 +34,1 @@\n-  \/\/ Default value of G1RSetRegionEntries=0 means will be set ergonomically.\n+  \/\/ Default value of G1RemSetArrayOfCardsEntries=0 means will be set ergonomically.\n@@ -36,1 +36,1 @@\n-  if (FLAG_IS_CMDLINE(G1RSetRegionEntries) && (value < 1)) {\n+  if (FLAG_IS_CMDLINE(G1RemSetArrayOfCardsEntries) && (value < 1)) {\n@@ -38,2 +38,2 @@\n-                        \"G1RSetRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetArrayOfCardsEntries (%u) must be \"\n+                        \"greater than or equal to 1.\\n\",\n@@ -47,1 +47,1 @@\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetHowlNumBucketsConstraintFunc(uint value, bool verbose) {\n@@ -50,3 +50,4 @@\n-  \/\/ Default value of G1RSetSparseRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetSparseRegionEntries) && (value < 1)) {\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlNumBuckets)) {\n+    return JVMFlag::SUCCESS;\n+  }\n+  if (value == 0 || !is_power_of_2(G1RemSetHowlNumBuckets)) {\n@@ -54,2 +55,2 @@\n-                        \"G1RSetSparseRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetHowlNumBuckets (%u) must be a power of two \"\n+                        \"and greater than or equal to 1.\\n\",\n@@ -58,1 +59,8 @@\n-  } else {\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1RemSetHowlMaxNumBucketsConstraintFunc(uint value, bool verbose) {\n+  if (!UseG1GC) return JVMFlag::SUCCESS;\n+\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlMaxNumBuckets)) {\n@@ -61,0 +69,7 @@\n+  if (!is_power_of_2(G1RemSetHowlMaxNumBuckets)) {\n+    JVMFlag::printError(verbose,\n+                        \"G1RemSetMaxHowlNumBuckets (%u) must be a power of two.\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,3 +33,6 @@\n-  \/* G1 Flag Constraints *\/                           \\\n-  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n-  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n+  \/* G1 Remembered Sets Constraints *\/                \\\n+  f(uint,   G1RemSetArrayOfCardsEntriesConstraintFunc)\\\n+  f(uint,   G1RemSetHowlMaxNumBucketsConstraintFunc)  \\\n+  f(uint,   G1RemSetHowlNumBucketsConstraintFunc)     \\\n+                                                      \\\n+  \/* G1 Heap Size Constraints *\/                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-\n-\/\/ Check that the size of the SparsePRTEntry is evenly divisible by the maximum\n-\/\/ member type to avoid SIGBUS when accessing them.\n-STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);\n-\n-void SparsePRTEntry::init(RegionIdx_t region_ind) {\n-  \/\/ Check that the card array element type can represent all cards in the region.\n-  \/\/ Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.\n-  assert(((size_t)1 << (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *\n-         G1CardTable::card_size >= HeapRegionBounds::max_size(), \"precondition\");\n-  assert(G1RSetSparseRegionEntries > 0, \"precondition\");\n-  _region_ind = region_ind;\n-  _next_index = RSHashTable::NullEntry;\n-  _next_null = 0;\n-}\n-\n-bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return SparsePRT::found;\n-    }\n-  }\n-  if (num_valid_cards() < cards_num() - 1) {\n-    _cards[_next_null] = (card_elem_t)card_index;\n-    _next_null++;\n-    return SparsePRT::added;\n-   }\n-  \/\/ Otherwise, we're full.\n-  return SparsePRT::overflow;\n-}\n-\n-void SparsePRTEntry::copy_cards(card_elem_t* cards) const {\n-  memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));\n-}\n-\n-void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {\n-  copy_cards(e->_cards);\n-  assert(_next_null >= 0, \"invariant\");\n-  assert(_next_null <= cards_num(), \"invariant\");\n-  e->_next_null = _next_null;\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-float RSHashTable::TableOccupancyFactor = 0.5f;\n-\n-\/\/ The empty table can't hold any entries and is effectively immutable\n-\/\/ This means it can be used as an initial sentinel value\n-static int empty_buckets[] = { RSHashTable::NullEntry };\n-RSHashTable RSHashTable::empty_table;\n-\n-RSHashTable::RSHashTable() :\n-  _num_entries(0),\n-  _capacity(0),\n-  _capacity_mask(0),\n-  _occupied_entries(0),\n-  _entries(NULL),\n-  _buckets(empty_buckets),\n-  _free_region(0),\n-  _free_list(NullEntry) { }\n-\n-RSHashTable::RSHashTable(size_t capacity) :\n-  _num_entries((capacity * TableOccupancyFactor) + 1),\n-  _capacity(capacity),\n-  _capacity_mask(capacity - 1),\n-  _occupied_entries(0),\n-  _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),\n-  _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),\n-  _free_region(0),\n-  _free_list(NullEntry)\n-{\n-  clear();\n-}\n-\n-RSHashTable::~RSHashTable() {\n-  \/\/ Nothing to free for empty RSHashTable\n-  if (_buckets != empty_buckets) {\n-    assert(_entries != NULL, \"invariant\");\n-    FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);\n-    FREE_C_HEAP_ARRAY(int, _buckets);\n-  }\n-}\n-\n-void RSHashTable::clear() {\n-  assert(_buckets != empty_buckets, \"Shouldn't call this for the empty_table\");\n-  _occupied_entries = 0;\n-  guarantee(_entries != NULL, \"invariant\");\n-  guarantee(_buckets != NULL, \"invariant\");\n-\n-  guarantee(_capacity <= ((size_t)1 << (sizeof(int)*BitsPerByte-1)) - 1,\n-                \"_capacity too large\");\n-\n-  \/\/ This will put -1 == NullEntry in the key field of all entries.\n-  memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());\n-  memset((void*)_buckets, NullEntry, _capacity * sizeof(int));\n-  _free_list = NullEntry;\n-  _free_region = 0;\n-}\n-\n-SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {\n-  assert(this != &empty_table, \"can't add a card to the empty table\");\n-  SparsePRTEntry* e = entry_for_region_ind_create(region_ind);\n-  assert(e != NULL && e->r_ind() == region_ind,\n-         \"Postcondition of call above.\");\n-  SparsePRT::AddCardResult res = e->add_card(card_index);\n-  assert(e->num_valid_cards() > 0, \"Postcondition\");\n-  return res;\n-}\n-\n-SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int cur_ind = _buckets[ind];\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    cur_ind = cur->next_index();\n-  }\n-\n-  if (cur_ind == NullEntry) return NULL;\n-  \/\/ Otherwise...\n-  assert(cur->r_ind() == region_ind, \"Postcondition of loop + test above.\");\n-  assert(cur->num_valid_cards() > 0, \"Inv\");\n-  return cur;\n-}\n-\n-bool RSHashTable::delete_entry(RegionIdx_t region_ind) {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int* prev_loc = &_buckets[ind];\n-  int cur_ind = *prev_loc;\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    prev_loc = cur->next_index_addr();\n-    cur_ind = *prev_loc;\n-  }\n-\n-  if (cur_ind == NullEntry) return false;\n-  \/\/ Otherwise, splice out \"cur\".\n-  *prev_loc = cur->next_index();\n-  free_entry(cur_ind);\n-  _occupied_entries--;\n-  return true;\n-}\n-\n-SparsePRTEntry*\n-RSHashTable::entry_for_region_ind_create(RegionIdx_t region_ind) {\n-  SparsePRTEntry* res = get_entry(region_ind);\n-  if (res == NULL) {\n-    int new_ind = alloc_entry();\n-    res = entry(new_ind);\n-    res->init(region_ind);\n-    \/\/ Insert at front.\n-    int ind = (int) (region_ind & capacity_mask());\n-    res->set_next_index(_buckets[ind]);\n-    _buckets[ind] = new_ind;\n-    _occupied_entries++;\n-  }\n-  return res;\n-}\n-\n-int RSHashTable::alloc_entry() {\n-  int res;\n-  if (_free_list != NullEntry) {\n-    res = _free_list;\n-    _free_list = entry(res)->next_index();\n-    return res;\n-  } else if ((size_t)_free_region < _num_entries) {\n-    res = _free_region;\n-    _free_region++;\n-    return res;\n-  } else {\n-    return NullEntry;\n-  }\n-}\n-\n-void RSHashTable::free_entry(int fi) {\n-  entry(fi)->set_next_index(_free_list);\n-  _free_list = fi;\n-}\n-\n-void RSHashTable::add_entry(SparsePRTEntry* e) {\n-  assert(e->num_valid_cards() > 0, \"Precondition.\");\n-  SparsePRTEntry* e2 = entry_for_region_ind_create(e->r_ind());\n-  e->copy_cards(e2);\n-  assert(e2->num_valid_cards() > 0, \"Postcondition.\");\n-}\n-\n-bool RSHashTableBucketIter::has_next(SparsePRTEntry*& entry) {\n-  while (_bl_ind == RSHashTable::NullEntry)  {\n-    if (_tbl_ind + 1 >= _rsht->capacity()) {\n-      return false;\n-    }\n-    _tbl_ind++;\n-    _bl_ind = _rsht->_buckets[_tbl_ind];\n-  }\n-  entry = _rsht->entry(_bl_ind);\n-  _bl_ind = entry->next_index();\n-  return true;\n-}\n-\n-bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {\n-  SparsePRTEntry* e = get_entry(region_index);\n-  return (e != NULL && e->contains_card(card_index));\n-}\n-\n-size_t RSHashTable::mem_size() const {\n-  return sizeof(RSHashTable) +\n-    _num_entries * (SparsePRTEntry::size() + sizeof(int));\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-SparsePRT::SparsePRT() :\n-  _table(&RSHashTable::empty_table) {\n-}\n-\n-\n-SparsePRT::~SparsePRT() {\n-  if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-  }\n-}\n-\n-\n-size_t SparsePRT::mem_size() const {\n-  \/\/ We ignore \"_cur\" here, because it either = _next, or else it is\n-  \/\/ on the deleted list.\n-  return sizeof(SparsePRT) + _table->mem_size();\n-}\n-\n-SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {\n-  if (_table->should_expand()) {\n-    expand();\n-  }\n-  return _table->add_card(region_id, card_index);\n-}\n-\n-SparsePRTEntry* SparsePRT::get_entry(RegionIdx_t region_id) {\n-  return _table->get_entry(region_id);\n-}\n-\n-bool SparsePRT::delete_entry(RegionIdx_t region_id) {\n-  return _table->delete_entry(region_id);\n-}\n-\n-void SparsePRT::clear() {\n-  \/\/ If the entry table not at initial capacity, just reset to the empty table.\n-  if (_table->capacity() == InitialCapacity) {\n-    _table->clear();\n-  } else if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-    _table = &RSHashTable::empty_table;\n-  }\n-}\n-\n-void SparsePRT::expand() {\n-  RSHashTable* last = _table;\n-  if (last != &RSHashTable::empty_table) {\n-    _table = new RSHashTable(last->capacity() * 2);\n-    for (size_t i = 0; i < last->num_entries(); i++) {\n-      SparsePRTEntry* e = last->entry((int)i);\n-      if (e->valid_entry()) {\n-        _table->add_entry(e);\n-      }\n-    }\n-    delete last;\n-  } else {\n-    _table = new RSHashTable(InitialCapacity);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.cpp","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_HPP\n-#define SHARE_GC_G1_SPARSEPRT_HPP\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class RSHashTable;\n-class SparsePRTEntry;\n-\n-\/\/ Sparse remembered set for a heap region (the \"owning\" region).  Maps\n-\/\/ indices of other regions to short sequences of cards in the other region\n-\/\/ that might contain pointers into the owner region.\n-\/\/ Concurrent access to a SparsePRT must be serialized by some external mutex.\n-class SparsePRT {\n-  friend class SparsePRTBucketIter;\n-\n-  RSHashTable* _table;\n-\n-  static const size_t InitialCapacity = 8;\n-\n-  void expand();\n-\n-public:\n-  SparsePRT();\n-  ~SparsePRT();\n-\n-  size_t mem_size() const;\n-\n-  enum AddCardResult {\n-    overflow, \/\/ The table is full, could not add the card to the table.\n-    found,    \/\/ The card is already in the PRT.\n-    added     \/\/ The card has been added.\n-  };\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  \/\/ Return the pointer to the entry associated with the given region.\n-  SparsePRTEntry* get_entry(RegionIdx_t region_ind);\n-\n-  \/\/ If there is an entry for \"region_ind\", removes it and return \"true\";\n-  \/\/ otherwise returns \"false.\"\n-  bool delete_entry(RegionIdx_t region_ind);\n-\n-  \/\/ Clear the table, and reinitialize to initial capacity.\n-  void clear();\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-};\n-\n-class SparsePRTEntry: public CHeapObj<mtGC> {\n-public:\n-  \/\/ The type of a card entry.\n-  typedef uint16_t card_elem_t;\n-\n-private:\n-  \/\/ We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,\n-  \/\/ in order to force correct alignment that could otherwise cause SIGBUS errors\n-  \/\/ when reading the member variables. This calculates the minimum number of card\n-  \/\/ array elements required to get that alignment.\n-  static const size_t card_array_alignment = sizeof(int) \/ sizeof(card_elem_t);\n-\n-  RegionIdx_t _region_ind;\n-  int         _next_index;\n-  int         _next_null;\n-  \/\/ The actual cards stored in this array.\n-  \/\/ WARNING: Don't put any data members beyond this line. Card array has, in fact, variable length.\n-  \/\/ It should always be the last data member.\n-  card_elem_t _cards[card_array_alignment];\n-\n-  \/\/ Copy the current entry's cards into \"cards\".\n-  inline void copy_cards(card_elem_t* cards) const;\n-public:\n-  \/\/ Returns the size of the entry, used for entry allocation.\n-  static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }\n-  \/\/ Returns the size of the card array.\n-  static int cards_num() {\n-    return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);\n-  }\n-\n-  \/\/ Set the region_ind to the given value, and delete all cards.\n-  inline void init(RegionIdx_t region_ind);\n-\n-  RegionIdx_t r_ind() const { return _region_ind; }\n-  bool valid_entry() const { return r_ind() >= 0; }\n-\n-  int next_index() const { return _next_index; }\n-  int* next_index_addr() { return &_next_index; }\n-  void set_next_index(int ni) { _next_index = ni; }\n-\n-  \/\/ Returns \"true\" iff the entry contains the given card index.\n-  inline bool contains_card(CardIdx_t card_index) const;\n-\n-  \/\/ Returns the number of non-NULL card entries.\n-  inline int num_valid_cards() const { return _next_null; }\n-\n-  inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);\n-\n-  \/\/ Copy the current entry's cards into the \"_card\" array of \"e.\"\n-  inline void copy_cards(SparsePRTEntry* e) const;\n-\n-  card_elem_t* cards() { return _cards; }\n-\n-  inline CardIdx_t card(int i) const {\n-    assert(i >= 0, \"must be nonnegative\");\n-    assert(i < cards_num(), \"range checking\");\n-    return (CardIdx_t)_cards[i];\n-  }\n-};\n-\n-class RSHashTable : public CHeapObj<mtGC> {\n-\n-  friend class RSHashTableBucketIter;\n-\n-  \/\/ Inverse maximum hash table occupancy used.\n-  static float TableOccupancyFactor;\n-\n-  size_t _num_entries;\n-\n-  size_t _capacity;\n-  size_t _capacity_mask;\n-  size_t _occupied_entries;\n-\n-  SparsePRTEntry* _entries;\n-  int* _buckets;\n-  int  _free_region;\n-  int  _free_list;\n-\n-  \/\/ Requires that the caller hold a lock preventing parallel modifying\n-  \/\/ operations, and that the the table be less than completely full.  If\n-  \/\/ an entry for \"region_ind\" is already in the table, finds it and\n-  \/\/ returns its address; otherwise allocates, initializes, inserts and\n-  \/\/ returns a new entry for \"region_ind\".\n-  SparsePRTEntry* entry_for_region_ind_create(RegionIdx_t region_ind);\n-\n-  \/\/ Returns the index of the next free entry in \"_entries\".\n-  int alloc_entry();\n-  \/\/ Declares the entry \"fi\" to be free.  (It must have already been\n-  \/\/ deleted from any bucket lists.\n-  void free_entry(int fi);\n-\n-  \/\/ For the empty sentinel created at static initialization time\n-  RSHashTable();\n-\n-public:\n-  RSHashTable(size_t capacity);\n-  ~RSHashTable();\n-\n-  static const int NullEntry = -1;\n-  static RSHashTable empty_table;\n-\n-  bool should_expand() const { return _occupied_entries == _num_entries; }\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  bool delete_entry(RegionIdx_t region_id);\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-\n-  void add_entry(SparsePRTEntry* e);\n-\n-  SparsePRTEntry* get_entry(RegionIdx_t region_id) const;\n-\n-  void clear();\n-\n-  size_t capacity() const      { return _capacity; }\n-  size_t capacity_mask() const { return _capacity_mask;  }\n-  size_t mem_size() const;\n-  \/\/ The number of SparsePRTEntry instances available.\n-  size_t num_entries() const { return _num_entries; }\n-\n-  SparsePRTEntry* entry(int i) const {\n-    assert(i >= 0 && (size_t)i < _num_entries, \"precondition\");\n-    return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);\n-  }\n-\n-  void print();\n-};\n-\n-\/\/ This is embedded in HRRS iterator.\n-class RSHashTableBucketIter {\n-  uint _tbl_ind;        \/\/ [0.._rsht->_capacity)\n-  int  _bl_ind;         \/\/ [-1, 0.._rsht->_capacity)\n-\n-  RSHashTable* _rsht;\n-\n-public:\n-  RSHashTableBucketIter(RSHashTable* rsht) :\n-    _tbl_ind(0),\n-    _bl_ind(rsht->_buckets[_tbl_ind]),\n-    _rsht(rsht) { }\n-\n-  bool has_next(SparsePRTEntry*& entry);\n-};\n-\n-class SparsePRTBucketIter: public RSHashTableBucketIter {\n-public:\n-  SparsePRTBucketIter(const SparsePRT* sprt) :\n-    RSHashTableBucketIter(sprt->_table) {}\n-\n-  bool has_next(SparsePRTEntry*& entry) {\n-    return RSHashTableBucketIter::has_next(entry);\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.hpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-#define SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n-\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-\n-inline bool SparsePRT::contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {\n-  return _table->contains_card(region_id, card_index);\n-}\n-\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n-  nonstatic_field(G1CollectedHeap, _g1mm,               G1MonitoringSupport*) \\\n+  nonstatic_field(G1CollectedHeap, _monitoring_support, G1MonitoringSupport*) \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1789,4 +1789,1 @@\n-    ref_processor()->enable_discovery();\n-    ref_processor()->setup_policy(maximum_heap_compaction);\n-\n-    bool marked_for_unloading = false;\n+    ref_processor()->start_discovery(maximum_heap_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -452,2 +451,1 @@\n-    reference_processor()->enable_discovery();\n-    reference_processor()->setup_policy(false);\n+    reference_processor()->start_discovery(false \/* always_clear *\/);\n@@ -489,1 +487,0 @@\n-      reference_processor()->setup_policy(false); \/\/ not always_clear\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -316,0 +316,9 @@\n+size_t DefNewGeneration::calculate_thread_increase_size(int threads_count) const {\n+    size_t thread_increase_size = 0;\n+    \/\/ Check an overflow at 'threads_count * NewSizeThreadIncrease'.\n+    if (threads_count > 0 && NewSizeThreadIncrease <= max_uintx \/ threads_count) {\n+      thread_increase_size = threads_count * NewSizeThreadIncrease;\n+    }\n+    return thread_increase_size;\n+}\n+\n@@ -318,1 +327,2 @@\n-                                                    size_t alignment) const {\n+                                                    size_t alignment,\n+                                                    size_t thread_increase_size) const {\n@@ -321,8 +331,1 @@\n-  if (NewSizeThreadIncrease > 0) {\n-    int threads_count;\n-    size_t thread_increase_size = 0;\n-\n-    \/\/ 1. Check an overflow at 'threads_count * NewSizeThreadIncrease'.\n-    threads_count = Threads::number_of_non_daemon_threads();\n-    if (threads_count > 0 && NewSizeThreadIncrease <= max_uintx \/ threads_count) {\n-      thread_increase_size = threads_count * NewSizeThreadIncrease;\n+  if (NewSizeThreadIncrease > 0 && thread_increase_size > 0) {\n@@ -330,3 +333,3 @@\n-      \/\/ 2. Check an overflow at 'new_size_candidate + thread_increase_size'.\n-      if (new_size_candidate <= max_uintx - thread_increase_size) {\n-        new_size_candidate += thread_increase_size;\n+    \/\/ 1. Check an overflow at 'new_size_candidate + thread_increase_size'.\n+    if (new_size_candidate <= max_uintx - thread_increase_size) {\n+      new_size_candidate += thread_increase_size;\n@@ -334,5 +337,4 @@\n-        \/\/ 3. Check an overflow at 'align_up'.\n-        size_t aligned_max = ((max_uintx - alignment) & ~(alignment-1));\n-        if (new_size_candidate <= aligned_max) {\n-          desired_new_size = align_up(new_size_candidate, alignment);\n-        }\n+      \/\/ 2. Check an overflow at 'align_up'.\n+      size_t aligned_max = ((max_uintx - alignment) & ~(alignment-1));\n+      if (new_size_candidate <= aligned_max) {\n+        desired_new_size = align_up(new_size_candidate, alignment);\n@@ -367,2 +369,2 @@\n-  int threads_count = 0;\n-  size_t thread_increase_size = 0;\n+  int threads_count = Threads::number_of_non_daemon_threads();\n+  size_t thread_increase_size = calculate_thread_increase_size(threads_count);\n@@ -373,1 +375,2 @@\n-  size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before, alignment);\n+  size_t desired_new_size = adjust_for_thread_increase(new_size_candidate, new_size_before,\n+                                                       alignment, thread_increase_size);\n@@ -498,3 +501,1 @@\n-HeapWord* DefNewGeneration::expand_and_allocate(size_t size,\n-                                                bool   is_tlab,\n-                                                bool   parallel) {\n+HeapWord* DefNewGeneration::expand_and_allocate(size_t size, bool is_tlab) {\n@@ -589,1 +590,0 @@\n-  rp->setup_policy(clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -311,3 +311,2 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n@@ -345,1 +344,4 @@\n-                                    size_t alignment) const;\n+                                    size_t alignment,\n+                                    size_t thread_increase_size) const;\n+\n+  size_t calculate_thread_increase_size(int threads_count) const;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  rp->setup_policy(clear_all_softrefs);\n@@ -201,1 +200,0 @@\n-    ref_processor()->setup_policy(clear_all_softrefs);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-  friend class VM_MarkSweep;\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -86,3 +86,1 @@\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark().has_bias_pattern()),\n-           \/\/ not gc marked?\n+           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,2 @@\n-  _shrink_factor = 0;\n+  \/\/ If we don't shrink the heap in steps, '_shrink_factor' is always 100%.\n+  _shrink_factor = ShrinkHeapInSteps ? 0 : 100;\n@@ -191,3 +192,1 @@\n-TenuredGeneration::expand_and_allocate(size_t word_size,\n-                                       bool is_tlab,\n-                                       bool parallel) {\n+TenuredGeneration::expand_and_allocate(size_t word_size, bool is_tlab) {\n@@ -195,24 +194,2 @@\n-  if (parallel) {\n-    MutexLocker x(ParGCRareEvent_lock);\n-    HeapWord* result = NULL;\n-    size_t byte_size = word_size * HeapWordSize;\n-    while (true) {\n-      expand(byte_size, _min_heap_delta_bytes);\n-      if (GCExpandToAllocateDelayMillis > 0) {\n-        os::naked_sleep(GCExpandToAllocateDelayMillis);\n-      }\n-      result = _the_space->par_allocate(word_size);\n-      if ( result != NULL) {\n-        return result;\n-      } else {\n-        \/\/ If there's not enough expansion space available, give up.\n-        if (_virtual_space.uncommitted_size() < byte_size) {\n-          return NULL;\n-        }\n-        \/\/ else try again\n-      }\n-    }\n-  } else {\n-    expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n-    return _the_space->allocate(word_size);\n-  }\n+  expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n+  return _the_space->allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,3 +96,1 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  _shrink_factor(0), _min_heap_delta_bytes(), _capacity_at_prologue(),\n+  _min_heap_delta_bytes(), _capacity_at_prologue(),\n@@ -47,0 +47,2 @@\n+  \/\/ If we don't shrink the heap in steps, '_shrink_factor' is always 100%.\n+  _shrink_factor = ShrinkHeapInSteps ? 0 : 100;\n@@ -189,1 +191,6 @@\n-  _shrink_factor = 0;\n+  if (ShrinkHeapInSteps) {\n+    \/\/ Always reset '_shrink_factor' if the heap is shrunk in steps.\n+    \/\/ If we shrink the heap in this iteration, '_shrink_factor' will\n+    \/\/ be recomputed based on the old value further down in this fuction.\n+    _shrink_factor = 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  static CardValue clean_card_val()          { return clean_card; }\n-  static CardValue dirty_card_val()          { return dirty_card; }\n+  static constexpr CardValue clean_card_val()          { return clean_card; }\n+  static constexpr CardValue dirty_card_val()          { return dirty_card; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    flush_deferred_card_mark_barrier(thread->as_Java_thread());\n+    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const { return \"ConcurrentGCThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,1 +151,0 @@\n-          constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -442,2 +441,1 @@\n-                                          bool is_tlab, bool run_verification, bool clear_soft_refs,\n-                                          bool restore_marks_for_biased_locking) {\n+                                          bool is_tlab, bool run_verification, bool clear_soft_refs) {\n@@ -464,8 +462,0 @@\n-  if (restore_marks_for_biased_locking) {\n-    \/\/ We perform this mark word preservation work lazily\n-    \/\/ because it's only at this point that we know whether we\n-    \/\/ absolutely have to do it; we want to avoid doing it for\n-    \/\/ scavenge-only collections where it's unnecessary\n-    BiasedLocking::preserve_marks();\n-  }\n-\n@@ -491,9 +481,2 @@\n-    \/\/ If the discovery of (\"weak\") refs in this generation is\n-    \/\/ atomic wrt other collectors in this configuration, we\n-    \/\/ are guaranteed to have empty discovered ref lists.\n-    if (rp->discovery_is_atomic()) {\n-      rp->enable_discovery();\n-      rp->setup_policy(clear_soft_refs);\n-    } else {\n-      \/\/ collect() below will enable discovery as appropriate\n-    }\n+    rp->start_discovery(clear_soft_refs);\n+\n@@ -501,5 +484,2 @@\n-    if (!rp->enqueuing_is_done()) {\n-      rp->disable_discovery();\n-    } else {\n-      rp->set_enqueuing_is_done(false);\n-    }\n+\n+    rp->disable_discovery();\n@@ -575,2 +555,1 @@\n-                       do_clear_all_soft_refs,\n-                       false);\n+                       do_clear_all_soft_refs);\n@@ -635,2 +614,1 @@\n-                       do_clear_all_soft_refs,\n-                       true);\n+                       do_clear_all_soft_refs);\n@@ -658,2 +636,0 @@\n-    BiasedLocking::restore_marks();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":7,"deletions":31,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,1 @@\n-                          bool run_verification, bool clear_soft_refs,\n-                          bool restore_marks_for_biased_locking);\n+                          bool run_verification, bool clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,3 +336,1 @@\n-  virtual HeapWord* expand_and_allocate(size_t word_size,\n-                                        bool is_tlab,\n-                                        bool parallel = false) = 0;\n+  virtual HeapWord* expand_and_allocate(size_t word_size, bool is_tlab) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,15 +70,0 @@\n-\/\/ As ConcGCThreads should be smaller than ParallelGCThreads,\n-\/\/ we need constraint function.\n-JVMFlag::Error ConcGCThreadsConstraintFunc(uint value, bool verbose) {\n-  \/\/ G1 GC use ConcGCThreads.\n-  if (GCConfig::is_gc_selected(CollectedHeap::G1) && (value > ParallelGCThreads)) {\n-    JVMFlag::printError(verbose,\n-                        \"ConcGCThreads (\" UINT32_FORMAT \") must be \"\n-                        \"less than or equal to ParallelGCThreads (\" UINT32_FORMAT \")\\n\",\n-                        value, ParallelGCThreads);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  }\n-\n-  return JVMFlag::SUCCESS;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n- f(uint,   ConcGCThreadsConstraintFunc)                        \\\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  _thread->as_Java_thread()->check_for_valid_safepoint_state();\n+  JavaThread::cast(_thread)->check_for_valid_safepoint_state();\n@@ -385,6 +385,2 @@\n-  if (UseBiasedLocking) {\n-    oopDesc::set_mark(mem, _klass->prototype_header());\n-  } else {\n-    \/\/ May be bootstrapping\n-    oopDesc::set_mark(mem, markWord::prototype());\n-  }\n+  \/\/ May be bootstrapping\n+  oopDesc::set_mark(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,8 +84,0 @@\n-  \/\/ Someone could have modified the value of the static\n-  \/\/ field in the j.l.r.SoftReference class that holds the\n-  \/\/ soft reference timestamp clock using reflection or\n-  \/\/ Unsafe between GCs. Unconditionally update the static\n-  \/\/ field in ReferenceProcessor here so that we use the new\n-  \/\/ value during reference discovery.\n-\n-  _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();\n@@ -103,1 +95,0 @@\n-  _enqueuing_is_done(false),\n@@ -160,2 +151,0 @@\n-  jlong soft_ref_clock = java_lang_ref_SoftReference::clock();\n-  assert(soft_ref_clock == _soft_ref_timestamp_clock, \"soft ref clocks out of sync\");\n@@ -202,1 +191,0 @@\n-  assert(!enqueuing_is_done(), \"If here enqueuing should not be complete\");\n@@ -206,10 +194,0 @@\n-  \/\/ If discovery was concurrent, someone could have modified\n-  \/\/ the value of the static field in the j.l.r.SoftReference\n-  \/\/ class that holds the soft reference timestamp clock using\n-  \/\/ reflection or Unsafe between when discovery was enabled and\n-  \/\/ now. Unconditionally update the static field in ReferenceProcessor\n-  \/\/ here so that we use the new value during processing of the\n-  \/\/ discovered soft refs.\n-\n-  _soft_ref_timestamp_clock = java_lang_ref_SoftReference::clock();\n-\n@@ -221,5 +199,0 @@\n-  {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase1, &phase_times);\n-    process_soft_ref_reconsider(proxy_task, phase_times);\n-  }\n-\n@@ -229,1 +202,1 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase2, &phase_times);\n+    RefProcTotalPhaseTimesTracker tt(SoftWeakFinalRefsPhase, &phase_times);\n@@ -234,1 +207,1 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase3, &phase_times);\n+    RefProcTotalPhaseTimesTracker tt(KeepAliveFinalRefsPhase, &phase_times);\n@@ -239,1 +212,1 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase4, &phase_times);\n+    RefProcTotalPhaseTimesTracker tt(PhantomRefsPhase, &phase_times);\n@@ -334,31 +307,0 @@\n-size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&    refs_list,\n-                                                            ReferencePolicy*   policy,\n-                                                            BoolObjectClosure* is_alive,\n-                                                            OopClosure*        keep_alive,\n-                                                            VoidClosure*       complete_gc) {\n-  assert(policy != NULL, \"Must have a non-NULL policy\");\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n-  \/\/ Decide which softly reachable refs should be kept alive.\n-  while (iter.has_next()) {\n-    iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() \/* allow_null_referent *\/));\n-    bool referent_is_dead = (iter.referent() != NULL) && !iter.is_referent_alive();\n-    if (referent_is_dead &&\n-        !policy->should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) {\n-      log_dropped_ref(iter, \"by policy\");\n-      \/\/ Remove Reference object from list\n-      iter.remove();\n-      \/\/ keep the referent around\n-      iter.make_referent_alive();\n-      iter.move_to_next();\n-    } else {\n-      iter.next();\n-    }\n-  }\n-  \/\/ Close the reachable set\n-  complete_gc->do_void();\n-\n-  log_develop_trace(gc, ref)(\" Dropped \" SIZE_FORMAT \" dead Refs out of \" SIZE_FORMAT \" discovered Refs by policy, from list \" INTPTR_FORMAT,\n-                             iter.removed(), iter.processed(), p2i(&refs_list));\n-  return iter.removed();\n-}\n-\n@@ -513,30 +455,2 @@\n-\n-class RefProcPhase1Task : public RefProcTask {\n-public:\n-  RefProcPhase1Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times,\n-                    ReferencePolicy* policy)\n-    : RefProcTask(ref_processor,\n-                  phase_times),\n-      _policy(policy) { }\n-\n-  void rp_work(uint worker_id,\n-               BoolObjectClosure* is_alive,\n-               OopClosure* keep_alive,\n-               VoidClosure* complete_gc) override {\n-    ResourceMark rm;\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, worker_id);\n-    size_t const removed = _ref_processor.process_soft_ref_reconsider_work(_ref_processor._discoveredSoftRefs[worker_id],\n-                                                                           _policy,\n-                                                                           is_alive,\n-                                                                           keep_alive,\n-                                                                           complete_gc);\n-    _phase_times->add_ref_cleared(REF_SOFT, removed);\n-  }\n-\n-private:\n-  ReferencePolicy* _policy;\n-};\n-\n-class RefProcPhase2Task: public RefProcTask {\n-  void run_phase2(uint worker_id,\n+class RefProcSoftWeakFinalPhaseTask: public RefProcTask {\n+  void run_phase(uint worker_id,\n@@ -556,2 +470,2 @@\n-  RefProcPhase2Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n+  RefProcSoftWeakFinalPhaseTask(ReferenceProcessor& ref_processor,\n+                                ReferenceProcessorPhaseTimes* phase_times)\n@@ -566,1 +480,1 @@\n-    RefProcWorkerTimeTracker t(_phase_times->phase2_worker_time_sec(), worker_id);\n+    RefProcWorkerTimeTracker t(_phase_times->soft_weak_final_refs_phase_worker_time_sec(), tracker_id(worker_id));\n@@ -568,2 +482,2 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_SOFT);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessSoftRefSubPhase, _phase_times, tracker_id(worker_id));\n+      run_phase(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_SOFT);\n@@ -572,2 +486,2 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::WeakRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_WEAK);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessWeakRefSubPhase, _phase_times, tracker_id(worker_id));\n+      run_phase(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_WEAK);\n@@ -576,2 +490,2 @@\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false \/* do_enqueue_and_clear *\/, REF_FINAL);\n+      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessFinalRefSubPhase, _phase_times, tracker_id(worker_id));\n+      run_phase(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false \/* do_enqueue_and_clear *\/, REF_FINAL);\n@@ -585,1 +499,1 @@\n-class RefProcPhase3Task: public RefProcTask {\n+class RefProcKeepAliveFinalPhaseTask: public RefProcTask {\n@@ -587,2 +501,2 @@\n-  RefProcPhase3Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n+  RefProcKeepAliveFinalPhaseTask(ReferenceProcessor& ref_processor,\n+                                 ReferenceProcessorPhaseTimes* phase_times)\n@@ -597,1 +511,1 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase3, _phase_times, worker_id);\n+    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::KeepAliveFinalRefsSubPhase, _phase_times, tracker_id(worker_id));\n@@ -602,1 +516,1 @@\n-class RefProcPhase4Task: public RefProcTask {\n+class RefProcPhantomPhaseTask: public RefProcTask {\n@@ -604,2 +518,2 @@\n-  RefProcPhase4Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n+  RefProcPhantomPhaseTask(ReferenceProcessor& ref_processor,\n+                          ReferenceProcessorPhaseTimes* phase_times)\n@@ -614,1 +528,1 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::PhantomRefSubPhase4, _phase_times, worker_id);\n+    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessPhantomRefsSubPhase, _phase_times, tracker_id(worker_id));\n@@ -658,0 +572,1 @@\n+  assert(v <= max_num_queues(), \"Mt degree %u too high, maximum %u\", v,  max_num_queues());\n@@ -796,32 +711,0 @@\n-void ReferenceProcessor::process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n-                                                     ReferenceProcessorPhaseTimes& phase_times) {\n-\n-  size_t const num_soft_refs = total_count(_discoveredSoftRefs);\n-  phase_times.set_ref_discovered(REF_SOFT, num_soft_refs);\n-  phase_times.set_processing_is_mt(processing_is_mt());\n-\n-  if (num_soft_refs == 0) {\n-    log_debug(gc, ref)(\"Skipped phase 1 of Reference Processing: no references\");\n-    return;\n-  }\n-\n-  if (_current_soft_ref_policy == NULL) {\n-    log_debug(gc, ref)(\"Skipped phase 1 of Reference Processing: no policy\");\n-    return;\n-  }\n-\n-  RefProcMTDegreeAdjuster a(this, RefPhase1, num_soft_refs);\n-\n-  if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase1, &phase_times);\n-    maybe_balance_queues(_discoveredSoftRefs);\n-  }\n-\n-  RefProcPhaseTimeTracker tt(RefPhase1, &phase_times);\n-\n-  log_reflist(\"Phase 1 Soft before\", _discoveredSoftRefs, _max_num_queues);\n-  RefProcPhase1Task phase1(*this, &phase_times, _current_soft_ref_policy);\n-  run_task(phase1, proxy_task, true);\n-  log_reflist(\"Phase 1 Soft after\", _discoveredSoftRefs, _max_num_queues);\n-}\n-\n@@ -841,1 +724,1 @@\n-    log_debug(gc, ref)(\"Skipped phase 2 of Reference Processing: no references\");\n+    log_debug(gc, ref)(\"Skipped SoftWeakFinalRefsPhase of Reference Processing: no references\");\n@@ -845,1 +728,1 @@\n-  RefProcMTDegreeAdjuster a(this, RefPhase2, num_total_refs);\n+  RefProcMTDegreeAdjuster a(this, SoftWeakFinalRefsPhase, num_total_refs);\n@@ -848,1 +731,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase2, &phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(SoftWeakFinalRefsPhase, &phase_times);\n@@ -854,1 +737,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase2, &phase_times);\n+  RefProcPhaseTimeTracker tt(SoftWeakFinalRefsPhase, &phase_times);\n@@ -856,3 +739,3 @@\n-  log_reflist(\"Phase 2 Soft before\", _discoveredSoftRefs, _max_num_queues);\n-  log_reflist(\"Phase 2 Weak before\", _discoveredWeakRefs, _max_num_queues);\n-  log_reflist(\"Phase 2 Final before\", _discoveredFinalRefs, _max_num_queues);\n+  log_reflist(\"SoftWeakFinalRefsPhase Soft before\", _discoveredSoftRefs, _max_num_queues);\n+  log_reflist(\"SoftWeakFinalRefsPhase Weak before\", _discoveredWeakRefs, _max_num_queues);\n+  log_reflist(\"SoftWeakFinalRefsPhase Final before\", _discoveredFinalRefs, _max_num_queues);\n@@ -860,2 +743,2 @@\n-  RefProcPhase2Task phase2(*this, &phase_times);\n-  run_task(phase2, proxy_task, false);\n+  RefProcSoftWeakFinalPhaseTask phase_task(*this, &phase_times);\n+  run_task(phase_task, proxy_task, false);\n@@ -865,1 +748,1 @@\n-  log_reflist(\"Phase 2 Final after\", _discoveredFinalRefs, _max_num_queues);\n+  log_reflist(\"SoftWeakFinalRefsPhase Final after\", _discoveredFinalRefs, _max_num_queues);\n@@ -875,1 +758,1 @@\n-    log_debug(gc, ref)(\"Skipped phase 3 of Reference Processing: no references\");\n+    log_debug(gc, ref)(\"Skipped KeepAliveFinalRefsPhase of Reference Processing: no references\");\n@@ -879,1 +762,1 @@\n-  RefProcMTDegreeAdjuster a(this, RefPhase3, num_final_refs);\n+  RefProcMTDegreeAdjuster a(this, KeepAliveFinalRefsPhase, num_final_refs);\n@@ -882,1 +765,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase3, &phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(KeepAliveFinalRefsPhase, &phase_times);\n@@ -886,5 +769,4 @@\n-  \/\/ Phase 3:\n-  \/\/ . Traverse referents of final references and keep them and followers alive.\n-  RefProcPhaseTimeTracker tt(RefPhase3, &phase_times);\n-  RefProcPhase3Task phase3(*this, &phase_times);\n-  run_task(phase3, proxy_task, true);\n+  \/\/ Traverse referents of final references and keep them and followers alive.\n+  RefProcPhaseTimeTracker tt(KeepAliveFinalRefsPhase, &phase_times);\n+  RefProcKeepAliveFinalPhaseTask phase_task(*this, &phase_times);\n+  run_task(phase_task, proxy_task, true);\n@@ -903,1 +785,1 @@\n-    log_debug(gc, ref)(\"Skipped phase 4 of Reference Processing: no references\");\n+    log_debug(gc, ref)(\"Skipped PhantomRefsPhase of Reference Processing: no references\");\n@@ -907,1 +789,1 @@\n-  RefProcMTDegreeAdjuster a(this, RefPhase4, num_phantom_refs);\n+  RefProcMTDegreeAdjuster a(this, PhantomRefsPhase, num_phantom_refs);\n@@ -910,1 +792,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase4, &phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(PhantomRefsPhase, &phase_times);\n@@ -914,2 +796,2 @@\n-  \/\/ Phase 4: Walk phantom references appropriately.\n-  RefProcPhaseTimeTracker tt(RefPhase4, &phase_times);\n+  \/\/ Walk phantom references appropriately.\n+  RefProcPhaseTimeTracker tt(PhantomRefsPhase, &phase_times);\n@@ -917,1 +799,1 @@\n-  log_reflist(\"Phase 4 Phantom before\", _discoveredPhantomRefs, _max_num_queues);\n+  log_reflist(\"PhantomRefsPhase Phantom before\", _discoveredPhantomRefs, _max_num_queues);\n@@ -919,2 +801,2 @@\n-  RefProcPhase4Task phase4(*this, &phase_times);\n-  run_task(phase4, proxy_task, false);\n+  RefProcPhantomPhaseTask phase_task(*this, &phase_times);\n+  run_task(phase_task, proxy_task, false);\n@@ -1310,2 +1192,2 @@\n-  \/\/ Even a small number of references in either of those cases could produce large amounts of work.\n-  return (phase == ReferenceProcessor::RefPhase1 || phase == ReferenceProcessor::RefPhase3);\n+  \/\/ Even a small number of references in this phase could produce large amounts of work.\n+  return phase == ReferenceProcessor::KeepAliveFinalRefsPhase;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":50,"deletions":168,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -163,4 +163,3 @@\n-  friend class RefProcPhase1Task;\n-  friend class RefProcPhase2Task;\n-  friend class RefProcPhase3Task;\n-  friend class RefProcPhase4Task;\n+  friend class RefProcSoftWeakFinalPhaseTask;\n+  friend class RefProcKeepAliveFinalPhaseTask;\n+  friend class RefProcPhantomPhaseTask;\n@@ -171,6 +170,5 @@\n-    SoftRefSubPhase1,\n-    SoftRefSubPhase2,\n-    WeakRefSubPhase2,\n-    FinalRefSubPhase2,\n-    FinalRefSubPhase3,\n-    PhantomRefSubPhase4,\n+    ProcessSoftRefSubPhase,\n+    ProcessWeakRefSubPhase,\n+    ProcessFinalRefSubPhase,\n+    KeepAliveFinalRefsSubPhase,\n+    ProcessPhantomRefsSubPhase,\n@@ -182,4 +180,3 @@\n-    RefPhase1,\n-    RefPhase2,\n-    RefPhase3,\n-    RefPhase4,\n+    SoftWeakFinalRefsPhase,\n+    KeepAliveFinalRefsPhase,\n+    PhantomRefsPhase,\n@@ -205,1 +202,0 @@\n-  bool        _enqueuing_is_done;       \/\/ true if all weak references enqueued\n@@ -241,5 +237,1 @@\n-  \/\/ Phase 1: Re-evaluate soft ref policy.\n-  void process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n-                                   ReferenceProcessorPhaseTimes& phase_times);\n-\n-  \/\/ Phase 2: Drop Soft\/Weak\/Final references with a NULL or live referent, and clear\n+  \/\/ Drop Soft\/Weak\/Final references with a NULL or live referent, and clear\n@@ -250,1 +242,1 @@\n-  \/\/ Phase 3: Keep alive followers of Final references, and enqueue.\n+  \/\/ Keep alive followers of Final references, and enqueue.\n@@ -254,1 +246,1 @@\n-  \/\/ Phase 4: Drop and keep alive live Phantom references, or clear and enqueue if dead.\n+  \/\/ Drop and keep alive live Phantom references, or clear and enqueue if dead.\n@@ -261,9 +253,0 @@\n-  \/\/ (SoftReferences only) Traverse the list and remove any SoftReferences whose\n-  \/\/ referents are not alive, but that should be kept alive for policy reasons.\n-  \/\/ Keep alive the transitive closure of all such referents.\n-  size_t process_soft_ref_reconsider_work(DiscoveredList&     refs_list,\n-                                          ReferencePolicy*    policy,\n-                                          BoolObjectClosure*  is_alive,\n-                                          OopClosure*         keep_alive,\n-                                          VoidClosure*        complete_gc);\n-\n@@ -289,0 +272,6 @@\n+\n+  void setup_policy(bool always_clear) {\n+    _current_soft_ref_policy = always_clear ?\n+                               _always_clear_soft_ref_policy : _default_soft_ref_policy;\n+    _current_soft_ref_policy->setup();   \/\/ snapshot the policy threshold\n+  }\n@@ -296,5 +285,3 @@\n-  ReferencePolicy* setup_policy(bool always_clear) {\n-    _current_soft_ref_policy = always_clear ?\n-      _always_clear_soft_ref_policy : _default_soft_ref_policy;\n-    _current_soft_ref_policy->setup();   \/\/ snapshot the policy threshold\n-    return _current_soft_ref_policy;\n+  void start_discovery(bool always_clear) {\n+    enable_discovery();\n+    setup_policy(always_clear);\n@@ -400,1 +387,0 @@\n-  void set_atomic_discovery(bool atomic) { _discovery_is_atomic = atomic; }\n@@ -409,4 +395,0 @@\n-  \/\/ whether all enqueueing of weak references is complete\n-  bool enqueuing_is_done()  { return _enqueuing_is_done; }\n-  void set_enqueuing_is_done(bool v) { _enqueuing_is_done = v; }\n-\n@@ -461,21 +443,0 @@\n-\/\/ A utility class to disable reference discovery in\n-\/\/ the scope which contains it, for given ReferenceProcessor.\n-class NoRefDiscovery: StackObj {\n- private:\n-  ReferenceProcessor* _rp;\n-  bool _was_discovering_refs;\n- public:\n-  NoRefDiscovery(ReferenceProcessor* rp) : _rp(rp) {\n-    _was_discovering_refs = _rp->discovery_enabled();\n-    if (_was_discovering_refs) {\n-      _rp->disable_discovery();\n-    }\n-  }\n-\n-  ~NoRefDiscovery() {\n-    if (_was_discovering_refs) {\n-      _rp->enable_discovery(false \/*check_no_refs*\/);\n-    }\n-  }\n-};\n-\n@@ -564,21 +525,0 @@\n-\/\/ A utility class to temporarily change the disposition\n-\/\/ of the \"discovery_is_atomic\" field of the\n-\/\/ given ReferenceProcessor in the scope that contains it.\n-class ReferenceProcessorAtomicMutator: StackObj {\n- private:\n-  ReferenceProcessor* _rp;\n-  bool                _saved_atomic_discovery;\n-\n- public:\n-  ReferenceProcessorAtomicMutator(ReferenceProcessor* rp,\n-                                  bool atomic):\n-    _rp(rp) {\n-    _saved_atomic_discovery = _rp->discovery_is_atomic();\n-    _rp->set_atomic_discovery(atomic);\n-  }\n-\n-  ~ReferenceProcessorAtomicMutator() {\n-    _rp->set_atomic_discovery(_saved_atomic_discovery);\n-  }\n-};\n-\n@@ -598,0 +538,4 @@\n+  \/\/ Used for tracking how much time a worker spends in a (sub)phase.\n+  uint tracker_id(uint worker_id) const {\n+    return _ref_processor.processing_is_mt() ? worker_id : 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":27,"deletions":83,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#define ASSERT_PHASE(phase) assert((phase) >= ReferenceProcessor::RefPhase1 && \\\n+#define ASSERT_PHASE(phase) assert((phase) >= ReferenceProcessor::SoftWeakFinalRefsPhase && \\\n@@ -43,1 +43,1 @@\n-#define ASSERT_SUB_PHASE(phase) assert((phase) >= ReferenceProcessor::SoftRefSubPhase1 && \\\n+#define ASSERT_SUB_PHASE(phase) assert((phase) >= ReferenceProcessor::ProcessSoftRefSubPhase && \\\n@@ -48,1 +48,0 @@\n-       \"SoftRef (ms):\",\n@@ -56,1 +55,1 @@\n-static const char* Phase2ParWorkTitle = \"Total (ms):\";\n+static const char* SoftWeakFinalRefsPhaseParWorkTitle = \"Total (ms):\";\n@@ -59,1 +58,0 @@\n-       \"SoftRef:\",\n@@ -67,1 +65,1 @@\n-static const char* Phase2SerWorkTitle = \"Total:\";\n+static const char* SoftWeakFinalRefsPhaseSerWorkTitle = \"Total:\";\n@@ -72,1 +70,0 @@\n-       \"Reconsider SoftReferences\",\n@@ -101,1 +98,1 @@\n-  _worker_time->set(_worker_id, result);\n+  _worker_time->set_or_add(_worker_id, result);\n@@ -120,3 +117,1 @@\n-  if (_phase_times->gc_timer() != NULL) {\n-    _phase_times->gc_timer()->register_gc_phase_start(title, _start_ticks);\n-  }\n+  _phase_times->gc_timer()->register_gc_phase_start(title, _start_ticks);\n@@ -141,4 +136,2 @@\n-  if (_phase_times->gc_timer() != NULL) {\n-    Ticks ticks = end_ticks();\n-    _phase_times->gc_timer()->register_gc_phase_end(ticks);\n-  }\n+  Ticks ticks = end_ticks();\n+  _phase_times->gc_timer()->register_gc_phase_end(ticks);\n@@ -178,1 +171,1 @@\n-\n+  assert(gc_timer != nullptr, \"pre-condition\");\n@@ -182,1 +175,1 @@\n-  _phase2_worker_time_sec = new WorkerDataArray<double>(NULL, Phase2ParWorkTitle, max_gc_threads);\n+  _soft_weak_final_refs_phase_worker_time_sec = new WorkerDataArray<double>(NULL, SoftWeakFinalRefsPhaseParWorkTitle, max_gc_threads);\n@@ -218,1 +211,1 @@\n-  _phase2_worker_time_sec->reset();\n+  _soft_weak_final_refs_phase_worker_time_sec->reset();\n@@ -234,1 +227,1 @@\n-  delete _phase2_worker_time_sec;\n+  delete _soft_weak_final_refs_phase_worker_time_sec;\n@@ -282,4 +275,3 @@\n-  print_phase(ReferenceProcessor::RefPhase1, next_indent);\n-  print_phase(ReferenceProcessor::RefPhase2, next_indent);\n-  print_phase(ReferenceProcessor::RefPhase3, next_indent);\n-  print_phase(ReferenceProcessor::RefPhase4, next_indent);\n+  print_phase(ReferenceProcessor::SoftWeakFinalRefsPhase, next_indent);\n+  print_phase(ReferenceProcessor::KeepAliveFinalRefsPhase, next_indent);\n+  print_phase(ReferenceProcessor::PhantomRefsPhase, next_indent);\n@@ -336,7 +328,4 @@\n-      case ReferenceProcessor::RefPhase1:\n-        print_sub_phase(&ls, ReferenceProcessor::SoftRefSubPhase1, indent + 1);\n-        break;\n-      case ReferenceProcessor::RefPhase2:\n-        print_sub_phase(&ls, ReferenceProcessor::SoftRefSubPhase2, indent + 1);\n-        print_sub_phase(&ls, ReferenceProcessor::WeakRefSubPhase2, indent + 1);\n-        print_sub_phase(&ls, ReferenceProcessor::FinalRefSubPhase2, indent + 1);\n+      case ReferenceProcessor::SoftWeakFinalRefsPhase:\n+        print_sub_phase(&ls, ReferenceProcessor::ProcessSoftRefSubPhase, indent + 1);\n+        print_sub_phase(&ls, ReferenceProcessor::ProcessWeakRefSubPhase, indent + 1);\n+        print_sub_phase(&ls, ReferenceProcessor::ProcessFinalRefSubPhase, indent + 1);\n@@ -344,2 +333,2 @@\n-      case ReferenceProcessor::RefPhase3:\n-        print_sub_phase(&ls, ReferenceProcessor::FinalRefSubPhase3, indent + 1);\n+      case ReferenceProcessor::KeepAliveFinalRefsPhase:\n+        print_sub_phase(&ls, ReferenceProcessor::KeepAliveFinalRefsSubPhase, indent + 1);\n@@ -347,2 +336,2 @@\n-      case ReferenceProcessor::RefPhase4:\n-        print_sub_phase(&ls, ReferenceProcessor::PhantomRefSubPhase4, indent + 1);\n+      case ReferenceProcessor::PhantomRefsPhase:\n+        print_sub_phase(&ls, ReferenceProcessor::ProcessPhantomRefsSubPhase, indent + 1);\n@@ -353,2 +342,2 @@\n-    if (phase == ReferenceProcessor::RefPhase2) {\n-      print_worker_time(&ls, _phase2_worker_time_sec, Phase2SerWorkTitle, indent + 1);\n+    if (phase == ReferenceProcessor::SoftWeakFinalRefsPhase) {\n+      print_worker_time(&ls, _soft_weak_final_refs_phase_worker_time_sec, SoftWeakFinalRefsPhaseSerWorkTitle, indent + 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  WorkerDataArray<double>* _phase2_worker_time_sec;\n+  WorkerDataArray<double>* _soft_weak_final_refs_phase_worker_time_sec;\n@@ -83,1 +83,1 @@\n-  WorkerDataArray<double>* phase2_worker_time_sec() const { return _phase2_worker_time_sec; }\n+  WorkerDataArray<double>* soft_weak_final_refs_phase_worker_time_sec() const { return _soft_weak_final_refs_phase_worker_time_sec; }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static const uint MaxThreadWorkItems = 6;\n+  static const uint MaxThreadWorkItems = 9;\n@@ -70,0 +70,1 @@\n+  void set_or_add(uint worker_i, T value);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+template <typename T>\n+void WorkerDataArray<T>::set_or_add(uint worker_i, T value) {\n+  assert(worker_i < _length, \"Worker %d is greater than max: %d\", worker_i, _length);\n+  if (_data[worker_i] == uninitialized()) {\n+    _data[worker_i] = value;\n+  } else {\n+    _data[worker_i] += value;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -222,0 +222,3 @@\n+\n+  \/\/ Printing\n+  const char* type_name() const override { return \"GCTaskThread\"; }\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -319,0 +319,22 @@\n+void ShenandoahAsserts::assert_marked_weak(void *interior_loc, oop obj, const char *file, int line) {\n+  assert_correct(interior_loc, obj, file, line);\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!heap->marking_context()->is_marked_weak(obj)) {\n+    print_failure(_safe_all, obj, interior_loc, NULL, \"Shenandoah assert_marked_weak failed\",\n+                  \"Object should be marked weakly\",\n+                  file, line);\n+  }\n+}\n+\n+void ShenandoahAsserts::assert_marked_strong(void *interior_loc, oop obj, const char *file, int line) {\n+  assert_correct(interior_loc, obj, file, line);\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!heap->marking_context()->is_marked_strong(obj)) {\n+    print_failure(_safe_all, obj, interior_loc, NULL, \"Shenandoah assert_marked_strong failed\",\n+                  \"Object should be marked strongly\",\n+                  file, line);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+  static void assert_marked_weak(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_marked_strong(void* interior_loc, oop obj, const char* file, int line);\n@@ -110,0 +112,14 @@\n+#define shenandoah_assert_marked_weak_if(interior_loc, obj, condition) \\\n+  if (condition)    ShenandoahAsserts::assert_marked_weak(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_marked_weak_except(interior_loc, obj, exception) \\\n+  if (!(exception)) ShenandoahAsserts::assert_marked_weak(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_marked_weak(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_marked_weak(interior_loc, obj, __FILE__, __LINE__)\n+\n+#define shenandoah_assert_marked_strong_if(interior_loc, obj, condition) \\\n+  if (condition)    ShenandoahAsserts::assert_marked_strong(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_marked_strong_except(interior_loc, obj, exception) \\\n+  if (!(exception)) ShenandoahAsserts::assert_marked_strong(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_marked_strong(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_marked_strong(interior_loc, obj, __FILE__, __LINE__)\n+\n@@ -171,0 +187,8 @@\n+#define shenandoah_assert_marked_weak_if(interior_loc, obj, condition)\n+#define shenandoah_assert_marked_weak_except(interior_loc, obj, exception)\n+#define shenandoah_assert_marked_weak(interior_loc, obj)\n+\n+#define shenandoah_assert_marked_strong_if(interior_loc, obj, condition)\n+#define shenandoah_assert_marked_strong_except(interior_loc, obj, exception)\n+#define shenandoah_assert_marked_strong(interior_loc, obj)\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-      JavaThread* const jt = thread->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(thread);\n@@ -125,1 +125,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n@@ -128,1 +128,1 @@\n-        StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+        StackWatermarkSet::finish_processing(JavaThread::cast(thread), &oops, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    return (decorators & (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF | ON_UNKNOWN_OOP_REF)) == 0;\n+    return (decorators & (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) == 0;\n@@ -61,1 +61,1 @@\n-    return (decorators & (ON_WEAK_OOP_REF | ON_UNKNOWN_OOP_REF)) != 0;\n+    return (decorators & ON_WEAK_OOP_REF) != 0;\n@@ -93,2 +93,0 @@\n-  template <DecoratorSet decorators>\n-  inline void keep_alive_if_weak(oop value);\n@@ -104,2 +102,11 @@\n-  template <DecoratorSet decorators, class T>\n-  inline oop load_reference_barrier(oop obj, T* load_addr);\n+  template <class T>\n+  inline oop load_reference_barrier(DecoratorSet decorators, oop obj, T* load_addr);\n+\n+  template <typename T>\n+  inline oop oop_load(DecoratorSet decorators, T* addr);\n+\n+  template <typename T>\n+  inline oop oop_cmpxchg(DecoratorSet decorators, T* addr, oop compare_value, oop new_value);\n+\n+  template <typename T>\n+  inline oop oop_xchg(DecoratorSet decorators, T* addr, oop new_value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n@@ -102,2 +102,2 @@\n-template <DecoratorSet decorators, class T>\n-inline oop ShenandoahBarrierSet::load_reference_barrier(oop obj, T* load_addr) {\n+template <class T>\n+inline oop ShenandoahBarrierSet::load_reference_barrier(DecoratorSet decorators, oop obj, T* load_addr) {\n@@ -109,1 +109,1 @@\n-  if (HasDecorator<decorators, ON_PHANTOM_OOP_REF>::value &&\n+  if ((decorators & ON_PHANTOM_OOP_REF) != 0 &&\n@@ -116,1 +116,1 @@\n-  if ((HasDecorator<decorators, ON_WEAK_OOP_REF>::value || HasDecorator<decorators, ON_UNKNOWN_OOP_REF>::value) &&\n+  if ((decorators & ON_WEAK_OOP_REF) != 0 &&\n@@ -124,1 +124,1 @@\n-  if (HasDecorator<decorators, AS_NO_KEEPALIVE>::value &&\n+  if ((decorators & AS_NO_KEEPALIVE) != 0 &&\n@@ -133,1 +133,1 @@\n-    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n@@ -187,7 +187,35 @@\n-template <DecoratorSet decorators>\n-inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {\n-  assert((decorators & ON_UNKNOWN_OOP_REF) == 0, \"Reference strength must be known\");\n-  if (!HasDecorator<decorators, ON_STRONG_OOP_REF>::value &&\n-      !HasDecorator<decorators, AS_NO_KEEPALIVE>::value) {\n-    satb_enqueue(value);\n-  }\n+template <typename T>\n+inline oop ShenandoahBarrierSet::oop_load(DecoratorSet decorators, T* addr) {\n+  oop value = RawAccess<>::oop_load(addr);\n+  value = load_reference_barrier(decorators, value, addr);\n+  keep_alive_if_weak(decorators, value);\n+  return value;\n+}\n+\n+template <typename T>\n+inline oop ShenandoahBarrierSet::oop_cmpxchg(DecoratorSet decorators, T* addr, oop compare_value, oop new_value) {\n+  iu_barrier(new_value);\n+  oop res;\n+  oop expected = compare_value;\n+  do {\n+    compare_value = expected;\n+    res = RawAccess<>::oop_atomic_cmpxchg(addr, compare_value, new_value);\n+    expected = res;\n+  } while ((compare_value != expected) && (resolve_forwarded(compare_value) == resolve_forwarded(expected)));\n+\n+  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n+  \/\/ because it must be the previous value.\n+  res = load_reference_barrier(decorators, res, reinterpret_cast<T*>(NULL));\n+  satb_enqueue(res);\n+  return res;\n+}\n+\n+template <typename T>\n+inline oop ShenandoahBarrierSet::oop_xchg(DecoratorSet decorators, T* addr, oop new_value) {\n+  iu_barrier(new_value);\n+  oop previous = RawAccess<>::oop_atomic_xchg(addr, new_value);\n+  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n+  \/\/ because it must be the previous value.\n+  previous = load_reference_barrier<T>(decorators, previous, reinterpret_cast<T*>(NULL));\n+  satb_enqueue(previous);\n+  return previous;\n@@ -199,7 +227,3 @@\n-  oop value = Raw::oop_load_not_in_heap(addr);\n-  if (value != NULL) {\n-    ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n-    value = bs->load_reference_barrier<decorators, T>(value, addr);\n-    bs->keep_alive_if_weak<decorators>(value);\n-  }\n-  return value;\n+  assert((decorators & ON_UNKNOWN_OOP_REF) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();\n+  return bs->oop_load(decorators, addr);\n@@ -211,5 +235,3 @@\n-  oop value = Raw::oop_load_in_heap(addr);\n-  ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n-  value = bs->load_reference_barrier<decorators, T>(value, addr);\n-  bs->keep_alive_if_weak<decorators>(value);\n-  return value;\n+  assert((decorators & ON_UNKNOWN_OOP_REF) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();\n+  return bs->oop_load(decorators, addr);\n@@ -220,2 +242,1 @@\n-  oop value = Raw::oop_load_in_heap_at(base, offset);\n-  ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n+  ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();\n@@ -223,3 +244,1 @@\n-  value = bs->load_reference_barrier<decorators>(value, AccessInternal::oop_field_addr<decorators>(base, offset));\n-  bs->keep_alive_if_weak(resolved_decorators, value);\n-  return value;\n+  return bs->oop_load(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset));\n@@ -257,0 +276,1 @@\n+  assert((decorators & (AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF)) == 0, \"must be absent\");\n@@ -258,15 +278,1 @@\n-  bs->iu_barrier(new_value);\n-\n-  oop res;\n-  oop expected = compare_value;\n-  do {\n-    compare_value = expected;\n-    res = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n-    expected = res;\n-  } while ((compare_value != expected) && (resolve_forwarded(compare_value) == resolve_forwarded(expected)));\n-\n-  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n-  \/\/ because it must be the previous value.\n-  res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier<decorators, T>(res, NULL);\n-  bs->satb_enqueue(res);\n-  return res;\n+  return bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n@@ -278,1 +284,3 @@\n-  return oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);\n+  assert((decorators & (AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF)) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  return bs->oop_cmpxchg(decorators, addr, compare_value, new_value);\n@@ -283,1 +291,4 @@\n-  return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+  assert((decorators & AS_NO_KEEPALIVE) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  DecoratorSet resolved_decorators = AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset);\n+  return bs->oop_cmpxchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n@@ -289,0 +300,1 @@\n+  assert((decorators & (AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF)) == 0, \"must be absent\");\n@@ -290,9 +302,1 @@\n-  bs->iu_barrier(new_value);\n-\n-  oop previous = Raw::oop_atomic_xchg(addr, new_value);\n-\n-  \/\/ Note: We don't need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,\n-  \/\/ because it must be the previous value.\n-  previous = ShenandoahBarrierSet::barrier_set()->load_reference_barrier<decorators, T>(previous, NULL);\n-  bs->satb_enqueue(previous);\n-  return previous;\n+  return bs->oop_xchg(decorators, addr, new_value);\n@@ -304,1 +308,3 @@\n-  return oop_atomic_xchg_not_in_heap(addr, new_value);\n+  assert((decorators & (AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF)) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  return bs->oop_xchg(decorators, addr, new_value);\n@@ -309,1 +315,4 @@\n-  return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+  assert((decorators & AS_NO_KEEPALIVE) == 0, \"must be absent\");\n+  ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();\n+  DecoratorSet resolved_decorators = AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset);\n+  return bs->oop_xchg(resolved_decorators, AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n@@ -352,1 +361,1 @@\n-        oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);\n+        ShenandoahHeap::atomic_update_oop(fwd, elem_ptr, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":69,"deletions":60,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        ShenandoahHeap::cas_oop(fwd, p, o);\n+        ShenandoahHeap::atomic_update_oop(fwd, p, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-      _heap->cas_oop(resolved, p, o);\n+      ShenandoahHeap::atomic_update_oop(resolved, p, o);\n@@ -210,1 +210,1 @@\n-        Atomic::cmpxchg(p, obj, oop());\n+        ShenandoahHeap::atomic_clear_oop(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -689,1 +689,1 @@\n-      Atomic::cmpxchg(p, obj, oop(NULL));\n+      ShenandoahHeap::atomic_clear_oop(p, obj);\n@@ -695,1 +695,1 @@\n-      Atomic::cmpxchg(p, obj, resolved);\n+      ShenandoahHeap::atomic_update_oop(resolved, p, obj);\n@@ -937,1 +937,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  char* name() const { return (char*)\"ShenandoahControlThread\";}\n+  const char* name() const { return \"ShenandoahControlThread\";}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -185,1 +184,0 @@\n-    BiasedLocking::preserve_marks();\n@@ -233,1 +231,0 @@\n-    BiasedLocking::restore_marks();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-      ThreadBlockInVM sp(thread->as_Java_thread());\n+      ThreadBlockInVM sp(JavaThread::cast(thread));\n@@ -1929,1 +1929,4 @@\n-  heap_region_containing(o)->record_unpin();\n+  ShenandoahHeapRegion* r = heap_region_containing(o);\n+  assert(r != NULL, \"Sanity\");\n+  assert(r->pin_count() > 0, \"Region \" SIZE_FORMAT \" should have non-zero pins\", r->index());\n+  r->record_unpin();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -638,3 +638,11 @@\n-  static inline oop cas_oop(oop n, narrowOop* addr, oop c);\n-  static inline oop cas_oop(oop n, oop* addr, oop c);\n-  static inline oop cas_oop(oop n, narrowOop* addr, narrowOop c);\n+  static inline void atomic_update_oop(oop update,       oop* addr,       oop compare);\n+  static inline void atomic_update_oop(oop update, narrowOop* addr,       oop compare);\n+  static inline void atomic_update_oop(oop update, narrowOop* addr, narrowOop compare);\n+\n+  static inline bool atomic_update_oop_check(oop update,       oop* addr,       oop compare);\n+  static inline bool atomic_update_oop_check(oop update, narrowOop* addr,       oop compare);\n+  static inline bool atomic_update_oop_check(oop update, narrowOop* addr, narrowOop compare);\n+\n+  static inline void atomic_clear_oop(      oop* addr,       oop compare);\n+  static inline void atomic_clear_oop(narrowOop* addr,       oop compare);\n+  static inline void atomic_clear_oop(narrowOop* addr, narrowOop compare);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -135,3 +135,1 @@\n-      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n-      oop witness = cas_oop(fwd, p, obj);\n-      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n+      atomic_update_oop(fwd, p, obj);\n@@ -142,1 +140,86 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, oop* addr, oop c) {\n+\/\/ Atomic updates of heap location. This is only expected to work with updating the same\n+\/\/ logical object with its forwardee. The reason why we need stronger-than-relaxed memory\n+\/\/ ordering has to do with coordination with GC barriers and mutator accesses.\n+\/\/\n+\/\/ In essence, stronger CAS access is required to maintain the transitive chains that mutator\n+\/\/ accesses build by themselves. To illustrate this point, consider the following example.\n+\/\/\n+\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Normally, the accesses to volatile\n+\/\/ field at \"addr\" would be matched with release\/acquire barriers. This changes when GC moves\n+\/\/ the object under mutator feet.\n+\/\/\n+\/\/ Thread 1 (Java)\n+\/\/         \/\/ --- previous access starts here\n+\/\/         ...\n+\/\/   T1.1: store(&o.x, 1, mo_relaxed)\n+\/\/   T1.2: store(&addr, o, mo_release) \/\/ volatile store\n+\/\/\n+\/\/         \/\/ --- new access starts here\n+\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n+\/\/   T1.3: var copy = copy(o)\n+\/\/   T1.4: cas(&fwd, t, copy, mo_release) \/\/ pointer-mediated publication\n+\/\/         <access continues>\n+\/\/\n+\/\/ Thread 2 (GC updater)\n+\/\/   T2.1: var f = load(&fwd, mo_{consume|acquire}) \/\/ pointer-mediated acquisition\n+\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n+\/\/\n+\/\/ Thread 3 (Java)\n+\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n+\/\/   T3.2: if (o != null)\n+\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n+\/\/\n+\/\/ r is guaranteed to contain \"1\".\n+\/\/\n+\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n+\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n+\/\/ another thread updates the reference to it, we need to have the transitive edge\n+\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n+\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n+\/\/\n+\/\/ Note that we do not need to \"acquire\" in these methods, because we do not read the\n+\/\/ failure witnesses contents on any path, and \"release\" is enough.\n+\/\/\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, compare, update, memory_order_release);\n+}\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, compare, u, memory_order_release);\n+}\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, c, u, memory_order_release);\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  return (oop) Atomic::cmpxchg(addr, compare, update, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  return (narrowOop) Atomic::cmpxchg(addr, compare, u, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, u, memory_order_release)) == compare;\n+}\n+\n+\/\/ The memory ordering discussion above does not apply for methods that store NULLs:\n+\/\/ then, there is no transitive reads in mutator (as we see NULLs), and we can do\n+\/\/ relaxed memory ordering there.\n+\n+inline void ShenandoahHeap::atomic_clear_oop(oop* addr, oop compare) {\n@@ -144,1 +227,1 @@\n-  return (oop) Atomic::cmpxchg(addr, c, n);\n+  Atomic::cmpxchg(addr, compare, oop(), memory_order_relaxed);\n@@ -147,1 +230,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, narrowOop c) {\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, oop compare) {\n@@ -149,2 +232,2 @@\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val));\n+  narrowOop cmp = CompressedOops::encode(compare);\n+  Atomic::cmpxchg(addr, cmp, narrowOop(), memory_order_relaxed);\n@@ -153,1 +236,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, oop c) {\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, narrowOop compare) {\n@@ -155,3 +238,1 @@\n-  narrowOop cmp = CompressedOops::encode(c);\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val));\n+  Atomic::cmpxchg(addr, compare, narrowOop(), memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -120,14 +120,3 @@\n-static bool reference_cas_discovered(oop reference, oop discovered);\n-\n-template<>\n-bool reference_cas_discovered<narrowOop>(oop reference, oop discovered) {\n-  volatile narrowOop* addr = reinterpret_cast<volatile narrowOop*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n-  narrowOop compare = CompressedOops::encode(NULL);\n-  narrowOop exchange = CompressedOops::encode(discovered);\n-  return Atomic::cmpxchg(addr, compare, exchange) == compare;\n-}\n-\n-template<>\n-bool reference_cas_discovered<oop>(oop reference, oop discovered) {\n-  volatile oop* addr = reinterpret_cast<volatile oop*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n-  return Atomic::cmpxchg(addr, oop(NULL), discovered) == NULL;\n+static bool reference_cas_discovered(oop reference, oop discovered) {\n+  T* addr = reinterpret_cast<T *>(java_lang_ref_Reference::discovered_addr_raw(reference));\n+  return ShenandoahHeap::atomic_update_oop_check(discovered, addr, NULL);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  NONCOPYABLE(ShenandoahRefProcThreadLocal);\n@@ -89,3 +90,0 @@\n-  ShenandoahRefProcThreadLocal(const ShenandoahRefProcThreadLocal&) = delete; \/\/ non construction-copyable\n-  ShenandoahRefProcThreadLocal& operator=(const ShenandoahRefProcThreadLocal&) = delete; \/\/ non copyable\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  JavaThread* const jt = thread->as_Java_thread();\n+  JavaThread* const jt = JavaThread::cast(thread);\n@@ -205,1 +205,1 @@\n-        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(thr->as_Java_thread(), StackWatermarkKind::gc);\n+        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(JavaThread::cast(thr), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_WEAK_OOP_REF, oop>(oop(src), load_addr);\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<oop>(ON_WEAK_OOP_REF, oop(src), load_addr);\n@@ -75,1 +75,1 @@\n-  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_WEAK_OOP_REF, narrowOop>(oop(src), load_addr);\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<narrowOop>(ON_WEAK_OOP_REF, oop(src), load_addr);\n@@ -79,1 +79,1 @@\n-  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_PHANTOM_OOP_REF, oop>(oop(src), load_addr);\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<oop>(ON_PHANTOM_OOP_REF, oop(src), load_addr);\n@@ -83,1 +83,1 @@\n-  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_PHANTOM_OOP_REF, narrowOop>(oop(src), load_addr);\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<narrowOop>(ON_PHANTOM_OOP_REF, oop(src), load_addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-      live = new (Compile::current()->comp_arena()->Amalloc_D(sizeof(RegMask))) RegMask();\n+      live = new (Compile::current()->comp_arena()->AmallocWords(sizeof(RegMask))) RegMask();\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-  static oop weak_load_barrier_on_weak_oop_field(volatile oop* p);\n@@ -103,1 +102,0 @@\n-  static oop weak_load_barrier_on_phantom_oop_field(volatile oop* p);\n@@ -119,1 +117,0 @@\n-  static void mark_barrier_on_invisible_root_oop_field(oop* p);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -290,5 +290,0 @@\n-inline oop ZBarrier::weak_load_barrier_on_weak_oop_field(volatile oop* p) {\n-  const oop o = Atomic::load(p);\n-  return weak_load_barrier_on_weak_oop_field_preloaded(p, o);\n-}\n-\n@@ -309,5 +304,0 @@\n-inline oop ZBarrier::weak_load_barrier_on_phantom_oop_field(volatile oop* p) {\n-  const oop o = Atomic::load(p);\n-  return weak_load_barrier_on_phantom_oop_field_preloaded(p, o);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    _sema.wait_with_safepoint_check(thread->as_Java_thread());\n+    _sema.wait_with_safepoint_check(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zFuture.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      ThreadBlockInVM tbivm(_thread->as_Java_thread());\n+      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    JavaThread* const jt = thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -730,3 +729,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -1037,21 +1033,0 @@\n-\n-  if (osr_nm != NULL) {\n-    \/\/ We may need to do on-stack replacement which requires that no\n-    \/\/ monitors in the activation are biased because their\n-    \/\/ BasicObjectLocks will need to migrate during OSR. Force\n-    \/\/ unbiasing of all monitors in the activation now (even though\n-    \/\/ the OSR nmethod might be invalidated) because we don't have a\n-    \/\/ safepoint opportunity later once the migration begins.\n-    if (UseBiasedLocking) {\n-      ResourceMark rm;\n-      GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-      for( BasicObjectLock *kptr = last_frame.monitor_end();\n-           kptr < last_frame.monitor_begin();\n-           kptr = last_frame.next_monitor(kptr) ) {\n-        if( kptr->obj() != NULL ) {\n-          objects_to_revoke->append(Handle(current, kptr->obj()));\n-        }\n-      }\n-      BiasedLocking::revoke(objects_to_revoke, current);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -574,1 +574,0 @@\n-    assert(!klass->can_be_verified_at_dumptime(), \"only shared old classes aren't rewritten\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -579,1 +579,0 @@\n-        \/\/ Monitor not filled in frame manager any longer as this caused race condition with biased locking.\n@@ -583,2 +582,0 @@\n-        assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -679,2 +676,0 @@\n-      assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1522,2 +1517,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1556,2 +1549,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -1880,1 +1871,0 @@\n-              assert(!UseBiasedLocking, \"Not implemented\");\n@@ -2686,2 +2676,0 @@\n-          assert(!UseBiasedLocking, \"Not implemented\");\n-\n@@ -2754,2 +2742,0 @@\n-            assert(!UseBiasedLocking, \"Not implemented\");\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-  DEBUG_ONLY(check_new_unstarted_java_thread(t->as_Java_thread());)\n+  DEBUG_ONLY(check_new_unstarted_java_thread(JavaThread::cast(t));)\n@@ -826,1 +826,1 @@\n-  if (check_exclusion_state_on_thread_start(t->as_Java_thread())) {\n+  if (check_exclusion_state_on_thread_start(JavaThread::cast(t))) {\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n@@ -162,0 +163,1 @@\n+  e.set_objectSize(sample->allocated());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,19 +73,0 @@\n-  <Event name=\"BiasedLockRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Revocation\" description=\"Revoked bias of object\" thread=\"true\"\n-    stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-    <Field type=\"Thread\" name=\"previousOwner\" label=\"Previous Owner\" description=\"Thread owning the bias before revocation\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockSelfRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Self Revocation\" description=\"Revoked bias of object biased towards own thread\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"lockClass\" label=\"Lock Class\" description=\"Class of object whose biased lock was revoked\" \/>\n-  <\/Event>\n-\n-  <Event name=\"BiasedLockClassRevocation\" category=\"Java Virtual Machine, Runtime\" label=\"Biased Lock Class Revocation\" description=\"Revoked biases for all instances of a class\"\n-    thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"Class\" name=\"revokedClass\" label=\"Revoked Class\" description=\"Class whose biased locks were revoked\" \/>\n-    <Field type=\"boolean\" name=\"disableBiasing\" label=\"Disable Further Biasing\" description=\"Whether further biasing for instances of this class will be allowed\" \/>\n-    <Field type=\"ulong\" name=\"safepointId\" label=\"Safepoint Identifier\" relation=\"SafepointId\" \/>\n-  <\/Event>\n-\n@@ -630,0 +611,1 @@\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"objectSize\" label=\"Object Size\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-  JavaThread* jth = context.thread()->as_Java_thread();\n+  JavaThread* jth = JavaThread::cast(context.thread());\n@@ -346,1 +346,2 @@\n-  virtual char* name() const { return (char*)\"JFR Thread Sampler\"; }\n+  virtual const char* name() const { return \"JFR Thread Sampler\"; }\n+  virtual const char* type_name() const { return \"JfrThreadSampler\"; }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-      ThreadInVMfromNative transition(thread->as_Java_thread());\n+      ThreadInVMfromNative transition(JavaThread::cast(thread));\n@@ -481,1 +481,1 @@\n-    JfrJavaEventWriter::notify(thread->as_Java_thread());\n+    JfrJavaEventWriter::notify(JavaThread::cast(thread));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  const oop thread_obj = t->as_Java_thread()->threadObj();\n+  const oop thread_obj = JavaThread::cast(t)->threadObj();\n@@ -126,1 +126,1 @@\n-  return t->is_Java_thread() ? get_java_thread_name(t->as_Java_thread()) : t->name();\n+  return t->is_Java_thread() ? get_java_thread_name(JavaThread::cast(t)) : t->name();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    _writer.write(JfrThreadGroup::thread_group_id(t->as_Java_thread(), _curthread));\n+    _writer.write(JfrThreadGroup::thread_group_id(JavaThread::cast(t), _curthread));\n@@ -279,1 +279,1 @@\n-    JavaThread* const jt = _thread->as_Java_thread();\n+    JavaThread* const jt = JavaThread::cast(_thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-    assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-    return;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? t->as_Java_thread() : NULL),\n+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? JavaThread::cast(t) : NULL),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  return (thread->is_Java_thread() && thread->as_Java_thread()->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n+  return (thread->is_Java_thread() && JavaThread::cast(thread)->thread_state() != _thread_in_vm) || thread->is_VM_thread();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,20 +49,11 @@\n-  bool allocation_failed = false;\n-  JavaThread* new_thread = NULL;\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    new_thread = new JavaThread(proc);\n-    \/\/ At this point it may be possible that no\n-    \/\/ osthread was created for the JavaThread due to lack of memory.\n-    if (new_thread == NULL || new_thread->osthread() == NULL) {\n-      delete new_thread;\n-      allocation_failed = true;\n-    } else {\n-      java_lang_Thread::set_thread(thread_oop(), new_thread);\n-      java_lang_Thread::set_priority(thread_oop(), NormPriority);\n-      java_lang_Thread::set_daemon(thread_oop());\n-      new_thread->set_threadObj(thread_oop());\n-      Threads::add(new_thread);\n-    }\n-  }\n-  if (allocation_failed) {\n-    JfrJavaSupport::throw_out_of_memory_error(\"Unable to create native recording thread for JFR\", CHECK_NULL);\n+  JavaThread* new_thread = new JavaThread(proc);\n+\n+  \/\/ At this point it may be possible that no\n+  \/\/ osthread was created for the JavaThread due to lack of resources.\n+  if (new_thread->osthread() == NULL) {\n+    delete new_thread;\n+    JfrJavaSupport::throw_out_of_memory_error(\"Unable to create native recording thread for JFR\", THREAD);\n+    return NULL;\n+  } else {\n+    JavaThread::start_internal_daemon(THREAD, new_thread, thread_oop, NormPriority);\n+    return new_thread;\n@@ -70,2 +61,0 @@\n-  Thread::start(new_thread);\n-  return new_thread;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  return instance().record_for(thread->as_Java_thread(), skip, frames, tl->stackdepth());\n+  return instance().record_for(JavaThread::cast(thread), skip, frames, tl->stackdepth());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        send_java_thread_start_event(t->as_Java_thread());\n+        send_java_thread_start_event(JavaThread::cast(t));\n@@ -163,1 +163,1 @@\n-      JavaThread* const jt = t->as_Java_thread();\n+      JavaThread* const jt = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-       JfrJavaEventWriter::notify(t->as_Java_thread());\n+       JfrJavaEventWriter::notify(JavaThread::cast(t));\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -48,0 +49,3 @@\n+volatile intx JVMCI::_fatal_log_init_thread = -1;\n+volatile int JVMCI::_fatal_log_fd = -1;\n+const char* JVMCI::_fatal_log_filename = NULL;\n@@ -214,0 +218,39 @@\n+void JVMCI::fatal_log(const char* buf, size_t count) {\n+  intx current_thread_id = os::current_thread_id();\n+  intx invalid_id = -1;\n+  int log_fd;\n+  if (_fatal_log_init_thread == invalid_id && Atomic::cmpxchg(&_fatal_log_init_thread, invalid_id, current_thread_id) == invalid_id) {\n+    if (ErrorFileToStdout) {\n+      log_fd = 1;\n+    } else if (ErrorFileToStderr) {\n+      log_fd = 2;\n+    } else {\n+      static char name_buffer[O_BUFLEN];\n+      log_fd = VMError::prepare_log_file(JVMCINativeLibraryErrorFile, LIBJVMCI_ERR_FILE, true, name_buffer, sizeof(name_buffer));\n+      if (log_fd != -1) {\n+        _fatal_log_filename = name_buffer;\n+      } else {\n+        int e = errno;\n+        tty->print(\"Can't open JVMCI shared library error report file. Error: \");\n+        tty->print_raw_cr(os::strerror(e));\n+        tty->print_cr(\"JVMCI shared library error report will be written to console.\");\n+\n+        \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+        log_fd = 1;\n+      }\n+    }\n+    _fatal_log_fd = log_fd;\n+  } else {\n+    \/\/ Another thread won the race to initialize the stream. Give it time\n+    \/\/ to complete initialization. VM locks cannot be used as the current\n+    \/\/ thread might not be attached to the VM (e.g. a native thread started\n+    \/\/ within libjvmci).\n+    while (_fatal_log_fd == -1) {\n+      os::naked_short_sleep(50);\n+    }\n+  }\n+  fdStream log(_fatal_log_fd);\n+  log.write(buf, count);\n+  log.flush();\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+  \/\/ The file descriptor to which fatal_log() writes. Initialized on\n+  \/\/ first call to fatal_log().\n+  static volatile int _fatal_log_fd;\n+\n+  \/\/ The path of the file underlying _fatal_log_fd if it is a normal file.\n+  static const char* _fatal_log_filename;\n+\n+  \/\/ Native thread id of thread that will initialize _fatal_log_fd.\n+  static volatile intx _fatal_log_init_thread;\n+\n@@ -103,0 +113,7 @@\n+  \/\/ Logs the fatal crash data in `buf` to the appropriate stream.\n+  static void fatal_log(const char* buf, size_t count);\n+\n+  \/\/ Gets the name of the opened JVMCI shared library crash data file or NULL\n+  \/\/ if this file has not been created.\n+  static const char* fatal_log_filename() { return _fatal_log_filename; }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -151,1 +152,1 @@\n-  return thread->as_Java_thread();\n+  return JavaThread::cast(thread);\n@@ -1146,1 +1147,4 @@\n-bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {\n+\/*\n+ * Used by matches() to convert a ResolvedJavaMethod[] to an array of Method*.\n+ *\/\n+GrowableArray<Method*>* init_resolved_methods(jobjectArray methods, JVMCIEnv* JVMCIENV) {\n@@ -1148,1 +1152,1 @@\n-\n+  GrowableArray<Method*>* resolved_methods = new GrowableArray<Method*>(methods_oop->length());\n@@ -1151,1 +1155,26 @@\n-    if ((resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) && HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {\n+    Method* resolved_method = NULL;\n+    if (resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) {\n+      resolved_method = HotSpotJVMCI::asMethod(JVMCIENV, resolved);\n+    }\n+    resolved_methods->append(resolved_method);\n+  }\n+  return resolved_methods;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to check if `method` matches one of the ResolvedJavaMethods in the `methods` array.\n+ * The ResolvedJavaMethod[] array is converted to a Method* array that is then cached in the resolved_methods_ref in\/out parameter.\n+ * In case of a match, the matching ResolvedJavaMethod is returned in matched_jvmci_method_ref.\n+ *\/\n+bool matches(jobjectArray methods, Method* method, GrowableArray<Method*>** resolved_methods_ref, Handle* matched_jvmci_method_ref, Thread* THREAD, JVMCIEnv* JVMCIENV) {\n+  GrowableArray<Method*>* resolved_methods = *resolved_methods_ref;\n+  if (resolved_methods == NULL) {\n+    resolved_methods = init_resolved_methods(methods, JVMCIENV);\n+    *resolved_methods_ref = resolved_methods;\n+  }\n+  assert(method != NULL, \"method should not be NULL\");\n+  assert(resolved_methods->length() == ((objArrayOop) JNIHandles::resolve(methods))->length(), \"arrays must have the same length\");\n+  for (int i = 0; i < resolved_methods->length(); i++) {\n+    Method* m = resolved_methods->at(i);\n+    if (m == method) {\n+      *matched_jvmci_method_ref = Handle(THREAD, ((objArrayOop) JNIHandles::resolve(methods))->obj_at(i));\n@@ -1158,1 +1187,4 @@\n-void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n+\/*\n+ * Resolves an interface call to a concrete method handle.\n+ *\/\n+methodHandle resolve_interface_call(Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n@@ -1164,1 +1196,1 @@\n-          callinfo, receiver, recvrKlass, link_info, true, CHECK);\n+          callinfo, receiver, recvrKlass, link_info, true, CHECK_(methodHandle()));\n@@ -1167,0 +1199,25 @@\n+  return method;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to make a new vframeStream at the given compiled frame id (stack pointer) and vframe id.\n+ *\/\n+void resync_vframestream_to_compiled_frame(vframeStream& vfst, intptr_t* stack_pointer, int vframe_id, JavaThread* thread, TRAPS) {\n+  vfst = vframeStream(thread);\n+  while (vfst.frame_id() != stack_pointer && !vfst.at_end()) {\n+    vfst.next();\n+  }\n+  if (vfst.frame_id() != stack_pointer) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n+  }\n+  if (vfst.is_interpreted_frame()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n+  }\n+  while (vfst.vframe_id() != vframe_id) {\n+    if (vfst.at_end()) {\n+      THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n+    }\n+    vfst.next();\n+    assert(!vfst.is_interpreted_frame(), \"Wrong frame type\");\n+  }\n+}\n@@ -1168,2 +1225,15 @@\n-  \/\/ Invoke the method\n-  JavaCalls::call(result, method, args, CHECK);\n+\/*\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ *\/\n+GrowableArray<ScopeValue*>* get_unallocated_objects_or_null(GrowableArray<ScopeValue*>* scope_objects) {\n+  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  for (int i = 0; i < scope_objects->length(); i++) {\n+    ObjectValue* sv = (ObjectValue*) scope_objects->at(i);\n+    if (sv->value().is_null()) {\n+      if (unallocated == NULL) {\n+        unallocated = new GrowableArray<ScopeValue*>(scope_objects->length());\n+      }\n+      unallocated->append(sv);\n+    }\n+  }\n+  return unallocated;\n@@ -1182,1 +1252,0 @@\n-  Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n@@ -1184,1 +1253,1 @@\n-  StackFrameStream fst(thread, true \/* update *\/, true \/* process_frames *\/);\n+  vframeStream vfst(thread);\n@@ -1186,0 +1255,2 @@\n+  methodHandle visitor_method;\n+  GrowableArray<Method*>* resolved_methods = NULL;\n@@ -1187,5 +1258,1 @@\n-  int frame_number = 0;\n-  vframe* vf = vframe::new_vframe(fst, thread);\n-\n-  while (true) {\n-    \/\/ look for the given method\n+  while (!vfst.at_end()) { \/\/ frame loop\n@@ -1193,27 +1260,47 @@\n-    while (true) {\n-      StackValueCollection* locals = NULL;\n-      if (vf->is_compiled_frame()) {\n-        \/\/ compiled method frame\n-        compiledVFrame* cvf = compiledVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            ScopeDesc* scope = cvf->scope();\n-            \/\/ native wrappers do not have a scope\n-            if (scope != NULL && scope->objects() != NULL) {\n-              GrowableArray<ScopeValue*>* objects;\n-              if (!realloc_called) {\n-                objects = scope->objects();\n-              } else {\n-                \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n-                objects = new GrowableArray<ScopeValue*>(scope->objects()->length());\n-                for (int i = 0; i < scope->objects()->length(); i++) {\n-                  ObjectValue* sv = (ObjectValue*) scope->objects()->at(i);\n-                  if (sv->value().is_null()) {\n-                    objects->append(sv);\n-                  }\n-                }\n-              }\n-              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);\n-              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);\n+    intptr_t* frame_id = vfst.frame_id();\n+\n+    \/\/ Previous compiledVFrame of this frame; use with at_scope() to reuse scope object pool.\n+    compiledVFrame* prev_cvf = NULL;\n+\n+    for (; !vfst.at_end() && vfst.frame_id() == frame_id; vfst.next()) { \/\/ vframe loop\n+      int frame_number = 0;\n+      Method *method = vfst.method();\n+      int bci = vfst.bci();\n+\n+      Handle matched_jvmci_method;\n+      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+          continue;\n+        }\n+        javaVFrame* vf;\n+        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+          assert(prev_cvf->is_compiled_frame(), \"expected compiled Java frame\");\n+          vf = prev_cvf->at_scope(vfst.decode_offset(), vfst.vframe_id());\n+        } else {\n+          vf = vfst.asJavaVFrame();\n+        }\n+\n+        StackValueCollection* locals = NULL;\n+        typeArrayHandle localIsVirtual_h;\n+        if (vf->is_compiled_frame()) {\n+          \/\/ compiled method frame\n+          compiledVFrame* cvf = compiledVFrame::cast(vf);\n+\n+          ScopeDesc* scope = cvf->scope();\n+          \/\/ native wrappers do not have a scope\n+          if (scope != NULL && scope->objects() != NULL) {\n+            prev_cvf = cvf;\n+\n+            GrowableArray<ScopeValue*>* objects = NULL;\n+            if (!realloc_called) {\n+              objects = scope->objects();\n+            } else {\n+              \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n+              objects = get_unallocated_objects_or_null(scope->objects());\n+            }\n+\n+            if (objects != NULL) {\n+              RegisterMap reg_map(vf->register_map());\n+              bool realloc_failures = Deoptimization::realloc_objects(thread, vf->frame_pointer(), &reg_map, objects, CHECK_NULL);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n@@ -1221,0 +1308,1 @@\n+            }\n@@ -1222,8 +1310,7 @@\n-              GrowableArray<ScopeValue*>* local_values = scope->locals();\n-              assert(local_values != NULL, \"NULL locals\");\n-              typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n-              typeArrayHandle array(THREAD, array_oop);\n-              for (int i = 0; i < local_values->length(); i++) {\n-                ScopeValue* value = local_values->at(i);\n-                if (value->is_object()) {\n-                  array->bool_at_put(i, true);\n+            GrowableArray<ScopeValue*>* local_values = scope->locals();\n+            for (int i = 0; i < local_values->length(); i++) {\n+              ScopeValue* value = local_values->at(i);\n+              if (value->is_object()) {\n+                if (localIsVirtual_h.is_null()) {\n+                  typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n+                  localIsVirtual_h = typeArrayHandle(THREAD, array_oop);\n@@ -1231,0 +1318,1 @@\n+                localIsVirtual_h->bool_at_put(i, true);\n@@ -1232,3 +1320,0 @@\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n-            } else {\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n@@ -1236,6 +1321,0 @@\n-\n-            locals = cvf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf->bci());\n-            methodHandle mh(THREAD, cvf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n@@ -1243,0 +1322,8 @@\n+\n+          locals = cvf->locals();\n+          frame_number = cvf->vframe_id();\n+        } else {\n+          \/\/ interpreted method frame\n+          interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n+\n+          locals = ivf->locals();\n@@ -1244,14 +1331,9 @@\n-      } else if (vf->is_interpreted_frame()) {\n-        \/\/ interpreted method frame\n-        interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            locals = ivf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf->bci());\n-            methodHandle mh(THREAD, ivf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n-          }\n+        assert(bci == vf->bci(), \"wrong bci\");\n+        assert(method == vf->method(), \"wrong method\");\n+\n+        Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), bci);\n+        if (matched_jvmci_method.is_null()) {\n+          methodHandle mh(THREAD, method);\n+          JVMCIObject jvmci_method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+          matched_jvmci_method = Handle(THREAD, JNIHandles::resolve(jvmci_method.as_jobject()));\n@@ -1259,1 +1341,2 @@\n-      }\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), matched_jvmci_method());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), localIsVirtual_h());\n@@ -1261,3 +1344,0 @@\n-      \/\/ locals != NULL means that we found a matching frame and result is already partially initialized\n-      if (locals != NULL) {\n-        methods = match_methods;\n@@ -1265,1 +1345,1 @@\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()->sp());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) frame_id);\n@@ -1282,0 +1362,4 @@\n+        if (visitor_method.is_null()) {\n+          visitor_method = resolve_interface_call(HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        }\n+\n@@ -1283,1 +1367,1 @@\n-        call_interface(&result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        JavaCalls::call(&result, visitor_method, &args, CHECK_NULL);\n@@ -1287,0 +1371,6 @@\n+        if (methods == initial_methods) {\n+          methods = match_methods;\n+          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = NULL;\n+          }\n+        }\n@@ -1290,0 +1380,1 @@\n+          prev_cvf = NULL;\n@@ -1291,18 +1382,1 @@\n-          fst = StackFrameStream(thread, true \/* update *\/, true \/* process_frames *\/);\n-          while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n-            fst.next();\n-          }\n-          if (fst.current()->sp() != stack_pointer) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n-          }\n-          vf = vframe::new_vframe(fst, thread);\n-          if (!vf->is_compiled_frame()) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n-          }\n-          for (int i = 0; i < frame_number; i++) {\n-            if (vf->is_top()) {\n-              THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n-            }\n-            vf = vf->sender();\n-            assert(vf->is_compiled_frame(), \"Wrong frame type\");\n-          }\n+          resync_vframestream_to_compiled_frame(vfst, stack_pointer, frame_number, thread, CHECK_NULL);\n@@ -1310,6 +1384,0 @@\n-        frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n-        HotSpotJVMCI::HotSpotStackFrameReference::klass()->initialize(CHECK_NULL);\n-      }\n-\n-      if (vf->is_top()) {\n-        break;\n@@ -1317,2 +1385,0 @@\n-      frame_number++;\n-      vf = vf->sender();\n@@ -1320,7 +1386,0 @@\n-\n-    if (fst.is_done()) {\n-      break;\n-    }\n-    fst.next();\n-    vf = vframe::new_vframe(fst, thread);\n-    frame_number = 0;\n@@ -1425,1 +1484,1 @@\n-  while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n+  while (fst.current()->id() != stack_pointer && !fst.is_done()) {\n@@ -1428,1 +1487,1 @@\n-  if (fst.current()->sp() != stack_pointer) {\n+  if (fst.current()->id() != stack_pointer) {\n@@ -1442,1 +1501,1 @@\n-  while (fstAfterDeopt.current()->sp() != stack_pointer && !fstAfterDeopt.is_done()) {\n+  while (fstAfterDeopt.current()->id() != stack_pointer && !fstAfterDeopt.is_done()) {\n@@ -1445,1 +1504,1 @@\n-  if (fstAfterDeopt.current()->sp() != stack_pointer) {\n+  if (fstAfterDeopt.current()->id() != stack_pointer) {\n@@ -2278,1 +2337,1 @@\n-    attach_args.name = thread->name();\n+    attach_args.name = const_cast<char*>(thread->name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":176,"deletions":117,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-  do_bool_flag(UseBiasedLocking)                                           \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-      attach_args.name = thread->name();\n+      attach_args.name = const_cast<char*>(thread->name());\n@@ -317,1 +317,1 @@\n-        JavaThread* THREAD = thread->as_Java_thread(); \/\/ For exception macros.\n+        JavaThread* THREAD = JavaThread::cast(thread); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -895,0 +894,6 @@\n+\/\/ Function for redirecting shared library JavaVM fatal error data to a log file.\n+\/\/ The log file is opened on first call to this function.\n+static void _fatal_log(const char* buf, size_t count) {\n+  JVMCI::fatal_log(buf, count);\n+}\n+\n@@ -902,1 +907,2 @@\n-  fatal(\"Fatal error in JVMCI shared library\");\n+  intx current_thread_id = os::current_thread_id();\n+  fatal(\"thread \" INTX_FORMAT \": Fatal error in JVMCI shared library\", current_thread_id);\n@@ -929,1 +935,1 @@\n-    JavaVMOption options[4];\n+    JavaVMOption options[5];\n@@ -944,0 +950,2 @@\n+    options[4].optionString = (char*) \"_fatal_log\";\n+    options[4].extraInfo = (void*) _fatal_log;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+  CHECK_NOT_SET(JVMCINativeLibraryErrorFile,  EnableJVMCI)\n@@ -179,0 +180,1 @@\n+    \"JVMCINativeLibraryErrorFile\",\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define LIBJVMCI_ERR_FILE \"hs_err_pid%p_libjvmci.log\"\n+\n@@ -126,0 +128,5 @@\n+  product(ccstr, JVMCINativeLibraryErrorFile, NULL, EXPERIMENTAL,           \\\n+          \"If an error in the JVMCI native library occurs, save the \"       \\\n+          \"error data to this file\"                                         \\\n+          \"[default: .\/\" LIBJVMCI_ERR_FILE \"] (%p replaced with pid)\")      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -500,7 +499,0 @@\n-  declare_constant(CollectedHeap::Serial)                                 \\\n-  declare_constant(CollectedHeap::Parallel)                               \\\n-  declare_constant(CollectedHeap::G1)                                     \\\n-  declare_constant(CollectedHeap::Epsilon)                                \\\n-  declare_constant(CollectedHeap::Z)                                      \\\n-  declare_constant(CollectedHeap::Shenandoah)                             \\\n-                                                                          \\\n@@ -651,1 +643,0 @@\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n@@ -653,1 +644,0 @@\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -658,1 +648,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  _bin = (bucket*)_arena->AmallocWords(sizeof(bucket) * _size);\n@@ -77,1 +77,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  _bin = (bucket*)_arena->AmallocWords(sizeof(bucket) * _size);\n@@ -84,1 +84,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  _bin = (bucket*)_arena->AmallocWords(sizeof(bucket) * _size);\n@@ -90,1 +90,1 @@\n-    _bin[i]._keyvals = (void**)_arena->Amalloc_4(sizeof(void*) * _bin[i]._max * 2);\n+    _bin[i]._keyvals = (void**)_arena->AmallocWords(sizeof(void*) * _bin[i]._max * 2);\n@@ -121,1 +121,1 @@\n-    nb->_keyvals = (void**)_arena->Amalloc_4(sizeof(void* ) * nb->_max * 2);\n+    nb->_keyvals = (void**)_arena->AmallocWords(sizeof(void* ) * nb->_max * 2);\n@@ -171,1 +171,1 @@\n-      b->_keyvals = (void**)_arena->Amalloc_4(sizeof(void*) * b->_max * 2);\n+      b->_keyvals = (void**)_arena->AmallocWords(sizeof(void*) * b->_max * 2);\n","filename":"src\/hotspot\/share\/libadt\/dict.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    uint32_t* counter = _stats.add_if_absent(msg.output(), 0, &p_created);\n+    uint32_t* counter = _stats.put_if_absent(msg.output(), 0, &p_created);\n@@ -82,1 +82,1 @@\n-    _stats(17 \/*table_size*\/) {\n+    _stats() {\n@@ -98,1 +98,1 @@\n-  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+  bool do_entry(LogFileOutput* output, uint32_t& counter) {\n@@ -101,1 +101,1 @@\n-    if (*counter > 0) {\n+    if (counter > 0) {\n@@ -104,1 +104,1 @@\n-      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n@@ -107,1 +107,1 @@\n-      *counter = 0;\n+      counter = 0;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,1 +111,7 @@\n-typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+typedef ResourceHashtable<LogFileOutput*,\n+                          uint32_t,\n+                          primitive_hash<LogFileOutput*>,\n+                          primitive_equals<LogFileOutput*>,\n+                          17, \/*table_size*\/\n+                          ResourceObj::C_HEAP,\n+                          mtLogging> AsyncLogMap;\n@@ -158,2 +164,2 @@\n-  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n-  bool is_Named_thread() const override { return true; }\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n+  const char* type_name() const override { return \"AsyncLogWriter\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,1 @@\n-  void operator=(const LogMessageBuffer& ref) {}\n-  LogMessageBuffer(const LogMessageBuffer& ref) {}\n+  NONCOPYABLE(LogMessageBuffer);\n","filename":"src\/hotspot\/share\/logging\/logMessageBuffer.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  LOG_TAG(biasedlocking) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -35,0 +37,7 @@\n+\/\/ Pre-defined default chunk sizes must be arena-aligned, see Chunk::operator new()\n+STATIC_ASSERT(is_aligned((int)Chunk::tiny_size, ARENA_AMALLOC_ALIGNMENT));\n+STATIC_ASSERT(is_aligned((int)Chunk::init_size, ARENA_AMALLOC_ALIGNMENT));\n+STATIC_ASSERT(is_aligned((int)Chunk::medium_size, ARENA_AMALLOC_ALIGNMENT));\n+STATIC_ASSERT(is_aligned((int)Chunk::size, ARENA_AMALLOC_ALIGNMENT));\n+STATIC_ASSERT(is_aligned((int)Chunk::non_pool_size, ARENA_AMALLOC_ALIGNMENT));\n+\n@@ -174,7 +183,24 @@\n-void* Chunk::operator new (size_t requested_size, AllocFailType alloc_failmode, size_t length) throw() {\n-  \/\/ requested_size is equal to sizeof(Chunk) but in order for the arena\n-  \/\/ allocations to come out aligned as expected the size must be aligned\n-  \/\/ to expected arena alignment.\n-  \/\/ expect requested_size but if sizeof(Chunk) doesn't match isn't proper size we must align it.\n-  assert(ARENA_ALIGN(requested_size) == aligned_overhead_size(), \"Bad alignment\");\n-  size_t bytes = ARENA_ALIGN(requested_size) + length;\n+void* Chunk::operator new (size_t sizeofChunk, AllocFailType alloc_failmode, size_t length) throw() {\n+\n+  \/\/ - requested_size = sizeof(Chunk)\n+  \/\/ - length = payload size\n+  \/\/ We must ensure that the boundaries of the payload (C and D) are aligned to 64-bit:\n+  \/\/\n+  \/\/ +-----------+--+--------------------------------------------+\n+  \/\/ |           |g |                                            |\n+  \/\/ | Chunk     |a |               Payload                      |\n+  \/\/ |           |p |                                            |\n+  \/\/ +-----------+--+--------------------------------------------+\n+  \/\/ A           B  C                                            D\n+  \/\/\n+  \/\/ - The Chunk is allocated from C-heap, therefore its start address (A) should be\n+  \/\/   64-bit aligned on all our platforms, including 32-bit.\n+  \/\/ - sizeof(Chunk) (B) may not be aligned to 64-bit, and we have to take that into\n+  \/\/   account when calculating the Payload bottom (C) (see Chunk::bottom())\n+  \/\/ - the payload size (length) must be aligned to 64-bit, which takes care of 64-bit\n+  \/\/   aligning (D)\n+\n+  assert(sizeofChunk == sizeof(Chunk), \"weird request size\");\n+  assert(is_aligned(length, ARENA_AMALLOC_ALIGNMENT), \"chunk payload length misaligned: \"\n+         SIZE_FORMAT \".\", length);\n+  size_t bytes = ARENA_ALIGN(sizeofChunk) + length;\n@@ -191,0 +217,2 @@\n+     \/\/ We rely on arena alignment <= malloc alignment.\n+     assert(is_aligned(p, ARENA_AMALLOC_ALIGNMENT), \"Chunk start address misaligned.\");\n@@ -242,2 +270,1 @@\n-  size_t round_size = (sizeof (char *)) - 1;\n-  init_size = (init_size+round_size) & ~round_size;\n+  init_size = ARENA_ALIGN(init_size);\n@@ -340,4 +367,0 @@\n-void Arena::signal_out_of_memory(size_t sz, const char* whence) const {\n-  vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"%s\", whence);\n-}\n-\n@@ -347,1 +370,2 @@\n-  size_t len = MAX2(x, (size_t) Chunk::size);\n+  \/\/ (Note: all chunk sizes have to be 64-bit aligned)\n+  size_t len = MAX2(ARENA_ALIGN(x), (size_t) Chunk::size);\n@@ -456,1 +480,1 @@\n-  char** save = (char**)internal_malloc_4(sizeof(char*));\n+  char** save = (char**)internal_amalloc(sizeof(char*));\n@@ -459,13 +483,0 @@\n-\n-\/\/ for debugging with UseMallocOnly\n-void* Arena::internal_malloc_4(size_t x) {\n-  assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n-  check_for_overflow(x, \"Arena::internal_malloc_4\");\n-  if (_hwm + x > _max) {\n-    return grow(x);\n-  } else {\n-    char *old = _hwm;\n-    _hwm += x;\n-    return old;\n-  }\n-}\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":39,"deletions":28,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -35,8 +36,3 @@\n-\/\/ The byte alignment to be used by Arena::Amalloc.  See bugid 4169348.\n-\/\/ Note: this value must be a power of 2\n-\n-#define ARENA_AMALLOC_ALIGNMENT (2*BytesPerWord)\n-\n-#define ARENA_ALIGN_M1 (((size_t)(ARENA_AMALLOC_ALIGNMENT)) - 1)\n-#define ARENA_ALIGN_MASK (~((size_t)ARENA_ALIGN_M1))\n-#define ARENA_ALIGN(x) ((((size_t)(x)) + ARENA_ALIGN_M1) & ARENA_ALIGN_MASK)\n+\/\/ The byte alignment to be used by Arena::Amalloc.\n+#define ARENA_AMALLOC_ALIGNMENT BytesPerLong\n+#define ARENA_ALIGN(x) (align_up((x), ARENA_AMALLOC_ALIGNMENT))\n@@ -59,0 +55,1 @@\n+    \/\/ Note: please keep these constants 64-bit aligned.\n@@ -63,1 +60,1 @@\n-    slack      = 20,            \/\/ suspected sizeof(Chunk) + internal malloc headers\n+    slack      = 24,            \/\/ suspected sizeof(Chunk) + internal malloc headers\n@@ -108,1 +105,0 @@\n-  debug_only(void* internal_malloc_4(size_t x);)\n@@ -110,9 +106,8 @@\n-  void signal_out_of_memory(size_t request, const char* whence) const;\n-\n-  bool check_for_overflow(size_t request, const char* whence,\n-      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) const {\n-    if (UINTPTR_MAX - request < (uintptr_t)_hwm) {\n-      if (alloc_failmode == AllocFailStrategy::RETURN_NULL) {\n-        return false;\n-      }\n-      signal_out_of_memory(request, whence);\n+  void* internal_amalloc(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)  {\n+    assert(is_aligned(x, BytesPerWord), \"misaligned size\");\n+    if (pointer_delta(_max, _hwm, 1) >= x) {\n+      char *old = _hwm;\n+      _hwm += x;\n+      return old;\n+    } else {\n+      return grow(x, alloc_failmode);\n@@ -120,2 +115,1 @@\n-    return true;\n- }\n+  }\n@@ -139,1 +133,2 @@\n-  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n+  \/\/ Fast allocate in the arena.  Common case aligns to the size of jlong which is 64 bits\n+  \/\/ on both 32 and 64 bit platforms. Required for atomic jlong operations on 32 bits.\n@@ -141,16 +136,1 @@\n-    assert(is_power_of_2(ARENA_AMALLOC_ALIGNMENT) , \"should be a power of 2\");\n-    x = ARENA_ALIGN(x);\n-    debug_only(if (UseMallocOnly) return malloc(x);)\n-    if (!check_for_overflow(x, \"Arena::Amalloc\", alloc_failmode))\n-      return NULL;\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-  \/\/ Further assume size is padded out to words\n-  void *Amalloc_4(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+    x = ARENA_ALIGN(x);  \/\/ note for 32 bits this should align _hwm as well.\n@@ -158,9 +138,6 @@\n-    if (!check_for_overflow(x, \"Arena::Amalloc_4\", alloc_failmode))\n-      return NULL;\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n+    \/\/ Amalloc guarantees 64-bit alignment and we need to ensure that in case the preceding\n+    \/\/ allocation was AmallocWords. Only needed on 32-bit - on 64-bit Amalloc and AmallocWords are\n+    \/\/ identical.\n+    assert(is_aligned(_max, ARENA_AMALLOC_ALIGNMENT), \"chunk end unaligned?\");\n+    NOT_LP64(_hwm = ARENA_ALIGN(_hwm));\n+    return internal_amalloc(x, alloc_failmode);\n@@ -169,4 +146,4 @@\n-  \/\/ Allocate with 'double' alignment. It is 8 bytes on sparc.\n-  \/\/ In other cases Amalloc_D() should be the same as Amalloc_4().\n-  void* Amalloc_D(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+  \/\/ Allocate in the arena, assuming the size has been aligned to size of pointer, which\n+  \/\/ is 4 bytes on 32 bits, hence the name.\n+  void* AmallocWords(size_t x, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {\n+    assert(is_aligned(x, BytesPerWord), \"misaligned size\");\n@@ -174,9 +151,1 @@\n-    if (!check_for_overflow(x, \"Arena::Amalloc_D\", alloc_failmode))\n-      return NULL;\n-    if (_hwm + x > _max) {\n-      return grow(x, alloc_failmode); \/\/ grow() returns a result aligned >= 8 bytes.\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n+    return internal_amalloc(x, alloc_failmode);\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":29,"deletions":60,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  _has_been_visited.add_if_absent(ref->obj(), read_only, &created);\n+  _has_been_visited.put_if_absent(ref->obj(), read_only, &created);\n@@ -102,1 +102,1 @@\n-    if (_has_been_visited.maybe_grow(MAX_TABLE_SIZE)) {\n+    if (_has_been_visited.maybe_grow()) {\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -396,1 +396,1 @@\n-  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}\n+  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {}\n@@ -399,1 +399,2 @@\n-  KVHashtable<address, bool, mtInternal> _has_been_visited;\n+  ResizeableResourceHashtable<address, bool, ResourceObj::C_HEAP,\n+                              mtClassShared> _has_been_visited;\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    char** save = (char**)internal_malloc_4(sizeof(char*));\n+    char** save = (char**)internal_amalloc(sizeof(char*));\n","filename":"src\/hotspot\/share\/memory\/resourceArea.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-        HeapShared::open_archive_heap_region_mapped() &&\n+        HeapShared::open_regions_mapped() &&\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-void VirtualSpace::print_on(outputStream* out) {\n+void VirtualSpace::print_on(outputStream* out) const {\n@@ -1049,1 +1049,1 @@\n-void VirtualSpace::print() {\n+void VirtualSpace::print() const {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-  void print_on(outputStream* out) PRODUCT_RETURN;\n-  void print();\n+  void print_on(outputStream* out) const PRODUCT_RETURN;\n+  void print() const;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    oop archived = HeapShared::archive_heap_object(rr);\n+    oop archived = HeapShared::archive_object(rr);\n@@ -293,1 +293,1 @@\n-    \/\/ the return value of archive_heap_object here. At runtime, the\n+    \/\/ the return value of archive_object() here. At runtime, the\n@@ -350,1 +350,1 @@\n-    if (HeapShared::open_archive_heap_region_mapped() &&\n+    if (HeapShared::open_regions_mapped() &&\n@@ -373,0 +373,6 @@\n+  \/\/ Shared ConstantPools are in the RO region, so the _flags cannot be modified.\n+  \/\/ The _on_stack flag is used to prevent ConstantPools from deallocation during\n+  \/\/ class redefinition. Since shared ConstantPools cannot be deallocated anyway,\n+  \/\/ we always set _on_stack to true to avoid having to change _flags during runtime.\n+  _flags |= (_on_stack | _is_shared);\n+\n@@ -385,5 +391,0 @@\n-  \/\/ Shared ConstantPools are in the RO region, so the _flags cannot be modified.\n-  \/\/ The _on_stack flag is used to prevent ConstantPools from deallocation during\n-  \/\/ class redefinition. Since shared ConstantPools cannot be deallocated anyway,\n-  \/\/ we always set _on_stack to true to avoid having to change _flags during runtime.\n-  _flags |= (_on_stack | _is_shared);\n@@ -589,1 +590,1 @@\n-      JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+      JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-class PSPromotionManager;\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2155,1 +2155,1 @@\n-    _exception = Exceptions::new_exception(current->as_Java_thread(),\n+    _exception = Exceptions::new_exception(JavaThread::cast(current),\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -92,0 +91,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -511,6 +511,0 @@\n-\n-  \/\/ Set biased locking bit for all instances of this class; it will be\n-  \/\/ cleared if revocation occurs too often for this type\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n@@ -686,1 +680,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(this);\n+    SystemDictionaryShared::handle_class_unloading(this);\n@@ -911,0 +905,3 @@\n+        if (is_shared()) {\n+          assert(!verified_at_dump_time(), \"must be\");\n+        }\n@@ -942,1 +939,2 @@\n-      \/\/ 2) the class is loaded by built-in class loader but failed to add archived loader constraints\n+      \/\/ 2) the class is loaded by built-in class loader but failed to add archived loader constraints or\n+      \/\/ 3) the class was not verified during dump time\n@@ -944,1 +942,2 @@\n-      if (is_shared() && SystemDictionaryShared::check_linking_constraints(THREAD, this)) {\n+      if (is_shared() && verified_at_dump_time() &&\n+          SystemDictionaryShared::check_linking_constraints(THREAD, this)) {\n@@ -1628,5 +1627,0 @@\n-\n-static int compare_fields_by_offset(int* a, int* b) {\n-  return a[0] - b[0];\n-}\n-\n@@ -1640,3 +1634,0 @@\n-  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n-  int* fields_sorted = NEW_C_HEAP_ARRAY(int, 2*(length+1), mtClass);\n-  int j = 0;\n@@ -1646,3 +1637,1 @@\n-      fields_sorted[j + 0] = fd.offset();\n-      fields_sorted[j + 1] = i;\n-      j += 2;\n+      cl->do_field(&fd);\n@@ -1651,2 +1640,28 @@\n-  if (j > 0) {\n-    length = j;\n+}\n+\n+\/\/ first in Pair is offset, second is index.\n+static int compare_fields_by_offset(Pair<int,int>* a, Pair<int,int>* b) {\n+  return a->first - b->first;\n+}\n+\n+void InstanceKlass::print_nonstatic_fields(FieldClosure* cl) {\n+  InstanceKlass* super = superklass();\n+  if (super != NULL) {\n+    super->print_nonstatic_fields(cl);\n+  }\n+  ResourceMark rm;\n+  fieldDescriptor fd;\n+  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n+  GrowableArray<Pair<int,int> > fields_sorted;\n+  int i = 0;\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static()) {\n+      fd = fs.field_descriptor();\n+      Pair<int,int> f(fs.offset(), fs.index());\n+      fields_sorted.push(f);\n+      i++;\n+    }\n+  }\n+  if (i > 0) {\n+    int length = i;\n+    assert(length == fields_sorted.length(), \"duh\");\n@@ -1654,4 +1669,4 @@\n-    qsort(fields_sorted, length\/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);\n-    for (int i = 0; i < length; i += 2) {\n-      fd.reinitialize(this, fields_sorted[i + 1]);\n-      assert(!fd.is_static() && fd.offset() == fields_sorted[i], \"only nonstatic fields\");\n+    fields_sorted.sort(compare_fields_by_offset);\n+    for (int i = 0; i < length; i++) {\n+      fd.reinitialize(this, fields_sorted.at(i).second);\n+      assert(!fd.is_static() && fd.offset() == fields_sorted.at(i).first, \"only nonstatic fields\");\n@@ -1661,1 +1676,0 @@\n-  FREE_C_HEAP_ARRAY(int, fields_sorted);\n@@ -1664,1 +1678,0 @@\n-\n@@ -2405,1 +2418,2 @@\n-  if (can_be_verified_at_dumptime()) {\n+  if (is_linked()) {\n+    assert(can_be_verified_at_dumptime(), \"must be\");\n@@ -2533,5 +2547,0 @@\n-  \/\/ Initialize current biased locking state.\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    set_prototype_header(markWord::biased_locking_prototype());\n-  }\n-\n@@ -2541,1 +2550,0 @@\n-    set_prototype_header(markWord::prototype());\n@@ -2616,1 +2624,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(ik);\n+    SystemDictionaryShared::handle_class_unloading(ik);\n@@ -3447,1 +3455,1 @@\n-  ik->do_nonstatic_fields(&print_nonstatic_field);\n+  ik->print_nonstatic_fields(&print_nonstatic_field);\n@@ -3489,1 +3497,0 @@\n-      if (!WizardMode)  return;  \/\/ that is enough\n@@ -3495,1 +3502,1 @@\n-  do_nonstatic_fields(&print_field);\n+  print_nonstatic_fields(&print_field);\n@@ -3501,10 +3508,0 @@\n-    Klass* mirrored_klass = java_lang_Class::as_Klass(obj);\n-    st->print(BULLET\"fake entry for mirror: \");\n-    Metadata::print_value_on_maybe_null(st, mirrored_klass);\n-    st->cr();\n-    Klass* array_klass = java_lang_Class::array_klass_acquire(obj);\n-    st->print(BULLET\"fake entry for array: \");\n-    Metadata::print_value_on_maybe_null(st, array_klass);\n-    st->cr();\n-    st->print_cr(BULLET\"fake entry for oop_size: %d\", java_lang_Class::oop_size(obj));\n-    st->print_cr(BULLET\"fake entry for static_oop_field_count: %d\", java_lang_Class::static_oop_field_count(obj));\n@@ -3513,0 +3510,1 @@\n+      st->print_cr(BULLET\"---- static fields (%d words):\", java_lang_Class::static_oop_field_count(obj));\n@@ -3627,1 +3625,1 @@\n-        current->as_Java_thread()->security_get_caller_class(1):\n+        JavaThread::cast(current)->security_get_caller_class(1):\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":49,"deletions":51,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1010,0 +1010,1 @@\n+  void print_nonstatic_fields(FieldClosure* cl); \/\/ including inherited and injected fields\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-                           _prototype_header(markWord::prototype()),\n@@ -526,3 +525,8 @@\n-  it->push((Klass**)&_subklass);\n-  it->push((Klass**)&_next_sibling);\n-  it->push(&_next_link);\n+  if (!Arguments::is_dumping_archive()) {\n+    \/\/ If dumping archive, these may point to excluded classes. There's no need\n+    \/\/ to follow these pointers anyway, as they will be set to NULL in\n+    \/\/ remove_unshareable_info().\n+    it->push((Klass**)&_subklass);\n+    it->push((Klass**)&_next_sibling);\n+    it->push(&_next_link);\n+  }\n@@ -603,1 +607,1 @@\n-    if (HeapShared::open_archive_heap_region_mapped()) {\n+    if (HeapShared::open_regions_mapped()) {\n@@ -715,4 +719,0 @@\n-int Klass::atomic_incr_biased_lock_revocation_count() {\n-  return (int) Atomic::add(&_biased_lock_revocation_count, 1);\n-}\n-\n@@ -747,2 +747,0 @@\n-     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -162,6 +162,0 @@\n-  \/\/ Biased locking implementation and statistics\n-  \/\/ (the 64-bit chunk goes first, to avoid some fragmentation)\n-  jlong    _last_biased_lock_bulk_revocation_time;\n-  markWord _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n-  jint     _biased_lock_revocation_count;\n-\n@@ -648,24 +642,0 @@\n-  \/\/ Biased locking support\n-  \/\/ Note: the prototype header is always set up to be at least the\n-  \/\/ prototype markWord. If biased locking is enabled it may further be\n-  \/\/ biasable and have an epoch.\n-  markWord prototype_header() const      { return _prototype_header; }\n-\n-  \/\/ NOTE: once instances of this klass are floating around in the\n-  \/\/ system, this header must only be updated at a safepoint.\n-  \/\/ NOTE 2: currently we only ever set the prototype header to the\n-  \/\/ biasable prototype for instanceKlasses. There is no technical\n-  \/\/ reason why it could not be done for arrayKlasses aside from\n-  \/\/ wanting to reduce the initial scope of this optimization. There\n-  \/\/ are potential problems in setting the bias pattern for\n-  \/\/ JVM-internal oops.\n-  inline void set_prototype_header(markWord header);\n-  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n-\n-  int  biased_lock_revocation_count() const { return (int) _biased_lock_revocation_count; }\n-  \/\/ Atomically increments biased_lock_revocation_count and returns updated value\n-  int atomic_incr_biased_lock_revocation_count();\n-  void set_biased_lock_revocation_count(int val) { _biased_lock_revocation_count = (jint) val; }\n-  jlong last_biased_lock_bulk_revocation_time() { return _last_biased_lock_bulk_revocation_time; }\n-  void  set_last_biased_lock_bulk_revocation_time(jlong cur_time) { _last_biased_lock_bulk_revocation_time = cur_time; }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-inline void Klass::set_prototype_header(markWord header) {\n-  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n-  _prototype_header = header;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,1 @@\n-    \/\/ Biased bit is 3rd rightmost bit\n-    if (is_neutral()) {   \/\/ last bits = 001\n+    if (is_neutral()) {   \/\/ last bits = 01\n@@ -91,4 +90,0 @@\n-    } else if (has_bias_pattern()) {  \/\/ last bits = 101\n-      st->print(\"is_biased\");\n-      JavaThread* jt = biased_locker();\n-      st->print(\" biased_locker=\" INTPTR_FORMAT \" epoch=%d\", p2i(jt), bias_epoch());\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,1 @@\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n@@ -44,2 +43,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n@@ -52,28 +50,0 @@\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n@@ -83,1 +53,1 @@\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [header          | 01]  unlocked           regular object header\n@@ -131,2 +101,2 @@\n-  static const int biased_lock_bits               = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;\n+  static const int first_unused_gap_bits          = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n@@ -134,2 +104,1 @@\n-  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n-  static const int epoch_bits                     = 2;\n+  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n@@ -137,2 +106,0 @@\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n@@ -140,5 +107,2 @@\n-  static const int biased_lock_shift              = lock_bits;\n-  static const int age_shift                      = lock_bits + biased_lock_bits;\n-  static const int unused_gap_shift               = age_shift + age_bits;\n-  static const int hash_shift                     = unused_gap_shift + unused_gap_bits;\n-  static const int epoch_shift                    = hash_shift;\n+  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n+  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n@@ -148,3 +112,0 @@\n-  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);\n-  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift;\n-  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift;\n@@ -153,3 +114,0 @@\n-  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);\n-  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\n-\n@@ -159,3 +117,0 @@\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  static const size_t biased_lock_alignment       = 2 << (epoch_shift + epoch_bits);\n-\n@@ -166,1 +121,0 @@\n-  static const uintptr_t biased_lock_pattern      = 5;\n@@ -174,2 +128,0 @@\n-  static const int max_bias_epoch                 = epoch_mask;\n-\n@@ -179,38 +131,0 @@\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markWord set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markWord incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markWord biased_locking_prototype() {\n-    return markWord( biased_lock_pattern );\n-  }\n-\n@@ -222,1 +136,1 @@\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n@@ -227,1 +141,3 @@\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+  bool is_neutral()  const {\n+    return (mask_bits(value(), lock_mask_in_place) == unlocked_value);\n+  }\n@@ -242,1 +158,3 @@\n-  inline bool must_be_preserved(const oopDesc* obj) const;\n+  bool must_be_preserved(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -246,16 +164,3 @@\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n+  bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n+    return (!is_unlocked() || !has_no_hash());\n+  }\n@@ -308,7 +213,0 @@\n-  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n-    uintptr_t tmp = (uintptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return markWord(tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n@@ -344,3 +242,0 @@\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markWord prototype_for_klass(const Klass* klass);\n-\n@@ -354,1 +249,1 @@\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() { return (void*)clear_lock_bits().value(); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":125,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n-#define SHARE_OOPS_MARKWORD_INLINE_HPP\n-\n-#include \"oops\/markWord.hpp\"\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    if (has_bias_pattern()) {\n-      \/\/ Will reset bias at end of collection\n-      \/\/ Mark words of biased and currently locked objects are preserved separately\n-      return false;\n-    }\n-    markWord prototype_header = prototype_for_klass(obj->klass());\n-    if (prototype_header.has_bias_pattern()) {\n-      \/\/ Individual instance which has its bias revoked; must return\n-      \/\/ true for correctness\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure during scavenge?\n-inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n-  if (UseBiasedLocking) {\n-    \/\/ We don't explicitly save off the mark words of biased and\n-    \/\/ currently-locked objects during scavenges, so if during a\n-    \/\/ promotion failure we encounter either a biased mark word or a\n-    \/\/ klass which still has a biasable prototype header, we have to\n-    \/\/ preserve the mark word. This results in oversaving, but promotion\n-    \/\/ failures are rare, and this avoids adding more complex logic to\n-    \/\/ the scavengers to call new variants of\n-    \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-    \/\/ of a scavenge when a promotion failure has first been detected.\n-    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-inline markWord markWord::prototype_for_klass(const Klass* klass) {\n-  markWord prototype_header = klass->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-\n-  return prototype_header;\n-}\n-\n-#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -616,1 +616,1 @@\n-    JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+    JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n@@ -2257,1 +2257,1 @@\n-  if (o == NULL || o == JNIMethodBlock::_free_method || !((Metadata*)o)->is_method()) {\n+  if (o == NULL || o == JNIMethodBlock::_free_method) {\n@@ -2260,1 +2260,6 @@\n-  return o;\n+  \/\/ Method should otherwise be valid. Assert for testing.\n+  assert(is_valid_method(o), \"should be valid jmethodid\");\n+  \/\/ If the method's class holder object is unreferenced, but not yet marked as\n+  \/\/ unloaded, we need to return NULL here too because after a safepoint, its memory\n+  \/\/ will be reclaimed.\n+  return o->method_holder()->is_loader_alive() ? o : NULL;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/heapShared.inline.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -221,1 +222,1 @@\n-  assert(!HeapShared::is_archived_object(forwardee) && !HeapShared::is_archived_object(this),\n+  assert(!Universe::heap()->is_archived_object(forwardee) && !Universe::heap()->is_archived_object(this),\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  inline markWord  mark_acquire()  const;\n@@ -236,1 +237,0 @@\n-  inline bool has_bias_pattern() const;\n@@ -286,2 +286,0 @@\n-  \/\/ NOTE with the introduction of UseBiasedLocking that identity_hash() might reach a\n-  \/\/ safepoint if called on a biased object. Calling code must be aware of that.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -52,0 +52,5 @@\n+markWord oopDesc::mark_acquire() const {\n+  uintptr_t v = HeapAccess<MO_ACQUIRE>::load_at(as_oop(), mark_offset_in_bytes());\n+  return markWord(v);\n+}\n+\n@@ -78,1 +83,1 @@\n-  set_mark(markWord::prototype_for_klass(klass()));\n+  set_mark(markWord::prototype());\n@@ -257,4 +262,0 @@\n-bool oopDesc::has_bias_pattern() const {\n-  return mark().has_bias_pattern();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  address res = (address)arena->Amalloc_4(alloc_size);\n+  address res = (address)arena->AmallocWords(alloc_size);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-    unsigned addr_bits = (unsigned)((uintptr_t)this >> (LogMinObjAlignmentInBytes + 3));\n+    unsigned addr_bits = (unsigned)((uintptr_t)this >> (LogBytesPerWord + 3));\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-  return t->object_size();\n+  return t->object_size(this);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  inline int object_size();\n+  inline int object_size(const TypeArrayKlass* tk) const;\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-int typeArrayOopDesc::object_size() {\n-  TypeArrayKlass* tk = TypeArrayKlass::cast(klass());\n+int typeArrayOopDesc::object_size(const TypeArrayKlass* tk) const {\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -324,0 +324,34 @@\n+  \/\/ Associative\n+  if (op1 == Op_MulI && op2 == Op_MulI) {\n+    Node* add_in1 = NULL;\n+    Node* add_in2 = NULL;\n+    Node* mul_in = NULL;\n+\n+    if (in1->in(1) == in2->in(1)) {\n+      \/\/ Convert \"a*b+a*c into a*(b+c)\n+      add_in1 = in1->in(2);\n+      add_in2 = in2->in(2);\n+      mul_in = in1->in(1);\n+    } else if (in1->in(2) == in2->in(1)) {\n+      \/\/ Convert a*b+b*c into b*(a+c)\n+      add_in1 = in1->in(1);\n+      add_in2 = in2->in(2);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(2) == in2->in(2)) {\n+      \/\/ Convert a*c+b*c into (a+b)*c\n+      add_in1 = in1->in(1);\n+      add_in2 = in2->in(1);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(1) == in2->in(2)) {\n+      \/\/ Convert a*b+c*a into a*(b+c)\n+      add_in1 = in1->in(2);\n+      add_in2 = in2->in(1);\n+      mul_in = in1->in(1);\n+    }\n+\n+    if (mul_in != NULL) {\n+      Node* add = phase->transform(new AddINode(add_in1, add_in2));\n+      return new MulINode(mul_in, add);\n+    }\n+  }\n+\n@@ -472,0 +506,34 @@\n+  \/\/ Associative\n+  if (op1 == Op_MulL && op2 == Op_MulL) {\n+    Node* add_in1 = NULL;\n+    Node* add_in2 = NULL;\n+    Node* mul_in = NULL;\n+\n+    if (in1->in(1) == in2->in(1)) {\n+      \/\/ Convert \"a*b+a*c into a*(b+c)\n+      add_in1 = in1->in(2);\n+      add_in2 = in2->in(2);\n+      mul_in = in1->in(1);\n+    } else if (in1->in(2) == in2->in(1)) {\n+      \/\/ Convert a*b+b*c into b*(a+c)\n+      add_in1 = in1->in(1);\n+      add_in2 = in2->in(2);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(2) == in2->in(2)) {\n+      \/\/ Convert a*c+b*c into (a+b)*c\n+      add_in1 = in1->in(1);\n+      add_in2 = in2->in(1);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(1) == in2->in(2)) {\n+      \/\/ Convert a*b+c*a into a*(b+c)\n+      add_in1 = in1->in(2);\n+      add_in2 = in2->in(1);\n+      mul_in = in1->in(1);\n+    }\n+\n+    if (mul_in != NULL) {\n+      Node* add = phase->transform(new AddLNode(add_in1, add_in2));\n+      return new MulLNode(mul_in, add);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -469,2 +469,5 @@\n-          if( OptoReg::is_valid(first) ) set_live_bit(tmp_live,first);\n-          if( OptoReg::is_valid(second) ) set_live_bit(tmp_live,second);\n+          \/\/If peephole had removed the node,do not set live bit for it.\n+          if (!(def->is_Mach() && def->as_Mach()->get_removed())) {\n+            if (OptoReg::is_valid(first)) set_live_bit(tmp_live,first);\n+            if (OptoReg::is_valid(second)) set_live_bit(tmp_live,second);\n+          }\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -290,7 +290,11 @@\n-  develop_pd(intx, FLOATPRESSURE,                                           \\\n-          \"Number of float LRG's that constitute high register pressure\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  develop_pd(intx, INTPRESSURE,                                             \\\n-          \"Number of integer LRG's that constitute high register pressure\") \\\n-          range(0, max_jint)                                                \\\n+  develop(intx, FLOATPRESSURE, -1,                                          \\\n+          \"Number of float LRG's that constitute high register pressure.\"   \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"float register for allocation\")                                  \\\n+          range(-1, max_jint)                                               \\\n+                                                                            \\\n+  develop(intx, INTPRESSURE, -1,                                            \\\n+          \"Number of integer LRG's that constitute high register pressure.\" \\\n+          \"-1: means the threshold is determined by number of available \"   \\\n+          \"integer register for allocation\")                                \\\n+          range(-1, max_jint)                                               \\\n@@ -451,4 +455,0 @@\n-  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n-          \"(Deprecated) Print per-lock-site statistics of biased locking \"  \\\n-          \"in JVM\")                                                         \\\n-                                                                            \\\n@@ -510,3 +510,0 @@\n-  product(bool, UseOptoBiasInlining, true,                                  \\\n-          \"(Deprecated) Generate biased locking code in C2 ideal graph\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1679,7 +1679,1 @@\n-  if (UseBiasedLocking && Opcode() == Op_Allocate) {\n-    Node* klass_node = in(AllocateNode::KlassNode);\n-    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n-    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n-  } else {\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n-  }\n+  mark_node = phase->MakeConX(markWord::prototype().value());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -213,4 +213,4 @@\n-  , _sched_int_pressure(0, INTPRESSURE)\n-  , _sched_float_pressure(0, FLOATPRESSURE)\n-  , _scratch_int_pressure(0, INTPRESSURE)\n-  , _scratch_float_pressure(0, FLOATPRESSURE)\n+  , _sched_int_pressure(0, Matcher::int_pressure_limit())\n+  , _sched_float_pressure(0, Matcher::float_pressure_limit())\n+  , _scratch_int_pressure(0, Matcher::int_pressure_limit())\n+  , _scratch_float_pressure(0, Matcher::float_pressure_limit())\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -532,7 +532,0 @@\n-  if (env()->jvmti_can_post_on_exceptions()) {\n-    \/\/ check if we must post exception events, take uncommon trap if so\n-    uncommon_trap_if_should_post_on_exceptions(reason, must_throw);\n-    \/\/ here if should_post_on_exceptions is false\n-    \/\/ continue on with the normal codegen\n-  }\n-\n@@ -601,0 +594,7 @@\n+      if (env()->jvmti_can_post_on_exceptions()) {\n+        \/\/ check if we must post exception events, take uncommon trap if so\n+        uncommon_trap_if_should_post_on_exceptions(reason, must_throw);\n+        \/\/ here if should_post_on_exceptions is false\n+        \/\/ continue on with the normal codegen\n+      }\n+\n@@ -3527,4 +3527,0 @@\n-  if (UseBiasedLocking && PrintPreciseBiasedLockingStatistics) {\n-    \/\/ Create the counters for this fast lock.\n-    flock->create_lock_counter(sync_jvms()); \/\/ sync_jvms used to get current bci\n-  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -859,2 +859,2 @@\n-    Pressure int_pressure(last_inst + 1, INTPRESSURE);\n-    Pressure float_pressure(last_inst + 1, FLOATPRESSURE);\n+    Pressure int_pressure(last_inst + 1, Matcher::int_pressure_limit());\n+    Pressure float_pressure(last_inst + 1, Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  char *mem = (char*)arena()->Amalloc_4(sizeof(BitBlock) *\n+  char *mem = (char*)arena()->AmallocWords(sizeof(BitBlock) *\n@@ -236,1 +236,1 @@\n-      (IndexSet::BitBlock**) arena()->Amalloc_4(sizeof(IndexSet::BitBlock**) * _max_blocks);\n+      (IndexSet::BitBlock**) arena()->AmallocWords(sizeof(IndexSet::BitBlock**) * _max_blocks);\n@@ -266,1 +266,1 @@\n-    _blocks = (IndexSet::BitBlock**) arena()->Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);\n+    _blocks = (IndexSet::BitBlock**) arena()->AmallocWords(sizeof(IndexSet::BitBlock*) * _max_blocks);\n@@ -291,1 +291,1 @@\n-    _blocks = (IndexSet::BitBlock**) arena->Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);\n+    _blocks = (IndexSet::BitBlock**) arena->AmallocWords(sizeof(IndexSet::BitBlock*) * _max_blocks);\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1079,5 +1079,4 @@\n-    uint float_pressure = Matcher::float_pressure(FLOATPRESSURE);\n-    _regalloc->_sched_int_pressure.init(INTPRESSURE);\n-    _regalloc->_sched_float_pressure.init(float_pressure);\n-    _regalloc->_scratch_int_pressure.init(INTPRESSURE);\n-    _regalloc->_scratch_float_pressure.init(float_pressure);\n+    _regalloc->_sched_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_sched_float_pressure.init(Matcher::float_pressure_limit());\n+    _regalloc->_scratch_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_scratch_float_pressure.init(Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3815,1 +3815,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n@@ -6418,1 +6418,1 @@\n-  assert(callee()->signature()->size() == 6, \"base64_decodeBlock has 6 parameters\");\n+  assert(callee()->signature()->size() == 7, \"base64_decodeBlock has 7 parameters\");\n@@ -6430,0 +6430,1 @@\n+  Node* isMIME = argument(7);\n@@ -6442,1 +6443,1 @@\n-                                 src_start, src_offset, len, dest_start, dest_offset, isURL);\n+                                 src_start, src_offset, len, dest_start, dest_offset, isURL, isMIME);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -161,9 +161,0 @@\n-\/\/\n-\/\/ Create a counter which counts the number of times this lock is acquired\n-\/\/\n-void FastLockNode::create_lock_counter(JVMState* state) {\n-  BiasedLockingNamedCounter* blnc = (BiasedLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::BiasedLockingCounter);\n-  _counters = blnc->counters();\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class BiasedLockingCounters;\n@@ -77,1 +76,0 @@\n-  BiasedLockingCounters*        _counters;\n@@ -85,1 +83,0 @@\n-    _counters = NULL;\n@@ -102,1 +99,0 @@\n-  void create_lock_counter(JVMState* s);\n@@ -104,1 +100,0 @@\n-  BiasedLockingCounters*        counters() const { return _counters; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -882,0 +882,2 @@\n+  const int stride_con = cl->stride_con();\n+\n@@ -883,1 +885,5 @@\n-  if (abs(cl->stride_con()) > (1<<2)*future_unroll_cnt) return false;\n+  const int initial_stride_sz = MAX2(1<<2, Matcher::max_vector_size(T_BYTE) \/ 2);\n+  \/\/ Maximum stride size should protect against overflow, when doubling stride unroll_count times\n+  const int max_stride_size = MIN2<int>(max_jint \/ 2 - 2, initial_stride_sz * future_unroll_cnt);\n+  \/\/ No abs() use; abs(min_jint) = min_jint\n+  if (stride_con < -max_stride_size || stride_con > max_stride_size) return false;\n@@ -909,1 +915,0 @@\n-  int stride_con = cl->stride_con();\n@@ -2008,2 +2013,2 @@\n-  assert(old_trip_count > 1 &&\n-      (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n+  assert(old_trip_count > 1 && (!adjust_min_trip || stride_p <=\n+    MIN2<int>(max_jint \/ 2 - 2, MAX2(1<<3, Matcher::max_vector_size(T_BYTE)) * loop_head->unrolled_count())), \"sanity\");\n@@ -3365,0 +3370,1 @@\n+      return false; \/\/ need to recalculate idom data\n@@ -3383,1 +3389,1 @@\n-      return true;\n+      return false; \/\/ need to recalculate idom data\n@@ -3496,0 +3502,1 @@\n+        return false; \/\/ need to recalculate idom data\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class BiasedLockingCounters;\n@@ -68,1 +67,1 @@\n-    return C->node_arena()->Amalloc_D(x);\n+    return C->node_arena()->AmallocWords(x);\n@@ -208,0 +207,3 @@\n+private:\n+  bool _removed = false;\n+\n@@ -376,0 +378,2 @@\n+  void set_removed() { _removed = true; }\n+  bool get_removed() { return _removed; }\n@@ -798,1 +802,0 @@\n-  BiasedLockingCounters*        _counters;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2168,80 +2168,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/*\n-     *  See the full description in MacroAssembler::biased_locking_enter().\n-     *\n-     *  if( (mark_word & biased_lock_mask) == biased_lock_pattern ) {\n-     *    \/\/ The object is biased.\n-     *    proto_node = klass->prototype_header;\n-     *    o_node = thread | proto_node;\n-     *    x_node = o_node ^ mark_word;\n-     *    if( (x_node & ~age_mask) == 0 ) { \/\/ Biased to the current thread ?\n-     *      \/\/ Done.\n-     *    } else {\n-     *      if( (x_node & biased_lock_mask) != 0 ) {\n-     *        \/\/ The klass's prototype header is no longer biased.\n-     *        cas(&mark_word, mark_word, proto_node)\n-     *        goto cas_lock;\n-     *      } else {\n-     *        \/\/ The klass's prototype header is still biased.\n-     *        if( (x_node & epoch_mask) != 0 ) { \/\/ Expired epoch?\n-     *          old = mark_word;\n-     *          new = o_node;\n-     *        } else {\n-     *          \/\/ Different thread or anonymous biased.\n-     *          old = mark_word & (epoch_mask | age_mask | biased_lock_mask);\n-     *          new = thread | old;\n-     *        }\n-     *        \/\/ Try to rebias.\n-     *        if( cas(&mark_word, old, new) == 0 ) {\n-     *          \/\/ Done.\n-     *        } else {\n-     *          goto slow_path; \/\/ Failed.\n-     *        }\n-     *      }\n-     *    }\n-     *  } else {\n-     *    \/\/ The object is not biased.\n-     *    cas_lock:\n-     *    if( FastLock(obj) == 0 ) {\n-     *      \/\/ Done.\n-     *    } else {\n-     *      slow_path:\n-     *      OptoRuntime::complete_monitor_locking_Java(obj);\n-     *    }\n-     *  }\n-     *\/\n-\n-    region  = new RegionNode(5);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    Node* fast_lock_region  = new RegionNode(3);\n-    Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ First, check mark word for the biased lock pattern.\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-\n-    \/\/ Get fast path - mark word has the biased lock pattern.\n-    ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern, true);\n-    \/\/ fast_lock_region->in(1) is set to slow path.\n-    fast_lock_mem_phi->init_req(1, mem);\n-\n-    \/\/ Now check that the lock is biased to the current thread and has\n-    \/\/ the same epoch and bias as Klass::_prototype_header.\n-\n-    \/\/ Special-case a fresh allocation to avoid building nodes:\n-    Node* klass_node = AllocateNode::Ideal_klass(obj, &_igvn);\n-    if (klass_node == NULL) {\n-      Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n-      klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)->is_ptr()));\n-#ifdef _LP64\n-      if (UseCompressedClassPointers && klass_node->is_DecodeNKlass()) {\n-        assert(klass_node->in(1)->Opcode() == Op_LoadNKlass, \"sanity\");\n-        klass_node->in(1)->init_req(0, ctrl);\n-      } else\n-#endif\n-      klass_node->init_req(0, ctrl);\n-    }\n-    Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X->basic_type());\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -2249,109 +2172,3 @@\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));\n-    Node* x_node = transform_later(new XorXNode(o_node, mark_node));\n-\n-    \/\/ Get slow path - mark word does NOT match the value.\n-    STATIC_ASSERT(markWord::age_mask_in_place <= INT_MAX);\n-    Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,\n-                                      (~(int)markWord::age_mask_in_place), 0);\n-    \/\/ region->in(3) is set to fast path - the object is biased to the current thread.\n-    mem_phi->init_req(3, mem);\n-\n-\n-    \/\/ Mark word does NOT match the value (thread | Klass::_prototype_header).\n-\n-\n-    \/\/ First, check biased pattern.\n-    \/\/ Get fast path - _prototype_header has the same biased lock pattern.\n-    ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,\n-                          markWord::biased_lock_mask_in_place, 0, true);\n-\n-    not_biased_ctrl = fast_lock_region->in(2); \/\/ Slow path\n-    \/\/ fast_lock_region->in(2) - the prototype header is no longer biased\n-    \/\/ and we have to revoke the bias on this object.\n-    \/\/ We are going to try to reset the mark of this object to the prototype\n-    \/\/ value and fall through to the CAS-based locking scheme.\n-    Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n-    Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,\n-                                          proto_node, mark_node);\n-    transform_later(cas);\n-    Node* proj = transform_later(new SCMemProjNode(cas));\n-    fast_lock_mem_phi->init_req(2, proj);\n-\n-\n-    \/\/ Second, check epoch bits.\n-    Node* rebiased_region  = new RegionNode(3);\n-    Node* old_phi = new PhiNode( rebiased_region, TypeX_X);\n-    Node* new_phi = new PhiNode( rebiased_region, TypeX_X);\n-\n-    \/\/ Get slow path - mark word does NOT match epoch bits.\n-    Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,\n-                                      markWord::epoch_mask_in_place, 0);\n-    \/\/ The epoch of the current bias is not valid, attempt to rebias the object\n-    \/\/ toward the current thread.\n-    rebiased_region->init_req(2, epoch_ctrl);\n-    old_phi->init_req(2, mark_node);\n-    new_phi->init_req(2, o_node);\n-\n-    \/\/ rebiased_region->in(1) is set to fast path.\n-    \/\/ The epoch of the current bias is still valid but we know\n-    \/\/ nothing about the owner; it might be set or it might be clear.\n-    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place |\n-                             markWord::epoch_mask_in_place);\n-    Node* old = transform_later(new AndXNode(mark_node, cmask));\n-    cast_thread = transform_later(new CastP2XNode(ctrl, thread));\n-    Node* new_mark = transform_later(new OrXNode(cast_thread, old));\n-    old_phi->init_req(1, old);\n-    new_phi->init_req(1, new_mark);\n-\n-    transform_later(rebiased_region);\n-    transform_later(old_phi);\n-    transform_later(new_phi);\n-\n-    \/\/ Try to acquire the bias of the object using an atomic operation.\n-    \/\/ If this fails we will go in to the runtime to revoke the object's bias.\n-    cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);\n-    transform_later(cas);\n-    proj = transform_later(new SCMemProjNode(cas));\n-\n-    \/\/ Get slow path - Failed to CAS.\n-    not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);\n-    mem_phi->init_req(4, proj);\n-    \/\/ region->in(4) is set to fast path - the object is rebiased to the current thread.\n-\n-    \/\/ Failed to CAS.\n-    slow_path  = new RegionNode(3);\n-    Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    slow_path->init_req(1, not_biased_ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(1, proj);\n-\n-    \/\/ Call CAS-based locking scheme (FastLock node).\n-\n-    transform_later(fast_lock_region);\n-    transform_later(fast_lock_mem_phi);\n-\n-    \/\/ Get slow path - FastLock failed to lock the object.\n-    ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, fast_lock_mem_phi);\n-    \/\/ region->in(2) is set to fast path - the object is locked to the current thread.\n-\n-    slow_path->init_req(2, ctrl); \/\/ Capture slow-control\n-    slow_mem->init_req(2, fast_lock_mem_phi);\n-\n-    transform_later(slow_path);\n-    transform_later(slow_mem);\n-    \/\/ Reset lock's memory edge.\n-    lock->set_req(TypeFunc::Memory, slow_mem);\n-\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-\n-    \/\/ Optimize test; set region slot 2\n-    slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n-    mem_phi->init_req(2, mem);\n-  }\n+  \/\/ Optimize test; set region slot 2\n+  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  mem_phi->init_req(2, mem);\n@@ -2407,17 +2224,3 @@\n-  if (UseOptoBiasInlining) {\n-    \/\/ Check for biased locking unlock case, which is a no-op.\n-    \/\/ See the full description in MacroAssembler::biased_locking_exit().\n-    region  = new RegionNode(4);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-    mem_phi->init_req(3, mem);\n-\n-    Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    ctrl = opt_bits_test(ctrl, region, 3, mark_node,\n-                         markWord::biased_lock_mask_in_place,\n-                         markWord::biased_lock_pattern);\n-  } else {\n-    region  = new RegionNode(3);\n-    \/\/ create a Phi for the memory state\n-    mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n-  }\n+  region  = new RegionNode(3);\n+  \/\/ create a Phi for the memory state\n+  mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":9,"deletions":206,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);\n+  RegMask *rms = (RegMask*)C->comp_arena()->AmallocWords(sizeof(RegMask) * NOF_STACK_MASKS);\n@@ -2641,1 +2641,1 @@\n-      } else if (is_generic_reg2reg_move(def->as_Mach())) {\n+      } else if (is_reg2reg_move(def->as_Mach())) {\n@@ -2667,3 +2667,0 @@\n-  if (C->max_vector_size() == 0) {\n-    return; \/\/ no vector instructions or operands\n-  }\n@@ -2678,1 +2675,1 @@\n-      if (Matcher::is_generic_reg2reg_move(m)) {\n+      if (Matcher::is_reg2reg_move(m)) {\n@@ -2692,0 +2689,33 @@\n+uint Matcher::vector_length(const Node* n) {\n+  const TypeVect* vt = n->bottom_type()->is_vect();\n+  return vt->length();\n+}\n+\n+uint Matcher::vector_length(const MachNode* use, const MachOper* opnd) {\n+  int def_idx = use->operand_index(opnd);\n+  Node* def = use->in(def_idx);\n+  return def->bottom_type()->is_vect()->length();\n+}\n+\n+uint Matcher::vector_length_in_bytes(const Node* n) {\n+  const TypeVect* vt = n->bottom_type()->is_vect();\n+  return vt->length_in_bytes();\n+}\n+\n+uint Matcher::vector_length_in_bytes(const MachNode* use, const MachOper* opnd) {\n+  uint def_idx = use->operand_index(opnd);\n+  Node* def = use->in(def_idx);\n+  return def->bottom_type()->is_vect()->length_in_bytes();\n+}\n+\n+BasicType Matcher::vector_element_basic_type(const Node* n) {\n+  const TypeVect* vt = n->bottom_type()->is_vect();\n+  return vt->element_basic_type();\n+}\n+\n+BasicType Matcher::vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+  int def_idx = use->operand_index(opnd);\n+  Node* def = use->in(def_idx);\n+  return def->bottom_type()->is_vect()->element_basic_type();\n+}\n+\n@@ -2701,1 +2731,1 @@\n-        assert(!Matcher::is_generic_reg2reg_move(m), \"no MoveVec nodes allowed\");\n+        assert(!Matcher::is_reg2reg_move(m), \"no MoveVec nodes allowed\");\n@@ -2770,3 +2800,1 @@\n-    \/\/ With biased locking we're no longer guaranteed that a monitor\n-    \/\/ enter operation contains a serializing instruction.\n-    if ((xop == Op_FastLock) && !UseBiasedLocking) {\n+    if (xop == Op_FastLock) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+  \/\/ Number of integer live ranges that constitute high register pressure\n+  static uint int_pressure_limit();\n+  \/\/ Number of float live ranges that constitute high register pressure\n+  static uint float_pressure_limit();\n@@ -331,3 +335,0 @@\n-  \/\/ Some uarchs have different sized float register resources\n-  static const int float_pressure(int default_pressure_threshold);\n-\n@@ -351,0 +352,12 @@\n+  \/\/ Vector length\n+  static uint vector_length(const Node* n);\n+  static uint vector_length(const MachNode* use, const MachOper* opnd);\n+\n+  \/\/ Vector length in bytes\n+  static uint vector_length_in_bytes(const Node* n);\n+  static uint vector_length_in_bytes(const MachNode* use, const MachOper* opnd);\n+\n+  \/\/ Vector element basic type\n+  static BasicType vector_element_basic_type(const Node* n);\n+  static BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd);\n+\n@@ -472,1 +485,1 @@\n-  static bool is_generic_reg2reg_move(MachNode* m);\n+  static bool is_reg2reg_move(MachNode* m);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-    _in = (Node **) ((char *) (C->node_arena()->Amalloc_D(req * sizeof(void*))));\n+    _in = (Node **) ((char *) (C->node_arena()->AmallocWords(req * sizeof(void*))));\n@@ -502,1 +502,1 @@\n-  Node *n = (Node*)C->node_arena()->Amalloc_D(size_of() + _max*sizeof(Node*));\n+  Node *n = (Node*)C->node_arena()->AmallocWords(size_of() + _max*sizeof(Node*));\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,2 +223,1 @@\n-  Node(const Node&);            \/\/ not defined; linker error to use these\n-  Node &operator=(const Node &rhs);\n+  NONCOPYABLE(Node);\n@@ -242,1 +241,1 @@\n-    Node* n = (Node*)C->node_arena()->Amalloc_D(x);\n+    Node* n = (Node*)C->node_arena()->AmallocWords(x);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  int bound_pres = is_float_or_vector ? FLOATPRESSURE : INTPRESSURE;\n+  int bound_pres = is_float_or_vector ? Matcher::float_pressure_limit() : Matcher::int_pressure_limit();\n@@ -803,1 +803,1 @@\n-              (b->_reg_pressure < (uint)INTPRESSURE) ||\n+              (b->_reg_pressure < Matcher::int_pressure_limit()) ||\n@@ -808,1 +808,1 @@\n-              (b->_freg_pressure < (uint)FLOATPRESSURE) ||\n+              (b->_freg_pressure < Matcher::float_pressure_limit()) ||\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-    int size = ((typeArrayOop)result)->object_size();\n+    int size = TypeArrayKlass::cast(array_type)->oop_size(result);\n@@ -1196,1 +1196,1 @@\n-  int argcnt = 6;\n+  int argcnt = 7;\n@@ -1206,0 +1206,1 @@\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isMIME\n@@ -1601,6 +1602,0 @@\n-    } else if (c->tag() == NamedCounter::BiasedLockingCounter) {\n-      BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)->counters();\n-      if (blc->nonzero()) {\n-        tty->print_cr(\"%s\", c->name());\n-        blc->print_on(tty);\n-      }\n@@ -1657,3 +1652,1 @@\n-  if (tag == NamedCounter::BiasedLockingCounter) {\n-    c = new BiasedLockingNamedCounter(st.as_string());\n-  } else if (tag == NamedCounter::RTMLockingCounter) {\n+  if (tag == NamedCounter::RTMLockingCounter) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -66,1 +65,0 @@\n-    BiasedLockingCounter,\n@@ -103,12 +101,0 @@\n-class BiasedLockingNamedCounter : public NamedCounter {\n- private:\n-  BiasedLockingCounters _counters;\n-\n- public:\n-  BiasedLockingNamedCounter(const char *n) :\n-    NamedCounter(n, BiasedLockingCounter), _counters() {}\n-\n-  BiasedLockingCounters* counters() { return &_counters; }\n-};\n-\n-\n@@ -173,4 +159,0 @@\n-  \/\/ Slow-path Locking and Unlocking\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -272,0 +272,34 @@\n+  \/\/ Associative\n+  if (op1 == Op_MulI && op2 == Op_MulI) {\n+    Node* sub_in1 = NULL;\n+    Node* sub_in2 = NULL;\n+    Node* mul_in = NULL;\n+\n+    if (in1->in(1) == in2->in(1)) {\n+      \/\/ Convert \"a*b-a*c into a*(b-c)\n+      sub_in1 = in1->in(2);\n+      sub_in2 = in2->in(2);\n+      mul_in = in1->in(1);\n+    } else if (in1->in(2) == in2->in(1)) {\n+      \/\/ Convert a*b-b*c into b*(a-c)\n+      sub_in1 = in1->in(1);\n+      sub_in2 = in2->in(2);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(2) == in2->in(2)) {\n+      \/\/ Convert a*c-b*c into (a-b)*c\n+      sub_in1 = in1->in(1);\n+      sub_in2 = in2->in(1);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(1) == in2->in(2)) {\n+      \/\/ Convert a*b-c*a into a*(b-c)\n+      sub_in1 = in1->in(2);\n+      sub_in2 = in2->in(1);\n+      mul_in = in1->in(1);\n+    }\n+\n+    if (mul_in != NULL) {\n+      Node* sub = phase->transform(new SubINode(sub_in1, sub_in2));\n+      return new MulINode(mul_in, sub);\n+    }\n+  }\n+\n@@ -396,0 +430,34 @@\n+  \/\/ Associative\n+  if (op1 == Op_MulL && op2 == Op_MulL) {\n+    Node* sub_in1 = NULL;\n+    Node* sub_in2 = NULL;\n+    Node* mul_in = NULL;\n+\n+    if (in1->in(1) == in2->in(1)) {\n+      \/\/ Convert \"a*b-a*c into a*(b+c)\n+      sub_in1 = in1->in(2);\n+      sub_in2 = in2->in(2);\n+      mul_in = in1->in(1);\n+    } else if (in1->in(2) == in2->in(1)) {\n+      \/\/ Convert a*b-b*c into b*(a-c)\n+      sub_in1 = in1->in(1);\n+      sub_in2 = in2->in(2);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(2) == in2->in(2)) {\n+      \/\/ Convert a*c-b*c into (a-b)*c\n+      sub_in1 = in1->in(1);\n+      sub_in2 = in2->in(1);\n+      mul_in = in1->in(2);\n+    } else if (in1->in(1) == in2->in(2)) {\n+      \/\/ Convert a*b-c*a into a*(b-c)\n+      sub_in1 = in1->in(2);\n+      sub_in2 = in2->in(1);\n+      mul_in = in1->in(1);\n+    }\n+\n+    if (mul_in != NULL) {\n+      Node* sub = phase->transform(new SubLNode(sub_in1, sub_in2));\n+      return new MulLNode(mul_in, sub);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2697,1 +2697,1 @@\n-          if (FLOATPRESSURE > 8) {\n+          if (Matcher::float_pressure_limit() > 8) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  const Type **fboth =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fboth =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -506,1 +506,1 @@\n-  const Type **ffalse =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **ffalse =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -511,1 +511,1 @@\n-  const Type **fneither =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fneither =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -516,1 +516,1 @@\n-  const Type **ftrue =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **ftrue =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -521,1 +521,1 @@\n-  const Type **floop =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **floop =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -536,1 +536,1 @@\n-  const Type **fsc = (const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fsc = (const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -2059,1 +2059,1 @@\n-  const Type **flds = (const Type **)(Compile::current()->type_arena()->Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));\n+  const Type **flds = (const Type **)(Compile::current()->type_arena()->AmallocWords((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));\n@@ -2087,1 +2087,1 @@\n-    const Type **fields = (const Type **)(Compile::current()->type_arena()->Amalloc_4( _cnt*sizeof(Type*) ));\n+    const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n@@ -2101,1 +2101,1 @@\n-  const Type **fields = (const Type **)(Compile::current()->type_arena()->Amalloc_4( _cnt*sizeof(Type*) ));\n+  const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return compile->type_arena()->Amalloc_D(x);\n+    return compile->type_arena()->AmallocWords(x);\n@@ -1877,3 +1877,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorLNode\n-#define StoreXConditionalNode StoreLConditionalNode\n+\/\/ For shenandoahSupport\n@@ -1925,3 +1923,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorINode\n-#define StoreXConditionalNode StoreIConditionalNode\n+\/\/ For shenandoahSupport\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -580,1 +580,1 @@\n-        \"in thread \\\"%s\\\" \", thread->get_thread_name());\n+        \"in thread \\\"%s\\\" \", thread->name());\n@@ -980,1 +980,1 @@\n-  DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);\n+  DT_RETURN_MARK(NewObjectA, jobject, (const jobject&)obj);\n@@ -2826,7 +2826,2 @@\n-  assert(a->is_array(), \"just checking\");\n-  BasicType type;\n-  if (a->is_objArray()) {\n-    type = T_OBJECT;\n-  } else {\n-    type = TypeArrayKlass::cast(a->klass())->element_type();\n-  }\n+  assert(a->is_typeArray(), \"Primitive array only\");\n+  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n@@ -3799,1 +3794,1 @@\n-      *(JNIEnv**)penv = t->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(t)->jni_environment();\n@@ -3936,1 +3931,1 @@\n-  JavaThread* thread = current->as_Java_thread();\n+  JavaThread* thread = JavaThread::cast(current);\n@@ -3998,1 +3993,1 @@\n-      *(JNIEnv**)penv = thread->as_Java_thread()->jni_environment();\n+      *(JNIEnv**)penv = JavaThread::cast(thread)->jni_environment();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    JavaThread* thr = cur->as_Java_thread();                             \\\n+    JavaThread* thr = JavaThread::cast(cur);                             \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n+    DynamicArchive::prepare_for_dynamic_dumping();\n@@ -2912,0 +2912,3 @@\n+    ResourceMark rm(thread);\n+    log_warning(os, thread)(\"Failed to start the native thread for java.lang.Thread \\\"%s\\\"\",\n+                            JavaThread::name_for(JNIHandles::resolve_non_null(jthread)));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-    <xsl:text>JavaThread* current_thread = this_thread->as_Java_thread();<\/xsl:text>\n+    <xsl:text>JavaThread* current_thread = JavaThread::cast(this_thread);<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1329,2 +1329,0 @@\n-  {\n-    MutexLocker mu(current_thread, Threads_lock); \/\/ grab Threads_lock\n@@ -1332,1 +1330,1 @@\n-    JvmtiAgentThread *new_thread = new JvmtiAgentThread(this, proc, arg);\n+  JvmtiAgentThread* new_thread = new JvmtiAgentThread(this, proc, arg);\n@@ -1334,12 +1332,7 @@\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory.\n-    if (new_thread == NULL || new_thread->osthread() == NULL) {\n-      if (new_thread != NULL) {\n-        new_thread->smr_delete();\n-      }\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-\n-    java_lang_Thread::set_thread(thread_hndl(), new_thread);\n-    java_lang_Thread::set_priority(thread_hndl(), (ThreadPriority)priority);\n-    java_lang_Thread::set_daemon(thread_hndl());\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources.\n+  if (new_thread->osthread() == NULL) {\n+    \/\/ The new thread is not known to Thread-SMR yet so we can just delete.\n+    delete new_thread;\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n@@ -1347,4 +1340,2 @@\n-    new_thread->set_threadObj(thread_hndl());\n-    Threads::add(new_thread);\n-    Thread::start(new_thread);\n-  } \/\/ unlock Threads_lock\n+  JavaThread::start_internal_daemon(current_thread, new_thread, thread_hndl,\n+                                    (ThreadPriority)priority);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -973,3 +972,0 @@\n-    \/\/ Revoke any biases before querying the mark word\n-    BiasedLocking::revoke_at_safepoint(hobj);\n-\n@@ -1272,1 +1268,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1396,1 +1392,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1531,1 +1527,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1621,1 +1617,1 @@\n-  JavaThread* java_thread = target->as_Java_thread();\n+  JavaThread* java_thread = JavaThread::cast(target);\n@@ -1652,1 +1648,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1662,1 +1658,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1672,1 +1668,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n@@ -1691,1 +1687,1 @@\n-  JavaThread *jt = target->as_Java_thread();\n+  JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-    JavaThread *jt = target->as_Java_thread();\n+    JavaThread *jt = JavaThread::cast(target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    JavaThread* jt = th->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(th);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-       _jthread = thread->as_Java_thread();\n+       _jthread = JavaThread::cast(thread);\n@@ -2209,0 +2209,1 @@\n+  assert(!nm->is_zombie(), \"nmethod zombie in post_compiled_method_load\");\n@@ -2311,1 +2312,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2335,1 +2336,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = JavaThread::cast(thread)->jvmti_thread_state();\n@@ -2871,1 +2872,1 @@\n-    JavaThread* current_thread = thread->as_Java_thread();\n+    JavaThread* current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -965,1 +965,1 @@\n-  \/\/ Post and destroy queue nodes\n+  \/\/ Post events while nmethods are still in the queue and can't be unloaded or made zombie\n@@ -967,2 +967,2 @@\n-     JvmtiDeferredEvent event = dequeue();\n-     event.post_compiled_method_load_event(env);\n+    _queue_head->event().post_compiled_method_load_event(env);\n+    dequeue();\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -329,1 +329,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -382,1 +382,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4071,1 +4071,1 @@\n-\/\/ Deoptimize all compiled code that depends on this class.\n+\/\/ Deoptimize all compiled code that depends on the classes redefined.\n@@ -4087,12 +4087,0 @@\n-\/\/ First step is to walk the code cache for each class redefined and mark\n-\/\/ dependent methods.  Wait until all classes are processed to deoptimize everything.\n-void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {\n-  assert_locked_or_safepoint(Compile_lock);\n-\n-  \/\/ All dependencies have been recorded from startup or this is a second or\n-  \/\/ subsequent use of RedefineClasses\n-  if (JvmtiExport::all_dependencies_are_recorded()) {\n-    CodeCache::mark_for_evol_deoptimization(ik);\n-  }\n-}\n-\n@@ -4223,3 +4211,0 @@\n-\n-  \/\/ Mark all compiled code that depends on this class\n-  mark_dependent_code(the_class);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -496,1 +496,0 @@\n-  void mark_dependent_code(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -1401,4 +1400,0 @@\n-\n-  if (UseBiasedLocking) {\n-    BiasedLocking::preserve_marks();\n-  }\n@@ -1427,4 +1422,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::restore_marks();\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-  oop threadObj = thread->as_Java_thread()->threadObj();\n+  oop threadObj = JavaThread::cast(thread)->threadObj();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"oops\/typeArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -1936,1 +1936,1 @@\n-  return HeapShared::is_archived_object(obj_oop);\n+  return Universe::heap()->is_archived_object(obj_oop);\n@@ -1944,1 +1944,1 @@\n-  return !HeapShared::closed_archive_heap_region_mapped();\n+  return !HeapShared::closed_regions_mapped();\n@@ -1969,1 +1969,1 @@\n-  return HeapShared::open_archive_heap_region_mapped();\n+  return HeapShared::open_regions_mapped();\n@@ -2020,0 +2020,46 @@\n+WB_ENTRY(jboolean, WB_HandshakeReadMonitors(JNIEnv* env, jobject wb, jobject thread_handle))\n+  class ReadMonitorsClosure : public HandshakeClosure {\n+    jboolean _executed;\n+\n+    void do_thread(Thread* th) {\n+      JavaThread* jt = JavaThread::cast(th);\n+      ResourceMark rm;\n+\n+      GrowableArray<MonitorInfo*>* info = new GrowableArray<MonitorInfo*>();\n+\n+      if (!jt->has_last_Java_frame()) {\n+        return;\n+      }\n+      RegisterMap rmap(jt);\n+      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != NULL; vf = vf->java_sender()) {\n+        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n+        if (monitors != NULL) {\n+          int len = monitors->length();\n+          \/\/ Walk monitors youngest to oldest\n+          for (int i = len - 1; i >= 0; i--) {\n+            MonitorInfo* mon_info = monitors->at(i);\n+            if (mon_info->eliminated()) continue;\n+            oop owner = mon_info->owner();\n+            if (owner != NULL) {\n+              info->append(mon_info);\n+            }\n+          }\n+        }\n+      }\n+      _executed = true;\n+    }\n+\n+   public:\n+    ReadMonitorsClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n+    jboolean executed() const { return _executed; }\n+  };\n+\n+  ReadMonitorsClosure rmc;\n+  oop thread_oop = JNIHandles::resolve(thread_handle);\n+  if (thread_oop != NULL) {\n+    JavaThread* target = java_lang_Thread::thread(thread_oop);\n+    Handshake::execute(&rmc, target);\n+  }\n+  return rmc.executed();\n+WB_END\n+\n@@ -2025,1 +2071,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2061,1 +2107,1 @@\n-      JavaThread* jt = th->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(th);\n@@ -2592,0 +2638,1 @@\n+  {CC\"handshakeReadMonitors\", CC\"(Ljava\/lang\/Thread;)Z\", (void*)&WB_HandshakeReadMonitors },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,3 +169,0 @@\n-  \/\/ ARCH specific policy for the BiasedLocking\n-  static bool use_biased_locking()  { return true; }\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -528,2 +528,8 @@\n-  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"FilterSpuriousWakeups\",        JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n+\n+  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n+  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n@@ -531,0 +537,2 @@\n+  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -540,9 +548,0 @@\n-\n-  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n-\n-  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n-  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -550,1 +549,1 @@\n-  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::undefined() },\n+  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::undefined() },\n@@ -1115,1 +1114,8 @@\n-    st->print_cr(\"java_class_path (initial): %s\", strlen(path) == 0 ? \"<not set>\" : path );\n+    size_t len = strlen(path);\n+    st->print(\"java_class_path (initial): \");\n+    \/\/ Avoid using st->print_cr() because path length maybe longer than O_BUFLEN.\n+    if (len == 0) {\n+      st->print_raw_cr(\"<not set>\");\n+    } else {\n+      st->print_raw_cr(path, len);\n+    }\n@@ -3110,4 +3116,0 @@\n-    \/\/ Disable biased locking now as it interferes with the clean up of\n-    \/\/ the archived Klasses and Java string objects (at dump time only).\n-    UseBiasedLocking = false;\n-\n@@ -3991,0 +3993,5 @@\n+  if (log_is_enabled(Info, arguments)) {\n+    LogStream st(Log(arguments)::info());\n+    Arguments::print_on(&st);\n+  }\n+\n@@ -4027,20 +4034,0 @@\n-  \/\/ Turn off biased locking for locking debug mode flags,\n-  \/\/ which are subtly different from each other but neither works with\n-  \/\/ biased locking\n-  if (UseHeavyMonitors\n-#ifdef COMPILER1\n-      || !UseFastLocking\n-#endif \/\/ COMPILER1\n-#if INCLUDE_JVMCI\n-      || !JVMCIUseFastLocking\n-#endif\n-    ) {\n-    if (!FLAG_IS_DEFAULT(UseBiasedLocking) && UseBiasedLocking) {\n-      \/\/ flag set to true on command line; warn the user that they\n-      \/\/ can't enable biased locking here\n-      warning(\"Biased Locking is not supported with locking debug flags\"\n-              \"; ignoring UseBiasedLocking flag.\" );\n-    }\n-    UseBiasedLocking = false;\n-  }\n-\n@@ -4050,1 +4037,0 @@\n-  FLAG_SET_DEFAULT(UseBiasedLocking, false);\n@@ -4081,7 +4067,0 @@\n-  \/\/ Apply CPU specific policy for the BiasedLocking\n-  if (UseBiasedLocking) {\n-    if (!VM_Version::use_biased_locking() &&\n-        !(FLAG_IS_CMDLINE(UseBiasedLocking))) {\n-      UseBiasedLocking = false;\n-    }\n-  }\n@@ -4089,4 +4068,0 @@\n-  if (!UseBiasedLocking) {\n-    UseOptoBiasInlining = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":24,"deletions":49,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  memory_order_seq_cst = 5,\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,995 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/support\/jfrThreadId.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/basicLock.hpp\"\n-#include \"runtime\/biasedLocking.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/handshake.hpp\"\n-#include \"runtime\/safepointMechanism.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-#include \"runtime\/vframe.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"runtime\/vmOperations.hpp\"\n-\n-\n-static bool _biased_locking_enabled = false;\n-BiasedLockingCounters BiasedLocking::_counters;\n-\n-static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n-static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n-\n-static void enable_biased_locking(InstanceKlass* k) {\n-  k->set_prototype_header(markWord::biased_locking_prototype());\n-}\n-\n-static void enable_biased_locking() {\n-  _biased_locking_enabled = true;\n-  log_info(biasedlocking)(\"Biased locking enabled\");\n-}\n-\n-class VM_EnableBiasedLocking: public VM_Operation {\n- public:\n-  VM_EnableBiasedLocking() {}\n-  VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }\n-\n-  void doit() {\n-    \/\/ Iterate the class loader data dictionaries enabling biased locking for all\n-    \/\/ currently loaded classes.\n-    ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);\n-    \/\/ Indicate that future instances should enable it as well\n-    enable_biased_locking();\n-  }\n-\n-  bool allow_nested_vm_operations() const        { return false; }\n-};\n-\n-\n-\/\/ One-shot PeriodicTask subclass for enabling biased locking\n-class EnableBiasedLockingTask : public PeriodicTask {\n- public:\n-  EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}\n-\n-  virtual void task() {\n-    VM_EnableBiasedLocking op;\n-    VMThread::execute(&op);\n-\n-    \/\/ Reclaim our storage and disenroll ourself\n-    delete this;\n-  }\n-};\n-\n-\n-void BiasedLocking::init() {\n-  \/\/ If biased locking is enabled and BiasedLockingStartupDelay is set,\n-  \/\/ schedule a task to fire after the specified delay which turns on\n-  \/\/ biased locking for all currently loaded classes as well as future\n-  \/\/ ones. This could be a workaround for startup time regressions\n-  \/\/ due to large number of safepoints being taken during VM startup for\n-  \/\/ bias revocation.\n-  if (UseBiasedLocking) {\n-    if (BiasedLockingStartupDelay > 0) {\n-      EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);\n-      task->enroll();\n-    } else {\n-      enable_biased_locking();\n-    }\n-  }\n-}\n-\n-\n-bool BiasedLocking::enabled() {\n-  assert(UseBiasedLocking, \"precondition\");\n-  \/\/ We check \"BiasedLockingStartupDelay == 0\" here to cover the\n-  \/\/ possibility of calls to BiasedLocking::enabled() before\n-  \/\/ BiasedLocking::init().\n-  return _biased_locking_enabled || BiasedLockingStartupDelay == 0;\n-}\n-\n-\n-\/\/ Returns MonitorInfos for all objects locked on this thread in youngest to oldest order\n-static GrowableArray<MonitorInfo*>* get_or_compute_monitor_info(JavaThread* thread) {\n-  GrowableArray<MonitorInfo*>* info = thread->cached_monitor_info();\n-  if (info != NULL) {\n-    return info;\n-  }\n-\n-  info = new GrowableArray<MonitorInfo*>();\n-\n-  \/\/ It's possible for the thread to not have any Java frames on it,\n-  \/\/ i.e., if it's the main thread and it's already returned from main()\n-  if (thread->has_last_Java_frame()) {\n-    RegisterMap rm(thread);\n-    for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-      GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-      if (monitors != NULL) {\n-        int len = monitors->length();\n-        \/\/ Walk monitors youngest to oldest\n-        for (int i = len - 1; i >= 0; i--) {\n-          MonitorInfo* mon_info = monitors->at(i);\n-          if (mon_info->eliminated()) continue;\n-          oop owner = mon_info->owner();\n-          if (owner != NULL) {\n-            info->append(mon_info);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  thread->set_cached_monitor_info(info);\n-  return info;\n-}\n-\n-\n-\/\/ After the call, *biased_locker will be set to obj->mark()->biased_locker() if biased_locker != NULL,\n-\/\/ AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).\n-void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  markWord mark = obj->mark();\n-  if (!mark.has_bias_pattern()) {\n-    if (log_is_enabled(Info, biasedlocking)) {\n-      ResourceMark rm;\n-      log_info(biasedlocking)(\"  (Skipping revocation of object \" INTPTR_FORMAT\n-                              \", mark \" INTPTR_FORMAT \", type %s\"\n-                              \", requesting thread \" INTPTR_FORMAT\n-                              \" because it's no longer biased)\",\n-                              p2i((void *)obj), mark.value(),\n-                              obj->klass()->external_name(),\n-                              (intptr_t) requesting_thread);\n-    }\n-    return;\n-  }\n-\n-  uint age = mark.age();\n-  markWord unbiased_prototype = markWord::prototype().set_age(age);\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    ResourceMark rm;\n-    log_info(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \", mark \"\n-                            INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                            \", requesting thread \" INTPTR_FORMAT,\n-                            p2i((void *)obj),\n-                            mark.value(),\n-                            obj->klass()->external_name(),\n-                            obj->klass()->prototype_header().value(),\n-                            (intptr_t) requesting_thread);\n-  } else {\n-    ResourceMark rm;\n-    log_trace(biasedlocking)(\"Revoking bias of object \" INTPTR_FORMAT \" , mark \"\n-                             INTPTR_FORMAT \" , type %s , prototype header \" INTPTR_FORMAT\n-                             \" , requesting thread \" INTPTR_FORMAT,\n-                             p2i((void *)obj),\n-                             mark.value(),\n-                             obj->klass()->external_name(),\n-                             obj->klass()->prototype_header().value(),\n-                             (intptr_t) requesting_thread);\n-  }\n-\n-  JavaThread* biased_thread = mark.biased_locker();\n-  if (biased_thread == NULL) {\n-    \/\/ Object is anonymously biased. We can get here if, for\n-    \/\/ example, we revoke the bias due to an identity hash code\n-    \/\/ being computed for an object.\n-    obj->set_mark(unbiased_prototype);\n-\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of anonymously-biased object\");\n-    }\n-    return;\n-  }\n-\n-  \/\/ Handle case where the thread toward which the object was biased has exited\n-  bool thread_is_alive = false;\n-  if (requesting_thread == biased_thread) {\n-    thread_is_alive = true;\n-  } else {\n-    ThreadsListHandle tlh;\n-    thread_is_alive = tlh.includes(biased_thread);\n-  }\n-  if (!thread_is_alive) {\n-    obj->set_mark(unbiased_prototype);\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                              PTR_FORMAT \")\", p2i(biased_thread));\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of object biased toward dead thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-    }\n-    return;\n-  }\n-\n-  \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-  if (!is_bulk) {\n-    log_info(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                            PTR_FORMAT \")\", p2i(biased_thread));\n-  } else {\n-    log_trace(biasedlocking)(\"  Revoked bias of object biased toward live thread (\"\n-                               PTR_FORMAT \")\", p2i(biased_thread));\n-  }\n-\n-  \/\/ Thread owning bias is alive.\n-  \/\/ Check to see whether it currently owns the lock and, if so,\n-  \/\/ write down the needed displaced headers to the thread's stack.\n-  \/\/ Otherwise, restore the object's header either to the unlocked\n-  \/\/ or unbiased state.\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_thread);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i((void *) mon_info->owner()),\n-                               p2i((void *) obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-    }\n-  } else {\n-    \/\/ Log at \"info\" level if not bulk, else \"trace\" level\n-    if (!is_bulk) {\n-      log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    } else {\n-      log_trace(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    }\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  \/\/ If requested, return information on which thread held the bias\n-  if (biased_locker != NULL) {\n-    *biased_locker = biased_thread;\n-  }\n-}\n-\n-\n-enum HeuristicsResult {\n-  HR_NOT_BIASED    = 1,\n-  HR_SINGLE_REVOKE = 2,\n-  HR_BULK_REBIAS   = 3,\n-  HR_BULK_REVOKE   = 4\n-};\n-\n-\n-static HeuristicsResult update_heuristics(oop o) {\n-  markWord mark = o->mark();\n-  if (!mark.has_bias_pattern()) {\n-    return HR_NOT_BIASED;\n-  }\n-\n-  \/\/ Heuristics to attempt to throttle the number of revocations.\n-  \/\/ Stages:\n-  \/\/ 1. Revoke the biases of all objects in the heap of this type,\n-  \/\/    but allow rebiasing of those objects if unlocked.\n-  \/\/ 2. Revoke the biases of all objects in the heap of this type\n-  \/\/    and don't allow rebiasing of these objects. Disable\n-  \/\/    allocation of objects of that type with the bias bit set.\n-  Klass* k = o->klass();\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  jlong last_bulk_revocation_time = k->last_biased_lock_bulk_revocation_time();\n-  int revocation_count = k->biased_lock_revocation_count();\n-  if ((revocation_count >= BiasedLockingBulkRebiasThreshold) &&\n-      (revocation_count <  BiasedLockingBulkRevokeThreshold) &&\n-      (last_bulk_revocation_time != 0) &&\n-      (cur_time - last_bulk_revocation_time >= BiasedLockingDecayTime)) {\n-    \/\/ This is the first revocation we've seen in a while of an\n-    \/\/ object of this type since the last time we performed a bulk\n-    \/\/ rebiasing operation. The application is allocating objects in\n-    \/\/ bulk which are biased toward a thread and then handing them\n-    \/\/ off to another thread. We can cope with this allocation\n-    \/\/ pattern via the bulk rebiasing mechanism so we reset the\n-    \/\/ klass's revocation count rather than allow it to increase\n-    \/\/ monotonically. If we see the need to perform another bulk\n-    \/\/ rebias operation later, we will, and if subsequently we see\n-    \/\/ many more revocation operations in a short period of time we\n-    \/\/ will completely disable biasing for this type.\n-    k->set_biased_lock_revocation_count(0);\n-    revocation_count = 0;\n-  }\n-\n-  \/\/ Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold\n-  if (revocation_count <= BiasedLockingBulkRevokeThreshold) {\n-    revocation_count = k->atomic_incr_biased_lock_revocation_count();\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRevokeThreshold) {\n-    return HR_BULK_REVOKE;\n-  }\n-\n-  if (revocation_count == BiasedLockingBulkRebiasThreshold) {\n-    return HR_BULK_REBIAS;\n-  }\n-\n-  return HR_SINGLE_REVOKE;\n-}\n-\n-\n-void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be done at safepoint\");\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-\n-  log_info(biasedlocking)(\"* Beginning bulk revocation (kind == %s) because of object \"\n-                          INTPTR_FORMAT \" , mark \" INTPTR_FORMAT \" , type %s\",\n-                          (bulk_rebias ? \"rebias\" : \"revoke\"),\n-                          p2i((void *) o),\n-                          o->mark().value(),\n-                          o->klass()->external_name());\n-\n-  jlong cur_time = nanos_to_millis(os::javaTimeNanos());\n-  o->klass()->set_last_biased_lock_bulk_revocation_time(cur_time);\n-\n-  Klass* k_o = o->klass();\n-  Klass* klass = k_o;\n-\n-  {\n-    JavaThreadIteratorWithHandle jtiwh;\n-\n-    if (bulk_rebias) {\n-      \/\/ Use the epoch in the klass of the object to implicitly revoke\n-      \/\/ all biases of objects of this data type and force them to be\n-      \/\/ reacquired. However, we also need to walk the stacks of all\n-      \/\/ threads and update the headers of lightweight locked objects\n-      \/\/ with biases to have the current epoch.\n-\n-      \/\/ If the prototype header doesn't have the bias pattern, don't\n-      \/\/ try to update the epoch -- assume another VM operation came in\n-      \/\/ and reset the header to the unbiased state, which will\n-      \/\/ implicitly cause all existing biases to be revoked\n-      if (klass->prototype_header().has_bias_pattern()) {\n-        int prev_epoch = klass->prototype_header().bias_epoch();\n-        klass->set_prototype_header(klass->prototype_header().incr_bias_epoch());\n-        int cur_epoch = klass->prototype_header().bias_epoch();\n-\n-        \/\/ Now walk all threads' stacks and adjust epochs of any biased\n-        \/\/ and locked objects of this data type we encounter\n-        for (; JavaThread *thr = jtiwh.next(); ) {\n-          GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-          for (int i = 0; i < cached_monitor_info->length(); i++) {\n-            MonitorInfo* mon_info = cached_monitor_info->at(i);\n-            oop owner = mon_info->owner();\n-            markWord mark = owner->mark();\n-            if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-              \/\/ We might have encountered this object already in the case of recursive locking\n-              assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n-              owner->set_mark(mark.set_bias_epoch(cur_epoch));\n-            }\n-          }\n-        }\n-      }\n-\n-      \/\/ At this point we're done. All we have to do is potentially\n-      \/\/ adjust the header of the given object to revoke its bias.\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    } else {\n-      if (log_is_enabled(Info, biasedlocking)) {\n-        ResourceMark rm;\n-        log_info(biasedlocking)(\"* Disabling biased locking for type %s\", klass->external_name());\n-      }\n-\n-      \/\/ Disable biased locking for this data type. Not only will this\n-      \/\/ cause future instances to not be biased, but existing biased\n-      \/\/ instances will notice that this implicitly caused their biases\n-      \/\/ to be revoked.\n-      klass->set_prototype_header(markWord::prototype());\n-\n-      \/\/ Now walk all threads' stacks and forcibly revoke the biases of\n-      \/\/ any locked and biased objects of this data type we encounter.\n-      for (; JavaThread *thr = jtiwh.next(); ) {\n-        GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(thr);\n-        for (int i = 0; i < cached_monitor_info->length(); i++) {\n-          MonitorInfo* mon_info = cached_monitor_info->at(i);\n-          oop owner = mon_info->owner();\n-          markWord mark = owner->mark();\n-          if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n-            single_revoke_at_safepoint(owner, true, requesting_thread, NULL);\n-          }\n-        }\n-      }\n-\n-      \/\/ Must force the bias of the passed object to be forcibly revoked\n-      \/\/ as well to ensure guarantees to callers\n-      single_revoke_at_safepoint(o, true, requesting_thread, NULL);\n-    }\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n-  log_info(biasedlocking)(\"* Ending bulk revocation\");\n-\n-  assert(!o->mark().has_bias_pattern(), \"bug in bulk bias revocation\");\n-}\n-\n-\n-static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {\n-  if (thread != NULL) {\n-    thread->set_cached_monitor_info(NULL);\n-  } else {\n-    \/\/ Walk the thread list clearing out the cached monitors\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n-      thr->set_cached_monitor_info(NULL);\n-    }\n-  }\n-}\n-\n-\n-class VM_BulkRevokeBias : public VM_Operation {\n-private:\n-  Handle* _obj;\n-  JavaThread* _requesting_thread;\n-  bool _bulk_rebias;\n-  uint64_t _safepoint_id;\n-\n-public:\n-  VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,\n-                    bool bulk_rebias)\n-    : _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _bulk_rebias(bulk_rebias)\n-    , _safepoint_id(0) {}\n-\n-  virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }\n-\n-  virtual void doit() {\n-    BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);\n-    _safepoint_id = SafepointSynchronize::safepoint_id();\n-    clean_up_cached_monitor_info();\n-  }\n-\n-  bool is_bulk_rebias() const {\n-    return _bulk_rebias;\n-  }\n-\n-  uint64_t safepoint_id() const {\n-    return _safepoint_id;\n-  }\n-};\n-\n-\n-class RevokeOneBias : public HandshakeClosure {\n-protected:\n-  Handle _obj;\n-  JavaThread* _requesting_thread;\n-  JavaThread* _biased_locker;\n-  BiasedLocking::Condition _status_code;\n-  traceid _biased_locker_id;\n-  bool _executed;\n-\n-public:\n-  RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)\n-    : HandshakeClosure(\"RevokeOneBias\")\n-    , _obj(obj)\n-    , _requesting_thread(requesting_thread)\n-    , _biased_locker(biased_locker)\n-    , _status_code(BiasedLocking::NOT_BIASED)\n-    , _biased_locker_id(0)\n-    , _executed(false) {}\n-\n-  bool executed() { return _executed; }\n-\n-  void do_thread(Thread* target) {\n-    assert(target == _biased_locker, \"Wrong thread\");\n-    _executed = true;\n-\n-    oop o = _obj();\n-    markWord mark = o->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    markWord prototype = o->klass()->prototype_header();\n-    if (!prototype.has_bias_pattern()) {\n-      \/\/ This object has a stale bias from before the handshake\n-      \/\/ was requested. If we fail this race, the object's bias\n-      \/\/ has been revoked by another thread so we simply return.\n-      markWord biased_value = mark;\n-      mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-      assert(!o->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-      if (biased_value == mark) {\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-      }\n-      return;\n-    }\n-\n-    if (_biased_locker == mark.biased_locker()) {\n-      if (mark.bias_epoch() == prototype.bias_epoch()) {\n-        \/\/ Epoch is still valid. This means biaser could be currently\n-        \/\/ synchronized on this object. We must walk its stack looking\n-        \/\/ for monitor records associated with this object and change\n-        \/\/ them to be stack locks if any are found.\n-        ResourceMark rm;\n-        BiasedLocking::walk_stack_and_revoke(o, _biased_locker);\n-        _biased_locker->set_cached_monitor_info(NULL);\n-        assert(!o->mark().has_bias_pattern(), \"invariant\");\n-        _biased_locker_id = JFR_THREAD_ID(_biased_locker);\n-        _status_code = BiasedLocking::BIAS_REVOKED;\n-        return;\n-      } else {\n-        markWord biased_value = mark;\n-        mark = o->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (mark == biased_value || !mark.has_bias_pattern()) {\n-          assert(!o->mark().has_bias_pattern(), \"should be revoked\");\n-          _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;\n-          return;\n-        }\n-      }\n-    }\n-\n-    _status_code = BiasedLocking::NOT_REVOKED;\n-  }\n-\n-  BiasedLocking::Condition status_code() const {\n-    return _status_code;\n-  }\n-\n-  traceid biased_locker() const {\n-    return _biased_locker_id;\n-  }\n-};\n-\n-\n-static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->commit();\n-}\n-\n-static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_lockClass(k);\n-  event->set_safepointId(0);\n-  event->set_previousOwner(op->biased_locker());\n-  event->commit();\n-}\n-\n-static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n-  assert(op != NULL, \"invariant\");\n-  assert(event->should_commit(), \"invariant\");\n-  event->set_revokedClass(k);\n-  event->set_disableBiasing(!op->is_bulk_rebias());\n-  event->set_safepointId(op->safepoint_id());\n-  event->commit();\n-}\n-\n-\n-BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {\n-\n-  EventBiasedLockRevocation event;\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(handshakes_count_addr());\n-  }\n-  log_info(biasedlocking, handshake)(\"JavaThread \" INTPTR_FORMAT \" handshaking JavaThread \"\n-                                     INTPTR_FORMAT \" to revoke object \" INTPTR_FORMAT, p2i(requester),\n-                                     p2i(biaser), p2i(obj()));\n-\n-  RevokeOneBias revoke(obj, requester, biaser);\n-  Handshake::execute(&revoke, biaser);\n-  if (revoke.status_code() == NOT_REVOKED) {\n-    return NOT_REVOKED;\n-  }\n-  if (revoke.executed()) {\n-    log_info(biasedlocking, handshake)(\"Handshake revocation for object \" INTPTR_FORMAT \" succeeded. Bias was %srevoked\",\n-                                       p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? \"\" : \"already \"));\n-    if (event.should_commit() && revoke.status_code() == BIAS_REVOKED) {\n-      post_revocation_event(&event, obj->klass(), &revoke);\n-    }\n-    assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-    return revoke.status_code();\n-  } else {\n-    \/\/ Thread was not alive.\n-    \/\/ Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly\n-    \/\/ created JavaThread (that happens to get the same memory address as biaser) synchronizing\n-    \/\/ on this object.\n-    {\n-      MutexLocker ml(Threads_lock);\n-      markWord mark = obj->mark();\n-      \/\/ Check if somebody else was able to revoke it before biased thread exited.\n-      if (!mark.has_bias_pattern()) {\n-        return NOT_BIASED;\n-      }\n-      ThreadsListHandle tlh;\n-      markWord prototype = obj->klass()->prototype_header();\n-      if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) && biaser == mark.biased_locker() &&\n-                                            prototype.bias_epoch() == mark.bias_epoch())) {\n-        obj->cas_set_mark(markWord::prototype().set_age(mark.age()), mark);\n-        if (event.should_commit()) {\n-          post_revocation_event(&event, obj->klass(), &revoke);\n-        }\n-        assert(!obj->mark().has_bias_pattern(), \"bias should be revoked by now\");\n-        return BIAS_REVOKED;\n-      }\n-    }\n-  }\n-\n-  return NOT_REVOKED;\n-}\n-\n-\n-\/\/ Caller should have instantiated a ResourceMark object before calling this method\n-void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {\n-  Thread* cur = Thread::current();\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"this should always be executed outside safepoints\");\n-  assert(biased_locker->is_handshake_safe_for(cur), \"wrong thread\");\n-\n-  markWord mark = obj->mark();\n-  assert(mark.biased_locker() == biased_locker &&\n-         obj->klass()->prototype_header().bias_epoch() == mark.bias_epoch(), \"invariant\");\n-\n-  log_trace(biasedlocking)(\"JavaThread(\" INTPTR_FORMAT \") revoking object \" INTPTR_FORMAT \", mark \"\n-                           INTPTR_FORMAT \", type %s, prototype header \" INTPTR_FORMAT\n-                           \", biaser \" INTPTR_FORMAT \" %s\",\n-                           p2i(cur),\n-                           p2i(obj),\n-                           mark.value(),\n-                           obj->klass()->external_name(),\n-                           obj->klass()->prototype_header().value(),\n-                           p2i(biased_locker),\n-                           cur != biased_locker ? \"\" : \"(walking own stack)\");\n-\n-  markWord unbiased_prototype = markWord::prototype().set_age(obj->mark().age());\n-\n-  GrowableArray<MonitorInfo*>* cached_monitor_info = get_or_compute_monitor_info(biased_locker);\n-  BasicLock* highest_lock = NULL;\n-  for (int i = 0; i < cached_monitor_info->length(); i++) {\n-    MonitorInfo* mon_info = cached_monitor_info->at(i);\n-    if (mon_info->owner() == obj) {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") == obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-      \/\/ Assume recursive case and fix up highest lock below\n-      markWord mark = markWord::encode((BasicLock*) NULL);\n-      highest_lock = mon_info->lock();\n-      highest_lock->set_displaced_header(mark);\n-    } else {\n-      log_trace(biasedlocking)(\"   mon_info->owner (\" PTR_FORMAT \") != obj (\" PTR_FORMAT \")\",\n-                               p2i(mon_info->owner()),\n-                               p2i(obj));\n-    }\n-  }\n-  if (highest_lock != NULL) {\n-    \/\/ Fix up highest lock to contain displaced header and point\n-    \/\/ object at it\n-    highest_lock->set_displaced_header(unbiased_prototype);\n-    \/\/ Reset object header to point to displaced mark.\n-    \/\/ Must release store the lock address for platforms without TSO\n-    \/\/ ordering (e.g. ppc).\n-    obj->release_set_mark(markWord::encode(highest_lock));\n-    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n-    log_info(biasedlocking)(\"  Revoked bias of currently-locked object\");\n-  } else {\n-    log_info(biasedlocking)(\"  Revoked bias of currently-unlocked object\");\n-    \/\/ Store the unlocked value into the object's header.\n-    obj->set_mark(unbiased_prototype);\n-  }\n-\n-  assert(!obj->mark().has_bias_pattern(), \"must not be biased\");\n-}\n-\n-void BiasedLocking::revoke_own_lock(JavaThread* current, Handle obj) {\n-  markWord mark = obj->mark();\n-\n-  if (!mark.has_bias_pattern()) {\n-    return;\n-  }\n-\n-  Klass *k = obj->klass();\n-  assert(mark.biased_locker() == current &&\n-         k->prototype_header().bias_epoch() == mark.bias_epoch(), \"Revoke failed, unhandled biased lock state\");\n-  ResourceMark rm(current);\n-  log_info(biasedlocking)(\"Revoking bias by walking my own stack:\");\n-  EventBiasedLockSelfRevocation event;\n-  BiasedLocking::walk_stack_and_revoke(obj(), current);\n-  current->set_cached_monitor_info(NULL);\n-  assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-  if (event.should_commit()) {\n-    post_self_revocation_event(&event, k);\n-  }\n-}\n-\n-void BiasedLocking::revoke(JavaThread* current, Handle obj) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"must not be called while at safepoint\");\n-\n-  while (true) {\n-    \/\/ We can revoke the biases of anonymously-biased objects\n-    \/\/ efficiently enough that we should not cause these revocations to\n-    \/\/ update the heuristics because doing so may cause unwanted bulk\n-    \/\/ revocations (which are expensive) to occur.\n-    markWord mark = obj->mark();\n-\n-    if (!mark.has_bias_pattern()) {\n-      return;\n-    }\n-\n-    if (mark.is_biased_anonymously()) {\n-      \/\/ We are probably trying to revoke the bias of this object due to\n-      \/\/ an identity hash code computation. Try to revoke the bias\n-      \/\/ without a safepoint. This is possible if we can successfully\n-      \/\/ compare-and-exchange an unbiased header into the mark word of\n-      \/\/ the object, meaning that no other thread has raced to acquire\n-      \/\/ the bias of the object.\n-      markWord biased_value       = mark;\n-      markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-      markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-      if (res_mark == biased_value) {\n-        return;\n-      }\n-      mark = res_mark;  \/\/ Refresh mark with the latest value.\n-    } else {\n-      Klass* k = obj->klass();\n-      markWord prototype_header = k->prototype_header();\n-      if (!prototype_header.has_bias_pattern()) {\n-        \/\/ This object has a stale bias from before the bulk revocation\n-        \/\/ for this data type occurred. It's pointless to update the\n-        \/\/ heuristics at this point so simply update the header with a\n-        \/\/ CAS. If we fail this race, the object's bias has been revoked\n-        \/\/ by another thread so we simply return and let the caller deal\n-        \/\/ with it.\n-        obj->cas_set_mark(prototype_header.set_age(mark.age()), mark);\n-        assert(!obj->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n-        return;\n-      } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {\n-        \/\/ The epoch of this biasing has expired indicating that the\n-        \/\/ object is effectively unbiased. We can revoke the bias of this\n-        \/\/ object efficiently enough with a CAS that we shouldn't update the\n-        \/\/ heuristics. This is normally done in the assembly code but we\n-        \/\/ can reach this point due to various points in the runtime\n-        \/\/ needing to revoke biases.\n-        markWord res_mark;\n-        markWord biased_value       = mark;\n-        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-        res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n-        if (res_mark == biased_value) {\n-          return;\n-        }\n-        mark = res_mark;  \/\/ Refresh mark with the latest value.\n-      }\n-    }\n-\n-    HeuristicsResult heuristics = update_heuristics(obj());\n-    if (heuristics == HR_NOT_BIASED) {\n-      return;\n-    } else if (heuristics == HR_SINGLE_REVOKE) {\n-      JavaThread *blt = mark.biased_locker();\n-      assert(blt != NULL, \"invariant\");\n-      if (blt == current) {\n-        \/\/ A thread is trying to revoke the bias of an object biased\n-        \/\/ toward it, again likely due to an identity hash code\n-        \/\/ computation. We can again avoid a safepoint\/handshake in this case\n-        \/\/ since we are only going to walk our own stack. There are no\n-        \/\/ races with revocations occurring in other threads because we\n-        \/\/ reach no safepoints in the revocation path.\n-        EventBiasedLockSelfRevocation event;\n-        ResourceMark rm(current);\n-        walk_stack_and_revoke(obj(), blt);\n-        blt->set_cached_monitor_info(NULL);\n-        assert(!obj->mark().has_bias_pattern(), \"invariant\");\n-        if (event.should_commit()) {\n-          post_self_revocation_event(&event, obj->klass());\n-        }\n-        return;\n-      } else {\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, current, blt);\n-        if (cond != NOT_REVOKED) {\n-          return;\n-        }\n-      }\n-    } else {\n-      assert((heuristics == HR_BULK_REVOKE) ||\n-         (heuristics == HR_BULK_REBIAS), \"?\");\n-      EventBiasedLockClassRevocation event;\n-      VM_BulkRevokeBias bulk_revoke(&obj, current, (heuristics == HR_BULK_REBIAS));\n-      VMThread::execute(&bulk_revoke);\n-      if (event.should_commit()) {\n-        post_class_revocation_event(&event, obj->klass(), &bulk_revoke);\n-      }\n-      return;\n-    }\n-  }\n-}\n-\n-\/\/ All objects in objs should be locked by biaser\n-void BiasedLocking::revoke(GrowableArray<Handle>* objs, JavaThread *biaser) {\n-  bool clean_my_cache = false;\n-  for (int i = 0; i < objs->length(); i++) {\n-    oop obj = (objs->at(i))();\n-    markWord mark = obj->mark();\n-    if (mark.has_bias_pattern()) {\n-      walk_stack_and_revoke(obj, biaser);\n-      clean_my_cache = true;\n-    }\n-  }\n-  if (clean_my_cache) {\n-    clean_up_cached_monitor_info(biaser);\n-  }\n-}\n-\n-\n-void BiasedLocking::revoke_at_safepoint(Handle h_obj) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-  oop obj = h_obj();\n-  HeuristicsResult heuristics = update_heuristics(obj);\n-  if (heuristics == HR_SINGLE_REVOKE) {\n-    JavaThread* biased_locker = NULL;\n-    single_revoke_at_safepoint(obj, false, NULL, &biased_locker);\n-    if (biased_locker) {\n-      clean_up_cached_monitor_info(biased_locker);\n-    }\n-  } else if ((heuristics == HR_BULK_REBIAS) ||\n-             (heuristics == HR_BULK_REVOKE)) {\n-    bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);\n-    clean_up_cached_monitor_info();\n-  }\n-}\n-\n-\n-void BiasedLocking::preserve_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must only be called while at safepoint\");\n-\n-  assert(_preserved_oop_stack  == NULL, \"double initialization\");\n-  assert(_preserved_mark_stack == NULL, \"double initialization\");\n-\n-  \/\/ In order to reduce the number of mark words preserved during GC\n-  \/\/ due to the presence of biased locking, we reinitialize most mark\n-  \/\/ words to the class's prototype during GC -- even those which have\n-  \/\/ a currently valid bias owner. One important situation where we\n-  \/\/ must not clobber a bias is when a biased object is currently\n-  \/\/ locked. To handle this case we iterate over the currently-locked\n-  \/\/ monitors in a prepass and, if they are biased, preserve their\n-  \/\/ mark words here. This should be a relatively small set of objects\n-  \/\/ especially compared to the number of objects in the heap.\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(10, mtGC);\n-  _preserved_oop_stack = new (ResourceObj::C_HEAP, mtGC) GrowableArray<Handle>(10, mtGC);\n-\n-  Thread* cur = Thread::current();\n-  ResourceMark rm(cur);\n-\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    if (thread->has_last_Java_frame()) {\n-      RegisterMap rm(thread);\n-      for (javaVFrame* vf = thread->last_java_vframe(&rm); vf != NULL; vf = vf->java_sender()) {\n-        GrowableArray<MonitorInfo*> *monitors = vf->monitors();\n-        if (monitors != NULL) {\n-          int len = monitors->length();\n-          \/\/ Walk monitors youngest to oldest\n-          for (int i = len - 1; i >= 0; i--) {\n-            MonitorInfo* mon_info = monitors->at(i);\n-            if (mon_info->owner_is_scalar_replaced()) continue;\n-            oop owner = mon_info->owner();\n-            if (owner != NULL) {\n-              markWord mark = owner->mark();\n-              if (mark.has_bias_pattern()) {\n-                _preserved_oop_stack->push(Handle(cur, owner));\n-                _preserved_mark_stack->push(mark);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-\n-void BiasedLocking::restore_marks() {\n-  if (!UseBiasedLocking)\n-    return;\n-\n-  assert(_preserved_oop_stack  != NULL, \"double free\");\n-  assert(_preserved_mark_stack != NULL, \"double free\");\n-\n-  int len = _preserved_oop_stack->length();\n-  for (int i = 0; i < len; i++) {\n-    Handle owner = _preserved_oop_stack->at(i);\n-    markWord mark = _preserved_mark_stack->at(i);\n-    owner->set_mark(mark);\n-  }\n-\n-  delete _preserved_oop_stack;\n-  _preserved_oop_stack = NULL;\n-  delete _preserved_mark_stack;\n-  _preserved_mark_stack = NULL;\n-}\n-\n-\n-int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }\n-int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }\n-int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }\n-int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }\n-int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }\n-int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }\n-int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }\n-int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }\n-\n-\n-\/\/ BiasedLockingCounters\n-\n-int BiasedLockingCounters::slow_path_entry_count() const {\n-  if (_slow_path_entry_count != 0) {\n-    return _slow_path_entry_count;\n-  }\n-  int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +\n-            _rebiased_lock_entry_count + _revoked_lock_entry_count +\n-            _fast_path_entry_count;\n-\n-  return _total_entry_count - sum;\n-}\n-\n-void BiasedLockingCounters::print_on(outputStream* st) const {\n-  tty->print_cr(\"# total entries: %d\", _total_entry_count);\n-  tty->print_cr(\"# biased lock entries: %d\", _biased_lock_entry_count);\n-  tty->print_cr(\"# anonymously biased lock entries: %d\", _anonymously_biased_lock_entry_count);\n-  tty->print_cr(\"# rebiased lock entries: %d\", _rebiased_lock_entry_count);\n-  tty->print_cr(\"# revoked lock entries: %d\", _revoked_lock_entry_count);\n-  tty->print_cr(\"# handshakes entries: %d\", _handshakes_count);\n-  tty->print_cr(\"# fast path lock entries: %d\", _fast_path_entry_count);\n-  tty->print_cr(\"# slow path lock entries: %d\", slow_path_entry_count());\n-}\n-\n-void BiasedLockingCounters::print() const { print_on(tty); }\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":0,"deletions":995,"binary":false,"changes":995,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP\n-#define SHARE_RUNTIME_BIASEDLOCKING_HPP\n-\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ This class describes operations to implement Store-Free Biased\n-\/\/ Locking. The high-level properties of the scheme are similar to\n-\/\/ IBM's lock reservation, Dice-Moir-Scherer QR locks, and other biased\n-\/\/ locking mechanisms. The principal difference is in the handling of\n-\/\/ recursive locking which is how this technique achieves a more\n-\/\/ efficient fast path than these other schemes.\n-\/\/\n-\/\/ The basic observation is that in HotSpot's current fast locking\n-\/\/ scheme, recursive locking (in the fast path) causes no update to\n-\/\/ the object header. The recursion is described simply by stack\n-\/\/ records containing a specific value (NULL). Only the last unlock by\n-\/\/ a given thread causes an update to the object header.\n-\/\/\n-\/\/ This observation, coupled with the fact that HotSpot only compiles\n-\/\/ methods for which monitor matching is obeyed (and which therefore\n-\/\/ can not throw IllegalMonitorStateException), implies that we can\n-\/\/ completely eliminate modifications to the object header for\n-\/\/ recursive locking in compiled code, and perform similar recursion\n-\/\/ checks and throwing of IllegalMonitorStateException in the\n-\/\/ interpreter with little or no impact on the performance of the fast\n-\/\/ path.\n-\/\/\n-\/\/ The basic algorithm is as follows (note, see below for more details\n-\/\/ and information). A pattern in the low three bits is reserved in\n-\/\/ the object header to indicate whether biasing of a given object's\n-\/\/ lock is currently being done or is allowed at all.  If the bias\n-\/\/ pattern is present, the contents of the rest of the header are\n-\/\/ either the JavaThread* of the thread to which the lock is biased,\n-\/\/ or NULL, indicating that the lock is \"anonymously biased\". The\n-\/\/ first thread which locks an anonymously biased object biases the\n-\/\/ lock toward that thread. If another thread subsequently attempts to\n-\/\/ lock the same object, the bias is revoked.\n-\/\/\n-\/\/ Because there are no updates to the object header at all during\n-\/\/ recursive locking while the lock is biased, the biased lock entry\n-\/\/ code is simply a test of the object header's value. If this test\n-\/\/ succeeds, the lock has been acquired by the thread. If this test\n-\/\/ fails, a bit test is done to see whether the bias bit is still\n-\/\/ set. If not, we fall back to HotSpot's original CAS-based locking\n-\/\/ scheme. If it is set, we attempt to CAS in a bias toward this\n-\/\/ thread. The latter operation is expected to be the rarest operation\n-\/\/ performed on these locks. We optimistically expect the biased lock\n-\/\/ entry to hit most of the time, and want the CAS-based fallthrough\n-\/\/ to occur quickly in the situations where the bias has been revoked.\n-\/\/\n-\/\/ Revocation of the lock's bias is fairly straightforward. We want to\n-\/\/ restore the object's header and stack-based BasicObjectLocks and\n-\/\/ BasicLocks to the state they would have been in had the object been\n-\/\/ locked by HotSpot's usual fast locking scheme. To do this, we execute\n-\/\/ a handshake with the JavaThread that biased the lock. Inside the\n-\/\/ handshake we walk the biaser stack searching for all of the lock\n-\/\/ records corresponding to this object, in particular the first \/ \"highest\"\n-\/\/ record. We fill in the highest lock record with the object's displaced\n-\/\/ header (which is a well-known value given that we don't maintain an\n-\/\/ identity hash nor age bits for the object while it's in the biased\n-\/\/ state) and all other lock records with 0, the value for recursive locks.\n-\/\/ Alternatively, we can revoke the bias of an object inside a safepoint\n-\/\/ if we are already in one and we detect that we need to perform a\n-\/\/ revocation.\n-\/\/\n-\/\/ This scheme can not handle transfers of biases of single objects\n-\/\/ from thread to thread efficiently, but it can handle bulk transfers\n-\/\/ of such biases, which is a usage pattern showing up in some\n-\/\/ applications and benchmarks. We implement \"bulk rebias\" and \"bulk\n-\/\/ revoke\" operations using a \"bias epoch\" on a per-data-type basis.\n-\/\/ If too many bias revocations are occurring for a particular data\n-\/\/ type, the bias epoch for the data type is incremented at a\n-\/\/ safepoint, effectively meaning that all previous biases are\n-\/\/ invalid. The fast path locking case checks for an invalid epoch in\n-\/\/ the object header and attempts to rebias the object with a CAS if\n-\/\/ found, avoiding safepoints or bulk heap sweeps (the latter which\n-\/\/ was used in a prior version of this algorithm and did not scale\n-\/\/ well). If too many bias revocations persist, biasing is completely\n-\/\/ disabled for the data type by resetting the prototype header to the\n-\/\/ unbiased markWord. The fast-path locking code checks to see whether\n-\/\/ the instance's bias pattern differs from the prototype header's and\n-\/\/ causes the bias to be revoked without reaching a safepoint or,\n-\/\/ again, a bulk heap sweep.\n-\n-\/\/ Biased locking counters\n-class BiasedLockingCounters {\n- private:\n-  int _total_entry_count;\n-  int _biased_lock_entry_count;\n-  int _anonymously_biased_lock_entry_count;\n-  int _rebiased_lock_entry_count;\n-  int _revoked_lock_entry_count;\n-  int _handshakes_count;\n-  int _fast_path_entry_count;\n-  int _slow_path_entry_count;\n-\n- public:\n-  BiasedLockingCounters() :\n-    _total_entry_count(0),\n-    _biased_lock_entry_count(0),\n-    _anonymously_biased_lock_entry_count(0),\n-    _rebiased_lock_entry_count(0),\n-    _revoked_lock_entry_count(0),\n-    _handshakes_count(0),\n-    _fast_path_entry_count(0),\n-    _slow_path_entry_count(0) {}\n-\n-  int slow_path_entry_count() const; \/\/ Compute this field if necessary\n-\n-  int* total_entry_count_addr()                   { return &_total_entry_count; }\n-  int* biased_lock_entry_count_addr()             { return &_biased_lock_entry_count; }\n-  int* anonymously_biased_lock_entry_count_addr() { return &_anonymously_biased_lock_entry_count; }\n-  int* rebiased_lock_entry_count_addr()           { return &_rebiased_lock_entry_count; }\n-  int* revoked_lock_entry_count_addr()            { return &_revoked_lock_entry_count; }\n-  int* handshakes_count_addr()                    { return &_handshakes_count; }\n-  int* fast_path_entry_count_addr()               { return &_fast_path_entry_count; }\n-  int* slow_path_entry_count_addr()               { return &_slow_path_entry_count; }\n-\n-  bool nonzero() { return _total_entry_count > 0; }\n-\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-};\n-\n-\n-class BiasedLocking : AllStatic {\n-friend class VM_BulkRevokeBias;\n-friend class RevokeOneBias;\n-\n-private:\n-  static BiasedLockingCounters _counters;\n-\n-public:\n-  static int* total_entry_count_addr();\n-  static int* biased_lock_entry_count_addr();\n-  static int* anonymously_biased_lock_entry_count_addr();\n-  static int* rebiased_lock_entry_count_addr();\n-  static int* revoked_lock_entry_count_addr();\n-  static int* handshakes_count_addr();\n-  static int* fast_path_entry_count_addr();\n-  static int* slow_path_entry_count_addr();\n-\n-  enum Condition {\n-    NOT_BIASED = 1,\n-    BIAS_REVOKED = 2,\n-    NOT_REVOKED = 3\n-  };\n-\n-private:\n-  static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);\n-  static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);\n-  static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);\n-  static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);\n-\n-public:\n-  \/\/ This initialization routine should only be called once and\n-  \/\/ schedules a PeriodicTask to turn on biased locking a few seconds\n-  \/\/ into the VM run to avoid startup time regressions\n-  static void init();\n-\n-  \/\/ This provides a global switch for leaving biased locking disabled\n-  \/\/ for the first part of a run and enabling it later\n-  static bool enabled();\n-\n-  \/\/ This should be called by JavaThreads to revoke the bias of an object\n-  static void revoke(JavaThread* current, Handle obj);\n-\n-  \/\/ This must only be called by a JavaThread to revoke the bias of an owned object.\n-  static void revoke_own_lock(JavaThread* current, Handle obj);\n-\n-  static void revoke_at_safepoint(Handle obj);\n-\n-  \/\/ These are used by deoptimization to ensure that monitors on the stack\n-  \/\/ can be migrated\n-  static void revoke(GrowableArray<Handle>* objs, JavaThread *biaser);\n-\n-  static void print_counters() { _counters.print(); }\n-  static BiasedLockingCounters* counters() { return &_counters; }\n-\n-  \/\/ These routines are GC-related and should not be called by end\n-  \/\/ users. GCs which do not do preservation of mark words do not need\n-  \/\/ to call these routines.\n-  static void preserve_marks();\n-  static void restore_marks();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_BIASEDLOCKING_HPP\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -314,3 +313,0 @@\n-  \/\/ Revoke biases of objects with eliminated locks in the given frame.\n-  Deoptimization::revoke_for_object_deoptimization(deoptee_thread, deoptee, &map, thread);\n-\n@@ -386,4 +382,0 @@\n-  \/\/ Revoke biases, done with in java state.\n-  \/\/ No safepoints allowed after this\n-  revoke_from_deopt_handler(current, deoptee, &map);\n-\n@@ -872,1 +864,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n@@ -1445,10 +1437,1 @@\n-        if (UseBiasedLocking && mark.has_bias_pattern()) {\n-          \/\/ New allocated objects may have the mark set to anonymously biased.\n-          \/\/ Also the deoptimized method may called methods with synchronization\n-          \/\/ where the thread-local object is bias locked to the current thread.\n-          assert(mark.is_biased_anonymously() ||\n-                 mark.biased_locker() == deoptee_thread, \"should be locked to current thread\");\n-          \/\/ Reset mark word to unbiased prototype.\n-          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n-          obj->set_mark(unbiased_prototype);\n-        } else if (exec_mode == Unpack_none) {\n+        if (exec_mode == Unpack_none) {\n@@ -1457,2 +1440,1 @@\n-            \/\/ a callee frame. In this case the bias was revoked before in revoke_for_object_deoptimization().\n-            \/\/ Make the lock in the callee a recursive lock and restore the displaced header.\n+            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n@@ -1598,92 +1580,0 @@\n-static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke,\n-                             bool only_eliminated) {\n-  GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n-  Thread* thread = Thread::current();\n-  for (int i = 0; i < monitors->length(); i++) {\n-    MonitorInfo* mon_info = monitors->at(i);\n-    if (mon_info->eliminated() == only_eliminated &&\n-        !mon_info->owner_is_scalar_replaced() &&\n-        mon_info->owner() != NULL) {\n-      objects_to_revoke->append(Handle(thread, mon_info->owner()));\n-    }\n-  }\n-}\n-\n-static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread,\n-                                    frame fr, RegisterMap* map, bool only_eliminated) {\n-  \/\/ Unfortunately we don't have a RegisterMap available in most of\n-  \/\/ the places we want to call this routine so we need to walk the\n-  \/\/ stack again to update the register map.\n-  if (map == NULL || !map->update_map()) {\n-    StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n-    bool found = false;\n-    while (!found && !sfs.is_done()) {\n-      frame* cur = sfs.current();\n-      sfs.next();\n-      found = cur->id() == fr.id();\n-    }\n-    assert(found, \"frame to be deoptimized not found on target thread's stack\");\n-    map = sfs.register_map();\n-  }\n-\n-  vframe* vf = vframe::new_vframe(&fr, map, thread);\n-  compiledVFrame* cvf = compiledVFrame::cast(vf);\n-  \/\/ Revoke monitors' biases in all scopes\n-  while (!cvf->is_top()) {\n-    collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-    cvf = compiledVFrame::cast(cvf->sender());\n-  }\n-  collect_monitors(cvf, objects_to_revoke, only_eliminated);\n-}\n-\n-void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  assert(thread == Thread::current(), \"should be\");\n-  ResourceMark rm(thread);\n-  HandleMark hm(thread);\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  get_monitors_from_stack(objects_to_revoke, thread, fr, map, false);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    BiasedLocking::revoke_own_lock(thread, objects_to_revoke->at(i));\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n-\/\/ Revoke the bias of objects with eliminated locking to prepare subsequent relocking.\n-void Deoptimization::revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                                      RegisterMap* map, JavaThread* thread) {\n-  if (!UseBiasedLocking) {\n-    return;\n-  }\n-  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n-  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n-  \/\/ Collect monitors but only those with eliminated locking.\n-  get_monitors_from_stack(objects_to_revoke, deoptee_thread, fr, map, true);\n-\n-  int len = objects_to_revoke->length();\n-  for (int i = 0; i < len; i++) {\n-    oop obj = (objects_to_revoke->at(i))();\n-    markWord mark = obj->mark();\n-    if (!mark.has_bias_pattern() ||\n-        mark.is_biased_anonymously() || \/\/ eliminated locking does not bias an object if it wasn't before\n-        !obj->klass()->prototype_header().has_bias_pattern() || \/\/ bulk revoke ignores eliminated monitors\n-        (obj->klass()->prototype_header().bias_epoch() != mark.bias_epoch())) { \/\/ bulk rebias ignores eliminated monitors\n-      \/\/ We reach here regularly if there's just eliminated locking on obj.\n-      \/\/ We must not call BiasedLocking::revoke_own_lock() in this case, as we\n-      \/\/ would hit assertions because it is a prerequisite that there has to be\n-      \/\/ non-eliminated locking on obj by deoptee_thread.\n-      \/\/ Luckily we don't have to revoke here because obj has to be a\n-      \/\/ non-escaping obj and can be relocked without revoking the bias. See\n-      \/\/ Deoptimization::relock_objects().\n-      continue;\n-    }\n-    BiasedLocking::revoke(thread, objects_to_revoke->at(i));\n-    assert(!objects_to_revoke->at(i)->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-}\n-\n@@ -1926,1 +1816,0 @@\n-  \/\/ We need to update the map if we have biased locking.\n@@ -1931,1 +1820,1 @@\n-  RegisterMap reg_map(current, UseBiasedLocking);\n+  RegisterMap reg_map(current, false);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":115,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -155,7 +155,0 @@\n- private:\n-  \/\/ Revoke biased locks at deopt.\n-  static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);\n-\n-  static void revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n-                                               RegisterMap* map, JavaThread* thread);\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,2 +113,0 @@\n-  assert(!f->is_internal(), \"regular Java fields only\");\n-\n@@ -128,1 +126,2 @@\n-    assert(_index < field_holder()->java_fields_count(), \"oob\");\n+    assert(access_flags().is_internal() ||\n+           _index < field_holder()->java_fields_count(), \"oob\");\n@@ -136,0 +135,1 @@\n+  if (access_flags().is_internal()) st->print(\"internal \");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,56 +68,0 @@\n-JVMFlag::Error BiasedLockingBulkRebiasThresholdFunc(intx value, bool verbose) {\n-  if (value > BiasedLockingBulkRevokeThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRevokeThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingStartupDelayFunc(intx value, bool verbose) {\n-  if ((value % PeriodicTask::interval_gran) != 0) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingStartupDelay (\" INTX_FORMAT \") must be \"\n-                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n-                        value, PeriodicTask::interval_gran);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingBulkRevokeThresholdFunc(intx value, bool verbose) {\n-  if (value < BiasedLockingBulkRebiasThreshold) {\n-    JVMFlag::printError(verbose,\n-                        \"BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else if ((double)value\/(double)BiasedLockingDecayTime > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRevokeThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        value, BiasedLockingBulkRebiasThreshold);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error BiasedLockingDecayTimeFunc(intx value, bool verbose) {\n-  if (BiasedLockingBulkRebiasThreshold\/(double)value > 0.1) {\n-    JVMFlag::printError(verbose,\n-                        \"The ratio of BiasedLockingBulkRebiasThreshold (\" INTX_FORMAT \")\"\n-                        \" to BiasedLockingDecayTime (\" INTX_FORMAT \") must be \"\n-                        \"less than or equal to 0.1\\n\",\n-                        BiasedLockingBulkRebiasThreshold, value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,0 @@\n-  f(intx,   BiasedLockingBulkRebiasThresholdFunc)     \\\n-  f(intx,   BiasedLockingStartupDelayFunc)            \\\n-  f(intx,   BiasedLockingBulkRevokeThresholdFunc)     \\\n-  f(intx,   BiasedLockingDecayTimeFunc)               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-  \/\/ native methods so that biased locking can revoke the receiver's\n-  \/\/ bias if necessary.  This is also used by JVMTI's GetLocalInstance method\n+  \/\/ native methods. Used by JVMTI's GetLocalInstance method\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -456,1 +456,2 @@\n-          \"Use only malloc\/free for allocation (no resource area\/arena)\")   \\\n+          \"Use only malloc\/free for allocation (no resource area\/arena). \"  \\\n+          \"Used to help diagnose memory stomping bugs.\")                    \\\n@@ -680,5 +681,0 @@\n-  product(bool, AlwaysLockClassLoader, false,                               \\\n-          \"(Deprecated) Require the VM to acquire the class loader lock \"   \\\n-          \"before calling loadClass() even for class loaders registering \"  \\\n-          \"as parallel capable\")                                            \\\n-                                                                            \\\n@@ -730,2 +726,2 @@\n-          \"When true prevents OS-level spurious, or premature, wakeups \"    \\\n-          \"from Object.wait (Ignored for Windows)\")                         \\\n+          \"(Deprecated) When true prevents OS-level spurious, or premature,\"\\\n+          \" wakeups from Object.wait (Ignored for Windows)\")                \\\n@@ -802,31 +798,0 @@\n-  product(bool, UseBiasedLocking, false,                                    \\\n-          \"(Deprecated) Enable biased locking in JVM\")                      \\\n-                                                                            \\\n-  product(intx, BiasedLockingStartupDelay, 0,                               \\\n-          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n-          \"biased locking\")                                                 \\\n-          range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \\\n-          constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \\\n-                                                                            \\\n-  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n-          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"try to rebias all objects in the heap of that type\")             \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \\\n-          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n-          \"permanently revoke biases of all objects in the heap of that \"   \\\n-          \"type\")                                                           \\\n-          range(0, max_intx)                                                \\\n-          constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \\\n-                                                                            \\\n-  product(intx, BiasedLockingDecayTime, 25000,                              \\\n-          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n-          \"rebiasing of a type after previous bulk rebias\")                 \\\n-          range(500, max_intx)                                              \\\n-          constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":39,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -195,5 +195,2 @@\n-#ifdef ASSERT\n-    oop* handle = (oop*) (UseMallocOnly ? internal_malloc_4(oopSize) : Amalloc_4(oopSize));\n-#else\n-    oop* handle = (oop*) Amalloc_4(oopSize);\n-#endif\n+    \/\/ Ignore UseMallocOnly by allocating only in arena.\n+    oop* handle = (oop*)internal_amalloc(oopSize);\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-        wait_blocked(self->as_Java_thread(), now);\n+        wait_blocked(JavaThread::cast(self), now);\n@@ -304,1 +304,1 @@\n-    StackWatermarkSet::start_processing(_requester->as_Java_thread(), StackWatermarkKind::gc);\n+    StackWatermarkSet::start_processing(JavaThread::cast(_requester), StackWatermarkKind::gc);\n@@ -632,1 +632,1 @@\n-    JavaThread* current = thr->as_Java_thread();\n+    JavaThread* current = JavaThread::cast(thr);\n@@ -640,2 +640,2 @@\n-  if (_handshakee->is_exiting() ||\n-     _handshakee->threadObj() == NULL) {\n+  assert(_handshakee->threadObj() != NULL, \"cannot suspend with a NULL threadObj\");\n+  if (_handshakee->is_exiting()) {\n@@ -676,1 +676,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  JavaThread *current_thread = thread->as_Java_thread();\n+  JavaThread *current_thread = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-      JavaThread* t2 = t->as_Java_thread();\n+      JavaThread* t2 = JavaThread::cast(t);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -250,1 +249,1 @@\n-  if (PrintLockStatistics || PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintLockStatistics || PrintPreciseRTMLockingStatistics) {\n@@ -336,4 +335,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n-\n@@ -378,1 +373,1 @@\n-  if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintPreciseRTMLockingStatistics) {\n@@ -382,3 +377,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    BiasedLocking::print_counters();\n-  }\n@@ -513,1 +505,1 @@\n-    DynamicArchive::dump();\n+    DynamicArchive::dump(thread);\n@@ -564,1 +556,1 @@\n-      thread->as_Java_thread()->set_thread_state(_thread_in_vm);\n+      JavaThread::cast(thread)->set_thread_state(_thread_in_vm);\n@@ -612,1 +604,1 @@\n-      JavaThread* jt = thread->as_Java_thread();\n+      JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-           is_frame_handle(thread->as_Java_thread(), handle))) {\n+           is_frame_handle(JavaThread::cast(thread), handle))) {\n@@ -305,1 +305,1 @@\n-          thread->as_Java_thread()->thread_state() == _thread_in_native);\n+          JavaThread::cast(thread)->thread_state() == _thread_in_native);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-MonitorDeflationThread* MonitorDeflationThread::_instance = NULL;\n-\n@@ -42,14 +40,1 @@\n-  Handle string = java_lang_String::create_from_str(name, CHECK);\n-\n-  \/\/ Initialize thread_oop to put it into the system threadGroup\n-  Handle thread_group (THREAD, Universe::system_thread_group());\n-  Handle thread_oop = JavaCalls::construct_new_instance(\n-                          vmClasses::Thread_klass(),\n-                          vmSymbols::threadgroup_string_void_signature(),\n-                          thread_group,\n-                          string,\n-                          CHECK);\n-\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    MonitorDeflationThread* thread =  new MonitorDeflationThread(&monitor_deflation_thread_entry);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n@@ -57,14 +42,2 @@\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n-\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n+  MonitorDeflationThread* thread = new MonitorDeflationThread(&monitor_deflation_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -72,3 +45,1 @@\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":4,"deletions":33,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-  static MonitorDeflationThread* _instance;\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    thread->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(thread)->check_for_valid_safepoint_state();\n@@ -88,1 +88,1 @@\n-      { ThreadBlockInVM tbivmdc(self->as_Java_thread(), &in_flight_mutex);\n+      { ThreadBlockInVM tbivmdc(JavaThread::cast(self), &in_flight_mutex);\n@@ -443,1 +443,1 @@\n-      new_owner->as_Java_thread()->inc_no_safepoint_count();\n+      JavaThread::cast(new_owner)->inc_no_safepoint_count();\n@@ -480,1 +480,1 @@\n-      old_owner->as_Java_thread()->dec_no_safepoint_count();\n+      JavaThread::cast(old_owner)->dec_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+Mutex*   UnregisteredClassesTable_lock= NULL;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+extern Mutex*   UnregisteredClassesTable_lock;   \/\/ UnregisteredClassesTableTable\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,2 +73,4 @@\n-\/\/ Name support for threads.  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n+\/\/ A base class for non-JavaThread subclasses with multiple\n+\/\/ uniquely named instances. NamedThreads also provide a common\n+\/\/ location to store GC information needed by GC threads\n+\/\/ and the VMThread.\n@@ -92,1 +94,2 @@\n-  virtual char* name() const { return _name == NULL ? (char*)\"Unknown Thread\" : _name; }\n+  virtual const char* name() const { return _name == NULL ? \"Unknown Thread\" : _name; }\n+  virtual const char* type_name() const { return \"NamedThread\"; }\n@@ -120,0 +123,4 @@\n+\n+  \/\/ Printing\n+  virtual const char* type_name() const { return \"WorkerThread\"; }\n+\n@@ -135,0 +142,1 @@\n+\n@@ -151,1 +159,2 @@\n-  char* name() const { return (char*)\"VM Periodic Task Thread\"; }\n+  const char* name() const { return \"VM Periodic Task Thread\"; }\n+  const char* type_name() const { return \"WatcherThread\"; }\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-NotificationThread* NotificationThread::_instance = NULL;\n-\n@@ -44,10 +42,1 @@\n-  Handle string = java_lang_String::create_from_str(name, CHECK);\n-\n-  \/\/ Initialize thread_oop to put it into the system threadGroup\n-  Handle thread_group (THREAD, Universe::system_thread_group());\n-  Handle thread_oop = JavaCalls::construct_new_instance(\n-                          vmClasses::Thread_klass(),\n-                          vmSymbols::threadgroup_string_void_signature(),\n-                          thread_group,\n-                          string,\n-                          CHECK);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, true \/* visible *\/, CHECK);\n@@ -55,21 +44,2 @@\n-  Klass* group = vmClasses::ThreadGroup_klass();\n-  JavaValue result(T_VOID);\n-  JavaCalls::call_special(&result,\n-                          thread_group,\n-                          group,\n-                          vmSymbols::add_method_name(),\n-                          vmSymbols::thread_void_signature(),\n-                          thread_oop,\n-                          THREAD);\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    NotificationThread* thread =  new NotificationThread(&notification_thread_entry);\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n+   NotificationThread* thread = new NotificationThread(&notification_thread_entry);\n+   JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -77,9 +47,1 @@\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n-\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+   JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n@@ -131,1 +93,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.cpp","additions":4,"deletions":43,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-  static NotificationThread* _instance;\n-\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    JavaThread* jt = self->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(self);\n@@ -488,1 +488,1 @@\n-    event.set_previousOwner((uintptr_t)_previous_owner_tid);\n+    event.set_previousOwner(_previous_owner_tid);\n@@ -548,1 +548,1 @@\n-    _contentions = -max_jint;\n+    _contentions = INT_MIN; \/\/ minimum negative int\n@@ -575,1 +575,1 @@\n-    if (Atomic::cmpxchg(&_contentions, (jint)0, -max_jint) != 0) {\n+    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n@@ -1434,1 +1434,1 @@\n-                                    jlong notifier_tid,\n+                                    uint64_t notifier_tid,\n@@ -2246,1 +2246,1 @@\n-  st->print_cr(\"  _previous_owner_tid = \" JLONG_FORMAT, _previous_owner_tid);\n+  st->print_cr(\"  _previous_owner_tid = \" UINT64_FORMAT, _previous_owner_tid);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  jlong         _notifier_tid;\n+  uint64_t      _notifier_tid;\n@@ -151,1 +151,1 @@\n-  volatile jlong _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n+  volatile uint64_t _previous_owner_tid;  \/\/ thread id of the previous owner of the monitor\n@@ -157,1 +157,1 @@\n-                        sizeof(volatile jlong));\n+                        sizeof(volatile uint64_t));\n@@ -171,1 +171,1 @@\n-  jint  _contentions;               \/\/ Number of active contentions in enter(). It is used by is_busy()\n+  int _contentions;                 \/\/ Number of active contentions in enter(). It is used by is_busy()\n@@ -177,1 +177,1 @@\n-  volatile jint  _waiters;          \/\/ number of waiting threads\n+  volatile int  _waiters;           \/\/ number of waiting threads\n@@ -241,3 +241,4 @@\n-    intptr_t ret_code = _waiters | intptr_t(_cxq) | intptr_t(_EntryList);\n-    if (contentions() > 0) {\n-      ret_code |= contentions();\n+    intptr_t ret_code = intptr_t(_waiters) | intptr_t(_cxq) | intptr_t(_EntryList);\n+    int cnts = contentions(); \/\/ read once\n+    if (cnts > 0) {\n+      ret_code |= intptr_t(cnts);\n@@ -284,1 +285,1 @@\n-  jint      waiters() const;\n+  int       waiters() const;\n@@ -286,2 +287,2 @@\n-  jint      contentions() const;\n-  void      add_to_contentions(jint value);\n+  int       contentions() const;\n+  void      add_to_contentions(int value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-inline jint ObjectMonitor::waiters() const {\n+inline int ObjectMonitor::waiters() const {\n@@ -82,1 +82,1 @@\n-inline jint ObjectMonitor::contentions() const {\n+inline int ObjectMonitor::contentions() const {\n@@ -87,1 +87,1 @@\n-inline void ObjectMonitor::add_to_contentions(jint value) {\n+inline void ObjectMonitor::add_to_contentions(int value) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-        VM_PrintThreads op;\n+        VM_PrintThreads op(tty, PrintConcurrentLocks, false \/* no extended info *\/, true \/* print JNI handle info *\/);\n@@ -404,2 +404,0 @@\n-        VM_PrintJNI jni_op;\n-        VMThread::execute(&jni_op);\n@@ -474,32 +472,2 @@\n-    const char thread_name[] = \"Signal Dispatcher\";\n-    Handle string = java_lang_String::create_from_str(thread_name, CHECK);\n-\n-    \/\/ Initialize thread_oop to put it into the system threadGroup\n-    Handle thread_group (THREAD, Universe::system_thread_group());\n-    Handle thread_oop = JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n-                           vmSymbols::threadgroup_string_void_signature(),\n-                           thread_group,\n-                           string,\n-                           CHECK);\n-\n-    Klass* group = vmClasses::ThreadGroup_klass();\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_special(&result,\n-                            thread_group,\n-                            group,\n-                            vmSymbols::add_method_name(),\n-                            vmSymbols::thread_void_signature(),\n-                            thread_oop,\n-                            CHECK);\n-\n-    { MutexLocker mu(THREAD, Threads_lock);\n-      JavaThread* signal_thread = new JavaThread(&signal_thread_entry);\n-\n-      \/\/ At this point it may be possible that no osthread was created for the\n-      \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-      \/\/ in that case. However, since this must work and we do not allow\n-      \/\/ exceptions anyway, check and abort if this fails.\n-      if (signal_thread == NULL || signal_thread->osthread() == NULL) {\n-        vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                      os::native_thread_creation_failed_msg());\n-      }\n+    const char* name = \"Signal Dispatcher\";\n+    Handle thread_oop = JavaThread::create_system_thread_object(name, true \/* visible *\/, CHECK);\n@@ -507,3 +475,4 @@\n-      java_lang_Thread::set_thread(thread_oop(), signal_thread);\n-      java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-      java_lang_Thread::set_daemon(thread_oop());\n+    JavaThread* thread = new JavaThread(&signal_thread_entry);\n+    JavaThread::vm_exit_on_osthread_failure(thread);\n+\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n@@ -511,4 +480,0 @@\n-      signal_thread->set_threadObj(thread_oop());\n-      Threads::add(signal_thread);\n-      Thread::start(signal_thread);\n-    }\n@@ -1472,1 +1437,1 @@\n-  address limit = thread->as_Java_thread()->stack_end() +\n+  address limit = JavaThread::cast(thread)->stack_end() +\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":8,"deletions":43,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -281,4 +281,0 @@\n-  \/\/ Binds the current process to a processor.\n-  \/\/    Returns true if it worked, false if it didn't.\n-  static bool bind_to_processor(uint processor_id);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  st->print(\"nid=0x%x \", thread_id());\n+  st->print(\"nid=\" UINT64_FORMAT \" \", (uint64_t)thread_id());\n","filename":"src\/hotspot\/share\/runtime\/osThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-      StackWatermarkSet::start_processing(thread->as_Java_thread(), StackWatermarkKind::gc);\n+      StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    _thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_thread)->inc_no_safepoint_count();\n@@ -42,1 +42,1 @@\n-    _thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_thread)->dec_no_safepoint_count();\n@@ -50,1 +50,1 @@\n-    _nsv->_thread->as_Java_thread()->dec_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->dec_no_safepoint_count();\n@@ -56,1 +56,1 @@\n-    _nsv->_thread->as_Java_thread()->inc_no_safepoint_count();\n+    JavaThread::cast(_nsv->_thread)->inc_no_safepoint_count();\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-ServiceThread* ServiceThread::_instance = NULL;\n+DEBUG_ONLY(JavaThread* ServiceThread::_instance = NULL;)\n@@ -95,1 +95,1 @@\n-  Handle string = java_lang_String::create_from_str(name, CHECK);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n@@ -97,8 +97,2 @@\n-  \/\/ Initialize thread_oop to put it into the system threadGroup\n-  Handle thread_group (THREAD, Universe::system_thread_group());\n-  Handle thread_oop = JavaCalls::construct_new_instance(\n-                          vmClasses::Thread_klass(),\n-                          vmSymbols::threadgroup_string_void_signature(),\n-                          thread_group,\n-                          string,\n-                          CHECK);\n+  ServiceThread* thread = new ServiceThread(&service_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -106,22 +100,2 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    ServiceThread* thread =  new ServiceThread(&service_thread_entry);\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n-\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n-\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n+  DEBUG_ONLY(_instance = thread;)\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static ServiceThread* _instance;\n+  DEBUG_ONLY(static JavaThread* _instance;)\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -144,1 +143,0 @@\n-int SharedRuntime::_throw_null_ctr = 0;\n@@ -159,1 +157,0 @@\n-int SharedRuntime::_multi1_ctr=0;\n@@ -995,1 +992,1 @@\n-      oop obj = thread->as_Java_thread()->threadObj();\n+      oop obj = JavaThread::cast(thread)->threadObj();\n@@ -2121,3 +2118,0 @@\n-  if (PrintBiasedLockingStatistics) {\n-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());\n-  }\n@@ -2161,2 +2155,0 @@\n-  if (_throw_null_ctr) tty->print_cr(\"%5d implicit null throw\", _throw_null_ctr);\n-\n@@ -2168,1 +2160,0 @@\n-  if (_multi1_ctr) tty->print_cr(\"%5d multianewarray 1 dim\", _multi1_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -537,1 +537,0 @@\n-  static int _throw_null_ctr;                    \/\/ throwing a null-pointer exception\n@@ -558,1 +557,1 @@\n-  static int _multi1_ctr, _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    JavaThread* jt = thread->as_Java_thread();\n+    JavaThread* jt = JavaThread::cast(thread);\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-      thread->as_Java_thread()->nmethods_do(_cl);\n+      JavaThread::cast(thread)->nmethods_do(_cl);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -130,1 +129,1 @@\n-      ObjectSynchronizer::chk_for_block_req(current->as_Java_thread(), \"unlinking\",\n+      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"unlinking\",\n@@ -303,1 +302,1 @@\n-  \/\/ biased locking and any other IMS exception states take the slow-path\n+  \/\/ other IMS exception states take the slow-path\n@@ -352,2 +351,1 @@\n-    \/\/ Biased Locking in the object's header, the second check is for\n-    \/\/ stack-locking in the object's header, the third check is for\n+    \/\/ stack-locking in the object's header, the second check is for\n@@ -367,1 +365,0 @@\n-  \/\/ -- perform bias revocation, or\n@@ -434,4 +431,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-  }\n-\n@@ -439,2 +432,0 @@\n-  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n-\n@@ -475,3 +466,0 @@\n-  \/\/ We cannot check for Biased Locking if we are racing an inflation.\n-  assert(mark == markWord::INFLATING() ||\n-         !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -538,5 +526,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -552,5 +535,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -578,4 +556,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -598,6 +572,0 @@\n-  if (UseBiasedLocking) {\n-    Handle h_obj(current, obj);\n-    BiasedLocking::revoke(current, h_obj);\n-    obj = h_obj();\n-  }\n-  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -641,4 +609,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -667,4 +631,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -680,4 +640,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -699,4 +655,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, obj);\n-    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n@@ -732,1 +684,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -739,1 +691,1 @@\n-    markWord mark = obj->mark();\n+    markWord mark = obj->mark_acquire();\n@@ -773,1 +725,1 @@\n-        while (obj->mark() == markWord::INFLATING()) {\n+        while (obj->mark_acquire() == markWord::INFLATING()) {\n@@ -849,19 +801,0 @@\n-  if (UseBiasedLocking) {\n-    \/\/ NOTE: many places throughout the JVM do not expect a safepoint\n-    \/\/ to be taken here. However, we only ever bias Java instances and all\n-    \/\/ of the call sites of identity_hash that might revoke biases have\n-    \/\/ been checked to make sure they can handle a safepoint. The\n-    \/\/ added check of the bias pattern is to avoid useless calls to\n-    \/\/ thread-local storage.\n-    if (obj->mark().has_bias_pattern()) {\n-      \/\/ Handle for oop obj in case of STW safepoint\n-      Handle hobj(current, obj);\n-      if (SafepointSynchronize::is_at_safepoint()) {\n-        BiasedLocking::revoke_at_safepoint(hobj);\n-      } else {\n-        BiasedLocking::revoke(current->as_Java_thread(), hobj);\n-      }\n-      obj = hobj();\n-      assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-    }\n-  }\n@@ -875,3 +808,0 @@\n-    \/\/ object should remain ineligible for biased locking\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n-\n@@ -988,5 +918,0 @@\n-  if (UseBiasedLocking) {\n-    BiasedLocking::revoke(current, h_obj);\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1016,9 +941,0 @@\n-  if (UseBiasedLocking) {\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke_at_safepoint(h_obj);\n-    } else {\n-      BiasedLocking::revoke(JavaThread::current(), h_obj);\n-    }\n-    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n-  }\n-\n@@ -1189,1 +1105,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -1204,2 +1120,1 @@\n-    const markWord mark = object->mark();\n-    assert(!mark.has_bias_pattern(), \"invariant\");\n+    const markWord mark = object->mark_acquire();\n@@ -1212,1 +1127,0 @@\n-    \/\/ *  BIASED       - Illegal.  We should never see this\n@@ -1420,1 +1334,1 @@\n-      chk_for_block_req(current->as_Java_thread(), \"deflation\", \"deflated_count\",\n+      chk_for_block_req(JavaThread::cast(current), \"deflation\", \"deflated_count\",\n@@ -1510,1 +1424,1 @@\n-        chk_for_block_req(current->as_Java_thread(), \"deletion\", \"deleted_count\",\n+        chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":96,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  ~PeriodicTask();\n+  virtual ~PeriodicTask();\n","filename":"src\/hotspot\/share\/runtime\/task.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -166,1 +165,1 @@\n-      const char* name = (javathread)->get_thread_name();                  \\\n+      const char* name = (javathread)->name();                             \\\n@@ -187,1 +186,0 @@\n-\/\/ Support for forcing alignment of thread objects for biased locking\n@@ -189,19 +187,1 @@\n-  if (UseBiasedLocking) {\n-    const size_t alignment = markWord::biased_lock_alignment;\n-    size_t aligned_size = size + (alignment - sizeof(intptr_t));\n-    void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)\n-                                          : AllocateHeap(aligned_size, flags, CURRENT_PC,\n-                                                         AllocFailStrategy::RETURN_NULL);\n-    void* aligned_addr     = align_up(real_malloc_addr, alignment);\n-    assert(((uintptr_t) aligned_addr + (uintptr_t) size) <=\n-           ((uintptr_t) real_malloc_addr + (uintptr_t) aligned_size),\n-           \"JavaThread alignment code overflowed allocated storage\");\n-    if (aligned_addr != real_malloc_addr) {\n-      log_info(biasedlocking)(\"Aligned thread \" INTPTR_FORMAT \" to \" INTPTR_FORMAT,\n-                              p2i(real_malloc_addr),\n-                              p2i(aligned_addr));\n-    }\n-    ((Thread*) aligned_addr)->_real_malloc_address = real_malloc_addr;\n-    return aligned_addr;\n-  } else {\n-    return throw_excpt? AllocateHeap(size, flags, CURRENT_PC)\n+  return throw_excpt ? AllocateHeap(size, flags, CURRENT_PC)\n@@ -209,1 +189,0 @@\n-  }\n@@ -213,5 +192,1 @@\n-  if (UseBiasedLocking) {\n-    FreeHeap(((Thread*) p)->_real_malloc_address);\n-  } else {\n-    FreeHeap(p);\n-  }\n+  FreeHeap(p);\n@@ -291,8 +266,0 @@\n-#ifdef ASSERT\n-  if (UseBiasedLocking) {\n-    assert(is_aligned(this, markWord::biased_lock_alignment), \"forced alignment of thread object failed\");\n-    assert(this == _real_malloc_address ||\n-           this == align_up(_real_malloc_address, markWord::biased_lock_alignment),\n-           \"bug in forced alignment of thread objects\");\n-  }\n-#endif \/\/ ASSERT\n@@ -352,1 +319,1 @@\n-    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n+    JavaThread::cast(this)->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -464,2 +431,2 @@\n-         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n-         !thread->as_Java_thread()->on_thread_list() ||\n+         JavaThread::cast(thread)->is_handshake_safe_for(Thread::current()) ||\n+         !JavaThread::cast(thread)->on_thread_list() ||\n@@ -467,1 +434,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(JavaThread::cast(thread)),\n@@ -482,0 +449,7 @@\n+  \/\/ If the target hasn't been started yet then it is trivially\n+  \/\/ \"protected\". We assume the caller is the thread that will do\n+  \/\/ the starting.\n+  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+    return true;\n+  }\n+\n@@ -539,1 +513,1 @@\n-    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+    java_lang_Thread::set_thread_status(JavaThread::cast(thread)->threadObj(),\n@@ -645,9 +619,1 @@\n-  if (is_VM_thread())                 { st->print(\"VMThread\"); }\n-  else if (is_GC_task_thread())       { st->print(\"GCTaskThread\"); }\n-  else if (is_Watcher_thread())       { st->print(\"WatcherThread\"); }\n-  else if (is_ConcurrentGC_thread())  { st->print(\"ConcurrentGCThread\"); }\n-  else                                { st->print(\"Thread\"); }\n-\n-  if (is_Named_thread()) {\n-    st->print(\" \\\"%s\\\"\", name());\n-  }\n+  st->print(\"%s \\\"%s\\\"\", type_name(), name());\n@@ -706,1 +672,1 @@\n-  return os::create_main_thread(this->as_Java_thread());\n+  return os::create_main_thread(JavaThread::cast(this));\n@@ -1082,1 +1048,0 @@\n-  _cached_monitor_info(nullptr),\n@@ -1302,1 +1267,1 @@\n-      this->set_native_thread_name(this->get_thread_name());\n+      this->set_native_thread_name(this->name());\n@@ -1381,1 +1346,1 @@\n-                    get_thread_name());\n+                    name());\n@@ -1486,1 +1451,1 @@\n-    thread_name = os::strdup(get_thread_name());\n+    thread_name = os::strdup(name());\n@@ -1554,1 +1519,1 @@\n-    return thread->as_Java_thread();\n+    return JavaThread::cast(thread);\n@@ -1558,1 +1523,1 @@\n-    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n@@ -1716,1 +1681,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n@@ -2096,1 +2061,1 @@\n-  st->print_raw(get_thread_name());\n+  st->print_raw(name());\n@@ -2134,1 +2099,1 @@\n-  st->print(\"JavaThread \\\"%s\\\"\", get_thread_name_string(buf, buflen));\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n@@ -2182,1 +2147,1 @@\n-const char* JavaThread::get_thread_name() const {\n+const char* JavaThread::name() const  {\n@@ -2193,1 +2158,1 @@\n-\/\/ descriptive string if there is no set name\n+\/\/ descriptive string if there is no set name.\n@@ -2208,1 +2173,1 @@\n-      name_str = Thread::name();\n+      name_str = \"<un-named>\";\n@@ -2217,0 +2182,13 @@\n+\/\/ Helper to extract the name from the thread oop for logging.\n+const char* JavaThread::name_for(oop thread_obj) {\n+  assert(thread_obj != NULL, \"precondition\");\n+  oop name = java_lang_Thread::name(thread_obj);\n+  const char* name_str;\n+  if (name != NULL) {\n+    name_str = java_lang_String::as_utf8_string(name);\n+  } else {\n+    name_str = \"<un-named>\";\n+  }\n+  return name_str;\n+}\n+\n@@ -3059,2 +3037,0 @@\n-  BiasedLocking::init();\n-\n@@ -3307,1 +3283,1 @@\n-  \/\/ it will cause MetaspaceShared::link_and_cleanup_shared_classes to\n+  \/\/ it will cause MetaspaceShared::link_shared_classes to\n@@ -3318,1 +3294,1 @@\n-    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n+    DynamicArchive::prepare_for_dynamic_dumping();\n@@ -3949,0 +3925,78 @@\n+\n+\/\/ Helper function to create the java.lang.Thread object for a\n+\/\/ VM-internal thread. The thread will have the given name, be\n+\/\/ part of the System ThreadGroup and if is_visible is true will be\n+\/\/ discoverable via the system ThreadGroup.\n+Handle JavaThread::create_system_thread_object(const char* name,\n+                                               bool is_visible, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n+\n+  \/\/ Initialize thread_oop to put it into the system threadGroup.\n+  \/\/ This is done by calling the Thread(ThreadGroup tg, String name)\n+  \/\/ constructor, which adds the new thread to the group as an unstarted\n+  \/\/ thread.\n+  Handle thread_group(THREAD, Universe::system_thread_group());\n+  Handle thread_oop =\n+    JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n+                                      vmSymbols::threadgroup_string_void_signature(),\n+                                      thread_group,\n+                                      string,\n+                                      CHECK_NH);\n+\n+  \/\/ If the Thread is intended to be visible then we have to mimic what\n+  \/\/ Thread.start() would do, by adding it to its ThreadGroup: tg.add(t).\n+  if (is_visible) {\n+    Klass* group = vmClasses::ThreadGroup_klass();\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_special(&result,\n+                            thread_group,\n+                            group,\n+                            vmSymbols::add_method_name(),\n+                            vmSymbols::thread_void_signature(),\n+                            thread_oop,\n+                            CHECK_NH);\n+  }\n+\n+  return thread_oop;\n+}\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadObj(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":121,"deletions":67,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -167,3 +166,0 @@\n-  \/\/ Support for forcing alignment of thread objects for biased locking\n-  void*       _real_malloc_address;\n-\n@@ -358,3 +354,5 @@\n-  \/\/ Casts\n-  inline JavaThread* as_Java_thread();\n-  inline const JavaThread* as_Java_thread() const;\n+  \/\/ All threads are given names. For singleton subclasses we can\n+  \/\/ just hard-wire the known name of the instance. JavaThreads and\n+  \/\/ NamedThreads support multiple named instances, and dynamic\n+  \/\/ changing of the name of an instance.\n+  virtual const char* name() const { return \"Unknown thread\"; }\n@@ -362,1 +360,3 @@\n-  virtual char* name() const { return (char*)\"Unknown thread\"; }\n+  \/\/ A thread's type name is also made available for debugging\n+  \/\/ and logging.\n+  virtual const char* type_name() const { return \"Thread\"; }\n@@ -578,0 +578,1 @@\n+  \/\/ Basic, non-virtual, printing support that is simple and always safe.\n@@ -1359,0 +1360,3 @@\n+  \/\/ factor out low-level mechanics for use in both normal and error cases\n+  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+\n@@ -1378,1 +1382,4 @@\n-  char* name() const { return (char*)get_thread_name(); }\n+  const char* name() const;\n+  const char* type_name() const { return \"JavaThread\"; }\n+  static const char* name_for(oop thread_obj);\n+\n@@ -1386,5 +1393,1 @@\n-  const char* get_thread_name() const;\n- protected:\n-  \/\/ factor out low-level mechanics for use in both normal and error cases\n-  virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n- public:\n+\n@@ -1425,1 +1428,4 @@\n-  static inline JavaThread* current();\n+  static JavaThread* current() {\n+    return JavaThread::cast(Thread::current());\n+  }\n+\n@@ -1429,0 +1435,11 @@\n+  \/\/ Casts\n+  static JavaThread* cast(Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n+    return static_cast<JavaThread*>(t);\n+  }\n+\n+  static const JavaThread* cast(const Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n+    return static_cast<const JavaThread*>(t);\n+  }\n+\n@@ -1558,3 +1575,0 @@\n-  \/\/ Biased locking support\n- private:\n-  GrowableArray<MonitorInfo*>* _cached_monitor_info;\n@@ -1562,3 +1576,0 @@\n-  GrowableArray<MonitorInfo*>* cached_monitor_info() { return _cached_monitor_info; }\n-  void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }\n-\n@@ -1591,1 +1602,0 @@\n-};\n@@ -1593,4 +1603,5 @@\n-\/\/ Inline implementation of JavaThread::current\n-inline JavaThread* JavaThread::current() {\n-  return Thread::current()->as_Java_thread();\n-}\n+  \/\/ Helper function to create the java.lang.Thread object for a\n+  \/\/ VM-internal thread. The thread will have the given name, be\n+  \/\/ part of the System ThreadGroup and if is_visible is true will be\n+  \/\/ discoverable via the system ThreadGroup.\n+  static Handle create_system_thread_object(const char* name, bool is_visible, TRAPS);\n@@ -1598,4 +1609,4 @@\n-inline JavaThread* JavaThread::current_or_null() {\n-  Thread* current = Thread::current_or_null();\n-  return current != nullptr ? current->as_Java_thread() : nullptr;\n-}\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n@@ -1603,4 +1614,4 @@\n-inline JavaThread* Thread::as_Java_thread() {\n-  assert(is_Java_thread(), \"incorrect cast to JavaThread\");\n-  return static_cast<JavaThread*>(this);\n-}\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+};\n@@ -1608,3 +1619,3 @@\n-inline const JavaThread* Thread::as_Java_thread() const {\n-  assert(is_Java_thread(), \"incorrect cast to const JavaThread\");\n-  return static_cast<const JavaThread*>(this);\n+inline JavaThread* JavaThread::current_or_null() {\n+  Thread* current = Thread::current_or_null();\n+  return current != nullptr ? JavaThread::cast(current) : nullptr;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":48,"deletions":37,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-          st->print(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n+          st->print_cr(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n@@ -577,1 +577,6 @@\n-    guarantee(_frame.is_compiled_frame(), \"expected compiled Java frame\");\n+    compiledVFrame* cvf;\n+    if (_frame.is_native_frame()) {\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&_frame, &_reg_map, _thread));\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n+    } else {\n+      assert(_frame.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -579,4 +584,4 @@\n-    \/\/ lazy update to register map\n-    bool update_map = true;\n-    RegisterMap map(_thread, update_map);\n-    frame f = _prev_frame.sender(&map);\n+      \/\/ lazy update to register map\n+      bool update_map = true;\n+      RegisterMap map(_thread, update_map);\n+      frame f = _prev_frame.sender(&map);\n@@ -584,1 +589,1 @@\n-    guarantee(f.is_compiled_frame(), \"expected compiled Java frame\");\n+      assert(f.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -586,1 +591,1 @@\n-    compiledVFrame* cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n@@ -588,1 +593,1 @@\n-    guarantee(cvf->cb() == cb(), \"wrong code blob\");\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n@@ -590,2 +595,2 @@\n-    \/\/ get the same scope as this stream\n-    cvf = cvf->at_scope(_decode_offset, _vframe_id);\n+      \/\/ get the same scope as this stream\n+      cvf = cvf->at_scope(_decode_offset, _vframe_id);\n@@ -593,3 +598,4 @@\n-    guarantee(cvf->scope()->decode_offset() == _decode_offset, \"wrong scope\");\n-    guarantee(cvf->scope()->sender_decode_offset() == _sender_decode_offset, \"wrong scope\");\n-    guarantee(cvf->vframe_id() == _vframe_id, \"wrong vframe\");\n+      assert(cvf->scope()->decode_offset() == _decode_offset, \"wrong scope\");\n+      assert(cvf->scope()->sender_decode_offset() == _sender_decode_offset, \"wrong scope\");\n+    }\n+    assert(cvf->vframe_id() == _vframe_id, \"wrong vframe\");\n@@ -601,1 +607,1 @@\n-  guarantee(result->method() == method(), \"wrong method\");\n+  assert(result->method() == method(), \"wrong method\");\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+  inline int vframe_id() const;\n+  inline int decode_offset() const;\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,10 @@\n+inline int vframeStreamCommon::vframe_id() const {\n+  assert(_mode == compiled_mode, \"unexpected mode: %d\", _mode);\n+  return _vframe_id;\n+}\n+\n+inline int vframeStreamCommon::decode_offset() const {\n+  assert(_mode == compiled_mode, \"unexpected mode: %d\", _mode);\n+  return _decode_offset;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() == NULL || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,3 +235,2 @@\n-    \/\/ This monitor is really only needed for UseBiasedLocking, but\n-    \/\/ return it in all cases for now as it might be useful for stack\n-    \/\/ traces and tools as well\n+    \/\/ This monitor is not really needed but return it for now as it might be\n+    \/\/ useful for stack traces and tools\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  template(PrintJNI)                              \\\n@@ -71,2 +70,0 @@\n-  template(EnableBiasedLocking)                   \\\n-  template(BulkRevokeBias)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  calling_thread()->as_Java_thread()->make_zombies();\n+  JavaThread::cast(calling_thread())->make_zombies();\n@@ -171,0 +171,3 @@\n+  if (_print_jni_handle_info) {\n+    JNIHandles::print_on(_out);\n+  }\n@@ -180,4 +183,0 @@\n-void VM_PrintJNI::doit() {\n-  JNIHandles::print_on(_out);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+  bool _print_jni_handle_info;\n@@ -148,1 +149,1 @@\n-    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false)\n+    : _out(tty), _print_concurrent_locks(PrintConcurrentLocks), _print_extended_info(false), _print_jni_handle_info(false)\n@@ -150,2 +151,3 @@\n-  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info)\n-    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info)\n+  VM_PrintThreads(outputStream* out, bool print_concurrent_locks, bool print_extended_info, bool print_jni_handle_info)\n+    : _out(out), _print_concurrent_locks(print_concurrent_locks), _print_extended_info(print_extended_info),\n+      _print_jni_handle_info(print_jni_handle_info)\n@@ -161,10 +163,0 @@\n-class VM_PrintJNI: public VM_Operation {\n- private:\n-  outputStream* _out;\n- public:\n-  VM_PrintJNI()                         { _out = tty; }\n-  VM_PrintJNI(outputStream* out)        { _out = out; }\n-  VMOp_Type type() const                { return VMOp_PrintJNI; }\n-  void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -169,5 +169,0 @@\n-typedef HashtableEntry<intptr_t, mtInternal>  IntptrHashtableEntry;\n-typedef Hashtable<intptr_t, mtInternal>       IntptrHashtable;\n-typedef Hashtable<InstanceKlass*, mtClass>       KlassHashtable;\n-typedef HashtableEntry<InstanceKlass*, mtClass>  KlassHashtableEntry;\n-\n@@ -269,1 +264,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -474,21 +468,0 @@\n-  \/* HashtableBucket *\/                                                                                                              \\\n-  \/*******************\/                                                                                                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(HashtableBucket<mtInternal>, _entry,                                        BasicHashtableEntry<mtInternal>*)      \\\n-                                                                                                                                     \\\n-  \/******************\/                                                                                                               \\\n-  \/* HashtableEntry *\/                                                                                                               \\\n-  \/******************\/                                                                                                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(BasicHashtableEntry<mtInternal>, _next,                                     BasicHashtableEntry<mtInternal>*)      \\\n-  nonstatic_field(BasicHashtableEntry<mtInternal>, _hash,                                     unsigned int)                          \\\n-  nonstatic_field(IntptrHashtableEntry,            _literal,                                  intptr_t)                              \\\n-                                                                                                                                     \\\n-  \/*************\/                                                                                                                    \\\n-  \/* Hashtable *\/                                                                                                                    \\\n-  \/*************\/                                                                                                                    \\\n-                                                                                                                                     \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _table_size,                                   int)                                   \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _buckets,                                      HashtableBucket<mtInternal>*)          \\\n-                                                                                                                                     \\\n-  \/*******************\/                                                                                                              \\\n@@ -501,1 +474,0 @@\n-  volatile_nonstatic_field(ClassLoaderData,    _dictionary,                                   Dictionary*)                           \\\n@@ -884,2 +856,2 @@\n-  nonstatic_field(ObjectMonitor,               _contentions,                                  jint)                                  \\\n-  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      jint)                                  \\\n+  nonstatic_field(ObjectMonitor,               _contentions,                                  int)                                   \\\n+  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      int)                                   \\\n@@ -1313,8 +1285,0 @@\n-  declare_toplevel_type(BasicHashtable<mtInternal>)                       \\\n-    declare_type(IntptrHashtable, BasicHashtable<mtInternal>)             \\\n-  declare_toplevel_type(BasicHashtable<mtSymbol>)                         \\\n-    declare_type(Dictionary, KlassHashtable)                              \\\n-  declare_toplevel_type(BasicHashtableEntry<mtInternal>)                  \\\n-  declare_type(IntptrHashtableEntry, BasicHashtableEntry<mtInternal>)     \\\n-    declare_type(DictionaryEntry, KlassHashtableEntry)                    \\\n-  declare_toplevel_type(HashtableBucket<mtInternal>)                      \\\n@@ -2633,1 +2597,0 @@\n-  declare_constant(markWord::biased_lock_bits)                            \\\n@@ -2638,1 +2601,0 @@\n-  declare_constant(markWord::biased_lock_shift)                           \\\n@@ -2644,3 +2606,0 @@\n-  declare_constant(markWord::biased_lock_mask)                            \\\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n-  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n@@ -2649,2 +2608,0 @@\n-  declare_constant(markWord::epoch_mask)                                  \\\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -2653,1 +2610,0 @@\n-  declare_constant(markWord::biased_lock_alignment)                       \\\n@@ -2659,1 +2615,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":47,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-    thread->as_Java_thread()->verify_states_for_handshake();\n+    JavaThread::cast(thread)->verify_states_for_handshake();\n@@ -525,1 +525,1 @@\n-    t->as_Java_thread()->check_for_valid_safepoint_state();\n+    JavaThread::cast(t)->check_for_valid_safepoint_state();\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  \/\/ Printing\n+  const char* type_name() const { return \"VMThread\"; }\n+\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info);\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(out, print_concurrent_locks, print_extended_info, true \/* print JNI handle info *\/);\n@@ -190,4 +190,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(out);\n-  VMThread::execute(&op2);\n-\n@@ -195,2 +191,2 @@\n-  VM_FindDeadlocks op3(out);\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(out);\n+  VMThread::execute(&op2);\n@@ -458,2 +454,2 @@\n-  const char thread_name[] = \"Attach Listener\";\n-  Handle string = java_lang_String::create_from_str(thread_name, THREAD);\n+  const char* name = \"Attach Listener\";\n+  Handle thread_oop = JavaThread::create_system_thread_object(name, true \/* visible *\/, THREAD);\n@@ -465,11 +461,2 @@\n-  \/\/ Initialize thread_oop to put it into the system threadGroup\n-  Handle thread_group (THREAD, Universe::system_thread_group());\n-  Handle thread_oop = JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n-                       vmSymbols::threadgroup_string_void_signature(),\n-                       thread_group,\n-                       string,\n-                       THREAD);\n-  if (has_init_error(THREAD)) {\n-    set_state(AL_NOT_INITIALIZED);\n-    return;\n-  }\n+  JavaThread* thread = new JavaThread(&attach_listener_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -477,30 +464,1 @@\n-  Klass* group = vmClasses::ThreadGroup_klass();\n-  JavaValue result(T_VOID);\n-  JavaCalls::call_special(&result,\n-                        thread_group,\n-                        group,\n-                        vmSymbols::add_method_name(),\n-                        vmSymbols::thread_void_signature(),\n-                        thread_oop,\n-                        THREAD);\n-  if (has_init_error(THREAD)) {\n-    set_state(AL_NOT_INITIALIZED);\n-    return;\n-  }\n-\n-  { MutexLocker mu(THREAD, Threads_lock);\n-    JavaThread* listener_thread = new JavaThread(&attach_listener_thread_entry);\n-\n-    \/\/ Check that thread and osthread were created\n-    if (listener_thread == NULL || listener_thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n-\n-    java_lang_Thread::set_thread(thread_oop(), listener_thread);\n-    java_lang_Thread::set_daemon(thread_oop());\n-\n-    listener_thread->set_threadObj(thread_oop());\n-    Threads::add(listener_thread);\n-    Thread::start(listener_thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":9,"deletions":51,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -61,1 +61,3 @@\n-\n+#ifdef LINUX\n+#include \"trimCHeapDCmd.hpp\"\n+#endif\n@@ -121,0 +123,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export, true, false));\n@@ -471,1 +474,3 @@\n-               \"9 the strongest compression.\", \"INT\", false, \"1\") {\n+               \"9 the strongest compression.\", \"INT\", false, \"1\"),\n+  _overwrite(\"-overwrite\", \"If specified, the dump file will be overwritten if it exists\",\n+           \"BOOLEAN\", false, \"false\") {\n@@ -475,0 +480,1 @@\n+  _dcmdparser.add_dcmd_option(&_overwrite);\n@@ -493,1 +499,1 @@\n-  dumper.dump(_filename.value(), output(), (int) level);\n+  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value());\n@@ -537,2 +543,2 @@\n-  \/\/ thread stacks\n-  VM_PrintThreads op1(output(), _locks.value(), _extended.value());\n+  \/\/ thread stacks and JNI global handles\n+  VM_PrintThreads op1(output(), _locks.value(), _extended.value(), true \/* print JNI handle info *\/);\n@@ -541,4 +547,0 @@\n-  \/\/ JNI global handles\n-  VM_PrintJNI op2(output());\n-  VMThread::execute(&op2);\n-\n@@ -546,2 +548,2 @@\n-  VM_FindDeadlocks op3(output());\n-  VMThread::execute(&op3);\n+  VM_FindDeadlocks op2(output());\n+  VMThread::execute(&op2);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+  DCmdArgument<bool> _overwrite;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n-int HeapDumper::dump(const char* path, outputStream* out, int compression) {\n+int HeapDumper::dump(const char* path, outputStream* out, int compression, bool overwrite) {\n@@ -1931,1 +1931,1 @@\n-  DumpWriter writer(new (std::nothrow) FileWriter(path), compressor);\n+  DumpWriter writer(new (std::nothrow) FileWriter(path, overwrite), compressor);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  int dump(const char* path, outputStream* out = NULL, int compression = -1);\n+  int dump(const char* path, outputStream* out = NULL, int compression = -1, bool overwrite = false);\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  _fd = os::create_binary_file(_path, false);    \/\/ don't replace existing file\n+  _fd = os::create_binary_file(_path, _overwrite);\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  bool _overwrite;\n@@ -67,1 +68,1 @@\n-  FileWriter(char const* path) : _path(path), _fd(-1) { }\n+  FileWriter(char const* path, bool overwrite) : _path(path), _overwrite(overwrite), _fd(-1) { }\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,9 @@\n+\/\/ Total malloc invocation count\n+size_t MallocMemorySnapshot::total_count() const {\n+  size_t amount = 0;\n+  for (int index = 0; index < mt_number_of_types; index ++) {\n+    amount += _malloc[index].malloc_count();\n+  }\n+  return amount;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+  \/\/ Total malloc invocation count\n+  size_t total_count() const;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,4 +101,6 @@\n-  size_t total_reserved_amount = _malloc_snapshot->total() +\n-    _vm_snapshot->total_reserved();\n-  size_t total_committed_amount = _malloc_snapshot->total() +\n-    _vm_snapshot->total_committed();\n+  const size_t total_malloced_bytes = _malloc_snapshot->total();\n+  const size_t total_mmap_reserved_bytes = _vm_snapshot->total_reserved();\n+  const size_t total_mmap_committed_bytes = _vm_snapshot->total_committed();\n+\n+  size_t total_reserved_amount = total_malloced_bytes + total_mmap_reserved_bytes;\n+  size_t total_committed_amount = total_malloced_bytes + total_mmap_committed_bytes;\n@@ -116,1 +118,8 @@\n-  out->print(\"\\n\");\n+  out->cr();\n+  out->print_cr(\"       malloc: \" SIZE_FORMAT \"%s #\" SIZE_FORMAT,\n+                amount_in_current_scale(total_malloced_bytes), current_scale(),\n+                _malloc_snapshot->total_count());\n+  out->print(\"       mmap:   \");\n+  print_total(total_mmap_reserved_bytes, total_mmap_committed_bytes);\n+  out->cr();\n+  out->cr();\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-          currentThread = owner->as_Java_thread();\n+          currentThread = JavaThread::cast(owner);\n@@ -444,2 +444,0 @@\n-            cycle->set_deadlock(true);\n-\n@@ -487,2 +485,0 @@\n-        cycle->set_deadlock(true);\n-\n@@ -958,1 +954,0 @@\n-  _is_deadlock = false;\n@@ -983,1 +978,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n@@ -994,2 +989,2 @@\n-          currentThread = owner->as_Java_thread();\n-          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+          currentThread = JavaThread::cast(owner);\n+          st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1034,1 +1029,1 @@\n-    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->get_thread_name());\n+    st->print_cr(\"%s \\\"%s\\\"\", owner_desc, currentThread->name());\n@@ -1046,1 +1041,1 @@\n-    st->print_cr(\"\\\"%s\\\":\", currentThread->get_thread_name());\n+    st->print_cr(\"\\\"%s\\\":\", currentThread->name());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -387,1 +387,0 @@\n-  bool _is_deadlock;\n@@ -397,3 +396,1 @@\n-  void           reset()                    { _is_deadlock = false; _threads->clear(); }\n-  void           set_deadlock(bool value)   { _is_deadlock = value; }\n-  bool           is_deadlock()              { return _is_deadlock; }\n+  void           reset()                    { _threads->clear(); }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,4 @@\n+#ifndef PRAGMA_NONNULL_IGNORED\n+#define PRAGMA_NONNULL_IGNORED\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+#define PRAGMA_NONNULL_IGNORED \\\n+  PRAGMA_DISABLE_GCC_WARNING(\"-Wnonnull\")\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+\n+    size_t get_mem_size() {\n+      return sizeof(*this) + _size * sizeof(Bucket);\n+    }\n@@ -387,0 +391,2 @@\n+  size_t get_mem_size(Thread* thread);\n+\n@@ -388,1 +394,1 @@\n-  size_t get_node_size() const { return sizeof(Node); }\n+  static size_t get_node_size() { return sizeof(Node); }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-\/\/ 2^5  = 32 buckets\n-#define SIZE_SMALL_LOG2 5\n+\/\/ 2^2  = 4 buckets\n+#define SIZE_SMALL_LOG2 2\n@@ -820,4 +820,1 @@\n-\n-  if (_new_table->_log2_size == _log2_size_limit) {\n-    _size_limit_reached = true;\n-  }\n+  _size_limit_reached = _new_table->_log2_size == _log2_size_limit;\n@@ -957,0 +954,1 @@\n+    Prefetch::read(current_node->next(), 0);\n@@ -1035,0 +1033,8 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline size_t ConcurrentHashTable<CONFIG, F>::\n+  get_mem_size(Thread* thread)\n+{\n+  ScopedCS cs(thread, this);\n+  return sizeof(*this) + _table->get_mem_size();\n+}\n+\n@@ -1138,2 +1144,0 @@\n-  assert(Thread::current()->is_VM_thread(),\n-         \"should be in vm thread\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  FormatBuffer(const FormatBuffer &); \/\/ prevent copies\n+  NONCOPYABLE(FormatBuffer);\n","filename":"src\/hotspot\/share\/utilities\/formatBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable and KVHashtable\n+\/\/ Default hash\/equals functions used by ResourceHashtable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,90 +223,0 @@\n-\/\/ A subclass of BasicHashtable that allows you to do a simple K -> V mapping\n-\/\/ without using tons of boilerplate code.\n-template<\n-    typename K, typename V, MEMFLAGS F,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class KVHashtable : public BasicHashtable<F> {\n-  class KVHashtableEntry : public BasicHashtableEntry<F> {\n-  public:\n-    K _key;\n-    V _value;\n-    KVHashtableEntry* next() {\n-      return (KVHashtableEntry*)BasicHashtableEntry<F>::next();\n-    }\n-  };\n-\n-protected:\n-  KVHashtableEntry* bucket(int i) const {\n-    return (KVHashtableEntry*)BasicHashtable<F>::bucket(i);\n-  }\n-\n-  KVHashtableEntry* new_entry(unsigned int hashValue, K key, V value) {\n-    KVHashtableEntry* entry = (KVHashtableEntry*)BasicHashtable<F>::new_entry(hashValue);\n-    entry->_key   = key;\n-    entry->_value = value;\n-    return entry;\n-  }\n-\n-public:\n-  KVHashtable(int table_size) : BasicHashtable<F>(table_size, sizeof(KVHashtableEntry)) {}\n-\n-  V* add(K key, V value) {\n-    unsigned int hash = HASH(key);\n-    KVHashtableEntry* entry = new_entry(hash, key, value);\n-    BasicHashtable<F>::add_entry(BasicHashtable<F>::hash_to_index(hash), entry);\n-    return &(entry->_value);\n-  }\n-\n-  V* lookup(K key) const {\n-    unsigned int hash = HASH(key);\n-    int index = BasicHashtable<F>::hash_to_index(hash);\n-    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      if (e->hash() == hash && EQUALS(e->_key, key)) {\n-        return &(e->_value);\n-      }\n-    }\n-    return NULL;\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n-  \/\/  pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* add_if_absent(K key, V value, bool* p_created) {\n-    unsigned int hash = HASH(key);\n-    int index = BasicHashtable<F>::hash_to_index(hash);\n-    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      if (e->hash() == hash && EQUALS(e->_key, key)) {\n-        *p_created = false;\n-        return &(e->_value);\n-      }\n-    }\n-\n-    KVHashtableEntry* entry = new_entry(hash, key, value);\n-    BasicHashtable<F>::add_entry(BasicHashtable<F>::hash_to_index(hash), entry);\n-    *p_created = true;\n-    return &(entry->_value);\n-  }\n-\n-  int table_size() const {\n-    return BasicHashtable<F>::table_size();\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns false,\n-  \/\/ the iteration is cancelled.\n-  template<class ITER>\n-  void iterate(ITER* iter) const {\n-    for (int index = 0; index < table_size(); index++) {\n-      for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-        bool cont = iter->do_entry(e->_key, &e->_value);\n-        if (!cont) { return; }\n-      }\n-    }\n-  }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n-\n-#include \"memory\/padded.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/pair.hpp\"\n-\n-\/\/ Return status of a LockFreeQueue::try_pop() call.\n-\/\/ See description for try_pop() below.\n-enum class LockFreeQueuePopStatus {\n-  success,\n-  lost_race,\n-  operation_in_progress\n-};\n-\n-\/\/ The LockFreeQueue template provides a lock-free FIFO. Its structure\n-\/\/ and usage is similar to LockFreeStack. It provides a try_pop() function\n-\/\/ for the client to implement pop() according to its need (e.g., whether\n-\/\/ or not to retry or prevent ABA problem). It has inner padding of one\n-\/\/ cache line between its two internal pointer fields.\n-\/\/\n-\/\/ \\tparam T is the class of the elements in the queue.\n-\/\/\n-\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n-\/\/ an object of type T must return a pointer to the list entry member\n-\/\/ of the object associated with the LockFreeQueue type.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-class LockFreeQueue {\n-  T* volatile _head;\n-  \/\/ Padding of one cache line to avoid false sharing.\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n-  T* volatile _tail;\n-\n-  NONCOPYABLE(LockFreeQueue);\n-\n-  \/\/ Return the entry following node in the list used by the\n-  \/\/ specialized LockFreeQueue class.\n-  static inline T* next(const T& node);\n-\n-  \/\/ Set the entry following node to new_next in the list used by the\n-  \/\/ specialized LockFreeQueue class. Not thread-safe, as it cannot\n-  \/\/ concurrently run with push or try_pop operations that modify this\n-  \/\/ node.\n-  static inline void set_next(T& node, T* new_next);\n-\n-public:\n-  inline LockFreeQueue();\n-  DEBUG_ONLY(~LockFreeQueue();)\n-\n-  \/\/ Return the first object in the queue.\n-  \/\/ Thread-safe, but the result may change immediately.\n-  inline T* top() const;\n-\n-  \/\/ Return true if the queue is empty.\n-  inline bool empty() const { return top() == NULL; }\n-\n-  \/\/ Return the number of objects in the queue.\n-  \/\/ Not thread-safe. There must be no concurrent modification\n-  \/\/ while the length is being determined.\n-  inline size_t length() const;\n-\n-  \/\/ Thread-safe add the object to the end of the queue.\n-  inline void push(T& node) { append(node, node); }\n-\n-  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n-  inline void append(T& first, T& last);\n-\n-  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n-  \/\/ Returns a <LockFreeQueuePopStatus, T*> pair for the caller to determine\n-  \/\/ further operation. 3 possible cases depending on pair.first:\n-  \/\/ - success:\n-  \/\/   The operation succeeded. If pair.second is NULL, the queue is empty;\n-  \/\/   otherwise caller can assume ownership of the object pointed by\n-  \/\/   pair.second. Note that this case is still subject to ABA behavior;\n-  \/\/   callers must ensure usage is safe.\n-  \/\/ - lost_race:\n-  \/\/   An atomic operation failed. pair.second is NULL.\n-  \/\/   The caller can typically retry in this case.\n-  \/\/ - operation_in_progress:\n-  \/\/   An in-progress concurrent operation interfered with taking what had been\n-  \/\/   the only remaining element in the queue. pair.second is NULL.\n-  \/\/   A concurrent try_pop may have already claimed it, but not completely\n-  \/\/   updated the queue. Alternatively, a concurrent push\/append may have not\n-  \/\/   yet linked the new entry(s) to the former sole entry. Retrying the try_pop\n-  \/\/   will continue to fail in this way until that other thread has updated the\n-  \/\/   queue's internal structure.\n-  inline Pair<LockFreeQueuePopStatus, T*> try_pop();\n-\n-  \/\/ Take all the objects from the queue, leaving the queue empty.\n-  \/\/ Not thread-safe. It should only be used when there is no concurrent\n-  \/\/ push\/append\/try_pop operation.\n-  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n-  inline Pair<T*, T*> take_all();\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.hpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-#define SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n-\n-#include \"utilities\/lockFreeQueue.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::next(const T& node) {\n-  return Atomic::load(next_ptr(const_cast<T&>(node)));\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n-    Atomic::store(next_ptr(node), new_next);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::LockFreeQueue() : _head(NULL), _tail(NULL) {}\n-\n-#ifdef ASSERT\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-LockFreeQueue<T, next_ptr>::~LockFreeQueue() {\n-  assert(_head == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n-}\n-#endif\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-T* LockFreeQueue<T, next_ptr>::top() const {\n-  return Atomic::load(&_head);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-size_t LockFreeQueue<T, next_ptr>::length() const {\n-  size_t result = 0;\n-  for (const T* current = top(); current != NULL; current = next(*current)) {\n-    ++result;\n-  }\n-  return result;\n-}\n-\n-\/\/ An append operation atomically exchanges the new tail with the queue tail.\n-\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n-\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n-\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n-\/\/ head of the list being appended is instead stored in the queue head; it is\n-\/\/ an invariant that the queue head is NULL in this case.\n-\/\/\n-\/\/ This means there is a period between the exchange and the old tail update\n-\/\/ where the queue sequence is split into two parts, the list from the queue\n-\/\/ head to the old tail, and the list being appended.  If there are concurrent\n-\/\/ push\/append operations, each may introduce another such segment.  But they\n-\/\/ all eventually get resolved by their respective updates of their old tail's\n-\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n-\/\/ with a NULL \"next\" value specially.\n-\/\/\n-\/\/ A push operation is just a degenerate append, where the object being pushed\n-\/\/ is both the head and the tail of the list being appended.\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-void LockFreeQueue<T, next_ptr>::append(T& first, T& last) {\n-  assert(next(last) == NULL, \"precondition\");\n-  T* old_tail = Atomic::xchg(&_tail, &last);\n-  if (old_tail == NULL) {       \/\/ Was empty.\n-    Atomic::store(&_head, &first);\n-  } else {\n-    assert(next(*old_tail) == NULL, \"invariant\");\n-    set_next(*old_tail, &first);\n-  }\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<LockFreeQueuePopStatus, T*> LockFreeQueue<T, next_ptr>::try_pop() {\n-  typedef Pair<LockFreeQueuePopStatus, T*> StatusPair;\n-  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n-  \/\/ as the memory_order_consume API is not ready for use yet.\n-  T* result = Atomic::load_acquire(&_head);\n-  if (result == NULL) {\n-    \/\/ Queue is empty.\n-    return StatusPair(LockFreeQueuePopStatus::success, NULL);\n-  }\n-\n-  \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n-  \/\/ is OK as the reader-side of the release-acquire ordering.\n-  T* next_node = Atomic::load(next_ptr(*result));\n-  if (next_node != NULL) {\n-    \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n-    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-      \/\/ Former head successfully taken; it is not the last.\n-      assert(Atomic::load(&_tail) != result, \"invariant\");\n-      assert(next(*result) != NULL, \"invariant\");\n-      set_next(*result, NULL);\n-      return StatusPair(LockFreeQueuePopStatus::success, result);\n-    }\n-    \/\/ Lost the race; the caller should try again.\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ next is NULL.  This case is handled differently from the \"usual\"\n-  \/\/ lock-free pop from the head of a singly linked list.\n-\n-  \/\/ If _tail == result then result is the only element in the list. We can\n-  \/\/ remove it from the list by first setting _tail to NULL and then setting\n-  \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n-  \/\/ case of a concurrent push\/append\/try_pop also changing _tail.  If we win\n-  \/\/ then we've claimed result.\n-  if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n-    assert(next(*result) == NULL, \"invariant\");\n-    \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n-    \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n-    \/\/ it may have already performed its list-was-empty update of _head,\n-    \/\/ which we must not overwrite.\n-    Atomic::cmpxchg(&_head, result, (T*)NULL);\n-    return StatusPair(LockFreeQueuePopStatus::success, result);\n-  }\n-\n-  \/\/ If _head != result then we lost the race to take result;\n-  \/\/ the caller should try again.\n-  if (result != Atomic::load_acquire(&_head)) {\n-    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n-  }\n-\n-  \/\/ An in-progress concurrent operation interfered with taking the head\n-  \/\/ element when it was the only element.  A concurrent try_pop may have won\n-  \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n-  \/\/ a concurrent push\/append may have changed the tail but not yet linked\n-  \/\/ result->next(). This case slightly differs from the \"lost_race\" case,\n-  \/\/ because the caller could wait for a long time for the other concurrent\n-  \/\/ operation to finish.\n-  return StatusPair(LockFreeQueuePopStatus::operation_in_progress, NULL);\n-}\n-\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-Pair<T*, T*> LockFreeQueue<T, next_ptr>::take_all() {\n-  Pair<T*, T*> result(Atomic::load(&_head), Atomic::load(&_tail));\n-  Atomic::store(&_head, (T*)NULL);\n-  Atomic::store(&_tail, (T*)NULL);\n-  return result;\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.inline.hpp","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n+\n+#include \"memory\/padded.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+\/\/ The NonblockingQueue template provides a non-blocking FIFO.\n+\/\/ It has inner padding of one cache line between its two internal pointers.\n+\/\/\n+\/\/ The queue is internally represented by a linked list of elements, with\n+\/\/ the link to the next element provided by a member of each element.\n+\/\/ Access to this member is provided by the next_ptr function.\n+\/\/\n+\/\/ The queue has a special pseudo-element that marks the end of the list.\n+\/\/ Each queue has its own unique special element.  A pointer to this element\n+\/\/ can be recognized using the is_end() function.  Such a pointer must never\n+\/\/ be dereferenced.  This end marker is the value of the next member of the\n+\/\/ last element in the queue, and possibly other elements while modifying\n+\/\/ the queue.\n+\/\/\n+\/\/ A queue may temporarily appear to be empty even though elements have been\n+\/\/ added and not removed.  For example, after running the following program,\n+\/\/ the value of r may be NULL.\n+\/\/\n+\/\/ thread1: q.push(a); r = q.pop();\n+\/\/ thread2: q.push(b);\n+\/\/\n+\/\/ This can occur if the push of b started before the push of a, but didn't\n+\/\/ complete until after the pop.\n+\/\/\n+\/\/ \\tparam T is the class of the elements in the queue.\n+\/\/\n+\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n+\/\/ an object of type T must return a pointer to the list entry member\n+\/\/ of the object associated with the NonblockingQueue type.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+class NonblockingQueue {\n+  T* volatile _head;\n+  \/\/ Padding of one cache line to avoid false sharing.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n+  T* volatile _tail;\n+\n+  NONCOPYABLE(NonblockingQueue);\n+\n+  \/\/ Return the entry following node in the list used by the\n+  \/\/ specialized NonblockingQueue class.\n+  static inline T* next(const T& node);\n+\n+  \/\/ Set the entry following node to new_next in the list used by the\n+  \/\/ specialized NonblockingQueue class. Not thread-safe, as it cannot\n+  \/\/ concurrently run with push or try_pop operations that modify this\n+  \/\/ node.\n+  static inline void set_next(T& node, T* new_next);\n+\n+  \/\/ A unique pseudo-object pointer associated with this specific queue.\n+  \/\/ The resulting pointer must not be dereferenced.\n+  inline T* end_marker() const;\n+\n+public:\n+  inline NonblockingQueue();\n+  inline ~NonblockingQueue() NOT_DEBUG(= default);\n+\n+  \/\/ Return true if the queue is empty.\n+  \/\/ Not thread-safe.  There must be no concurrent modification while the\n+  \/\/ queue is being tested.\n+  inline bool empty() const;\n+\n+  \/\/ Return the number of objects in the queue.\n+  \/\/ Not thread-safe. There must be no concurrent modification while the\n+  \/\/ length is being determined.\n+  inline size_t length() const;\n+\n+  \/\/ Thread-safe add the object to the end of the queue.\n+  inline void push(T& node) { append(node, node); }\n+\n+  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n+  inline void append(T& first, T& last);\n+\n+  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n+  \/\/ Returns true if successful.  If successful then *node_ptr is the former\n+  \/\/ first object, or NULL if the queue was empty.  If unsuccessful, because\n+  \/\/ of contention with a concurrent modification, then returns false with\n+  \/\/ the value of *node_ptr unspecified.  Subject to ABA behavior; callers\n+  \/\/ must ensure usage is safe.\n+  inline bool try_pop(T** node_ptr);\n+\n+  \/\/ Thread-safe remove and return the first object in the queue, or NULL if\n+  \/\/ the queue was empty.  This just iterates on try_pop() until it\n+  \/\/ succeeds, returning the (possibly NULL) element obtained from that.\n+  \/\/ Subject to ABA behavior; callers must ensure usage is safe.\n+  inline T* pop();\n+\n+  \/\/ Take all the objects from the queue, leaving the queue empty.\n+  \/\/ Not thread-safe.  There must be no concurrent operations.\n+  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n+  inline Pair<T*, T*> take_all();\n+\n+  \/\/ Iteration support is provided by first() and is_end().  The queue must\n+  \/\/ not be modified while iterating over its elements.\n+\n+  \/\/ Return the first object in the queue, or an end marker (a pointer p for\n+  \/\/ which is_end(p) is true) if the queue is empty.\n+  inline T* first() const;\n+\n+  \/\/ Test whether entry is an end marker for this queue.\n+  inline bool is_end(const T* entry) const;\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n+\n+#include \"utilities\/nonblockingQueue.hpp\"\n+\n+#include \"runtime\/atomic.hpp\"\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::next(const T& node) {\n+  return Atomic::load(next_ptr(const_cast<T&>(node)));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n+  Atomic::store(next_ptr(node), new_next);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::NonblockingQueue() : _head(NULL), _tail(NULL) {}\n+\n+#ifdef ASSERT\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n+  assert(_head == NULL, \"precondition\");\n+  assert(_tail == NULL, \"precondition\");\n+}\n+#endif\n+\n+\/\/ The end_marker must be uniquely associated with the specific queue, in\n+\/\/ case queue elements can make their way through multiple queues.  A\n+\/\/ pointer to the queue itself (after casting) satisfies that requirement.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::end_marker() const {\n+  return const_cast<T*>(reinterpret_cast<const T*>(this));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::first() const {\n+  T* head = Atomic::load(&_head);\n+  return head == NULL ? end_marker() : head;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::is_end(const T* entry) const {\n+  return entry == end_marker();\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::empty() const {\n+  return Atomic::load(&_head) == NULL;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+size_t NonblockingQueue<T, next_ptr>::length() const {\n+  size_t result = 0;\n+  for (T* cur = first(); !is_end(cur); cur = next(*cur)) {\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+\/\/ An append operation atomically exchanges the new tail with the queue tail.\n+\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n+\/\/ appended. If the old tail is NULL then the queue was empty, then the head\n+\/\/ of the list being appended is instead stored in the queue head.\n+\/\/\n+\/\/ This means there is a period between the exchange and the old tail update\n+\/\/ where the queue sequence is split into two parts, the list from the queue\n+\/\/ head to the old tail, and the list being appended.  If there are concurrent\n+\/\/ push\/append operations, each may introduce another such segment.  But they\n+\/\/ all eventually get resolved by their respective updates of their old tail's\n+\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n+\/\/ with a NULL \"next\" value specially.\n+\/\/\n+\/\/ A push operation is just a degenerate append, where the object being pushed\n+\/\/ is both the head and the tail of the list being appended.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void NonblockingQueue<T, next_ptr>::append(T& first, T& last) {\n+  assert(next(last) == NULL, \"precondition\");\n+  set_next(last, end_marker());\n+  T* old_tail = Atomic::xchg(&_tail, &last);\n+  bool is_old_tail_null = (old_tail == NULL);\n+  if (is_old_tail_null ||\n+      \/\/ Try to install first as old_tail's next.\n+      !is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n+    \/\/ Install first as the new head if either\n+    \/\/ (1) the list was empty, or\n+    \/\/ (2) a concurrent try_pop claimed old_tail, so it is no longer in the list.\n+    \/\/ Note that multiple concurrent push\/append operations cannot modify\n+    \/\/ _head simultaneously, because the Atomic::xchg() above orders these\n+    \/\/ push\/append operations so they perform Atomic::cmpxchg() on different\n+    \/\/ old_tail. Thus, the cmpxchg can only fail because of a concurrent try_pop.\n+    DEBUG_ONLY(T* old_head = Atomic::load(&_head);)\n+    \/\/ If old_tail is NULL, old_head could be NULL, or an unseen object\n+    \/\/ that is being popped.  Otherwise, old_head must be either NULL\n+    \/\/ or the same as old_tail.\n+    assert(is_old_tail_null ||\n+           old_head == NULL || old_head == old_tail, \"invariant\");\n+    Atomic::store(&_head, &first);\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+bool NonblockingQueue<T, next_ptr>::try_pop(T** node_ptr) {\n+  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n+  \/\/ as the memory_order_consume API is not ready for use yet.\n+  T* result = Atomic::load_acquire(&_head);\n+  if (result == NULL) {\n+    *node_ptr = NULL;\n+    return true;                \/\/ Queue is empty.\n+  }\n+\n+  T* next_node = Atomic::load_acquire(next_ptr(*result));\n+  if (next_node == NULL) {\n+    \/\/ A concurrent try_pop already claimed what was the last entry.  That\n+    \/\/ operation may not have cleared queue head yet, but we should still\n+    \/\/ treat the queue as empty until a push\/append operation changes head\n+    \/\/ to an entry with a non-NULL next value.\n+    *node_ptr = NULL;\n+    return true;\n+\n+  } else if (!is_end(next_node)) {\n+    \/\/ The next_node is not at the end of the queue's list.  Use the \"usual\"\n+    \/\/ lock-free pop from the head of a singly linked list to try to take it.\n+    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ Former head successfully taken.\n+      set_next(*result, NULL);\n+      *node_ptr = result;\n+      return true;\n+    } else {\n+      \/\/ Lost race to take result from the head of the list.\n+      return false;\n+    }\n+\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), end_marker(), (T*)NULL))) {\n+    \/\/ Result was the last entry and we've claimed it by setting its next\n+    \/\/ value to NULL.  However, this leaves the queue in disarray.  Fix up\n+    \/\/ the queue, possibly in conjunction with other concurrent operations.\n+    \/\/ Any further try_pops will consider the queue empty until a\n+    \/\/ push\/append completes by installing a new head.\n+\n+    \/\/ Attempt to change the queue tail from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates that a concurrent push\/append updated the tail first.\n+    \/\/ That operation will eventually recognize the old tail (our result) is\n+    \/\/ no longer in the list and update head from the list being appended.\n+    Atomic::cmpxchg(&_tail, result, (T*)NULL);\n+\n+    \/\/ Attempt to change the queue head from result to NULL.  Failure of the\n+    \/\/ cmpxchg indicates a concurrent push\/append updated the head first.\n+    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+\n+    \/\/ The queue has been restored to order, and we can return the result.\n+    *node_ptr = result;\n+    return true;\n+\n+  } else {\n+    \/\/ Result was the last entry in the list, but either a concurrent pop\n+    \/\/ claimed it first or a concurrent push\/append extended the list from\n+    \/\/ it.  Either way, we lost the race.\n+    return false;\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* NonblockingQueue<T, next_ptr>::pop() {\n+  T* result = NULL;\n+  \/\/ Typically try_pop() will succeed without retrying many times, thus we\n+  \/\/ omit SpinPause in the loop body.  SpinPause or yield may be worthwhile\n+  \/\/ in rare, highly contended cases, and client code could implement such\n+  \/\/ with try_pop().\n+  while (!try_pop(&result)) {}\n+  return result;\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+Pair<T*, T*> NonblockingQueue<T, next_ptr>::take_all() {\n+  T* tail = Atomic::load(&_tail);\n+  if (tail != NULL) set_next(*tail, NULL); \/\/ Clear end marker.\n+  Pair<T*, T*> result(Atomic::load(&_head), tail);\n+  Atomic::store(&_head, (T*)NULL);\n+  Atomic::store(&_tail, (T*)NULL);\n+  return result;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_NONBLOCKINGQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -100,1 +100,1 @@\n-   void print_raw(const char* str, int len)   { write(str,         len); }\n+   void print_raw(const char* str, size_t len)   { write(str,         len); }\n@@ -102,1 +102,1 @@\n-   void print_raw_cr(const char* str, int len){ write(str,         len); cr(); }\n+   void print_raw_cr(const char* str, size_t len){ write(str,         len); cr(); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+#define SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+\n+#include \"utilities\/resourceHash.hpp\"\n+\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE>\n+class ResizeableResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n+\n+protected:\n+  unsigned _table_size;\n+  Node** _table;\n+\n+  ResizeableResourceHashtableStorage(unsigned table_size) {\n+    _table_size = table_size;\n+    _table = alloc_table(table_size);\n+  }\n+\n+  ~ResizeableResourceHashtableStorage() {\n+    if (ALLOC_TYPE == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n+    }\n+  }\n+\n+  Node** alloc_table(unsigned table_size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TYPE);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(Node*));\n+    return table;\n+  }\n+\n+  unsigned table_size() const {\n+    return _table_size;\n+  }\n+\n+  Node** table() const {\n+    return _table;\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class ResizeableResourceHashtable : public ResourceHashtableBase<\n+    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+  unsigned _max_size;\n+\n+  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>,\n+                                     K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>;\n+  using Node = ResourceHashtableNode<K, V>;\n+  NONCOPYABLE(ResizeableResourceHashtable);\n+public:\n+  ResizeableResourceHashtable(unsigned size, unsigned max_size = 0)\n+  : BASE(size), _max_size(max_size) {\n+    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n+  }\n+\n+  bool maybe_grow(int load_factor = 8) {\n+    unsigned old_size = BASE::_table_size;\n+    if (old_size >= _max_size) {\n+      return false;\n+    }\n+    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n+      unsigned new_size = MIN2<unsigned>(old_size * 2, _max_size);\n+      resize(old_size, new_size);\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  void resize(unsigned old_size, unsigned new_size) {\n+    Node** old_table = BASE::_table;\n+    Node** new_table = BASE::alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    while (bucket < &old_table[old_size]) {\n+      Node* node = *bucket;\n+      while (node != NULL) {\n+        Node* next = node->_next;\n+        unsigned hash = HASH(node->_key);\n+        unsigned index = hash % new_size;\n+\n+        node->_next = new_table[index];\n+        new_table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, old_table);\n+    }\n+    BASE::_table = new_table;\n+    BASE::_table_size = new_size;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,16 @@\n+template<typename K, typename V>\n+class ResourceHashtableNode : public ResourceObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  ResourceHashtableNode* _next;\n+\n+  ResourceHashtableNode(unsigned hash, K const& key, V const& value) :\n+    _hash(hash), _key(key), _value(value), _next(NULL) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  ResourceHashtableNode(unsigned hash, K const& key) :\n+    _hash(hash), _key(key), _value(), _next(NULL) {}\n+};\n+\n@@ -31,0 +47,1 @@\n+    class STORAGE,\n@@ -32,9 +49,4 @@\n-    \/\/ xlC does not compile this:\n-    \/\/ http:\/\/stackoverflow.com\/questions\/8532961\/template-argument-of-type-that-is-defined-by-inner-typedef-from-other-template-c\n-    \/\/typename ResourceHashtableFns<K>::hash_fn   HASH   = primitive_hash<K>,\n-    \/\/typename ResourceHashtableFns<K>::equals_fn EQUALS = primitive_equals<K>,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-    unsigned SIZE = 256,\n-    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n-    MEMFLAGS MEM_TYPE = mtInternal\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&),\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE\n@@ -42,1 +54,2 @@\n-class ResourceHashtable : public ResourceObj {\n+class ResourceHashtableBase : public STORAGE {\n+  using Node = ResourceHashtableNode<K, V>;\n@@ -44,0 +57,1 @@\n+  int _number_of_entries;\n@@ -45,17 +59,4 @@\n-  class Node : public ResourceObj {\n-   public:\n-    unsigned _hash;\n-    K _key;\n-    V _value;\n-    Node* _next;\n-\n-    Node(unsigned hash, K const& key, V const& value) :\n-        _hash(hash), _key(key), _value(value), _next(NULL) {}\n-\n-    \/\/ Create a node with a default-constructed value.\n-    Node(unsigned hash, K const& key) :\n-        _hash(hash), _key(key), _value(), _next(NULL) {}\n-\n-  };\n-\n-  Node* _table[SIZE];\n+  Node** bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n@@ -66,2 +67,2 @@\n-    unsigned index = hash % SIZE;\n-    Node** ptr = &_table[index];\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n@@ -80,1 +81,1 @@\n-        const_cast<ResourceHashtable*>(this)->lookup_node(hash, key));\n+        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n@@ -83,2 +84,2 @@\n- public:\n-  ResourceHashtable() { memset(_table, 0, SIZE * sizeof(Node*)); }\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n@@ -86,4 +87,9 @@\n-  ~ResourceHashtable() {\n-    if (ALLOC_TYPE == C_HEAP) {\n-      Node* const* bucket = _table;\n-      while (bucket < &_table[SIZE]) {\n+  ResourceHashtableBase() : STORAGE(), _number_of_entries(0) {}\n+  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n+  NONCOPYABLE(ResourceHashtableBase);\n+\n+  ~ResourceHashtableBase() {\n+    if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n@@ -101,0 +107,4 @@\n+ public:\n+  unsigned table_size() const { return STORAGE::table_size(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n@@ -128,0 +138,1 @@\n+      _number_of_entries ++;\n@@ -143,0 +154,1 @@\n+      _number_of_entries ++;\n@@ -160,0 +172,1 @@\n+      _number_of_entries ++;\n@@ -174,1 +187,1 @@\n-      if (ALLOC_TYPE == C_HEAP) {\n+      if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n@@ -177,0 +190,1 @@\n+      _number_of_entries --;\n@@ -187,2 +201,3 @@\n-    Node* const* bucket = _table;\n-    while (bucket < &_table[SIZE]) {\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n@@ -200,0 +215,34 @@\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n+\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedResourceHashtableStorage() : _table() {}\n+  ~FixedResourceHashtableStorage() = default;\n+\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n+\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+    unsigned SIZE = 256,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal\n+    >\n+class ResourceHashtable : public ResourceHashtableBase<\n+  FixedResourceHashtableStorage<SIZE, K, V>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+  NONCOPYABLE(ResourceHashtable);\n+public:\n+  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>,\n+                                              K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>() {}\n+};\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":89,"deletions":40,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n@@ -156,1 +159,1 @@\n-    if (thread->as_Java_thread()->thread_state() == _thread_in_native) {\n+    if (JavaThread::cast(thread)->thread_state() == _thread_in_native) {\n@@ -267,1 +270,1 @@\n-          RegisterMap map(t->as_Java_thread(), false); \/\/ No update\n+          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n@@ -753,1 +756,1 @@\n-       print_stack_trace(st, _thread->as_Java_thread(), buf, sizeof(buf));\n+       print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n@@ -762,1 +765,1 @@\n-         JavaThread* jt = thread->as_Java_thread();\n+         JavaThread* jt = JavaThread::cast(thread);\n@@ -1276,1 +1279,1 @@\n-static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {\n+int VMError::prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {\n@@ -1587,0 +1590,7 @@\n+#if INCLUDE_JVMCI\n+  if (JVMCI::fatal_log_filename() != NULL) {\n+    out.print_raw(\"#\\n# The JVMCI shared library error report file is saved as:\\n# \");\n+    out.print_raw_cr(JVMCI::fatal_log_filename());\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -187,0 +187,5 @@\n+  \/\/ Construct file name for a log file and return it's file descriptor.\n+  \/\/ Name and location depends on pattern, default_pattern params and access\n+  \/\/ permissions.\n+  static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-            this.keysize = keysize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2113,0 +2113,7 @@\n+     * <p> If the {@code directory} argument is not {@code null} and its\n+     * abstract pathname is valid and denotes an existing, writable directory,\n+     * then the file will be created in that directory. Otherwise the file will\n+     * not be created and an {@code IOException} will be thrown.  Under no\n+     * circumstances will a directory be created at the location specified by\n+     * the {@code directory} argument.\n+     *\n@@ -2130,1 +2137,2 @@\n-     * @throws  IOException  If a file could not be created\n+     * @throws  IOException\n+     *          If a file could not be created\n@@ -2152,0 +2160,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -560,1 +560,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -619,4 +618,4 @@\n-            String factoryClassName = StaticProperty.jdkSerialFilterFactory();\n-            if (factoryClassName == null) {\n-                \/\/ Fallback to security property\n-                factoryClassName = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+            @SuppressWarnings(\"removal\")\n+            String factoryClassName = StaticProperty.jdkSerialFilterFactory() != null\n+                    ? StaticProperty.jdkSerialFilterFactory()\n+                    : AccessController.doPrivileged((PrivilegedAction<String>) () ->\n@@ -624,1 +623,0 @@\n-            }\n@@ -626,4 +624,4 @@\n-            String filterString = StaticProperty.jdkSerialFilter();\n-            if (filterString == null) {\n-                \/\/ Fallback to security property\n-                filterString = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+            @SuppressWarnings(\"removal\")\n+            String filterString = StaticProperty.jdkSerialFilter() != null\n+                    ? StaticProperty.jdkSerialFilter()\n+                    : AccessController.doPrivileged((PrivilegedAction<String>) () ->\n@@ -631,1 +629,0 @@\n-            }\n@@ -713,0 +710,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -806,0 +804,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -412,3 +413,1 @@\n-        if (i < 0 || i >= count) {\n-            throw new StringIndexOutOfBoundsException(index);\n-        }\n+        checkIndex(i, count);\n@@ -508,1 +507,1 @@\n-        checkRangeSIOOBE(srcBegin, srcEnd, count);  \/\/ compatible to old version\n+        Preconditions.checkFromToIndex(srcBegin, srcEnd, count, Preconditions.SIOOBE_FORMATTER);  \/\/ compatible to old version\n@@ -510,1 +509,1 @@\n-        checkRange(dstBegin, dstBegin + n, dst.length);\n+        Preconditions.checkFromToIndex(dstBegin, dstBegin + n, dst.length, Preconditions.IOOBE_FORMATTER);\n@@ -680,1 +679,1 @@\n-        checkRange(start, end, s.length());\n+        Preconditions.checkFromToIndex(start, end, s.length(), Preconditions.IOOBE_FORMATTER);\n@@ -739,1 +738,1 @@\n-        checkRange(offset, end, str.length);\n+        Preconditions.checkFromToIndex(offset, end, str.length, Preconditions.IOOBE_FORMATTER);\n@@ -917,1 +916,1 @@\n-        checkRangeSIOOBE(start, end, count);\n+        Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);\n@@ -1000,1 +999,1 @@\n-        checkRangeSIOOBE(start, end, count);\n+        Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);\n@@ -1070,1 +1069,1 @@\n-        checkRangeSIOOBE(start, end, count);\n+        Preconditions.checkFromToIndex(start, end, count, Preconditions.SIOOBE_FORMATTER);\n@@ -1107,1 +1106,1 @@\n-        checkRangeSIOOBE(offset, offset + len, str.length);\n+        Preconditions.checkFromToIndex(offset, offset + len, str.length, Preconditions.SIOOBE_FORMATTER);\n@@ -1295,1 +1294,1 @@\n-        checkRange(start, end, s.length());\n+        Preconditions.checkFromToIndex(start, end, s.length(), Preconditions.IOOBE_FORMATTER);\n@@ -1798,16 +1797,0 @@\n-\n-    \/* IndexOutOfBoundsException, if out of bounds *\/\n-    private static void checkRange(int start, int end, int len) {\n-        if (start < 0 || start > end || end > len) {\n-            throw new IndexOutOfBoundsException(\n-                \"start \" + start + \", end \" + end + \", length \" + len);\n-        }\n-    }\n-\n-    \/* StringIndexOutOfBoundsException, if out of bounds *\/\n-    private static void checkRangeSIOOBE(int start, int end, int len) {\n-        if (start < 0 || start > end || end > len) {\n-            throw new StringIndexOutOfBoundsException(\n-                \"start \" + start + \", end \" + end + \", length \" + len);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Objects;\n@@ -9252,4 +9253,1 @@\n-        int length = seq.length();\n-        if (beginIndex < 0 || endIndex > length || beginIndex > endIndex) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkFromToIndex(beginIndex, endIndex, seq.length());\n@@ -9287,3 +9285,1 @@\n-        if (count > a.length - offset || offset < 0 || count < 0) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkFromIndexSize(count, offset, a.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -712,0 +712,1 @@\n+        Objects.checkFromToIndex(beginIndex, endIndex, s.length());\n@@ -713,3 +714,0 @@\n-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > s.length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n@@ -895,0 +893,1 @@\n+        Objects.checkFromToIndex(beginIndex, endIndex, s.length());\n@@ -896,3 +895,0 @@\n-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > s.length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -755,0 +755,1 @@\n+        Objects.checkFromToIndex(beginIndex, endIndex, s.length());\n@@ -756,3 +757,0 @@\n-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > s.length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n@@ -1001,0 +999,1 @@\n+        Objects.checkFromToIndex(beginIndex, endIndex, s.length());\n@@ -1002,3 +1001,0 @@\n-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > s.length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,7 +94,2 @@\n- * overflow errors need to be detected, the methods {@code addExact},\n- * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},\n- * {@code incrementExact}, {@code decrementExact} and {@code negateExact}\n- * throw an {@code ArithmeticException} when the results overflow.\n- * For the arithmetic operations divide and absolute value, overflow\n- * occurs only with a specific minimum or maximum value and\n- * should be checked against the minimum or maximum as appropriate.\n+ * overflow errors need to be detected, the methods whose names end with\n+ * {@code Exact} throw an {@code ArithmeticException} when the results overflow.\n@@ -1010,0 +1005,54 @@\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows an {@code int}.  Such overflow occurs in this method if\n+     * {@code x} is {@link Integer#MIN_VALUE} and {@code y} is {@code -1}.\n+     * In contrast, if {@code Integer.MIN_VALUE \/ -1} were evaluated directly,\n+     * the result would be {@code Integer.MIN_VALUE} and no exception would be\n+     * thrown.\n+     * <p>\n+     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n+     * (JLS {@jls 15.17.2}).\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if {@code y} is zero or the quotient\n+     * overflows an int\n+     * @jls 15.17.2 Division Operator \/\n+     * @since 18\n+     *\/\n+    public static int divideExact(int x, int y) {\n+        int q = x \/ y;\n+        if ((x & y & q) >= 0) {\n+            return q;\n+        }\n+        throw new ArithmeticException(\"integer overflow\");\n+    }\n+\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows a {@code long}.  Such overflow occurs in this method if\n+     * {@code x} is {@link Long#MIN_VALUE} and {@code y} is {@code -1}.\n+     * In contrast, if {@code Long.MIN_VALUE \/ -1} were evaluated directly,\n+     * the result would be {@code Long.MIN_VALUE} and no exception would be\n+     * thrown.\n+     * <p>\n+     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n+     * (JLS {@jls 15.17.2}).\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if {@code y} is zero or the quotient\n+     * overflows a long\n+     * @jls 15.17.2 Division Operator \/\n+     * @since 18\n+     *\/\n+    public static long divideExact(long x, long y) {\n+        long q = x \/ y;\n+        if ((x & y & q) >= 0) {\n+            return q;\n+        }\n+        throw new ArithmeticException(\"long overflow\");\n+    }\n+\n@@ -1159,0 +1208,1 @@\n+     * @see #unsignedMultiplyHigh\n@@ -1163,25 +1213,32 @@\n-        if (x < 0 || y < 0) {\n-            \/\/ Use technique from section 8-2 of Henry S. Warren, Jr.,\n-            \/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n-            long x1 = x >> 32;\n-            long x2 = x & 0xFFFFFFFFL;\n-            long y1 = y >> 32;\n-            long y2 = y & 0xFFFFFFFFL;\n-            long z2 = x2 * y2;\n-            long t = x1 * y2 + (z2 >>> 32);\n-            long z1 = t & 0xFFFFFFFFL;\n-            long z0 = t >> 32;\n-            z1 += x2 * y1;\n-            return x1 * y1 + z0 + (z1 >> 32);\n-        } else {\n-            \/\/ Use Karatsuba technique with two base 2^32 digits.\n-            long x1 = x >>> 32;\n-            long y1 = y >>> 32;\n-            long x2 = x & 0xFFFFFFFFL;\n-            long y2 = y & 0xFFFFFFFFL;\n-            long A = x1 * y1;\n-            long B = x2 * y2;\n-            long C = (x1 + x2) * (y1 + y2);\n-            long K = C - A - B;\n-            return (((B >>> 32) + K) >>> 32) + A;\n-        }\n+        \/\/ Use technique from section 8-2 of Henry S. Warren, Jr.,\n+        \/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+        long x1 = x >> 32;\n+        long x2 = x & 0xFFFFFFFFL;\n+        long y1 = y >> 32;\n+        long y2 = y & 0xFFFFFFFFL;\n+\n+        long z2 = x2 * y2;\n+        long t = x1 * y2 + (z2 >>> 32);\n+        long z1 = t & 0xFFFFFFFFL;\n+        long z0 = t >> 32;\n+        z1 += x2 * y1;\n+\n+        return x1 * y1 + z0 + (z1 >> 32);\n+    }\n+\n+    \/**\n+     * Returns as a {@code long} the most significant 64 bits of the unsigned\n+     * 128-bit product of two unsigned 64-bit factors.\n+     *\n+     * @param x the first value\n+     * @param y the second value\n+     * @return the result\n+     * @see #multiplyHigh\n+     * @since 18\n+     *\/\n+    public static long unsignedMultiplyHigh(long x, long y) {\n+        \/\/ Compute via multiplyHigh() to leverage the intrinsic\n+        long result = Math.multiplyHigh(x, y);\n+        result += (y & (x >> 63)); \/\/ equivalent to `if (x < 0) result += y;`\n+        result += (x & (y >> 63)); \/\/ equivalent to `if (y < 0) result += x;`\n+        return result;\n@@ -1522,1 +1579,2 @@\n-        return (a <= 0.0F) ? 0.0F - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Float.intBitsToFloat(Float.floatToRawIntBits(a) & FloatConsts.MAG_BIT_MASK);\n@@ -1547,1 +1605,3 @@\n-        return (a <= 0.0D) ? 0.0D - a : a;\n+        \/\/ Convert to bit field form, zero the sign bit, and convert back\n+        return Double.longBitsToDouble(Double.doubleToRawLongBits(a) & DoubleConsts.MAG_BIT_MASK);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":94,"deletions":34,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -69,7 +69,2 @@\n- * overflow errors need to be detected, the methods {@code addExact},\n- * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},\n- * {@code incrementExact}, {@code decrementExact} and {@code negateExact}\n- * throw an {@code ArithmeticException} when the results overflow.\n- * For the arithmetic operations divide and absolute value, overflow\n- * occurs only with a specific minimum or maximum value and\n- * should be checked against the minimum or maximum as appropriate.\n+ * overflow errors need to be detected, the methods whose names end with\n+ * {@code Exact} throw an {@code ArithmeticException} when the results overflow.\n@@ -861,0 +856,48 @@\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows an {@code int}.  Such overflow occurs in this method if\n+     * {@code x} is {@link Integer#MIN_VALUE} and {@code y} is {@code -1}.\n+     * In contrast, if {@code Integer.MIN_VALUE \/ -1} were evaluated directly,\n+     * the result would be {@code Integer.MIN_VALUE} and no exception would be\n+     * thrown.\n+     * <p>\n+     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n+     * (JLS {@jls 15.17.2}).\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if {@code y} is zero or the quotient\n+     * overflows an int\n+     * @jls 15.17.2 Division Operator \/\n+     * @see Math#divideExact(int,int)\n+     * @since 18\n+     *\/\n+    public static int divideExact(int x, int y) {\n+        return Math.divideExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the quotient of the arguments, throwing an exception if the\n+     * result overflows a {@code long}.  Such overflow occurs in this method if\n+     * {@code x} is {@link Long#MIN_VALUE} and {@code y} is {@code -1}.\n+     * In contrast, if {@code Long.MIN_VALUE \/ -1} were evaluated directly,\n+     * the result would be {@code Long.MIN_VALUE} and no exception would be\n+     * thrown.\n+     * <p>\n+     * If {@code y} is zero, an {@code ArithmeticException} is thrown\n+     * (JLS {@jls 15.17.2}).\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the quotient {@code x \/ y}\n+     * @throws ArithmeticException if {@code y} is zero or the quotient\n+     * overflows a long\n+     * @jls 15.17.2 Division Operator \/\n+     * @see Math#divideExact(long,long)\n+     * @since 18\n+     *\/\n+    public static long divideExact(long x, long y) {\n+        return Math.divideExact(x, y);\n+    }\n+\n@@ -985,0 +1028,1 @@\n+     * @see #unsignedMultiplyHigh\n@@ -992,0 +1036,15 @@\n+    \/**\n+     * Returns as a {@code long} the most significant 64 bits of the unsigned\n+     * 128-bit product of two unsigned 64-bit factors.\n+     *\n+     * @param x the first value\n+     * @param y the second value\n+     * @return the result\n+     * @see #multiplyHigh\n+     * @see Math#unsignedMultiplyHigh(long,long)\n+     * @since 18\n+     *\/\n+    public static long unsignedMultiplyHigh(long x, long y) {\n+        return Math.unsignedMultiplyHigh(x, y);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -1574,3 +1575,1 @@\n-        if (i < 0 || i >= length()) {\n-            throw new StringIndexOutOfBoundsException(index);\n-        }\n+        checkIndex(i, length());\n@@ -1605,4 +1604,1 @@\n-        if (beginIndex < 0 || beginIndex > endIndex ||\n-            endIndex > length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkFromToIndex(beginIndex, endIndex, length());\n@@ -4559,4 +4555,1 @@\n-        if (index < 0 || index >= length) {\n-            throw new StringIndexOutOfBoundsException(\"index \" + index +\n-                                                      \", length \" + length);\n-        }\n+        Preconditions.checkIndex(index, length, Preconditions.SIOOBE_FORMATTER);\n@@ -4570,4 +4563,1 @@\n-        if (offset < 0 || offset > length) {\n-            throw new StringIndexOutOfBoundsException(\"offset \" + offset +\n-                                                      \", length \" + length);\n-        }\n+        Preconditions.checkFromToIndex(offset, length, length, Preconditions.SIOOBE_FORMATTER);\n@@ -4585,4 +4575,1 @@\n-        if (offset < 0 || count < 0 || offset > length - count) {\n-            throw new StringIndexOutOfBoundsException(\n-                \"offset \" + offset + \", count \" + count + \", length \" + length);\n-        }\n+        Preconditions.checkFromIndexSize(offset, count, length, Preconditions.SIOOBE_FORMATTER);\n@@ -4600,4 +4587,1 @@\n-        if (begin < 0 || begin > end || end > length) {\n-            throw new StringIndexOutOfBoundsException(\n-                \"begin \" + begin + \", end \" + end + \", length \" + length);\n-        }\n+        Preconditions.checkFromToIndex(begin, end, length, Preconditions.SIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.String.checkIndex;\n@@ -47,3 +48,1 @@\n-        if (index < 0 || index >= value.length) {\n-            throw new StringIndexOutOfBoundsException(index);\n-        }\n+        checkIndex(index, value.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -116,2 +117,3 @@\n-        if (start < 0 || start >= argTypes.length || end < 0 || end > argTypes.length || start > end)\n-            throw new IndexOutOfBoundsException();\n+        Objects.checkIndex(start, argTypes.length);\n+        Objects.checkFromToIndex(start, end, argTypes.length);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import static java.lang.invoke.MethodHandleStatics.rangeCheck1;\n-import static java.lang.invoke.MethodHandleStatics.rangeCheck2;\n-\n@@ -122,1 +119,1 @@\n-            rangeCheck2(start, end, size);\n+            Objects.checkFromToIndex(start, end, size);\n@@ -126,1 +123,1 @@\n-            return rangeCheck1(index, size) + offset;\n+            return Objects.checkIndex(index, size) + offset;\n@@ -146,1 +143,1 @@\n-            rangeCheck2(start, end, size);\n+            Objects.checkFromToIndex(start, end, size);\n@@ -163,1 +160,1 @@\n-            rangeCheck2(start, end, size);\n+            Objects.checkFromToIndex(start, end, size);\n@@ -172,1 +169,1 @@\n-            rangeCheck2(start, end, size);\n+            Objects.checkFromToIndex(start, end, size);\n@@ -192,1 +189,1 @@\n-            rangeCheck2(start, end, self.size());\n+            Objects.checkFromToIndex(start, end, self.size());\n@@ -203,1 +200,1 @@\n-            return rangeCheck1(index, size) + offset;\n+            return Objects.checkIndex(index, size) + offset;\n@@ -226,1 +223,1 @@\n-            rangeCheck2(start, end, size);\n+            Objects.checkFromToIndex(start, end, size);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractConstantGroup.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-            cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);\n+            cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n@@ -507,1 +508,1 @@\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n+        cw.visit(CLASSFILE_VERSION, Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.misc.VM;\n@@ -59,1 +60,1 @@\n-    private static final int CLASSFILE_VERSION = 59;\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n+        cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-            cw.visit(52, ACC_PRIVATE | ACC_SUPER, \"InjectedInvoker\", null, \"java\/lang\/Object\", null);\n+            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_SUPER, \"InjectedInvoker\", null, \"java\/lang\/Object\", null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.VM;\n@@ -49,0 +50,1 @@\n+    static final int CLASSFILE_VERSION = VM.classFileVersion();\n@@ -192,11 +194,0 @@\n-    \/*non-public*\/\n-    static void rangeCheck2(int start, int end, int size) {\n-        if (0 > start || start > end || end > size)\n-            throw new IndexOutOfBoundsException(start+\"..\"+end);\n-    }\n-    \/*non-public*\/\n-    static int rangeCheck1(int index, int size) {\n-        if (0 > index || index >= size)\n-            throw new IndexOutOfBoundsException(index);\n-        return index;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2182,9 +2182,0 @@\n-    static final BiFunction<String, List<Number>, ArrayIndexOutOfBoundsException>\n-            AIOOBE_SUPPLIER = Preconditions.outOfBoundsExceptionFormatter(\n-            new Function<String, ArrayIndexOutOfBoundsException>() {\n-                @Override\n-                public ArrayIndexOutOfBoundsException apply(String s) {\n-                    return new ArrayIndexOutOfBoundsException(s);\n-                }\n-            });\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n@@ -845,1 +845,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -858,1 +858,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n@@ -870,1 +870,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -883,1 +883,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase);\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n@@ -895,1 +895,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -909,1 +909,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -923,1 +923,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -937,1 +937,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -951,1 +951,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -965,1 +965,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -979,1 +979,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -993,1 +993,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1007,1 +1007,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1021,1 +1021,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1034,1 +1034,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1047,1 +1047,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1058,1 +1058,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1067,1 +1067,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1076,1 +1076,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1087,1 +1087,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1096,1 +1096,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1105,1 +1105,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1114,1 +1114,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1123,1 +1123,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1132,1 +1132,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1141,1 +1141,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1150,1 +1150,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n@@ -1159,1 +1159,1 @@\n-                                       (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) << handle.ashift) + handle.abase,\n+                                       (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -112,3 +112,0 @@\n-        private static final BiFunction<String, List<Number>, ArrayIndexOutOfBoundsException>\n-            OOBEF = Preconditions.outOfBoundsExceptionFormatter(ArrayIndexOutOfBoundsException::new);\n-\n@@ -117,1 +114,1 @@\n-            return Preconditions.checkIndex(index, ba.length - ALIGN, OOBEF);\n+            return Preconditions.checkIndex(index, ba.length - ALIGN, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.VM;\n@@ -58,1 +59,1 @@\n-\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n@@ -458,1 +459,1 @@\n-        visit(V14, accessFlags, dotToSlash(className), null,\n+        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,5 +41,6 @@\n- * integer <i>{@linkplain scale() scale}<\/i>.  If zero or positive,\n- * the scale is the number of digits to the right of the decimal\n- * point.  If negative, the unscaled value of the number is multiplied\n- * by ten to the power of the negation of the scale.  The value of the\n- * number represented by the {@code BigDecimal} is therefore\n+ * integer <i>{@linkplain scale() scale}<\/i>.  If the\n+ * scale is zero or positive, the scale is the number of digits to\n+ * the right of the decimal point.  If the scale is negative, the\n+ * unscaled value of the number is multiplied by ten to the power of\n+ * the negation of the scale.  The value of the number represented by\n+ * the {@code BigDecimal} is therefore\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,530 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import sun.net.ResourceManager;\n-import sun.net.ext.ExtendedSocketOptions;\n-import sun.net.util.IPAddressUtil;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * Abstract datagram and multicast socket implementation base class.\n- * Note: This is not a public class, so that applets cannot call\n- * into the implementation directly and hence cannot bypass the\n- * security checks present in the DatagramSocket and MulticastSocket\n- * classes.\n- *\n- * @author Pavani Diwanji\n- *\/\n-\n-abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl\n-{\n-    \/* timeout value for receive() *\/\n-    int timeout = 0;\n-    boolean connected = false;\n-    private int trafficClass = 0;\n-    protected InetAddress connectedAddress = null;\n-    private int connectedPort = -1;\n-    private final boolean isMulticast;\n-\n-    private static final String os =\n-            GetPropertyAction.privilegedGetProperty(\"os.name\");\n-\n-    \/**\n-     * flag set if the native connect() call not to be used\n-     *\/\n-    private static final boolean connectDisabled = os.contains(\"OS X\");\n-\n-    \/**\n-     * Load net library into runtime.\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-\n-    private static volatile boolean checkedReusePort;\n-    private static volatile boolean isReusePortAvailable;\n-\n-    \/**\n-     * Tells whether SO_REUSEPORT is supported.\n-     *\/\n-    static boolean isReusePortAvailable() {\n-        if (!checkedReusePort) {\n-            isReusePortAvailable = isReusePortAvailable0();\n-            checkedReusePort = true;\n-        }\n-        return isReusePortAvailable;\n-    }\n-\n-    AbstractPlainDatagramSocketImpl(boolean isMulticast) {\n-        this.isMulticast = isMulticast;\n-    }\n-\n-    \/**\n-     * Creates a datagram socket\n-     *\/\n-    protected synchronized void create() throws SocketException {\n-        ResourceManager.beforeUdpCreate();\n-        fd = new FileDescriptor();\n-        try {\n-            datagramSocketCreate();\n-            SocketCleanable.register(fd, false);\n-        } catch (SocketException ioe) {\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-            throw ioe;\n-        }\n-    }\n-\n-    \/**\n-     * Binds a datagram socket to a local port.\n-     *\/\n-    protected synchronized void bind(int lport, InetAddress laddr)\n-        throws SocketException {\n-        if (laddr.isLinkLocalAddress()) {\n-            laddr = IPAddressUtil.toScopedAddress(laddr);\n-        }\n-        bind0(lport, laddr);\n-    }\n-\n-    protected abstract void bind0(int lport, InetAddress laddr)\n-        throws SocketException;\n-\n-    \/**\n-     * Sends a datagram packet. The packet contains the data and the\n-     * destination address to send the packet to.\n-     * @param p the packet to be sent.\n-     *\/\n-    protected void send(DatagramPacket p) throws IOException {\n-        InetAddress orig = p.getAddress();\n-        if (orig.isLinkLocalAddress()) {\n-            InetAddress scoped = IPAddressUtil.toScopedAddress(orig);\n-            if (orig != scoped) {\n-                p = new DatagramPacket(p.getData(), p.getOffset(),\n-                                       p.getLength(), scoped, p.getPort());\n-            }\n-        }\n-        send0(p);\n-    }\n-\n-    protected abstract void send0(DatagramPacket p) throws IOException;\n-\n-    \/**\n-     * Connects a datagram socket to a remote destination. This associates the remote\n-     * address with the local socket so that datagrams may only be sent to this destination\n-     * and received from this destination.\n-     * @param address the remote InetAddress to connect to\n-     * @param port the remote port number\n-     *\/\n-    protected void connect(InetAddress address, int port) throws SocketException {\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-        connect0(address, port);\n-        connectedAddress = address;\n-        connectedPort = port;\n-        connected = true;\n-    }\n-\n-    \/**\n-     * Disconnects a previously connected socket. Does nothing if the socket was\n-     * not connected already.\n-     *\/\n-    protected void disconnect() {\n-        disconnect0(connectedAddress.holder().getFamily());\n-        connected = false;\n-        connectedAddress = null;\n-        connectedPort = -1;\n-    }\n-\n-    \/**\n-     * Peek at the packet to see who it is from.\n-     * @param i the address to populate with the sender address\n-     *\/\n-    protected abstract int peek(InetAddress i) throws IOException;\n-    protected abstract int peekData(DatagramPacket p) throws IOException;\n-    \/**\n-     * Receive the datagram packet.\n-     * @param p the packet to receive into\n-     *\/\n-    protected synchronized void receive(DatagramPacket p)\n-        throws IOException {\n-        receive0(p);\n-    }\n-\n-    protected abstract void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl TTL to be set.\n-     *\/\n-    protected abstract void setTimeToLive(int ttl) throws IOException;\n-\n-    \/**\n-     * Get the TTL (time-to-live) option.\n-     *\/\n-    protected abstract int getTimeToLive() throws IOException;\n-\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl TTL to be set.\n-     *\/\n-    @Deprecated\n-    protected abstract void setTTL(byte ttl) throws IOException;\n-\n-    \/**\n-     * Get the TTL (time-to-live) option.\n-     *\/\n-    @Deprecated\n-    protected abstract byte getTTL() throws IOException;\n-\n-    \/**\n-     * Join the multicast group.\n-     * @param inetaddr multicast address to join.\n-     *\/\n-    protected void join(InetAddress inetaddr) throws IOException {\n-        join(inetaddr, null);\n-    }\n-\n-    \/**\n-     * Leave the multicast group.\n-     * @param inetaddr multicast address to leave.\n-     *\/\n-    protected void leave(InetAddress inetaddr) throws IOException {\n-        leave(inetaddr, null);\n-    }\n-    \/**\n-     * Join the multicast group.\n-     * @param mcastaddr multicast address to join.\n-     * @param netIf specifies the local interface to receive multicast\n-     *        datagram packets\n-     * @throws  IllegalArgumentException if mcastaddr is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-\n-    protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n-        throws IOException {\n-        if (!(mcastaddr instanceof InetSocketAddress addr))\n-            throw new IllegalArgumentException(\"Unsupported address type\");\n-        join(addr.getAddress(), netIf);\n-    }\n-\n-    protected abstract void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    \/**\n-     * Leave the multicast group.\n-     * @param mcastaddr  multicast address to leave.\n-     * @param netIf specified the local interface to leave the group at\n-     * @throws  IllegalArgumentException if mcastaddr is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-    protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n-        throws IOException {\n-        if (!(mcastaddr instanceof InetSocketAddress addr))\n-            throw new IllegalArgumentException(\"Unsupported address type\");\n-        leave(addr.getAddress(), netIf);\n-    }\n-\n-    protected abstract void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    \/**\n-     * Close the socket.\n-     *\/\n-    protected void close() {\n-        if (fd != null) {\n-            SocketCleanable.unregister(fd);\n-            datagramSocketClose();\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-        }\n-    }\n-\n-    protected boolean isClosed() {\n-        return (fd == null) ? true : false;\n-    }\n-\n-    \/**\n-     * set a value - since we only support (setting) binary options\n-     * here, o must be a Boolean\n-     *\/\n-\n-     public void setOption(int optID, Object o) throws SocketException {\n-         if (isClosed()) {\n-             throw new SocketException(\"Socket Closed\");\n-         }\n-         switch (optID) {\n-            \/* check type safety b4 going native.  These should never\n-             * fail, since only java.Socket* has access to\n-             * PlainSocketImpl.setOption().\n-             *\/\n-         case SO_TIMEOUT:\n-             if (!(o instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for SO_TIMEOUT\");\n-             }\n-             int tmp = ((Integer) o).intValue();\n-             if (tmp < 0)\n-                 throw new IllegalArgumentException(\"timeout < 0\");\n-             timeout = tmp;\n-             return;\n-         case IP_TOS:\n-             if (!(o instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for IP_TOS\");\n-             }\n-             trafficClass = ((Integer)o).intValue();\n-             break;\n-         case SO_REUSEADDR:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_REUSEADDR\");\n-             }\n-             break;\n-         case SO_BROADCAST:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_BROADCAST\");\n-             }\n-             break;\n-         case SO_BINDADDR:\n-             throw new SocketException(\"Cannot re-bind Socket\");\n-         case SO_RCVBUF:\n-         case SO_SNDBUF:\n-             if (!(o instanceof Integer) ||\n-                 ((Integer)o).intValue() < 0) {\n-                 throw new SocketException(\"bad argument for SO_SNDBUF or \" +\n-                                           \"SO_RCVBUF\");\n-             }\n-             break;\n-         case IP_MULTICAST_IF:\n-             if (!(o instanceof InetAddress))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_IF\");\n-             break;\n-         case IP_MULTICAST_IF2:\n-             if (!(o instanceof NetworkInterface))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_IF2\");\n-             break;\n-         case IP_MULTICAST_LOOP:\n-             if (!(o instanceof Boolean))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_LOOP\");\n-             break;\n-         case SO_REUSEPORT:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_REUSEPORT\");\n-             }\n-             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                 throw new UnsupportedOperationException(\"unsupported option\");\n-             }\n-             break;\n-         default:\n-             throw new SocketException(\"invalid option: \" + optID);\n-         }\n-         socketSetOption(optID, o);\n-     }\n-\n-    \/*\n-     * get option's state - set or not\n-     *\/\n-\n-    public Object getOption(int optID) throws SocketException {\n-        if (isClosed()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-\n-        Object result;\n-\n-        switch (optID) {\n-            case SO_TIMEOUT:\n-                result = timeout;\n-                break;\n-\n-            case IP_TOS:\n-                result = socketGetOption(optID);\n-                if ( ((Integer)result).intValue() == -1) {\n-                    result = trafficClass;\n-                }\n-                break;\n-\n-            case SO_BINDADDR:\n-            case IP_MULTICAST_IF:\n-            case IP_MULTICAST_IF2:\n-            case SO_RCVBUF:\n-            case SO_SNDBUF:\n-            case IP_MULTICAST_LOOP:\n-            case SO_REUSEADDR:\n-            case SO_BROADCAST:\n-                result = socketGetOption(optID);\n-                break;\n-\n-            case SO_REUSEPORT:\n-                if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                    throw new UnsupportedOperationException(\"unsupported option\");\n-                }\n-                result = socketGetOption(optID);\n-                break;\n-\n-            default:\n-                throw new SocketException(\"invalid option: \" + optID);\n-        }\n-\n-        return result;\n-    }\n-\n-    static final ExtendedSocketOptions extendedOptions =\n-            ExtendedSocketOptions.getInstance();\n-\n-    private static final Set<SocketOption<?>> datagramSocketOptions = datagramSocketOptions();\n-\n-    private static Set<SocketOption<?>> datagramSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_BROADCAST);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        options.add(StandardSocketOptions.IP_MULTICAST_IF);\n-        options.add(StandardSocketOptions.IP_MULTICAST_TTL);\n-        options.add(StandardSocketOptions.IP_MULTICAST_LOOP);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.datagramSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-            return datagramSocketOptions;\n-    }\n-\n-    @Override\n-    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (!name.type().isInstance(value))\n-            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n-\n-        if (isClosed())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_SNDBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n-            setOption(SocketOptions.SO_SNDBUF, value);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n-            setOption(SocketOptions.SO_RCVBUF, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            setOption(SocketOptions.SO_REUSEADDR, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            setOption(SocketOptions.SO_REUSEPORT, value);\n-        } else if (name == StandardSocketOptions.SO_BROADCAST) {\n-            setOption(SocketOptions.SO_BROADCAST, value);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n-            setOption(SocketOptions.IP_TOS, value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_IF ) {\n-            setOption(SocketOptions.IP_MULTICAST_IF2, value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid TTL\/hop value: \" + value);\n-            setTimeToLive((Integer)value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {\n-            boolean enable = (boolean) value;\n-            \/\/ Legacy setOption expects true to mean 'disabled'\n-            setOption(SocketOptions.IP_MULTICAST_LOOP, !enable);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            extendedOptions.setOption(fd, name, value);\n-        } else {\n-            throw new AssertionError(\"unknown option :\" + name);\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T getOption(SocketOption<T> name) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (isClosed())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_SNDBUF) {\n-            return (T) getOption(SocketOptions.SO_SNDBUF);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            return (T) getOption(SocketOptions.SO_RCVBUF);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            return (T) getOption(SocketOptions.SO_REUSEADDR);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            return (T) getOption(SocketOptions.SO_REUSEPORT);\n-        } else if (name == StandardSocketOptions.SO_BROADCAST) {\n-            return (T) getOption(SocketOptions.SO_BROADCAST);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            return (T) getOption(SocketOptions.IP_TOS);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_IF) {\n-            return (T) getOption(SocketOptions.IP_MULTICAST_IF2);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {\n-            return (T) ((Integer) getTimeToLive());\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {\n-            boolean disabled = (boolean) getOption(SocketOptions.IP_MULTICAST_LOOP);\n-            \/\/ Legacy getOption returns true when disabled\n-            return (T) Boolean.valueOf(!disabled);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            return (T) extendedOptions.getOption(fd, name);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    protected abstract void datagramSocketCreate() throws SocketException;\n-    protected abstract void datagramSocketClose();\n-    protected abstract void socketSetOption(int opt, Object val)\n-        throws SocketException;\n-    protected abstract Object socketGetOption(int opt) throws SocketException;\n-\n-    protected abstract void connect0(InetAddress address, int port) throws SocketException;\n-    protected abstract void disconnect0(int family);\n-\n-    protected boolean nativeConnectDisabled() {\n-        return connectDisabled;\n-    }\n-\n-    abstract int dataAvailable();\n-    private static native boolean isReusePortAvailable0();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainDatagramSocketImpl.java","additions":0,"deletions":530,"binary":false,"changes":530,"status":"deleted"},{"patch":"@@ -1,875 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import sun.net.ConnectionResetException;\n-import sun.net.NetHooks;\n-import sun.net.PlatformSocketImpl;\n-import sun.net.ResourceManager;\n-import sun.net.ext.ExtendedSocketOptions;\n-import sun.net.util.IPAddressUtil;\n-import sun.net.util.SocketExceptions;\n-\n-\/**\n- * Default Socket Implementation. This implementation does\n- * not implement any security checks.\n- * Note this class should <b>NOT<\/b> be public.\n- *\n- * @author  Steven B. Byrne\n- *\/\n-abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {\n-    \/* instance variable for SO_TIMEOUT *\/\n-    int timeout;   \/\/ timeout in millisec\n-    \/\/ traffic class\n-    private int trafficClass;\n-\n-    private boolean shut_rd = false;\n-    private boolean shut_wr = false;\n-\n-    private SocketInputStream socketInputStream = null;\n-    private SocketOutputStream socketOutputStream = null;\n-\n-    \/* number of threads using the FileDescriptor *\/\n-    protected int fdUseCount = 0;\n-\n-    \/* lock when increment\/decrementing fdUseCount *\/\n-    protected final Object fdLock = new Object();\n-\n-    \/* indicates a close is pending on the file descriptor *\/\n-    protected boolean closePending = false;\n-\n-    \/* indicates connection reset state *\/\n-    private volatile boolean connectionReset;\n-\n-    \/* indicates whether impl is bound  *\/\n-    boolean isBound;\n-\n-    \/* indicates whether impl is connected  *\/\n-    volatile boolean isConnected;\n-\n-   \/* whether this Socket is a stream (TCP) socket or not (UDP)\n-    *\/\n-    protected boolean stream;\n-\n-    \/* whether this is a server or not *\/\n-    final boolean isServer;\n-\n-    \/**\n-     * Load net library into runtime.\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-\n-    private static volatile boolean checkedReusePort;\n-    private static volatile boolean isReusePortAvailable;\n-\n-    \/**\n-     * Tells whether SO_REUSEPORT is supported.\n-     *\/\n-    static boolean isReusePortAvailable() {\n-        if (!checkedReusePort) {\n-            isReusePortAvailable = isReusePortAvailable0();\n-            checkedReusePort = true;\n-        }\n-        return isReusePortAvailable;\n-    }\n-\n-    AbstractPlainSocketImpl(boolean isServer) {\n-        this.isServer = isServer;\n-    }\n-\n-    \/**\n-     * Creates a socket with a boolean that specifies whether this\n-     * is a stream socket (true) or an unconnected UDP socket (false).\n-     *\/\n-    protected synchronized void create(boolean stream) throws IOException {\n-        this.stream = stream;\n-        if (!stream) {\n-            ResourceManager.beforeUdpCreate();\n-            \/\/ only create the fd after we know we will be able to create the socket\n-            fd = new FileDescriptor();\n-            try {\n-                socketCreate(false);\n-                SocketCleanable.register(fd, false);\n-            } catch (IOException ioe) {\n-                ResourceManager.afterUdpClose();\n-                fd = null;\n-                throw ioe;\n-            }\n-        } else {\n-            fd = new FileDescriptor();\n-            socketCreate(true);\n-            SocketCleanable.register(fd, true);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified port on\n-     * the specified host.\n-     * @param host the specified host\n-     * @param port the specified port\n-     *\/\n-    protected void connect(String host, int port)\n-        throws UnknownHostException, IOException\n-    {\n-        boolean connected = false;\n-        try {\n-            InetAddress address = InetAddress.getByName(host);\n-            \/\/ recording this.address as supplied by caller before calling connect\n-            this.address = address;\n-            this.port = port;\n-            if (address.isLinkLocalAddress()) {\n-                address = IPAddressUtil.toScopedAddress(address);\n-            }\n-\n-            connectToAddress(address, port, timeout);\n-            connected = true;\n-        } finally {\n-            if (!connected) {\n-                try {\n-                    close();\n-                } catch (IOException ioe) {\n-                    \/* Do nothing. If connect threw an exception then\n-                       it will be passed up the call stack *\/\n-                }\n-            }\n-            isConnected = connected;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified address on\n-     * the specified port.\n-     * @param address the address\n-     * @param port the specified port\n-     *\/\n-    protected void connect(InetAddress address, int port) throws IOException {\n-        \/\/ recording this.address as supplied by caller before calling connect\n-        this.address = address;\n-        this.port = port;\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-\n-        try {\n-            connectToAddress(address, port, timeout);\n-            isConnected = true;\n-            return;\n-        } catch (IOException e) {\n-            \/\/ everything failed\n-            close();\n-            throw e;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified address on\n-     * the specified port.\n-     * @param address the address\n-     * @param timeout the timeout value in milliseconds, or zero for no timeout.\n-     * @throws IOException if connection fails\n-     * @throws  IllegalArgumentException if address is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-    protected void connect(SocketAddress address, int timeout)\n-            throws IOException {\n-        boolean connected = false;\n-        try {\n-            if (!(address instanceof InetSocketAddress addr))\n-                throw new IllegalArgumentException(\"unsupported address type\");\n-            if (addr.isUnresolved())\n-                throw new UnknownHostException(addr.getHostName());\n-            \/\/ recording this.address as supplied by caller before calling connect\n-            InetAddress ia = addr.getAddress();\n-            this.address = ia;\n-            this.port = addr.getPort();\n-            if (ia.isLinkLocalAddress()) {\n-                ia = IPAddressUtil.toScopedAddress(ia);\n-            }\n-            connectToAddress(ia, port, timeout);\n-            connected = true;\n-        } finally {\n-            if (!connected) {\n-                try {\n-                    close();\n-                } catch (IOException ioe) {\n-                    \/* Do nothing. If connect threw an exception then\n-                       it will be passed up the call stack *\/\n-                }\n-            }\n-            isConnected = connected;\n-        }\n-    }\n-\n-    private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {\n-        if (address.isAnyLocalAddress()) {\n-            doConnect(InetAddress.getLocalHost(), port, timeout);\n-        } else {\n-            doConnect(address, port, timeout);\n-        }\n-    }\n-\n-    public void setOption(int opt, Object val) throws SocketException {\n-        if (isClosedOrPending()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-        boolean on = true;\n-        switch (opt) {\n-            \/* check type safety b4 going native.  These should never\n-             * fail, since only java.Socket* has access to\n-             * PlainSocketImpl.setOption().\n-             *\/\n-        case SO_LINGER:\n-            if (!(val instanceof Integer) && !(val instanceof Boolean))\n-                throw new SocketException(\"Bad parameter for option\");\n-            if (val instanceof Boolean) {\n-                \/* true only if disabling - enabling should be Integer *\/\n-                on = false;\n-            }\n-            break;\n-        case SO_TIMEOUT:\n-            if (!(val instanceof Integer))\n-                throw new SocketException(\"Bad parameter for SO_TIMEOUT\");\n-            int tmp = ((Integer) val).intValue();\n-            if (tmp < 0)\n-                throw new IllegalArgumentException(\"timeout < 0\");\n-            timeout = tmp;\n-            break;\n-        case IP_TOS:\n-             if (!(val instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for IP_TOS\");\n-             }\n-             trafficClass = ((Integer)val).intValue();\n-             break;\n-        case SO_BINDADDR:\n-            throw new SocketException(\"Cannot re-bind socket\");\n-        case TCP_NODELAY:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for TCP_NODELAY\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_SNDBUF:\n-        case SO_RCVBUF:\n-            if (!(val instanceof Integer) ||\n-                !(((Integer)val).intValue() > 0)) {\n-                throw new SocketException(\"bad parameter for SO_SNDBUF \" +\n-                                          \"or SO_RCVBUF\");\n-            }\n-            break;\n-        case SO_KEEPALIVE:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_KEEPALIVE\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_OOBINLINE:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_OOBINLINE\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_REUSEADDR:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_REUSEADDR\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_REUSEPORT:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_REUSEPORT\");\n-            if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT))\n-                throw new UnsupportedOperationException(\"unsupported option\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        default:\n-            throw new SocketException(\"unrecognized TCP option: \" + opt);\n-        }\n-        socketSetOption(opt, on, val);\n-    }\n-    public Object getOption(int opt) throws SocketException {\n-        if (isClosedOrPending()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-        if (opt == SO_TIMEOUT) {\n-            return timeout;\n-        }\n-        int ret = 0;\n-        \/*\n-         * The native socketGetOption() knows about 3 options.\n-         * The 32 bit value it returns will be interpreted according\n-         * to what we're asking.  A return of -1 means it understands\n-         * the option but its turned off.  It will raise a SocketException\n-         * if \"opt\" isn't one it understands.\n-         *\/\n-\n-        switch (opt) {\n-        case TCP_NODELAY:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_OOBINLINE:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_LINGER:\n-            ret = socketGetOption(opt, null);\n-            return (ret == -1) ? Boolean.FALSE: (Object)(ret);\n-        case SO_REUSEADDR:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_BINDADDR:\n-            InetAddressContainer in = new InetAddressContainer();\n-            ret = socketGetOption(opt, in);\n-            return in.addr;\n-        case SO_SNDBUF:\n-        case SO_RCVBUF:\n-            ret = socketGetOption(opt, null);\n-            return ret;\n-        case IP_TOS:\n-            try {\n-                ret = socketGetOption(opt, null);\n-                if (ret == -1) { \/\/ ipv6 tos\n-                    return trafficClass;\n-                } else {\n-                    return ret;\n-                }\n-            } catch (SocketException se) {\n-                    \/\/ TODO - should make better effort to read TOS or TCLASS\n-                    return trafficClass; \/\/ ipv6 tos\n-            }\n-        case SO_KEEPALIVE:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_REUSEPORT:\n-            if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                throw new UnsupportedOperationException(\"unsupported option\");\n-            }\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        \/\/ should never get here\n-        default:\n-            return null;\n-        }\n-    }\n-\n-    static final ExtendedSocketOptions extendedOptions =\n-            ExtendedSocketOptions.getInstance();\n-\n-    private static final Set<SocketOption<?>> clientSocketOptions = clientSocketOptions();\n-    private static final Set<SocketOption<?>> serverSocketOptions = serverSocketOptions();\n-\n-    private static Set<SocketOption<?>> clientSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_KEEPALIVE);\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_LINGER);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        options.add(StandardSocketOptions.TCP_NODELAY);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.clientSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    private static Set<SocketOption<?>> serverSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.serverSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-        if (isServer)\n-            return serverSocketOptions;\n-        else\n-            return clientSocketOptions;\n-    }\n-\n-    @Override\n-    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (!name.type().isInstance(value))\n-            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n-\n-        if (isClosedOrPending())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_KEEPALIVE) {\n-            setOption(SocketOptions.SO_KEEPALIVE, value);\n-        } else if (name == StandardSocketOptions.SO_SNDBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n-            setOption(SocketOptions.SO_SNDBUF, value);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n-            setOption(SocketOptions.SO_RCVBUF, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            setOption(SocketOptions.SO_REUSEADDR, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            setOption(SocketOptions.SO_REUSEPORT, value);\n-        } else if (name == StandardSocketOptions.SO_LINGER ) {\n-            if (((Integer)value).intValue() < 0)\n-                setOption(SocketOptions.SO_LINGER, false);\n-            else\n-                setOption(SocketOptions.SO_LINGER, value);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n-            setOption(SocketOptions.IP_TOS, value);\n-        } else if (name == StandardSocketOptions.TCP_NODELAY) {\n-            setOption(SocketOptions.TCP_NODELAY, value);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            extendedOptions.setOption(fd, name, value);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T getOption(SocketOption<T> name) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (isClosedOrPending())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_KEEPALIVE) {\n-            return (T)getOption(SocketOptions.SO_KEEPALIVE);\n-        } else if (name == StandardSocketOptions.SO_SNDBUF) {\n-            return (T)getOption(SocketOptions.SO_SNDBUF);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            return (T)getOption(SocketOptions.SO_RCVBUF);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            return (T)getOption(SocketOptions.SO_REUSEADDR);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            return (T)getOption(SocketOptions.SO_REUSEPORT);\n-        } else if (name == StandardSocketOptions.SO_LINGER) {\n-            Object value = getOption(SocketOptions.SO_LINGER);\n-            if (value instanceof Boolean) {\n-                assert ((Boolean)value).booleanValue() == false;\n-                value = -1;\n-            }\n-            return (T)value;\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            return (T)getOption(SocketOptions.IP_TOS);\n-        } else if (name == StandardSocketOptions.TCP_NODELAY) {\n-            return (T)getOption(SocketOptions.TCP_NODELAY);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            return (T) extendedOptions.getOption(fd, name);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    \/**\n-     * The workhorse of the connection operation.  Tries several times to\n-     * establish a connection to the given <host, port>.  If unsuccessful,\n-     * throws an IOException indicating what went wrong.\n-     *\/\n-\n-    synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {\n-        synchronized (fdLock) {\n-            if (!closePending && !isBound) {\n-                NetHooks.beforeTcpConnect(fd, address, port);\n-            }\n-        }\n-        try {\n-            acquireFD();\n-            try {\n-                socketConnect(address, port, timeout);\n-                \/* socket may have been closed during poll\/select *\/\n-                synchronized (fdLock) {\n-                    if (closePending) {\n-                        throw new SocketException (\"Socket closed\");\n-                    }\n-                }\n-            } finally {\n-                releaseFD();\n-            }\n-        } catch (IOException e) {\n-            close();\n-            throw SocketExceptions.of(e, new InetSocketAddress(address, port));\n-        }\n-    }\n-\n-    \/**\n-     * Binds the socket to the specified address of the specified local port.\n-     * @param address the address\n-     * @param lport the port\n-     *\/\n-    protected synchronized void bind(InetAddress address, int lport)\n-        throws IOException\n-    {\n-       synchronized (fdLock) {\n-            if (!closePending && !isBound) {\n-                NetHooks.beforeTcpBind(fd, address, lport);\n-            }\n-        }\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-        socketBind(address, lport);\n-        isBound = true;\n-    }\n-\n-    \/**\n-     * Listens, for a specified amount of time, for connections.\n-     * @param count the amount of time to listen for connections\n-     *\/\n-    protected synchronized void listen(int count) throws IOException {\n-        socketListen(count);\n-    }\n-\n-    \/**\n-     * Accepts connections.\n-     * @param si the socket impl\n-     *\/\n-    protected void accept(SocketImpl si) throws IOException {\n-        si.fd = new FileDescriptor();\n-        acquireFD();\n-        try {\n-            socketAccept(si);\n-        } finally {\n-            releaseFD();\n-        }\n-        SocketCleanable.register(si.fd, true);\n-    }\n-\n-    \/**\n-     * Gets an InputStream for this socket.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    protected synchronized InputStream getInputStream() throws IOException {\n-        synchronized (fdLock) {\n-            if (isClosedOrPending())\n-                throw new IOException(\"Socket Closed\");\n-            if (shut_rd)\n-                throw new IOException(\"Socket input is shutdown\");\n-            if (socketInputStream == null) {\n-                PrivilegedExceptionAction<SocketInputStream> pa = () -> new SocketInputStream(this);\n-                try {\n-                    socketInputStream = AccessController.doPrivileged(pa);\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getCause();\n-                }\n-            }\n-        }\n-        return socketInputStream;\n-    }\n-\n-    void setInputStream(SocketInputStream in) {\n-        socketInputStream = in;\n-    }\n-\n-    \/**\n-     * Gets an OutputStream for this socket.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    protected synchronized OutputStream getOutputStream() throws IOException {\n-        synchronized (fdLock) {\n-            if (isClosedOrPending())\n-                throw new IOException(\"Socket Closed\");\n-            if (shut_wr)\n-                throw new IOException(\"Socket output is shutdown\");\n-            if (socketOutputStream == null) {\n-                PrivilegedExceptionAction<SocketOutputStream> pa = () -> new SocketOutputStream(this);\n-                try {\n-                    socketOutputStream = AccessController.doPrivileged(pa);\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getCause();\n-                }\n-            }\n-        }\n-        return socketOutputStream;\n-    }\n-\n-    void setFileDescriptor(FileDescriptor fd) {\n-        this.fd = fd;\n-    }\n-\n-    void setAddress(InetAddress address) {\n-        this.address = address;\n-    }\n-\n-    void setPort(int port) {\n-        this.port = port;\n-    }\n-\n-    void setLocalPort(int localport) {\n-        this.localport = localport;\n-    }\n-\n-    \/**\n-     * Returns the number of bytes that can be read without blocking.\n-     *\/\n-    protected synchronized int available() throws IOException {\n-        if (isClosedOrPending()) {\n-            throw new IOException(\"Stream closed.\");\n-        }\n-\n-        \/*\n-         * If connection has been reset or shut down for input, then return 0\n-         * to indicate there are no buffered bytes.\n-         *\/\n-        if (isConnectionReset() || shut_rd) {\n-            return 0;\n-        }\n-\n-        \/*\n-         * If no bytes available and we were previously notified\n-         * of a connection reset then we move to the reset state.\n-         *\n-         * If are notified of a connection reset then check\n-         * again if there are bytes buffered on the socket.\n-         *\/\n-        int n = 0;\n-        try {\n-            n = socketAvailable();\n-        } catch (ConnectionResetException exc1) {\n-            setConnectionReset();\n-        }\n-        return n;\n-    }\n-\n-    \/**\n-     * Closes the socket.\n-     *\/\n-    protected void close() throws IOException {\n-        synchronized(fdLock) {\n-            if (fd != null) {\n-                if (fdUseCount == 0) {\n-                    if (closePending) {\n-                        return;\n-                    }\n-                    closePending = true;\n-                    \/*\n-                     * We close the FileDescriptor in two-steps - first the\n-                     * \"pre-close\" which closes the socket but doesn't\n-                     * release the underlying file descriptor. This operation\n-                     * may be lengthy due to untransmitted data and a long\n-                     * linger interval. Once the pre-close is done we do the\n-                     * actual socket to release the fd.\n-                     *\/\n-                    try {\n-                        socketPreClose();\n-                    } finally {\n-                        socketClose();\n-                    }\n-                    fd = null;\n-                    return;\n-                } else {\n-                    \/*\n-                     * If a thread has acquired the fd and a close\n-                     * isn't pending then use a deferred close.\n-                     * Also decrement fdUseCount to signal the last\n-                     * thread that releases the fd to close it.\n-                     *\/\n-                    if (!closePending) {\n-                        closePending = true;\n-                        fdUseCount--;\n-                        socketPreClose();\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    void reset() {\n-        throw new InternalError(\"should not get here\");\n-    }\n-\n-    \/**\n-     * Shutdown read-half of the socket connection;\n-     *\/\n-    protected void shutdownInput() throws IOException {\n-      if (fd != null) {\n-          socketShutdown(SHUT_RD);\n-          if (socketInputStream != null) {\n-              socketInputStream.setEOF(true);\n-          }\n-          shut_rd = true;\n-      }\n-    }\n-\n-    \/**\n-     * Shutdown write-half of the socket connection;\n-     *\/\n-    protected void shutdownOutput() throws IOException {\n-      if (fd != null) {\n-          socketShutdown(SHUT_WR);\n-          shut_wr = true;\n-      }\n-    }\n-\n-    protected boolean supportsUrgentData () {\n-        return true;\n-    }\n-\n-    protected void sendUrgentData (int data) throws IOException {\n-        if (fd == null) {\n-            throw new IOException(\"Socket Closed\");\n-        }\n-        socketSendUrgentData (data);\n-    }\n-\n-    \/*\n-     * \"Acquires\" and returns the FileDescriptor for this impl\n-     *\n-     * A corresponding releaseFD is required to \"release\" the\n-     * FileDescriptor.\n-     *\/\n-    FileDescriptor acquireFD() {\n-        synchronized (fdLock) {\n-            fdUseCount++;\n-            return fd;\n-        }\n-    }\n-\n-    \/*\n-     * \"Release\" the FileDescriptor for this impl.\n-     *\n-     * If the use count goes to -1 then the socket is closed.\n-     *\/\n-    void releaseFD() {\n-        synchronized (fdLock) {\n-            fdUseCount--;\n-            if (fdUseCount == -1) {\n-                if (fd != null) {\n-                    try {\n-                        socketClose();\n-                    } catch (IOException e) {\n-                    } finally {\n-                        fd = null;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    boolean isConnectionReset() {\n-        return connectionReset;\n-    }\n-\n-    void setConnectionReset() {\n-        connectionReset = true;\n-    }\n-\n-    \/*\n-     * Return true if already closed or close is pending\n-     *\/\n-    public boolean isClosedOrPending() {\n-        \/*\n-         * Lock on fdLock to ensure that we wait if a\n-         * close is in progress.\n-         *\/\n-        synchronized (fdLock) {\n-            if (closePending || (fd == null)) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Return the current value of SO_TIMEOUT\n-     *\/\n-    public int getTimeout() {\n-        return timeout;\n-    }\n-\n-    \/*\n-     * \"Pre-close\" a socket by dup'ing the file descriptor - this enables\n-     * the socket to be closed without releasing the file descriptor.\n-     *\/\n-    private void socketPreClose() throws IOException {\n-        socketClose0(true);\n-    }\n-\n-    \/*\n-     * Close the socket (and release the file descriptor).\n-     *\/\n-    protected void socketClose() throws IOException {\n-        SocketCleanable.unregister(fd);\n-        try {\n-            socketClose0(false);\n-        } finally {\n-            if (!stream) {\n-                ResourceManager.afterUdpClose();\n-            }\n-        }\n-    }\n-\n-    abstract void socketCreate(boolean stream) throws IOException;\n-    abstract void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException;\n-    abstract void socketBind(InetAddress address, int port)\n-        throws IOException;\n-    abstract void socketListen(int count)\n-        throws IOException;\n-    abstract void socketAccept(SocketImpl s)\n-        throws IOException;\n-    abstract int socketAvailable()\n-        throws IOException;\n-    abstract void socketClose0(boolean useDeferredClose)\n-        throws IOException;\n-    abstract void socketShutdown(int howto)\n-        throws IOException;\n-    abstract void socketSetOption(int cmd, boolean on, Object value)\n-        throws SocketException;\n-    abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;\n-    abstract void socketSendUrgentData(int data)\n-        throws IOException;\n-\n-    public static final int SHUT_RD = 0;\n-    public static final int SHUT_WR = 1;\n-\n-    private static native boolean isReusePortAvailable0();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainSocketImpl.java","additions":0,"deletions":875,"binary":false,"changes":875,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,8 +55,0 @@\n-    \/**\n-     * Perform class initialization\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-        init();\n-    }\n-\n@@ -427,5 +419,0 @@\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramPacket.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -1341,8 +1342,0 @@\n-    private static final boolean USE_PLAINDATAGRAMSOCKET = usePlainDatagramSocketImpl();\n-\n-    private static boolean usePlainDatagramSocketImpl() {\n-        PrivilegedAction<String> pa = () -> NetProperties.get(\"jdk.net.usePlainDatagramSocketImpl\");\n-        @SuppressWarnings(\"removal\")\n-        String s = AccessController.doPrivileged(pa);\n-        return (s != null) && (s.isEmpty() || s.equalsIgnoreCase(\"true\"));\n-    }\n@@ -1401,1 +1394,1 @@\n-            if (USE_PLAINDATAGRAMSOCKET || factory != null) {\n+            if (factory != null) {\n@@ -1403,6 +1396,3 @@\n-                DatagramSocketImpl impl;\n-                if (factory != null) {\n-                    impl = factory.createDatagramSocketImpl();\n-                } else {\n-                    impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);\n-                }\n+                DatagramSocketImpl impl = factory.createDatagramSocketImpl();\n+                Objects.requireNonNull(impl,\n+                        \"Implementation returned by installed DatagramSocketImplFactory is null\");\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,18 +36,0 @@\n- * @implNote Sockets created with the {@code DatagramSocket} and {@code\n- * MulticastSocket} public constructors historically delegated all socket\n- * operations to a {@code DatagramSocketImpl} implementation named\n- * \"PlainDatagramSocketImpl\". {@code DatagramSocket} and {@code MulticastSocket}\n- * have since been changed to a new implementation based on {@code DatagramChannel}.\n- * The JDK continues to ship with the older implementation to allow code to run\n- * that depends on unspecified behavior that differs between the old and new\n- * implementations. The old implementation will be used if the Java virtual\n- * machine is started with the system property {@systemProperty\n- * jdk.net.usePlainDatagramSocketImpl} set to use the old implementation. It may\n- * also be set in the JDK's network configuration file, located in {@code\n- * ${java.home}\/conf\/net.properties}. The value of the property is the string\n- * representation of a boolean. If set without a value then it defaults to {@code\n- * true}, hence running with {@code -Djdk.net.usePlainDatagramSocketImpl} or\n- * {@code -Djdk.net.usePlainDatagramSocketImpl=true} will configure the Java\n- * virtual machine to use the old implementation. The property and old\n- * implementation will be removed in a future version.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -227,2 +226,0 @@\n-        InputStream stream = null;\n-\n@@ -231,9 +228,7 @@\n-            if (System.getSecurityManager() != null) {\n-                stream = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public InputStream run() {\n-                        return StringPrep.class.getResourceAsStream(IDN_PROFILE);\n-                    }\n-                });\n-            } else {\n-                stream = StringPrep.class.getResourceAsStream(IDN_PROFILE);\n-            }\n+            @SuppressWarnings(\"removal\")\n+            InputStream stream = System.getSecurityManager() != null\n+                    ? AccessController.doPrivileged(new PrivilegedAction<>() {\n+                            public InputStream run() {\n+                                return StringPrep.class.getResourceAsStream(IDN_PROFILE);\n+                            }})\n+                    : StringPrep.class.getResourceAsStream(IDN_PROFILE);\n","filename":"src\/java.base\/share\/classes\/java\/net\/IDN.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -139,2 +139,1 @@\n-        if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &&\n-                ((AbstractPlainDatagramSocketImpl) impl).nativeConnectDisabled())) {\n+        if (oldImpl) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.ref.CleanerFactory;\n-import jdk.internal.ref.PhantomCleanable;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.lang.ref.Cleaner;\n-\n-import sun.net.ResourceManager;\n-\n-\/**\n- * Cleanable for a socket\/datagramsocket FileDescriptor when it becomes phantom reachable.\n- * Create a cleanup if the raw fd != -1. Windows closes sockets using the fd.\n- * Subclassed from {@code PhantomCleanable} so that {@code clear} can be\n- * called to disable the cleanup when the socket fd is closed by any means\n- * other than calling {@link FileDescriptor#close}.\n- * Otherwise, it might incorrectly close the handle or fd after it has been reused.\n- *\/\n-final class SocketCleanable extends PhantomCleanable<FileDescriptor> {\n-\n-    \/\/ Access to FileDescriptor private fields\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-            SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    \/\/ Native function to call NET_SocketClose(fd)\n-    \/\/ Used only for last chance cleanup.\n-    private static native void cleanupClose0(int fd) throws IOException;\n-\n-    \/\/ The raw fd to close\n-    private final int fd;\n-\n-    \/\/ true for socket, false for datagram socket\n-    private final boolean stream;\n-\n-    \/**\n-     * Register a socket specific Cleanable with the FileDescriptor\n-     * if the FileDescriptor is non-null and the raw fd is != -1.\n-     *\n-     * @param fdo     the FileDescriptor; may be null\n-     * @param stream  false for datagram socket\n-     *\/\n-    static void register(FileDescriptor fdo, boolean stream) {\n-        if (fdo != null && fdo.valid()) {\n-            int fd = fdAccess.get(fdo);\n-            fdAccess.registerCleanup(fdo,\n-                    new SocketCleanable(fdo, CleanerFactory.cleaner(),\n-                                        fd, stream));\n-        }\n-    }\n-\n-    \/**\n-     * Unregister a Cleanable from the FileDescriptor.\n-     * @param fdo the FileDescriptor; may be null\n-     *\/\n-    static void unregister(FileDescriptor fdo) {\n-        if (fdo != null) {\n-            fdAccess.unregisterCleanup(fdo);\n-        }\n-    }\n-\n-    \/**\n-     * Constructor for a phantom cleanable reference.\n-     *\n-     * @param obj     the object to monitor\n-     * @param cleaner the cleaner\n-     * @param fd      file descriptor to close\n-     * @param stream  false for datagram socket\n-     *\/\n-    private SocketCleanable(FileDescriptor obj, Cleaner cleaner,\n-                            int fd, boolean stream) {\n-        super(obj, cleaner);\n-        this.fd = fd;\n-        this.stream = stream;\n-    }\n-\n-    \/**\n-     * Close the native handle or fd.\n-     *\/\n-    @Override\n-    protected void performCleanup() {\n-        try {\n-            cleanupClose0(fd);\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(\"close\", ioe);\n-        } finally {\n-            if (!stream) {\n-                ResourceManager.afterUdpClose();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketCleanable.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,1 +35,0 @@\n-import sun.net.NetProperties;\n@@ -46,17 +43,0 @@\n- * @implNote Client and server sockets created with the {@code Socket} and\n- * {@code SocketServer} public constructors create a system-default\n- * {@code SocketImpl}. The JDK historically used a {@code SocketImpl}\n- * implementation type named \"PlainSocketImpl\" that has since been replaced by a\n- * newer implementation. The JDK continues to ship with the older implementation\n- * to allow code to run that depends on unspecified behavior that differs between\n- * the old and new implementations. The old implementation will be used if the\n- * Java virtual machine is started with the system property {@systemProperty\n- * jdk.net.usePlainSocketImpl} set to use the old implementation. It may also be\n- * set in the JDK's network configuration file, located in {@code\n- * ${java.home}\/conf\/net.properties}. The value of the property is the string\n- * representation of a boolean. If set without a value then it defaults to {@code\n- * true}, hence running with {@code -Djdk.net.usePlainSocketImpl} or {@code\n- * -Djdk.net.usePlainSocketImpl=true} will configure the Java virtual machine\n- * to use the old implementation. The property and old implementation will be\n- * removed in a future version.\n- *\n@@ -66,8 +46,0 @@\n-    private static final boolean USE_PLAINSOCKETIMPL = usePlainSocketImpl();\n-\n-    private static boolean usePlainSocketImpl() {\n-        PrivilegedAction<String> pa = () -> NetProperties.get(\"jdk.net.usePlainSocketImpl\");\n-        @SuppressWarnings(\"removal\")\n-        String s = AccessController.doPrivileged(pa);\n-        return (s != null) && !s.equalsIgnoreCase(\"false\");\n-    }\n@@ -80,5 +52,1 @@\n-        if (USE_PLAINSOCKETIMPL) {\n-            return (S) new PlainSocketImpl(server);\n-        } else {\n-            return (S) new NioSocketImpl(server);\n-        }\n+        return (S) new NioSocketImpl(server);\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,250 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-\n-import sun.net.ConnectionResetException;\n-\n-\/**\n- * This stream extends FileInputStream to implement a\n- * SocketInputStream. Note that this class should <b>NOT<\/b> be\n- * public.\n- *\n- * @author      Jonathan Payne\n- * @author      Arthur van Hoff\n- *\/\n-class SocketInputStream extends FileInputStream {\n-    static {\n-        init();\n-    }\n-\n-    private boolean eof;\n-    private AbstractPlainSocketImpl impl = null;\n-    private byte temp[];\n-\n-    \/**\n-     * Creates a new SocketInputStream. Can only be called\n-     * by a Socket. This method needs to hang on to the owner Socket so\n-     * that the fd will not be closed.\n-     * @param impl the implemented socket input stream\n-     *\/\n-    SocketInputStream(AbstractPlainSocketImpl impl) throws IOException {\n-        super(impl.getFileDescriptor());\n-        this.impl = impl;\n-    }\n-\n-    \/**\n-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}\n-     * object associated with this file input stream.<\/p>\n-     *\n-     * The {@code getChannel} method of {@code SocketInputStream}\n-     * returns {@code null} since it is a socket based stream.<\/p>\n-     *\n-     * @return  the file channel associated with this file input stream\n-     *\n-     * @since 1.4\n-     *\/\n-    public final FileChannel getChannel() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Reads into an array of bytes at the specified offset using\n-     * the received socket primitive.\n-     * @param fd the FileDescriptor\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param len the maximum number of bytes read\n-     * @param timeout the read timeout in ms\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native int socketRead0(FileDescriptor fd,\n-                                   byte b[], int off, int len,\n-                                   int timeout)\n-        throws IOException;\n-\n-    \/\/ wrap native call to allow instrumentation\n-    \/**\n-     * Reads into an array of bytes at the specified offset using\n-     * the received socket primitive.\n-     * @param fd the FileDescriptor\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param len the maximum number of bytes read\n-     * @param timeout the read timeout in ms\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private int socketRead(FileDescriptor fd,\n-                           byte b[], int off, int len,\n-                           int timeout)\n-        throws IOException {\n-        return socketRead0(fd, b, off, len, timeout);\n-    }\n-\n-    \/**\n-     * Reads into a byte array data from the socket.\n-     * @param b the buffer into which the data is read\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public int read(byte b[]) throws IOException {\n-        return read(b, 0, b.length);\n-    }\n-\n-    \/**\n-     * Reads into a byte array <i>b<\/i> at offset <i>off<\/i>,\n-     * <i>length<\/i> bytes of data.\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param length the maximum number of bytes read\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public int read(byte b[], int off, int length) throws IOException {\n-        return read(b, off, length, impl.getTimeout());\n-    }\n-\n-    int read(byte b[], int off, int length, int timeout) throws IOException {\n-        int n;\n-\n-        \/\/ EOF already encountered\n-        if (eof) {\n-            return -1;\n-        }\n-\n-        \/\/ connection reset\n-        if (impl.isConnectionReset()) {\n-            throw new SocketException(\"Connection reset\");\n-        }\n-\n-        \/\/ bounds check\n-        if (length <= 0 || off < 0 || length > b.length - off) {\n-            if (length == 0) {\n-                return 0;\n-            }\n-            throw new ArrayIndexOutOfBoundsException(\"length == \" + length\n-                    + \" off == \" + off + \" buffer length == \" + b.length);\n-        }\n-\n-        \/\/ acquire file descriptor and do the read\n-        FileDescriptor fd = impl.acquireFD();\n-        try {\n-            n = socketRead(fd, b, off, length, timeout);\n-            if (n > 0) {\n-                return n;\n-            }\n-        } catch (ConnectionResetException rstExc) {\n-            impl.setConnectionReset();\n-        } finally {\n-            impl.releaseFD();\n-        }\n-\n-        \/*\n-         * If we get here we are at EOF, the socket has been closed,\n-         * or the connection has been reset.\n-         *\/\n-        if (impl.isClosedOrPending()) {\n-            throw new SocketException(\"Socket closed\");\n-        }\n-        if (impl.isConnectionReset()) {\n-            throw new SocketException(\"Connection reset\");\n-        }\n-        eof = true;\n-        return -1;\n-    }\n-\n-    \/**\n-     * Reads a single byte from the socket.\n-     *\/\n-    public int read() throws IOException {\n-        if (eof) {\n-            return -1;\n-        }\n-        temp = new byte[1];\n-        int n = read(temp, 0, 1);\n-        if (n <= 0) {\n-            return -1;\n-        }\n-        return temp[0] & 0xff;\n-    }\n-\n-    \/**\n-     * Skips n bytes of input.\n-     * @param numbytes the number of bytes to skip\n-     * @return  the actual number of bytes skipped.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public long skip(long numbytes) throws IOException {\n-        if (numbytes <= 0) {\n-            return 0;\n-        }\n-        long n = numbytes;\n-        int buflen = (int) Math.min(1024, n);\n-        byte data[] = new byte[buflen];\n-        while (n > 0) {\n-            int r = read(data, 0, (int) Math.min((long) buflen, n));\n-            if (r < 0) {\n-                break;\n-            }\n-            n -= r;\n-        }\n-        return numbytes - n;\n-    }\n-\n-    \/**\n-     * Returns the number of bytes that can be read without blocking.\n-     * @return the number of immediately available bytes\n-     *\/\n-    public int available() throws IOException {\n-        int available = impl.available();\n-        return eof ? 0 : available;\n-    }\n-\n-    void setEOF(boolean eof) {\n-        this.eof = eof;\n-    }\n-\n-    public void close() throws IOException {\n-        \/\/ No longer used. Socket.getInputStream returns an\n-        \/\/ InputStream which calls Socket.close directly\n-        assert false;\n-    }\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketInputStream.java","additions":0,"deletions":250,"binary":false,"changes":250,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-\n-\/**\n- * This stream extends FileOutputStream to implement a\n- * SocketOutputStream. Note that this class should <b>NOT<\/b> be\n- * public.\n- *\n- * @author      Jonathan Payne\n- * @author      Arthur van Hoff\n- *\/\n-class SocketOutputStream extends FileOutputStream {\n-    static {\n-        init();\n-    }\n-\n-    private AbstractPlainSocketImpl impl = null;\n-    private byte temp[] = new byte[1];\n-\n-    \/**\n-     * Creates a new SocketOutputStream. Can only be called\n-     * by a Socket. This method needs to hang on to the owner Socket so\n-     * that the fd will not be closed.\n-     * @param impl the socket output stream implemented\n-     *\/\n-    SocketOutputStream(AbstractPlainSocketImpl impl) throws IOException {\n-        super(impl.getFileDescriptor());\n-        this.impl = impl;\n-    }\n-\n-    \/**\n-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}\n-     * object associated with this file output stream. <\/p>\n-     *\n-     * The {@code getChannel} method of {@code SocketOutputStream}\n-     * returns {@code null} since it is a socket based stream.<\/p>\n-     *\n-     * @return  the file channel associated with this file output stream\n-     *\n-     * @since 1.4\n-     *\/\n-    public final FileChannel getChannel() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Writes to the socket.\n-     * @param fd the FileDescriptor\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native void socketWrite0(FileDescriptor fd, byte[] b, int off,\n-                                     int len) throws IOException;\n-\n-    \/**\n-     * Writes to the socket with appropriate locking of the\n-     * FileDescriptor.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private void socketWrite(byte b[], int off, int len) throws IOException {\n-\n-\n-        if (len <= 0 || off < 0 || len > b.length - off) {\n-            if (len == 0) {\n-                return;\n-            }\n-            throw new ArrayIndexOutOfBoundsException(\"len == \" + len\n-                    + \" off == \" + off + \" buffer length == \" + b.length);\n-        }\n-\n-        FileDescriptor fd = impl.acquireFD();\n-        try {\n-            socketWrite0(fd, b, off, len);\n-        } catch (SocketException se) {\n-            if (impl.isClosedOrPending()) {\n-                throw new SocketException(\"Socket closed\");\n-            } else {\n-                throw se;\n-            }\n-        } finally {\n-            impl.releaseFD();\n-        }\n-    }\n-\n-    \/**\n-     * Writes a byte to the socket.\n-     * @param b the data to be written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public void write(int b) throws IOException {\n-        temp[0] = (byte)b;\n-        socketWrite(temp, 0, 1);\n-    }\n-\n-    \/**\n-     * Writes the contents of the buffer <i>b<\/i> to the socket.\n-     * @param b the data to be written\n-     * @throws    SocketException If an I\/O error has occurred.\n-     *\/\n-    public void write(byte b[]) throws IOException {\n-        socketWrite(b, 0, b.length);\n-    }\n-\n-    \/**\n-     * Writes <i>length<\/i> bytes from buffer <i>b<\/i> starting at\n-     * offset <i>len<\/i>.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    SocketException If an I\/O error has occurred.\n-     *\/\n-    public void write(byte b[], int off, int len) throws IOException {\n-        socketWrite(b, off, len);\n-    }\n-\n-    public void close() throws IOException {\n-        \/\/ No longer used. Socket.getOutputStream returns an\n-        \/\/ OutputStream which calls Socket.close directly\n-        assert false;\n-    }\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketOutputStream.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -40,0 +39,1 @@\n+import java.util.Objects;\n@@ -740,1 +740,0 @@\n-    @IntrinsicCandidate\n@@ -742,3 +741,1 @@\n-        if ((i < 0) || (i >= limit))\n-            throw new IndexOutOfBoundsException();\n-        return i;\n+        return Objects.checkIndex(i, limit);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1669,10 +1669,5 @@\n-        StringBuffer sb = new StringBuffer();\n-        sb.append(getClass().getName());\n-        sb.append(\"[pos=\");\n-        sb.append(position());\n-        sb.append(\" lim=\");\n-        sb.append(limit());\n-        sb.append(\" cap=\");\n-        sb.append(capacity());\n-        sb.append(\"]\");\n-        return sb.toString();\n+        return getClass().getName()\n+                 + \"[pos=\" + position()\n+                 + \" lim=\" + limit()\n+                 + \" cap=\" + capacity()\n+                 + \"]\";\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-     * Path}\"{@code foo\/bar}\" with the {@code String} \"{@code bar\/}\" returns\n+     * Path} \"{@code foo\/bar}\" with the {@code String} \"{@code bar\/}\" returns\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,6 +450,2 @@\n-        case INITIAL:\n-            p.print(\"<initialized>\");\n-            break;\n-        case IN_PROGRESS:\n-            p.print(\"<in progress>\");\n-            break;\n+            case INITIAL     -> p.print(\"<initialized>\");\n+            case IN_PROGRESS -> p.print(\"<in progress>\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -950,12 +950,6 @@\n-        String initState = \"\";\n-        switch (state) {\n-        case UNINITIALIZED:\n-            initState = \"<not initialized>\";\n-            break;\n-        case VERIFY:\n-            initState = \"<initialized for verifying>\";\n-            break;\n-        case SIGN:\n-            initState = \"<initialized for signing>\";\n-            break;\n-        }\n+        String initState = switch (state) {\n+            case UNINITIALIZED -> \"<not initialized>\";\n+            case VERIFY        -> \"<initialized for verifying>\";\n+            case SIGN          -> \"<initialized for signing>\";\n+            default -> \"\";\n+        };\n@@ -1320,20 +1314,7 @@\n-            case I_PUB:\n-                spi.engineInitVerify((PublicKey)key);\n-                break;\n-            case I_PUB_PARAM:\n-                spi.engineInitVerify((PublicKey)key, params);\n-                break;\n-            case I_PRIV:\n-                spi.engineInitSign((PrivateKey)key);\n-                break;\n-            case I_PRIV_SR:\n-                spi.engineInitSign((PrivateKey)key, random);\n-                break;\n-            case I_PRIV_PARAM_SR:\n-                spi.engineInitSign((PrivateKey)key, params, random);\n-                break;\n-            case S_PARAM:\n-                spi.engineSetParameter(params);\n-                break;\n-            default:\n-                throw new AssertionError(\"Internal error: \" + type);\n+                case I_PUB           -> spi.engineInitVerify((PublicKey) key);\n+                case I_PUB_PARAM     -> spi.engineInitVerify((PublicKey) key, params);\n+                case I_PRIV          -> spi.engineInitSign((PrivateKey) key);\n+                case I_PRIV_SR       -> spi.engineInitSign((PrivateKey) key, random);\n+                case I_PRIV_PARAM_SR -> spi.engineInitSign((PrivateKey) key, params, random);\n+                case S_PARAM         -> spi.engineSetParameter(params);\n+                default -> throw new AssertionError(\"Internal error: \" + type);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -892,23 +892,10 @@\n-            switch (type) {\n-            case NAME_RFC822:\n-                result = new RFC822Name(nameAsString);\n-                break;\n-            case NAME_DNS:\n-                result = new DNSName(nameAsString);\n-                break;\n-            case NAME_DIRECTORY:\n-                result = new X500Name(nameAsString);\n-                break;\n-            case NAME_URI:\n-                result = new URIName(nameAsString);\n-                break;\n-            case NAME_IP:\n-                result = new IPAddressName(nameAsString);\n-                break;\n-            case NAME_OID:\n-                result = new OIDName(nameAsString);\n-                break;\n-            default:\n-                throw new IOException(\"unable to parse String names of type \"\n-                                      + type);\n-            }\n+            result = switch (type) {\n+                case NAME_RFC822    -> new RFC822Name(nameAsString);\n+                case NAME_DNS       -> new DNSName(nameAsString);\n+                case NAME_DIRECTORY -> new X500Name(nameAsString);\n+                case NAME_URI       -> new URIName(nameAsString);\n+                case NAME_IP        -> new IPAddressName(nameAsString);\n+                case NAME_OID       -> new OIDName(nameAsString);\n+                default -> throw new IOException(\"unable to parse String names of type \"\n+                                                 + type);\n+            };\n@@ -926,32 +913,13 @@\n-            switch (type) {\n-            case NAME_ANY:\n-                result = new OtherName(val);\n-                break;\n-            case NAME_RFC822:\n-                result = new RFC822Name(val);\n-                break;\n-            case NAME_DNS:\n-                result = new DNSName(val);\n-                break;\n-            case NAME_X400:\n-                result = new X400Address(val);\n-                break;\n-            case NAME_DIRECTORY:\n-                result = new X500Name(val);\n-                break;\n-            case NAME_EDI:\n-                result = new EDIPartyName(val);\n-                break;\n-            case NAME_URI:\n-                result = new URIName(val);\n-                break;\n-            case NAME_IP:\n-                result = new IPAddressName(val);\n-                break;\n-            case NAME_OID:\n-                result = new OIDName(val);\n-                break;\n-            default:\n-                throw new IOException(\"unable to parse byte array names of \"\n-                    + \"type \" + type);\n-            }\n+            result = switch (type) {\n+                case NAME_ANY       -> new OtherName(val);\n+                case NAME_RFC822    -> new RFC822Name(val);\n+                case NAME_DNS       -> new DNSName(val);\n+                case NAME_X400      -> new X400Address(val);\n+                case NAME_DIRECTORY -> new X500Name(val);\n+                case NAME_EDI       -> new EDIPartyName(val);\n+                case NAME_URI       -> new URIName(val);\n+                case NAME_IP        -> new IPAddressName(val);\n+                case NAME_OID       -> new OIDName(val);\n+                default -> throw new IOException(\"unable to parse byte array names of \"\n+                                                 + \"type \" + type);\n+            };\n@@ -1931,14 +1899,8 @@\n-            switch (extId) {\n-                case PrivateKeyUsage:\n-                    return impl.getPrivateKeyUsageExtension();\n-                case SubjectAlternativeName:\n-                    return impl.getSubjectAlternativeNameExtension();\n-                case NameConstraints:\n-                    return impl.getNameConstraintsExtension();\n-                case CertificatePolicies:\n-                    return impl.getCertificatePoliciesExtension();\n-                case extendedKeyUsage:\n-                    return impl.getExtendedKeyUsageExtension();\n-                default:\n-                    return null;\n-            }\n+            return switch (extId) {\n+                case PrivateKeyUsage        -> impl.getPrivateKeyUsageExtension();\n+                case SubjectAlternativeName -> impl.getSubjectAlternativeNameExtension();\n+                case NameConstraints        -> impl.getNameConstraintsExtension();\n+                case CertificatePolicies    -> impl.getCertificatePoliciesExtension();\n+                case extendedKeyUsage       -> impl.getExtendedKeyUsageExtension();\n+                default -> null;\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":31,"deletions":69,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -585,0 +585,14 @@\n+    \/**\n+     * Checks if this duration is positive, excluding zero.\n+     * <p>\n+     * A {@code Duration} represents a directed distance between two points on\n+     * the time-line and can therefore be positive, zero or negative.\n+     * This method checks whether the length is greater than zero.\n+     *\n+     * @return true if this duration has a total length greater than zero\n+     * @since 18\n+     *\/\n+    public boolean isPositive() {\n+        return (seconds | nanos) > 0;\n+    }\n+\n@@ -723,7 +737,7 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n-                case MILLIS: return plusMillis(amountToAdd);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-            }\n-            return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            return switch (chronoUnit) {\n+                case NANOS -> plusNanos(amountToAdd);\n+                case MICROS -> plusSeconds((amountToAdd \/ (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);\n+                case MILLIS -> plusMillis(amountToAdd);\n+                case SECONDS -> plusSeconds(amountToAdd);\n+                default -> plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));\n+            };\n@@ -1263,0 +1277,2 @@\n+     * @apiNote\n+     * This method behaves exactly the same way as {@link #toDays()}.\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -561,7 +561,7 @@\n-        if (field instanceof ChronoField) {\n-            switch ((ChronoField) field) {\n-                case NANO_OF_SECOND: return nanos;\n-                case MICRO_OF_SECOND: return nanos \/ 1000;\n-                case MILLI_OF_SECOND: return nanos \/ 1000_000;\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        if (field instanceof ChronoField chronoField) {\n+            return switch (chronoField) {\n+                case NANO_OF_SECOND -> nanos;\n+                case MICRO_OF_SECOND -> nanos \/ 1000;\n+                case MILLI_OF_SECOND -> nanos \/ 1000_000;\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -597,8 +597,8 @@\n-        if (field instanceof ChronoField) {\n-            switch ((ChronoField) field) {\n-                case NANO_OF_SECOND: return nanos;\n-                case MICRO_OF_SECOND: return nanos \/ 1000;\n-                case MILLI_OF_SECOND: return nanos \/ 1000_000;\n-                case INSTANT_SECONDS: return seconds;\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        if (field instanceof ChronoField chronoField) {\n+            return switch (chronoField) {\n+                case NANO_OF_SECOND -> nanos;\n+                case MICRO_OF_SECOND -> nanos \/ 1000;\n+                case MILLI_OF_SECOND -> nanos \/ 1000_000;\n+                case INSTANT_SECONDS -> seconds;\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -708,2 +708,2 @@\n-            switch (chronoField) {\n-                case MILLI_OF_SECOND: {\n+            return switch (chronoField) {\n+                case MILLI_OF_SECOND -> {\n@@ -711,1 +711,1 @@\n-                    return (nval != nanos ? create(seconds, nval) : this);\n+                    yield nval != nanos ? create(seconds, nval) : this;\n@@ -713,1 +713,1 @@\n-                case MICRO_OF_SECOND: {\n+                case MICRO_OF_SECOND -> {\n@@ -715,1 +715,1 @@\n-                    return (nval != nanos ? create(seconds, nval) : this);\n+                    yield nval != nanos ? create(seconds, nval) : this;\n@@ -717,4 +717,4 @@\n-                case NANO_OF_SECOND: return (newValue != nanos ? create(seconds, (int) newValue) : this);\n-                case INSTANT_SECONDS: return (newValue != seconds ? create(newValue, nanos) : this);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+                case NANO_OF_SECOND -> newValue != nanos ? create(seconds, (int) newValue) : this;\n+                case INSTANT_SECONDS -> newValue != seconds ? create(newValue, nanos) : this;\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -851,12 +851,12 @@\n-        if (unit instanceof ChronoUnit) {\n-            switch ((ChronoUnit) unit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plus(amountToAdd \/ 1000_000, (amountToAdd % 1000_000) * 1000);\n-                case MILLIS: return plusMillis(amountToAdd);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_MINUTE));\n-                case HOURS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_HOUR));\n-                case HALF_DAYS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY \/ 2));\n-                case DAYS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+        if (unit instanceof ChronoUnit chronoUnit) {\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plus(amountToAdd \/ 1000_000, (amountToAdd % 1000_000) * 1000);\n+                case MILLIS    -> plusMillis(amountToAdd);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_MINUTE));\n+                case HOURS     -> plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_HOUR));\n+                case HALF_DAYS -> plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY \/ 2));\n+                case DAYS      -> plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -1146,11 +1146,11 @@\n-            switch (chronoUnit) {\n-                case NANOS: return nanosUntil(end);\n-                case MICROS: return nanosUntil(end) \/ 1000;\n-                case MILLIS: return Math.subtractExact(end.toEpochMilli(), toEpochMilli());\n-                case SECONDS: return secondsUntil(end);\n-                case MINUTES: return secondsUntil(end) \/ SECONDS_PER_MINUTE;\n-                case HOURS: return secondsUntil(end) \/ SECONDS_PER_HOUR;\n-                case HALF_DAYS: return secondsUntil(end) \/ (12 * SECONDS_PER_HOUR);\n-                case DAYS: return secondsUntil(end) \/ (SECONDS_PER_DAY);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case NANOS     -> nanosUntil(end);\n+                case MICROS    -> nanosUntil(end) \/ 1000;\n+                case MILLIS    -> Math.subtractExact(end.toEpochMilli(), toEpochMilli());\n+                case SECONDS   -> secondsUntil(end);\n+                case MINUTES   -> secondsUntil(end) \/ SECONDS_PER_MINUTE;\n+                case HOURS     -> secondsUntil(end) \/ SECONDS_PER_HOUR;\n+                case HALF_DAYS -> secondsUntil(end) \/ (12 * SECONDS_PER_HOUR);\n+                case DAYS      -> secondsUntil(end) \/ (SECONDS_PER_DAY);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -445,12 +445,5 @@\n-            int dom = 31;\n-            switch (month) {\n-                case 2:\n-                    dom = (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n-                    break;\n-                case 4:\n-                case 6:\n-                case 9:\n-                case 11:\n-                    dom = 30;\n-                    break;\n-            }\n+            int dom = switch (month) {\n+                case 2 -> (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n+                case 4, 6, 9, 11 -> 30;\n+                default -> 31;\n+            };\n@@ -478,9 +471,2 @@\n-            case 2:\n-                day = Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n-                break;\n-            case 4:\n-            case 6:\n-            case 9:\n-            case 11:\n-                day = Math.min(day, 30);\n-                break;\n+            case 2 -> day = Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n+            case 4, 6, 9, 11 -> day = Math.min(day, 30);\n@@ -607,8 +593,7 @@\n-                switch (chronoField) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() == Month.FEBRUARY && isLeapYear() == false ? 4 : 5);\n-                    case YEAR_OF_ERA:\n-                        return (getYear() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n-                }\n-                return field.range();\n+                return switch (chronoField) {\n+                    case DAY_OF_MONTH -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR -> ValueRange.of(1, lengthOfYear());\n+                    case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, getMonth() == Month.FEBRUARY && !isLeapYear() ? 4 : 5);\n+                    case YEAR_OF_ERA -> (getYear() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n+                    default -> field.range();\n+                };\n@@ -694,16 +679,16 @@\n-        switch ((ChronoField) field) {\n-            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n-            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n-            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n-            case DAY_OF_MONTH: return day;\n-            case DAY_OF_YEAR: return getDayOfYear();\n-            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field 'EpochDay' for get() method, use getLong() instead\");\n-            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) \/ 7) + 1;\n-            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) \/ 7) + 1;\n-            case MONTH_OF_YEAR: return month;\n-            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field 'ProlepticMonth' for get() method, use getLong() instead\");\n-            case YEAR_OF_ERA: return (year >= 1 ? year : 1 - year);\n-            case YEAR: return year;\n-            case ERA: return (year >= 1 ? 1 : 0);\n-        }\n-        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        return switch ((ChronoField) field) {\n+            case DAY_OF_WEEK -> getDayOfWeek().getValue();\n+            case ALIGNED_DAY_OF_WEEK_IN_MONTH -> ((day - 1) % 7) + 1;\n+            case ALIGNED_DAY_OF_WEEK_IN_YEAR -> ((getDayOfYear() - 1) % 7) + 1;\n+            case DAY_OF_MONTH -> day;\n+            case DAY_OF_YEAR -> getDayOfYear();\n+            case EPOCH_DAY -> throw new UnsupportedTemporalTypeException(\"Invalid field 'EpochDay' for get() method, use getLong() instead\");\n+            case ALIGNED_WEEK_OF_MONTH -> ((day - 1) \/ 7) + 1;\n+            case ALIGNED_WEEK_OF_YEAR -> ((getDayOfYear() - 1) \/ 7) + 1;\n+            case MONTH_OF_YEAR -> month;\n+            case PROLEPTIC_MONTH -> throw new UnsupportedTemporalTypeException(\"Invalid field 'ProlepticMonth' for get() method, use getLong() instead\");\n+            case YEAR_OF_ERA -> (year >= 1 ? year : 1 - year);\n+            case YEAR -> year;\n+            case ERA -> (year >= 1 ? 1 : 0);\n+            default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        };\n@@ -869,11 +854,5 @@\n-        switch (month) {\n-            case 2:\n-                return (isLeapYear() ? 29 : 28);\n-            case 4:\n-            case 6:\n-            case 9:\n-            case 11:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (month) {\n+            case 2 -> (isLeapYear() ? 29 : 28);\n+            case 4, 6, 9, 11 -> 30;\n+            default -> 31;\n+        };\n@@ -1049,16 +1028,16 @@\n-            switch (chronoField) {\n-                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n-                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n-                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n-                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n-                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n-                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n-                case MONTH_OF_YEAR: return withMonth((int) newValue);\n-                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA: return withYear((int) (year >= 1 ? newValue : 1 - newValue));\n-                case YEAR: return withYear((int) newValue);\n-                case ERA: return (getLong(ERA) == newValue ? this : withYear(1 - year));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case DAY_OF_WEEK -> plusDays(newValue - getDayOfWeek().getValue());\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH -> plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR -> plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n+                case DAY_OF_MONTH -> withDayOfMonth((int) newValue);\n+                case DAY_OF_YEAR -> withDayOfYear((int) newValue);\n+                case EPOCH_DAY -> LocalDate.ofEpochDay(newValue);\n+                case ALIGNED_WEEK_OF_MONTH -> plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n+                case ALIGNED_WEEK_OF_YEAR -> plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n+                case MONTH_OF_YEAR -> withMonth((int) newValue);\n+                case PROLEPTIC_MONTH -> plusMonths(newValue - getProlepticMonth());\n+                case YEAR_OF_ERA -> withYear((int) (year >= 1 ? newValue : 1 - newValue));\n+                case YEAR -> withYear((int) newValue);\n+                case ERA -> (getLong(ERA) == newValue ? this : withYear(1 - year));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -1260,11 +1239,11 @@\n-            switch (chronoUnit) {\n-                case DAYS: return plusDays(amountToAdd);\n-                case WEEKS: return plusWeeks(amountToAdd);\n-                case MONTHS: return plusMonths(amountToAdd);\n-                case YEARS: return plusYears(amountToAdd);\n-                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n-                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n-                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n-                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case DAYS      -> plusDays(amountToAdd);\n+                case WEEKS     -> plusWeeks(amountToAdd);\n+                case MONTHS    -> plusMonths(amountToAdd);\n+                case YEARS     -> plusYears(amountToAdd);\n+                case DECADES   -> plusYears(Math.multiplyExact(amountToAdd, 10));\n+                case CENTURIES -> plusYears(Math.multiplyExact(amountToAdd, 100));\n+                case MILLENNIA -> plusYears(Math.multiplyExact(amountToAdd, 1000));\n+                case ERAS      -> with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -1642,12 +1621,12 @@\n-        if (unit instanceof ChronoUnit) {\n-            switch ((ChronoUnit) unit) {\n-                case DAYS: return daysUntil(end);\n-                case WEEKS: return daysUntil(end) \/ 7;\n-                case MONTHS: return monthsUntil(end);\n-                case YEARS: return monthsUntil(end) \/ 12;\n-                case DECADES: return monthsUntil(end) \/ 120;\n-                case CENTURIES: return monthsUntil(end) \/ 1200;\n-                case MILLENNIA: return monthsUntil(end) \/ 12000;\n-                case ERAS: return end.getLong(ERA) - getLong(ERA);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+        if (unit instanceof ChronoUnit chronoUnit) {\n+            return switch (chronoUnit) {\n+                case DAYS      -> daysUntil(end);\n+                case WEEKS     -> daysUntil(end) \/ 7;\n+                case MONTHS    -> monthsUntil(end);\n+                case YEARS     -> monthsUntil(end) \/ 12;\n+                case DECADES   -> monthsUntil(end) \/ 120;\n+                case CENTURIES -> monthsUntil(end) \/ 1200;\n+                case MILLENNIA -> monthsUntil(end) \/ 12000;\n+                case ERAS      -> end.getLong(ERA) - getLong(ERA);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":74,"deletions":95,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -1180,10 +1180,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -686,18 +686,18 @@\n-        switch ((ChronoField) field) {\n-            case NANO_OF_SECOND: return nano;\n-            case NANO_OF_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field 'NanoOfDay' for get() method, use getLong() instead\");\n-            case MICRO_OF_SECOND: return nano \/ 1000;\n-            case MICRO_OF_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field 'MicroOfDay' for get() method, use getLong() instead\");\n-            case MILLI_OF_SECOND: return nano \/ 1000_000;\n-            case MILLI_OF_DAY: return (int) (toNanoOfDay() \/ 1000_000);\n-            case SECOND_OF_MINUTE: return second;\n-            case SECOND_OF_DAY: return toSecondOfDay();\n-            case MINUTE_OF_HOUR: return minute;\n-            case MINUTE_OF_DAY: return hour * 60 + minute;\n-            case HOUR_OF_AMPM: return hour % 12;\n-            case CLOCK_HOUR_OF_AMPM: int ham = hour % 12; return (ham % 12 == 0 ? 12 : ham);\n-            case HOUR_OF_DAY: return hour;\n-            case CLOCK_HOUR_OF_DAY: return (hour == 0 ? 24 : hour);\n-            case AMPM_OF_DAY: return hour \/ 12;\n-        }\n-        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        return switch ((ChronoField) field) {\n+            case NANO_OF_SECOND -> nano;\n+            case NANO_OF_DAY -> throw new UnsupportedTemporalTypeException(\"Invalid field 'NanoOfDay' for get() method, use getLong() instead\");\n+            case MICRO_OF_SECOND -> nano \/ 1000;\n+            case MICRO_OF_DAY -> throw new UnsupportedTemporalTypeException(\"Invalid field 'MicroOfDay' for get() method, use getLong() instead\");\n+            case MILLI_OF_SECOND -> nano \/ 1000_000;\n+            case MILLI_OF_DAY -> (int) (toNanoOfDay() \/ 1000_000);\n+            case SECOND_OF_MINUTE -> second;\n+            case SECOND_OF_DAY -> toSecondOfDay();\n+            case MINUTE_OF_HOUR -> minute;\n+            case MINUTE_OF_DAY -> hour * 60 + minute;\n+            case HOUR_OF_AMPM -> hour % 12;\n+            case CLOCK_HOUR_OF_AMPM -> { int ham = hour % 12; yield ham % 12 == 0 ? 12 : ham; }\n+            case HOUR_OF_DAY -> hour;\n+            case CLOCK_HOUR_OF_DAY -> (hour == 0 ? 24 : hour);\n+            case AMPM_OF_DAY -> hour \/ 12;\n+            default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+        };\n@@ -860,18 +860,18 @@\n-            switch (chronoField) {\n-                case NANO_OF_SECOND: return withNano((int) newValue);\n-                case NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);\n-                case MICRO_OF_SECOND: return withNano((int) newValue * 1000);\n-                case MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);\n-                case MILLI_OF_SECOND: return withNano((int) newValue * 1000_000);\n-                case MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000_000);\n-                case SECOND_OF_MINUTE: return withSecond((int) newValue);\n-                case SECOND_OF_DAY: return plusSeconds(newValue - toSecondOfDay());\n-                case MINUTE_OF_HOUR: return withMinute((int) newValue);\n-                case MINUTE_OF_DAY: return plusMinutes(newValue - (hour * 60 + minute));\n-                case HOUR_OF_AMPM: return plusHours(newValue - (hour % 12));\n-                case CLOCK_HOUR_OF_AMPM: return plusHours((newValue == 12 ? 0 : newValue) - (hour % 12));\n-                case HOUR_OF_DAY: return withHour((int) newValue);\n-                case CLOCK_HOUR_OF_DAY: return withHour((int) (newValue == 24 ? 0 : newValue));\n-                case AMPM_OF_DAY: return plusHours((newValue - (hour \/ 12)) * 12);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case NANO_OF_SECOND     -> withNano((int) newValue);\n+                case NANO_OF_DAY        -> LocalTime.ofNanoOfDay(newValue);\n+                case MICRO_OF_SECOND    -> withNano((int) newValue * 1000);\n+                case MICRO_OF_DAY       -> LocalTime.ofNanoOfDay(newValue * 1000);\n+                case MILLI_OF_SECOND    -> withNano((int) newValue * 1000_000);\n+                case MILLI_OF_DAY       -> LocalTime.ofNanoOfDay(newValue * 1000_000);\n+                case SECOND_OF_MINUTE   -> withSecond((int) newValue);\n+                case SECOND_OF_DAY      -> plusSeconds(newValue - toSecondOfDay());\n+                case MINUTE_OF_HOUR     -> withMinute((int) newValue);\n+                case MINUTE_OF_DAY      -> plusMinutes(newValue - (hour * 60 + minute));\n+                case HOUR_OF_AMPM       -> plusHours(newValue - (hour % 12));\n+                case CLOCK_HOUR_OF_AMPM -> plusHours((newValue == 12 ? 0 : newValue) - (hour % 12));\n+                case HOUR_OF_DAY        -> withHour((int) newValue);\n+                case CLOCK_HOUR_OF_DAY  -> withHour((int) (newValue == 24 ? 0 : newValue));\n+                case AMPM_OF_DAY        -> plusHours((newValue - (hour \/ 12)) * 12);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -1069,10 +1069,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusHours((amountToAdd % 2) * 12);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusHours((amountToAdd % 2) * 12);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -1411,10 +1411,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return nanosUntil;\n-                case MICROS: return nanosUntil \/ 1000;\n-                case MILLIS: return nanosUntil \/ 1000_000;\n-                case SECONDS: return nanosUntil \/ NANOS_PER_SECOND;\n-                case MINUTES: return nanosUntil \/ NANOS_PER_MINUTE;\n-                case HOURS: return nanosUntil \/ NANOS_PER_HOUR;\n-                case HALF_DAYS: return nanosUntil \/ (12 * NANOS_PER_HOUR);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case NANOS     -> nanosUntil;\n+                case MICROS    -> nanosUntil \/ 1000;\n+                case MILLIS    -> nanosUntil \/ 1000_000;\n+                case SECONDS   -> nanosUntil \/ NANOS_PER_SECOND;\n+                case MINUTES   -> nanosUntil \/ NANOS_PER_MINUTE;\n+                case HOURS     -> nanosUntil \/ NANOS_PER_HOUR;\n+                case HALF_DAYS -> nanosUntil \/ (12 * NANOS_PER_HOUR);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -426,11 +426,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return (leapYear ? 29 : 28);\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> (leapYear ? 29 : 28);\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -449,11 +443,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 28;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 28;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -472,11 +460,5 @@\n-        switch (this) {\n-            case FEBRUARY:\n-                return 29;\n-            case APRIL:\n-            case JUNE:\n-            case SEPTEMBER:\n-            case NOVEMBER:\n-                return 30;\n-            default:\n-                return 31;\n-        }\n+        return switch (this) {\n+            case FEBRUARY -> 29;\n+            case APRIL, JUNE, SEPTEMBER, NOVEMBER -> 30;\n+            default -> 31;\n+        };\n@@ -497,27 +479,15 @@\n-        switch (this) {\n-            case JANUARY:\n-                return 1;\n-            case FEBRUARY:\n-                return 32;\n-            case MARCH:\n-                return 60 + leap;\n-            case APRIL:\n-                return 91 + leap;\n-            case MAY:\n-                return 121 + leap;\n-            case JUNE:\n-                return 152 + leap;\n-            case JULY:\n-                return 182 + leap;\n-            case AUGUST:\n-                return 213 + leap;\n-            case SEPTEMBER:\n-                return 244 + leap;\n-            case OCTOBER:\n-                return 274 + leap;\n-            case NOVEMBER:\n-                return 305 + leap;\n-            case DECEMBER:\n-            default:\n-                return 335 + leap;\n-        }\n+        return switch (this) {\n+            case JANUARY   -> 1;\n+            case FEBRUARY  -> 32;\n+            case MARCH     -> 60 + leap;\n+            case APRIL     -> 91 + leap;\n+            case MAY       -> 121 + leap;\n+            case JUNE      -> 152 + leap;\n+            case JULY      -> 182 + leap;\n+            case AUGUST    -> 213 + leap;\n+            case SEPTEMBER -> 244 + leap;\n+            case OCTOBER   -> 274 + leap;\n+            case NOVEMBER  -> 305 + leap;\n+            \/\/ otherwise (DECEMBER)\n+            default -> 335 + leap;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Month.java","additions":30,"deletions":60,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-            switch (chronoField) {\n+            return switch (chronoField) {\n@@ -450,4 +450,4 @@\n-                case DAY_OF_MONTH: return day;\n-                case MONTH_OF_YEAR: return month;\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+                case DAY_OF_MONTH -> day;\n+                case MONTH_OF_YEAR -> month;\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -600,7 +600,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -637,5 +636,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n@@ -971,7 +970,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n-                case OFFSET_SECONDS: {\n-                    return with(dateTime, ZoneOffset.ofTotalSeconds(chronoField.checkValidIntValue(newValue)));\n-                }\n-            }\n-            return with(dateTime.with(field, newValue), offset);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);\n+                case OFFSET_SECONDS ->\n+                     with(dateTime, ZoneOffset.ofTotalSeconds(chronoField.checkValidIntValue(newValue)));\n+                default -> with(dateTime.with(field, newValue), offset);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1183,10 +1183,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return nanosUntil;\n-                case MICROS: return nanosUntil \/ 1000;\n-                case MILLIS: return nanosUntil \/ 1000_000;\n-                case SECONDS: return nanosUntil \/ NANOS_PER_SECOND;\n-                case MINUTES: return nanosUntil \/ NANOS_PER_MINUTE;\n-                case HOURS: return nanosUntil \/ NANOS_PER_HOUR;\n-                case HALF_DAYS: return nanosUntil \/ (12 * NANOS_PER_HOUR);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case NANOS     -> nanosUntil;\n+                case MICROS    -> nanosUntil \/ 1000;\n+                case MILLIS    -> nanosUntil \/ 1000_000;\n+                case SECONDS   -> nanosUntil \/ NANOS_PER_SECOND;\n+                case MINUTES   -> nanosUntil \/ NANOS_PER_MINUTE;\n+                case HOURS     -> nanosUntil \/ NANOS_PER_HOUR;\n+                case HALF_DAYS -> nanosUntil \/ (12 * NANOS_PER_HOUR);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -170,44 +170,15 @@\n-            case DURATION_TYPE:\n-                ((Duration) object).writeExternal(out);\n-                break;\n-            case INSTANT_TYPE:\n-                ((Instant) object).writeExternal(out);\n-                break;\n-            case LOCAL_DATE_TYPE:\n-                ((LocalDate) object).writeExternal(out);\n-                break;\n-            case LOCAL_DATE_TIME_TYPE:\n-                ((LocalDateTime) object).writeExternal(out);\n-                break;\n-            case LOCAL_TIME_TYPE:\n-                ((LocalTime) object).writeExternal(out);\n-                break;\n-            case ZONE_REGION_TYPE:\n-                ((ZoneRegion) object).writeExternal(out);\n-                break;\n-            case ZONE_OFFSET_TYPE:\n-                ((ZoneOffset) object).writeExternal(out);\n-                break;\n-            case ZONE_DATE_TIME_TYPE:\n-                ((ZonedDateTime) object).writeExternal(out);\n-                break;\n-            case OFFSET_TIME_TYPE:\n-                ((OffsetTime) object).writeExternal(out);\n-                break;\n-            case OFFSET_DATE_TIME_TYPE:\n-                ((OffsetDateTime) object).writeExternal(out);\n-                break;\n-            case YEAR_TYPE:\n-                ((Year) object).writeExternal(out);\n-                break;\n-            case YEAR_MONTH_TYPE:\n-                ((YearMonth) object).writeExternal(out);\n-                break;\n-            case MONTH_DAY_TYPE:\n-                ((MonthDay) object).writeExternal(out);\n-                break;\n-            case PERIOD_TYPE:\n-                ((Period) object).writeExternal(out);\n-                break;\n-            default:\n-                throw new InvalidClassException(\"Unknown serialized type\");\n+            case DURATION_TYPE         -> ((Duration) object).writeExternal(out);\n+            case INSTANT_TYPE          -> ((Instant) object).writeExternal(out);\n+            case LOCAL_DATE_TYPE       -> ((LocalDate) object).writeExternal(out);\n+            case LOCAL_DATE_TIME_TYPE  -> ((LocalDateTime) object).writeExternal(out);\n+            case LOCAL_TIME_TYPE       -> ((LocalTime) object).writeExternal(out);\n+            case ZONE_REGION_TYPE      -> ((ZoneRegion) object).writeExternal(out);\n+            case ZONE_OFFSET_TYPE      -> ((ZoneOffset) object).writeExternal(out);\n+            case ZONE_DATE_TIME_TYPE   -> ((ZonedDateTime) object).writeExternal(out);\n+            case OFFSET_TIME_TYPE      -> ((OffsetTime) object).writeExternal(out);\n+            case OFFSET_DATE_TIME_TYPE -> ((OffsetDateTime) object).writeExternal(out);\n+            case YEAR_TYPE             -> ((Year) object).writeExternal(out);\n+            case YEAR_MONTH_TYPE       -> ((YearMonth) object).writeExternal(out);\n+            case MONTH_DAY_TYPE        -> ((MonthDay) object).writeExternal(out);\n+            case PERIOD_TYPE           -> ((Period) object).writeExternal(out);\n+            default -> throw new InvalidClassException(\"Unknown serialized type\");\n@@ -273,18 +244,17 @@\n-        switch (type) {\n-            case DURATION_TYPE: return Duration.readExternal(in);\n-            case INSTANT_TYPE: return Instant.readExternal(in);\n-            case LOCAL_DATE_TYPE: return LocalDate.readExternal(in);\n-            case LOCAL_DATE_TIME_TYPE: return LocalDateTime.readExternal(in);\n-            case LOCAL_TIME_TYPE: return LocalTime.readExternal(in);\n-            case ZONE_DATE_TIME_TYPE: return ZonedDateTime.readExternal(in);\n-            case ZONE_OFFSET_TYPE: return ZoneOffset.readExternal(in);\n-            case ZONE_REGION_TYPE: return ZoneRegion.readExternal(in);\n-            case OFFSET_TIME_TYPE: return OffsetTime.readExternal(in);\n-            case OFFSET_DATE_TIME_TYPE: return OffsetDateTime.readExternal(in);\n-            case YEAR_TYPE: return Year.readExternal(in);\n-            case YEAR_MONTH_TYPE: return YearMonth.readExternal(in);\n-            case MONTH_DAY_TYPE: return MonthDay.readExternal(in);\n-            case PERIOD_TYPE: return Period.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case DURATION_TYPE         -> Duration.readExternal(in);\n+            case INSTANT_TYPE          -> Instant.readExternal(in);\n+            case LOCAL_DATE_TYPE       -> LocalDate.readExternal(in);\n+            case LOCAL_DATE_TIME_TYPE  -> LocalDateTime.readExternal(in);\n+            case LOCAL_TIME_TYPE       -> LocalTime.readExternal(in);\n+            case ZONE_DATE_TIME_TYPE   -> ZonedDateTime.readExternal(in);\n+            case ZONE_OFFSET_TYPE      -> ZoneOffset.readExternal(in);\n+            case ZONE_REGION_TYPE      -> ZoneRegion.readExternal(in);\n+            case OFFSET_TIME_TYPE      -> OffsetTime.readExternal(in);\n+            case OFFSET_DATE_TIME_TYPE -> OffsetDateTime.readExternal(in);\n+            case YEAR_TYPE             -> Year.readExternal(in);\n+            case YEAR_MONTH_TYPE       -> YearMonth.readExternal(in);\n+            case MONTH_DAY_TYPE        -> MonthDay.readExternal(in);\n+            case PERIOD_TYPE           -> Period.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Ser.java","additions":32,"deletions":62,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -500,6 +500,6 @@\n-            switch (chronoField) {\n-                case YEAR_OF_ERA: return (year < 1 ? 1 - year : year);\n-                case YEAR: return year;\n-                case ERA: return (year < 1 ? 0 : 1);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case YEAR_OF_ERA -> year < 1 ? 1 - year : year;\n+                case YEAR -> year;\n+                case ERA -> year < 1 ? 0 : 1;\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -624,6 +624,6 @@\n-            switch (chronoField) {\n-                case YEAR_OF_ERA: return Year.of((int) (year < 1 ? 1 - newValue : newValue));\n-                case YEAR: return Year.of((int) newValue);\n-                case ERA: return (getLong(ERA) == newValue ? this : Year.of(1 - year));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case YEAR_OF_ERA -> Year.of((int) (year < 1 ? 1 - newValue : newValue));\n+                case YEAR -> Year.of((int) newValue);\n+                case ERA -> getLong(ERA) == newValue ? this : Year.of(1 - year);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -711,8 +711,8 @@\n-            switch (chronoUnit) {\n-                case YEARS: return plusYears(amountToAdd);\n-                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n-                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n-                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n-                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case YEARS     -> plusYears(amountToAdd);\n+                case DECADES   -> plusYears(Math.multiplyExact(amountToAdd, 10));\n+                case CENTURIES -> plusYears(Math.multiplyExact(amountToAdd, 100));\n+                case MILLENNIA -> plusYears(Math.multiplyExact(amountToAdd, 1000));\n+                case ERAS      -> with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -918,8 +918,8 @@\n-            switch (chronoUnit) {\n-                case YEARS: return yearsUntil;\n-                case DECADES: return yearsUntil \/ 10;\n-                case CENTURIES: return yearsUntil \/ 100;\n-                case MILLENNIA: return yearsUntil \/ 1000;\n-                case ERAS: return end.getLong(ERA) - getLong(ERA);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case YEARS     -> yearsUntil;\n+                case DECADES   -> yearsUntil \/ 10;\n+                case CENTURIES -> yearsUntil \/ 100;\n+                case MILLENNIA -> yearsUntil \/ 1000;\n+                case ERAS      -> end.getLong(ERA) - getLong(ERA);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/Year.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -489,8 +489,8 @@\n-            switch (chronoField) {\n-                case MONTH_OF_YEAR: return month;\n-                case PROLEPTIC_MONTH: return getProlepticMonth();\n-                case YEAR_OF_ERA: return (year < 1 ? 1 - year : year);\n-                case YEAR: return year;\n-                case ERA: return (year < 1 ? 0 : 1);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case MONTH_OF_YEAR   -> month;\n+                case PROLEPTIC_MONTH -> getProlepticMonth();\n+                case YEAR_OF_ERA     -> (year < 1 ? 1 - year : year);\n+                case YEAR            -> year;\n+                case ERA             -> (year < 1 ? 0 : 1);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -687,8 +687,8 @@\n-            switch (chronoField) {\n-                case MONTH_OF_YEAR: return withMonth((int) newValue);\n-                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA: return withYear((int) (year < 1 ? 1 - newValue : newValue));\n-                case YEAR: return withYear((int) newValue);\n-                case ERA: return (getLong(ERA) == newValue ? this : withYear(1 - year));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case MONTH_OF_YEAR   -> withMonth((int) newValue);\n+                case PROLEPTIC_MONTH -> plusMonths(newValue - getProlepticMonth());\n+                case YEAR_OF_ERA     -> withYear((int) (year < 1 ? 1 - newValue : newValue));\n+                case YEAR            -> withYear((int) newValue);\n+                case ERA             -> (getLong(ERA) == newValue ? this : withYear(1 - year));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -808,9 +808,9 @@\n-            switch (chronoUnit) {\n-                case MONTHS: return plusMonths(amountToAdd);\n-                case YEARS: return plusYears(amountToAdd);\n-                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n-                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n-                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n-                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case MONTHS    -> plusMonths(amountToAdd);\n+                case YEARS     -> plusYears(amountToAdd);\n+                case DECADES   -> plusYears(Math.multiplyExact(amountToAdd, 10));\n+                case CENTURIES -> plusYears(Math.multiplyExact(amountToAdd, 100));\n+                case MILLENNIA -> plusYears(Math.multiplyExact(amountToAdd, 1000));\n+                case ERAS      -> with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -1050,9 +1050,9 @@\n-            switch (chronoUnit) {\n-                case MONTHS: return monthsUntil;\n-                case YEARS: return monthsUntil \/ 12;\n-                case DECADES: return monthsUntil \/ 120;\n-                case CENTURIES: return monthsUntil \/ 1200;\n-                case MILLENNIA: return monthsUntil \/ 12000;\n-                case ERAS: return end.getLong(ERA) - getLong(ERA);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case MONTHS    -> monthsUntil;\n+                case YEARS     -> monthsUntil \/ 12;\n+                case DECADES   -> monthsUntil \/ 120;\n+                case CENTURIES -> monthsUntil \/ 1200;\n+                case MILLENNIA -> monthsUntil \/ 12000;\n+                case ERAS      -> end.getLong(ERA) - getLong(ERA);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -817,7 +817,6 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    throw new UnsupportedTemporalTypeException(\"Invalid field 'InstantSeconds' for get() method, use getLong() instead\");\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.get(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> throw new UnsupportedTemporalTypeException(\"Invalid field \" +\n+                                         \"'InstantSeconds' for get() method, use getLong() instead\");\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.get(field);\n+            };\n@@ -854,5 +853,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return dateTime.getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> dateTime.getLong(field);\n+            };\n@@ -1304,4 +1303,3 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n-                    return create(newValue, getNano(), zone);\n-                case OFFSET_SECONDS:\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> create(newValue, getNano(), zone);\n+                case OFFSET_SECONDS -> {\n@@ -1309,3 +1307,4 @@\n-                    return resolveOffset(offset);\n-            }\n-            return resolveLocal(dateTime.with(field, newValue));\n+                    yield resolveOffset(offset);\n+                }\n+                default -> resolveLocal(dateTime.with(field, newValue));\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -201,11 +201,11 @@\n-            switch (chronoUnit) {\n-                case DAYS: return plusDays(amountToAdd);\n-                case WEEKS: return plusDays(Math.multiplyExact(amountToAdd, 7));\n-                case MONTHS: return plusMonths(amountToAdd);\n-                case YEARS: return plusYears(amountToAdd);\n-                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n-                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n-                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n-                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case DAYS      -> plusDays(amountToAdd);\n+                case WEEKS     -> plusDays(Math.multiplyExact(amountToAdd, 7));\n+                case MONTHS    -> plusMonths(amountToAdd);\n+                case YEARS     -> plusYears(amountToAdd);\n+                case DECADES   -> plusYears(Math.multiplyExact(amountToAdd, 10));\n+                case CENTURIES -> plusYears(Math.multiplyExact(amountToAdd, 100));\n+                case MILLENNIA -> plusYears(Math.multiplyExact(amountToAdd, 1000));\n+                case ERAS      -> with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n@@ -380,11 +380,11 @@\n-            switch (chronoUnit) {\n-                case DAYS: return daysUntil(end);\n-                case WEEKS: return daysUntil(end) \/ 7;\n-                case MONTHS: return monthsUntil(end);\n-                case YEARS: return monthsUntil(end) \/ 12;\n-                case DECADES: return monthsUntil(end) \/ 120;\n-                case CENTURIES: return monthsUntil(end) \/ 1200;\n-                case MILLENNIA: return monthsUntil(end) \/ 12000;\n-                case ERAS: return end.getLong(ERA) - getLong(ERA);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            return switch (chronoUnit) {\n+                case DAYS      -> daysUntil(end);\n+                case WEEKS     -> daysUntil(end) \/ 7;\n+                case MONTHS    -> monthsUntil(end);\n+                case YEARS     -> monthsUntil(end) \/ 12;\n+                case DECADES   -> monthsUntil(end) \/ 120;\n+                case CENTURIES -> monthsUntil(end) \/ 1200;\n+                case MILLENNIA -> monthsUntil(end) \/ 12000;\n+                case ERAS      -> end.getLong(ERA) - getLong(ERA);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateImpl.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -302,10 +302,10 @@\n-            switch (chronoUnit) {\n-                case NANOS: return plusNanos(amountToAdd);\n-                case MICROS: return plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n-                case MILLIS: return plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n-                case SECONDS: return plusSeconds(amountToAdd);\n-                case MINUTES: return plusMinutes(amountToAdd);\n-                case HOURS: return plusHours(amountToAdd);\n-                case HALF_DAYS: return plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12);  \/\/ no overflow (256 is multiple of 2)\n-            }\n-            return with(date.plus(amountToAdd, unit), time);\n+            return switch (chronoUnit) {\n+                case NANOS     -> plusNanos(amountToAdd);\n+                case MICROS    -> plusDays(amountToAdd \/ MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n+                case MILLIS    -> plusDays(amountToAdd \/ MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000000);\n+                case SECONDS   -> plusSeconds(amountToAdd);\n+                case MINUTES   -> plusMinutes(amountToAdd);\n+                case HOURS     -> plusHours(amountToAdd);\n+                case HALF_DAYS -> plusDays(amountToAdd \/ 256).plusHours((amountToAdd % 256) * 12); \/\/ no overflow (256 is multiple of 2)\n+                default -> with(date.plus(amountToAdd, unit), time);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateTimeImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS:\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS ->\n@@ -202,4 +202,3 @@\n-                case OFFSET_SECONDS:\n-                    return getOffset().getTotalSeconds();\n-            }\n-            return toLocalDateTime().get(field);\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> toLocalDateTime().get(field);\n+            };\n@@ -213,5 +212,5 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return toEpochSecond();\n-                case OFFSET_SECONDS: return getOffset().getTotalSeconds();\n-            }\n-            return toLocalDateTime().getLong(field);\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> toEpochSecond();\n+                case OFFSET_SECONDS -> getOffset().getTotalSeconds();\n+                default -> toLocalDateTime().getLong(field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoZonedDateTime.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -287,3 +287,3 @@\n-            switch (chronoField) {\n-                case INSTANT_SECONDS: return plus(newValue - toEpochSecond(), SECONDS);\n-                case OFFSET_SECONDS: {\n+            return switch (chronoField) {\n+                case INSTANT_SECONDS -> plus(newValue - toEpochSecond(), SECONDS);\n+                case OFFSET_SECONDS -> {\n@@ -291,1 +291,1 @@\n-                    return create(dateTime.toInstant(offset), zone);\n+                    yield create(dateTime.toInstant(offset), zone);\n@@ -293,2 +293,2 @@\n-            }\n-            return ofBest(dateTime.with(field, newValue), zone, offset);\n+                default -> ofBest(dateTime.with(field, newValue), zone, offset);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoZonedDateTimeImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -294,2 +293,4 @@\n-        CONF_PATH = Path.of(AccessController.doPrivileged((PrivilegedAction<String>)\n-                () -> System.getProperty(\"java.home\")), \"conf\", \"chronology\");\n+        @SuppressWarnings(\"removal\")\n+        String javaHome = AccessController.doPrivileged((PrivilegedAction<String>)\n+                        () -> System.getProperty(\"java.home\"));\n+        CONF_PATH = Path.of(javaHome, \"conf\", \"chronology\");\n@@ -520,6 +521,4 @@\n-        switch (eraValue) {\n-            case 1:\n-                return HijrahEra.AH;\n-            default:\n-                throw new DateTimeException(\"invalid Hijrah era\");\n-        }\n+        return switch (eraValue) {\n+            case 1 -> HijrahEra.AH;\n+            default -> throw new DateTimeException(\"invalid Hijrah era\");\n+        };\n@@ -539,15 +538,8 @@\n-            switch (f) {\n-                case DAY_OF_MONTH:\n-                    return ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n-                case DAY_OF_YEAR:\n-                    return ValueRange.of(1, getMaximumDayOfYear());\n-                case ALIGNED_WEEK_OF_MONTH:\n-                    return ValueRange.of(1, 5);\n-                case YEAR:\n-                case YEAR_OF_ERA:\n-                    return ValueRange.of(getMinimumYear(), getMaximumYear());\n-                case ERA:\n-                    return ValueRange.of(1, 1);\n-                default:\n-                    return field.range();\n-            }\n+            return switch (f) {\n+                case DAY_OF_MONTH -> ValueRange.of(1, 1, getMinimumMonthLength(), getMaximumMonthLength());\n+                case DAY_OF_YEAR -> ValueRange.of(1, getMaximumDayOfYear());\n+                case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5);\n+                case YEAR, YEAR_OF_ERA -> ValueRange.of(getMinimumYear(), getMaximumYear());\n+                case ERA -> ValueRange.of(1, 1);\n+                default -> field.range();\n+            };\n@@ -850,1 +842,1 @@\n-        try (InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {\n+        try (@SuppressWarnings(\"removal\") InputStream is = AccessController.doPrivileged(getResourceAction, null, perm1, perm2)) {\n@@ -1045,0 +1037,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahChronology.java","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -354,4 +354,4 @@\n-                switch (f) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, 5);  \/\/ TODO\n+                return switch (f) {\n+                    case DAY_OF_MONTH -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR -> ValueRange.of(1, lengthOfYear());\n+                    case ALIGNED_WEEK_OF_MONTH -> ValueRange.of(1, 5); \/\/ TODO\n@@ -360,2 +360,2 @@\n-                }\n-                return getChronology().range(f);\n+                    default -> getChronology().range(f);\n+                };\n@@ -371,16 +371,16 @@\n-            switch ((ChronoField) field) {\n-                case DAY_OF_WEEK: return getDayOfWeek();\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((dayOfMonth - 1) % 7) + 1;\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n-                case DAY_OF_MONTH: return this.dayOfMonth;\n-                case DAY_OF_YEAR: return this.getDayOfYear();\n-                case EPOCH_DAY: return toEpochDay();\n-                case ALIGNED_WEEK_OF_MONTH: return ((dayOfMonth - 1) \/ 7) + 1;\n-                case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) \/ 7) + 1;\n-                case MONTH_OF_YEAR: return monthOfYear;\n-                case PROLEPTIC_MONTH: return getProlepticMonth();\n-                case YEAR_OF_ERA: return prolepticYear;\n-                case YEAR: return prolepticYear;\n-                case ERA: return getEraValue();\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch ((ChronoField) field) {\n+                case DAY_OF_WEEK                  ->  getDayOfWeek();\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  ((dayOfMonth - 1) % 7) + 1;\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  ((getDayOfYear() - 1) % 7) + 1;\n+                case DAY_OF_MONTH                 ->  this.dayOfMonth;\n+                case DAY_OF_YEAR                  ->  this.getDayOfYear();\n+                case EPOCH_DAY                    ->  toEpochDay();\n+                case ALIGNED_WEEK_OF_MONTH        ->  ((dayOfMonth - 1) \/ 7) + 1;\n+                case ALIGNED_WEEK_OF_YEAR         ->  ((getDayOfYear() - 1) \/ 7) + 1;\n+                case MONTH_OF_YEAR                ->  monthOfYear;\n+                case PROLEPTIC_MONTH              ->  getProlepticMonth();\n+                case YEAR_OF_ERA                  ->  prolepticYear;\n+                case YEAR                         ->  prolepticYear;\n+                case ERA                          ->  getEraValue();\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n@@ -401,16 +401,16 @@\n-            switch (chronoField) {\n-                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek());\n-                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n-                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n-                case DAY_OF_MONTH: return resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n-                case DAY_OF_YEAR: return plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n-                case EPOCH_DAY: return new HijrahDate(chrono, newValue);\n-                case ALIGNED_WEEK_OF_MONTH: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n-                case ALIGNED_WEEK_OF_YEAR: return plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n-                case MONTH_OF_YEAR: return resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n-                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA: return resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n-                case YEAR: return resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n-                case ERA: return resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n-            }\n-            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            return switch (chronoField) {\n+                case DAY_OF_WEEK                  ->  plusDays(newValue - getDayOfWeek());\n+                case ALIGNED_DAY_OF_WEEK_IN_MONTH ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n+                case ALIGNED_DAY_OF_WEEK_IN_YEAR  ->  plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n+                case DAY_OF_MONTH                 ->  resolvePreviousValid(prolepticYear, monthOfYear, nvalue);\n+                case DAY_OF_YEAR                  ->  plusDays(Math.min(nvalue, lengthOfYear()) - getDayOfYear());\n+                case EPOCH_DAY                    ->  new HijrahDate(chrono, newValue);\n+                case ALIGNED_WEEK_OF_MONTH        ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_MONTH)) * 7);\n+                case ALIGNED_WEEK_OF_YEAR         ->  plusDays((newValue - getLong(ALIGNED_WEEK_OF_YEAR)) * 7);\n+                case MONTH_OF_YEAR                ->  resolvePreviousValid(prolepticYear, nvalue, dayOfMonth);\n+                case PROLEPTIC_MONTH              ->  plusMonths(newValue - getProlepticMonth());\n+                case YEAR_OF_ERA                  ->  resolvePreviousValid(prolepticYear >= 1 ? nvalue : 1 - nvalue, monthOfYear, dayOfMonth);\n+                case YEAR                         ->  resolvePreviousValid(nvalue, monthOfYear, dayOfMonth);\n+                case ERA                          ->  resolvePreviousValid(1 - prolepticYear, monthOfYear, dayOfMonth);\n+                default -> throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -131,8 +131,5 @@\n-        switch (isoEra) {\n-            case 0:\n-                return BCE;\n-            case 1:\n-                return CE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + isoEra);\n-        }\n+        return switch (isoEra) {\n+            case 0  -> BCE;\n+            case 1  -> CE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + isoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/IsoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-        if (field instanceof ChronoField) {\n+        if (field instanceof ChronoField chronoField) {\n@@ -449,5 +449,4 @@\n-                ChronoField f = (ChronoField) field;\n-                switch (f) {\n-                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n-                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n-                    case YEAR_OF_ERA: {\n+                return switch (chronoField) {\n+                    case DAY_OF_MONTH -> ValueRange.of(1, lengthOfMonth());\n+                    case DAY_OF_YEAR -> ValueRange.of(1, lengthOfYear());\n+                    case YEAR_OF_ERA -> {\n@@ -457,1 +456,1 @@\n-                        return ValueRange.of(1, jcal.getActualMaximum(Calendar.YEAR));\n+                        yield ValueRange.of(1, jcal.getActualMaximum(Calendar.YEAR));\n@@ -459,2 +458,2 @@\n-                }\n-                return getChronology().range(f);\n+                    default -> getChronology().range(chronoField);\n+                };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/JapaneseDate.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -315,2 +315,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -318,1 +318,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE * 12L, range.getMaximum() - YEARS_DIFFERENCE * 12L);\n@@ -320,1 +320,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -322,1 +322,1 @@\n-                return ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, range.getMaximum() - YEARS_DIFFERENCE, -range.getMinimum() + 1 + YEARS_DIFFERENCE);\n@@ -324,1 +324,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -326,1 +326,1 @@\n-                return ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() - YEARS_DIFFERENCE, range.getMaximum() - YEARS_DIFFERENCE);\n@@ -328,2 +328,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-            switch (chronoField) {\n-                case PROLEPTIC_MONTH:\n+            return switch (chronoField) {\n+                case PROLEPTIC_MONTH -> {\n@@ -321,4 +321,3 @@\n-                    return plusMonths(newValue - getProlepticMonth());\n-                case YEAR_OF_ERA:\n-                case YEAR:\n-                case ERA: {\n+                    yield plusMonths(newValue - getProlepticMonth());\n+                }\n+                case YEAR_OF_ERA -> {\n@@ -326,8 +325,1 @@\n-                    switch (chronoField) {\n-                        case YEAR_OF_ERA:\n-                            return with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue)  + YEARS_DIFFERENCE));\n-                        case YEAR:\n-                            return with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n-                        case ERA:\n-                            return with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n-                    }\n+                    yield with(isoDate.withYear(getProlepticYear() >= 1 ? nvalue + YEARS_DIFFERENCE : (1 - nvalue) + YEARS_DIFFERENCE));\n@@ -335,2 +327,8 @@\n-            }\n-            return with(isoDate.with(field, newValue));\n+                case YEAR -> {\n+                    int nvalue = getChronology().range(chronoField).checkValidIntValue(newValue, chronoField);\n+                    yield with(isoDate.withYear(nvalue + YEARS_DIFFERENCE));\n+                }\n+                case ERA -> with(isoDate.withYear((1 - getProlepticYear()) + YEARS_DIFFERENCE));\n+\n+                default -> with(isoDate.with(field, newValue));\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoDate.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (minguoEra) {\n-            case 0:\n-                return BEFORE_ROC;\n-            case 1:\n-                return ROC;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + minguoEra);\n-        }\n+        return switch (minguoEra) {\n+            case 0  -> BEFORE_ROC;\n+            case 1  -> ROC;\n+            default -> throw new DateTimeException(\"Invalid era: \" + minguoEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/MinguoEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -248,12 +248,12 @@\n-        switch (type) {\n-            case CHRONO_TYPE: return (Serializable)AbstractChronology.readExternal(in);\n-            case CHRONO_LOCAL_DATE_TIME_TYPE: return (Serializable)ChronoLocalDateTimeImpl.readExternal(in);\n-            case CHRONO_ZONE_DATE_TIME_TYPE: return (Serializable)ChronoZonedDateTimeImpl.readExternal(in);\n-            case JAPANESE_DATE_TYPE:  return JapaneseDate.readExternal(in);\n-            case JAPANESE_ERA_TYPE: return JapaneseEra.readExternal(in);\n-            case HIJRAH_DATE_TYPE: return HijrahDate.readExternal(in);\n-            case MINGUO_DATE_TYPE: return MinguoDate.readExternal(in);\n-            case THAIBUDDHIST_DATE_TYPE: return ThaiBuddhistDate.readExternal(in);\n-            case CHRONO_PERIOD_TYPE: return ChronoPeriodImpl.readExternal(in);\n-            default: throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case CHRONO_TYPE                 -> (Serializable) AbstractChronology.readExternal(in);\n+            case CHRONO_LOCAL_DATE_TIME_TYPE -> (Serializable) ChronoLocalDateTimeImpl.readExternal(in);\n+            case CHRONO_ZONE_DATE_TIME_TYPE  -> (Serializable) ChronoZonedDateTimeImpl.readExternal(in);\n+            case JAPANESE_DATE_TYPE          -> JapaneseDate.readExternal(in);\n+            case JAPANESE_ERA_TYPE           -> JapaneseEra.readExternal(in);\n+            case HIJRAH_DATE_TYPE            -> HijrahDate.readExternal(in);\n+            case MINGUO_DATE_TYPE            -> MinguoDate.readExternal(in);\n+            case THAIBUDDHIST_DATE_TYPE      -> ThaiBuddhistDate.readExternal(in);\n+            case CHRONO_PERIOD_TYPE          -> ChronoPeriodImpl.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/Ser.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -351,2 +351,2 @@\n-        switch (field) {\n-            case PROLEPTIC_MONTH: {\n+        return switch (field) {\n+            case PROLEPTIC_MONTH -> {\n@@ -354,1 +354,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE * 12L, range.getMaximum() + YEARS_DIFFERENCE * 12L);\n@@ -356,1 +356,1 @@\n-            case YEAR_OF_ERA: {\n+            case YEAR_OF_ERA -> {\n@@ -358,1 +358,1 @@\n-                return ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(1, -(range.getMinimum() + YEARS_DIFFERENCE) + 1, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -360,1 +360,1 @@\n-            case YEAR: {\n+            case YEAR -> {\n@@ -362,1 +362,1 @@\n-                return ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n+                yield ValueRange.of(range.getMinimum() + YEARS_DIFFERENCE, range.getMaximum() + YEARS_DIFFERENCE);\n@@ -364,2 +364,2 @@\n-        }\n-        return field.range();\n+            default -> field.range();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistChronology.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -138,8 +138,5 @@\n-        switch (thaiBuddhistEra) {\n-            case 0:\n-                return BEFORE_BE;\n-            case 1:\n-                return BE;\n-            default:\n-                throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n-        }\n+        return switch (thaiBuddhistEra) {\n+            case 0  -> BEFORE_BE;\n+            case 1  -> BE;\n+            default -> throw new DateTimeException(\"Invalid era: \" + thaiBuddhistEra);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistEra.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2549,4 +2549,4 @@\n-                case 0: context.setCaseSensitive(true); break;\n-                case 1: context.setCaseSensitive(false); break;\n-                case 2: context.setStrict(true); break;\n-                case 3: context.setStrict(false); break;\n+                case 0 -> context.setCaseSensitive(true);\n+                case 1 -> context.setCaseSensitive(false);\n+                case 2 -> context.setStrict(true);\n+                case 3 -> context.setStrict(false);\n@@ -2560,7 +2560,7 @@\n-            switch (ordinal()) {\n-                case 0: return \"ParseCaseSensitive(true)\";\n-                case 1: return \"ParseCaseSensitive(false)\";\n-                case 2: return \"ParseStrict(true)\";\n-                case 3: return \"ParseStrict(false)\";\n-            }\n-            throw new IllegalStateException(\"Unreachable\");\n+            return switch (ordinal()) {\n+                case 0 -> \"ParseCaseSensitive(true)\";\n+                case 1 -> \"ParseCaseSensitive(false)\";\n+                case 2 -> \"ParseStrict(true)\";\n+                case 3 -> \"ParseStrict(false)\";\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n@@ -2790,9 +2790,4 @@\n-                    case NORMAL:\n-                    case EXCEEDS_PAD:\n-                    case ALWAYS:\n-                        buf.append(decimalStyle.getNegativeSign());\n-                        break;\n-                    case NOT_NEGATIVE:\n-                        throw new DateTimeException(\"Field \" + field +\n-                            \" cannot be printed as the value \" + value +\n-                            \" cannot be negative according to the SignStyle\");\n+                    case NORMAL, EXCEEDS_PAD, ALWAYS -> buf.append(decimalStyle.getNegativeSign());\n+                    case NOT_NEGATIVE -> throw new DateTimeException(\"Field \" + field +\n+                                             \" cannot be printed as the value \" + value +\n+                                             \" cannot be negative according to the SignStyle\");\n@@ -4131,7 +4126,5 @@\n-            switch (type) {\n-            case STD:\n-                return names[textStyle.zoneNameStyleIndex() + 1];\n-            case DST:\n-                return names[textStyle.zoneNameStyleIndex() + 3];\n-            }\n-            return names[textStyle.zoneNameStyleIndex() + 5];\n+            return switch (type) {\n+                case STD -> names[textStyle.zoneNameStyleIndex() + 1];\n+                case DST -> names[textStyle.zoneNameStyleIndex() + 3];\n+                default  -> names[textStyle.zoneNameStyleIndex() + 5];\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -126,11 +126,5 @@\n-        switch (ordinal()) {\n-            case 0: \/\/ NORMAL\n-                \/\/ valid if negative or (positive and lenient)\n-                return !positive || !strict;\n-            case 1: \/\/ ALWAYS\n-            case 4: \/\/ EXCEEDS_PAD\n-                return true;\n-            default:\n-                \/\/ valid if lenient and not fixed width\n-                return !strict && !fixedWidth;\n-        }\n+        return switch (ordinal()) {\n+            case 0 -> !positive || !strict; \/\/ NORMAL - valid if negative or (positive and lenient)\n+            case 1, 4 -> true; \/\/ ALWAYS, EXCEEDS_PAD\n+            default -> !strict && !fixedWidth; \/\/ valid if lenient and not fixed width\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/SignStyle.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -706,10 +706,7 @@\n-            switch (this) {\n-                case WEEK_BASED_YEARS:\n-                    return (R) temporal.with(WEEK_BASED_YEAR,\n-                            Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n-                case QUARTER_YEARS:\n-                    return (R) temporal.plus(amount \/ 4, YEARS)\n-                            .plus((amount % 4) * 3, MONTHS);\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> (R) temporal.with(WEEK_BASED_YEAR,\n+                                          Math.addExact(temporal.get(WEEK_BASED_YEAR), amount));\n+                case QUARTER_YEARS -> (R) temporal.plus(amount \/ 4, YEARS)\n+                                       .plus((amount % 4) * 3, MONTHS);\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n@@ -723,9 +720,6 @@\n-            switch(this) {\n-                case WEEK_BASED_YEARS:\n-                    return Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n-                            temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n-                case QUARTER_YEARS:\n-                    return temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n-                default:\n-                    throw new IllegalStateException(\"Unreachable\");\n-            }\n+            return switch (this) {\n+                case WEEK_BASED_YEARS -> Math.subtractExact(temporal2Exclusive.getLong(WEEK_BASED_YEAR),\n+                                          temporal1Inclusive.getLong(WEEK_BASED_YEAR));\n+                case QUARTER_YEARS -> temporal1Inclusive.until(temporal2Exclusive, MONTHS) \/ 3;\n+                default -> throw new IllegalStateException(\"Unreachable\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/IsoFields.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -194,10 +194,6 @@\n-        switch (type) {\n-            case ZRULES:\n-                return ZoneRules.readExternal(in);\n-            case ZOT:\n-                return ZoneOffsetTransition.readExternal(in);\n-            case ZOTRULE:\n-                return ZoneOffsetTransitionRule.readExternal(in);\n-            default:\n-                throw new StreamCorruptedException(\"Unknown serialized type\");\n-        }\n+        return switch (type) {\n+            case ZRULES -> ZoneRules.readExternal(in);\n+            case ZOT -> ZoneOffsetTransition.readExternal(in);\n+            case ZOTRULE -> ZoneOffsetTransitionRule.readExternal(in);\n+            default -> throw new StreamCorruptedException(\"Unknown serialized type\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/Ser.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -150,13 +149,20 @@\n-        final List<ZoneRulesProvider> loaded = new ArrayList<>();\n-        AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public Object run() {\n-                String prop = System.getProperty(\"java.time.zone.DefaultZoneRulesProvider\");\n-                if (prop != null) {\n-                    try {\n-                        Class<?> c = Class.forName(prop, true, ClassLoader.getSystemClassLoader());\n-                        @SuppressWarnings(\"deprecation\")\n-                        ZoneRulesProvider provider = ZoneRulesProvider.class.cast(c.newInstance());\n-                        registerProvider(provider);\n-                        loaded.add(provider);\n-                    } catch (Exception x) {\n-                        throw new Error(x);\n+        @SuppressWarnings(\"removal\")\n+        final List<ZoneRulesProvider> loaded =\n+                AccessController.doPrivileged(new PrivilegedAction<List<ZoneRulesProvider>>() {\n+                    public List<ZoneRulesProvider> run() {\n+                        List<ZoneRulesProvider> result = new ArrayList<>();\n+                        String prop = System.getProperty(\"java.time.zone.DefaultZoneRulesProvider\");\n+                        if (prop != null) {\n+                            try {\n+                                Class<?> c = Class.forName(prop, true, ClassLoader.getSystemClassLoader());\n+                                @SuppressWarnings(\"deprecation\")\n+                                ZoneRulesProvider provider = ZoneRulesProvider.class.cast(c.newInstance());\n+                                registerProvider(provider);\n+                                result.add(provider);\n+                            } catch (Exception x) {\n+                                throw new Error(x);\n+                            }\n+                        } else {\n+                            registerProvider(new TzdbZoneRulesProvider());\n+                        }\n+                        return result;\n@@ -164,6 +170,1 @@\n-                } else {\n-                    registerProvider(new TzdbZoneRulesProvider());\n-                }\n-                return null;\n-            }\n-        });\n+                });\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/ZoneRulesProvider.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\n+import jdk.internal.util.Preconditions;\n@@ -756,4 +756,0 @@\n-         * If the intrinsic function does not process all of the bytes in\n-         * src, it must process a multiple of four of them, making the\n-         * returned destination length a multiple of three.\n-         *\n@@ -765,1 +761,4 @@\n-         * containing pad characters.\n+         * containing pad characters.  However, MIME decoding ignores\n+         * illegal characters, so any intrinsic overriding decodeBlock\n+         * can choose how to handle illegal characters based on the isMIME\n+         * parameter.\n@@ -782,0 +781,2 @@\n+         * @param  isMIME\n+         *         boolean, when true decode according to RFC2045 (ignore illegal chars)\n@@ -785,1 +786,1 @@\n-        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {\n+        private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME) {\n@@ -813,1 +814,1 @@\n-                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL);\n+                    int dl = decodeBlock(src, sp, sl, dst, dp, isURL, isMIME);\n@@ -818,1 +819,1 @@\n-                    int chars_decoded = (dl \/ 3) * 4;\n+                    int chars_decoded = ((dl + 2) \/ 3) * 4;\n@@ -934,2 +935,1 @@\n-            if (off < 0 || len < 0 || len > b.length - off)\n-                throw new ArrayIndexOutOfBoundsException();\n+            Preconditions.checkFromIndexSize(len, off, b.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Base64.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5181,3 +5181,1 @@\n-            if (index < 0 || index >= n)\n-                throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                    \", Size: \"+n);\n+            Objects.checkIndex(index, n);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -213,0 +212,5 @@\n+        initStatic();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-@SuppressWarnings(\"exports\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1603,1 +1603,2 @@\n-     * @return true if and only if this scanner has another line of input\n+     * @return true if there is a line separator in the remaining input\n+     * or if the input has other remaining characters\n","filename":"src\/java.base\/share\/classes\/java\/util\/Scanner.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})\n+@SuppressWarnings(\"serial\")\n@@ -385,2 +385,2 @@\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            BASE = l.findVarHandle(Striped64.class,\n+            MethodHandles.Lookup l1 = MethodHandles.lookup();\n+            BASE = l1.findVarHandle(Striped64.class,\n@@ -388,1 +388,1 @@\n-            CELLSBUSY = l.findVarHandle(Striped64.class,\n+            CELLSBUSY = l1.findVarHandle(Striped64.class,\n@@ -390,1 +390,2 @@\n-            l = java.security.AccessController.doPrivileged(\n+            @SuppressWarnings(\"removal\")\n+            MethodHandles.Lookup l2 = java.security.AccessController.doPrivileged(\n@@ -399,1 +400,1 @@\n-            THREAD_PROBE = l.findVarHandle(Thread.class,\n+            THREAD_PROBE = l2.findVarHandle(Thread.class,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -758,0 +758,8 @@\n+ *    <li><p><i>Free-spacing mode<\/i> in Perl (called <i>comments\n+ *    mode<\/i> in this class) denoted by {@code (?x)} in the regular\n+ *    expression (or by the {@link Pattern#COMMENTS} flag when compiling\n+ *    the expression) will not ignore whitespace inside of character classes. In\n+ *    this class, whitespace inside of character classes must be escaped to be\n+ *    considered as part of the regular expression when in comments mode.\n+ *    <\/p><\/li>\n+ *\n@@ -819,1 +827,3 @@\n-     * with {@code #} are ignored until the end of a line.\n+     * with {@code #} are ignored until the end of a line. Comments mode ignores\n+     * whitespace within a character class contained in a pattern string. Such\n+     * whitespace must be escaped in order to be considered significant.  <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,3 @@\n-            for (int i = 0; i < index; i++) sb.append(' ');\n+            for (int i = 0; i < index; i++) {\n+                sb.append((pattern.charAt(i) == '\\t') ? '\\t' : ' ');\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/PatternSyntaxException.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\n+import jdk.internal.util.Preconditions;\n@@ -77,3 +77,1 @@\n-        if (off < 0 || len < 0 || off > b.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, b.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -76,3 +77,1 @@\n-        if (off < 0 || len < 0 || off > b.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, b.length, Preconditions.AIOOBE_FORMATTER);\n@@ -151,9 +150,2 @@\n-\n-        if (off < 0 || off >= b.length) {\n-            throw new ArrayIndexOutOfBoundsException(off);\n-        }\n-\n-        int endIndex = off + len - 1;\n-        if (endIndex < 0 || endIndex >= b.length) {\n-            throw new ArrayIndexOutOfBoundsException(endIndex);\n-        }\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + len - 1, b.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -151,3 +152,1 @@\n-        if (off < 0 || len < 0 || off > b.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, b.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -233,3 +234,1 @@\n-        if (off < 0 || len < 0 || off > input.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, input.length, Preconditions.AIOOBE_FORMATTER);\n@@ -300,3 +299,1 @@\n-        if (off < 0 || len < 0 || off > dictionary.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, dictionary.length, Preconditions.AIOOBE_FORMATTER);\n@@ -559,3 +556,1 @@\n-        if (off < 0 || len < 0 || off > output.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, output.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -154,3 +155,1 @@\n-        if (off < 0 || len < 0 || off > input.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, input.length, Preconditions.AIOOBE_FORMATTER);\n@@ -221,3 +220,1 @@\n-        if (off < 0 || len < 0 || off > dictionary.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, dictionary.length, Preconditions.AIOOBE_FORMATTER);\n@@ -366,3 +363,1 @@\n-        if (off < 0 || len < 0 || off > output.length - len) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(len, off, output.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -275,1 +275,2 @@\n-        if (!JceSecurityManager.INSTANCE.isCallerTrusted(provider)) {\n+        if (!JceSecurityManager.INSTANCE.isCallerTrusted(\n+                JceSecurityManager.WALKER.getCallerClass(), provider)) {\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.StackWalker.*;\n@@ -42,2 +43,0 @@\n- * <p>Note that this security manager is never installed, only instantiated.\n- *\n@@ -48,3 +47,1 @@\n-\n-@SuppressWarnings(\"removal\")\n-final class JceSecurityManager extends SecurityManager {\n+final class JceSecurityManager {\n@@ -64,0 +61,1 @@\n+    static final StackWalker WALKER;\n@@ -69,6 +67,13 @@\n-        INSTANCE = AccessController.doPrivileged(\n-                new PrivilegedAction<>() {\n-                    public JceSecurityManager run() {\n-                        return new JceSecurityManager();\n-                    }\n-                });\n+\n+        PrivilegedAction<JceSecurityManager> paSM = JceSecurityManager::new;\n+        @SuppressWarnings(\"removal\")\n+        JceSecurityManager dummySecurityManager =\n+                AccessController.doPrivileged(paSM);\n+        INSTANCE = dummySecurityManager;\n+\n+        PrivilegedAction<StackWalker> paWalker =\n+                () -> StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+        @SuppressWarnings(\"removal\")\n+        StackWalker dummyWalker = AccessController.doPrivileged(paWalker);\n+\n+        WALKER = dummyWalker;\n@@ -85,1 +90,2 @@\n-    CryptoPermission getCryptoPermission(String alg) {\n+    CryptoPermission getCryptoPermission(String theAlg) {\n+\n@@ -88,1 +94,1 @@\n-        alg = alg.toUpperCase(Locale.ENGLISH);\n+        final String alg = theAlg.toUpperCase(Locale.ENGLISH);\n@@ -103,21 +109,10 @@\n-        Class<?>[] context = getClassContext();\n-        URL callerCodeBase = null;\n-        int i;\n-        for (i=0; i<context.length; i++) {\n-            Class<?> cls = context[i];\n-            callerCodeBase = JceSecurity.getCodeBase(cls);\n-            if (callerCodeBase != null) {\n-                break;\n-            } else {\n-                if (cls.getName().startsWith(\"javax.crypto.\")) {\n-                    \/\/ skip jce classes since they aren't the callers\n-                    continue;\n-                }\n-                \/\/ use default permission when the caller is system classes\n-                return defaultPerm;\n-            }\n-        }\n-\n-        if (i == context.length) {\n-            return defaultPerm;\n-        }\n+        return WALKER.walk(s -> s.map(StackFrame::getDeclaringClass)\n+                .filter(c -> !c.getPackageName().equals(\"javax.crypto\"))\n+                .map(cls -> {\n+                    URL callerCodeBase = JceSecurity.getCodeBase(cls);\n+                    return (callerCodeBase != null) ?\n+                            getCryptoPermissionFromURL(callerCodeBase,\n+                                    alg, defaultPerm) : defaultPerm;})\n+                .findFirst().get()         \/\/ nulls not possible for Optional\n+        );\n+    }\n@@ -125,0 +120,2 @@\n+    CryptoPermission getCryptoPermissionFromURL(URL callerCodeBase,\n+            String alg, CryptoPermission defaultPerm) {\n@@ -234,1 +231,1 @@\n-    boolean isCallerTrusted(Provider provider) {\n+    boolean isCallerTrusted(Class<?> caller, Provider provider) {\n@@ -236,6 +233,1 @@\n-        Class<?>[] context = getClassContext();\n-        if (context.length >= 3) {\n-            \/\/ context[0]: class javax.crypto.JceSecurityManager\n-            \/\/ context[1]: class javax.crypto.Cipher (or other JCE API class)\n-            \/\/ context[2]: this is what we are gonna check\n-            Class<?> caller = context[2];\n+        if (caller != null) {\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurityManager.java","additions":33,"deletions":41,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-\/\/ Note that at least JDK 1.1 has a low level \"plainSocketImpl\" that\n+\/\/ Note that at least JDK 1.1 has a low level \"SocketImpl\" that\n","filename":"src\/java.base\/share\/classes\/javax\/net\/SocketFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n-        \/*\n-         * This one can only be removed after JDK 17\n-         *\/\n-        SEALED_CLASSES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -188,1 +189,2 @@\n-        synchronized (loadedLibraryNames) {\n+        acquireNativeLibraryLock(name);\n+        try {\n@@ -205,3 +207,2 @@\n-             * We use a static stack to hold the list of libraries we are\n-             * loading because this can happen only when called by the\n-             * same thread because this block is synchronous.\n+             * Each thread maintains its own stack to hold the list of\n+             * libraries it is loading.\n@@ -210,2 +211,2 @@\n-             * immediately return success; otherwise, we raise\n-             * UnsatisfiedLinkError.\n+             * immediately return success; if the pending load is from\n+             * a different class loader, we raise UnsatisfiedLinkError.\n@@ -213,1 +214,1 @@\n-            for (NativeLibraryImpl lib : nativeLibraryContext) {\n+            for (NativeLibraryImpl lib : NativeLibraryContext.current()) {\n@@ -226,1 +227,1 @@\n-            nativeLibraryContext.push(lib);\n+            NativeLibraryContext.push(lib);\n@@ -245,1 +246,1 @@\n-                nativeLibraryContext.pop();\n+                NativeLibraryContext.pop();\n@@ -251,0 +252,2 @@\n+        } finally {\n+            releaseNativeLibraryLock(name);\n@@ -298,1 +301,2 @@\n-        synchronized (loadedLibraryNames) {\n+        acquireNativeLibraryLock(lib.name());\n+        try {\n@@ -305,0 +309,2 @@\n+        } finally {\n+            releaseNativeLibraryLock(lib.name());\n@@ -418,1 +424,2 @@\n-            synchronized (loadedLibraryNames) {\n+            acquireNativeLibraryLock(name);\n+            try {\n@@ -423,1 +430,1 @@\n-                nativeLibraryContext.push(UNLOADER);\n+                NativeLibraryContext.push(UNLOADER);\n@@ -427,1 +434,1 @@\n-                    nativeLibraryContext.pop();\n+                    NativeLibraryContext.pop();\n@@ -429,0 +436,2 @@\n+            } finally {\n+                releaseNativeLibraryLock(name);\n@@ -446,3 +455,57 @@\n-    \/\/ This also serves as the lock to obtain nativeLibraries\n-    \/\/ and write to nativeLibraryContext.\n-    private static final Set<String> loadedLibraryNames = new HashSet<>();\n+    private static final Set<String> loadedLibraryNames =\n+            ConcurrentHashMap.newKeySet();\n+\n+    \/\/ reentrant lock class that allows exact counting (with external synchronization)\n+    @SuppressWarnings(\"serial\")\n+    private static final class CountedLock extends ReentrantLock {\n+\n+        private int counter = 0;\n+\n+        public void increment() {\n+            if (counter == Integer.MAX_VALUE) {\n+                \/\/ prevent overflow\n+                throw new Error(\"Maximum lock count exceeded\");\n+            }\n+            ++counter;\n+        }\n+\n+        public void decrement() {\n+            --counter;\n+        }\n+\n+        public int getCounter() {\n+            return counter;\n+        }\n+    }\n+\n+    \/\/ Maps native library name to the corresponding lock object\n+    private static final Map<String, CountedLock> nativeLibraryLockMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static void acquireNativeLibraryLock(String libraryName) {\n+        nativeLibraryLockMap.compute(libraryName, (name, currentLock) -> {\n+            if (currentLock == null) {\n+                currentLock = new CountedLock();\n+            }\n+            \/\/ safe as compute lambda is executed atomically\n+            currentLock.increment();\n+            return currentLock;\n+        }).lock();\n+    }\n+\n+    private static void releaseNativeLibraryLock(String libraryName) {\n+        CountedLock lock = nativeLibraryLockMap.computeIfPresent(libraryName, (name, currentLock) -> {\n+            if (currentLock.getCounter() == 1) {\n+                \/\/ unlock and release the object if no other threads are queued\n+                currentLock.unlock();\n+                \/\/ remove the element\n+                return null;\n+            } else {\n+                currentLock.decrement();\n+                return currentLock;\n+            }\n+        });\n+        if (lock != null) {\n+            lock.unlock();\n+        }\n+    }\n@@ -451,1 +514,38 @@\n-    private static Deque<NativeLibraryImpl> nativeLibraryContext = new ArrayDeque<>(8);\n+    private static final class NativeLibraryContext {\n+\n+        \/\/ Maps thread object to the native library context stack, maintained by each thread\n+        private static Map<Thread, Deque<NativeLibraryImpl>> nativeLibraryThreadContext =\n+                new ConcurrentHashMap<>();\n+\n+        \/\/ returns a context associated with the current thread\n+        private static Deque<NativeLibraryImpl> current() {\n+            return nativeLibraryThreadContext.computeIfAbsent(\n+                    Thread.currentThread(),\n+                    t -> new ArrayDeque<>(8));\n+        }\n+\n+        private static NativeLibraryImpl peek() {\n+            return current().peek();\n+        }\n+\n+        private static void push(NativeLibraryImpl lib) {\n+            current().push(lib);\n+        }\n+\n+        private static void pop() {\n+            \/\/ this does not require synchronization since each\n+            \/\/ thread has its own context\n+            Deque<NativeLibraryImpl> libs = current();\n+            libs.pop();\n+            if (libs.isEmpty()) {\n+                \/\/ context can be safely removed once empty\n+                nativeLibraryThreadContext.remove(Thread.currentThread());\n+            }\n+        }\n+\n+        private static boolean isEmpty() {\n+            Deque<NativeLibraryImpl> context =\n+                    nativeLibraryThreadContext.get(Thread.currentThread());\n+            return (context == null || context.isEmpty());\n+        }\n+    }\n@@ -456,1 +556,1 @@\n-        if (nativeLibraryContext.isEmpty()) { \/\/ only default library\n+        if (NativeLibraryContext.isEmpty()) { \/\/ only default library\n@@ -459,1 +559,1 @@\n-        return nativeLibraryContext.peek().fromClass;\n+        return NativeLibraryContext.peek().fromClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":119,"deletions":19,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code double}.\n+     *\/\n+    public static final long    MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,3 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0L)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0L));\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,6 @@\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code float}.\n+     *\/\n+    public static final int     MAG_BIT_MASK = ~SIGN_BIT_MASK;\n+\n@@ -82,1 +88,2 @@\n-                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)));\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == ~0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+        String cwd = new File(\"\").getAbsolutePath(); \/\/ current dir used for printing message.\n@@ -302,2 +303,2 @@\n-            String stdOutFile = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n-            String stdErrFile = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n+            String stdOutFileName = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n+            String stdErrFileName = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n@@ -314,2 +315,2 @@\n-                                            stdOutFile + \" or stderr file \" +\n-                                            stdErrFile + \" for more detail\");\n+                                            cwd + File.separator + stdOutFileName + \" or stderr file \" +\n+                                            cwd + File.separator + stdErrFileName + \" for more detail\");\n@@ -321,1 +322,2 @@\n-                                           \" is not created, please check process \" +\n+                                           \" is not created, please check current working directory \" +\n+                                           cwd  + \" for process \" +\n@@ -334,1 +336,1 @@\n-        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFileName);\n+        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + cwd + File.separator + archiveFileName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -154,0 +154,8 @@\n+    \/**\n+     * Returns the class file version of the current release.\n+     * @jvms 4.1 Table 4.1-A. class file format major versions\n+     *\/\n+    public static int classFileVersion() {\n+        return classFileMajorVersion;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    int V18 = 0 << 16 | 62;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,36 @@\n+    \/**\n+     * Utility exception formatters which can be used in {@code Preconditions}\n+     * check functions below.\n+     *\n+     * These anonymous inner classes can be syntactically replaced by lambda\n+     * expression or method reference, but it's not feasible in practices,\n+     * because {@code Preconditions} is used in many fundamental classes such\n+     * as {@code java.lang.String}, lambda expressions or method references\n+     * exercise many other code at VM startup, this could lead a recursive\n+     * calls when fundamental classes is used in lambda expressions or method\n+     * references.\n+     *\/\n+    public static final BiFunction<String, List<Number>, StringIndexOutOfBoundsException>\n+            SIOOBE_FORMATTER = Preconditions.outOfBoundsExceptionFormatter(new Function<>() {\n+        @Override\n+        public StringIndexOutOfBoundsException apply(String s) {\n+            return new StringIndexOutOfBoundsException(s);\n+        }\n+    });\n+\n+    public static final BiFunction<String, List<Number>, ArrayIndexOutOfBoundsException>\n+            AIOOBE_FORMATTER = Preconditions.outOfBoundsExceptionFormatter(new Function<>() {\n+        @Override\n+        public ArrayIndexOutOfBoundsException apply(String s) {\n+            return new ArrayIndexOutOfBoundsException(s);\n+        }\n+    });\n+\n+    public static final BiFunction<String,List<Number>, IndexOutOfBoundsException>\n+            IOOBE_FORMATTER = Preconditions.outOfBoundsExceptionFormatter(new Function<>() {\n+        @Override\n+        public IndexOutOfBoundsException apply(String s) {\n+            return new IndexOutOfBoundsException(s);\n+        }\n+    });\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Preconditions.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,1 +287,1 @@\n-        String line = null;\n+        String line;\n@@ -291,1 +291,1 @@\n-        Vector<String> jars = new Vector<>();\n+        ArrayList<String> jars = new ArrayList<>();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/JarIndex.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -47,3 +46,2 @@\n-    private static String tempFileTemplate;\n-\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static String tempFileTemplate =\n@@ -51,18 +49,6 @@\n-            new java.security.PrivilegedAction<Void>() {\n-                public Void run() {\n-                tempFileTemplate =\n-                    System.getProperty(\"content.types.temp.file.template\",\n-                                       \"\/tmp\/%s\");\n-\n-                mailcapLocations = new String[] {\n-                    System.getProperty(\"user.mailcap\"),\n-                    StaticProperty.userHome() + \"\/.mailcap\",\n-                    \"\/etc\/mailcap\",\n-                    \"\/usr\/etc\/mailcap\",\n-                    \"\/usr\/local\/etc\/mailcap\",\n-                };\n-                return null;\n-            }\n-        });\n-    }\n-\n+                new java.security.PrivilegedAction<String>() {\n+                    public String run() {\n+                        return System.getProperty(\"content.types.temp.file.template\",\n+                                \"\/tmp\/%s\");\n+                    }\n+                });\n@@ -80,0 +66,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -223,1 +210,14 @@\n-    protected static String[] mailcapLocations;\n+    @SuppressWarnings(\"removal\")\n+    protected static String[] mailcapLocations =\n+        java.security.AccessController.doPrivileged(\n+                new java.security.PrivilegedAction<String[]>() {\n+                    public String[] run() {\n+                        return new String[]{\n+                                System.getProperty(\"user.mailcap\"),\n+                                StaticProperty.userHome() + \"\/.mailcap\",\n+                                \"\/etc\/mailcap\",\n+                                \"\/usr\/etc\/mailcap\",\n+                                \"\/usr\/local\/etc\/mailcap\",\n+                        };\n+                    }\n+                });\n@@ -391,0 +391,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MimeTable.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -73,3 +72,2 @@\n-    static final boolean serializeAuth;\n-    static {\n-        serializeAuth = java.security.AccessController.doPrivileged(\n+    @SuppressWarnings(\"removal\")\n+    static final boolean serializeAuth = java.security.AccessController.doPrivileged(\n@@ -78,1 +76,0 @@\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.ArrayList;\n@@ -45,3 +46,0 @@\n-import java.util.Vector;\n-\n-import javax.security.auth.x500.X500Principal;\n@@ -151,1 +149,1 @@\n-            Vector<String>      v = new Vector<String>();\n+            ArrayList<String>   v = new ArrayList<>();\n@@ -155,1 +153,1 @@\n-                v.addElement(tokenizer.nextToken());\n+                v.add(tokenizer.nextToken());\n@@ -158,1 +156,1 @@\n-                ciphers [i] = v.elementAt(i);\n+                ciphers [i] = v.get(i);\n@@ -175,1 +173,1 @@\n-            Vector<String>      v = new Vector<String>();\n+            ArrayList<String>   v = new ArrayList<>();\n@@ -179,1 +177,1 @@\n-                v.addElement(tokenizer.nextToken());\n+                v.add(tokenizer.nextToken());\n@@ -182,1 +180,1 @@\n-                protocols [i] = v.elementAt(i);\n+                protocols [i] = v.get(i);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Objects;\n@@ -311,2 +312,1 @@\n-        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))\n-            throw new IndexOutOfBoundsException();\n+        Objects.checkFromIndexSize(offset, length, dsts.length);\n@@ -413,2 +413,1 @@\n-        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))\n-            throw new IndexOutOfBoundsException();\n+        Objects.checkFromIndexSize(offset, length, srcs.length);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,3 +67,0 @@\n- * This implementation attempts to be compatible with legacy PlainSocketImpl,\n- * including behavior and exceptions that are not specified by SocketImpl.\n- *\n@@ -644,2 +641,2 @@\n-            \/\/ set the address field to the given host address to keep\n-            \/\/ compatibility with PlainSocketImpl. When binding to 0.0.0.0\n+            \/\/ set the address field to the given host address to\n+            \/\/ maintain long standing behavior. When binding to 0.0.0.0\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -172,0 +173,2 @@\n+            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n+            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n@@ -173,17 +176,2 @@\n-            if (sp < 0 || sp >= sa.length) {\n-                throw new ArrayIndexOutOfBoundsException(sp);\n-            }\n-\n-            if (dp < 0 || dp >= da.length) {\n-                throw new ArrayIndexOutOfBoundsException(dp);\n-            }\n-\n-            int endIndexSP = sp + len - 1;\n-            if (endIndexSP < 0 || endIndexSP >= sa.length) {\n-                throw new ArrayIndexOutOfBoundsException(endIndexSP);\n-            }\n-\n-            int endIndexDP = dp + len - 1;\n-            if (endIndexDP < 0 || endIndexDP >= da.length) {\n-                throw new ArrayIndexOutOfBoundsException(endIndexDP);\n-            }\n+            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n+            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -506,0 +506,3 @@\n+        if (!arrayType.isArray()) {\n+            return parseUnknownArray(length, buf);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -581,1 +581,1 @@\n-        Vector<SignerInfo> intResult = new Vector<>();\n+        ArrayList<SignerInfo> intResult = new ArrayList<>();\n@@ -586,1 +586,1 @@\n-                intResult.addElement(signerInfo);\n+                intResult.add(signerInfo);\n@@ -592,2 +592,1 @@\n-            intResult.copyInto(result);\n-            return result;\n+            return intResult.toArray(result);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -108,3 +109,1 @@\n-        if ((ofs < 0) || (len < 0) || (ofs > b.length - len)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(ofs, len, b.length, Preconditions.AIOOBE_FORMATTER);\n@@ -162,4 +161,1 @@\n-\n-        if (ofs < 0 || ofs >= b.length) {\n-            throw new ArrayIndexOutOfBoundsException(ofs);\n-        }\n+        Preconditions.checkIndex(ofs, b.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.Preconditions;\n@@ -155,3 +157,1 @@\n-        if ((ofs < 0) || ((buf.length - ofs) < 64)) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/MD5.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+\n+import jdk.internal.util.Preconditions;\n@@ -139,3 +141,1 @@\n-        if (ofs < 0 || (buf.length - ofs) < 64) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -131,3 +132,1 @@\n-        if (ofs < 0 || (buf.length - ofs) < 64) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(ofs, 64, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA2.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -232,3 +233,1 @@\n-        if (ofs < 0 || (buf.length - ofs) < 128) {\n-            throw new ArrayIndexOutOfBoundsException();\n-        }\n+        Preconditions.checkFromIndexSize(ofs, 128, buf.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA5.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,6 +28,2 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n+\n@@ -860,0 +856,33 @@\n+    private static final Map<Integer, CipherSuite> cipherSuiteIds;\n+    private static final Map<String, CipherSuite> cipherSuiteNames;\n+    private static final List<CipherSuite> allowedCipherSuites;\n+    private static final List<CipherSuite> defaultCipherSuites;\n+\n+    static {\n+        Map<Integer, CipherSuite> ids = new HashMap<>();\n+        Map<String, CipherSuite> names = new HashMap<>();\n+        List<CipherSuite> allowedCS = new ArrayList<>();\n+        List<CipherSuite> defaultCS = new ArrayList<>();\n+\n+        for(CipherSuite cs : CipherSuite.values()) {\n+            ids.put(cs.id, cs);\n+            names.put(cs.name, cs);\n+            for (String alias : cs.aliases) {\n+                names.put(alias, cs);\n+            }\n+\n+            if (!cs.supportedProtocols.isEmpty()) {\n+                allowedCS.add(cs);\n+            }\n+\n+            if (cs.isDefaultEnabled) {\n+                defaultCS.add(cs);\n+            }\n+        }\n+\n+        cipherSuiteIds = Map.copyOf(ids);\n+        cipherSuiteNames = Map.copyOf(names);\n+        allowedCipherSuites = List.copyOf(allowedCS);\n+        defaultCipherSuites = List.copyOf(defaultCS);\n+    }\n+\n@@ -897,8 +926,1 @@\n-        for (CipherSuite cs : CipherSuite.values()) {\n-            if (cs.name.equals(ciperSuiteName) ||\n-                    cs.aliases.contains(ciperSuiteName)) {\n-                return cs;\n-            }\n-        }\n-\n-        return null;\n+        return cipherSuiteNames.get(ciperSuiteName);\n@@ -908,7 +930,1 @@\n-        for (CipherSuite cs : CipherSuite.values()) {\n-            if (cs.id == id) {\n-                return cs;\n-            }\n-        }\n-\n-        return null;\n+        return cipherSuiteIds.get(id);\n@@ -918,4 +934,4 @@\n-        for (CipherSuite cs : CipherSuite.values()) {\n-            if (cs.id == id) {\n-                return cs.name;\n-            }\n+        CipherSuite cs = cipherSuiteIds.get(id);\n+\n+        if (cs != null) {\n+            return cs.name;\n@@ -928,11 +944,1 @@\n-        Collection<CipherSuite> cipherSuites = new LinkedList<>();\n-        for (CipherSuite cs : CipherSuite.values()) {\n-            if (!cs.supportedProtocols.isEmpty()) {\n-                cipherSuites.add(cs);\n-            } else {\n-                \/\/ values() is ordered, remaining cipher suites are\n-                \/\/ not supported.\n-                break;\n-            }\n-        }\n-        return cipherSuites;\n+        return allowedCipherSuites;\n@@ -942,11 +948,1 @@\n-        Collection<CipherSuite> cipherSuites = new LinkedList<>();\n-        for (CipherSuite cs : CipherSuite.values()) {\n-            if (cs.isDefaultEnabled) {\n-                cipherSuites.add(cs);\n-            } else {\n-                \/\/ values() is ordered, remaining cipher suites are\n-                \/\/ not enabled.\n-                break;\n-            }\n-        }\n-        return cipherSuites;\n+        return defaultCipherSuites;\n@@ -975,13 +971,5 @@\n-            for (CipherSuite cs : CipherSuite.values()) {\n-                if (!cs.supportedProtocols.isEmpty()) {\n-                    if (cs.name.equals(name) ||\n-                            cs.aliases.contains(name)) {\n-                        cipherSuites.add(cs);\n-                        found = true;\n-                        break;\n-                    }\n-                } else {\n-                    \/\/ values() is ordered, remaining cipher suites are\n-                    \/\/ not supported.\n-                    break;\n-                }\n+            CipherSuite cs;\n+            if ((cs = cipherSuiteNames.get(name)) != null\n+                    && !cs.supportedProtocols.isEmpty()) {\n+                cipherSuites.add(cs);\n+                found = true;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CipherSuite.java","additions":48,"deletions":60,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.TreeSet;\n@@ -51,1 +52,1 @@\n-    static List<String> getAlgorithms(String propertyName) {\n+    static Set<String> getAlgorithms(String propertyName) {\n@@ -76,1 +77,1 @@\n-            return Collections.emptyList();\n+            return Collections.emptySet();\n@@ -78,1 +79,3 @@\n-        return new ArrayList<>(Arrays.asList(algorithmsInProperty));\n+        Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n+        algorithmsInPropertySet.addAll(Arrays.asList(algorithmsInProperty));\n+        return algorithmsInPropertySet;\n@@ -81,1 +84,1 @@\n-    static boolean checkAlgorithm(List<String> algorithms, String algorithm,\n+    static boolean checkAlgorithm(Set<String> algorithms, String algorithm,\n@@ -87,10 +90,3 @@\n-        Set<String> elements = null;\n-        for (String item : algorithms) {\n-            if (item == null || item.isEmpty()) {\n-                continue;\n-            }\n-\n-            \/\/ check the full name\n-            if (item.equalsIgnoreCase(algorithm)) {\n-                return false;\n-            }\n+        if (algorithms.contains(algorithm)) {\n+            return false;\n+        }\n@@ -98,4 +94,2 @@\n-            \/\/ decompose the algorithm into sub-elements\n-            if (elements == null) {\n-                elements = decomposer.decompose(algorithm);\n-            }\n+        \/\/ decompose the algorithm into sub-elements\n+        Set<String> elements = decomposer.decompose(algorithm);\n@@ -103,5 +97,4 @@\n-            \/\/ check the items of the algorithm\n-            for (String element : elements) {\n-                if (item.equalsIgnoreCase(element)) {\n-                    return false;\n-                }\n+        \/\/ check the element of the elements\n+        for (String element : elements) {\n+            if (algorithms.contains(element)) {\n+                return false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -73,2 +73,8 @@\n-                                certs.add(X509CertImpl.getFingerprint(HASH, cert));\n-                                certIssuers.add(cert.getSubjectX500Principal());\n+                                String fp =\n+                                    X509CertImpl.getFingerprint(HASH, cert, debug);\n+                                \/\/ only add trust anchor if fingerprint can\n+                                \/\/ be calculated\n+                                if (fp != null) {\n+                                    certs.add(fp);\n+                                    certIssuers.add(cert.getSubjectX500Principal());\n+                                }\n@@ -96,2 +102,2 @@\n-        String key = X509CertImpl.getFingerprint(HASH, cert);\n-        boolean result = certs.contains(key);\n+        String key = X509CertImpl.getFingerprint(HASH, cert, debug);\n+        boolean result = (key == null ? false : certs.contains(key));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AnchorCertificates.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,5 +40,0 @@\n-    private static final BiFunction<String, List<Number>,\n-            ArrayIndexOutOfBoundsException> AIOOBE_SUPPLIER =\n-            Preconditions.outOfBoundsExceptionFormatter\n-            (ArrayIndexOutOfBoundsException::new);\n-\n@@ -53,1 +48,1 @@\n-        Preconditions.checkFromIndexSize(offset, len, array.length, AIOOBE_SUPPLIER);\n+        Preconditions.checkFromIndexSize(offset, len, array.length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ArrayUtil.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.util.Preconditions;\n+\n@@ -128,3 +130,1 @@\n-        if (index < 0 || index >= length) {\n-            throw new ArrayIndexOutOfBoundsException(Integer.toString(index));\n-        }\n+        Preconditions.checkIndex(index, length, Preconditions.AIOOBE_FORMATTER);\n@@ -140,3 +140,1 @@\n-        if (index < 0 || index >= length) {\n-            throw new ArrayIndexOutOfBoundsException(Integer.toString(index));\n-        }\n+        Preconditions.checkIndex(index, length, Preconditions.AIOOBE_FORMATTER);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/BitArray.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+    private static final Pattern INCLUDE_PATTERN = Pattern.compile(\"include \" +\n+            PROPERTY_DISABLED_EC_CURVES, Pattern.CASE_INSENSITIVE);\n+\n@@ -98,1 +101,1 @@\n-    private final List<String> disabledAlgorithms;\n+    private final Set<String> disabledAlgorithms;\n@@ -133,1 +136,0 @@\n-        int ecindex = -1, i = 0;\n@@ -135,6 +137,6 @@\n-            if (s.regionMatches(true, 0,\"include \", 0, 8)) {\n-                if (s.regionMatches(true, 8, PROPERTY_DISABLED_EC_CURVES, 0,\n-                        PROPERTY_DISABLED_EC_CURVES.length())) {\n-                    ecindex = i;\n-                    break;\n-                }\n+            Matcher matcher = INCLUDE_PATTERN.matcher(s);\n+            if (matcher.matches()) {\n+                disabledAlgorithms.remove(matcher.group());\n+                disabledAlgorithms.addAll(\n+                        getAlgorithms(PROPERTY_DISABLED_EC_CURVES));\n+                break;\n@@ -142,6 +144,0 @@\n-            i++;\n-        }\n-        if (ecindex > -1) {\n-            disabledAlgorithms.remove(ecindex);\n-            disabledAlgorithms.addAll(ecindex,\n-                    getAlgorithms(PROPERTY_DISABLED_EC_CURVES));\n@@ -335,2 +331,2 @@\n-        public Constraints(String propertyName, List<String> constraintArray) {\n-            for (String constraintEntry : constraintArray) {\n+        public Constraints(String propertyName, Set<String> constraintSet) {\n+            for (String constraintEntry : constraintSet) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private final List<String> legacyAlgorithms;\n+    private final Set<String> legacyAlgorithms;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/LegacyAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.cert.CertificateException;\n@@ -83,11 +82,3 @@\n-        String key;\n-        if (cert instanceof X509CertImpl) {\n-            key = ((X509CertImpl)cert).getFingerprint(algorithm);\n-        } else {\n-            try {\n-                key = new X509CertImpl(cert.getEncoded()).getFingerprint(algorithm);\n-            } catch (CertificateException cee) {\n-                return false;\n-            }\n-        }\n-        return props.containsKey(key);\n+        \/\/ if fingerprint cannot be calculated, also treat it as untrusted\n+        String key = X509CertImpl.getFingerprint(algorithm, cert, debug);\n+        return (key == null || props.containsKey(key));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/UntrustedCertificates.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.util.Debug;\n@@ -43,0 +44,2 @@\n+    private static final Debug debug = Debug.getInstance(\"certpath\");\n+\n@@ -157,1 +160,6 @@\n-        if (FINGERPRINTS.contains(fingerprint(anchor))) {\n+        String fp = fingerprint(anchor);\n+        if (fp == null) {\n+            throw new ValidatorException(\"Cannot generate fingerprint for \"\n+                + \"trust anchor of TLS server certificate\");\n+        }\n+        if (FINGERPRINTS.contains(fp)) {\n@@ -164,1 +172,6 @@\n-                LocalDate distrustDate = EXEMPT_SUBCAS.get(fingerprint(subCA));\n+                fp = fingerprint(subCA);\n+                if (fp == null) {\n+                    throw new ValidatorException(\"Cannot generate fingerprint \"\n+                        + \"for intermediate CA of TLS server certificate\");\n+                }\n+                LocalDate distrustDate = EXEMPT_SUBCAS.get(fp);\n@@ -177,3 +190,1 @@\n-        return (cert instanceof X509CertImpl)\n-               ? ((X509CertImpl)cert).getFingerprint(\"SHA-256\")\n-               : X509CertImpl.getFingerprint(\"SHA-256\", cert);\n+        return X509CertImpl.getFingerprint(\"SHA-256\", cert, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/SymantecTLSPolicy.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1920,1 +1920,1 @@\n-    public String getFingerprint(String algorithm) {\n+    private String getFingerprint(String algorithm, Debug debug) {\n@@ -1922,1 +1922,25 @@\n-            x -> getFingerprint(x, this));\n+            x -> {\n+                try {\n+                    return getFingerprintInternal(x, getEncodedInternal(), debug);\n+                } catch (CertificateEncodingException e) {\n+                    if (debug != null) {\n+                        debug.println(\"Cannot encode certificate: \" + e);\n+                    }\n+                    return null;\n+                }\n+            });\n+    }\n+\n+    private static String getFingerprintInternal(String algorithm,\n+            byte[] encodedCert, Debug debug) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(algorithm);\n+            byte[] digest = md.digest(encodedCert);\n+            return HexFormat.of().withUpperCase().formatHex(digest);\n+        } catch (NoSuchAlgorithmException e) {\n+            if (debug != null) {\n+                debug.println(\"Cannot create \" + algorithm\n+                    + \" MessageDigest: \" + e);\n+            }\n+            return null;\n+        }\n@@ -1926,1 +1950,1 @@\n-     * Gets the requested finger print of the certificate. The result\n+     * Gets the requested fingerprint of the certificate. The result\n@@ -1928,0 +1952,5 @@\n+     *\n+     * @param algorithm the MessageDigest algorithm\n+     * @param cert the X509Certificate\n+     * @return the fingerprint, or null if it cannot be calculated because\n+     *     of an exception\n@@ -1930,8 +1959,12 @@\n-            X509Certificate cert) {\n-        try {\n-            byte[] encCertInfo = cert.getEncoded();\n-            MessageDigest md = MessageDigest.getInstance(algorithm);\n-            byte[] digest = md.digest(encCertInfo);\n-            return HexFormat.of().withUpperCase().formatHex(digest);\n-        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n-            \/\/ ignored\n+            X509Certificate cert, Debug debug) {\n+        if (cert instanceof X509CertImpl) {\n+            return ((X509CertImpl)cert).getFingerprint(algorithm, debug);\n+        } else {\n+            try {\n+                return getFingerprintInternal(algorithm, cert.getEncoded(), debug);\n+            } catch (CertificateEncodingException e) {\n+                if (debug != null) {\n+                    debug.println(\"Cannot encode certificate: \" + e);\n+                }\n+                return null;\n+            }\n@@ -1939,1 +1972,0 @@\n-        return \"\";\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-        values[(int)index] = value;\n+        values[index] = value;\n@@ -329,1 +329,0 @@\n-            values = null;\n@@ -335,5 +334,0 @@\n-    private byte[] getArray()\n-    {\n-        return values;\n-    }\n-\n@@ -350,1 +344,1 @@\n-};\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/text\/CompactByteArray.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -252,0 +251,5 @@\n+        loadTZDB();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadTZDB() {\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\\-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 18\\-ea\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]17\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]18\\f[R]) and a limited number of previous releases, detailed in the\n@@ -3999,10 +3999,0 @@\n-.TP\n-.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n-Enables the use of biased locking.\n-Some applications with significant amounts of uncontended\n-synchronization may attain significant speedups with this flag enabled,\n-but applications with certain patterns of locking may see slowdowns.\n-.RS\n-.PP\n-By default, this option is disabled.\n-.RE\n@@ -4023,8 +4013,0 @@\n-.SH REMOVED JAVA OPTIONS\n-.PP\n-These \\f[CB]java\\f[R] options have been removed in JDK 17 and using them\n-results in an error of:\n-.RS\n-.PP\n-\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n-.RE\n@@ -4032,52 +4014,5 @@\n-.B \\f[CB]\\-XX:+UseMembar\\f[R]\n-Enabled issuing membars on thread\\-state transitions.\n-This option was disabled by default on all platforms except ARM servers,\n-where it was enabled.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:MaxPermSize=\\f[R]\\f[I]size\\f[R]\n-Sets the maximum permanent generation space size (in bytes).\n-This option was deprecated in JDK 8 and superseded by the\n-\\f[CB]\\-XX:MaxMetaspaceSize\\f[R] option.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:PermSize=\\f[R]\\f[I]size\\f[R]\n-Sets the space (in bytes) allocated to the permanent generation that\n-triggers a garbage collection if it\\[aq]s exceeded.\n-This option was deprecated in JDK 8 and superseded by the\n-\\f[CB]\\-XX:MetaspaceSize\\f[R] option.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassLoading\\f[R]\n-Enables tracing of classes as they are loaded.\n-By default, this option is disabled and classes aren\\[aq]t traced.\n-.RS\n-.PP\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+load=\\f[R]\\f[I]level\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R]\n-.PP\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]debug\\f[R] for additional information.\n-In Unified Logging syntax, \\f[CB]\\-verbose:class\\f[R] equals\n-\\f[CB]\\-Xlog:class+load=info,class+unload=info\\f[R].\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassLoadingPreorder\\f[R]\n-Enables tracing of all loaded classes in the order in which they\\[aq]re\n-referenced.\n-By default, this option is disabled and classes aren\\[aq]t traced.\n-.RS\n-.PP\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+preorder=debug\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n-.RE\n-.TP\n-.B \\f[CB]\\-XX:+TraceClassResolution\\f[R]\n-Enables tracing of constant pool resolutions.\n-By default, this option is disabled and constant pool resolutions\n-aren\\[aq]t traced.\n+.B \\f[CB]\\-XX:+UseBiasedLocking\\f[R]\n+Enables the use of biased locking.\n+Some applications with significant amounts of uncontended\n+synchronization may attain significant speedups with this flag enabled,\n+but applications with certain patterns of locking may see slowdowns.\n@@ -4086,3 +4021,1 @@\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+resolve=debug\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n+By default, this option is disabled.\n@@ -4090,6 +4023,1 @@\n-.TP\n-.B \\f[CB]\\-XX:+TraceLoaderConstraints\\f[R]\n-Enables tracing of the loader constraints recording.\n-By default, this option is disabled and loader constraints recording\n-isn\\[aq]t traced.\n-.RS\n+.SH REMOVED JAVA OPTIONS\n@@ -4097,4 +4025,1 @@\n-The replacement Unified Logging syntax is\n-\\f[CB]\\-Xlog:class+loader+constraints=info\\f[R].\n-See \\f[B]Enable Logging with the JVM Unified Logging Framework\\f[R].\n-.RE\n+No documented \\f[CB]java\\f[R] options have been removed in JDK 18.\n@@ -4105,1 +4030,4 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 16\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 17\\f[R]\n+[https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/specs\/man\/java.html]\n+.IP \\[bu] 2\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 16\\f[R]\n@@ -4108,1 +4036,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 15\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 15\\f[R]\n@@ -4111,1 +4039,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 14\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 14\\f[R]\n@@ -4114,1 +4042,1 @@\n-\\f[B]Java Platform, Standard Edition Tools Reference, Release 13\\f[R]\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 13\\f[R]\n@@ -4937,8 +4865,0 @@\n-\\f[CB]TraceBiasedLocking\\f[R]\n-T}@T{\n-\\f[CB]\\-Xlog:biasedlocking=\\f[R]\\f[I]level\\f[R]\n-T}@T{\n-Use \\f[I]level\\f[R]=\\f[CB]info\\f[R] for regular information, or\n-\\f[I]level\\f[R]=\\f[CB]trace\\f[R] for additional information.\n-T}\n-T{\n","filename":"src\/java.base\/share\/man\/java.1","additions":17,"deletions":97,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,1 @@\n-    fos_fd =\n-        (*env)->GetFieldID(env, fosClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n+    fos_fd = (*env)->GetFieldID(env, fosClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n@@ -70,2 +69,1 @@\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append)\n-{\n+    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"src\/java.base\/windows\/native\/libjava\/FileOutputStream_md.c","status":"renamed"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"java_net_DatagramPacket.h\"\n-#include \"net_util.h\"\n-\n-\/************************************************************************\n- * DatagramPacket\n- *\/\n-\n-jfieldID dp_addressID;\n-jfieldID dp_portID;\n-jfieldID dp_bufID;\n-jfieldID dp_offsetID;\n-jfieldID dp_lengthID;\n-jfieldID dp_bufLengthID;\n-\n-\/*\n- * Class:     java_net_DatagramPacket\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_DatagramPacket_init (JNIEnv *env, jclass cls) {\n-    dp_addressID = (*env)->GetFieldID(env, cls, \"address\",\n-                                      \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(dp_addressID);\n-    dp_portID = (*env)->GetFieldID(env, cls, \"port\", \"I\");\n-    CHECK_NULL(dp_portID);\n-    dp_bufID = (*env)->GetFieldID(env, cls, \"buf\", \"[B\");\n-    CHECK_NULL(dp_bufID);\n-    dp_offsetID = (*env)->GetFieldID(env, cls, \"offset\", \"I\");\n-    CHECK_NULL(dp_offsetID);\n-    dp_lengthID = (*env)->GetFieldID(env, cls, \"length\", \"I\");\n-    CHECK_NULL(dp_lengthID);\n-    dp_bufLengthID = (*env)->GetFieldID(env, cls, \"bufLength\", \"I\");\n-    CHECK_NULL(dp_bufLengthID);\n-}\n","filename":"src\/java.base\/share\/native\/libnet\/DatagramPacket.c","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n- * i.e. psi_timeoutID is PlainSocketImpl's timeout field's ID.\n@@ -87,7 +86,0 @@\n-\/* PlainSocketImpl fields *\/\n-extern jfieldID psi_timeoutID;\n-extern jfieldID psi_fdID;\n-extern jfieldID psi_addressID;\n-extern jfieldID psi_portID;\n-extern jfieldID psi_localportID;\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * This class defines a factory for creating DatagramSocketImpls. It defaults\n- * to creating plain DatagramSocketImpls, but may create other DatagramSocketImpls\n- * by setting the impl.prefix system property.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DefaultDatagramSocketImplFactory {\n-    static Class<?> prefixImplClass = null;\n-\n-    static {\n-        String prefix = null;\n-        try {\n-            prefix = GetPropertyAction.privilegedGetProperty(\"impl.prefix\");\n-            if (prefix != null)\n-                prefixImplClass = Class.forName(\"java.net.\"+prefix+\"DatagramSocketImpl\");\n-        } catch (Exception e) {\n-            System.err.println(\"Can't find class: java.net.\" +\n-                                prefix +\n-                                \"DatagramSocketImpl: check impl.prefix property\");\n-            \/\/prefixImplClass = null;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new <code>DatagramSocketImpl<\/code> instance.\n-     *\n-     * @param   isMulticast     true if this impl if for a MutlicastSocket\n-     * @return  a new instance of a <code>DatagramSocketImpl<\/code>.\n-     *\/\n-    static DatagramSocketImpl createDatagramSocketImpl(boolean isMulticast \/*unused on unix*\/)\n-        throws SocketException {\n-        if (prefixImplClass != null) {\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                DatagramSocketImpl result = (DatagramSocketImpl)prefixImplClass.newInstance();\n-                return result;\n-            } catch (Exception e) {\n-                throw new SocketException(\"can't instantiate DatagramSocketImpl\");\n-            }\n-        } else {\n-            return new java.net.PlainDatagramSocketImpl(isMulticast);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/DefaultDatagramSocketImplFactory.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/*\n- * On Unix systems we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    PlainDatagramSocketImpl(boolean isMulticast) {\n-        super(isMulticast);\n-    }\n-\n-    static {\n-        init();\n-    }\n-\n-    protected void socketSetOption(int opt, Object val) throws SocketException {\n-        if (opt == SocketOptions.SO_REUSEPORT &&\n-            !supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-        try {\n-            socketSetOption0(opt, val);\n-        } catch (SocketException se) {\n-            if (!connected)\n-                throw se;\n-        }\n-    }\n-\n-    protected synchronized native void bind0(int lport, InetAddress laddr)\n-        throws SocketException;\n-\n-    protected native void send0(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native int peek(InetAddress i) throws IOException;\n-\n-    protected synchronized native int peekData(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    protected native void setTimeToLive(int ttl) throws IOException;\n-\n-    protected native int getTimeToLive() throws IOException;\n-\n-    @Deprecated\n-    protected native void setTTL(byte ttl) throws IOException;\n-\n-    @Deprecated\n-    protected native byte getTTL() throws IOException;\n-\n-    protected native void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void datagramSocketCreate() throws SocketException;\n-\n-    protected native void datagramSocketClose();\n-\n-    protected native void socketSetOption0(int opt, Object val)\n-        throws SocketException;\n-\n-    protected native Object socketGetOption(int opt) throws SocketException;\n-\n-    protected native void connect0(InetAddress address, int port) throws SocketException;\n-\n-    protected native void disconnect0(int family);\n-\n-    native int dataAvailable();\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainDatagramSocketImpl.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/*\n- * On Unix systems we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainSocketImpl extends AbstractPlainSocketImpl\n-{\n-    static {\n-        initProto();\n-    }\n-\n-    \/**\n-     * Constructs an empty instance.\n-     *\/\n-    PlainSocketImpl(boolean isServer) {\n-        super(isServer);\n-    }\n-\n-    protected void socketSetOption(int opt, boolean b, Object val) throws SocketException {\n-        if (opt == SocketOptions.SO_REUSEPORT &&\n-            !supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-        try {\n-            socketSetOption0(opt, b, val);\n-        } catch (SocketException se) {\n-            if (!isConnected)\n-                throw se;\n-        }\n-    }\n-\n-    void socketCreate(boolean stream) throws IOException {\n-        socketCreate(stream, isServer);\n-    }\n-\n-    native void socketCreate(boolean stream, boolean isServer) throws IOException;\n-\n-    native void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException;\n-\n-    native void socketBind(InetAddress address, int port)\n-        throws IOException;\n-\n-    native void socketListen(int count) throws IOException;\n-\n-    native void socketAccept(SocketImpl s) throws IOException;\n-\n-    native int socketAvailable() throws IOException;\n-\n-    native void socketClose0(boolean useDeferredClose) throws IOException;\n-\n-    native void socketShutdown(int howto) throws IOException;\n-\n-    static native void initProto();\n-\n-    native void socketSetOption0(int cmd, boolean on, Object value)\n-        throws SocketException;\n-\n-    native int socketGetOption(int opt, Object iaContainerObj) throws SocketException;\n-\n-    native void socketSendUrgentData(int data) throws IOException;\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -50,1 +51,0 @@\n-    private static final String USER_DIR = \"user.dir\";\n@@ -55,2 +55,1 @@\n-        String userDir = System.getProperty(USER_DIR);\n-        theFileSystem = newFileSystem(userDir);\n+        theFileSystem = newFileSystem(StaticProperty.userDir());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-\n-#include \"io_util.h\"\n-#include \"io_util_md.h\"\n-#include \"java_io_FileOutputStream.h\"\n-\n-#include <fcntl.h>\n-\n-\/*******************************************************************\/\n-\/*  BEGIN JNI ********* BEGIN JNI *********** BEGIN JNI ************\/\n-\/*******************************************************************\/\n-\n-jfieldID fos_fd; \/* id for jobject 'fd' in java.io.FileOutputStream *\/\n-\n-\/**************************************************************\n- * static methods to store field ID's in initializers\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_initIDs(JNIEnv *env, jclass fdClass) {\n-    fos_fd = (*env)->GetFieldID(env, fdClass, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n-}\n-\n-\/**************************************************************\n- * Output stream\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_open0(JNIEnv *env, jobject this,\n-                                    jstring path, jboolean append) {\n-    fileOpen(env, this, path, fos_fd,\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_write(JNIEnv *env, jobject this, jint byte, jboolean append) {\n-    writeSingle(env, this, byte, append, fos_fd);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_io_FileOutputStream_writeBytes(JNIEnv *env,\n-    jobject this, jbyteArray bytes, jint off, jint len, jboolean append) {\n-    writeBytes(env, this, bytes, off, len, append, fos_fd);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/FileOutputStream_md.c","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -48,0 +48,2 @@\n+ * Second parameter is a hint about the type of a file. JNI_TRUE is for\n+ * shared libraries and JNI_FALSE is for executables.\n@@ -52,1 +54,1 @@\n-TruncatePath(char *buf)\n+TruncatePath(char *buf, jboolean pathisdll)\n@@ -54,2 +56,8 @@\n-    \/\/ try bin directory, maybe an executable\n-    char *p = findLastPathComponent(buf, \"\/bin\/\");\n+    \/*\n+     * If the file is a library, try lib directory first and then bin\n+     * directory.\n+     * If the file is an executable, try bin directory first and then lib\n+     * directory.\n+     *\/\n+\n+    char *p = findLastPathComponent(buf, pathisdll ? \"\/lib\/\" : \"\/bin\/\");\n@@ -60,2 +68,1 @@\n-    \/\/ try lib directory, maybe a library\n-    p = findLastPathComponent(buf, \"\/lib\/\");\n+    p = findLastPathComponent(buf, pathisdll ? \"\/bin\/\" : \"\/lib\/\");\n@@ -83,1 +90,1 @@\n-    return TruncatePath(buf);\n+    return TruncatePath(buf, JNI_FALSE);\n@@ -98,1 +105,1 @@\n-            return TruncatePath(buf);\n+            return TruncatePath(buf, JNI_TRUE);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_common.c","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,2179 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys\/ioctl.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_PlainDatagramSocketImpl.h\"\n-#include \"java_net_InetAddress.h\"\n-#include \"java_net_NetworkInterface.h\"\n-#include \"java_net_SocketOptions.h\"\n-\n-#ifdef __linux__\n-#define IPV6_MULTICAST_IF 17\n-#ifndef SO_BSDCOMPAT\n-#define SO_BSDCOMPAT  14\n-#endif\n-\/**\n- * IP_MULTICAST_ALL has been supported since kernel version 2.6.31\n- * but we may be building on a machine that is older than that.\n- *\/\n-#ifndef IP_MULTICAST_ALL\n-#define IP_MULTICAST_ALL      49\n-#endif\n-#endif  \/\/  __linux__\n-\n-#ifdef __APPLE__\n-#define IPV4_SNDBUF_LIMIT 65507\n-#define IPV6_SNDBUF_LIMIT 65527\n-#endif  \/\/ __APPLE__\n-\n-#ifndef IPTOS_TOS_MASK\n-#define IPTOS_TOS_MASK 0x1e\n-#endif\n-#ifndef IPTOS_PREC_MASK\n-#define IPTOS_PREC_MASK 0xe0\n-#endif\n-\n-\/************************************************************************\n- * PlainDatagramSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-static jfieldID pdsi_fdID;\n-static jfieldID pdsi_timeoutID;\n-static jfieldID pdsi_trafficClassID;\n-static jfieldID pdsi_localPortID;\n-static jfieldID pdsi_connected;\n-static jfieldID pdsi_connectedAddress;\n-static jfieldID pdsi_connectedPort;\n-\n-\/*\n- * Returns a java.lang.Integer based on 'i'\n- *\/\n-static jobject createInteger(JNIEnv *env, int i) {\n-    static jclass i_class;\n-    static jmethodID i_ctrID;\n-\n-    if (i_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        i_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(I)V\");\n-        CHECK_NULL_RETURN(i_ctrID, NULL);\n-        i_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(i_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, i_class, i_ctrID, i);\n-}\n-\n-\/*\n- * Returns a java.lang.Boolean based on 'b'\n- *\/\n-static jobject createBoolean(JNIEnv *env, int b) {\n-    static jclass b_class;\n-    static jmethodID b_ctrID;\n-\n-    if (b_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        b_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(Z)V\");\n-        CHECK_NULL_RETURN(b_ctrID, NULL);\n-        b_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(b_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, b_class, b_ctrID, (jboolean)(b != 0));\n-}\n-\n-\/*\n- * Returns the fd for a PlainDatagramSocketImpl or -1\n- * if closed.\n- *\/\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {\n-\n-    pdsi_fdID = (*env)->GetFieldID(env, cls, \"fd\",\n-                                   \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    pdsi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(pdsi_timeoutID);\n-    pdsi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(pdsi_trafficClassID);\n-    pdsi_localPortID = (*env)->GetFieldID(env, cls, \"localPort\", \"I\");\n-    CHECK_NULL(pdsi_localPortID);\n-    pdsi_connected = (*env)->GetFieldID(env, cls, \"connected\", \"Z\");\n-    CHECK_NULL(pdsi_connected);\n-    pdsi_connectedAddress = (*env)->GetFieldID(env, cls, \"connectedAddress\",\n-                                               \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(pdsi_connectedAddress);\n-    pdsi_connectedPort = (*env)->GetFieldID(env, cls, \"connectedPort\", \"I\");\n-    CHECK_NULL(pdsi_connectedPort);\n-\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    initInetAddressIDs(env);\n-    JNU_CHECK_EXCEPTION(env);\n-    Java_java_net_NetworkInterface_init(env, 0);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    bind\n- * Signature: (ILjava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_bind0(JNIEnv *env, jobject this,\n-                                            jint localport, jobject iaObj) {\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* fd is an int field on fdObj *\/\n-    int fd;\n-    int len = 0;\n-    SOCKETADDRESS sa;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj is null.\");\n-        return;\n-    }\n-\n-    \/* bind *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, localport, &sa, &len,\n-                                  JNI_TRUE) != 0) {\n-      return;\n-    }\n-\n-    if (NET_Bind(fd, &sa, len) < 0)  {\n-        if (errno == EADDRINUSE || errno == EADDRNOTAVAIL ||\n-            errno == EPERM || errno == EACCES) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"BindException\",\n-                            \"Bind failed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Bind failed\");\n-        }\n-        return;\n-    }\n-\n-    \/* initialize the local port *\/\n-    if (localport == 0) {\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return;\n-        }\n-\n-        localport = NET_GetPortFromSockaddr(&sa);\n-\n-        (*env)->SetIntField(env, this, pdsi_localPortID, localport);\n-    } else {\n-        (*env)->SetIntField(env, this, pdsi_localPortID, localport);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    connect0\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_connect0(JNIEnv *env, jobject this,\n-                                               jobject address, jint port) {\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-    \/* The packetAddress address, family and port *\/\n-    SOCKETADDRESS rmtaddr;\n-    int len = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(address)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, address, port, &rmtaddr, &len,\n-                                  JNI_TRUE) != 0) {\n-      return;\n-    }\n-\n-    if (NET_Connect(fd, &rmtaddr.sa, len) == -1) {\n-        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                        \"Connect failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    disconnect0\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_disconnect0(JNIEnv *env, jobject this, jint family) {\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-\n-#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n-    SOCKETADDRESS addr;\n-    socklen_t len;\n-#if defined(__linux__)\n-    int localPort = 0;\n-#endif\n-#endif\n-\n-    if (IS_NULL(fdObj)) {\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n-    memset(&addr, 0, sizeof(addr));\n-    if (ipv6_available()) {\n-        addr.sa6.sin6_family = AF_UNSPEC;\n-        len = sizeof(struct sockaddr_in6);\n-    } else {\n-        addr.sa4.sin_family = AF_UNSPEC;\n-        len = sizeof(struct sockaddr_in);\n-    }\n-    NET_Connect(fd, &addr.sa, len);\n-\n-#if defined(__linux__)\n-    if (getsockname(fd, &addr.sa, &len) == -1)\n-        return;\n-\n-    localPort = NET_GetPortFromSockaddr(&addr);\n-    if (localPort == 0) {\n-        localPort = (*env)->GetIntField(env, this, pdsi_localPortID);\n-        if (addr.sa.sa_family == AF_INET6) {\n-            addr.sa6.sin6_port = htons(localPort);\n-        } else {\n-            addr.sa4.sin_port = htons(localPort);\n-        }\n-\n-        NET_Bind(fd, &addr, len);\n-    }\n-\n-#endif\n-#else\n-    NET_Connect(fd, 0, 0);\n-#endif\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    send0\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_send0(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int ret, mallocedPacket = JNI_FALSE;\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint trafficClass = (*env)->GetIntField(env, this, pdsi_trafficClassID);\n-\n-    jbyteArray packetBuffer;\n-    jobject packetAddress;\n-    jint packetBufferOffset, packetBufferLen, packetPort;\n-    jboolean connected;\n-\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-\n-    SOCKETADDRESS rmtaddr;\n-    struct sockaddr *rmtaddrP = 0;\n-    int len = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-    if (IS_NULL(packetBuffer) || IS_NULL(packetAddress)) {\n-        JNU_ThrowNullPointerException(env, \"null buffer || null address\");\n-        return;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_lengthID);\n-\n-    \/\/ arg to NET_Sendto() null, if connected\n-    if (!connected) {\n-        packetPort = (*env)->GetIntField(env, packet, dp_portID);\n-        if (NET_InetAddressToSockaddr(env, packetAddress, packetPort, &rmtaddr,\n-                                      &len, JNI_TRUE) != 0) {\n-            return;\n-        }\n-        rmtaddrP = &rmtaddr.sa;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF), the max size of an IP packet.\n-         * Anything bigger should be truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Send buffer native heap allocation failed\");\n-            return;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, packetBuffer, packetBufferOffset, packetBufferLen,\n-                               (jbyte *)fullPacket);\n-    if (trafficClass != 0 && ipv6_available()) {\n-        NET_SetTrafficClass(&rmtaddr, trafficClass);\n-    }\n-\n-    \/*\n-     * Send the datagram.\n-     *\n-     * If we are connected it's possible that sendto will return\n-     * ECONNREFUSED indicating that an ICMP port unreachable has\n-     * received.\n-     *\/\n-    ret = NET_SendTo(fd, fullPacket, packetBufferLen, 0, rmtaddrP, len);\n-\n-    if (ret < 0) {\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            JNU_ThrowIOExceptionWithLastError(env, \"sendto failed\");\n-        }\n-    }\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-    return;\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    peek\n- * Signature: (Ljava\/net\/InetAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_peek(JNIEnv *env, jobject this,\n-                                           jobject addressObj) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jint fd;\n-    ssize_t n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    char buf[1];\n-    jint family;\n-    jobject iaObj;\n-    int port;\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"Null address in peek()\");\n-        return -1;\n-    }\n-    if (timeout) {\n-        int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Peek timed out\");\n-            return ret;\n-        } else if (ret == -1) {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else if (errno == ENOMEM) {\n-                 JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Peek failed\");\n-            }\n-            return ret;\n-        }\n-    }\n-\n-    n = NET_RecvFrom(fd, buf, 1, MSG_PEEK, &rmtaddr.sa, &slen);\n-\n-    if (n == -1) {\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Peek failed\");\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    iaObj = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-    family = getInetAddress_family(env, iaObj) == java_net_InetAddress_IPv4 ?\n-        AF_INET : AF_INET6;\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    if (family == AF_INET) { \/* this API can't handle IPV6 addresses *\/\n-        int address = getInetAddress_addr(env, iaObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        setInetAddress_addr(env, addressObj, address);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    }\n-    return port;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_peekData(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int mallocedPacket = JNI_FALSE;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-    int fd;\n-    int n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    int port = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return -1;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return -1;\n-    }\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-    if (timeout) {\n-        int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Receive timed out\");\n-            return -1;\n-        } else if (ret == -1) {\n-            if (errno == ENOMEM) {\n-                JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-#ifdef __linux__\n-            } else if (errno == EBADF) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-#else\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-#endif\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF), the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Peek buffer native heap allocation failed\");\n-            return -1;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    n = NET_RecvFrom(fd, fullPacket, packetBufferLen, MSG_PEEK,\n-                     &rmtaddr.sa, &slen);\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n == -1) {\n-        (*env)->SetIntField(env, packet, dp_offsetID, 0);\n-        (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-            }\n-        }\n-    } else {\n-        \/*\n-         * success - fill in received address...\n-         *\n-         * REMIND: Fill in an int on the packet, and create inetadd\n-         * object in Java, as a performance improvement. Also\n-         * construct the inetadd object lazily.\n-         *\/\n-\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &rmtaddr, packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (!(*env)->ExceptionCheck(env)){\n-            if (packetAddress == NULL ) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-                \/* stuff the new InetAddress in the packet *\/\n-                (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-            } else {\n-                \/* only get the new port number *\/\n-                port = NET_GetPortFromSockaddr(&rmtaddr);\n-            }\n-            \/* and fill in the data, remote address\/port and such *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                    (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, packet, dp_portID, port);\n-            (*env)->SetIntField(env, packet, dp_lengthID, n);\n-        }\n-    }\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    receive\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_receive0(JNIEnv *env, jobject this,\n-                                              jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int mallocedPacket = JNI_FALSE;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-\n-    int fd;\n-\n-    int n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    jboolean retry;\n-#ifdef __linux__\n-    jboolean connected = JNI_FALSE;\n-    jobject connectedAddress = NULL;\n-    jint connectedPort = 0;\n-    jlong prevTime = 0;\n-#endif\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return;\n-    }\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet,\n-         * anything bigger is truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Receive buffer native heap allocation failed\");\n-            return;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        retry = JNI_FALSE;\n-\n-        if (timeout) {\n-            int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    if (errno == ENOMEM) {\n-                        JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-#ifdef __linux__\n-                    } else if (errno == EBADF) {\n-                         JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                    } else {\n-                        JNU_ThrowByNameWithMessageAndLastError\n-                            (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-#else\n-                    } else {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-#endif\n-                    }\n-                }\n-\n-                if (mallocedPacket) {\n-                    free(fullPacket);\n-                }\n-\n-                return;\n-            }\n-        }\n-\n-        n = NET_RecvFrom(fd, fullPacket, packetBufferLen, 0,\n-                         &rmtaddr.sa, &slen);\n-        \/* truncate the data if the packet's length is too small *\/\n-        if (n > packetBufferLen) {\n-            n = packetBufferLen;\n-        }\n-        if (n == -1) {\n-            (*env)->SetIntField(env, packet, dp_offsetID, 0);\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-            if (errno == ECONNREFUSED) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                \"ICMP Port Unreachable\");\n-            } else {\n-                if (errno == EBADF) {\n-                     JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                 } else {\n-                     JNU_ThrowByNameWithMessageAndLastError\n-                         (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-                 }\n-            }\n-        } else {\n-            int port;\n-            jobject packetAddress;\n-\n-            \/*\n-             * success - fill in received address...\n-             *\n-             * REMIND: Fill in an int on the packet, and create inetadd\n-             * object in Java, as a performance improvement. Also\n-             * construct the inetadd object lazily.\n-             *\/\n-\n-            \/*\n-             * Check if there is an InetAddress already associated with this\n-             * packet. If so we check if it is the same source address. We\n-             * can't update any existing InetAddress because it is immutable\n-             *\/\n-            packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-            if (packetAddress != NULL) {\n-                if (!NET_SockaddrEqualsInetAddress(env, &rmtaddr,\n-                                                   packetAddress)) {\n-                    \/* force a new InetAddress to be created *\/\n-                    packetAddress = NULL;\n-                }\n-            }\n-            if (packetAddress == NULL) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-                \/* stuff the new Inetaddress in the packet *\/\n-                (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-            } else {\n-                \/* only get the new port number *\/\n-                port = NET_GetPortFromSockaddr(&rmtaddr);\n-            }\n-            \/* and fill in the data, remote address\/port and such *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                       (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, packet, dp_portID, port);\n-            (*env)->SetIntField(env, packet, dp_lengthID, n);\n-        }\n-\n-    } while (retry);\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    datagramSocketCreate\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_datagramSocketCreate(JNIEnv *env,\n-                                                           jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int arg, fd, t = 1;\n-    char tmpbuf[1024];\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if ((fd = socket(domain, SOCK_DGRAM, 0)) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error creating socket\");\n-        return;\n-    }\n-\n-    \/*\n-     * If IPv4 is available, disable IPV6_V6ONLY to ensure dual-socket support.\n-     *\/\n-    if (domain == AF_INET6 && ipv4_available()) {\n-        arg = 0;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n-                       sizeof(int)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set IPPROTO_IPV6\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-#ifdef __APPLE__\n-    arg = (domain == AF_INET6) ? IPV6_SNDBUF_LIMIT : IPV4_SNDBUF_LIMIT;\n-    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF,\n-                   (char *)&arg, sizeof(arg)) < 0) {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-        close(fd);\n-        return;\n-    }\n-#endif \/* __APPLE__ *\/\n-\n-    if (setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char*) &t, sizeof (int)) < 0) {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-        close(fd);\n-        return;\n-    }\n-\n-#if defined(__linux__)\n-     arg = 0;\n-     int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;\n-     if ((setsockopt(fd, level, IP_MULTICAST_ALL, (char*)&arg, sizeof(arg)) < 0) &&\n-           (errno != ENOPROTOOPT))\n-    {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-         close(fd);\n-         return;\n-     }\n-#endif\n-\n-#if defined (__linux__)\n-    \/*\n-     * On Linux for IPv6 sockets we must set the hop limit\n-     * to 1 to be compatible with default TTL of 1 for IPv4 sockets.\n-     *\/\n-    if (domain == AF_INET6) {\n-        int ttl = 1;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *) &ttl,\n-                sizeof (ttl)) < 0) {\n-            getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-            close(fd);\n-            return;\n-        }\n-    }\n-#endif \/* __linux__ *\/\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    datagramSocketClose\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_datagramSocketClose(JNIEnv *env,\n-                                                          jobject this) {\n-    \/*\n-     * REMIND: PUT A LOCK AROUND THIS CODE\n-     *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        return;\n-    }\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-    NET_SocketClose(fd);\n-}\n-\n-\n-\/*\n- * Set outgoing multicast interface designated by a NetworkInterface.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_if_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jfieldID ni_addrsID;\n-    struct in_addr in;\n-    jobjectArray addrArray;\n-    jsize len;\n-    jint family;\n-    jobject addr;\n-    int i;\n-\n-    if (ni_addrsID == NULL ) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                        \"[Ljava\/net\/InetAddress;\");\n-        CHECK_NULL(ni_addrsID);\n-    }\n-\n-    addrArray = (*env)->GetObjectField(env, value, ni_addrsID);\n-    len = (*env)->GetArrayLength(env, addrArray);\n-\n-    \/*\n-     * Check that there is at least one address bound to this\n-     * interface.\n-     *\/\n-    if (len < 1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-            \"bad argument for IP_MULTICAST_IF2: No IP addresses bound to interface\");\n-        return;\n-    }\n-\n-    \/*\n-     * We need an ipv4 address here\n-     *\/\n-    in.s_addr = 0;\n-    for (i = 0; i < len; i++) {\n-        addr = (*env)->GetObjectArrayElement(env, addrArray, i);\n-        family = getInetAddress_family(env, addr);\n-        JNU_CHECK_EXCEPTION(env);\n-        if (family == java_net_InetAddress_IPv4) {\n-            in.s_addr = htonl(getInetAddress_addr(env, addr));\n-            JNU_CHECK_EXCEPTION(env);\n-            break;\n-        }\n-    }\n-\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                   (const char *)&in, sizeof(in)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by a NetworkInterface.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_if_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jfieldID ni_indexID;\n-    int index;\n-\n-    if (ni_indexID == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-        CHECK_NULL(ni_indexID);\n-    }\n-    index = (*env)->GetIntField(env, value, ni_indexID);\n-\n-    if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                   (const char*)&index, sizeof(index)) < 0) {\n-        if ((errno == EINVAL || errno == EADDRNOTAVAIL) && index > 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"IPV6_MULTICAST_IF failed (interface has IPv4 \"\n-                \"address only?)\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        }\n-        return;\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by an InetAddress.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_addr_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    struct in_addr in;\n-\n-    in.s_addr = htonl( getInetAddress_addr(env, value) );\n-    JNU_CHECK_EXCEPTION(env);\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                   (const char*)&in, sizeof(in)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by an InetAddress.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_addr_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jclass ni_class;\n-    if (ni_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL(ni_class);\n-    }\n-\n-    value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);\n-    if (value == NULL) {\n-        if (!(*env)->ExceptionOccurred(env)) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                 \"bad argument for IP_MULTICAST_IF\"\n-                 \": address not bound to any interface\");\n-        }\n-        return;\n-    }\n-\n-    mcast_set_if_by_if_v6(env, this, fd, value);\n-}\n-\n-\/*\n- * Sets the multicast interface.\n- *\n- * SocketOptions.IP_MULTICAST_IF :-\n- *      value is a InetAddress\n- *      IPv4:   set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *      IPv6:   Get the index of the interface to which the\n- *              InetAddress is bound\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- * SockOptions.IF_MULTICAST_IF2 :-\n- *      value is a NetworkInterface\n- *      IPv4:   Obtain IP address bound to network interface\n- *              (NetworkInterface.addres[0])\n- *              set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *      IPv6:   Obtain NetworkInterface.index\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- *\/\n-static void setMulticastInterface(JNIEnv *env, jobject this, int fd,\n-                                  jint opt, jobject value)\n-{\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-        \/*\n-         * value is an InetAddress.\n-         *\/\n-#ifdef __linux__\n-        mcast_set_if_by_addr_v4(env, this, fd, value);\n-        if (ipv6_available()) {\n-            if ((*env)->ExceptionCheck(env)){\n-                (*env)->ExceptionClear(env);\n-            }\n-            mcast_set_if_by_addr_v6(env, this, fd, value);\n-        }\n-#else  \/* __linux__ not defined *\/\n-        if (ipv6_available()) {\n-            mcast_set_if_by_addr_v6(env, this, fd, value);\n-        } else {\n-            mcast_set_if_by_addr_v4(env, this, fd, value);\n-        }\n-#endif  \/* __linux__ *\/\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        \/*\n-         * value is a NetworkInterface.\n-         *\/\n-#ifdef __linux__\n-        mcast_set_if_by_if_v4(env, this, fd, value);\n-        if (ipv6_available()) {\n-            if ((*env)->ExceptionCheck(env)){\n-                (*env)->ExceptionClear(env);\n-            }\n-            mcast_set_if_by_if_v6(env, this, fd, value);\n-        }\n-#else  \/* __linux__ not defined *\/\n-        if (ipv6_available()) {\n-            mcast_set_if_by_if_v6(env, this, fd, value);\n-        } else {\n-            mcast_set_if_by_if_v4(env, this, fd, value);\n-        }\n-#endif  \/* __linux__ *\/\n-    }\n-}\n-\n-\/*\n- * Enable\/disable local loopback of multicast datagrams.\n- *\/\n-static void mcast_set_loop_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    jclass cls;\n-    jfieldID fid;\n-    jboolean on;\n-    char loopback;\n-\n-    cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-    CHECK_NULL(cls);\n-    fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-    CHECK_NULL(fid);\n-\n-    on = (*env)->GetBooleanField(env, value, fid);\n-    loopback = (!on ? 1 : 0);\n-\n-    if (NET_SetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,\n-                       (const void *)&loopback, sizeof(char)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-}\n-\n-\/*\n- * Enable\/disable local loopback of multicast datagrams.\n- *\/\n-static void mcast_set_loop_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    jclass cls;\n-    jfieldID fid;\n-    jboolean on;\n-    int loopback;\n-\n-    cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-    CHECK_NULL(cls);\n-    fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-    CHECK_NULL(fid);\n-\n-    on = (*env)->GetBooleanField(env, value, fid);\n-    loopback = (!on ? 1 : 0);\n-\n-    if (NET_SetSockOpt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,\n-                       (const void *)&loopback, sizeof(int)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-\n-}\n-\n-\/*\n- * Sets the multicast loopback mode.\n- *\/\n-static void setMulticastLoopbackMode(JNIEnv *env, jobject this, int fd,\n-                                     jint opt, jobject value) {\n-#ifdef __linux__\n-    mcast_set_loop_v4(env, this, fd, value);\n-    if (ipv6_available()) {\n-        if ((*env)->ExceptionCheck(env)){\n-            (*env)->ExceptionClear(env);\n-        }\n-        mcast_set_loop_v6(env, this, fd, value);\n-    }\n-#else  \/* __linux__ not defined *\/\n-    if (ipv6_available()) {\n-        mcast_set_loop_v6(env, this, fd, value);\n-    } else {\n-        mcast_set_loop_v4(env, this, fd, value);\n-    }\n-#endif  \/* __linux__ *\/\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    socketSetOption0\n- * Signature: (ILjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_socketSetOption0\n-  (JNIEnv *env, jobject this, jint opt, jobject value)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    int optval;\n-    optlen = sizeof(int);\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    \/*\n-     * Check argument has been provided\n-     *\/\n-    if (IS_NULL(value)) {\n-        JNU_ThrowNullPointerException(env, \"value argument\");\n-        return;\n-    }\n-\n-    \/*\n-     * Setting the multicast interface handled separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-\n-        setMulticastInterface(env, this, fd, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Setting the multicast loopback mode handled separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP) {\n-        setMulticastLoopbackMode(env, this, fd, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                optval = (*env)->GetIntField(env, value, fid);\n-                break;\n-            }\n-\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-        case java_net_SocketOptions_SO_REUSEPORT:\n-        case java_net_SocketOptions_SO_BROADCAST:\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-                jboolean on;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-                CHECK_NULL(fid);\n-\n-                on = (*env)->GetBooleanField(env, value, fid);\n-\n-                \/* SO_REUSEADDR or SO_BROADCAST *\/\n-                optval = (on ? 1 : 0);\n-\n-                break;\n-            }\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by PlainDatagramSocketImp\");\n-            return;\n-\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, optname, (const void *)&optval, optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-}\n-\n-\n-\/*\n- * Return the multicast interface:\n- *\n- * SocketOptions.IP_MULTICAST_IF\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Create InetAddress\n- *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2\n- *              kernel but struct in_addr on 2.4 kernel\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              If index == 0 return InetAddress representing\n- *              anyLocalAddress.\n- *              If index > 0 query NetworkInterface by index\n- *              and returns addrs[0]\n- *\n- * SocketOptions.IP_MULTICAST_IF2\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Query NetworkInterface by IP address and\n- *              return the NetworkInterface that the address\n- *              is bound too.\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              (except Linux .2 kernel)\n- *              Query NetworkInterface by index and\n- *              return NetworkInterface.\n- *\/\n-jobject getMulticastInterface(JNIEnv *env, jobject this, int fd, jint opt) {\n-    jboolean isIPV4 = JNI_TRUE;\n-\n-    if (ipv6_available()) {\n-        isIPV4 = JNI_FALSE;\n-    }\n-\n-    \/*\n-     * IPv4 implementation\n-     *\/\n-    if (isIPV4) {\n-        static jclass inet4_class;\n-        static jmethodID inet4_ctrID;\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jfieldID ni_nameID;\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-        jobject ni_name;\n-\n-        struct in_addr in;\n-        struct in_addr *inP = &in;\n-        socklen_t len = sizeof(struct in_addr);\n-\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                       (char *)inP, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        \/*\n-         * Construct and populate an Inet4Address\n-         *\/\n-        if (inet4_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            inet4_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(inet4_ctrID, NULL);\n-            inet4_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(inet4_class, NULL);\n-        }\n-        addr = (*env)->NewObject(env, inet4_class, inet4_ctrID, 0);\n-        CHECK_NULL_RETURN(addr, NULL);\n-\n-        setInetAddress_addr(env, addr, ntohl(in.s_addr));\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-\n-        \/*\n-         * For IP_MULTICAST_IF return InetAddress\n-         *\/\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-\n-        \/*\n-         * For IP_MULTICAST_IF2 we get the NetworkInterface for\n-         * this address and return it\n-         *\/\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-            ni_nameID = (*env)->GetFieldID(env, c,\"name\", \"Ljava\/lang\/String;\");\n-            CHECK_NULL_RETURN(ni_nameID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-        ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-        if (ni) {\n-            return ni;\n-        }\n-        return NULL;\n-    }\n-\n-\n-    \/*\n-     * IPv6 implementation\n-     *\/\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jclass ia_class;\n-        static jfieldID ni_nameID;\n-        static jmethodID ia_anyLocalAddressID;\n-\n-        int index = 0;\n-        socklen_t len = sizeof(index);\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-        jobject ni_name;\n-\n-        if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                       (char*)&index, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-\n-            ia_class = (*env)->FindClass(env, \"java\/net\/InetAddress\");\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_class = (*env)->NewGlobalRef(env, ia_class);\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_anyLocalAddressID = (*env)->GetStaticMethodID(env,\n-                                                             ia_class,\n-                                                             \"anyLocalAddress\",\n-                                                             \"()Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ia_anyLocalAddressID, NULL);\n-            ni_nameID = (*env)->GetFieldID(env, c,\"name\", \"Ljava\/lang\/String;\");\n-            CHECK_NULL_RETURN(ni_nameID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-\n-        \/*\n-         * If multicast to a specific interface then return the\n-         * interface (for IF2) or the any address on that interface\n-         * (for IF).\n-         *\/\n-        if (index > 0) {\n-            ni = Java_java_net_NetworkInterface_getByIndex0(env, ni_class,\n-                                                                   index);\n-            if (ni == NULL) {\n-                char errmsg[255];\n-                sprintf(errmsg,\n-                        \"IPV6_MULTICAST_IF returned index to unrecognized interface: %d\",\n-                        index);\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-                return NULL;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF2 return the NetworkInterface\n-             *\/\n-            if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-                return ni;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF return addrs[0]\n-             *\/\n-            addrArray = (*env)->GetObjectField(env, ni, ni_addrsID);\n-            if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IPV6_MULTICAST_IF returned interface without IP bindings\");\n-                return NULL;\n-            }\n-\n-            addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-            return addr;\n-        }\n-\n-        \/*\n-         * Multicast to any address - return anyLocalAddress\n-         * or a NetworkInterface with addrs[0] set to anyLocalAddress\n-         *\/\n-\n-        addr = (*env)->CallStaticObjectMethod(env, ia_class, ia_anyLocalAddressID,\n-                                              NULL);\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-    }\n-    return NULL;\n-}\n-\n-\n-\n-\/*\n- * Returns relevant info as a jint.\n- *\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    socketGetOption\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_PlainDatagramSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint opt)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        char c;\n-    } optval;\n-\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket closed\");\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Handle IP_MULTICAST_IF separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        return getMulticastInterface(env, this, fd, opt);\n-\n-    }\n-\n-    \/*\n-     * SO_BINDADDR implemented using getsockname\n-     *\/\n-    if (opt == java_net_SocketOptions_SO_BINDADDR) {\n-        \/* find out local IP address *\/\n-        SOCKETADDRESS sa;\n-        socklen_t len = sizeof(SOCKETADDRESS);\n-        int port;\n-        jobject iaObj;\n-\n-        if (getsockname(fd, &sa.sa, &len) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return NULL;\n-        }\n-        iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-\n-        return iaObj;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return NULL;\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP &&\n-        level == IPPROTO_IP) {\n-        optlen = sizeof(optval.c);\n-    } else {\n-        optlen = sizeof(optval.i);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-        return NULL;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            \/* getLoopbackMode() returns true if IP_MULTICAST_LOOP disabled *\/\n-            if (level == IPPROTO_IP) {\n-                return createBoolean(env, (int)!optval.c);\n-            } else {\n-                return createBoolean(env, !optval.i);\n-            }\n-\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_SO_REUSEPORT:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return createInteger(env, optval.i);\n-\n-    }\n-\n-    \/* should never reach here *\/\n-    return NULL;\n-}\n-\n-\/*\n- * Multicast-related calls\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_setTTL(JNIEnv *env, jobject this,\n-                                             jbyte ttl) {\n-    jint ittl = ttl;\n-    if (ittl < 0) {\n-        ittl += 0x100;\n-    }\n-    Java_java_net_PlainDatagramSocketImpl_setTimeToLive(env, this, ittl);\n-}\n-\n-\/*\n- * Set TTL for a socket. Throw exception if failed.\n- *\/\n-static void setTTL(JNIEnv *env, int fd, jint ttl) {\n-    char ittl = (char)ttl;\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ittl,\n-                   sizeof(ittl)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set hops limit for a socket. Throw exception if failed.\n- *\/\n-static void setHopLimit(JNIEnv *env, int fd, jint ttl) {\n-    int ittl = (int)ttl;\n-    if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n-                   (char*)&ittl, sizeof(ittl)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    setTTL\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_setTimeToLive(JNIEnv *env, jobject this,\n-                                                    jint ttl) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int fd;\n-    \/* it is important to cast this to a char, otherwise setsockopt gets confused *\/\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    \/* setsockopt to be correct TTL *\/\n-#ifdef __linux__\n-    setTTL(env, fd, ttl);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (ipv6_available()) {\n-        setHopLimit(env, fd, ttl);\n-    }\n-#else  \/*  __linux__ not defined *\/\n-    if (ipv6_available()) {\n-        setHopLimit(env, fd, ttl);\n-    } else {\n-        setTTL(env, fd, ttl);\n-    }\n-#endif  \/* __linux__ *\/\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jbyte JNICALL\n-Java_java_net_PlainDatagramSocketImpl_getTTL(JNIEnv *env, jobject this) {\n-    return (jbyte)Java_java_net_PlainDatagramSocketImpl_getTimeToLive(env, this);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_getTimeToLive(JNIEnv *env, jobject this) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint fd = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    \/* getsockopt of TTL *\/\n-    if (ipv6_available()) {\n-        int ttl = 0;\n-        socklen_t len = sizeof(ttl);\n-\n-        if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n-                       (char*)&ttl, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return -1;\n-        }\n-        return (jint)ttl;\n-    } else {\n-        u_char ttl = 0;\n-        socklen_t len = sizeof(ttl);\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,\n-                       (char*)&ttl, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return -1;\n-        }\n-        return (jint)ttl;\n-    }\n-}\n-\n-\n-\/*\n- * mcast_join_leave: Join or leave a multicast group.\n- *\n- * For IPv4 sockets use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP socket option\n- * to join\/leave multicast group.\n- *\n- * For IPv6 sockets use IPV6_ADD_MEMBERSHIP\/IPV6_DROP_MEMBERSHIP socket option\n- * to join\/leave multicast group. If multicast group is an IPv4 address then\n- * an IPv4-mapped address is used.\n- *\n- * On Linux with IPv6 if we wish to join\/leave an IPv4 multicast group then\n- * we must use the IPv4 socket options. This is because the IPv6 socket options\n- * don't support IPv4-mapped addresses. This is true as per 2.2.19 and 2.4.7\n- * kernel releases. In the future it's possible that IP_ADD_MEMBERSHIP\n- * will be updated to return ENOPROTOOPT if uses with an IPv6 socket. Thus to\n- * cater for this we first try with the IPv4 socket options and if they fail we\n- * use the IPv6 socket options. This seems a reasonable failsafe solution.\n- *\/\n-static void mcast_join_leave(JNIEnv *env, jobject this,\n-                             jobject iaObj, jobject niObj,\n-                             jboolean join) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint fd;\n-    jint family;\n-    jint ipv6_join_leave;\n-    int res;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj\");\n-        return;\n-    }\n-\n-    \/*\n-     * Determine if this is an IPv4 or IPv6 join\/leave.\n-     *\/\n-    ipv6_join_leave = ipv6_available();\n-\n-#ifdef __linux__\n-    family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv4) {\n-        ipv6_join_leave = JNI_FALSE;\n-    }\n-#endif\n-\n-    \/*\n-     * For IPv4 join use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP socket option\n-     *\n-     * On Linux if IPv4 or IPv6 use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP\n-     *\/\n-    if (!ipv6_join_leave) {\n-#ifdef __linux__\n-        struct ip_mreqn mname;\n-#else\n-        struct ip_mreq mname;\n-#endif\n-        int mname_len;\n-\n-        \/*\n-         * joinGroup(InetAddress, NetworkInterface) implementation :-\n-         *\n-         * Linux\/IPv6:  use ip_mreqn structure populated with multicast\n-         *              address and interface index.\n-         *\n-         * IPv4:        use ip_mreq structure populated with multicast\n-         *              address and first address obtained from\n-         *              NetworkInterface\n-         *\/\n-        if (niObj != NULL) {\n-#if defined(__linux__)\n-            if (ipv6_available()) {\n-                static jfieldID ni_indexID;\n-\n-                if (ni_indexID == NULL) {\n-                    jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                    CHECK_NULL(c);\n-                    ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-                    CHECK_NULL(ni_indexID);\n-                }\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_address.s_addr = 0;\n-                mname.imr_ifindex =  (*env)->GetIntField(env, niObj, ni_indexID);\n-                mname_len = sizeof(struct ip_mreqn);\n-            } else\n-#endif\n-            {\n-                jobjectArray addrArray = (*env)->GetObjectField(env, niObj, ni_addrsID);\n-                jobject addr;\n-\n-                if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"bad argument for IP_ADD_MEMBERSHIP: \"\n-                        \"No IP addresses bound to interface\");\n-                    return;\n-                }\n-                addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-#ifdef __linux__\n-                mname.imr_address.s_addr = htonl(getInetAddress_addr(env, addr));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_ifindex = 0;\n-#else\n-                mname.imr_interface.s_addr = htonl(getInetAddress_addr(env, addr));\n-                JNU_CHECK_EXCEPTION(env);\n-#endif\n-                mname_len = sizeof(struct ip_mreq);\n-            }\n-        }\n-\n-\n-        \/*\n-         * joinGroup(InetAddress) implementation :-\n-         *\n-         * Linux\/IPv6:  use ip_mreqn structure populated with multicast\n-         *              address and interface index. index obtained\n-         *              from cached value or IPV6_MULTICAST_IF.\n-         *\n-         * IPv4:        use ip_mreq structure populated with multicast\n-         *              address and local address obtained from\n-         *              IP_MULTICAST_IF. On Linux IP_MULTICAST_IF\n-         *              returns different structure depending on\n-         *              kernel.\n-         *\/\n-\n-        if (niObj == NULL) {\n-\n-#if defined(__linux__)\n-            if (ipv6_available()) {\n-\n-                int index;\n-                socklen_t len = sizeof(index);\n-\n-                if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (char*)&index, &len) < 0) {\n-                    NET_ThrowCurrent(env, \"getsockopt IPV6_MULTICAST_IF failed\");\n-                    return;\n-                }\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_address.s_addr = 0 ;\n-                mname.imr_ifindex = index;\n-                mname_len = sizeof(struct ip_mreqn);\n-            } else\n-#endif\n-            {\n-                struct in_addr in;\n-                struct in_addr *inP = &in;\n-                socklen_t len = sizeof(struct in_addr);\n-\n-                if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, (char *)inP, &len) < 0) {\n-                    NET_ThrowCurrent(env, \"getsockopt IP_MULTICAST_IF failed\");\n-                    return;\n-                }\n-\n-#ifdef __linux__\n-                mname.imr_address.s_addr = in.s_addr;\n-                mname.imr_ifindex = 0;\n-#else\n-                mname.imr_interface.s_addr = in.s_addr;\n-#endif\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname_len = sizeof(struct ip_mreq);\n-            }\n-        }\n-\n-\n-        \/*\n-         * Join the multicast group.\n-         *\/\n-        res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n-                       (char *) &mname, mname_len);\n-\n-#ifdef __APPLE__\n-        if (res < 0 && errno == ENOMEM) {\n-            res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n-                       (char *) &mname, mname_len);\n-        }\n-#endif\n-\n-        if (res < 0) {\n-            \/*\n-             * If IP_ADD_MEMBERSHIP returns ENOPROTOOPT on Linux and we've got\n-             * IPv6 enabled then it's possible that the kernel has been fixed\n-             * so we switch to IPV6_ADD_MEMBERSHIP socket option.\n-             * As of 2.4.7 kernel IPV6_ADD_MEMBERSHIP can't handle IPv4-mapped\n-             * addresses so we have to use IP_ADD_MEMBERSHIP for IPv4 multicast\n-             * groups. However if the socket is an IPv6 socket then setsockopt\n-             * should return ENOPROTOOPT. We assume this will be fixed in Linux\n-             * at some stage.\n-             *\/\n-#if defined(__linux__)\n-            if (errno == ENOPROTOOPT) {\n-                if (ipv6_available()) {\n-                    ipv6_join_leave = JNI_TRUE;\n-                    errno = 0;\n-                } else  {\n-                    errno = ENOPROTOOPT;    \/* errno can be changed by ipv6_available *\/\n-                }\n-            }\n-#endif\n-            if (errno) {\n-                if (join) {\n-                    NET_ThrowCurrent(env, \"setsockopt IP_ADD_MEMBERSHIP failed\");\n-                } else {\n-                    if (errno == ENOENT)\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"Not a member of the multicast group\");\n-                    else\n-                        NET_ThrowCurrent(env, \"setsockopt IP_DROP_MEMBERSHIP failed\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        \/*\n-         * If we haven't switched to IPv6 socket option then we're done.\n-         *\/\n-        if (!ipv6_join_leave) {\n-            return;\n-        }\n-    }\n-\n-\n-    \/*\n-     * IPv6 join. If it's an IPv4 multicast group then we use an IPv4-mapped\n-     * address.\n-     *\/\n-    {\n-        struct ipv6_mreq mname6;\n-        jbyteArray ipaddress;\n-        jbyte caddr[16];\n-        jint family;\n-        jint address;\n-        family = getInetAddress_family(env, iaObj) == java_net_InetAddress_IPv4 ?\n-            AF_INET : AF_INET6;\n-        JNU_CHECK_EXCEPTION(env);\n-        if (family == AF_INET) { \/* will convert to IPv4-mapped address *\/\n-            memset((char *) caddr, 0, 16);\n-            address = getInetAddress_addr(env, iaObj);\n-            JNU_CHECK_EXCEPTION(env);\n-            caddr[10] = 0xff;\n-            caddr[11] = 0xff;\n-\n-            caddr[12] = ((address >> 24) & 0xff);\n-            caddr[13] = ((address >> 16) & 0xff);\n-            caddr[14] = ((address >> 8) & 0xff);\n-            caddr[15] = (address & 0xff);\n-        } else {\n-            getInet6Address_ipaddress(env, iaObj, (char*)caddr);\n-        }\n-\n-        memcpy((void *)&(mname6.ipv6mr_multiaddr), caddr, sizeof(struct in6_addr));\n-        if (IS_NULL(niObj)) {\n-            int index;\n-            socklen_t len = sizeof(index);\n-\n-            if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                           (char*)&index, &len) < 0) {\n-                NET_ThrowCurrent(env, \"getsockopt IPV6_MULTICAST_IF failed\");\n-                return;\n-            }\n-            mname6.ipv6mr_interface = index;\n-        } else {\n-            jint idx = (*env)->GetIntField(env, niObj, ni_indexID);\n-            mname6.ipv6mr_interface = idx;\n-        }\n-\n-#if defined(_ALLBSD_SOURCE)\n-#define ADD_MEMBERSHIP          IPV6_JOIN_GROUP\n-#define DRP_MEMBERSHIP          IPV6_LEAVE_GROUP\n-#define S_ADD_MEMBERSHIP        \"IPV6_JOIN_GROUP\"\n-#define S_DRP_MEMBERSHIP        \"IPV6_LEAVE_GROUP\"\n-#else\n-#define ADD_MEMBERSHIP          IPV6_ADD_MEMBERSHIP\n-#define DRP_MEMBERSHIP          IPV6_DROP_MEMBERSHIP\n-#define S_ADD_MEMBERSHIP        \"IPV6_ADD_MEMBERSHIP\"\n-#define S_DRP_MEMBERSHIP        \"IPV6_DROP_MEMBERSHIP\"\n-#endif\n-\n-        \/* Join the multicast group *\/\n-        res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n-                       (char *) &mname6, sizeof(mname6));\n-\n-#ifdef __APPLE__\n-        if (res < 0 && errno == ENOMEM) {\n-            res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n-                       (char *) &mname6, sizeof(mname6));\n-        }\n-#endif\n-        if (res < 0) {\n-            if (join) {\n-                NET_ThrowCurrent(env, \"setsockopt \" S_ADD_MEMBERSHIP \" failed\");\n-            } else {\n-                if (errno == ENOENT) {\n-                   JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Not a member of the multicast group\");\n-                } else {\n-                    NET_ThrowCurrent(env, \"setsockopt \" S_DRP_MEMBERSHIP \" failed\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    join\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_join(JNIEnv *env, jobject this,\n-                                           jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave(env, this, iaObj, niObj, JNI_TRUE);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    leave\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_leave(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave(env, this, iaObj, niObj, JNI_FALSE);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_dataAvailable(JNIEnv *env, jobject this)\n-{\n-    int fd, retval;\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (ioctl(fd, FIONREAD, &retval) < 0) {\n-        return -1;\n-    }\n-    return retval;\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainDatagramSocketImpl.c","additions":0,"deletions":2179,"binary":false,"changes":2179,"status":"deleted"},{"patch":"@@ -1,994 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOptions.h\"\n-#include \"java_net_PlainSocketImpl.h\"\n-\n-\/************************************************************************\n- * PlainSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-jfieldID psi_fdID;\n-jfieldID psi_addressID;\n-jfieldID psi_ipaddressID;\n-jfieldID psi_portID;\n-jfieldID psi_localportID;\n-jfieldID psi_timeoutID;\n-jfieldID psi_trafficClassID;\n-jfieldID psi_fdLockID;\n-jfieldID psi_closePendingID;\n-\n-\/*\n- * file descriptor used for dup2\n- *\/\n-static int marker_fd = -1;\n-\n-\n-#define SET_NONBLOCKING(fd) {           \\\n-        int flags = fcntl(fd, F_GETFL); \\\n-        flags |= O_NONBLOCK;            \\\n-        fcntl(fd, F_SETFL, flags);      \\\n-}\n-\n-#define SET_BLOCKING(fd) {              \\\n-        int flags = fcntl(fd, F_GETFL); \\\n-        flags &= ~O_NONBLOCK;           \\\n-        fcntl(fd, F_SETFL, flags);      \\\n-}\n-\n-\/*\n- * Create the marker file descriptor by establishing a loopback connection\n- * which we shutdown but do not close the fd. The result is an fd that\n- * can be used for read\/write.\n- *\/\n-static int getMarkerFD()\n-{\n-    int sv[2];\n-\n-#ifdef AF_UNIX\n-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {\n-        return -1;\n-    }\n-#else\n-    return -1;\n-#endif\n-\n-    \/*\n-     * Finally shutdown sv[0] (any reads to this fd will get\n-     * EOF; any writes will get an error).\n-     *\/\n-    shutdown(sv[0], 2);\n-    close(sv[1]);\n-\n-    return sv[0];\n-}\n-\n-\/*\n- * Return the file descriptor given a PlainSocketImpl\n- *\/\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    CHECK_NULL_RETURN(fdObj, -1);\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * The initroto function is called whenever PlainSocketImpl is\n- * loaded, to cache field IDs for efficiency. This is called every time\n- * the Java class is loaded.\n- *\n- * Class:     java_net_PlainSocketImpl\n- * Method:    initProto\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_initProto(JNIEnv *env, jclass cls) {\n-    psi_fdID = (*env)->GetFieldID(env, cls , \"fd\",\n-                                  \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(psi_fdID);\n-    psi_addressID = (*env)->GetFieldID(env, cls, \"address\",\n-                                          \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(psi_addressID);\n-    psi_portID = (*env)->GetFieldID(env, cls, \"port\", \"I\");\n-    CHECK_NULL(psi_portID);\n-    psi_localportID = (*env)->GetFieldID(env, cls, \"localport\", \"I\");\n-    CHECK_NULL(psi_localportID);\n-    psi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(psi_timeoutID);\n-    psi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(psi_trafficClassID);\n-    psi_fdLockID = (*env)->GetFieldID(env, cls, \"fdLock\",\n-                                      \"Ljava\/lang\/Object;\");\n-    CHECK_NULL(psi_fdLockID);\n-    psi_closePendingID = (*env)->GetFieldID(env, cls, \"closePending\", \"Z\");\n-    CHECK_NULL(psi_closePendingID);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    initInetAddressIDs(env);\n-    JNU_CHECK_EXCEPTION(env);\n-\n-    \/* Create the marker fd used for dup2 *\/\n-    marker_fd = getMarkerFD();\n-}\n-\n-\/* a global reference to the java.net.SocketException class. In\n- * socketCreate, we ensure that this is initialized. This is to\n- * prevent the problem where socketCreate runs out of file\n- * descriptors, and is then unable to load the exception class.\n- *\/\n-static jclass socketExceptionCls;\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketCreate\n- * Signature: (ZZ)V *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketCreate(JNIEnv *env, jobject this,\n-                                           jboolean stream, jboolean isServer) {\n-    jobject fdObj, ssObj;\n-    int fd;\n-    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    if (socketExceptionCls == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/SocketException\");\n-        CHECK_NULL(c);\n-        socketExceptionCls = (jclass)(*env)->NewGlobalRef(env, c);\n-        CHECK_NULL(socketExceptionCls);\n-    }\n-    fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    if (fdObj == NULL) {\n-        (*env)->ThrowNew(env, socketExceptionCls, \"null fd object\");\n-        return;\n-    }\n-\n-    if ((fd = socket(domain, type, 0)) == -1) {\n-        \/* note: if you run out of fds, you may not be able to load\n-         * the exception class, and get a NoClassDefFoundError\n-         * instead.\n-         *\/\n-        NET_ThrowNew(env, errno, \"can't create socket\");\n-        return;\n-    }\n-\n-    \/*\n-     * If IPv4 is available, disable IPV6_V6ONLY to ensure dual-socket support.\n-     *\/\n-    if (domain == AF_INET6 && ipv4_available()) {\n-        int arg = 0;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n-                       sizeof(int)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set IPPROTO_IPV6\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-    \/*\n-     * If this is a server socket then enable SO_REUSEADDR\n-     * automatically and set to non blocking.\n-     *\/\n-    if (isServer) {\n-        int arg = 1;\n-        SET_NONBLOCKING(fd);\n-        if (NET_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,\n-                       sizeof(arg)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set SO_REUSEADDR\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-}\n-\n-\/*\n- * inetAddress is the address object passed to the socket connect\n- * call.\n- *\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketConnect\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketConnect(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jint port,\n-                                            jint timeout)\n-{\n-    jint localport = (*env)->GetIntField(env, this, psi_localportID);\n-    int len = 0;\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    jclass clazz = (*env)->GetObjectClass(env, this);\n-\n-    jobject fdLock;\n-\n-    jint trafficClass = (*env)->GetIntField(env, this, psi_trafficClassID);\n-\n-    \/* fd is an int field on iaObj *\/\n-    jint fd;\n-\n-    SOCKETADDRESS sa;\n-    \/* The result of the connection *\/\n-    int connect_rv = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"inet address argument null.\");\n-        return;\n-    }\n-\n-    \/* connect *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa, &len,\n-                                  JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    if (trafficClass != 0 && ipv6_available()) {\n-        NET_SetTrafficClass(&sa, trafficClass);\n-    }\n-\n-    if (timeout <= 0) {\n-        connect_rv = NET_Connect(fd, &sa.sa, len);\n-    } else {\n-        \/*\n-         * A timeout was specified. We put the socket into non-blocking\n-         * mode, connect, and then wait for the connection to be\n-         * established, fail, or timeout.\n-         *\/\n-        SET_NONBLOCKING(fd);\n-\n-        \/* no need to use NET_Connect as non-blocking *\/\n-        connect_rv = connect(fd, &sa.sa, len);\n-\n-        \/* connection not established immediately *\/\n-        if (connect_rv != 0) {\n-            socklen_t optlen;\n-            jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-            jlong prevNanoTime = JVM_NanoTime(env, 0);\n-\n-            if (errno != EINPROGRESS) {\n-                NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                             \"connect failed\");\n-                SET_BLOCKING(fd);\n-                return;\n-            }\n-\n-            \/*\n-             * Wait for the connection to be established or a\n-             * timeout occurs. poll needs to handle EINTR in\n-             * case lwp sig handler redirects any process signals to\n-             * this thread.\n-             *\/\n-            while (1) {\n-                jlong newNanoTime;\n-                struct pollfd pfd;\n-                pfd.fd = fd;\n-                pfd.events = POLLOUT;\n-\n-                errno = 0;\n-                connect_rv = NET_Poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-\n-                if (connect_rv >= 0) {\n-                    break;\n-                }\n-                if (errno != EINTR) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * The poll was interrupted so adjust timeout and\n-                 * restart\n-                 *\/\n-                newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= (newNanoTime - prevNanoTime);\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    connect_rv = 0;\n-                    break;\n-                }\n-                prevNanoTime = newNanoTime;\n-\n-            } \/* while *\/\n-\n-            if (connect_rv == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"connect timed out\");\n-\n-                \/*\n-                 * Timeout out but connection may still be established.\n-                 * At the high level it should be closed immediately but\n-                 * just in case we make the socket blocking again and\n-                 * shutdown input & output.\n-                 *\/\n-                SET_BLOCKING(fd);\n-                shutdown(fd, 2);\n-                return;\n-            }\n-\n-            \/* has connection been established *\/\n-            optlen = sizeof(connect_rv);\n-            if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&connect_rv,\n-                           &optlen) <0) {\n-                connect_rv = errno;\n-            }\n-        }\n-\n-        \/* make socket blocking again *\/\n-        SET_BLOCKING(fd);\n-\n-        \/* restore errno *\/\n-        if (connect_rv != 0) {\n-            errno = connect_rv;\n-            connect_rv = -1;\n-        }\n-    }\n-\n-    \/* report the appropriate exception *\/\n-    if (connect_rv < 0) {\n-\n-#ifdef __linux__\n-        \/*\n-         * Linux\/GNU distribution setup \/etc\/hosts so that\n-         * InetAddress.getLocalHost gets back the loopback address\n-         * rather than the host address. Thus a socket can be\n-         * bound to the loopback address and the connect will\n-         * fail with EADDRNOTAVAIL. In addition the Linux kernel\n-         * returns the wrong error in this case - it returns EINVAL\n-         * instead of EADDRNOTAVAIL. We handle this here so that\n-         * a more descriptive exception text is used.\n-         *\/\n-        if (connect_rv == -1 && errno == EINVAL) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Invalid argument or cannot assign requested address\");\n-            return;\n-        }\n-#endif\n-#if defined(EPROTO)\n-        if (errno == EPROTO) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ProtocolException\",\n-                           \"Protocol error\");\n-            return;\n-        }\n-#endif\n-        if (errno == ECONNREFUSED) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                           \"Connection refused\");\n-        } else if (errno == ETIMEDOUT) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                           \"Connection timed out\");\n-        } else if (errno == EHOSTUNREACH) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"NoRouteToHostException\",\n-                           \"Host unreachable\");\n-        } else if (errno == EADDRNOTAVAIL) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"NoRouteToHostException\",\n-                             \"Address not available\");\n-        } else if ((errno == EISCONN) || (errno == EBADF)) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"Socket closed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"connect failed\");\n-        }\n-        return;\n-    }\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-\n-    \/* set the remote peer address and port *\/\n-    (*env)->SetObjectField(env, this, psi_addressID, iaObj);\n-    (*env)->SetIntField(env, this, psi_portID, port);\n-\n-    \/*\n-     * we need to initialize the local port field if bind was called\n-     * previously to the connect (by the client) then localport field\n-     * will already be initialized\n-     *\/\n-    if (localport == 0) {\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        socklen_t slen = sizeof(SOCKETADDRESS);\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-        } else {\n-            localport = NET_GetPortFromSockaddr(&sa);\n-            (*env)->SetIntField(env, this, psi_localportID, localport);\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketBind\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketBind(JNIEnv *env, jobject this,\n-                                         jobject iaObj, jint localport) {\n-\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    \/* fd is an int field on fdObj *\/\n-    int fd;\n-    int len = 0;\n-    SOCKETADDRESS sa;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj is null.\");\n-        return;\n-    }\n-\n-    \/* bind *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, localport, &sa,\n-                                  &len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    if (NET_Bind(fd, &sa, len) < 0) {\n-        if (errno == EADDRINUSE || errno == EADDRNOTAVAIL ||\n-            errno == EPERM || errno == EACCES) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"BindException\",\n-                           \"Bind failed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Bind failed\");\n-        }\n-        return;\n-    }\n-\n-    \/* set the address *\/\n-    (*env)->SetObjectField(env, this, psi_addressID, iaObj);\n-\n-    \/* initialize the local port *\/\n-    if (localport == 0) {\n-        socklen_t slen = sizeof(SOCKETADDRESS);\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return;\n-        }\n-        localport = NET_GetPortFromSockaddr(&sa);\n-        (*env)->SetIntField(env, this, psi_localportID, localport);\n-    } else {\n-        (*env)->SetIntField(env, this, psi_localportID, localport);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketListen\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketListen(JNIEnv *env, jobject this,\n-                                           jint count)\n-{\n-    \/* this FileDescriptor fd field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    \/* fdObj's int fd field *\/\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    \/*\n-     * Workaround for bugid 4101691 in Solaris 2.6. See 4106600.\n-     * If listen backlog is Integer.MAX_VALUE then subtract 1.\n-     *\/\n-    if (count == 0x7fffffff)\n-        count -= 1;\n-\n-    if (listen(fd, count) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Listen failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketAccept\n- * Signature: (Ljava\/net\/SocketImpl;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketAccept(JNIEnv *env, jobject this,\n-                                           jobject socket)\n-{\n-    \/* fields on this *\/\n-    int port;\n-    jint timeout = (*env)->GetIntField(env, this, psi_timeoutID);\n-    jlong prevNanoTime = 0;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    \/* the FileDescriptor field on socket *\/\n-    jobject socketFdObj;\n-    \/* the InetAddress field on socket *\/\n-    jobject socketAddressObj;\n-\n-    \/* the ServerSocket fd int field on fdObj *\/\n-    jint fd;\n-\n-    \/* accepted fd *\/\n-    jint newfd;\n-\n-    SOCKETADDRESS sa;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(socket)) {\n-        JNU_ThrowNullPointerException(env, \"socket is null\");\n-        return;\n-    }\n-\n-    \/*\n-     * accept connection but ignore ECONNABORTED indicating that\n-     * connection was eagerly accepted by the OS but was reset\n-     * before accept() was called.\n-     *\n-     * If accept timeout in place and timeout is adjusted with\n-     * each ECONNABORTED or EWOULDBLOCK or EAGAIN to ensure that\n-     * semantics of timeout are preserved.\n-     *\/\n-    for (;;) {\n-        int ret;\n-        jlong currNanoTime;\n-\n-        \/* first usage pick up current time *\/\n-        if (prevNanoTime == 0 && nanoTimeout > 0) {\n-            prevNanoTime = JVM_NanoTime(env, 0);\n-        }\n-\n-        \/* passing a timeout of 0 to poll will return immediately,\n-           but in the case of ServerSocket 0 means infinite. *\/\n-        if (timeout <= 0) {\n-            ret = NET_Timeout(env, fd, -1, 0);\n-        } else {\n-            ret = NET_Timeout(env, fd, nanoTimeout \/ NET_NSEC_PER_MSEC, prevNanoTime);\n-        }\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Accept timed out\");\n-            return;\n-        } else if (ret == -1) {\n-            if (errno == EBADF) {\n-               JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else if (errno == ENOMEM) {\n-               JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-            } else {\n-               JNU_ThrowByNameWithMessageAndLastError\n-                   (env, JNU_JAVANETPKG \"SocketException\", \"Accept failed\");\n-            }\n-            return;\n-        }\n-\n-        newfd = NET_Accept(fd, &sa.sa, &slen);\n-\n-        \/* connection accepted *\/\n-        if (newfd >= 0) {\n-            SET_BLOCKING(newfd);\n-            break;\n-        }\n-\n-        \/* non (ECONNABORTED or EWOULDBLOCK or EAGAIN) error *\/\n-        if (!(errno == ECONNABORTED || errno == EWOULDBLOCK || errno == EAGAIN)) {\n-            break;\n-        }\n-\n-        \/* ECONNABORTED or EWOULDBLOCK or EAGAIN error so adjust timeout if there is one. *\/\n-        if (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-            currNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= (currNanoTime - prevNanoTime);\n-            if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"Accept timed out\");\n-                return;\n-            }\n-            prevNanoTime = currNanoTime;\n-        }\n-    }\n-\n-    if (newfd < 0) {\n-        if (newfd == -2) {\n-            JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                            \"operation interrupted\");\n-        } else {\n-            if (errno == EINVAL) {\n-                errno = EBADF;\n-            }\n-            if (errno == EBADF) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Accept failed\");\n-            }\n-        }\n-        return;\n-    }\n-\n-    \/*\n-     * fill up the remote peer port and address in the new socket structure.\n-     *\/\n-    socketAddressObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    if (socketAddressObj == NULL) {\n-        \/* should be pending exception *\/\n-        close(newfd);\n-        return;\n-    }\n-\n-    \/*\n-     * Populate SocketImpl.fd.fd\n-     *\/\n-    socketFdObj = (*env)->GetObjectField(env, socket, psi_fdID);\n-    (*env)->SetIntField(env, socketFdObj, IO_fd_fdID, newfd);\n-\n-    (*env)->SetObjectField(env, socket, psi_addressID, socketAddressObj);\n-    (*env)->SetIntField(env, socket, psi_portID, port);\n-    \/* also fill up the local port information *\/\n-     port = (*env)->GetIntField(env, this, psi_localportID);\n-    (*env)->SetIntField(env, socket, psi_localportID, port);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainSocketImpl_socketAvailable(JNIEnv *env, jobject this) {\n-    int count = 0;\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (NET_SocketAvailable(fd, &count) != 0) {\n-        if (errno == ECONNRESET) {\n-            JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\", \"\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"ioctl FIONREAD failed\");\n-        }\n-    }\n-    return (jint) count;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketClose0\n- * Signature: (Z)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketClose0(JNIEnv *env, jobject this,\n-                                          jboolean useDeferredClose) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket already closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (fd != -1) {\n-        if (useDeferredClose && marker_fd >= 0) {\n-            NET_Dup2(marker_fd, fd);\n-        } else {\n-            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-            NET_SocketClose(fd);\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketShutdown\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketShutdown(JNIEnv *env, jobject this,\n-                                             jint howto)\n-{\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    \/*\n-     * WARNING: THIS NEEDS LOCKING. ALSO: SHOULD WE CHECK for fd being\n-     * -1 already?\n-     *\/\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket already closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    shutdown(fd, howto);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketSetOption0\n- * Signature: (IZLjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketSetOption0\n-  (JNIEnv *env, jobject this, jint cmd, jboolean on, jobject value)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        struct linger ling;\n-    } optval;\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    \/*\n-     * SO_TIMEOUT is a NOOP on Solaris\/Linux\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_TIMEOUT) {\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(cmd, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_SO_LINGER :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid = (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                if (cmd == java_net_SocketOptions_SO_LINGER) {\n-                    if (on) {\n-                        optval.ling.l_onoff = 1;\n-                        optval.ling.l_linger = (*env)->GetIntField(env, value, fid);\n-                    } else {\n-                        optval.ling.l_onoff = 0;\n-                        optval.ling.l_linger = 0;\n-                    }\n-                    optlen = sizeof(optval.ling);\n-                } else {\n-                    optval.i = (*env)->GetIntField(env, value, fid);\n-                    optlen = sizeof(optval.i);\n-                }\n-\n-                break;\n-            }\n-\n-        \/* Boolean -> int *\/\n-        default :\n-            optval.i = (on ? 1 : 0);\n-            optlen = sizeof(optval.i);\n-\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, optname, (const void *)&optval, optlen) < 0) {\n-#if defined(_AIX)\n-        if (errno == EINVAL) {\n-            \/\/ On AIX setsockopt will set errno to EINVAL if the socket\n-            \/\/ is closed. The default error message is then confusing\n-            char fullMsg[128];\n-            jio_snprintf(fullMsg, sizeof(fullMsg), \"Invalid option or socket reset by remote peer\");\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", fullMsg);\n-            return;\n-        }\n-#endif \/* _AIX *\/\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketGetOption\n- * Signature: (ILjava\/lang\/Object;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint cmd, jobject iaContainerObj)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        struct linger ling;\n-    } optval;\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * SO_BINDADDR isn't a socket option\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_BINDADDR) {\n-        SOCKETADDRESS sa;\n-        socklen_t len = sizeof(SOCKETADDRESS);\n-        int port;\n-        jobject iaObj;\n-        jclass iaCntrClass;\n-        jfieldID iaFieldID;\n-\n-        if (getsockname(fd, &sa.sa, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return -1;\n-        }\n-        iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-        CHECK_NULL_RETURN(iaObj, -1);\n-\n-        iaCntrClass = (*env)->GetObjectClass(env, iaContainerObj);\n-        iaFieldID = (*env)->GetFieldID(env, iaCntrClass, \"addr\", \"Ljava\/net\/InetAddress;\");\n-        CHECK_NULL_RETURN(iaFieldID, -1);\n-        (*env)->SetObjectField(env, iaContainerObj, iaFieldID, iaObj);\n-        return 0; \/* notice change from before *\/\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(cmd, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * Args are int except for SO_LINGER\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_LINGER) {\n-        optlen = sizeof(optval.ling);\n-    } else {\n-        optlen = sizeof(optval.i);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-        return -1;\n-    }\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_SO_LINGER:\n-            return (optval.ling.l_onoff ? optval.ling.l_linger: -1);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return optval.i;\n-\n-        default :\n-            return (optval.i == 0) ? -1 : 1;\n-    }\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketSendUrgentData\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketSendUrgentData(JNIEnv *env, jobject this,\n-                                             jint data) {\n-    \/* The fd field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    int n, fd;\n-    unsigned char d = data & 0xFF;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        \/* Bug 4086704 - If the Socket associated with this file descriptor\n-         * was closed (sysCloseFD), the file descriptor is set to -1.\n-         *\/\n-        if (fd == -1) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            return;\n-        }\n-\n-    }\n-    n = NET_Send(fd, (char *)&d, 1, MSG_OOB);\n-    if (n == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Write failed\");\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":0,"deletions":994,"binary":false,"changes":994,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <string.h>\n-\n-#include \"net_util.h\"\n-#include \"java_net_SocketCleanable.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainDatagramSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_net_Sockets_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_SocketCleanable\n- * Method:    cleanupClose0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketCleanable_cleanupClose0(JNIEnv *env, jclass c1, jint fd)\n-{\n-    NET_SocketClose(fd);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketInputStream.h\"\n-\n-\/*\n- * SocketInputStream\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketInputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-static int NET_ReadWithTimeout(JNIEnv *env, int fd, char *bufP, int len, long timeout) {\n-    int result = 0;\n-    jlong prevNanoTime = JVM_NanoTime(env, 0);\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    while (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-        result = NET_Timeout(env, fd, nanoTimeout \/ NET_NSEC_PER_MSEC, prevNanoTime);\n-        if (result <= 0) {\n-            if (result == 0) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\", \"Read timed out\");\n-            } else if (result == -1) {\n-                if (errno == EBADF) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-                } else if (errno == ENOMEM) {\n-                    JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-                } else {\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                            (env, \"java\/net\/SocketException\", \"select\/poll failed\");\n-                }\n-            }\n-            return -1;\n-        }\n-        result = NET_NonBlockingRead(fd, bufP, len);\n-        if (result == -1 && ((errno == EAGAIN) || (errno == EWOULDBLOCK))) {\n-            jlong newtNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= newtNanoTime - prevNanoTime;\n-            if (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-                prevNanoTime = newtNanoTime;\n-            }\n-        } else {\n-            break;\n-        }\n-    }\n-    return result;\n-}\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    socketRead0\n- * Signature: (Ljava\/io\/FileDescriptor;[BIII)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_SocketInputStream_socketRead0(JNIEnv *env, jobject this,\n-                                            jobject fdObj, jbyteArray data,\n-                                            jint off, jint len, jint timeout)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *bufP;\n-    jint fd, nread;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * If the read is greater than our stack allocated buffer then\n-     * we allocate from the heap (up to a limit)\n-     *\/\n-    if (len > MAX_BUFFER_LEN) {\n-        if (len > MAX_HEAP_BUFFER_LEN) {\n-            len = MAX_HEAP_BUFFER_LEN;\n-        }\n-        bufP = (char *)malloc((size_t)len);\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            len = MAX_BUFFER_LEN;\n-        }\n-    } else {\n-        bufP = BUF;\n-    }\n-    if (timeout) {\n-        nread = NET_ReadWithTimeout(env, fd, bufP, len, timeout);\n-        if ((*env)->ExceptionCheck(env)) {\n-            if (bufP != BUF) {\n-                free(bufP);\n-            }\n-            return nread;\n-        }\n-    } else {\n-        nread = NET_Read(fd, bufP, len);\n-    }\n-\n-    if (nread <= 0) {\n-        if (nread < 0) {\n-\n-            switch (errno) {\n-                case ECONNRESET:\n-                case EPIPE:\n-                    JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\",\n-                        \"Connection reset\");\n-                    break;\n-\n-                case EBADF:\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-                    break;\n-\n-                case EINTR:\n-                     JNU_ThrowByName(env, \"java\/io\/InterruptedIOException\",\n-                           \"Operation interrupted\");\n-                     break;\n-                default:\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                        (env, \"java\/net\/SocketException\", \"Read failed\");\n-            }\n-        }\n-    } else {\n-        (*env)->SetByteArrayRegion(env, data, off, nread, (jbyte *)bufP);\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-    return nread;\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketInputStream.c","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOutputStream.h\"\n-\n-#define min(a, b)       ((a) < (b) ? (a) : (b))\n-\n-\/*\n- * SocketOutputStream\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    socketWrite0\n- * Signature: (Ljava\/io\/FileDescriptor;[BII)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,\n-                                              jobject fdObj,\n-                                              jbyteArray data,\n-                                              jint off, jint len) {\n-    char *bufP;\n-    char BUF[MAX_BUFFER_LEN];\n-    int buflen;\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        \/* Bug 4086704 - If the Socket associated with this file descriptor\n-         * was closed (sysCloseFD), the file descriptor is set to -1.\n-         *\/\n-        if (fd == -1) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            return;\n-        }\n-\n-    }\n-\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-        buflen = MAX_BUFFER_LEN;\n-    } else {\n-        buflen = min(MAX_HEAP_BUFFER_LEN, len);\n-        bufP = (char *)malloc((size_t)buflen);\n-\n-        \/* if heap exhausted resort to stack buffer *\/\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            buflen = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-    while(len > 0) {\n-        int loff = 0;\n-        int chunkLen = min(buflen, len);\n-        int llen = chunkLen;\n-        (*env)->GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);\n-\n-        if ((*env)->ExceptionCheck(env)) {\n-            break;\n-        } else {\n-            while(llen > 0) {\n-                int n = NET_Send(fd, bufP + loff, llen, 0);\n-                if (n > 0) {\n-                    llen -= n;\n-                    loff += n;\n-                    continue;\n-                }\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, \"java\/net\/SocketException\", \"Write failed\");\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return;\n-            }\n-            len -= chunkLen;\n-            off += chunkLen;\n-        }\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketOutputStream.c","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.util.Properties;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * This class defines a factory for creating DatagramSocketImpls. It defaults\n- * to creating plain DatagramSocketImpls, but may create other DatagramSocketImpls\n- * by setting the impl.prefix system property.\n- *\n- * For Windows versions lower than Windows Vista a TwoStacksPlainDatagramSocketImpl\n- * is always created. This impl supports IPv6 on these platform where available.\n- *\n- * On Windows platforms greater than Vista that support a dual layer TCP\/IP stack\n- * a DualStackPlainDatagramSocketImpl is created for DatagramSockets. For MulticastSockets\n- * a TwoStacksPlainDatagramSocketImpl is always created. This is to overcome the lack\n- * of behavior defined for multicasting over a dual layer socket by the RFC.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DefaultDatagramSocketImplFactory\n-{\n-    private static final Class<?> prefixImplClass;\n-\n-    \/* java.net.preferIPv4Stack *\/\n-    private static final boolean preferIPv4Stack;\n-\n-    \/* True if exclusive binding is on for Windows *\/\n-    private static final boolean exclusiveBind;\n-\n-    static {\n-        Class<?> prefixImplClassLocal = null;\n-\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        preferIPv4Stack = Boolean.parseBoolean(\n-                props.getProperty(\"java.net.preferIPv4Stack\"));\n-\n-        String exclBindProp = props.getProperty(\"sun.net.useExclusiveBind\", \"\");\n-        exclusiveBind = (exclBindProp.isEmpty())\n-                ? true\n-                : Boolean.parseBoolean(exclBindProp);\n-\n-        \/\/ impl.prefix\n-        String prefix = null;\n-        try {\n-            prefix = props.getProperty(\"impl.prefix\");\n-            if (prefix != null)\n-                prefixImplClassLocal = Class.forName(\"java.net.\"+prefix+\"DatagramSocketImpl\");\n-        } catch (Exception e) {\n-            System.err.println(\"Can't find class: java.net.\" +\n-                                prefix +\n-                                \"DatagramSocketImpl: check impl.prefix property\");\n-        }\n-\n-        prefixImplClass = prefixImplClassLocal;\n-    }\n-\n-    \/**\n-     * Creates a new <code>DatagramSocketImpl<\/code> instance.\n-     *\n-     * @param   isMulticast true if this impl is to be used for a MutlicastSocket\n-     * @return  a new instance of <code>PlainDatagramSocketImpl<\/code>.\n-     *\/\n-    static DatagramSocketImpl createDatagramSocketImpl(boolean isMulticast)\n-        throws SocketException {\n-        if (prefixImplClass != null) {\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                Object result = prefixImplClass.newInstance();\n-                return (DatagramSocketImpl) result;\n-            } catch (Exception e) {\n-                throw new SocketException(\"can't instantiate DatagramSocketImpl\");\n-            }\n-        } else {\n-            \/\/ Always use TwoStacksPlainDatagramSocketImpl since we need\n-            \/\/ to support multicasting at DatagramSocket level\n-            return new TwoStacksPlainDatagramSocketImpl(exclusiveBind && !isMulticast, isMulticast);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DefaultDatagramSocketImplFactory.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,324 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/**\n- * This class defines the plain DatagramSocketImpl that is used on\n- * Windows platforms greater than or equal to Windows Vista. These\n- * platforms have a dual layer TCP\/IP stack and can handle both IPv4\n- * and IPV6 through a single file descriptor.\n- * <p>\n- * Note: Multicasting on a dual layer TCP\/IP stack is always done with\n- * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack\n- * of behavior defined for multicasting over a dual layer socket by the RFC.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DualStackPlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    static JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    static {\n-        initIDs();\n-    }\n-\n-    \/\/ true if this socket is exclusively bound\n-    private final boolean exclusiveBind;\n-\n-    \/*\n-     * Set to true if SO_REUSEADDR is set after the socket is bound to\n-     * indicate SO_REUSEADDR is being emulated\n-     *\/\n-    private boolean reuseAddressEmulated;\n-\n-    \/\/ emulates SO_REUSEADDR when exclusiveBind is true and socket is bound\n-    private boolean isReuseAddress;\n-\n-    DualStackPlainDatagramSocketImpl(boolean exclBind) {\n-        super(false);\n-        exclusiveBind = exclBind;\n-    }\n-\n-    protected void datagramSocketCreate() throws SocketException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        int newfd = socketCreate();\n-\n-        fdAccess.set(fd, newfd);\n-    }\n-\n-    protected synchronized void bind0(int lport, InetAddress laddr)\n-        throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (laddr == null)\n-            throw new NullPointerException(\"argument address\");\n-\n-        socketBind(nativefd, laddr, lport, exclusiveBind);\n-        if (lport == 0) {\n-            localPort = socketLocalPort(nativefd);\n-        } else {\n-            localPort = lport;\n-        }\n-    }\n-\n-    protected synchronized int peek(InetAddress address) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"Null address in peek()\");\n-\n-        \/\/ Use peekData()\n-        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n-        int peekPort = peekData(peekPacket);\n-        address = peekPacket.getAddress();\n-        return peekPort;\n-    }\n-\n-    protected synchronized int peekData(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"packet\");\n-        if (p.getData() == null)\n-            throw new NullPointerException(\"packet buffer\");\n-\n-        return socketReceiveOrPeekData(nativefd, p, timeout, connected, true \/*peek*\/);\n-    }\n-\n-    protected synchronized void receive0(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"packet\");\n-        if (p.getData() == null)\n-            throw new NullPointerException(\"packet buffer\");\n-\n-        socketReceiveOrPeekData(nativefd, p, timeout, connected, false \/*receive*\/);\n-    }\n-\n-    protected void send0(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"null packet\");\n-\n-        if (p.getAddress() == null ||p.getData() ==null)\n-            throw new NullPointerException(\"null address || null buffer\");\n-\n-        socketSend(nativefd, p.getData(), p.getOffset(), p.getLength(),\n-                   p.getAddress(), p.getPort(), connected);\n-    }\n-\n-    protected void connect0(InetAddress address, int port) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"address\");\n-\n-        socketConnect(nativefd, address, port);\n-    }\n-\n-    protected void disconnect0(int family \/*unused*\/) {\n-        if (fd == null || !fd.valid())\n-            return;   \/\/ disconnect doesn't throw any exceptions\n-\n-        socketDisconnect(fdAccess.get(fd));\n-    }\n-\n-    protected void datagramSocketClose() {\n-        if (fd == null || !fd.valid())\n-            return;   \/\/ close doesn't throw any exceptions\n-\n-        socketClose(fdAccess.get(fd));\n-        fdAccess.set(fd, -1);\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    protected void socketSetOption(int opt, Object val) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        int optionValue = 0;\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        switch(opt) {\n-            case IP_TOS :\n-            case SO_RCVBUF :\n-            case SO_SNDBUF :\n-                optionValue = ((Integer)val).intValue();\n-                break;\n-            case SO_REUSEADDR :\n-                if (exclusiveBind && localPort != 0)  {\n-                    \/\/ socket already bound, emulate SO_REUSEADDR\n-                    reuseAddressEmulated = true;\n-                    isReuseAddress = (Boolean)val;\n-                    return;\n-                }\n-                \/\/Intentional fallthrough\n-            case SO_BROADCAST :\n-                optionValue = ((Boolean)val).booleanValue() ? 1 : 0;\n-                break;\n-            default: \/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        socketSetIntOption(nativefd, opt, optionValue);\n-    }\n-\n-    protected Object socketGetOption(int opt) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-         \/\/ SO_BINDADDR is not a socket option.\n-        if (opt == SO_BINDADDR) {\n-            return socketLocalAddress(nativefd);\n-        }\n-        if (opt == SO_REUSEADDR && reuseAddressEmulated)\n-            return isReuseAddress;\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT)\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-\n-        int value = socketGetIntOption(nativefd, opt);\n-        Object returnValue = null;\n-\n-        switch (opt) {\n-            case SO_REUSEADDR :\n-            case SO_BROADCAST :\n-                returnValue =  (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n-                break;\n-            case IP_TOS :\n-            case SO_RCVBUF :\n-            case SO_SNDBUF :\n-                returnValue = Integer.valueOf(value);\n-                break;\n-            default: \/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        return returnValue;\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_BROADCAST);\n-        options.add(StandardSocketOptions.IP_TOS);\n-\n-        options.addAll(ExtendedSocketOptions.datagramSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    \/* Multicast specific methods.\n-     * Multicasting on a dual layer TCP\/IP stack is always done with\n-     * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack\n-     * of behavior defined for multicasting over a dual layer socket by the RFC.\n-     *\/\n-    protected void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected void setTimeToLive(int ttl) throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected int getTimeToLive() throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    @Deprecated\n-    protected void setTTL(byte ttl) throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    @Deprecated\n-    protected byte getTTL() throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-    \/* END Multicast specific methods *\/\n-\n-    private int checkAndReturnNativeFD() throws SocketException {\n-        if (fd == null || !fd.valid())\n-            throw new SocketException(\"Socket closed\");\n-\n-        return fdAccess.get(fd);\n-    }\n-\n-    \/* Native methods *\/\n-\n-    private static native void initIDs();\n-\n-    private static native int socketCreate();\n-\n-    private static native void socketBind(int fd, InetAddress localAddress,\n-            int localport, boolean exclBind) throws SocketException;\n-\n-    private static native void socketConnect(int fd, InetAddress address, int port)\n-        throws SocketException;\n-\n-    private static native void socketDisconnect(int fd);\n-\n-    private static native void socketClose(int fd);\n-\n-    private static native int socketLocalPort(int fd) throws SocketException;\n-\n-    private static native Object socketLocalAddress(int fd) throws SocketException;\n-\n-    private static native int socketReceiveOrPeekData(int fd, DatagramPacket packet,\n-        int timeout, boolean connected, boolean peek) throws IOException;\n-\n-    private static native void socketSend(int fd, byte[] data, int offset, int length,\n-        InetAddress address, int port, boolean connected) throws IOException;\n-\n-    private static native void socketSetIntOption(int fd, int cmd,\n-        int optionValue) throws SocketException;\n-\n-    private static native int socketGetIntOption(int fd, int cmd) throws SocketException;\n-\n-    native int dataAvailable();\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DualStackPlainDatagramSocketImpl.java","additions":0,"deletions":324,"binary":false,"changes":324,"status":"deleted"},{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-import java.security.AccessController;\n-\n-import sun.security.action.GetPropertyAction;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-\n-\/**\n- * On Windows system we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainSocketImpl extends AbstractPlainSocketImpl {\n-\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-        SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final boolean preferIPv4Stack =\n-            Boolean.parseBoolean(AccessController.doPrivileged(\n-                new GetPropertyAction(\"java.net.preferIPv4Stack\", \"false\")));\n-\n-    \/**\n-     * Empty value of sun.net.useExclusiveBind is treated as 'true'.\n-     *\/\n-    private static final boolean useExclusiveBind;\n-\n-    static {\n-        @SuppressWarnings(\"removal\")\n-        String exclBindProp = AccessController.doPrivileged(\n-                new GetPropertyAction(\"sun.net.useExclusiveBind\", \"\"));\n-        useExclusiveBind = exclBindProp.isEmpty()\n-                || Boolean.parseBoolean(exclBindProp);\n-    }\n-\n-    \/\/ emulates SO_REUSEADDR when useExclusiveBind is true\n-    private boolean isReuseAddress;\n-\n-    \/**\n-     * Constructs an empty instance.\n-     *\/\n-    PlainSocketImpl(boolean isServer) {\n-        super(isServer);\n-    }\n-\n-    @Override\n-    void socketCreate(boolean stream) throws IOException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        int newfd = socket0(stream);\n-\n-        fdAccess.set(fd, newfd);\n-    }\n-\n-    @Override\n-    void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"inet address argument is null.\");\n-\n-        if (preferIPv4Stack && !(address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-\n-        int connectResult;\n-        if (timeout <= 0) {\n-            connectResult = connect0(nativefd, address, port);\n-        } else {\n-            configureBlocking(nativefd, false);\n-            try {\n-                connectResult = connect0(nativefd, address, port);\n-                if (connectResult == WOULDBLOCK) {\n-                    waitForConnect(nativefd, timeout);\n-                }\n-            } finally {\n-                configureBlocking(nativefd, true);\n-            }\n-        }\n-        \/*\n-         * We need to set the local port field. If bind was called\n-         * previous to the connect (by the client) then localport field\n-         * will already be set.\n-         *\/\n-        if (localport == 0)\n-            localport = localPort0(nativefd);\n-    }\n-\n-    @Override\n-    void socketBind(InetAddress address, int port) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"inet address argument is null.\");\n-\n-        if (preferIPv4Stack && !(address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-\n-        bind0(nativefd, address, port, useExclusiveBind);\n-        if (port == 0) {\n-            localport = localPort0(nativefd);\n-        } else {\n-            localport = port;\n-        }\n-\n-        this.address = address;\n-    }\n-\n-    @Override\n-    void socketListen(int backlog) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        listen0(nativefd, backlog);\n-    }\n-\n-    @Override\n-    void socketAccept(SocketImpl s) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (s == null)\n-            throw new NullPointerException(\"socket is null\");\n-\n-        int newfd = -1;\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n-        if (timeout <= 0) {\n-            newfd = accept0(nativefd, isaa);\n-        } else {\n-            configureBlocking(nativefd, false);\n-            try {\n-                waitForNewConnection(nativefd, timeout);\n-                newfd = accept0(nativefd, isaa);\n-                if (newfd != -1) {\n-                    configureBlocking(newfd, true);\n-                }\n-            } finally {\n-                configureBlocking(nativefd, true);\n-            }\n-        }\n-        \/* Update (SocketImpl)s' fd *\/\n-        fdAccess.set(s.fd, newfd);\n-        \/* Update socketImpls remote port, address and localport *\/\n-        InetSocketAddress isa = isaa[0];\n-        s.port = isa.getPort();\n-        s.address = isa.getAddress();\n-        s.localport = localport;\n-        if (preferIPv4Stack && !(s.address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-    }\n-\n-    @Override\n-    int socketAvailable() throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        return available0(nativefd);\n-    }\n-\n-    @Override\n-    void socketClose0(boolean useDeferredClose\/*unused*\/) throws IOException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (!fd.valid())\n-            return;\n-\n-        final int nativefd = fdAccess.get(fd);\n-        fdAccess.set(fd, -1);\n-        close0(nativefd);\n-    }\n-\n-    @Override\n-    void socketShutdown(int howto) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        shutdown0(nativefd, howto);\n-    }\n-\n-    \/\/ Intentional fallthrough after SO_REUSEADDR\n-    @SuppressWarnings(\"fallthrough\")\n-    @Override\n-    void socketSetOption(int opt, boolean on, Object value)\n-        throws SocketException {\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (opt == SO_TIMEOUT) {\n-            if (preferIPv4Stack) {\n-                \/\/ Don't enable the socket option on ServerSocket as it's\n-                \/\/ meaningless (we don't receive on a ServerSocket).\n-                if (!isServer) {\n-                    setSoTimeout0(nativefd, ((Integer)value).intValue());\n-                }\n-            } \/\/ else timeout is implemented through select.\n-            return;\n-        }\n-\n-        int optionValue = 0;\n-\n-        switch(opt) {\n-            case SO_REUSEADDR:\n-                if (useExclusiveBind) {\n-                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                    isReuseAddress = on;\n-                    return;\n-                }\n-                \/\/ intentional fallthrough\n-            case TCP_NODELAY:\n-            case SO_OOBINLINE:\n-            case SO_KEEPALIVE:\n-                optionValue = on ? 1 : 0;\n-                break;\n-            case SO_SNDBUF:\n-            case SO_RCVBUF:\n-            case IP_TOS:\n-                optionValue = ((Integer)value).intValue();\n-                break;\n-            case SO_LINGER:\n-                if (on) {\n-                    optionValue = ((Integer)value).intValue();\n-                } else {\n-                    optionValue = -1;\n-                }\n-                break;\n-            default :\/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        setIntOption(nativefd, opt, optionValue);\n-    }\n-\n-    @Override\n-    int socketGetOption(int opt, Object iaContainerObj)\n-        throws SocketException {\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        \/\/ SO_BINDADDR is not a socket option.\n-        if (opt == SO_BINDADDR) {\n-            localAddress(nativefd, (InetAddressContainer)iaContainerObj);\n-            return 0;  \/\/ return value doesn't matter.\n-        }\n-\n-        \/\/ SO_REUSEADDR emulated when using exclusive bind\n-        if (opt == SO_REUSEADDR && useExclusiveBind)\n-            return isReuseAddress ? 1 : -1;\n-\n-        int value = getIntOption(nativefd, opt);\n-\n-        switch (opt) {\n-            case TCP_NODELAY:\n-            case SO_OOBINLINE:\n-            case SO_KEEPALIVE:\n-            case SO_REUSEADDR:\n-                return (value == 0) ? -1 : 1;\n-        }\n-        return value;\n-    }\n-\n-    @Override\n-    void socketSendUrgentData(int data) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        sendOOB(nativefd, data);\n-    }\n-\n-    private int checkAndReturnNativeFD() throws SocketException {\n-        if (fd == null || !fd.valid())\n-            throw new SocketException(\"Socket closed\");\n-\n-        return fdAccess.get(fd);\n-    }\n-\n-    static final int WOULDBLOCK = -2;       \/\/ Nothing available (non-blocking)\n-\n-    static {\n-        initIDs();\n-    }\n-\n-    \/* Native methods *\/\n-\n-    static native void initIDs();\n-\n-    static native int socket0(boolean stream) throws IOException;\n-\n-    static native void bind0(int fd, InetAddress localAddress, int localport,\n-                             boolean exclBind)\n-        throws IOException;\n-\n-    static native int connect0(int fd, InetAddress remote, int remotePort)\n-        throws IOException;\n-\n-    static native void waitForConnect(int fd, int timeout) throws IOException;\n-\n-    static native int localPort0(int fd) throws IOException;\n-\n-    static native void localAddress(int fd, InetAddressContainer in) throws SocketException;\n-\n-    static native void listen0(int fd, int backlog) throws IOException;\n-\n-    static native int accept0(int fd, InetSocketAddress[] isaa) throws IOException;\n-\n-    static native void waitForNewConnection(int fd, int timeout) throws IOException;\n-\n-    static native int available0(int fd) throws IOException;\n-\n-    static native void close0(int fd) throws IOException;\n-\n-    static native void shutdown0(int fd, int howto) throws IOException;\n-\n-    static native void setIntOption(int fd, int cmd, int optionValue) throws SocketException;\n-\n-    static native void setSoTimeout0(int fd, int timeout) throws SocketException;\n-\n-    static native int getIntOption(int fd, int cmd) throws SocketException;\n-\n-    static native void sendOOB(int fd, int data) throws IOException;\n-\n-    static native void configureBlocking(int fd, boolean blocking) throws IOException;\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/PlainSocketImpl.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -1,238 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-import sun.net.ResourceManager;\n-\n-\/**\n- * This class defines the plain DatagramSocketImpl that is used for all\n- * Windows versions lower than Vista. It adds support for IPv6 on\n- * these platforms where available.\n- *\n- * For backward compatibility windows platforms that do not have IPv6\n- * support also use this implementation, and fd1 gets set to null\n- * during socket creation.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-final class TwoStacksPlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    \/* Used for IPv6 on Windows only *\/\n-    private FileDescriptor fd1;\n-\n-    \/*\n-     * Needed for ipv6 on windows because we need to know\n-     * if the socket was bound to ::0 or 0.0.0.0, when a caller\n-     * asks for it. In this case, both sockets are used, but we\n-     * don't know whether the caller requested ::0 or 0.0.0.0\n-     * and need to remember it here.\n-     *\/\n-    private InetAddress anyLocalBoundAddr=null;\n-\n-    private int fduse=-1; \/* saved between peek() and receive() calls *\/\n-\n-    \/* saved between successive calls to receive, if data is detected\n-     * on both sockets at same time. To ensure that one socket is not\n-     * starved, they rotate using this field\n-     *\/\n-    private int lastfd=-1;\n-\n-    static {\n-        init();\n-    }\n-\n-    \/\/ true if this socket is exclusively bound\n-    private final boolean exclusiveBind;\n-\n-    \/*\n-     * Set to true if SO_REUSEADDR is set after the socket is bound to\n-     * indicate SO_REUSEADDR is being emulated\n-     *\/\n-    private boolean reuseAddressEmulated;\n-\n-    \/\/ emulates SO_REUSEADDR when exclusiveBind is true and socket is bound\n-    private boolean isReuseAddress;\n-\n-    TwoStacksPlainDatagramSocketImpl(boolean exclBind, boolean isMulticast) {\n-        super(isMulticast);\n-        exclusiveBind = exclBind;\n-    }\n-\n-    protected synchronized void create() throws SocketException {\n-        fd1 = new FileDescriptor();\n-        try {\n-            super.create();\n-            \/\/ make SocketCleanable treat fd1 as a stream socket\n-            \/\/ to avoid touching the counter in ResourceManager\n-            SocketCleanable.register(fd1, true);\n-        } catch (SocketException e) {\n-            fd1 = null;\n-            throw e;\n-        }\n-    }\n-\n-    protected synchronized void bind(int lport, InetAddress laddr)\n-        throws SocketException {\n-        super.bind(lport, laddr);\n-        if (laddr.isAnyLocalAddress()) {\n-            anyLocalBoundAddr = laddr;\n-        }\n-    }\n-\n-    @Override\n-    protected synchronized void bind0(int lport, InetAddress laddr)\n-        throws SocketException\n-    {\n-        \/\/ The native bind0 may close one or both of the underlying file\n-        \/\/ descriptors, and even create new sockets, so the safest course of\n-        \/\/ action is to unregister the socket cleaners, and register afterwards.\n-        SocketCleanable.unregister(fd);\n-        SocketCleanable.unregister(fd1);\n-\n-        bind0(lport, laddr, exclusiveBind);\n-\n-        SocketCleanable.register(fd, false);\n-        \/\/ make SocketCleanable treat fd1 as a stream socket\n-        \/\/ to avoid touching the counter in ResourceManager\n-        SocketCleanable.register(fd1, true);\n-    }\n-\n-    protected synchronized void receive(DatagramPacket p)\n-        throws IOException {\n-        try {\n-            receive0(p);\n-        } finally {\n-            fduse = -1;\n-        }\n-    }\n-\n-    public Object getOption(int optID) throws SocketException {\n-        if (isClosed()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-\n-        if (optID == SO_BINDADDR) {\n-            if ((fd != null && fd1 != null) && !connected) {\n-                return anyLocalBoundAddr;\n-            }\n-            int family = connectedAddress == null ? -1 : connectedAddress.holder().getFamily();\n-            return socketLocalAddress(family);\n-        } else if (optID == SO_REUSEADDR && reuseAddressEmulated) {\n-            return isReuseAddress;\n-        } else if (optID == SO_REUSEPORT) {\n-            \/\/ SO_REUSEPORT is not supported on Windows.\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        } else {\n-            return super.getOption(optID);\n-        }\n-    }\n-\n-    protected void socketSetOption(int opt, Object val)\n-        throws SocketException\n-    {\n-        if (opt == SO_REUSEADDR && exclusiveBind && localPort != 0)  {\n-            \/\/ socket already bound, emulate\n-            reuseAddressEmulated = true;\n-            isReuseAddress = (Boolean)val;\n-        } else if (opt == SO_REUSEPORT) {\n-            \/\/ SO_REUSEPORT is not supported on Windows.\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        } else {\n-            socketNativeSetOption(opt, val);\n-        }\n-\n-    }\n-\n-    protected boolean isClosed() {\n-        return (fd == null && fd1 == null) ? true : false;\n-    }\n-\n-    protected void close() {\n-        if (fd != null || fd1 != null) {\n-            SocketCleanable.unregister(fd);\n-            SocketCleanable.unregister(fd1);\n-            datagramSocketClose();\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-            fd1 = null;\n-        }\n-    }\n-\n-    \/* Native methods *\/\n-\n-    protected synchronized native void bind0(int lport, InetAddress laddr,\n-                                             boolean exclBind)\n-        throws SocketException;\n-\n-    protected native void send0(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native int peek(InetAddress i) throws IOException;\n-\n-    protected synchronized native int peekData(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    protected native void setTimeToLive(int ttl) throws IOException;\n-\n-    protected native int getTimeToLive() throws IOException;\n-\n-    @Deprecated\n-    protected native void setTTL(byte ttl) throws IOException;\n-\n-    @Deprecated\n-    protected native byte getTTL() throws IOException;\n-\n-    protected native void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void datagramSocketCreate() throws SocketException;\n-\n-    protected native void datagramSocketClose();\n-\n-    protected native void socketNativeSetOption(int opt, Object val)\n-        throws SocketException;\n-\n-    protected native Object socketGetOption(int opt) throws SocketException;\n-\n-    protected native void connect0(InetAddress address, int port) throws SocketException;\n-\n-    protected native Object socketLocalAddress(int family) throws SocketException;\n-\n-    protected native void disconnect0(int family);\n-\n-    native int dataAvailable();\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/TwoStacksPlainDatagramSocketImpl.java","additions":0,"deletions":238,"binary":false,"changes":238,"status":"deleted"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Objects;\n@@ -142,2 +143,1 @@\n-        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))\n-           throw new IndexOutOfBoundsException();\n+        Objects.checkFromIndexSize(offset, length, srcs.length);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -123,2 +124,1 @@\n-        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))\n-           throw new IndexOutOfBoundsException();\n+        Objects.checkFromIndexSize(offset, length, dsts.length);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,539 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-\n-#include \"java_net_DualStackPlainDatagramSocketImpl.h\"\n-\n-\/*\n- * This function \"purges\" all outstanding ICMP port unreachable packets\n- * outstanding on a socket and returns JNI_TRUE if any ICMP messages\n- * have been purged. The rational for purging is to emulate normal BSD\n- * behaviour whereby receiving a \"connection reset\" status resets the\n- * socket.\n- *\/\n-static jboolean purgeOutstandingICMP(JNIEnv *env, jint fd)\n-{\n-    jboolean got_icmp = JNI_FALSE;\n-    char buf[1];\n-    fd_set tbl;\n-    struct timeval t = { 0, 0 };\n-    SOCKETADDRESS rmtaddr;\n-    int addrlen = sizeof(rmtaddr);\n-\n-    \/*\n-     * Peek at the queue to see if there is an ICMP port unreachable. If there\n-     * is then receive it.\n-     *\/\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    while(1) {\n-        if (select(\/*ignored*\/fd+1, &tbl, 0, 0, &t) <= 0) {\n-            break;\n-        }\n-        if (recvfrom(fd, buf, 1, MSG_PEEK,\n-                     &rmtaddr.sa, &addrlen) != SOCKET_ERROR) {\n-            break;\n-        }\n-        if (WSAGetLastError() != WSAECONNRESET) {\n-            \/* some other error - we don't care here *\/\n-            break;\n-        }\n-\n-        recvfrom(fd, buf, 1, 0, &rmtaddr.sa, &addrlen);\n-        got_icmp = JNI_TRUE;\n-    }\n-\n-    return got_icmp;\n-}\n-\n-static jfieldID IO_fd_fdID = NULL;\n-static jfieldID pdsi_fdID = NULL;\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    initIDs\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_initIDs\n-  (JNIEnv *env, jclass clazz)\n-{\n-    pdsi_fdID = (*env)->GetFieldID(env, clazz, \"fd\",\n-                                   \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-    JNU_CHECK_EXCEPTION(env);\n-\n-    initInetAddressIDs(env);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketCreate\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketCreate\n-  (JNIEnv *env, jclass clazz) {\n-    int fd, rv, opt=0, t=TRUE;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-\n-    fd = (int) socket(AF_INET6, SOCK_DGRAM, 0);\n-    if (fd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Socket creation failed\");\n-        return -1;\n-    }\n-\n-    rv = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &opt, sizeof(opt));\n-    if (rv == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Socket creation failed\");\n-        closesocket(fd);\n-        return -1;\n-    }\n-\n-    SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);\n-    NET_SetSockOpt(fd, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-\n-    \/* SIO_UDP_CONNRESET fixes a \"bug\" introduced in Windows 2000, which\n-     * returns connection reset errors on unconnected UDP sockets (as well\n-     * as connected sockets). The solution is to only enable this feature\n-     * when the socket is connected.\n-     *\/\n-    t = FALSE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-\n-    return fd;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketBind\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketBind\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port, jboolean exclBind) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                 &sa_len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-    rv = NET_WinBind(fd, &sa, sa_len, exclBind);\n-\n-    if (rv == SOCKET_ERROR) {\n-        if (WSAGetLastError() == WSAEACCES) {\n-            WSASetLastError(WSAEADDRINUSE);\n-        }\n-        NET_ThrowNew(env, WSAGetLastError(), \"Cannot bind\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketConnect\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketConnect\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0, t;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                   &sa_len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    rv = connect(fd, &sa.sa, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"connect\");\n-        return;\n-    }\n-\n-    \/* see comment in socketCreate *\/\n-    t = TRUE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketDisconnect\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketDisconnect\n-  (JNIEnv *env, jclass clazz, jint fd ) {\n-    SOCKETADDRESS sa;\n-    int sa_len = sizeof(sa);\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int t = FALSE;\n-\n-    memset(&sa, 0, sa_len);\n-    connect(fd, &sa.sa, sa_len);\n-\n-    \/* see comment in socketCreate *\/\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketClose\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketClose\n-  (JNIEnv *env, jclass clazz , jint fd) {\n-    NET_SocketClose(fd);\n-}\n-\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketLocalPort\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketLocalPort\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n-        return -1;\n-    }\n-    return (int) ntohs((u_short)GET_PORT(&sa));\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketLocalAddress\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketLocalAddress\n-  (JNIEnv *env , jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-    jobject iaObj;\n-    int port;\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Error getting socket name\");\n-        return NULL;\n-    }\n-\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    return iaObj;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketReceiveOrPeekData\n- * Signature: (ILjava\/net\/DatagramPacket;IZZ)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketReceiveOrPeekData\n-  (JNIEnv *env, jclass clazz, jint fd, jobject dpObj,\n-   jint timeout, jboolean connected, jboolean peek) {\n-    SOCKETADDRESS sa;\n-    int sa_len = sizeof(sa);\n-    int port, rv, flags=0;\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    jint packetBufferOffset, packetBufferLen;\n-    jbyteArray packetBuffer;\n-\n-    \/* if we are only peeking. Called from peekData *\/\n-    if (peek) {\n-        flags = MSG_PEEK;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, dpObj, dp_bufID);\n-    packetBufferOffset = (*env)->GetIntField(env, dpObj, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, dpObj, dp_bufLengthID);\n-    \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)\n-    * the max size of an IP packet. Anything bigger is truncated anyway.\n-    *\/\n-    if (packetBufferLen > MAX_PACKET_LEN) {\n-        packetBufferLen = MAX_PACKET_LEN;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return -1;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        retry = FALSE;\n-\n-        if (timeout) {\n-            if (prevTime == 0) {\n-                prevTime = JVM_CurrentTimeMillis(env, 0);\n-            }\n-            rv = NET_Timeout(fd, timeout);\n-            if (rv <= 0) {\n-                if (rv == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (rv == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-        }\n-\n-        \/* receive the packet *\/\n-        rv = recvfrom(fd, fullPacket, packetBufferLen, flags,\n-                      &sa.sa, &sa_len);\n-\n-        if (rv == SOCKET_ERROR && (WSAGetLastError() == WSAECONNRESET)) {\n-            \/* An icmp port unreachable - we must receive this as Windows\n-             * does not reset the state of the socket until this has been\n-             * received.\n-             *\/\n-            purgeOutstandingICMP(env, fd);\n-\n-            if (connected) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                \"ICMP Port Unreachable\");\n-                if (packetBufferLen > MAX_BUFFER_LEN)\n-                    free(fullPacket);\n-                return -1;\n-            } else if (timeout) {\n-                \/* Adjust timeout *\/\n-                jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                timeout -= (jint)(newTime - prevTime);\n-                if (timeout <= 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                    if (packetBufferLen > MAX_BUFFER_LEN)\n-                        free(fullPacket);\n-                    return -1;\n-                }\n-                prevTime = newTime;\n-            }\n-            retry = TRUE;\n-        }\n-    } while (retry);\n-\n-    port = (int) ntohs ((u_short) GET_PORT((SOCKETADDRESS *)&sa));\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (rv > packetBufferLen) {\n-        rv = packetBufferLen;\n-    }\n-    if (rv < 0) {\n-        if (WSAGetLastError() == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            rv = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, dpObj, dp_lengthID, 0);\n-        }\n-    }\n-\n-    if (rv == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (rv == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    } else if (rv < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-    } else {\n-        jobject packetAddress;\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so, we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, dpObj, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &sa, packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (!(*env)->ExceptionCheck(env)){\n-            if (packetAddress == NULL ) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &sa, &port);\n-                if (packetAddress != NULL) {\n-                    \/* stuff the new InetAddress into the packet *\/\n-                    (*env)->SetObjectField(env, dpObj, dp_addressID, packetAddress);\n-                }\n-            }\n-            \/* populate the packet *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, rv,\n-                                   (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, dpObj, dp_portID, port);\n-            (*env)->SetIntField(env, dpObj, dp_lengthID, rv);\n-        }\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketSend\n- * Signature: (I[BIILjava\/net\/InetAddress;IZ)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketSend\n-  (JNIEnv *env, jclass clazz, jint fd, jbyteArray data, jint offset, jint length,\n-     jobject iaObj, jint port, jboolean connected) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    struct sockaddr *sap = 0;\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-\n-    \/\/ if already connected, sap arg to sendto() is null\n-    if (!connected) {\n-        if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                      &sa_len, JNI_TRUE) != 0) {\n-            return;\n-        }\n-        sap = &sa.sa;\n-    }\n-\n-    if (length > MAX_BUFFER_LEN) {\n-        \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)\n-         * the max size of an IP packet. Anything bigger is truncated anyway.\n-         *\/\n-        if (length > MAX_PACKET_LEN) {\n-            length = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(length);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, data, offset, length,\n-                               (jbyte *)fullPacket);\n-    rv = sendto(fd, fullPacket, length, 0, sap, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        if (rv == -1) {\n-            NET_ThrowNew(env, WSAGetLastError(), \"Datagram send failed\");\n-        }\n-    }\n-\n-    if (length > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketSetIntOption\n- * Signature: (III)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_socketSetIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd, jint value)\n-{\n-    int level = 0, opt = 0;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, opt, (char *)&value, sizeof(value)) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketGetIntOption\n- * Signature: (II)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_socketGetIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd)\n-{\n-    int level = 0, opt = 0, result = 0;\n-    int result_len = sizeof(result);\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, opt, (void *)&result, &result_len) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n-        return -1;\n-    }\n-\n-    return result;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_dataAvailable\n-  (JNIEnv *env, jobject this)\n-{\n-    SOCKET fd;\n-    int  rv = -1;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (!IS_NULL(fdObj)) {\n-        int retval = 0;\n-        fd = (SOCKET)(*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        rv = ioctlsocket(fd, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    if (rv < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/DualStackPlainDatagramSocketImpl.c","additions":0,"deletions":539,"binary":false,"changes":539,"status":"deleted"},{"patch":"@@ -1,535 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-\n-#include \"java_net_PlainSocketImpl.h\"\n-#include \"java_net_SocketOptions.h\"\n-\n-#define SET_BLOCKING     0\n-#define SET_NONBLOCKING  1\n-\n-static jclass isa_class;        \/* java.net.InetSocketAddress *\/\n-static jmethodID isa_ctorID;    \/* InetSocketAddress(InetAddress, int) *\/\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    initIDs\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_initIDs\n-  (JNIEnv *env, jclass clazz) {\n-\n-    jclass cls = (*env)->FindClass(env, \"java\/net\/InetSocketAddress\");\n-    CHECK_NULL(cls);\n-    isa_class = (*env)->NewGlobalRef(env, cls);\n-    CHECK_NULL(isa_class);\n-    isa_ctorID = (*env)->GetMethodID(env, cls, \"<init>\",\n-                                     \"(Ljava\/net\/InetAddress;I)V\");\n-    CHECK_NULL(isa_ctorID);\n-    initInetAddressIDs(env);\n-\n-    \/\/ implement read timeout with select.\n-    isRcvTimeoutSupported = JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socket0\n- * Signature: (ZZ)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_socket0\n-  (JNIEnv *env, jclass clazz, jboolean stream) {\n-    int fd, rv, opt = 0;\n-    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    fd = NET_Socket(domain, type, 0);\n-\n-    if (fd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"create\");\n-        return -1;\n-    }\n-\n-    if (domain == AF_INET6) {\n-        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &opt,\n-                        sizeof(opt));\n-        if (rv == SOCKET_ERROR) {\n-            NET_ThrowNew(env, WSAGetLastError(), \"create\");\n-            closesocket(fd);\n-            return -1;\n-        }\n-    }\n-\n-    return fd;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    bind0\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_bind0\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port,\n-   jboolean exclBind)\n-{\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    jboolean v4MappedAddress = ipv6_available() ? JNI_TRUE : JNI_FALSE;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                  &sa_len, v4MappedAddress) != 0) {\n-        return;\n-    }\n-\n-    rv = NET_WinBind(fd, &sa, sa_len, exclBind);\n-\n-    if (rv == SOCKET_ERROR)\n-        NET_ThrowNew(env, WSAGetLastError(), \"NET_Bind\");\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    connect0\n- * Signature: (ILjava\/net\/InetAddress;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_connect0\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    jboolean v4MappedAddress = ipv6_available() ? JNI_TRUE : JNI_FALSE;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                  &sa_len, v4MappedAddress) != 0) {\n-        return -1;\n-    }\n-\n-    rv = connect(fd, &sa.sa, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        int err = WSAGetLastError();\n-        if (err == WSAEWOULDBLOCK) {\n-            return java_net_PlainSocketImpl_WOULDBLOCK;\n-        } else if (err == WSAEADDRNOTAVAIL) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"ConnectException\",\n-                \"connect: Address is invalid on local machine,\"\n-                \" or port is not valid on remote machine\");\n-        } else {\n-            NET_ThrowNew(env, err, \"connect\");\n-        }\n-        \/\/ return value not important.\n-    }\n-    return rv;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    waitForConnect\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_waitForConnect\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout) {\n-    int rv, retry;\n-    int optlen = sizeof(rv);\n-    fd_set wr, ex;\n-    struct timeval t;\n-\n-    FD_ZERO(&wr);\n-    FD_ZERO(&ex);\n-    FD_SET(fd, &wr);\n-    FD_SET(fd, &ex);\n-    t.tv_sec = timeout \/ 1000;\n-    t.tv_usec = (timeout % 1000) * 1000;\n-\n-    \/*\n-     * Wait for timeout, connection established or\n-     * connection failed.\n-     *\/\n-    rv = select(fd+1, 0, &wr, &ex, &t);\n-\n-    \/*\n-     * Timeout before connection is established\/failed so\n-     * we throw exception and shutdown input\/output to prevent\n-     * socket from being used.\n-     * The socket should be closed immediately by the caller.\n-     *\/\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"connect timed out\");\n-        shutdown(fd, SD_BOTH);\n-        return;\n-    }\n-\n-    \/*\n-     * Socket is writable or error occurred. On some Windows editions\n-     * the socket will appear writable when the connect fails so we\n-     * check for error rather than writable.\n-     *\/\n-    if (!FD_ISSET(fd, &ex)) {\n-        return;         \/* connection established *\/\n-    }\n-\n-    \/*\n-     * Connection failed. The logic here is designed to work around\n-     * bug on Windows NT whereby using getsockopt to obtain the\n-     * last error (SO_ERROR) indicates there is no error. The workaround\n-     * on NT is to allow winsock to be scheduled and this is done by\n-     * yielding and retrying. As yielding is problematic in heavy\n-     * load conditions we attempt up to 3 times to get the error reason.\n-     *\/\n-    for (retry = 0; retry < 3; retry++) {\n-        NET_GetSockOpt(fd, SOL_SOCKET, SO_ERROR,\n-                       (char*)&rv, &optlen);\n-        if (rv) {\n-            break;\n-        }\n-        Sleep(0);\n-    }\n-\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Unable to establish connection\");\n-    } else if (!ipv6_available() && rv == WSAEADDRNOTAVAIL) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"ConnectException\",\n-                        \"connect: Address is invalid on local machine,\"\n-                        \" or port is not valid on remote machine\");\n-    } else {\n-        NET_ThrowNew(env, rv, \"connect\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    localPort0\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_localPort0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        if (WSAGetLastError() == WSAENOTSOCK) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"Socket closed\");\n-        } else {\n-            NET_ThrowNew(env, WSAGetLastError(), \"getsockname failed\");\n-        }\n-        return -1;\n-    }\n-    return (int) ntohs((u_short)GET_PORT(&sa));\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    localAddress\n- * Signature: (ILjava\/net\/InetAddressContainer;)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_localAddress\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaContainerObj) {\n-    int port;\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-    jobject iaObj;\n-    jclass iaContainerClass;\n-    jfieldID iaFieldID;\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Error getting socket name\");\n-        return;\n-    }\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    CHECK_NULL(iaObj);\n-\n-    iaContainerClass = (*env)->GetObjectClass(env, iaContainerObj);\n-    iaFieldID = (*env)->GetFieldID(env, iaContainerClass, \"addr\", \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(iaFieldID);\n-    (*env)->SetObjectField(env, iaContainerObj, iaFieldID, iaObj);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    listen0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_listen0\n-  (JNIEnv *env, jclass clazz, jint fd, jint backlog) {\n-    if (listen(fd, backlog) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"listen failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    accept0\n- * Signature: (I[Ljava\/net\/InetSocketAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_accept0\n-  (JNIEnv *env, jclass clazz, jint fd, jobjectArray isaa) {\n-    int newfd, port = 0;\n-    jobject isa;\n-    jobject ia;\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    memset((char *)&sa, 0, len);\n-    newfd = accept(fd, &sa.sa, &len);\n-\n-    if (newfd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"accept failed\");\n-        return -1;\n-    }\n-\n-    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n-\n-    ia = NET_SockaddrToInetAddress(env, &sa, &port);\n-    if (ia == NULL){\n-        closesocket(newfd);\n-        return -1;\n-    }\n-    isa = (*env)->NewObject(env, isa_class, isa_ctorID, ia, port);\n-    if (isa == NULL) {\n-        closesocket(newfd);\n-        return -1;\n-    }\n-    (*env)->SetObjectArrayElement(env, isaa, 0, isa);\n-\n-    return newfd;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    waitForNewConnection\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_waitForNewConnection\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout) {\n-    int rv;\n-\n-    rv = NET_Timeout(fd, timeout);\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"Accept timed out\");\n-    } else if (rv == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (rv == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    available0\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_available0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    jint available = -1;\n-\n-    if ((ioctlsocket(fd, FIONREAD, &available)) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"socket available\");\n-    }\n-\n-    return available;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    close0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_close0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-     NET_SocketClose(fd);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    shutdown0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_shutdown0\n-  (JNIEnv *env, jclass clazz, jint fd, jint howto) {\n-    shutdown(fd, howto);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    setIntOption\n- * Signature: (III)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_setIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd, jint value)\n-{\n-    int level = 0, opt = 0;\n-    struct linger linger = {0, 0};\n-    char *parg;\n-    int arglen;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER) {\n-        parg = (char *)&linger;\n-        arglen = sizeof(linger);\n-        if (value >= 0) {\n-            linger.l_onoff = 1;\n-            linger.l_linger = (unsigned short)value;\n-        } else {\n-            linger.l_onoff = 0;\n-            linger.l_linger = 0;\n-        }\n-    } else {\n-        parg = (char *)&value;\n-        arglen = sizeof(value);\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, opt, parg, arglen) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    setSoTimeout0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_setSoTimeout0\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout)\n-{\n-    \/*\n-     * SO_TIMEOUT is the socket option used to specify the timeout\n-     * for ServerSocket.accept and Socket.getInputStream().read.\n-     * It does not typically map to a native level socket option.\n-     * For Windows we special-case this and use the SOL_SOCKET\/SO_RCVTIMEO\n-     * socket option to specify a receive timeout on the socket. This\n-     * receive timeout is applicable to Socket only and the socket\n-     * option should not be set on ServerSocket.\n-     *\/\n-\n-    \/*\n-     * SO_RCVTIMEO is only supported on Microsoft's implementation\n-     * of Windows Sockets so if WSAENOPROTOOPT returned then\n-     * reset flag and timeout will be implemented using\n-     * select() -- see SocketInputStream.socketRead.\n-     *\/\n-    if (isRcvTimeoutSupported) {\n-        \/*\n-         * Disable SO_RCVTIMEO if timeout is <= 5 second.\n-         *\/\n-        if (timeout <= 5000) {\n-            timeout = 0;\n-        }\n-\n-        if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,\n-            sizeof(timeout)) < 0) {\n-            int err = WSAGetLastError();\n-            if (err == WSAENOPROTOOPT) {\n-                isRcvTimeoutSupported = JNI_FALSE;\n-            } else {\n-                NET_ThrowNew(env, err, \"setsockopt SO_RCVTIMEO\");\n-            }\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    getIntOption\n- * Signature: (II)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_getIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd)\n-{\n-    int level = 0, opt = 0;\n-    int result = 0;\n-    struct linger linger = {0, 0};\n-    char *arg;\n-    int arglen;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER) {\n-        arg = (char *)&linger;\n-        arglen = sizeof(linger);\n-    } else {\n-        arg = (char *)&result;\n-        arglen = sizeof(result);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, opt, arg, &arglen) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n-        return -1;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER)\n-        return linger.l_onoff ? linger.l_linger : -1;\n-    else\n-        return result;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    sendOOB\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_sendOOB\n-  (JNIEnv *env, jclass clazz, jint fd, jint data) {\n-    jint n;\n-    unsigned char d = (unsigned char) data & 0xff;\n-\n-    n = send(fd, (char *)&data, 1, MSG_OOB);\n-    if (n == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"send\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    configureBlocking\n- * Signature: (IZ)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_configureBlocking\n-  (JNIEnv *env, jclass clazz, jint fd, jboolean blocking) {\n-    u_long arg;\n-    int result;\n-\n-    if (blocking == JNI_TRUE) {\n-        arg = SET_BLOCKING;      \/\/ 0\n-    } else {\n-        arg = SET_NONBLOCKING;   \/\/ 1\n-    }\n-\n-    result = ioctlsocket(fd, FIONBIO, &arg);\n-    if (result == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"configureBlocking\");\n-    }\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/PlainSocketImpl.c","additions":0,"deletions":535,"binary":false,"changes":535,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include \"net_util.h\"\n-#include \"java_net_SocketCleanable.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainDatagramSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_net_Sockets_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_SocketCleanable\n- * Method:    cleanupClose0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketCleanable_cleanupClose0(JNIEnv *env, jclass c1, jint fd)\n-{\n-    NET_SocketClose(fd);\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketImpl.c","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketInputStream.h\"\n-\n-\/*************************************************************************\n- * SocketInputStream\n- *\/\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketInputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    socketRead\n- * Signature: (Ljava\/io\/FileDescriptor;[BIII)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_SocketInputStream_socketRead0(JNIEnv *env, jobject this,\n-                                            jobject fdObj, jbyteArray data,\n-                                            jint off, jint len, jint timeout)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *bufP;\n-    jint fd, newfd, nread;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * If the caller buffer is large than our stack buffer then we allocate\n-     * from the heap (up to a limit). If memory is exhausted we always use\n-     * the stack buffer.\n-     *\/\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-    } else {\n-        if (len > MAX_HEAP_BUFFER_LEN) {\n-            len = MAX_HEAP_BUFFER_LEN;\n-        }\n-        bufP = (char *)malloc((size_t)len);\n-        if (bufP == NULL) {\n-            \/* allocation failed so use stack buffer *\/\n-            bufP = BUF;\n-            len = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-\n-    if (timeout) {\n-        if (timeout <= 5000 || !isRcvTimeoutSupported) {\n-            int ret = NET_Timeout (fd, timeout);\n-\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\",\n-                                    \"Read timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\", \"socket closed\");\n-                }\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return -1;\n-            }\n-\n-            \/*check if the socket has been closed while we were in timeout*\/\n-            newfd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-            if (newfd == -1) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return -1;\n-            }\n-        }\n-    }\n-\n-    nread = recv(fd, bufP, len, 0);\n-    if (nread > 0) {\n-        (*env)->SetByteArrayRegion(env, data, off, nread, (jbyte *)bufP);\n-    } else {\n-        if (nread < 0) {\n-            int err = WSAGetLastError();\n-            \/\/ Check if the socket has been closed since we last checked.\n-            \/\/ This could be a reason for recv failing.\n-            if ((*env)->GetIntField(env, fdObj, IO_fd_fdID) == -1) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            } else {\n-                switch (err) {\n-                    case WSAEINTR:\n-                        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                            \"socket closed\");\n-                        break;\n-\n-                    case WSAECONNRESET:\n-                    case WSAESHUTDOWN:\n-                        \/*\n-                         * Connection has been reset - Windows sometimes reports\n-                         * the reset as a shutdown error.\n-                         *\/\n-                        JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\",\n-                            \"\");\n-                        break;\n-\n-                    case WSAETIMEDOUT :\n-                        JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\",\n-                                       \"Read timed out\");\n-                        break;\n-\n-                    default:\n-                        NET_ThrowCurrent(env, \"recv failed\");\n-                }\n-            }\n-        }\n-    }\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-    return nread;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketInputStream.c","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOutputStream.h\"\n-\n-\/************************************************************************\n- * SocketOutputStream\n- *\/\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    socketWrite\n- * Signature: (Ljava\/io\/FileDescriptor;[BII)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,\n-                                              jobject fdObj, jbyteArray data,\n-                                              jint off, jint len) {\n-    char *bufP;\n-    char BUF[MAX_BUFFER_LEN];\n-    int buflen;\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(data)) {\n-        JNU_ThrowNullPointerException(env, \"data argument\");\n-        return;\n-    }\n-\n-    \/*\n-     * Use stack allocate buffer if possible. For large sizes we allocate\n-     * an intermediate buffer from the heap (up to a maximum). If heap is\n-     * unavailable just use our stack buffer.\n-     *\/\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-        buflen = MAX_BUFFER_LEN;\n-    } else {\n-        buflen = min(MAX_HEAP_BUFFER_LEN, len);\n-        bufP = (char *)malloc((size_t)buflen);\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            buflen = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-    while(len > 0) {\n-        int loff = 0;\n-        int chunkLen = min(buflen, len);\n-        int llen = chunkLen;\n-        int retry = 0;\n-\n-        (*env)->GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);\n-        if ((*env)->ExceptionCheck(env)) {\n-            break;\n-        } else {\n-            while(llen > 0) {\n-                int n = send(fd, bufP + loff, llen, 0);\n-                if (n > 0) {\n-                    llen -= n;\n-                    loff += n;\n-                    continue;\n-                }\n-\n-                \/*\n-                 * Due to a bug in Windows Sockets (observed on NT and Windows\n-                 * 2000) it may be necessary to retry the send. The issue is that\n-                 * on blocking sockets send\/WSASend is supposed to block if there\n-                 * is insufficient buffer space available. If there are a large\n-                 * number of threads blocked on write due to congestion then it's\n-                 * possile to hit the NT\/2000 bug whereby send returns WSAENOBUFS.\n-                 * The workaround we use is to retry the send. If we have a\n-                 * large buffer to send (>2k) then we retry with a maximum of\n-                 * 2k buffer. If we hit the issue with <=2k buffer then we backoff\n-                 * for 1 second and retry again. We repeat this up to a reasonable\n-                 * limit before bailing out and throwing an exception. In load\n-                 * conditions we've observed that the send will succeed after 2-3\n-                 * attempts but this depends on network buffers associated with\n-                 * other sockets draining.\n-                 *\/\n-                if (WSAGetLastError() == WSAENOBUFS) {\n-                    if (llen > MAX_BUFFER_LEN) {\n-                        buflen = MAX_BUFFER_LEN;\n-                        chunkLen = MAX_BUFFER_LEN;\n-                        llen = MAX_BUFFER_LEN;\n-                        continue;\n-                    }\n-                    if (retry >= 30) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"No buffer space available - exhausted attempts to queue buffer\");\n-                        if (bufP != BUF) {\n-                            free(bufP);\n-                        }\n-                        return;\n-                    }\n-                    Sleep(1000);\n-                    retry++;\n-                    continue;\n-                }\n-\n-                \/*\n-                 * Send failed - can be caused by close or write error.\n-                 *\/\n-                if (WSAGetLastError() == WSAENOTSOCK) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                } else {\n-                    NET_ThrowCurrent(env, \"socket write error\");\n-                }\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return;\n-            }\n-            len -= chunkLen;\n-            off += chunkLen;\n-        }\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketOutputStream.c","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -1,2349 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-#include \"NetworkInterface.h\"\n-\n-#include \"java_net_TwoStacksPlainDatagramSocketImpl.h\"\n-#include \"java_net_SocketOptions.h\"\n-#include \"java_net_NetworkInterface.h\"\n-#include \"java_net_InetAddress.h\"\n-\n-#ifndef IPTOS_TOS_MASK\n-#define IPTOS_TOS_MASK 0x1e\n-#endif\n-#ifndef IPTOS_PREC_MASK\n-#define IPTOS_PREC_MASK 0xe0\n-#endif\n-\n-\n-#define IN_CLASSD(i)    (((long)(i) & 0xf0000000) == 0xe0000000)\n-#define IN_MULTICAST(i) IN_CLASSD(i)\n-\n-extern int getAllInterfacesAndAddresses(JNIEnv *env, netif **netifPP);\n-\n-\/************************************************************************\n- * TwoStacksPlainDatagramSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-static jfieldID pdsi_trafficClassID;\n-jfieldID pdsi_fdID;\n-jfieldID pdsi_fd1ID;\n-jfieldID pdsi_fduseID;\n-jfieldID pdsi_lastfdID;\n-jfieldID pdsi_timeoutID;\n-\n-jfieldID pdsi_localPortID;\n-jfieldID pdsi_connected;\n-\n-static jclass ia4_clazz;\n-static jmethodID ia4_ctor;\n-\n-\/*\n- * Notes about UDP\/IPV6 on Windows (XP and 2003 server):\n- *\n- * fd always points to the IPv4 fd, and fd1 points to the IPv6 fd.\n- * Both fds are used when we bind to a wild-card address. When a specific\n- * address is used, only one of them is used.\n- *\/\n-\n-\/*\n- * Returns a java.lang.Integer based on 'i'\n- *\/\n-jobject createInteger(JNIEnv *env, int i) {\n-    static jclass i_class = NULL;\n-    static jmethodID i_ctrID;\n-    static jfieldID i_valueID;\n-\n-    if (i_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        i_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(I)V\");\n-        CHECK_NULL_RETURN(i_ctrID, NULL);\n-        i_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(i_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, i_class, i_ctrID, i);\n-}\n-\n-\/*\n- * Returns a java.lang.Boolean based on 'b'\n- *\/\n-jobject createBoolean(JNIEnv *env, int b) {\n-    static jclass b_class = NULL;\n-    static jmethodID b_ctrID;\n-    static jfieldID b_valueID;\n-\n-    if (b_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        b_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(Z)V\");\n-        CHECK_NULL_RETURN(b_ctrID, NULL);\n-        b_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(b_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, b_class, b_ctrID, (jboolean)(b!=0));\n-}\n-\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-static int getFD1(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * This function \"purges\" all outstanding ICMP port unreachable packets\n- * outstanding on a socket and returns JNI_TRUE if any ICMP messages\n- * have been purged. The rational for purging is to emulate normal BSD\n- * behaviour whereby receiving a \"connection reset\" status resets the\n- * socket.\n- *\/\n-static jboolean purgeOutstandingICMP(JNIEnv *env, jobject this, jint fd)\n-{\n-    jboolean got_icmp = JNI_FALSE;\n-    char buf[1];\n-    fd_set tbl;\n-    struct timeval t = { 0, 0 };\n-    SOCKETADDRESS rmtaddr;\n-    int addrlen = sizeof(SOCKETADDRESS);\n-\n-    memset((char *)&rmtaddr, 0, sizeof(rmtaddr));\n-\n-    \/*\n-     * Peek at the queue to see if there is an ICMP port unreachable. If there\n-     * is then receive it.\n-     *\/\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    while(1) {\n-        if (select(\/*ignored*\/fd+1, &tbl, 0, 0, &t) <= 0) {\n-            break;\n-        }\n-        if (recvfrom(fd, buf, 1, MSG_PEEK, &rmtaddr.sa, &addrlen) != SOCKET_ERROR) {\n-            break;\n-        }\n-        if (WSAGetLastError() != WSAECONNRESET) {\n-            \/* some other error - we don't care here *\/\n-            break;\n-        }\n-\n-        recvfrom(fd, buf, 1, 0, &rmtaddr.sa, &addrlen);\n-        got_icmp = JNI_TRUE;\n-    }\n-\n-    return got_icmp;\n-}\n-\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {\n-    \/* get fieldIDs *\/\n-    pdsi_fdID = (*env)->GetFieldID(env, cls, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    pdsi_fd1ID = (*env)->GetFieldID(env, cls, \"fd1\", \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fd1ID);\n-    pdsi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(pdsi_timeoutID);\n-    pdsi_fduseID = (*env)->GetFieldID(env, cls, \"fduse\", \"I\");\n-    CHECK_NULL(pdsi_fduseID);\n-    pdsi_lastfdID = (*env)->GetFieldID(env, cls, \"lastfd\", \"I\");\n-    CHECK_NULL(pdsi_lastfdID);\n-    pdsi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(pdsi_trafficClassID);\n-    pdsi_localPortID = (*env)->GetFieldID(env, cls, \"localPort\", \"I\");\n-    CHECK_NULL(pdsi_localPortID);\n-    pdsi_connected = (*env)->GetFieldID(env, cls, \"connected\", \"Z\");\n-    CHECK_NULL(pdsi_connected);\n-\n-    cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL(cls);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    ia4_clazz = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-    CHECK_NULL(ia4_clazz);\n-    ia4_clazz = (*env)->NewGlobalRef(env, ia4_clazz);\n-    CHECK_NULL(ia4_clazz);\n-    ia4_ctor = (*env)->GetMethodID(env, ia4_clazz, \"<init>\", \"()V\");\n-    CHECK_NULL(ia4_ctor);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_bind0(JNIEnv *env, jobject this,\n-                                           jint port, jobject addressObj,\n-                                           jboolean exclBind) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int ipv6_supported = ipv6_available();\n-    int fd, fd1 = -1, lcladdrlen = 0;\n-    jint family;\n-    SOCKETADDRESS lcladdr;\n-\n-    family = getInetAddress_family(env, addressObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv6 && !ipv6_supported) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol family not supported\");\n-        return;\n-    }\n-    if (IS_NULL(fdObj) || (ipv6_supported && IS_NULL(fd1Obj))) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (ipv6_supported) {\n-            fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        }\n-    }\n-\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"argument address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, addressObj, port, &lcladdr,\n-                                  &lcladdrlen, JNI_FALSE) != 0) {\n-        return;\n-    }\n-\n-    if (ipv6_supported) {\n-        struct ipv6bind v6bind;\n-        v6bind.addr = &lcladdr;\n-        v6bind.ipv4_fd = fd;\n-        v6bind.ipv6_fd = fd1;\n-        if (NET_BindV6(&v6bind, exclBind) != -1) {\n-            \/* check if the fds have changed *\/\n-            if (v6bind.ipv4_fd != fd) {\n-                fd = v6bind.ipv4_fd;\n-                if (fd == -1) {\n-                    \/* socket is closed. *\/\n-                    (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-                } else {\n-                    \/* socket was re-created *\/\n-                    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-                }\n-            }\n-            if (v6bind.ipv6_fd != fd1) {\n-                fd1 = v6bind.ipv6_fd;\n-                if (fd1 == -1) {\n-                    \/* socket is closed. *\/\n-                    (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-                } else {\n-                    \/* socket was re-created *\/\n-                    (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);\n-                }\n-            }\n-        } else {\n-            \/* NET_BindV6() closes both sockets upon a failure *\/\n-            (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-            (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-            NET_ThrowCurrent (env, \"Cannot bind\");\n-            return;\n-        }\n-    } else {\n-        if (NET_WinBind(fd, &lcladdr, lcladdrlen, exclBind) == -1) {\n-            if (WSAGetLastError() == WSAEACCES) {\n-                WSASetLastError(WSAEADDRINUSE);\n-            }\n-            (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-            NET_ThrowCurrent(env, \"Cannot bind\");\n-            closesocket(fd);\n-            return;\n-        }\n-    }\n-\n-    if (port == 0) {\n-        if (getsockname(fd == -1 ? fd1 : fd, &lcladdr.sa, &lcladdrlen) == -1) {\n-            NET_ThrowCurrent(env, \"getsockname\");\n-            return;\n-        }\n-        port = ntohs((u_short)GET_PORT(&lcladdr));\n-    }\n-    (*env)->SetIntField(env, this, pdsi_localPortID, port);\n-}\n-\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    connect0\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_connect0\n-  (JNIEnv *env, jobject this, jobject address, jint port)\n-{\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint fd = -1, fd1 = -1, fdc, family;\n-    SOCKETADDRESS rmtaddr;\n-    int rmtaddrlen = 0;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int res, t;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(address)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    family = getInetAddress_family(env, address);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv6 && !ipv6_available()) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol family not supported\");\n-        return;\n-    }\n-\n-    fdc = family == java_net_InetAddress_IPv4 ? fd : fd1;\n-\n-    \/* SIO_UDP_CONNRESET fixes a bug introduced in Windows 2000, which\n-     * returns connection reset errors on connected UDP sockets (as well\n-     * as connected sockets). The solution is to only enable this feature\n-     * when the socket is connected\n-     *\/\n-    t = TRUE;\n-    res = WSAIoctl(fdc, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-\n-    if (NET_InetAddressToSockaddr(env, address, port, &rmtaddr,\n-                                  &rmtaddrlen, JNI_FALSE) != 0) {\n-        return;\n-    }\n-\n-    if (connect(fdc, &rmtaddr.sa, rmtaddrlen) == -1) {\n-        NET_ThrowCurrent(env, \"connect\");\n-        return;\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    disconnect0\n- * Signature: ()V\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_disconnect0(JNIEnv *env, jobject this, jint family) {\n-    \/* The object's field *\/\n-    jobject fdObj;\n-    \/* The fdObj'fd *\/\n-    jint fd, len;\n-    SOCKETADDRESS addr;\n-    DWORD x1 = 0, x2 = 0; \/* ignored result codes *\/\n-    int t;\n-\n-    if (family == java_net_InetAddress_IPv4) {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-        len = sizeof(struct sockaddr_in);\n-    } else {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-        len = sizeof(struct sockaddr_in6);\n-    }\n-\n-    if (IS_NULL(fdObj)) {\n-        \/* disconnect doesn't throw any exceptions *\/\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    memset((char *)&addr, 0, len);\n-    connect(fd, &addr.sa, len);\n-\n-    \/*\n-     * use SIO_UDP_CONNRESET\n-     * to disable ICMP port unreachable handling here.\n-     *\/\n-    t = FALSE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    send0\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_send0\n-  (JNIEnv *env, jobject this, jobject packet)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj;\n-    jint fd;\n-\n-    jobject iaObj;\n-    jint family;\n-\n-    jint packetBufferOffset, packetBufferLen, packetPort;\n-    jbyteArray packetBuffer;\n-    jboolean connected;\n-\n-    SOCKETADDRESS rmtaddr;\n-    struct sockaddr *addrp = 0;\n-    int addrlen = 0;\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"null packet\");\n-        return;\n-    }\n-\n-    iaObj = (*env)->GetObjectField(env, packet, dp_addressID);\n-\n-    packetPort = (*env)->GetIntField(env, packet, dp_portID);\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBuffer = (jbyteArray)(*env)->GetObjectField(env, packet, dp_bufID);\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-\n-    if (IS_NULL(iaObj) || IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"null address || null buffer\");\n-        return;\n-    }\n-\n-    family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv4) {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    } else {\n-        if (!ipv6_available()) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol not allowed\");\n-            return;\n-        }\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    }\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_lengthID);\n-    \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)...\n-     * the maximum size of an IP packet. Anything bigger is truncated anyway.\n-     *\/\n-    if (packetBufferLen > MAX_PACKET_LEN) {\n-        packetBufferLen = MAX_PACKET_LEN;\n-    }\n-\n-    \/\/ sockaddr arg to sendto() is null if already connected\n-    if (!connected) {\n-        if (NET_InetAddressToSockaddr(env, iaObj, packetPort, &rmtaddr,\n-                                      &addrlen, JNI_FALSE) != 0) {\n-            return;\n-        }\n-        addrp = &rmtaddr.sa;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Send buf native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, packetBuffer, packetBufferOffset,\n-                               packetBufferLen, (jbyte *)fullPacket);\n-    if (sendto(fd, fullPacket, packetBufferLen, 0, addrp,\n-               addrlen) == SOCKET_ERROR)\n-    {\n-        NET_ThrowCurrent(env, \"Datagram send failed\");\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * check which socket was last serviced when there was data on both sockets.\n- * Only call this if sure that there is data on both sockets.\n- *\/\n-static int checkLastFD (JNIEnv *env, jobject this, int fd, int fd1) {\n-    int nextfd, lastfd = (*env)->GetIntField(env, this, pdsi_lastfdID);\n-    if (lastfd == -1) {\n-        \/* arbitrary. Choose fd *\/\n-        (*env)->SetIntField(env, this, pdsi_lastfdID, fd);\n-        return fd;\n-    } else {\n-        if (lastfd == fd) {\n-            nextfd = fd1;\n-        } else {\n-            nextfd = fd;\n-        }\n-        (*env)->SetIntField(env, this, pdsi_lastfdID, nextfd);\n-        return nextfd;\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    peek\n- * Signature: (Ljava\/net\/InetAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_peek(JNIEnv *env, jobject this,\n-                                           jobject addressObj) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jint fd;\n-\n-    \/* The address and family fields of addressObj *\/\n-    jint address, family;\n-\n-    int n;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    char buf[1];\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-    }\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"Null address in peek()\");\n-        return -1;\n-    } else {\n-        address = getInetAddress_addr(env, addressObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        \/* We only handle IPv4 for now. Will support IPv6 once its in the os *\/\n-        family = AF_INET;\n-    }\n-\n-    do {\n-        retry = FALSE;\n-\n-        \/*\n-         * If a timeout has been specified then we select on the socket\n-         * waiting for a read event or a timeout.\n-         *\/\n-        if (timeout) {\n-            int ret;\n-            prevTime = JVM_CurrentTimeMillis(env, 0);\n-            ret = NET_Timeout (fd, timeout);\n-            if (ret == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Peek timed out\");\n-                return ret;\n-            } else if (ret == -1) {\n-                NET_ThrowCurrent(env, \"timeout in datagram socket peek\");\n-                return ret;\n-            }\n-        }\n-\n-        \/* now try the peek *\/\n-        n = recvfrom(fd, buf, 1, MSG_PEEK, &remote_addr.sa, &remote_addrsize);\n-\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                jboolean connected;\n-\n-                \/*\n-                 * An icmp port unreachable - we must receive this as Windows\n-                 * does not reset the state of the socket until this has been\n-                 * received.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fd);\n-\n-                connected =  (*env)->GetBooleanField(env, this, pdsi_connected);\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-                    return 0;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout befor the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    if (timeout <= 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-                        return 0;\n-                    }\n-                    prevTime = newTime;\n-                }\n-\n-                \/* Need to retry the recv *\/\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    if (n == SOCKET_ERROR && WSAGetLastError() != WSAEMSGSIZE) {\n-        NET_ThrowCurrent(env, \"Datagram peek failed\");\n-        return 0;\n-    }\n-    setInetAddress_addr(env, addressObj, ntohl(remote_addr.sa4.sin_addr.s_addr));\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    setInetAddress_family(env, addressObj, java_net_InetAddress_IPv4);\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-    \/* return port *\/\n-    return ntohs(remote_addr.sa4.sin_port);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_peekData(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-     char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-\n-    int fd = -1, fd1 = -1, fduse, nsockets = 0, errorCode;\n-    int port;\n-\n-    int checkBoth = 0;\n-    int n;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-        nsockets = 1;\n-    }\n-\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        if (fd1 < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-        nsockets ++;\n-    }\n-\n-    switch (nsockets) {\n-      case 0:\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                       \"socket closed\");\n-        return -1;\n-      case 1:\n-        if (!IS_NULL(fdObj)) {\n-           fduse = fd;\n-        } else {\n-           fduse = fd1;\n-        }\n-        break;\n-      case 2:\n-        checkBoth = TRUE;\n-        break;\n-    }\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return -1;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return -1;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * read's and write's of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return -1;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        int ret;\n-        retry = FALSE;\n-\n-        \/*\n-         * If a timeout has been specified then we select on the socket\n-         * waiting for a read event or a timeout.\n-         *\/\n-        if (checkBoth) {\n-            int t = timeout == 0 ? -1: timeout;\n-            prevTime = JVM_CurrentTimeMillis(env, 0);\n-            ret = NET_Timeout2 (fd, fd1, t, &fduse);\n-            \/* all subsequent calls to recv() or select() will use the same fd\n-             * for this call to peek() *\/\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                        \"Peek timed out\");\n-                } else if (ret == -1) {\n-                    NET_ThrowCurrent(env, \"timeout in datagram socket peek\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-            if (ret == 2) {\n-                fduse = checkLastFD (env, this, fd, fd1);\n-            }\n-            checkBoth = FALSE;\n-        } else if (timeout) {\n-            if (prevTime == 0) {\n-                prevTime = JVM_CurrentTimeMillis(env, 0);\n-            }\n-            ret = NET_Timeout (fduse, timeout);\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-        }\n-\n-        \/* receive the packet *\/\n-        n = recvfrom(fduse, fullPacket, packetBufferLen, MSG_PEEK,\n-                     &remote_addr.sa, &remote_addrsize);\n-        port = (int) ntohs ((u_short) GET_PORT((SOCKETADDRESS *)&remote_addr));\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                jboolean connected;\n-\n-                \/*\n-                 * An icmp port unreachable - we must receive this as Windows\n-                 * does not reset the state of the socket until this has been\n-                 * received.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fduse);\n-\n-                connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-\n-                    if (packetBufferLen > MAX_BUFFER_LEN) {\n-                        free(fullPacket);\n-                    }\n-                    return -1;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout befor the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    if (timeout <= 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-                        if (packetBufferLen > MAX_BUFFER_LEN) {\n-                            free(fullPacket);\n-                        }\n-                        return -1;\n-                    }\n-                    prevTime = newTime;\n-                }\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n < 0) {\n-        errorCode = WSAGetLastError();\n-        \/* check to see if it's because the buffer was too small *\/\n-        if (errorCode == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            n = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        }\n-    }\n-    if (n == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else if (n == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else if (n < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else {\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &remote_addr,\n-                                               packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (packetAddress == NULL) {\n-            packetAddress = NET_SockaddrToInetAddress(env, &remote_addr,\n-                                                      &port);\n-            \/* stuff the new Inetaddress in the packet *\/\n-            (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-        }\n-\n-        \/* populate the packet *\/\n-        (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                   (jbyte *)fullPacket);\n-        (*env)->SetIntField(env, packet, dp_portID, port);\n-        (*env)->SetIntField(env, packet, dp_lengthID, n);\n-    }\n-\n-    \/* make sure receive() picks up the right fd *\/\n-    (*env)->SetIntField(env, this, pdsi_fduseID, fduse);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    receive\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_receive0(JNIEnv *env, jobject this,\n-                                              jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-    int ipv6_supported = ipv6_available();\n-\n-    \/* as a result of the changes for ipv6, peek() or peekData()\n-     * must be called prior to receive() so that fduse can be set.\n-     *\/\n-    int fd = -1, fd1 = -1, fduse, errorCode;\n-\n-    int n, nsockets=0;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    BOOL retry;\n-    jlong prevTime = 0, selectTime=0;\n-    jboolean connected;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        nsockets ++;\n-    }\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        nsockets ++;\n-    }\n-\n-    if (nsockets == 2) { \/* need to choose one of them *\/\n-        \/* was fduse set in peek? *\/\n-        fduse = (*env)->GetIntField(env, this, pdsi_fduseID);\n-        if (fduse == -1) {\n-            \/* not set in peek(), must select on both sockets *\/\n-            int ret, t = (timeout == 0) ? -1: timeout;\n-            ret = NET_Timeout2 (fd, fd1, t, &fduse);\n-            if (ret == 2) {\n-                fduse = checkLastFD (env, this, fd, fd1);\n-            } else if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                return;\n-            }\n-        }\n-    } else if (!ipv6_supported) {\n-        fduse = fd;\n-    } else if (IS_NULL(fdObj)) {\n-        \/* ipv6 supported: and this socket bound to an IPV6 only address *\/\n-        fduse = fd1;\n-    } else {\n-        \/* ipv6 supported: and this socket bound to an IPV4 only address *\/\n-        fduse = fd;\n-    }\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * read's and write's of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Receive buf native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-\n-\n-    \/*\n-     * If we are not connected then we need to know if a timeout has been\n-     * specified and if so we need to pick up the current time. These are\n-     * required in order to implement the semantics of timeout, viz :-\n-     * timeout set to t1 but ICMP port unreachable arrives in t2 where\n-     * t2 < t1. In this case we must discard the ICMP packets and then\n-     * wait for the next packet up to a maximum of t1 minus t2.\n-     *\/\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-    if (!connected && timeout && !ipv6_supported) {\n-        prevTime = JVM_CurrentTimeMillis(env, 0);\n-    }\n-\n-    if (timeout && nsockets == 1) {\n-        int ret;\n-        ret = NET_Timeout(fduse, timeout);\n-        if (ret <= 0) {\n-            if (ret == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-            } else if (ret == -1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                \"Socket closed\");\n-            }\n-            if (packetBufferLen > MAX_BUFFER_LEN) {\n-                free(fullPacket);\n-            }\n-            return;\n-        }\n-    }\n-\n-    \/*\n-     * Loop only if we discarding ICMP port unreachable packets\n-     *\/\n-    do {\n-        retry = FALSE;\n-\n-        \/* receive the packet *\/\n-        n = recvfrom(fduse, fullPacket, packetBufferLen, 0, &remote_addr.sa,\n-                     &remote_addrsize);\n-\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                \/*\n-                 * An icmp port unreachable has been received - consume any other\n-                 * outstanding packets.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fduse);\n-\n-                \/*\n-                 * If connected throw a PortUnreachableException\n-                 *\/\n-\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-\n-                    if (packetBufferLen > MAX_BUFFER_LEN) {\n-                        free(fullPacket);\n-                    }\n-\n-                    return;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout before the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    int ret;\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    prevTime = newTime;\n-\n-                    if (timeout <= 0) {\n-                        ret = 0;\n-                    } else {\n-                        ret = NET_Timeout(fduse, timeout);\n-                    }\n-\n-                    if (ret <= 0) {\n-                        if (ret == 0) {\n-                            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                            \"Receive timed out\");\n-                        } else if (ret == -1) {\n-                            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                            \"Socket closed\");\n-                        }\n-                        if (packetBufferLen > MAX_BUFFER_LEN) {\n-                            free(fullPacket);\n-                        }\n-                        return;\n-                    }\n-                }\n-\n-                \/*\n-                 * An ICMP port unreachable was received but we are\n-                 * not connected so ignore it.\n-                 *\/\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n < 0) {\n-        errorCode = WSAGetLastError();\n-        \/* check to see if it's because the buffer was too small *\/\n-        if (errorCode == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            n = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        }\n-    }\n-    if (n == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (n == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    } else if (n < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-    } else {\n-        int port = 0;\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &remote_addr,\n-                                               packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (packetAddress == NULL) {\n-            packetAddress = NET_SockaddrToInetAddress(env, &remote_addr,\n-                                                      &port);\n-            \/* stuff the new Inetaddress in the packet *\/\n-            (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-        } else {\n-            \/* only get the new port number *\/\n-            port = NET_GetPortFromSockaddr(&remote_addr);\n-        }\n-        \/* populate the packet *\/\n-        (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                   (jbyte *)fullPacket);\n-        (*env)->SetIntField(env, packet, dp_portID, port);\n-        (*env)->SetIntField(env, packet, dp_lengthID, n);\n-    }\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    datagramSocketCreate\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_datagramSocketCreate(JNIEnv *env,\n-                                                           jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-\n-    int fd, fd1;\n-    int t = TRUE;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int ipv6_supported = ipv6_available();\n-\n-    int arg = -1;\n-\n-    if (IS_NULL(fdObj) || (ipv6_supported && IS_NULL(fd1Obj))) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd =  (int) socket (AF_INET, SOCK_DGRAM, 0);\n-    }\n-    if (fd == SOCKET_ERROR) {\n-        NET_ThrowCurrent(env, \"Socket creation failed\");\n-        return;\n-    }\n-    SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-    NET_SetSockOpt(fd, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-\n-    if (ipv6_supported) {\n-        \/* SIO_UDP_CONNRESET fixes a bug introduced in Windows 2000, which\n-         * returns connection reset errors un connected UDP sockets (as well\n-         * as connected sockets. The solution is to only enable this feature\n-         * when the socket is connected\n-         *\/\n-        t = FALSE;\n-        WSAIoctl(fd,SIO_UDP_CONNRESET,&t,sizeof(t),&x1,sizeof(x1),&x2,0,0);\n-        t = TRUE;\n-        fd1 = socket (AF_INET6, SOCK_DGRAM, 0);\n-        if (fd1 == SOCKET_ERROR) {\n-            NET_ThrowCurrent(env, \"Socket creation failed\");\n-            return;\n-        }\n-        NET_SetSockOpt(fd1, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-        t = FALSE;\n-        WSAIoctl(fd1,SIO_UDP_CONNRESET,&t,sizeof(t),&x1,sizeof(x1),&x2,0,0);\n-        (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);\n-        SetHandleInformation((HANDLE)(UINT_PTR)fd1, HANDLE_FLAG_INHERIT, FALSE);\n-    } else {\n-        \/* drop the second fd *\/\n-        (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    datagramSocketClose\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_datagramSocketClose(JNIEnv *env,\n-                                                          jobject this) {\n-    \/*\n-     * REMIND: PUT A LOCK AROUND THIS CODE\n-     *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int ipv6_supported = ipv6_available();\n-    int fd = -1, fd1 = -1;\n-\n-    if (IS_NULL(fdObj) && (!ipv6_supported || IS_NULL(fd1Obj))) {\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd != -1) {\n-            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-            NET_SocketClose(fd);\n-        }\n-    }\n-\n-    if (ipv6_supported && fd1Obj != NULL) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        if (fd1 == -1) {\n-            return;\n-        }\n-        (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, -1);\n-        NET_SocketClose(fd1);\n-    }\n-}\n-\n-\/*\n- * check the addresses attached to the NetworkInterface object\n- * and return the first one (of the requested family Ipv4 or Ipv6)\n- * in *iaddr\n- *\/\n-\n-static int getInetAddrFromIf (JNIEnv *env, int family, jobject nif, jobject *iaddr)\n-{\n-    jobjectArray addrArray;\n-    static jfieldID ni_addrsID=0;\n-    jsize len;\n-    jobject addr;\n-    int i;\n-\n-    if (ni_addrsID == NULL ) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL_RETURN (c, -1);\n-        ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                        \"[Ljava\/net\/InetAddress;\");\n-        CHECK_NULL_RETURN (ni_addrsID, -1);\n-    }\n-\n-    addrArray = (*env)->GetObjectField(env, nif, ni_addrsID);\n-    len = (*env)->GetArrayLength(env, addrArray);\n-\n-    \/*\n-     * Check that there is at least one address bound to this\n-     * interface.\n-     *\/\n-    if (len < 1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-            \"bad argument for IP_MULTICAST_IF2: No IP addresses bound to interface\");\n-        return -1;\n-    }\n-    for (i=0; i<len; i++) {\n-        int fam;\n-        addr = (*env)->GetObjectArrayElement(env, addrArray, i);\n-        fam = getInetAddress_family(env, addr);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        if (fam == family) {\n-            *iaddr = addr;\n-            return 0;\n-        }\n-    }\n-    return -1;\n-}\n-\n-static int getInet4AddrFromIf (JNIEnv *env, jobject nif, struct in_addr *iaddr)\n-{\n-    jobject addr;\n-\n-    int ret = getInetAddrFromIf(env, java_net_InetAddress_IPv4, nif, &addr);\n-    if (ret == -1) {\n-        return -1;\n-    }\n-\n-    iaddr->s_addr = htonl(getInetAddress_addr(env, addr));\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    return 0;\n-}\n-\n-\/* Get the multicasting index from the interface *\/\n-\n-static int getIndexFromIf (JNIEnv *env, jobject nif) {\n-    static jfieldID ni_indexID = NULL;\n-\n-    if (ni_indexID == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL_RETURN(c, -1);\n-        ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-        CHECK_NULL_RETURN(ni_indexID, -1);\n-    }\n-\n-    return (*env)->GetIntField(env, nif, ni_indexID);\n-}\n-\n-static int isAdapterIpv6Enabled(JNIEnv *env, int index) {\n-  netif *ifList, *curr;\n-  int ipv6Enabled = 0;\n-  if (getAllInterfacesAndAddresses(env, &ifList) < 0) {\n-      return ipv6Enabled;\n-  }\n-\n-  \/* search by index *\/\n-  curr = ifList;\n-  while (curr != NULL) {\n-      if (index == curr->index) {\n-          break;\n-      }\n-      curr = curr->next;\n-  }\n-\n-  \/* if found ipv6Index != 0 then interface is configured with IPV6 *\/\n-  if ((curr != NULL) && (curr->ipv6Index !=0)) {\n-      ipv6Enabled = 1;\n-  }\n-\n-  \/* release the interface list *\/\n-  free_netif(ifList);\n-\n-  return ipv6Enabled;\n-}\n-\n-\/*\n- * Sets the multicast interface.\n- *\n- * SocketOptions.IP_MULTICAST_IF (argument is an InetAddress) :-\n- *      IPv4:   set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *\n- *      IPv6:   Get the interface to which the\n- *              InetAddress is bound\n- *              and do same as SockOptions.IF_MULTICAST_IF2\n- *\n- * SockOptions.IF_MULTICAST_IF2 (argument is a NetworkInterface ) :-\n- *      For each stack:\n- *      IPv4:   Obtain IP address bound to network interface\n- *              (NetworkInterface.addres[0])\n- *              set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *\n- *      IPv6:   Obtain NetworkInterface.index\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- *\/\n-static void setMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1,\n-                                  jint opt, jobject value)\n-{\n-    int ipv6_supported = ipv6_available();\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-        \/*\n-         * value is an InetAddress.\n-         * On IPv4 system use IP_MULTICAST_IF socket option\n-         * On IPv6 system get the NetworkInterface that this IP\n-         * address is bound to and use the IPV6_MULTICAST_IF\n-         * option instead of IP_MULTICAST_IF\n-         *\/\n-        if (ipv6_supported && fd1 >= 0) {\n-            static jclass ni_class = NULL;\n-            if (ni_class == NULL) {\n-                jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                CHECK_NULL(c);\n-                ni_class = (*env)->NewGlobalRef(env, c);\n-                CHECK_NULL(ni_class);\n-            }\n-\n-            value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);\n-            if (value == NULL) {\n-                if (!(*env)->ExceptionOccurred(env)) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                         \"bad argument for IP_MULTICAST_IF\"\n-                         \": address not bound to any interface\");\n-                }\n-                return;\n-            }\n-            opt = java_net_SocketOptions_IP_MULTICAST_IF2;\n-        } else {\n-            struct in_addr in;\n-\n-            in.s_addr = htonl(getInetAddress_addr(env, value));\n-            JNU_CHECK_EXCEPTION(env);\n-            if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                               (const char*)&in, sizeof(in)) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-            }\n-            return;\n-        }\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        \/*\n-         * value is a NetworkInterface.\n-         * On IPv6 system get the index of the interface and use the\n-         * IPV6_MULTICAST_IF socket option\n-         * On IPv4 system extract addr[0] and use the IP_MULTICAST_IF\n-         * option. For IPv6 both must be done.\n-         *\/\n-        if (ipv6_supported && fd1 >= 0) {\n-            static jfieldID ni_indexID = NULL;\n-            struct in_addr in;\n-            int index;\n-\n-            if (ni_indexID == NULL) {\n-                jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                CHECK_NULL(c);\n-                ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-                CHECK_NULL(ni_indexID);\n-            }\n-            index = (*env)->GetIntField(env, value, ni_indexID);\n-            if (isAdapterIpv6Enabled(env, index) != 0) {\n-                if (setsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (const char*)&index, sizeof(index)) < 0) {\n-                    if (errno == EINVAL && index > 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"IPV6_MULTICAST_IF failed (interface has IPv4 \"\n-                            \"address only?)\");\n-                    } else {\n-                        JNU_ThrowByNameWithMessageAndLastError\n-                            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-                    }\n-                    return;\n-                }\n-            }\n-            if (fd >= 0) {\n-                \/* If there are any IPv4 addresses on this interface then\n-                 * repeat the operation on the IPv4 fd *\/\n-\n-                if (getInet4AddrFromIf(env, value, &in) < 0) {\n-                    return;\n-                }\n-                if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                                   (const char*)&in, sizeof(in)) < 0) {\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                        (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-                }\n-            }\n-            return;\n-        } else {\n-            struct in_addr in;\n-\n-            if (getInet4AddrFromIf (env, value, &in) < 0) {\n-                if ((*env)->ExceptionOccurred(env)) {\n-                    return;\n-                }\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"no InetAddress instances of requested type\");\n-                return;\n-            }\n-\n-            if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                               (const char*)&in, sizeof(in)) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-            }\n-            return;\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketNativeSetOption\n- * Signature: (ILjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketNativeSetOption\n-  (JNIEnv *env,jobject this, jint opt,jobject value)\n-{\n-    int fd = -1, fd1 = -1;\n-    int levelv4 = 0, levelv6 = 0, optnamev4 = 0, optnamev6 = 0, optlen = 0;\n-    union {\n-        int i;\n-        char c;\n-    } optval = { 0 };\n-    int ipv6_supported = ipv6_available();\n-    fd = getFD(env, this);\n-\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        return;\n-    }\n-\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        setMulticastInterface(env, this, fd, fd1, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level(s) and option name(s).\n-     *\/\n-    if (fd1 != -1) {\n-        if (NET_MapSocketOptionV6(opt, &levelv6, &optnamev6)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return;\n-        }\n-    }\n-    if (fd != -1) {\n-        if (NET_MapSocketOption(opt, &levelv4, &optnamev4)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return;\n-        }\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                optval.i = (*env)->GetIntField(env, value, fid);\n-                optlen = sizeof(optval.i);\n-            }\n-            break;\n-\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-                jboolean on;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-                CHECK_NULL(fid);\n-\n-                on = (*env)->GetBooleanField(env, value, fid);\n-                optval.i = (on ? 1 : 0);\n-                \/*\n-                 * setLoopbackMode (true) disables IP_MULTICAST_LOOP rather\n-                 * than enabling it.\n-                 *\/\n-                if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP) {\n-                    optval.i = !optval.i;\n-                }\n-                optlen = sizeof(optval.i);\n-            }\n-            break;\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by PlainDatagramSocketImp\");\n-            return;\n-\n-    }\n-\n-    if (fd1 != -1) {\n-        if (NET_SetSockOpt(fd1, levelv6, optnamev6, (void *)&optval, optlen) < 0) {\n-            NET_ThrowCurrent(env, \"setsockopt IPv6\");\n-            return;\n-        }\n-    }\n-    if (fd != -1) {\n-        if (NET_SetSockOpt(fd, levelv4, optnamev4, (void *)&optval, optlen) < 0) {\n-            NET_ThrowCurrent(env, \"setsockopt\");\n-            return;\n-        }\n-    }\n-}\n-\n-\/*\n- *\n- * called by getMulticastInterface to retrieve a NetworkInterface\n- * configured for IPv4.\n- * The ipv4Mode parameter, is a closet boolean, which allows for a NULL return,\n- * or forces the creation of a NetworkInterface object with null data.\n- * It relates to its calling context in getMulticastInterface.\n- * ipv4Mode == 1, the context is IPV4 processing only.\n- * ipv4Mode == 0, the context is IPV6 processing\n- *\n- *\/\n-static jobject getIPv4NetworkInterface (JNIEnv *env, jobject this, int fd, jint opt, int ipv4Mode) {\n-        static jclass inet4_class;\n-        static jmethodID inet4_ctrID;\n-\n-        static jclass ni_class; static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-\n-        jobject addr;\n-        jobject ni;\n-\n-        struct in_addr in;\n-        struct in_addr *inP = &in;\n-        int len = sizeof(struct in_addr);\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                           (char *)inP, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        \/*\n-         * Construct and populate an Inet4Address\n-         *\/\n-        if (inet4_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            inet4_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(inet4_ctrID, NULL);\n-            inet4_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(inet4_class, NULL);\n-        }\n-        addr = (*env)->NewObject(env, inet4_class, inet4_ctrID, 0);\n-        CHECK_NULL_RETURN(addr, NULL);\n-\n-        setInetAddress_addr(env, addr, ntohl(in.s_addr));\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-        \/*\n-         * For IP_MULTICAST_IF return InetAddress\n-         *\/\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-\n-        \/*\n-         * For IP_MULTICAST_IF2 we get the NetworkInterface for\n-         * this address and return it\n-         *\/\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-        ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);\n-        if (ni) {\n-            return ni;\n-        }\n-        return NULL;\n-}\n-\n-\/*\n- * Return the multicast interface:\n- *\n- * SocketOptions.IP_MULTICAST_IF\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Create InetAddress\n- *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2\n- *              kernel but struct in_addr on 2.4 kernel\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF or\n- *              obtain from impl is Linux 2.2 kernel\n- *              If index == 0 return InetAddress representing\n- *              anyLocalAddress.\n- *              If index > 0 query NetworkInterface by index\n- *              and returns addrs[0]\n- *\n- * SocketOptions.IP_MULTICAST_IF2\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Query NetworkInterface by IP address and\n- *              return the NetworkInterface that the address\n- *              is bound too.\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              (except Linux .2 kernel)\n- *              Query NetworkInterface by index and\n- *              return NetworkInterface.\n- *\/\n-jobject getMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1, jint opt) {\n-    jboolean isIPV4 = !ipv6_available() || fd1 == -1;\n-\n-    \/*\n-     * IPv4 implementation\n-     *\/\n-    if (isIPV4) {\n-        jobject netObject = NULL; \/\/ return is either an addr or a netif\n-        netObject = getIPv4NetworkInterface(env, this, fd, opt, 1);\n-        return netObject;\n-    }\n-\n-    \/*\n-     * IPv6 implementation\n-     *\/\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jclass ia_class;\n-        static jmethodID ia_anyLocalAddressID;\n-\n-        int index;\n-        int len = sizeof(index);\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-\n-        {\n-            if (getsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (char*)&index, &len) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-                return NULL;\n-            }\n-        }\n-\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-\n-            ia_class = (*env)->FindClass(env, \"java\/net\/InetAddress\");\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_class = (*env)->NewGlobalRef(env, ia_class);\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_anyLocalAddressID = (*env)->GetStaticMethodID(env,\n-                                                             ia_class,\n-                                                             \"anyLocalAddress\",\n-                                                             \"()Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ia_anyLocalAddressID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-\n-        \/*\n-         * If multicast to a specific interface then return the\n-         * interface (for IF2) or the any address on that interface\n-         * (for IF).\n-         *\/\n-        if (index > 0) {\n-            ni = Java_java_net_NetworkInterface_getByIndex0(env, ni_class,\n-                                                                   index);\n-            if (ni == NULL) {\n-                char errmsg[255];\n-                sprintf(errmsg,\n-                        \"IPV6_MULTICAST_IF returned index to unrecognized interface: %d\",\n-                        index);\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-                return NULL;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF2 return the NetworkInterface\n-             *\/\n-            if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-                return ni;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF return addrs[0]\n-             *\/\n-            addrArray = (*env)->GetObjectField(env, ni, ni_addrsID);\n-            if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IPV6_MULTICAST_IF returned interface without IP bindings\");\n-                return NULL;\n-            }\n-\n-            addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-            return addr;\n-        } else if (index == 0 && fd >= 0) {\n-            \/\/ falling back to treat interface as configured for IPv4\n-            jobject netObject = NULL;\n-            netObject = getIPv4NetworkInterface(env, this, fd, opt, 0);\n-            if (netObject != NULL) {\n-                return netObject;\n-            }\n-        }\n-    }\n-    return NULL;\n-}\n-\n-\n-\/*\n- * Returns relevant info as a jint.\n- *\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketGetOption\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint opt)\n-{\n-    int fd = -1, fd1 = -1;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-    } optval = {0};\n-    int ipv6_supported = ipv6_available();\n-\n-    fd = getFD(env, this);\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Handle IP_MULTICAST_IF separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        return getMulticastInterface(env, this, fd, fd1, opt);\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return NULL;\n-    }\n-\n-    if (fd == -1) {\n-        if (NET_MapSocketOptionV6(opt, &level, &optname)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return NULL;\n-        }\n-        fd = fd1; \/* must be IPv6 only *\/\n-    }\n-\n-    optlen = sizeof(optval.i);\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        char tmpbuf[255];\n-        int size = 0;\n-        char errmsg[255 + 31];\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        sprintf(errmsg, \"error getting socket option: %s\", tmpbuf);\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-        return NULL;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            \/* getLoopbackMode() returns true if IP_MULTICAST_LOOP is disabled *\/\n-            return createBoolean(env, !optval.i);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return createInteger(env, optval.i);\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by TwoStacksPlainDatagramSocketImpl\");\n-            return NULL;\n-\n-    }\n-}\n-\n-\/*\n- * Returns local address of the socket.\n- *\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketLocalAddress\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketLocalAddress\n-  (JNIEnv *env, jobject this, jint family)\n-{\n-    int fd = -1, fd1 = -1;\n-    SOCKETADDRESS sa;\n-    int len = 0;\n-    int port;\n-    jobject iaObj;\n-    int ipv6_supported = ipv6_available();\n-\n-    fd = getFD(env, this);\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    \/* find out local IP address *\/\n-\n-    len = sizeof(struct sockaddr_in);\n-\n-    \/* family==-1 when socket is not connected *\/\n-    if ((family == java_net_InetAddress_IPv6) || (family == -1 && fd == -1)) {\n-        fd = fd1; \/* must be IPv6 only *\/\n-        len = sizeof(struct sockaddr_in6);\n-    }\n-\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    if (getsockname(fd, &sa.sa, &len) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-        return NULL;\n-    }\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-\n-    return iaObj;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    setTimeToLive\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_setTimeToLive(JNIEnv *env, jobject this,\n-                                                    jint ttl) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int fd = -1, fd1 = -1;\n-    int ittl = (int)ttl;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-      if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-      }\n-      if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-      }\n-    }\n-\n-    \/* setsockopt to be correct ttl *\/\n-    if (fd >= 0) {\n-      if (NET_SetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ittl,\n-                         sizeof (ittl)) < 0) {\n-        NET_ThrowCurrent(env, \"set IP_MULTICAST_TTL failed\");\n-        return;\n-      }\n-    }\n-\n-    if (fd1 >= 0) {\n-      if (NET_SetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *)&ittl,\n-                         sizeof(ittl)) <0) {\n-        NET_ThrowCurrent(env, \"set IPV6_MULTICAST_HOPS failed\");\n-      }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    setTTL\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_setTTL(JNIEnv *env, jobject this,\n-                                             jbyte ttl) {\n-    Java_java_net_TwoStacksPlainDatagramSocketImpl_setTimeToLive(env, this,\n-                                                        (jint)ttl & 0xFF);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    getTimeToLive\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_getTimeToLive(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int fd = -1, fd1 = -1;\n-    int ttl = 0;\n-    int len = sizeof(ttl);\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-      if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-      }\n-      if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-      }\n-    }\n-\n-    \/* getsockopt of ttl *\/\n-    if (fd >= 0) {\n-      if (NET_GetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, &len) < 0) {\n-        NET_ThrowCurrent(env, \"get IP_MULTICAST_TTL failed\");\n-        return -1;\n-      }\n-      return (jint)ttl;\n-    }\n-    if (fd1 >= 0) {\n-      if (NET_GetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char*)&ttl, &len) < 0) {\n-        NET_ThrowCurrent(env, \"get IP_MULTICAST_TTL failed\");\n-        return -1;\n-      }\n-      return (jint)ttl;\n-    }\n-    return -1;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jbyte JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_getTTL(JNIEnv *env, jobject this) {\n-    int result = Java_java_net_TwoStacksPlainDatagramSocketImpl_getTimeToLive(env, this);\n-\n-    return (jbyte)result;\n-}\n-\n-\/* join\/leave the named group on the named interface, or if no interface specified\n- * then the interface set with setInterfac(), or the default interface otherwise *\/\n-\n-static void mcast_join_leave(JNIEnv *env, jobject this,\n-                             jobject iaObj, jobject niObj,\n-                             jboolean join)\n-{\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint fd = -1, fd1 = -1;\n-\n-    SOCKETADDRESS name;\n-    struct ip_mreq mname;\n-    struct ipv6_mreq mname6;\n-\n-    struct in_addr in;\n-    DWORD ifindex = 0;\n-\n-    int len, family;\n-    int ipv6_supported = ipv6_available();\n-    int cmd;\n-\n-    memset((char *)&in, 0, sizeof(in));\n-    memset((char *)&name, 0, sizeof(name));\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (ipv6_supported && !IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, 0, &name, &len, JNI_FALSE) != 0) {\n-      return;\n-    }\n-\n-    \/* Set the multicast group address in the ip_mreq field\n-     * eventually this check should be done by the security manager\n-     *\/\n-    family = name.sa.sa_family;\n-\n-    if (family == AF_INET) {\n-        int address = name.sa4.sin_addr.s_addr;\n-        if (!IN_MULTICAST(ntohl(address))) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"not in multicast\");\n-            return;\n-        }\n-        mname.imr_multiaddr.s_addr = address;\n-        if (fd < 0) {\n-          JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Can't join an IPv4 group on an IPv6 only socket\");\n-          return;\n-        }\n-        if (IS_NULL(niObj)) {\n-            len = sizeof(in);\n-            if (NET_GetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                           (char *)&in, &len) < 0) {\n-                NET_ThrowCurrent(env, \"get IP_MULTICAST_IF failed\");\n-                return;\n-            }\n-            mname.imr_interface.s_addr = in.s_addr;\n-        } else {\n-            if (getInet4AddrFromIf (env, niObj, &mname.imr_interface) != 0) {\n-                NET_ThrowCurrent(env, \"no Inet4Address associated with interface\");\n-                return;\n-            }\n-        }\n-\n-        cmd = join ? IP_ADD_MEMBERSHIP: IP_DROP_MEMBERSHIP;\n-\n-        \/* Join the multicast group *\/\n-        if (NET_SetSockOpt(fd, IPPROTO_IP, cmd, (char *) &mname, sizeof (mname)) < 0) {\n-            if (WSAGetLastError() == WSAENOBUFS) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IP_ADD_MEMBERSHIP failed (out of hardware filters?)\");\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\"error setting options\");\n-            }\n-        }\n-    } else \/* AF_INET6 *\/ {\n-        if (ipv6_supported) {\n-            struct in6_addr *address;\n-            address = &name.sa6.sin6_addr;\n-            if (!IN6_IS_ADDR_MULTICAST(address)) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"not in6 multicast\");\n-                return;\n-            }\n-            mname6.ipv6mr_multiaddr = *address;\n-        } else {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"IPv6 not supported\");\n-            return;\n-        }\n-        if (fd1 < 0) {\n-          JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Can't join an IPv6 group on a IPv4 socket\");\n-          return;\n-        }\n-        if (IS_NULL(niObj)) {\n-            len = sizeof (ifindex);\n-            if (NET_GetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF, &ifindex, &len) < 0) {\n-                NET_ThrowCurrent(env, \"get IPV6_MULTICAST_IF failed\");\n-                return;\n-            }\n-        } else {\n-            ifindex = getIndexFromIf (env, niObj);\n-            if (ifindex == -1) {\n-                if ((*env)->ExceptionOccurred(env)) {\n-                    return;\n-                }\n-                NET_ThrowCurrent(env, \"get ifindex failed\");\n-                return;\n-            }\n-        }\n-        mname6.ipv6mr_interface = ifindex;\n-        cmd = join ? IPV6_ADD_MEMBERSHIP: IPV6_DROP_MEMBERSHIP;\n-\n-        \/* Join the multicast group *\/\n-        if (NET_SetSockOpt(fd1, IPPROTO_IPV6, cmd, (char *) &mname6, sizeof (mname6)) < 0) {\n-            if (WSAGetLastError() == WSAENOBUFS) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IP_ADD_MEMBERSHIP failed (out of hardware filters?)\");\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\"error setting options\");\n-            }\n-        }\n-    }\n-\n-    return;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    join\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_join(JNIEnv *env, jobject this,\n-                                           jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave (env, this, iaObj, niObj, JNI_TRUE);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    leave\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_leave(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave (env, this, iaObj, niObj, JNI_FALSE);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_TwoStacksPlainDatagramSocketImpl_dataAvailable\n-(JNIEnv *env, jobject this) {\n-    SOCKET fd;\n-    SOCKET fd1;\n-    int  rv = -1, rv1 = -1;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj;\n-\n-    if (!IS_NULL(fdObj)) {\n-        int retval = 0;\n-        fd = (SOCKET)(*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        rv = ioctlsocket(fd, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    if (!IS_NULL(fd1Obj)) {\n-        int retval = 0;\n-        fd1 = (SOCKET)(*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        rv1 = ioctlsocket(fd1, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    if (rv < 0 && rv1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/TwoStacksPlainDatagramSocketImpl.c","additions":0,"deletions":2349,"binary":false,"changes":2349,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,9 @@\n-    RELEASE_17;\n+    RELEASE_17,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @since 18\n+     *\/\n+    RELEASE_18;\n@@ -249,1 +257,1 @@\n-        return RELEASE_17;\n+        return RELEASE_18;\n@@ -264,1 +272,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(17, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(18, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+ * <p>Unless stated otherwise, references in this class to \"<em>this file object<\/em>\"\n+ * should be interpreted as referring indirectly to the {@link #fileObject delegate file object}.\n+ *\n@@ -48,1 +51,1 @@\n-     * The file object which all methods are delegated to.\n+     * The file object to which all methods are delegated.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingFileObject.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+ * <p>Unless stated otherwise, references in this class to \"<em>this file manager<\/em>\"\n+ * should be interpreted as referring indirectly to the {@link #fileManager delegate file manager}.\n+ *\n@@ -47,1 +50,1 @@\n-     * The file manager which all methods are delegated to.\n+     * The file manager to which all methods are delegated.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileManager.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+ * <p>Unless stated otherwise, references in this class to \"<em>this file object<\/em>\"\n+ * should be interpreted as referring indirectly to the {@link #fileObject delegate file object}.\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileObject.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -375,0 +375,3 @@\n+     * @implSpec\n+     * The default implementation throws {@link UnsupportedOperationException}.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/StandardJavaFileManager.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -59,0 +58,5 @@\n+        loadOSXLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadOSXLibrary() {\n@@ -135,0 +139,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -149,0 +154,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -163,0 +169,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -177,0 +184,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -191,0 +199,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -254,0 +263,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -281,0 +291,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -332,0 +343,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -350,0 +362,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -371,0 +384,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -394,0 +408,1 @@\n+                @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"}) \/\/ JDK implementation class\n+@SuppressWarnings(\"serial\") \/\/ JDK implementation class\n@@ -60,0 +60,5 @@\n+        loadOSXUILibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadOSXUILibrary() {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"}) \/\/ JDK implementation class\n+@SuppressWarnings(\"serial\") \/\/ JDK implementation class\n@@ -45,0 +45,5 @@\n+        loadAWTLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadAWTLibrary() {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -70,1 +69,6 @@\n-        \/\/ Need to load the native library for this code.\n+        loadAWTLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadAWTLibrary() {\n+            \/\/ Need to load the native library for this code.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -63,0 +64,1 @@\n+    private AtomicReference<Throwable> printErrorRef = new AtomicReference<>();\n@@ -326,0 +328,1 @@\n+            printErrorRef.set(null);\n@@ -384,0 +387,9 @@\n+\n+            Throwable printError = printErrorRef.getAndSet(null);\n+            if (printError != null) {\n+                if (printError instanceof PrinterException) {\n+                    throw (PrinterException) printError;\n+                }\n+                throw (PrinterException)\n+                    new PrinterException().initCause(printError);\n+            }\n@@ -789,5 +801,13 @@\n-        Runnable r = new Runnable() { public void run() { synchronized(ret) {\n-            try {\n-                int pageResult = printable.print(graphics, pageFormat, pageIndex);\n-                if (pageResult != Printable.NO_SUCH_PAGE) {\n-                    ret[0] = getPageFormatArea(pageFormat);\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                synchronized (ret) {\n+                    try {\n+                        int pageResult = printable.print(\n+                            graphics, pageFormat, pageIndex);\n+                        if (pageResult != Printable.NO_SUCH_PAGE) {\n+                            ret[0] = getPageFormatArea(pageFormat);\n+                        }\n+                    } catch (Throwable t) {\n+                        printErrorRef.compareAndSet(null, t);\n+                    }\n@@ -795,2 +815,2 @@\n-            } catch (Exception e) {} \/\/ Original code bailed on any exception\n-        }}};\n+            }\n+        };\n@@ -799,1 +819,5 @@\n-            try { EventQueue.invokeAndWait(r); } catch (Exception e) { e.printStackTrace(); }\n+            try {\n+                EventQueue.invokeAndWait(r);\n+            } catch (Throwable t) {\n+                printErrorRef.compareAndSet(null, t);\n+            }\n@@ -804,1 +828,3 @@\n-        synchronized(ret) { return ret[0]; }\n+        synchronized (ret) {\n+            return ret[0];\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -150,0 +149,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -179,6 +179,0 @@\n-        inAWT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-            @Override\n-            public Boolean run() {\n-                return !Boolean.parseBoolean(System.getProperty(\"javafx.embed.singleThread\", \"false\"));\n-            }\n-        });\n@@ -191,1 +185,9 @@\n-    private static final boolean inAWT;\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean inAWT\n+            = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        @Override\n+        public Boolean run() {\n+            return !Boolean.parseBoolean(\n+                    System.getProperty(\"javafx.embed.singleThread\", \"false\"));\n+        }\n+    });\n@@ -193,0 +195,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -251,0 +254,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -589,0 +593,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -195,2 +194,0 @@\n-    private static boolean fxAppThreadIsDispatchThread;\n-\n@@ -233,7 +230,0 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            public Object run() {\n-                fxAppThreadIsDispatchThread =\n-                        \"true\".equals(System.getProperty(\"javafx.embed.singleThread\"));\n-                return null;\n-            }\n-        });\n@@ -242,0 +232,8 @@\n+    @SuppressWarnings(\"removal\")\n+    private static boolean fxAppThreadIsDispatchThread =\n+            AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+                public Boolean run() {\n+                    return \"true\".equals(System.getProperty(\"javafx.embed.singleThread\"));\n+                }\n+            });\n+\n@@ -737,0 +735,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -738,0 +737,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -739,0 +739,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -753,0 +754,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/EventQueue.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-     * Changes this application's icon to the provided image.\n+     * Requests the system to change this application's icon to the provided {@code image}.\n@@ -343,0 +343,4 @@\n+     * @apiNote The returned icon image may not be equal\n+     * to an image set by {@link java.awt.Taskbar#setIconImage},\n+     * but should be visually similar.\n+     *\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Taskbar.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -388,1 +388,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -408,4 +407,2 @@\n-    public static final String hostEncoding;\n-\n-    static {\n-        hostEncoding =\n+    @SuppressWarnings(\"removal\")\n+    public static final String hostEncoding =\n@@ -414,1 +411,0 @@\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/DocFlavor.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"}) \/\/ Same-version serialization only\n+@SuppressWarnings(\"serial\") \/\/ Same-version serialization only\n@@ -108,0 +108,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -109,1 +110,19 @@\n-    protected static final Component component;\n+    protected static final Component component\n+            = AccessController.doPrivileged(new PrivilegedAction<Component>() {\n+        public Component run() {\n+            try {\n+                final Component component = createNoPermsComponent();\n+\n+                \/\/ 6482575 - clear the appContext field so as not to leak it\n+                AWTAccessor.getComponentAccessor().\n+                        setAppContext(component, null);\n+\n+                return component;\n+            } catch (Throwable e) {\n+                \/\/ We don't care about component.\n+                \/\/ So don't prevent class initialisation.\n+                e.printStackTrace();\n+                return null;\n+            }\n+        }\n+    });\n@@ -117,23 +136,1 @@\n-    protected static final MediaTracker tracker;\n-\n-    static {\n-        component = AccessController.doPrivileged(new PrivilegedAction<Component>() {\n-            public Component run() {\n-                try {\n-                    final Component component = createNoPermsComponent();\n-\n-                    \/\/ 6482575 - clear the appContext field so as not to leak it\n-                    AWTAccessor.getComponentAccessor().\n-                            setAppContext(component, null);\n-\n-                    return component;\n-                } catch (Throwable e) {\n-                    \/\/ We don't care about component.\n-                    \/\/ So don't prevent class initialisation.\n-                    e.printStackTrace();\n-                    return null;\n-                }\n-            }\n-        });\n-        tracker = new MediaTracker(component);\n-    }\n+    protected static final MediaTracker tracker = new MediaTracker(component);\n@@ -141,0 +138,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ImageIcon.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})\n+@SuppressWarnings(\"serial\")\n@@ -120,4 +120,3 @@\n-    static boolean popupPostionFixDisabled = false;\n-\n-    static {\n-        popupPostionFixDisabled = java.security.AccessController.doPrivileged(\n+    @SuppressWarnings(\"removal\")\n+    static boolean popupPostionFixDisabled =\n+            java.security.AccessController.doPrivileged(\n@@ -125,3 +124,1 @@\n-                \"javax.swing.adjustPopupLocationToFit\",\"\")).equals(\"false\");\n-\n-    }\n+                    \"javax.swing.adjustPopupLocationToFit\",\"\")).equals(\"false\");\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})\n+@SuppressWarnings(\"serial\")\n@@ -211,1 +211,4 @@\n-    private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING;\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING\n+            = AccessController.doPrivileged(new GetBooleanAction(\n+                                   \"swing.logDoubleBufferingDisable\"));\n@@ -217,1 +220,4 @@\n-    private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING\n+            = AccessController.doPrivileged(new GetBooleanAction(\n+                                   \"swing.ignoreDoubleBufferingDisable\"));\n@@ -329,9 +335,0 @@\n-    static {\n-        LOG_DISABLE_TRUE_DOUBLE_BUFFERING =\n-            AccessController.doPrivileged(new GetBooleanAction(\n-                                   \"swing.logDoubleBufferingDisable\"));\n-        IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING =\n-            AccessController.doPrivileged(new GetBooleanAction(\n-                                   \"swing.ignoreDoubleBufferingDisable\"));\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRootPane.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -99,6 +98,4 @@\n-    private static final boolean legacySortingFTPEnabled;\n-\n-    static {\n-        legacySortingFTPEnabled = \"true\".equals(AccessController.doPrivileged(\n-            new GetPropertyAction(\"swing.legacySortingFTPEnabled\", \"true\")));\n-    }\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean legacySortingFTPEnabled = \"true\".equals(\n+            AccessController.doPrivileged(\n+                    new GetPropertyAction(\"swing.legacySortingFTPEnabled\", \"true\")));\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SortingFocusTraversalPolicy.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -59,0 +58,2 @@\n+        initStatic();\n+    }\n@@ -60,0 +61,2 @@\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -138,0 +137,5 @@\n+        initStatic();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -69,2 +68,4 @@\n-    private static final boolean uiScaleEnabled;\n-    private static final double debugScale;\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean uiScaleEnabled\n+            = \"true\".equals(AccessController.doPrivileged(\n+            new GetPropertyAction(\"sun.java2d.uiScale.enabled\", \"true\")));\n@@ -72,5 +73,2 @@\n-    static {\n-        uiScaleEnabled = \"true\".equals(AccessController.doPrivileged(\n-                new GetPropertyAction(\"sun.java2d.uiScale.enabled\", \"true\")));\n-        debugScale = uiScaleEnabled ? getScaleFactor(\"sun.java2d.uiScale\") : -1;\n-    }\n+    private static final double debugScale =\n+            uiScaleEnabled ? getScaleFactor(\"sun.java2d.uiScale\") : -1;\n@@ -302,0 +300,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphicsEnvironment.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"}) \/\/ JDK-implementation class\n+@SuppressWarnings(\"serial\") \/\/ JDK-implementation class\n@@ -86,13 +86,0 @@\n-    \/**\n-     * {@code copyBufferEnabled}, true by default, defines the following strategy.\n-     * A duplicating (copy) buffer is created for the original pixel buffer.\n-     * The copy buffer is synchronized with the original buffer every time the\n-     * latter changes. {@code JLightweightFrame} passes the copy buffer array\n-     * to the {@link LightweightContent#imageBufferReset} method. The code spot\n-     * which synchronizes two buffers becomes the only critical section guarded\n-     * by the lock (managed with the {@link LightweightContent#paintLock()},\n-     * {@link LightweightContent#paintUnlock()} methods).\n-     *\/\n-    private static boolean copyBufferEnabled;\n-    private int[] copyBuffer;\n-\n@@ -109,2 +96,0 @@\n-        copyBufferEnabled = \"true\".equals(AccessController.\n-            doPrivileged(new GetPropertyAction(\"swing.jlf.copyBufferEnabled\", \"true\")));\n@@ -113,0 +98,15 @@\n+    \/**\n+     * {@code copyBufferEnabled}, true by default, defines the following strategy.\n+     * A duplicating (copy) buffer is created for the original pixel buffer.\n+     * The copy buffer is synchronized with the original buffer every time the\n+     * latter changes. {@code JLightweightFrame} passes the copy buffer array\n+     * to the {@link LightweightContent#imageBufferReset} method. The code spot\n+     * which synchronizes two buffers becomes the only critical section guarded\n+     * by the lock (managed with the {@link LightweightContent#paintLock()},\n+     * {@link LightweightContent#paintUnlock()} methods).\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static boolean copyBufferEnabled = \"true\".equals(AccessController.\n+            doPrivileged(new GetPropertyAction(\"swing.jlf.copyBufferEnabled\", \"true\")));\n+    private int[] copyBuffer;\n+\n@@ -117,0 +117,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -333,1 +334,1 @@\n-    @SuppressWarnings(\"serial\") \/\/ anonymous class inside\n+    @SuppressWarnings({\"removal\",\"serial\"}) \/\/ anonymous class inside\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/JLightweightFrame.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Optional;\n@@ -343,1 +344,13 @@\n-                getWMSetInsets(XAtom.get(ev.get_atom()));\n+                if (getMWMDecorTitleProperty().isPresent()) {\n+                    \/\/ Insets might have changed \"in-flight\" if that property\n+                    \/\/ is present, so we need to get the actual values of\n+                    \/\/ insets from the WM and propagate them through all the\n+                    \/\/ proper channels.\n+                    wm_set_insets = null;\n+                    Insets in = getWMSetInsets(XAtom.get(ev.get_atom()));\n+                    if (in != null && !in.equals(dimensions.getInsets())) {\n+                        handleCorrectInsets(in);\n+                    }\n+                } else {\n+                    getWMSetInsets(XAtom.get(ev.get_atom()));\n+                }\n@@ -1308,0 +1321,20 @@\n+\n+    public static final String MWM_DECOR_TITLE_PROPERTY_NAME = \"xawt.mwm_decor_title\";\n+\n+    public final Optional<Boolean> getMWMDecorTitleProperty() {\n+        Optional<Boolean> res = Optional.empty();\n+\n+        if (SunToolkit.isInstanceOf(target, \"javax.swing.RootPaneContainer\")) {\n+            javax.swing.JRootPane rootpane = ((javax.swing.RootPaneContainer) target).getRootPane();\n+            Object prop = rootpane.getClientProperty(MWM_DECOR_TITLE_PROPERTY_NAME);\n+            if (prop != null) {\n+                res = Optional.of(Boolean.parseBoolean(prop.toString()));\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    public final boolean getWindowTitleVisible() {\n+        return getMWMDecorTitleProperty().orElse(true);\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDecoratedPeer.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import sun.awt.SunToolkit;\n@@ -69,5 +70,1 @@\n-        if (winAttr.nativeDecor) {\n-            winAttr.decorations = XWindowAttributesData.AWT_DECOR_ALL;\n-        } else {\n-            winAttr.decorations = XWindowAttributesData.AWT_DECOR_NONE;\n-        }\n+        winAttr.decorations = getWindowDecorationBits();\n@@ -83,0 +80,32 @@\n+\n+        registerWindowDecorationChangeListener();\n+    }\n+\n+    private void registerWindowDecorationChangeListener() {\n+        if (SunToolkit.isInstanceOf(target, \"javax.swing.RootPaneContainer\")) { \/\/ avoid unnecessary class loading\n+            javax.swing.JRootPane rootpane = ((javax.swing.RootPaneContainer) target).getRootPane();\n+            rootpane.addPropertyChangeListener(MWM_DECOR_TITLE_PROPERTY_NAME, e -> winAttr.decorations = getWindowDecorationBits() );\n+        }\n+    }\n+\n+    private int getWindowDecorationBits() {\n+        int decorations = XWindowAttributesData.AWT_DECOR_NONE;\n+        final Frame target = (Frame)(this.target);\n+        final boolean useNativeDecor = !target.isUndecorated();\n+        if (useNativeDecor) {\n+            decorations = XWindowAttributesData.AWT_DECOR_ALL;\n+\n+            if (!getWindowTitleVisible()) {\n+                \/\/ NB: the window must be [re-]mapped to make this change effective. Also, window insets will probably\n+                \/\/ change and that'll be caught by one of the subsequent property change events in XDecoratedPeer\n+                \/\/ (not necessarily the very next event, though).\n+                decorations = XWindowAttributesData.AWT_DECOR_BORDER;\n+            }\n+\n+            if (log.isLoggable(PlatformLogger.Level.FINE)) {\n+                log.fine(\"Frame''s initial decorations affected by the client property {0}={1}\",\n+                         MWM_DECOR_TITLE_PROPERTY_NAME, getMWMDecorTitleProperty());\n+            }\n+        }\n+\n+        return decorations;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XFramePeer.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -60,0 +59,5 @@\n+        initStatic();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n@@ -298,0 +302,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -320,0 +325,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -84,0 +83,5 @@\n+        initStatic();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void initStatic() {\n@@ -286,0 +290,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -386,0 +391,1 @@\n+                @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -79,2 +78,3 @@\n-\n-    static String osname;\n+    @SuppressWarnings(\"removal\")\n+    static String osname = java.security.AccessController.doPrivileged(\n+            new sun.security.action.GetPropertyAction(\"os.name\"));\n@@ -100,0 +100,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -115,0 +116,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -129,3 +131,0 @@\n-        osname = java.security.AccessController.doPrivileged(\n-            new sun.security.action.GetPropertyAction(\"os.name\"));\n-\n@@ -138,0 +137,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -225,0 +225,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -563,0 +564,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -626,0 +628,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -635,0 +638,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -868,0 +872,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -312,1 +312,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -539,1 +538,2 @@\n-        java.security.AccessController.doPrivileged(po);\n+        @SuppressWarnings(\"removal\")\n+        var dummy = java.security.AccessController.doPrivileged(po);\n@@ -612,1 +612,2 @@\n-            java.security.AccessController.doPrivileged(spooler);\n+            @SuppressWarnings(\"removal\")\n+            var dummy2 = java.security.AccessController.doPrivileged(spooler);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintJob.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -84,1 +83,0 @@\n-    private static String encoding = \"ISO8859_1\";\n@@ -150,2 +148,2 @@\n-    static {\n-        encoding = java.security.AccessController.doPrivileged(\n+    @SuppressWarnings(\"removal\")\n+    private static String encoding = java.security.AccessController.doPrivileged(\n@@ -153,1 +151,0 @@\n-    }\n@@ -424,0 +421,1 @@\n+      @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintService.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,7 +50,4 @@\n-    private static TrueTypeFont eudcFont;\n-\n-    static {\n-\n-        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\n-                public Object run() {\n+    @SuppressWarnings(\"removal\")\n+    private static final TrueTypeFont eudcFont =\n+            AccessController.doPrivileged(new PrivilegedAction<TrueTypeFont>() {\n+                public TrueTypeFont run() {\n@@ -64,1 +60,1 @@\n-                            eudcFont = new TrueTypeFont(eudcFile, null, 0,\n+                            return new TrueTypeFont(eudcFile, null, 0,\n@@ -71,1 +67,0 @@\n-\n@@ -73,1 +68,0 @@\n-    }\n@@ -87,0 +81,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -221,0 +216,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -255,0 +251,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32FontManager.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.awt.image.MultiResolutionImage;\n@@ -1163,1 +1164,1 @@\n-                                return getShell32Icon(FOLDER_ICON_ID, size);\n+                                newIcon = getShell32Icon(FOLDER_ICON_ID, size);\n@@ -1165,1 +1166,1 @@\n-                                return getShell32Icon(FILE_ICON_ID, size);\n+                                newIcon = getShell32Icon(FILE_ICON_ID, size);\n@@ -1167,0 +1168,7 @@\n+                            if (newIcon == null) {\n+                                return null;\n+                            }\n+                            if (!(newIcon instanceof MultiResolutionImage)) {\n+                                newIcon = new MultiResolutionIconImage(size, newIcon);\n+                            }\n+                            return newIcon;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolder2.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,0 +50,5 @@\n+        loadAWTLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadAWTLibrary() {\n@@ -105,0 +109,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -205,0 +210,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -270,0 +276,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -279,0 +286,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,16 +106,0 @@\n-\/*\n- * Terminate all utf processing\n- *\/\n-static void\n-utfTerminate(void)\n-{\n-    if ( iconvFromPlatform!=(iconv_t)-1 ) {\n-        (void)iconv_close(iconvFromPlatform);\n-    }\n-    if ( iconvToPlatform!=(iconv_t)-1 ) {\n-        (void)iconv_close(iconvToPlatform);\n-    }\n-    iconvToPlatform   = (iconv_t)-1;\n-    iconvFromPlatform = (iconv_t)-1;\n-}\n-\n@@ -179,10 +163,0 @@\n-\/*\n- * Convert Platform Encoding to UTF-8.\n- *    Returns length or -1 if output overflows.\n- *\/\n-static int\n-platformToUtf8(char *str, int len, char *output, int outputMaxLen)\n-{\n-    return iconvConvert(iconvFromPlatform, str, len, output, outputMaxLen);\n-}\n-\n","filename":"src\/java.instrument\/unix\/native\/libinstrument\/EncodingSupport_md.c","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -601,0 +602,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -888,0 +890,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -923,0 +926,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1015,0 +1019,5 @@\n+        loadNativeLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadNativeLib() {\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-@SuppressWarnings({\"removal\",\"serial\"})  \/\/ serialVersionUID not constant\n+@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -122,10 +122,2 @@\n-        String form = null;\n-        boolean compat = false;\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            form = AccessController.doPrivileged(act);\n-            compat = \"1.0\".equals(form);  \/\/ form may be null\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        serialForm = form;\n+        serialForm = getForm();\n+        boolean compat = \"1.0\".equals(serialForm);  \/\/ serialForm may be null\n@@ -140,0 +132,13 @@\n+\n+    @SuppressWarnings(\"removal\")\n+    private static String getForm() {\n+        String form = null;\n+        try {\n+            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n+            return  AccessController.doPrivileged(act);\n+        } catch (Exception e) {\n+            \/\/ OK: No compat with 1.0\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -167,12 +166,1 @@\n-            \/\/ Create cleaner to expire idle connections\n-            PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    Thread t = InnocuousThread.newSystemThread(\n-                            \"LDAP PoolCleaner\",\n-                            new PoolCleaner(idleTimeout, pools));\n-                    assert t.getContextClassLoader() == null;\n-                    t.setDaemon(true);\n-                    t.start();\n-                    return null;\n-                }};\n-            AccessController.doPrivileged(pa);\n+            startCleanerThread();\n@@ -186,0 +174,16 @@\n+    @SuppressWarnings(\"removal\")\n+    private static void startCleanerThread() {\n+        \/\/ Create cleaner to expire idle connections\n+        PrivilegedAction<Void> pa = new PrivilegedAction<Void>() {\n+            public Void run() {\n+                Thread t = InnocuousThread.newSystemThread(\n+                        \"LDAP PoolCleaner\",\n+                        new PoolCleaner(idleTimeout, pools));\n+                assert t.getContextClassLoader() == null;\n+                t.setDaemon(true);\n+                t.start();\n+                return null;\n+            }};\n+        AccessController.doPrivileged(pa);\n+    }\n+\n@@ -399,0 +403,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -404,0 +409,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -409,0 +415,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapPoolManager.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-    static private final int BUFFER = 8; \/\/ added as an upper bound\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-final class HttpClientFacade extends HttpClient implements Trackable {\n+public final class HttpClientFacade extends HttpClient implements Trackable {\n@@ -113,0 +113,4 @@\n+    public Executor theExecutor() {\n+        return impl.theExecutor();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private final boolean server;\n+    private int maskingKey;\n@@ -65,0 +67,4 @@\n+        this(output, false);\n+    }\n+\n+    MessageDecoder(MessageStreamConsumer output, boolean server) {\n@@ -66,0 +72,1 @@\n+        this.server = server;\n@@ -146,1 +153,1 @@\n-        if (value) {\n+        if (value && !server) {\n@@ -149,0 +156,3 @@\n+        if (!value && server) {\n+            throw new FailWebSocketException(\"Masked frame expected\");\n+        }\n@@ -178,1 +188,3 @@\n-        throw new InternalError();\n+        if (!server)\n+            throw new InternalError();\n+        maskingKey = value;\n@@ -207,1 +219,5 @@\n-                output.onBinary(data.slice(), last);\n+                ByteBuffer slice = data.slice();\n+                if (server) {\n+                    unMask(slice);\n+                }\n+                output.onBinary(slice, last);\n@@ -211,0 +227,3 @@\n+                if (server) {\n+                    unMask(data);\n+                }\n@@ -228,0 +247,11 @@\n+    private void unMask(ByteBuffer src) {\n+        int pos = src.position();\n+        int size = src.remaining();\n+        ByteBuffer temp = ByteBuffer.allocate(size);\n+        Frame.Masker.transferMasking(src, temp, maskingKey);\n+        temp.flip();\n+        src.position(pos);\n+        src.put(temp);\n+        src.position(pos).limit(pos+size);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageDecoder.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -84,0 +84,9 @@\n+    private final boolean server;\n+\n+    MessageEncoder() {\n+        this(false);\n+    }\n+\n+    MessageEncoder(boolean isServer) {\n+        this.server = isServer;\n+    }\n@@ -372,2 +381,9 @@\n-        int mask = maskingKeySource.nextInt();\n-        headerWriter.fin(fin)\n+        \/\/ for server setting mask to 0 disables masking (xor)\n+        int mask = this.server ? 0 : maskingKeySource.nextInt();\n+        if (mask == 0) {\n+            headerWriter.fin(fin)\n+                    .opcode(opcode)\n+                    .payloadLen(payloadLen)\n+                    .write(headerBuffer);\n+        } else {\n+            headerWriter.fin(fin)\n@@ -378,0 +394,1 @@\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageEncoder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.net.http.HttpClientFacade;\n@@ -40,0 +41,1 @@\n+import java.net.http.HttpClient;\n@@ -47,0 +49,1 @@\n+import java.util.concurrent.Executor;\n@@ -118,0 +121,1 @@\n+    private final Executor clientExecutor;\n@@ -122,0 +126,1 @@\n+                                       b.getClient(),\n@@ -143,0 +148,1 @@\n+                                     HttpClient client,\n@@ -146,1 +152,1 @@\n-        WebSocketImpl ws = new WebSocketImpl(uri, subprotocol, listener, transport);\n+        WebSocketImpl ws = new WebSocketImpl(uri, client, subprotocol, listener, transport);\n@@ -154,0 +160,1 @@\n+                          HttpClient client,\n@@ -158,0 +165,1 @@\n+        this.clientExecutor = ((HttpClientFacade)client).theExecutor();\n@@ -359,1 +367,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n@@ -401,1 +409,1 @@\n-     *       x --(1)--> IDLE --(2)--> y (otherwise we're loosing events, or\n+     *       x --(1)--> IDLE --(2)--> y (otherwise we're losing events, or\n@@ -705,1 +713,1 @@\n-        receiveScheduler.runOrSchedule();\n+        receiveScheduler.runOrSchedule(clientExecutor);\n@@ -837,1 +845,1 @@\n-                receiveScheduler.runOrSchedule();\n+                receiveScheduler.runOrSchedule(clientExecutor);\n@@ -853,1 +861,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/WebSocketImpl.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -83,0 +82,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -53,0 +52,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n@@ -63,0 +67,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -114,0 +119,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -181,0 +187,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -448,0 +455,5 @@\n+        addShutdownHook();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void addShutdownHook() {\n@@ -516,0 +528,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -585,0 +598,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -632,0 +646,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -665,0 +680,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -703,0 +719,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -737,0 +754,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -786,0 +804,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,0 +50,5 @@\n+        loadPrefsLib();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadPrefsLib() {\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -95,0 +94,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -100,0 +100,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -105,0 +106,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -125,2 +127,5 @@\n-    private static final AccessControlContext SOCKET_ACC;\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static final AccessControlContext SOCKET_ACC = createSocketAcc();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static AccessControlContext createSocketAcc() {\n@@ -130,1 +135,1 @@\n-        SOCKET_ACC = new AccessControlContext(pd);\n+        return new AccessControlContext(pd);\n@@ -254,0 +259,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -493,0 +499,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -518,0 +525,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCClient.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-@SuppressWarnings({\"removal\",\"deprecation\"})\n+@SuppressWarnings(\"deprecation\")\n@@ -71,0 +71,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -76,0 +77,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -81,0 +83,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -86,0 +89,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -123,0 +127,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -318,0 +323,5 @@\n+        exportSingleton();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void exportSingleton() {\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/DGCImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-@SuppressWarnings({\"removal\",\"deprecation\"})\n+@SuppressWarnings(\"deprecation\")\n@@ -90,0 +90,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -95,0 +96,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -101,0 +103,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -111,0 +114,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -125,2 +129,5 @@\n-    private static final AccessControlContext NOPERMS_ACC;\n-    static {\n+    @SuppressWarnings(\"removal\")\n+    private static final AccessControlContext NOPERMS_ACC = createNopermsAcc();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static AccessControlContext createNopermsAcc() {\n@@ -129,1 +136,1 @@\n-        NOPERMS_ACC = new AccessControlContext(pd);\n+        return new AccessControlContext(pd);\n@@ -151,0 +158,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -301,1 +309,2 @@\n-    protected void checkAcceptPermission(AccessControlContext acc) {\n+    protected void checkAcceptPermission(@SuppressWarnings(\"removal\") AccessControlContext acc) {\n+        @SuppressWarnings(\"removal\")\n@@ -341,0 +350,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -353,0 +363,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -649,0 +660,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -651,0 +663,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -654,0 +667,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -672,0 +686,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -697,0 +712,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @LastModified: Aug 2019\n+ * @LastModified: June 2021\n@@ -1444,21 +1444,0 @@\n-\n-                    \/\/ The next is kind of a hack to keep from escaping in the case\n-                    \/\/ of Shift_JIS and the like.\n-\n-                    \/*\n-                    else if ((ch < m_maxCharacter) && (m_maxCharacter == 0xFFFF)\n-                    && (ch != 160))\n-                    {\n-                    writer.write(ch);  \/\/ no escaping in this case\n-                    }\n-                    else\n-                    *\/\n-                    String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\n-                    if (null != outputStringForChar)\n-                    {\n-                        writer.write(outputStringForChar);\n-                    }\n-                    else if (escapingNotNeeded(ch))\n-                    {\n-                        writer.write(ch); \/\/ no escaping in this case\n-                    }\n@@ -1467,3 +1446,15 @@\n-                        writer.write(\"&#\");\n-                        writer.write(Integer.toString(ch));\n-                        writer.write(';');\n+                        String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\n+                        if (null != outputStringForChar)\n+                        {\n+                            writer.write(outputStringForChar);\n+                        }\n+                        else if (escapingNotNeeded(ch))\n+                        {\n+                            writer.write(ch); \/\/ no escaping in this case\n+                        }\n+                        else\n+                        {\n+                            writer.write(\"&#\");\n+                            writer.write(Integer.toString(ch));\n+                            writer.write(';');\n+                        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToHTMLStream.java","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -51,1 +50,8 @@\n-    private static final long CURRENT_PID;\n+    private static final long CURRENT_PID = pid();\n+\n+    @SuppressWarnings(\"removal\")\n+    private static long pid() {\n+        PrivilegedAction<ProcessHandle> pa = () -> ProcessHandle.current();\n+        return AccessController.doPrivileged(pa).pid();\n+    }\n+\n@@ -54,3 +60,0 @@\n-        PrivilegedAction<ProcessHandle> pa = ProcessHandle::current;\n-        CURRENT_PID = AccessController.doPrivileged(pa).pid();\n-\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-\n@@ -198,1 +197,1 @@\n-     * tree within the provided compilation unit\n+     * tree within the provided compilation unit.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTrees.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -88,1 +89,0 @@\n-import com.sun.tools.javac.code.Type.ErrorType;\n@@ -91,1 +91,0 @@\n-import com.sun.tools.javac.code.Types.TypeRelation;\n@@ -100,1 +99,0 @@\n-import com.sun.tools.javac.code.Symbol;\n@@ -154,1 +152,0 @@\n-import static com.sun.tools.javac.code.TypeTag.*;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,1 +115,6 @@\n-    JDK17(\"17\");\n+    JDK17(\"17\"),\n+\n+    \/**\n+      * 18, tbd\n+      *\/\n+    JDK18(\"18\");\n@@ -167,0 +172,1 @@\n+        case JDK18  -> Target.JDK1_18;\n@@ -309,0 +315,1 @@\n+        case JDK18  -> RELEASE_18;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4342,1 +4342,1 @@\n-            if (sym.name == names._this) {\n+            if (sym.name == names._this || sym.name == names._super) {\n@@ -4344,1 +4344,2 @@\n-                \/\/ C.this' does not appear in a call to a super(...)\n+                \/\/ `C.this' does not appear in an explicit call to a constructor\n+                \/\/ also make sure that `super` is not used in constructor invocations\n@@ -4346,1 +4347,3 @@\n-                    site.tsym == env.enclClass.sym) {\n+                        ((sym.name == names._this &&\n+                        site.tsym == env.enclClass.sym) ||\n+                        sym.name == names._super)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                        return make.at(t.pos).SpeculativeNewClass(encl, typeargs, clazz, args, def, t.def != null);\n+                        return make.at(t.pos).SpeculativeNewClass(encl, typeargs, clazz, args, def, t.def != null || t.classDeclRemoved());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-        V61(61, 0);   \/\/ JDK 17\n+        V61(61, 0),   \/\/ JDK 17\n+        V62(62, 0);   \/\/ JDK 18\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,4 @@\n-    JDK1_17(\"17\", 61, 0);\n+    JDK1_17(\"17\", 61, 0),\n+\n+    \/** JDK 18. *\/\n+    JDK1_18(\"18\", 62, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * so by stripping the leading whitespace and comment starts from\n+ * so by stripping the leading whitespace and comment stars from\n@@ -92,1 +92,1 @@\n-         * Pattern used to detect a well formed @deprecated tag in a JaavDoc\n+         * Pattern used to detect a well formed @deprecated tag in a Javadoc\n@@ -335,1 +335,3 @@\n-         * Logical size of map (number of valid entries.)\n+         * Logical size of map.\n+         * This is the number of occupied positions in {@code map},\n+         * and equals {@code NOFFSETS} multiplied by the number of entries.\n@@ -352,1 +354,1 @@\n-         * @param posOffet  input offset member of pair.\n+         * @param posOffset  input offset member of pair.\n@@ -356,2 +358,2 @@\n-        boolean shouldAdd(int sbOffset, int posOffet) {\n-            return sbOffset - lastSBOffset() != posOffet - lastPosOffset();\n+        boolean shouldAdd(int sbOffset, int posOffset) {\n+            return sbOffset - lastSBOffset() != posOffset - lastPosOffset();\n@@ -364,1 +366,1 @@\n-         * @param posOffet  input offset member of pair.\n+         * @param posOffset  input offset member of pair.\n@@ -366,2 +368,2 @@\n-        void add(int sbOffset, int posOffet) {\n-            if (size == 0 || shouldAdd(sbOffset, posOffet)) {\n+        void add(int sbOffset, int posOffset) {\n+            if (size == 0 || shouldAdd(sbOffset, posOffset)) {\n@@ -370,1 +372,1 @@\n-                map[size + POS_OFFSET] = posOffet;\n+                map[size + POS_OFFSET] = posOffset;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreeScanner;\n@@ -196,0 +199,3 @@\n+        if (new TypeAnnotationFinder().scan(paramTypes, null) != null)\n+            throw new ParseException(\"dc.ref.annotations.not.allowed\");\n+\n@@ -198,1 +204,13 @@\n-}\n+\n+    static class TypeAnnotationFinder extends TreeScanner<Tree, Void> {\n+        @Override\n+        public Tree visitAnnotatedType(AnnotatedTypeTree t, Void ignore) {\n+            return t;\n+        }\n+\n+        @Override\n+        public Tree reduce(Tree t1, Tree t2) {\n+            return t1 != null ? t1 : t2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_17)\n+@SupportedSourceVersion(SourceVersion.RELEASE_18)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3272,0 +3272,3 @@\n+compiler.err.dc.ref.annotations.not.allowed=\\\n+    annotations not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,5 @@\n+    \/**\n+     * {@return the source position for this tree node}\n+     *\n+     * @param dc the enclosing doc comment\n+     *\/\n@@ -70,0 +75,11 @@\n+    \/**\n+     * {@return the source position for position relative to this tree node}\n+     * This is primarily useful for nodes that wrap a single string child.\n+     *\n+     * @param dc     the enclosing doc comment\n+     * @param offset the offset\n+     *\/\n+    public long getSourcePosition(DCDocComment dc, int offset) {\n+        return dc.comment.getSourcePos(pos + offset);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Objects;\n@@ -239,3 +240,1 @@\n-            if (i < 0 || i >= length) {\n-                throw new IndexOutOfBoundsException(String.valueOf(i));\n-            }\n+            Objects.checkIndex(i, length);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-    dictionaryField = type.getAddressField(\"_dictionary\");\n@@ -57,1 +56,0 @@\n-  private static AddressField dictionaryField;\n@@ -63,5 +61,0 @@\n-  public Dictionary dictionary() {\n-      Address tmp = dictionaryField.getValue();\n-      return (Dictionary) VMObjectFactory.newObject(Dictionary.class, tmp);\n-  }\n-\n@@ -117,5 +110,0 @@\n-\n-  \/** Iterate over all klasses in the dictionary, including initiating loader. *\/\n-  public void allEntriesDo(ClassLoaderDataGraph.ClassAndLoaderVisitor v) {\n-      dictionary().allEntriesDo(v, getClassLoader());\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/classfile\/ClassLoaderData.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,8 +87,0 @@\n-\n-  \/** Iterate over all klasses - including object, primitive\n-      array klasses, pass initiating loader. *\/\n-  public void allEntriesDo(ClassAndLoaderVisitor v) {\n-    for (ClassLoaderData cld = getClassLoaderGraphHead(); cld != null; cld = cld.next()) {\n-        cld.allEntriesDo(v);\n-    }\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/classfile\/ClassLoaderDataGraph.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -756,1 +756,1 @@\n-          if ((i < 0) || (i >= getNumEntries())) throw new IndexOutOfBoundsException();\n+          Objects.checkIndex(i, getNumEntries());\n@@ -812,3 +812,1 @@\n-          if (i < 0 || i >= getSizeOfData()) {\n-            throw new IndexOutOfBoundsException();\n-          }\n+          Objects.checkIndex(i, getSizeOfData());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/win32\/coff\/COFFFileParser.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    \/\/ G1MonitoringSupport* _g1mm;\n-    static private AddressField g1mmField;\n+    \/\/ G1MonitoringSupport* _monitoring_support;\n+    static private AddressField monitoringSupportField;\n@@ -78,1 +78,1 @@\n-        g1mmField = type.getAddressField(\"_g1mm\");\n+        monitoringSupportField = type.getAddressField(\"_monitoring_support\");\n@@ -102,3 +102,3 @@\n-    public G1MonitoringSupport g1mm() {\n-        Address g1mmAddr = g1mmField.getValue(addr);\n-        return (G1MonitoringSupport) VMObjectFactory.newObject(G1MonitoringSupport.class, g1mmAddr);\n+    public G1MonitoringSupport monitoringSupport() {\n+        Address monitoringSupportAddr = monitoringSupportField.getValue(addr);\n+        return (G1MonitoringSupport) VMObjectFactory.newObject(G1MonitoringSupport.class, monitoringSupportAddr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * @(#)BinaryTreeDictionary.java\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.memory;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class AFLBinaryTreeDictionary extends VMObject {\n-   static {\n-      VM.registerVMInitializedObserver(new Observer() {\n-         public void update(Observable o, Object data) {\n-            initialize(VM.getVM().getTypeDataBase());\n-         }\n-      });\n-   }\n-\n-   private static synchronized void initialize(TypeDataBase db) {\n-      Type type = db.lookupType(\"AFLBinaryTreeDictionary\");\n-      totalSizeField = type.getCIntegerField(\"_total_size\");\n-   }\n-\n-   \/\/ Fields\n-   private static CIntegerField totalSizeField;\n-\n-   \/\/ Accessors\n-   public long size() {\n-      return totalSizeField.getValue(addr);\n-   }\n-\n-   \/\/ Constructor\n-   public AFLBinaryTreeDictionary(Address addr) {\n-      super(addr);\n-   }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/AFLBinaryTreeDictionary.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.memory;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.classfile.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Dictionary extends sun.jvm.hotspot.utilities.Hashtable {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    \/\/ just checking that the type exists\n-    Type type = db.lookupType(\"Dictionary\");\n-  }\n-\n-  public Dictionary(Address addr) {\n-    super(addr);\n-  }\n-\n-  \/\/ this is overriden here so that Hashtable.bucket will return\n-  \/\/ object of DictionaryEntry.class\n-  protected Class<? extends HashtableEntry> getHashtableEntryClass() {\n-    return DictionaryEntry.class;\n-  }\n-\n-  \/** All classes, and their initiating class loader, passed in. *\/\n-  public void allEntriesDo(ClassLoaderDataGraph.ClassAndLoaderVisitor v, Oop loader) {\n-    int tblSize = tableSize();\n-    for (int index = 0; index < tblSize; index++) {\n-      for (DictionaryEntry probe = (DictionaryEntry) bucket(index); probe != null;\n-                                              probe = (DictionaryEntry) probe.next()) {\n-        Klass k = probe.klass();\n-        \/\/ Only visit InstanceKlasses that are at least in the \"loaded\" init_state. Otherwise\n-        \/\/ the InstanceKlass won't have some required fields initialized, which can cause problems.\n-        if (k instanceof InstanceKlass && !((InstanceKlass)k).isLoaded()) {\n-            continue;\n-        }\n-        v.visit(k, loader);\n-      }\n-    }\n-  }\n-\n-  \/\/ - Internals only below this point\n-\n-  private DictionaryEntry getEntry(int index, long hash, Symbol className) {\n-    for (DictionaryEntry entry = (DictionaryEntry) bucket(index); entry != null;\n-                                    entry = (DictionaryEntry) entry.next()) {\n-      if (entry.hash() == hash && entry.equals(className)) {\n-        return entry;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  public boolean contains(Klass c) {\n-    long hash = computeHash(c.getName());\n-    int index = hashToIndex(hash);\n-\n-    for (DictionaryEntry entry = (DictionaryEntry) bucket(index); entry != null;\n-                                    entry = (DictionaryEntry) entry.next()) {\n-      if (entry.literalValue().equals(c.getAddress())) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/Dictionary.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.memory;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.classfile.ClassLoaderData;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class DictionaryEntry extends sun.jvm.hotspot.utilities.HashtableEntry {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"DictionaryEntry\");\n-  }\n-\n-  public Klass klass() {\n-    return (Klass)Metadata.instantiateWrapperFor(literalValue());\n-  }\n-\n-  public DictionaryEntry(Address addr) {\n-    super(addr);\n-  }\n-\n-  public boolean equals(Symbol className) {\n-    InstanceKlass ik = (InstanceKlass) klass();\n-    return ik.getName().equals(className);\n-  }\n-\n-  \/* covariant return type :-(\n-  public DictionaryEntry next() {\n-    return (DictionaryEntry) super.next();\n-  }\n-  For now, let the caller cast it ..\n-  *\/\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/DictionaryEntry.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -82,1 +82,1 @@\n-    if (i < 0 || i >= getLength()) throw new IndexOutOfBoundsException(i + \" \" + getLength());\n+    Objects.checkIndex(i, getLength());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPoolCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.jvm.hotspot.memory.Dictionary;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n@@ -56,1 +55,0 @@\n-    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n@@ -61,3 +59,0 @@\n-    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n@@ -68,1 +63,0 @@\n-    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n@@ -73,1 +67,0 @@\n-    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n@@ -86,1 +79,0 @@\n-  private static long biasedLockBits;\n@@ -91,1 +83,0 @@\n-  private static long biasedLockShift;\n@@ -97,3 +88,0 @@\n-  private static long biasedLockMask;\n-  private static long biasedLockMaskInPlace;\n-  private static long biasedLockBitInPlace;\n@@ -104,1 +92,0 @@\n-  private static long biasedLockAlignment;\n@@ -110,1 +97,0 @@\n-  private static long biasedLockPattern;\n@@ -136,22 +122,0 @@\n-  \/\/ Biased locking accessors\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchoronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  public boolean hasBiasPattern() {\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);\n-  }\n-\n-  public JavaThread biasedLocker() {\n-    Threads threads = VM.getVM().getThreads();\n-    Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace & ageMaskInPlace));\n-    return threads.createJavaThreadWrapper(addr);\n-  }\n-\n-  \/\/ Indicates that the mark gas the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  public boolean isBiasedAnonymously() {\n-    return hasBiasPattern() && (biasedLocker() == null);\n-  }\n-\n@@ -163,1 +127,1 @@\n-    return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);\n+    return (Bits.maskBitsLong(value(), lockMaskInPlace) == unlockedValue);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,13 +84,0 @@\n-  public long identityHash() {\n-    long addr_value = getAddress().asLongValue();\n-    long addr_bits =\n-      (addr_value >> (VM.getVM().getLogMinObjAlignmentInBytes() + 3)) & 0xffffffffL;\n-    int  length = (int)getLength();\n-    int  byte0 = getByteAt(0);\n-    int  byte1 = getByteAt(1);\n-    long id_hash = (long)idHashAndRefcount.getValue(this.addr);\n-    id_hash = (id_hash >> 16) & 0xffff;\n-    return (id_hash |\n-      ((addr_bits ^ (length << 8) ^ ((byte0 << 8) | byte1)) << 16)) & 0xffffffffL;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Symbol.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-    out.print(String.format(\"0x%x \",this.getOSThread().threadId()));\n+    out.print(String.format(\"%d \",this.getOSThread().threadId()));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,3 @@\n-    contentionsField  = type.getJIntField(\"_contentions\");\n-    waitersField = type.getJIntField(\"_waiters\");\n-    recursionsField = type.getCIntegerField(\"_recursions\");\n+    contentionsField  = new CIntField(type.getCIntegerField(\"_contentions\"), 0);\n+    waitersField      = new CIntField(type.getCIntegerField(\"_waiters\"), 0);\n+    recursionsField   = type.getCIntegerField(\"_recursions\");\n@@ -86,1 +86,1 @@\n-  public int    waiters() { return waitersField.getValue(addr); }\n+  public int    waiters() { return (int)waitersField.getValue(this); }\n@@ -103,1 +103,1 @@\n-      return contentionsField.getValue(addr);\n+      return (int)contentionsField.getValue(this);\n@@ -114,2 +114,2 @@\n-  private static JIntField     contentionsField;\n-  private static JIntField     waitersField;\n+  private static CIntField     contentionsField;\n+  private static CIntField     waitersField;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-    if ((locationValid[index] & (1 << i % locationValidTypeSize)) != 0) {\n+    if ((locationValid[index] & (1L << i % locationValidTypeSize)) != 0) {\n@@ -165,1 +165,1 @@\n-    locationValid[index] |= (1 << (i % locationValidTypeSize));\n+    locationValid[index] |= (1L << (i % locationValidTypeSize));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/RegisterMap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  private int          logBytesPerWord;\n@@ -480,0 +481,1 @@\n+    logBytesPerWord = db.lookupIntConstant(\"LogBytesPerWord\").intValue();\n@@ -691,0 +693,4 @@\n+  public int getLogBytesPerWord() {\n+    return logBytesPerWord;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  private static VMReg fp = new VMReg(29);\n+  private static VMReg fp = new VMReg(29 << 1);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -247,3 +247,3 @@\n-      G1MonitoringSupport g1mm = g1h.g1mm();\n-      long edenSpaceRegionNum = g1mm.edenSpaceRegionNum();\n-      long survivorSpaceRegionNum = g1mm.survivorSpaceRegionNum();\n+      G1MonitoringSupport monitoringSupport = g1h.monitoringSupport();\n+      long edenSpaceRegionNum = monitoringSupport.edenSpaceRegionNum();\n+      long survivorSpaceRegionNum = monitoringSupport.survivorSpaceRegionNum();\n@@ -258,1 +258,1 @@\n-                   g1mm.edenSpaceUsed(), g1mm.edenSpaceCommitted());\n+                   monitoringSupport.edenSpaceUsed(), monitoringSupport.edenSpaceCommitted());\n@@ -260,1 +260,1 @@\n-                   g1mm.survivorSpaceUsed(), g1mm.survivorSpaceCommitted());\n+                   monitoringSupport.survivorSpaceUsed(), monitoringSupport.survivorSpaceCommitted());\n@@ -262,1 +262,1 @@\n-                   g1mm.oldGenUsed(), g1mm.oldGenCommitted());\n+                   monitoringSupport.oldGenUsed(), monitoringSupport.oldGenCommitted());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.utilities;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/\/ Superclass for symbol and string tables.\n-\n-public class BasicHashtable extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"BasicHashtable<mtInternal>\");\n-    tableSizeField = type.getCIntegerField(\"_table_size\");\n-    bucketsField   = type.getAddressField(\"_buckets\");\n-    bucketSize = db.lookupType(\"HashtableBucket<mtInternal>\").getSize();\n-  }\n-\n-  \/\/ Fields\n-  private static CIntegerField tableSizeField;\n-  private static AddressField  bucketsField;\n-  private static long bucketSize;\n-\n-  \/\/ Accessors\n-  protected int tableSize() {\n-    return (int) tableSizeField.getValue(addr);\n-  }\n-\n-  protected BasicHashtableEntry bucket(int i) {\n-    if (Assert.ASSERTS_ENABLED) {\n-       Assert.that(i >= 0 && i < tableSize(), \"Invalid bucket id\");\n-    }\n-    Address tmp = bucketsField.getValue(addr);\n-    tmp = tmp.addOffsetTo(i * bucketSize);\n-    HashtableBucket bucket = VMObjectFactory.newObject(\n-                                              HashtableBucket.class, tmp);\n-    return bucket.getEntry(getHashtableEntryClass());\n-  }\n-\n-  \/\/ derived class may return Class<? extends BasicHashtableEntry>\n-  protected Class<? extends BasicHashtableEntry> getHashtableEntryClass() {\n-    return BasicHashtableEntry.class;\n-  }\n-\n-  public BasicHashtable(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/BasicHashtable.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.utilities;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.oops.Oop;\n-import sun.jvm.hotspot.oops.ObjectHeap;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class BasicHashtableEntry extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"BasicHashtableEntry<mtInternal>\");\n-    hashField      = type.getCIntegerField(\"_hash\");\n-    nextField      = type.getAddressField(\"_next\");\n-  }\n-\n-  \/\/ Fields\n-  private static CIntegerField hashField;\n-  private static AddressField  nextField;\n-\n-  \/\/ Accessors\n-  public long hash() {\n-    return hashField.getValue(addr) & 0xFFFFFFFFL;\n-  }\n-\n-  private long nextAddressValue() {\n-    Debugger dbg = VM.getVM().getDebugger();\n-    Address nextValue = nextField.getValue(addr);\n-    return (nextValue != null) ? dbg.getAddressValue(nextValue) : 0L;\n-  }\n-\n-  public boolean isShared() {\n-    return (nextAddressValue() & 1L) != 0;\n-  }\n-\n-  public BasicHashtableEntry next() {\n-    Address nextValue = nextField.getValue(addr);\n-    Address next = (nextValue != null)? nextValue.andWithMask(-2L) : null;\n-    \/\/ using this.getClass so that return type will be as expected in\n-    \/\/ subclass context. But, because we can't use covariant return type\n-    \/\/ caller has to use this next and cast the result to correct type.\n-    return (BasicHashtableEntry) VMObjectFactory.newObject(this.getClass(), next);\n-  }\n-\n-  public BasicHashtableEntry(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/BasicHashtableEntry.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.utilities;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class Hashtable extends BasicHashtable {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    \/\/ just to confirm that type exists\n-    Type type = db.lookupType(\"IntptrHashtable\");\n-  }\n-\n-  protected Class<? extends HashtableEntry> getHashtableEntryClass() {\n-    return HashtableEntry.class;\n-  }\n-\n-  public long computeHash(Symbol name) {\n-    return name.identityHash();\n-  }\n-\n-  public int hashToIndex(long fullHash) {\n-    return (int) (fullHash % tableSize());\n-  }\n-\n-  public Hashtable(Address addr) {\n-    super(addr);\n-  }\n-\n-  \/\/ VM's Hashtable::hash_symbol\n-  protected static long hashSymbol(byte[] buf) {\n-    long h = 0;\n-    int s = 0;\n-    int len = buf.length;\n-    while (len-- > 0) {\n-      h = 31*h + (0xFFL & buf[s]);\n-      s++;\n-    }\n-    return h & 0xFFFFFFFFL;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/Hashtable.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.utilities;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class HashtableBucket extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"HashtableBucket<mtInternal>\");\n-    entryField = type.getAddressField(\"_entry\");\n-  }\n-\n-  \/\/ Field\n-  private static AddressField entryField;\n-\n-  \/\/ Accessor\n-  public BasicHashtableEntry getEntry(Class<? extends BasicHashtableEntry> clazz) {\n-    Address tmp = entryField.getValue(addr);\n-    return VMObjectFactory.newObject(clazz, tmp);\n-  }\n-\n-  public BasicHashtableEntry entry() {\n-    return getEntry(HashtableEntry.class);\n-  }\n-\n-  public HashtableBucket(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HashtableBucket.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.utilities;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.oops.Oop;\n-import sun.jvm.hotspot.oops.ObjectHeap;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class HashtableEntry extends BasicHashtableEntry {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"IntptrHashtableEntry\");\n-    literalField   = type.getAddressField(\"_literal\");\n-  }\n-\n-  \/\/ Fields\n-  private static AddressField      literalField;\n-\n-  \/\/ Accessors\n-  public Address literalValue() {\n-    return literalField.getValue(addr);\n-  }\n-\n-  public HashtableEntry(Address addr) {\n-    super(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HashtableEntry.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,1 @@\n+import java.util.function.BiFunction;\n@@ -66,8 +68,2 @@\n- * <p> All methods in this class accept {@code null} values for keys and values.\n- * However, {@code null} keys will never will be present in HTTP request\n- * headers, and will not be output\/sent in response headers. Null values can be\n- * represented as either a {@code null} entry for the key (i.e. the list is\n- * {@code null}) or where the key has a list, but one (or more) of the list's\n- * values is {@code null}. Null values are output as a header line containing\n- * the key but no associated value.\n- *\n+ * <p> All methods in this class reject {@code null} values for keys and values.\n+ * {@code null} keys will never be present in HTTP request or response headers.\n@@ -78,25 +74,1 @@\n-        HashMap<String,List<String>> map;\n-\n-       \/**\n-        * Creates an empty instance of {@code Headers}.\n-        *\/\n-        public Headers () {map = new HashMap<String,List<String>>(32);}\n-\n-        \/**\n-         * Normalize the key by converting to following form.\n-         * First {@code char} upper case, rest lower case.\n-         * key is presumed to be {@code ASCII}.\n-         *\/\n-        private String normalize (String key) {\n-            if (key == null) {\n-                return null;\n-            }\n-            int len = key.length();\n-            if (len == 0) {\n-                return key;\n-            }\n-            char[] b = key.toCharArray();\n-            if (b[0] >= 'a' && b[0] <= 'z') {\n-                b[0] = (char)(b[0] - ('a' - 'A'));\n-            } else if (b[0] == '\\r' || b[0] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+    HashMap<String,List<String>> map;\n@@ -104,7 +76,15 @@\n-            for (int i=1; i<len; i++) {\n-                if (b[i] >= 'A' && b[i] <= 'Z') {\n-                    b[i] = (char) (b[i] + ('a' - 'A'));\n-                } else if (b[i] == '\\r' || b[i] == '\\n')\n-                    throw new IllegalArgumentException(\"illegal character in key\");\n-            }\n-            return new String(b);\n+    \/**\n+     * Creates an empty instance of {@code Headers}.\n+     *\/\n+    public Headers() {map = new HashMap<>(32);}\n+\n+    \/**\n+     * Normalize the key by converting to following form.\n+     * First {@code char} upper case, rest lower case.\n+     * key is presumed to be {@code ASCII}.\n+     *\/\n+    private String normalize(String key) {\n+        Objects.requireNonNull(key);\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n@@ -112,0 +92,5 @@\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n@@ -113,1 +98,8 @@\n-        public int size() {return map.size();}\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n+                throw new IllegalArgumentException(\"illegal character in key\");\n+        }\n+        return new String(b);\n+    }\n@@ -115,1 +107,2 @@\n-        public boolean isEmpty() {return map.isEmpty();}\n+    @Override\n+    public int size() {return map.size();}\n@@ -117,9 +110,2 @@\n-        public boolean containsKey(Object key) {\n-            if (key == null) {\n-                return false;\n-            }\n-            if (!(key instanceof String)) {\n-                return false;\n-            }\n-            return map.containsKey (normalize((String)key));\n-        }\n+    @Override\n+    public boolean isEmpty() {return map.isEmpty();}\n@@ -127,3 +113,5 @@\n-        public boolean containsValue(Object value) {\n-            return map.containsValue(value);\n-        }\n+    @Override\n+    public boolean containsKey(Object key) {\n+        Objects.requireNonNull(key);\n+        return key instanceof String k && map.containsKey(normalize(k));\n+    }\n@@ -131,3 +119,5 @@\n-        public List<String> get(Object key) {\n-            return map.get(normalize((String)key));\n-        }\n+    @Override\n+    public boolean containsValue(Object value) {\n+        Objects.requireNonNull(value);\n+        return map.containsValue(value);\n+    }\n@@ -135,14 +125,4 @@\n-        \/**\n-         * Returns the first value from the {@link List} of {@code String}\n-         * values for the given key (if at least one exists).\n-         *\n-         * @param key the key to search for\n-         * @return the first {@code String} value associated with the key\n-         *\/\n-        public String getFirst (String key) {\n-            List<String> l = map.get(normalize(key));\n-            if (l == null) {\n-                return null;\n-            }\n-            return l.get(0);\n-        }\n+    @Override\n+    public List<String> get(Object key) {\n+        return map.get(normalize((String)key));\n+    }\n@@ -150,4 +130,13 @@\n-        public List<String> put(String key, List<String> value) {\n-            for (String v : value)\n-                checkValue(v);\n-            return map.put (normalize(key), value);\n+    \/**\n+     * Returns the first value from the {@link List} of {@code String} values\n+     * for the given {@code key}, or {@code null} if no mapping for the\n+     * {@code key} exists.\n+     *\n+     * @param key the key to search for\n+     * @return    the first {@code String} value associated with the key,\n+     *            or {@code null} if no mapping for the key exists\n+     *\/\n+    public String getFirst(String key) {\n+        List<String> l = map.get(normalize(key));\n+        if (l == null || l.size() == 0) {  \/\/ no mapping exists\n+            return null;\n@@ -155,0 +144,2 @@\n+        return l.get(0);\n+    }\n@@ -156,16 +147,21 @@\n-        \/**\n-         * Adds the given value to the list of headers for the given key. If\n-         * the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the value to add to the header\n-         *\/\n-        public void add (String key, String value) {\n-            checkValue(value);\n-            String k = normalize(key);\n-            List<String> l = map.get(k);\n-            if (l == null) {\n-                l = new LinkedList<String>();\n-                map.put(k,l);\n-            }\n-            l.add (value);\n+    @Override\n+    public List<String> put(String key, List<String> value) {\n+        for (String v : value)\n+            checkValue(v);\n+        return map.put(normalize(key), value);\n+    }\n+\n+    \/**\n+     * Adds the given {@code value} to the list of headers for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n+     *\n+     * @param key   the header name\n+     * @param value the value to add to the header\n+     *\/\n+    public void add(String key, String value) {\n+        checkValue(value);\n+        String k = normalize(key);\n+        List<String> l = map.get(k);\n+        if (l == null) {\n+            l = new LinkedList<>();\n+            map.put(k,l);\n@@ -173,0 +169,2 @@\n+        l.add(value);\n+    }\n@@ -174,20 +172,8 @@\n-        private static void checkValue(String value) {\n-            int len = value.length();\n-            for (int i=0; i<len; i++) {\n-                char c = value.charAt(i);\n-                if (c == '\\r') {\n-                    \/\/ is allowed if it is followed by \\n and a whitespace char\n-                    if (i >= len - 2) {\n-                        throw new IllegalArgumentException(\"Illegal CR found in header\");\n-                    }\n-                    char c1 = value.charAt(i+1);\n-                    char c2 = value.charAt(i+2);\n-                    if (c1 != '\\n') {\n-                        throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n-                    }\n-                    if (c2 != ' ' && c2 != '\\t') {\n-                        throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n-                    }\n-                    i+=2;\n-                } else if (c == '\\n') {\n-                    throw new IllegalArgumentException(\"Illegal LF found in header\");\n+    private static void checkValue(String value) {\n+        int len = value.length();\n+        for (int i=0; i<len; i++) {\n+            char c = value.charAt(i);\n+            if (c == '\\r') {\n+                \/\/ is allowed if it is followed by \\n and a whitespace char\n+                if (i >= len - 2) {\n+                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n@@ -195,0 +181,11 @@\n+                char c1 = value.charAt(i+1);\n+                char c2 = value.charAt(i+2);\n+                if (c1 != '\\n') {\n+                    throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n+                }\n+                if (c2 != ' ' && c2 != '\\t') {\n+                    throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n+                }\n+                i+=2;\n+            } else if (c == '\\n') {\n+                throw new IllegalArgumentException(\"Illegal LF found in header\");\n@@ -197,0 +194,1 @@\n+    }\n@@ -198,12 +196,12 @@\n-        \/**\n-         * Sets the given value as the sole header value for the given\n-         * key. If the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the header value to set\n-         *\/\n-        public void set (String key, String value) {\n-            LinkedList<String> l = new LinkedList<String>();\n-            l.add (value);\n-            put (key, l);\n-        }\n+    \/**\n+     * Sets the given {@code value} as the sole header value for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n+     *\n+     * @param key   the header name\n+     * @param value the header value to set\n+     *\/\n+    public void set(String key, String value) {\n+        LinkedList<String> l = new LinkedList<>();\n+        l.add(value);\n+        put(key, l);\n+    }\n@@ -211,0 +209,4 @@\n+    @Override\n+    public List<String> remove(Object key) {\n+        return map.remove(normalize((String)key));\n+    }\n@@ -212,3 +214,4 @@\n-        public List<String> remove(Object key) {\n-            return map.remove(normalize((String)key));\n-        }\n+    @Override\n+    public void putAll(Map<? extends String,? extends List<String>> t)  {\n+        t.forEach(this::put);\n+    }\n@@ -216,3 +219,2 @@\n-        public void putAll(Map<? extends String,? extends List<String>> t)  {\n-            map.putAll (t);\n-        }\n+    @Override\n+    public void clear() {map.clear();}\n@@ -220,1 +222,2 @@\n-        public void clear() {map.clear();}\n+    @Override\n+    public Set<String> keySet() {return map.keySet();}\n@@ -222,1 +225,2 @@\n-        public Set<String> keySet() {return map.keySet();}\n+    @Override\n+    public Collection<List<String>> values() {return map.values();}\n@@ -224,1 +228,4 @@\n-        public Collection<List<String>> values() {return map.values();}\n+    @Override\n+    public Set<Map.Entry<String, List<String>>> entrySet() {\n+        return map.entrySet();\n+    }\n@@ -226,3 +233,12 @@\n-        public Set<Map.Entry<String, List<String>>> entrySet() {\n-            return map.entrySet();\n-        }\n+    @Override\n+    public void replaceAll(BiFunction<? super String, ? super List<String>, ? extends List<String>> function) {\n+        var f = function.andThen(values -> {\n+            Objects.requireNonNull(values);\n+            values.forEach(Headers::checkValue);\n+            return values;\n+        });\n+        Map.super.replaceAll(f);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) { return map.equals(o); }\n@@ -230,1 +246,2 @@\n-        public boolean equals(Object o) {return map.equals(o);}\n+    @Override\n+    public int hashCode() {return map.hashCode();}\n@@ -232,1 +249,7 @@\n-        public int hashCode() {return map.hashCode();}\n+    @Override\n+    public String toString() {\n+        final var sb = new StringBuilder(Headers.class.getSimpleName());\n+        sb.append(\" { \");\n+        sb.append(map.toString());\n+        sb.append(\" }\");\n+        return sb.toString();\n@@ -234,0 +257,1 @@\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":162,"deletions":138,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -99,6 +100,11 @@\n-            @SuppressWarnings(\"deprecation\")\n-            Object o = Class.forName(cn, true,\n-                                     ClassLoader.getSystemClassLoader()).newInstance();\n-            provider = (HttpServerProvider)o;\n-            return true;\n-        } catch (ClassNotFoundException |\n+            var cls = Class.forName(cn, false, ClassLoader.getSystemClassLoader());\n+            if (HttpServerProvider.class.isAssignableFrom(cls)) {\n+                provider = (HttpServerProvider) cls.getDeclaredConstructor().newInstance();\n+                return true;\n+            } else {\n+                throw new ServiceConfigurationError(\"not assignable to HttpServerProvider: \"\n+                        + cls.getName());\n+            }\n+        } catch (InvocationTargetException |\n+                 NoSuchMethodException |\n+                 ClassNotFoundException |\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/spi\/HttpServerProvider.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n@@ -34,3 +32,1 @@\n-    final static int MAX_CONTEXTS = 50;\n-\n-    LinkedList<HttpContextImpl> list = new LinkedList<HttpContextImpl>();\n+    private final LinkedList<HttpContextImpl> list = new LinkedList<>();\n@@ -40,0 +36,3 @@\n+        if (contains(ctx)) {\n+            throw new IllegalArgumentException (\"cannot add context to list\");\n+        }\n@@ -43,0 +42,4 @@\n+    boolean contains(HttpContextImpl ctx) {\n+        return findContext(ctx.getProtocol(), ctx.getPath(), true) != null;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ContextList.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.Objects;\n+\n@@ -268,3 +270,1 @@\n-            if (off < 0 || srclen < 0|| srclen > (b.length-off)) {\n-                throw new IndexOutOfBoundsException ();\n-            }\n+            Objects.checkFromIndexSize(srclen, off, b.length);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Request.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.Objects;\n@@ -236,3 +237,1 @@\n-        if (i < 0 || i >= numLocals) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkIndex(i, numLocals);\n@@ -250,3 +249,1 @@\n-        if (i < 0 || i >= numStack) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkIndex(i, numStack);\n@@ -264,3 +261,1 @@\n-        if (i < 0 || i >= numLocals) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkIndex(i, numLocals);\n@@ -278,3 +273,1 @@\n-        if (i < 0 || i >= numStack) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkIndex(i, numStack);\n@@ -292,3 +285,1 @@\n-        if (i < 0 || i >= numLocks) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        Objects.checkIndex(i, numLocks);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -926,5 +926,1 @@\n-        if (isArray()) {\n-            return config.arrayPrototypeMarkWord();\n-        } else {\n-            return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);\n-        }\n+        return config.prototypeMarkWord();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -155,1 +154,1 @@\n-    long arrayPrototypeMarkWord() {\n+    long prototypeMarkWord() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n@@ -83,0 +87,30 @@\n+    \/**\n+     * Prints a diagnostic message related to a position within a range of characters in a tree node.\n+     *\n+     * Only kinds of {@code DocTree} that wrap a simple string value are supported as leaf nodes\n+     * of the given path. This currently includes\n+     * {@link CommentTree}, {@link DocTypeTree}, {@link ReferenceTree}, and {@link TextTree}.\n+     *\n+     * The positions are all 0-based character offsets from the beginning of string.\n+     * The positions should satisfy the relation {@code start <= pos <= end}.\n+     *\n+     * @implSpec\n+     * This implementation ignores the {@code (start, pos, end)} values and simply calls\n+     * {@link #print(Diagnostic.Kind, DocTreePath, String) print(kind, path, message)}.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param path    the path for the tree node\n+     * @param start   the beginning of the enclosing range\n+     * @param pos     the position\n+     * @param end     the end of the enclosing range\n+     * @param message the message to be printed\n+     *\n+     * @throws IllegalArgumentException if {@code start}, {@code pos} and {@code end} do\n+     *          not form a valid range.\n+     *\n+     * @since 18\n+     *\/\n+    default void print(Diagnostic.Kind kind, DocTreePath path, int start, int pos, int end, String message) {\n+        print(kind, path, message);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/Reporter.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -98,0 +98,14 @@\n+    \/**\n+     * Reports an error message to the doclet's reporter.\n+     *\n+     * @param path  a path identifying the position to be included with the message\n+     * @param start the start of a range of characters to be associated with the message\n+     * @param pos   the position to be associated with the message\n+     * @param end   the end of a range of characters to be associated with the message\n+     * @param key   the name of a resource containing the message to be printed\n+     * @param args  optional arguments to be replaced in the message\n+     *\/\n+    public void error(DocTreePath path, int start, int pos, int end, String key, Object... args) {\n+        report(ERROR, path, start, pos, end, resources.getText(key, args));\n+    }\n+\n@@ -137,0 +151,14 @@\n+    \/**\n+     * Reports a warning message to the doclet's reporter.\n+     *\n+     * @param path  a path identifying the position to be included with the message\n+     * @param start the start of a range of characters to be associated with the message\n+     * @param pos   the position to be associated with the message\n+     * @param end   the end of a range of characters to be associated with the message\n+     * @param key   the name of a resource containing the message to be printed\n+     * @param args  optional arguments to be replaced in the message\n+     *\/\n+    public void warning(DocTreePath path, int start, int pos, int end, String key, Object... args) {\n+        report(WARNING, path, start, pos, end, resources.getText(key, args));\n+    }\n+\n@@ -197,0 +225,4 @@\n+\n+    private void report(Diagnostic.Kind k, DocTreePath path, int start, int pos, int end, String msg) {\n+        reporter.print(k, path, start, pos, end, msg);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Messages.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -48,0 +48,6 @@\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.tools.javac.tree.DCTree;\n@@ -250,0 +256,42 @@\n+    @Override \/\/ Reporter\n+    public void print(Diagnostic.Kind kind, DocTreePath path, int start, int pos, int end, String message) {\n+        if (!(start <= pos && pos <= end)) {\n+            throw new IllegalArgumentException(\"start:\" + start + \",pos:\" + pos + \",end:\" + end);\n+        }\n+\n+        DocTree t = path.getLeaf();\n+        String s = switch (t.getKind()) {\n+            case COMMENT -> ((CommentTree) t).getBody();\n+            case DOC_TYPE -> ((DocTypeTree) t).getText();\n+            case REFERENCE -> ((ReferenceTree) t).getSignature();\n+            case TEXT -> ((TextTree) t).getBody();\n+            default -> throw new IllegalArgumentException(t.getKind().toString());\n+        };\n+\n+        if (start < 0 || end > s.length()) {\n+            throw new StringIndexOutOfBoundsException(\"start:\" + start + \",pos:\" + pos + \",end:\" + end\n+                    + \"; string length \" + s.length());\n+        }\n+\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+\n+        DCTree.DCDocComment docComment = (DCTree.DCDocComment) path.getDocComment();\n+        DCTree tree = (DCTree) path.getLeaf();\n+        \/\/ note: it is important to evaluate the offsets in the context of the position\n+        \/\/ within the comment text, and not in the context of the overall source text\n+        int sStart = (int) tree.getSourcePosition(docComment, start);\n+        int sPos = (int) tree.getSourcePosition(docComment, pos);\n+        int sEnd = (int) tree.getSourcePosition(docComment, end);\n+        DiagnosticPosition dp = createDiagnosticPosition(null, sStart, sPos, sEnd);\n+\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    private int getSourcePos(DocTreePath path, int offset) {\n+        DCTree.DCDocComment docComment = (DCTree.DCDocComment) path.getDocComment();\n+        DCTree tree = (DCTree) path.getLeaf();\n+        return (int) tree.getSourcePosition(docComment, offset);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocLog.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -734,4 +734,0 @@\n-    private int stiFileTableIndex(int sti, int lti) {\n-        return fileTableIndex(sti, lineTable[lti].fileId);\n-    }\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/SDE.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1233,0 +1233,4 @@\n+    \/* Setting this flag is needed by findThread(). It's ok to set it before\n+       the callbacks are cleared.*\/\n+    gdata->jvmtiCallBacksCleared = JNI_TRUE;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,2 +257,17 @@\n-         * Search runningThreads list. The TLS lookup may have failed because the\n-         * thread has terminated, but the ThreadNode may still be present.\n+         * Normally we can assume that a thread with no TLS will never be in the runningThreads\n+         * list. This is because we always set the TLS when adding to runningThreads.\n+         * However, when a thread exits, its TLS is automatically cleared. Normally this\n+         * is not a problem because the debug agent will first get a THREAD_END event,\n+         * and that will cause the thread to be removed from runningThreads, thus we\n+         * avoid this situation of having a thread in runningThreads, but with no TLS.\n+         *\n+         * However... there is one exception to this. While handling VM_DEATH, the first thing\n+         * the debug agent does is clear all the callbacks. This means we will no longer\n+         * get THREAD_END events as threads exit. This means we might find threads on\n+         * runningThreads with no TLS during VM_DEATH. Essentially the THREAD_END that\n+         * would normally have resulted in removing the thread from runningThreads is\n+         * missed, so the thread remains on runningThreads.\n+         *\n+         * The end result of all this is that if the TLS lookup failed, we still need to check\n+         * if the thread is on runningThreads, but only if JVMTI callbacks have been cleared.\n+         * Otherwise the thread should not be on the runningThreads.\n@@ -260,3 +275,12 @@\n-        if ( node == NULL ) {\n-            if ( list == NULL || list == &runningThreads ) {\n-                node = nonTlsSearch(getEnv(), &runningThreads, thread);\n+        if ( !gdata->jvmtiCallBacksCleared ) {\n+            \/* The thread better not be on runningThreads if the TLS lookup failed. *\/\n+            JDI_ASSERT(!nonTlsSearch(getEnv(), &runningThreads, thread));\n+        } else {\n+            \/*\n+             * Search the runningThreads list. The TLS lookup may have failed because the\n+             * thread has terminated, but we never got the THREAD_END event.\n+             *\/\n+            if ( node == NULL ) {\n+                if ( list == NULL || list == &runningThreads ) {\n+                    node = nonTlsSearch(getEnv(), &runningThreads, thread);\n+                }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -136,2 +136,5 @@\n-     \/* Indication that the agent has been loaded *\/\n-     jboolean isLoaded;\n+    \/* Indication that the agent has been loaded *\/\n+    jboolean isLoaded;\n+\n+    \/* Indication that VM_DEATH has been recieved and the JVMTI callbacks have been cleared. *\/\n+    volatile jboolean jvmtiCallBacksCleared;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,7 +268,0 @@\n-\/*\n- * Below Adapted from PlainSocketImpl.c, win32 version 1.18. Changed exception\n- * throws to returns of SYS_ERR; we should improve the error codes\n- * eventually. Changed java objects to values the debugger back end can\n- * more easily deal with.\n- *\/\n-\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libdt_socket\/socket_md.c","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.internal.PrivateAccess;\n@@ -33,0 +34,1 @@\n+import jdk.jfr.internal.WriteableUserPath;\n@@ -47,1 +49,0 @@\n-            SafePath safePath = null;\n@@ -49,0 +50,2 @@\n+            WriteableUserPath path = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();\n+            SafePath safePath = path == null ? null : new SafePath(path.getRealPathText());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -99,18 +99,0 @@\n-    <event name=\"jdk.BiasedLockRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockSelfRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n-    <event name=\"jdk.BiasedLockClassRevocation\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;;\n@@ -85,1 +86,1 @@\n-        boolean withDesktopFile = !associations.isEmpty() || SHORTCUT_HINT.fetchFrom(params);\n+        boolean withDesktopFile = !associations.isEmpty() || LINUX_SHORTCUT_HINT.fetchFrom(params);\n@@ -141,1 +142,2 @@\n-            List<String> launcherPaths = AppImageFile.getLauncherNames(\n+            List<AppImageFile.LauncherInfo> launcherInfos =\n+                    AppImageFile.getLaunchers(\n@@ -143,2 +145,2 @@\n-            if (!launcherPaths.isEmpty()) {\n-                launcherPaths.remove(0); \/\/ Remove main launcher\n+            if (!launcherInfos.isEmpty()) {\n+                launcherInfos.remove(0); \/\/ Remove main launcher\n@@ -146,1 +148,1 @@\n-            for (var launcherPath : launcherPaths) {\n+            for (var launcherInfo : launcherInfos) {\n@@ -149,6 +151,9 @@\n-                        launcherPath);\n-                launcherParams = AddLauncherArguments.merge(params, launcherParams,\n-                    ICON.getID(), ICON_PNG.getID(), ADD_LAUNCHERS.getID(),\n-                    FILE_ASSOCIATIONS.getID(), PREDEFINED_APP_IMAGE.getID());\n-                nestedIntegrations.add(new DesktopIntegration(thePackage,\n-                        launcherParams, params));\n+                        launcherInfo.getName());\n+                launcherParams = AddLauncherArguments.merge(params,\n+                        launcherParams, ICON.getID(), ICON_PNG.getID(),\n+                        ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(),\n+                        PREDEFINED_APP_IMAGE.getID());\n+                if (launcherInfo.isShortcut()) {\n+                    nestedIntegrations.add(new DesktopIntegration(thePackage,\n+                            launcherParams, params));\n+                }\n@@ -158,5 +163,7 @@\n-                launcherParams = AddLauncherArguments.merge(params, launcherParams,\n-                        ICON.getID(), ICON_PNG.getID(), ADD_LAUNCHERS.getID(),\n-                        FILE_ASSOCIATIONS.getID());\n-                nestedIntegrations.add(new DesktopIntegration(thePackage,\n-                        launcherParams, params));\n+                launcherParams = AddLauncherArguments.merge(params,\n+                        launcherParams, ICON.getID(), ICON_PNG.getID(),\n+                        ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID());\n+                if (SHORTCUT_HINT.fetchFrom(launcherParams)) {\n+                    nestedIntegrations.add(new DesktopIntegration(thePackage,\n+                            launcherParams, params));\n+                }\n@@ -570,1 +577,1 @@\n-    private static final StandardBundlerParam<Boolean> SHORTCUT_HINT =\n+    private static final StandardBundlerParam<Boolean> LINUX_SHORTCUT_HINT =\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n+import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -62,0 +64,2 @@\n+ * win-shortcut\n+ * win-menu\n@@ -63,0 +67,1 @@\n+ * linux-shortcut\n@@ -112,7 +117,0 @@\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_CATEGORY.getId(),\n-                getOptionValue(CLIOptions.LINUX_CATEGORY));\n-\n-        Arguments.putUnlessNull(bundleParams,\n-                CLIOptions.WIN_CONSOLE_HINT.getId(),\n-                getOptionValue(CLIOptions.WIN_CONSOLE_HINT));\n-\n@@ -123,0 +121,17 @@\n+        if (Platform.isWindows())  {\n+            Arguments.putUnlessNull(bundleParams,\n+                    CLIOptions.WIN_CONSOLE_HINT.getId(),\n+                    getOptionValue(CLIOptions.WIN_CONSOLE_HINT));\n+            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+                    getOptionValue(CLIOptions.WIN_SHORTCUT_HINT));\n+            Arguments.putUnlessNull(bundleParams, MENU_HINT.getID(),\n+                    getOptionValue(CLIOptions.WIN_MENU_HINT));\n+        }\n+\n+        if (Platform.isLinux())  {\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_CATEGORY.getId(),\n+                    getOptionValue(CLIOptions.LINUX_CATEGORY));\n+            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+                    getOptionValue(CLIOptions.LINUX_SHORTCUT_HINT));\n+        }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import org.w3c.dom.Node;\n@@ -44,0 +45,1 @@\n+import org.w3c.dom.NamedNodeMap;\n@@ -49,0 +51,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n+import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n@@ -56,1 +60,1 @@\n-    private final List<String> addLauncherNames;\n+    private final List<LauncherInfo> addLauncherInfos;\n@@ -69,1 +73,1 @@\n-    private AppImageFile(String launcherName, List<String> addLauncherNames,\n+    private AppImageFile(String launcherName, List<LauncherInfo> launcherInfos,\n@@ -72,1 +76,1 @@\n-        this.addLauncherNames = addLauncherNames;\n+        this.addLauncherInfos = launcherInfos;\n@@ -82,2 +86,2 @@\n-    List<String> getAddLauncherNames() {\n-        return addLauncherNames;\n+    List<LauncherInfo> getAddLaunchers() {\n+        return addLauncherInfos;\n@@ -134,1 +138,4 @@\n-                xml.writeCharacters(APP_NAME.fetchFrom(sl));\n+                xml.writeAttribute(\"name\", APP_NAME.fetchFrom(sl));\n+                xml.writeAttribute(\"shortcut\",\n+                        SHORTCUT_HINT.fetchFrom(sl).toString());\n+                xml.writeAttribute(\"menu\", MENU_HINT.fetchFrom(sl).toString());\n@@ -159,1 +166,1 @@\n-            List<String> addLaunchers = new ArrayList<>();\n+            List<LauncherInfo> launcherInfos = new ArrayList<>();\n@@ -167,2 +174,2 @@\n-            NodeList launcherNameNodes = (NodeList) xPath.evaluate(\n-                    \"\/jpackage-state\/add-launcher\/text()\", doc,\n+            NodeList launcherNodes = (NodeList) xPath.evaluate(\n+                    \"\/jpackage-state\/add-launcher\", doc,\n@@ -171,2 +178,9 @@\n-            for (int i = 0; i != launcherNameNodes.getLength(); i++) {\n-                addLaunchers.add(launcherNameNodes.item(i).getNodeValue());\n+            for (int i = 0; i != launcherNodes.getLength(); i++) {\n+                 Node item = launcherNodes.item(i);\n+                 String name = getAttribute(item, \"name\");\n+                 String shortcut = getAttribute(item, \"shortcut\");\n+                 String menu = getAttribute(item, \"menu\");\n+\n+                 launcherInfos.add(new LauncherInfo(name,\n+                         !(\"false\".equals(shortcut)),\n+                         !(\"false\".equals(menu))));\n@@ -176,1 +190,1 @@\n-                    mainLauncher, addLaunchers, version, platform);\n+                    mainLauncher, launcherInfos, version, platform);\n@@ -187,0 +201,6 @@\n+    private static String getAttribute(Node item, String attr) {\n+        NamedNodeMap attrs = item.getAttributes();\n+        Node attrNode = attrs.getNamedItem(attr);\n+        return ((attrNode == null) ? null : attrNode.getNodeValue());\n+    }\n+\n@@ -205,2 +225,2 @@\n-     * Returns list of launcher names configured for the application.\n-     * The first item in the returned list is main launcher name.\n+     * Returns list of LauncherInfo objects configured for the application.\n+     * The first item in the returned list is main launcher.\n@@ -209,1 +229,1 @@\n-    static List<String> getLauncherNames(Path appImageDir,\n+    static List<LauncherInfo> getLaunchers(Path appImageDir,\n@@ -211,1 +231,1 @@\n-        List<String> launchers = new ArrayList<>();\n+        List<LauncherInfo> launchers = new ArrayList<>();\n@@ -215,2 +235,3 @@\n-                launchers.add(appImageInfo.getLauncherName());\n-                launchers.addAll(appImageInfo.getAddLauncherNames());\n+                launchers.add(new LauncherInfo(\n+                        appImageInfo.getLauncherName(), true, true));\n+                launchers.addAll(appImageInfo.getAddLaunchers());\n@@ -229,0 +250,2 @@\n+        \/\/ this should never be the case, but maintaining behavior of\n+        \/\/ creating default launchers without AppImageFile present\n@@ -230,3 +253,2 @@\n-        launchers.add(APP_NAME.fetchFrom(params));\n-        ADD_LAUNCHERS.fetchFrom(params).stream().map(APP_NAME::fetchFrom).forEach(\n-                launchers::add);\n+        ADD_LAUNCHERS.fetchFrom(params).stream().map(APP_NAME::fetchFrom).map(\n+                name -> new LauncherInfo(name, true, true)).forEach(launchers::add);\n@@ -265,3 +287,1 @@\n-        if (launcherName == null || launcherName.length() == 0 ||\n-            addLauncherNames.indexOf(\"\") != -1) {\n-            \/\/ Some launchers have empty names. This is invalid.\n+        if (launcherName == null || launcherName.length() == 0) {\n@@ -270,2 +290,5 @@\n-\n-        \/\/ Add more validation.\n+        for (var launcher : addLauncherInfos) {\n+            if (\"\".equals(launcher.getName())) {\n+                return false;\n+            }\n+        }\n@@ -276,0 +299,21 @@\n+    static class LauncherInfo {\n+        private String name;\n+        private boolean shortcut;\n+        private boolean menu;\n+\n+        public LauncherInfo(String name, boolean shortcut, boolean menu) {\n+            this.name = name;\n+            this.shortcut = shortcut;\n+            this.menu = menu;\n+        }\n+        public String getName() {\n+            return name;\n+        }\n+        public boolean isShortcut() {\n+            return shortcut;\n+        }\n+        public boolean isMenu() {\n+            return menu;\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":71,"deletions":27,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -314,0 +314,18 @@\n+    static final StandardBundlerParam<Boolean> SHORTCUT_HINT  =\n+            new StandardBundlerParam<>(\n+                    \"shortcut-hint\", \/\/ not directly related to a CLI option\n+                    Boolean.class,\n+                    params -> true,  \/\/ defaults to true\n+                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n+                            true : Boolean.valueOf(s)\n+            );\n+\n+    static final StandardBundlerParam<Boolean> MENU_HINT  =\n+            new StandardBundlerParam<>(\n+                    \"menu-hint\", \/\/ not directly related to a CLI option\n+                    Boolean.class,\n+                    params -> true,  \/\/ defaults to true\n+                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n+                            true : Boolean.valueOf(s)\n+            );\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -138,2 +138,3 @@\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\", and\\n\\\n-\\          \"win-console\" can be used.\\n\\\n+\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n+\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n+\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,2 +138,3 @@\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\", and\\n\\\n-\\          \"win-console\" can be used.\\n\\\n+\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n+\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n+\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,2 +138,3 @@\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\", and\\n\\\n-\\          \"win-console\" can be used.\\n\\\n+\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n+\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n+\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_zh_CN.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-            launcherPaths = Collections.emptyList();\n+            launchers = Collections.emptyList();\n@@ -112,4 +112,1 @@\n-            launcherPaths = AppImageFile.getLauncherNames(appImageRoot, params).stream()\n-                    .map(name -> installedAppImage.launchersDirectory().resolve(name))\n-                    .map(WixAppImageFragmentBuilder::addExeSuffixToPath)\n-                    .toList();\n+            launchers = AppImageFile.getLaunchers(appImageRoot, params);\n@@ -414,1 +411,1 @@\n-        for (var launcherPath : launcherPaths) {\n+        for (var launcher : launchers) {\n@@ -416,5 +413,15 @@\n-                String componentId = addShortcutComponent(xml, launcherPath,\n-                        folder);\n-                if (componentId != null) {\n-                    defineShortcutFolders.add(folder);\n-                    componentIds.add(componentId);\n+                Path launcherPath = addExeSuffixToPath(installedAppImage\n+                        .launchersDirectory().resolve(launcher.getName()));\n+\n+                if ((launcher.isMenu() &&\n+                        (folder.equals(ShortcutsFolder.ProgramMenu))) ||\n+                    (launcher.isShortcut() &&\n+                        (folder.equals(ShortcutsFolder.Desktop)))) {\n+\n+                    String componentId = addShortcutComponent(xml, launcherPath,\n+                            folder);\n+\n+                    if (componentId != null) {\n+                        defineShortcutFolders.add(folder);\n+                        componentIds.add(componentId);\n+                    }\n@@ -827,1 +834,1 @@\n-    private List<Path> launcherPaths;\n+    private List<AppImageFile.LauncherInfo> launchers;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -66,2 +66,7 @@\n-static void next_line(FILE *f) {\n-    while (fgetc(f) != '\\n');\n+static int next_line(FILE *f) {\n+    int c;\n+    do {\n+        c = fgetc(f);\n+    } while (c != '\\n' && c != EOF);\n+\n+    return c;\n@@ -96,1 +101,4 @@\n-    next_line(fh);\n+    if (next_line(fh) == EOF) {\n+        fclose(fh);\n+        return -2;\n+    }\n@@ -109,1 +117,4 @@\n-            next_line(fh);\n+            if (next_line(fh) == EOF) {\n+                fclose(fh);\n+                return -2;\n+            }\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -191,0 +190,1 @@\n+                    @SuppressWarnings(\"removal\")\n@@ -361,0 +361,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -643,0 +644,1 @@\n+                SctpNet.close(fdVal);\n@@ -650,1 +652,0 @@\n-                SctpNet.close(fdVal);\n@@ -652,0 +653,1 @@\n+                SctpNet.close(fdVal);\n@@ -1092,0 +1094,5 @@\n+        loadSctpLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadSctpLibrary() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -377,0 +377,1 @@\n+                SctpNet.close(fdVal);\n@@ -383,1 +384,0 @@\n-                SctpNet.close(fdVal);\n@@ -385,0 +385,1 @@\n+                SctpNet.close(fdVal);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -45,0 +44,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -107,0 +107,1 @@\n+         @SuppressWarnings(\"removal\")\n@@ -116,1 +117,1 @@\n-                                                         SecurityManager sm)\n+                                                         @SuppressWarnings(\"removal\") SecurityManager sm)\n@@ -339,0 +340,5 @@\n+        loadSctpLibrary();\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void loadSctpLibrary() {\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+                SctpNet.close(fdVal);\n@@ -291,1 +292,0 @@\n-                SctpNet.close(fdVal);\n@@ -293,0 +293,1 @@\n+                SctpNet.close(fdVal);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,5 @@\n+\n+    \/\/ a threshold, in bytes, to decide whether to create a temp file\n+    \/\/ for outputstream of a zip entry\n+    private final int tempFileCreationThreshold = 10 * 1024 * 1024; \/\/ 10 MB\n+\n@@ -1947,1 +1952,1 @@\n-        if (useTempFile) {\n+        if (useTempFile || e.size >= tempFileCreationThreshold) {\n@@ -1951,1 +1956,1 @@\n-            os = new ByteArrayOutputStream((e.size > 0)? (int)e.size : 8192);\n+            os = new FileRolloverOutputStream(e);\n@@ -1991,2 +1996,3 @@\n-            if (out instanceof ByteArrayOutputStream)\n-                e.bytes = ((ByteArrayOutputStream)out).toByteArray();\n+            if (out instanceof FileRolloverOutputStream fros && fros.tmpFileOS == null) {\n+                e.bytes = fros.toByteArray();\n+            }\n@@ -2027,2 +2033,3 @@\n-            if (out instanceof ByteArrayOutputStream)\n-                e.bytes = ((ByteArrayOutputStream)out).toByteArray();\n+            if (out instanceof FileRolloverOutputStream fros && fros.tmpFileOS == null) {\n+                e.bytes = fros.toByteArray();\n+            }\n@@ -2110,0 +2117,105 @@\n+    \/\/ A wrapper around the ByteArrayOutputStream. This FileRolloverOutputStream\n+    \/\/ uses a threshold size to decide if the contents being written need to be\n+    \/\/ rolled over into a temporary file. Until the threshold is reached, writes\n+    \/\/ on this outputstream just write it to the internal in-memory byte array\n+    \/\/ held by the ByteArrayOutputStream. Once the threshold is reached, the\n+    \/\/ write operation on this outputstream first (and only once) creates a temporary file\n+    \/\/ and transfers the data that has so far been written in the internal\n+    \/\/ byte array, to that newly created file. The temp file is then opened\n+    \/\/ in append mode and any subsequent writes, including the one which triggered\n+    \/\/ the temporary file creation, will be written to the file.\n+    \/\/ Implementation note: the \"write\" and the \"close\" methods of this implementation\n+    \/\/ aren't \"synchronized\" because this FileRolloverOutputStream gets called\n+    \/\/ only from either DeflatingEntryOutputStream or EntryOutputStream, both of which\n+    \/\/ already have the necessary \"synchronized\" before calling these methods.\n+    private class FileRolloverOutputStream extends OutputStream {\n+        private ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);\n+        private final Entry entry;\n+        private OutputStream tmpFileOS;\n+        private long totalWritten = 0;\n+\n+        private FileRolloverOutputStream(final Entry e) {\n+            this.entry = e;\n+        }\n+\n+        @Override\n+        public void write(final int b) throws IOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b);\n+                return;\n+            }\n+            if (totalWritten + 1 < tempFileCreationThreshold) {\n+                \/\/ write to our in-memory byte array\n+                baos.write(b);\n+                totalWritten++;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            transferToFile();\n+            writeToFile(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            write(b, 0, b.length);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len) throws IOException {\n+            if (tmpFileOS != null) {\n+                \/\/ already rolled over, write to the file that has been created previously\n+                writeToFile(b, off, len);\n+                return;\n+            }\n+            if (totalWritten + len < tempFileCreationThreshold) {\n+                \/\/ write to our in-memory byte array\n+                baos.write(b, off, len);\n+                totalWritten += len;\n+                return;\n+            }\n+            \/\/ rollover into a file\n+            transferToFile();\n+            writeToFile(b, off, len);\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            if (tmpFileOS != null) {\n+                tmpFileOS.flush();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            baos = null;\n+            if (tmpFileOS != null) {\n+                tmpFileOS.close();\n+            }\n+        }\n+\n+        private void writeToFile(int b) throws IOException {\n+            tmpFileOS.write(b);\n+            totalWritten++;\n+        }\n+\n+        private void writeToFile(byte[] b, int off, int len) throws IOException {\n+            tmpFileOS.write(b, off, len);\n+            totalWritten += len;\n+        }\n+\n+        private void transferToFile() throws IOException {\n+            \/\/ create a tempfile\n+            entry.file = getTempPathForEntry(null);\n+            tmpFileOS = new BufferedOutputStream(Files.newOutputStream(entry.file));\n+            \/\/ transfer the already written data from the byte array buffer into this tempfile\n+            baos.writeTo(tmpFileOS);\n+            \/\/ release the underlying byte array\n+            baos = null;\n+        }\n+\n+        private byte[] toByteArray() {\n+            return baos == null ? null : baos.toByteArray();\n+        }\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":118,"deletions":6,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-        Point viewPosition = getScrollPane().getViewport().getViewPosition();\n@@ -157,3 +156,1 @@\n-            setZoomFactor(newZoom);\n-            validate();\n-            getScrollPane().getViewport().setViewPosition(new Point((int) (viewPosition.x \/ DiagramScene.ZOOM_INCREMENT), (int) (viewPosition.y \/ DiagramScene.ZOOM_INCREMENT)));\n+            zoom(newZoom);\n@@ -167,1 +164,0 @@\n-        Point viewPosition = getScrollPane().getViewport().getViewPosition();\n@@ -170,3 +166,1 @@\n-            setZoomFactor(newZoom);\n-            validate();\n-            getScrollPane().getViewport().setViewPosition(new Point((int) (viewPosition.x * DiagramScene.ZOOM_INCREMENT), (int) (viewPosition.y * DiagramScene.ZOOM_INCREMENT)));\n+            zoom(newZoom);\n@@ -176,0 +170,9 @@\n+    private void zoom(double newZoom) {\n+        double currentZoom = getZoomFactor();\n+        Point viewPosition = getScrollPane().getViewport().getViewPosition();\n+        Rectangle viewRect = getScrollPane().getViewport().getViewRect();\n+        setZoomFactor(newZoom);\n+        validate();\n+        getScrollPane().getViewport().validate();\n+        getScrollPane().getViewport().setViewPosition(new Point((int) ((viewPosition.x + viewRect.width \/ 2) * newZoom \/ currentZoom - viewRect.width \/ 2), (int) ((viewPosition.y + viewRect.height \/ 2) * newZoom \/ currentZoom - viewRect.height \/ 2)));\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -48,1 +51,4 @@\n-                for (TopComponent t : manager.getOpenedTopComponents(m)) {\n+                List<TopComponent> l = new ArrayList<>();\n+                l.add(m.getSelectedTopComponent());\n+                l.addAll(Arrays.asList(manager.getOpenedTopComponents(m)));\n+                for (TopComponent t : l) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-JAVA_RELEASE = 7\n+JAVA_RELEASE = 15\n@@ -56,1 +56,0 @@\n-CC := \"cl.exe\"\n@@ -61,8 +60,0 @@\n-native: require_env\n-ifeq (\"${OS_NAME}\", \"Cygwin\")\n-\t\"${CC}\" src\/windows\/native\/jdk\/test\/failurehandler\/jtreg\/*.c        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\")\"                        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\/win32\")\"                  \\\n-\t\/link \/DLL \/OUT:timeoutHandler.dll\n-endif\n-\n@@ -115,1 +106,1 @@\n-build: classes native\n+build: classes\n@@ -117,1 +108,1 @@\n-.PHONY: all build classes native test require_env clean\n+.PHONY: all build classes test require_env clean\n@@ -119,1 +110,0 @@\n-\n","filename":"test\/failure_handler\/Makefile","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-The library requires jtreg 4b13+ and JDK 7+.\n+The library requires jtreg 4b13+ and JDK 15+.\n@@ -105,1 +105,0 @@\n-\n","filename":"test\/failure_handler\/README","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.failurehandler;\n+\n+import java.nio.file.Path;\n+\n+public interface CoreInfoGatherer {\n+    void gatherCoreInfo(HtmlSection section, Path core);\n+}\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/CoreInfoGatherer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+    public CoreInfoGatherer getCoreInfoGatherer() {\n+        return create();\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/GathererFactory.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +38,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +40,1 @@\n-public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer {\n+public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +43,1 @@\n+    private final PrintWriter log;\n@@ -42,0 +47,1 @@\n+        this.log = log;\n@@ -54,0 +60,21 @@\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        if (core.getFileName().toString().endsWith(\".gz\")) {\n+            Path unpackedCore = Path.of(core.toString().replace(\".gz\", \"\"));\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(core))) {\n+                Files.copy(gzis, unpackedCore);\n+                for (ActionSet set : actions) {\n+                    set.gatherCoreInfo(section, unpackedCore);\n+                }\n+                Files.delete(unpackedCore);\n+            } catch (IOException ioe) {\n+                log.printf(\"Unexpected exception whilc opening %s\", core.getFileName().toString());\n+                ioe.printStackTrace(log);\n+            }\n+        } else {\n+            for (ActionSet set : actions) {\n+                set.gatherCoreInfo(section, core);\n+            }\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/ToolKit.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import com.sun.tools.attach.VirtualMachine;\n-import com.sun.tools.attach.VirtualMachineDescriptor;\n@@ -137,1 +135,1 @@\n-    private File findApp(String app) {\n+    public File findApp(String app) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionHelper.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.failurehandler.CoreInfoGatherer;\n@@ -31,0 +32,1 @@\n+import java.io.IOException;\n@@ -32,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +39,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +41,1 @@\n-public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer {\n+public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +44,2 @@\n+    private static final String CORES_PROPERTY = \"cores\";\n+\n@@ -49,0 +56,1 @@\n+    private final List<PatternAction> coreActions;\n@@ -58,0 +66,1 @@\n+        coreActions = getPatternActions(log, p, CORES_PROPERTY);\n@@ -126,0 +135,7 @@\n+\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        for (PatternAction action : coreActions) {\n+            helper.runPatternAction(action, section, core.toString());\n+        }\n+    }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionSet.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+        for (int i = 0, n = args.length; i < n; ++i) {\n+            args[i] = args[i].replace(\"%java\", helper.findApp(\"java\").getAbsolutePath());\n+        }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/PatternAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -38,2 +39,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -48,0 +47,2 @@\n+    public static final String CORES_OUTPUT = \"cores.html\";\n+\n@@ -67,1 +68,1 @@\n-        PrintWriter log;\n+        PrintWriter log1;\n@@ -70,1 +71,1 @@\n-            log = new PrintWriter(new FileWriter(\n+            log1 = new PrintWriter(new FileWriter(\n@@ -74,2 +75,2 @@\n-            log = new PrintWriter(System.out);\n-            log.printf(\"ERROR: %s cannot open log file %s\", name,\n+            log1 = new PrintWriter(System.out);\n+            log1.printf(\"ERROR: %s cannot open log file %s\", name,\n@@ -77,1 +78,1 @@\n-            e.printStackTrace(log);\n+            e.printStackTrace(log1);\n@@ -79,0 +80,1 @@\n+        final PrintWriter log = log1;\n@@ -86,0 +88,5 @@\n+            Files.walk(workDir)\n+                    .filter(Files::isRegularFile)\n+                    .filter(f -> (f.getFileName().toString().contains(\"core\") || f.getFileName().toString().contains(\"mdmp\")))\n+                    .forEach(core -> gatherCoreInfo(workDir, name,\n+                            core, log, gathererFactory.getCoreInfoGatherer()));\n@@ -99,0 +106,16 @@\n+    private void gatherCoreInfo(Path workDir, String name, Path core, PrintWriter log,\n+                               CoreInfoGatherer gatherer) {\n+        File output = workDir.resolve(CORES_OUTPUT).toFile();\n+        try (HtmlPage html = new HtmlPage(new PrintWriter(\n+                new FileWriter(output, true), true))) {\n+            try (ElapsedTimePrinter timePrinter\n+                         = new ElapsedTimePrinter(new Stopwatch(), name, log)) {\n+                gatherer.gatherCoreInfo(html.getRootSection(), core);\n+            }\n+        } catch (Throwable e) {\n+            log.printf(\"ERROR: exception in observer on getting environment \"\n+                    + \"information %s:\", name);\n+            e.printStackTrace(log);\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherDiagnosticInfoObserver.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Field;\n@@ -105,27 +104,0 @@\n-    @Override\n-    protected long getProcessId(Process process) {\n-        long result = super.getProcessId(process);\n-        if (result == 0L) {\n-            \/* jtreg didn't find pid, most probably we are on JDK < 9\n-               there is no Process::getPid *\/\n-            if (HAS_NATIVE_LIBRARY && \"windows\".equals(OS.current().family)) {\n-                try {\n-                    Field field = process.getClass().getDeclaredField(\"handle\");\n-                    boolean old = field.canAccess(process);\n-                    try {\n-                        field.setAccessible(true);\n-                        long handle = field.getLong(process);\n-                        result = getWin32Pid(handle);\n-                    } finally {\n-                        field.setAccessible(old);\n-                    }\n-                } catch (ReflectiveOperationException e) {\n-                    e.printStackTrace(log);\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private native long getWin32Pid(long handle);\n-\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherProcessInfoTimeoutHandler.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  jstack\n+  jstack jhsdb.jstack\n@@ -54,0 +54,1 @@\n+jcmd.vm.info.args=%p VM.info\n@@ -63,0 +64,9 @@\n+jhsdb.app=jhsdb\n+jhsdb.jstack.args=jstack --mixed --pid %p\n+jhsdb.jstack.params.repeat=6\n+\n+cores=jhsdb.jstack\n+jhsdb.jstack.app=jhsdb\n+# Assume that java standard laucher has been used\n+jhsdb.jstack.args=jstack --mixed --core %p --exe %java\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -58,0 +59,7 @@\n+\n+cores=native.gdb\n+native.gdb.app=gdb\n+# Assume that java standard laucher has been used\n+native.gdb.args=%java\\0-c\\0%p\\0-batch\\0-ex\\0thread apply all backtrace\n+native.gdb.args.delimiter=\\0\n+\n@@ -131,1 +139,0 @@\n-\n","filename":"test\/failure_handler\/src\/share\/conf\/linux.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+cores=native.lldb\n+native.lldb.app=lldb\n+native.lldb.delimiter=\\0\n+# Assume that java standard laucher has been used\n+native.lldb.args=--core\\0%p\\0%java\\0-o\\0thread backtrace all\\0-o\\0quit\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <windows.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-JNIEXPORT jlong JNICALL Java_jdk_test_failurehandler_jtreg_GatherProcessInfoTimeoutHandler_getWin32Pid\n-        (JNIEnv* env, jobject o, jlong handle) {\n-    return GetProcessId((HANDLE) handle);\n-}\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/failure_handler\/src\/windows\/native\/libtimeoutHandler\/GatherProcessInfoTimeoutHandler.c","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -911,1 +911,8 @@\n-           self._merge = \"\/m\"\n+           assert len(args) > 2, \"Must specify predicate type\"\n+           for arg in args[2:]:\n+              if arg == 'm':\n+                 self._merge = \"\/m\"\n+              elif arg == 'z':\n+                 self._merge = \"\/z\"\n+              else:\n+                 assert arg == \"dn\", \"Unknown predicate type\"\n@@ -914,1 +921,1 @@\n-           self._merge =\"\"\n+           self._merge = \"\"\n@@ -924,0 +931,2 @@\n+\n+        self._dnm = None\n@@ -925,3 +934,4 @@\n-            self._dnm = args[2]\n-        else:\n-            self._dnm = None\n+           for arg in args[2:]:\n+             if arg == \"dn\":\n+               self._dnm = arg\n+\n@@ -1526,0 +1536,1 @@\n+                        [\"fmov\",   \"__ fmovhid(r0, v1);\",                                \"fmov\\tx0, v1.d[1]\"],\n@@ -1546,0 +1557,2 @@\n+                        [\"dup\",    \"__ sve_dup(z4, __ B, r3);\",                          \"dup\\tz4.b, w3\"],\n+                        [\"dup\",    \"__ sve_dup(z14, __ H, r22);\",                        \"dup\\tz14.h, w22\"],\n@@ -1561,0 +1574,11 @@\n+                        [\"cntb\",   \"__ sve_cntb(r9);\",                                   \"cntb\\tx9\"],\n+                        [\"cnth\",   \"__ sve_cnth(r10);\",                                  \"cnth\\tx10\"],\n+                        [\"cntw\",   \"__ sve_cntw(r11);\",                                  \"cntw\\tx11\"],\n+                        [\"cntd\",   \"__ sve_cntd(r12);\",                                  \"cntd\\tx12\"],\n+                        [\"brka\",   \"__ sve_brka(p2, p0, p2, false);\",                    \"brka\\tp2.b, p0\/z, p2.b\"],\n+                        [\"brka\",   \"__ sve_brka(p1, p2, p3, true);\",                     \"brka\\tp1.b, p2\/m, p3.b\"],\n+                        [\"incp\",   \"__ sve_incp(r0, __ B, p2);\",                         \"incp\\tx0, p2.b\"],\n+                        [\"whilelt\",   \"__ sve_whilelt(p0, __ B, r1, r28);\",              \"whilelt\\tp0.b, x1, x28\"],\n+                        [\"whilele\",   \"__ sve_whilele(p2, __ H, r11, r8);\",              \"whilele\\tp2.h, x11, x8\"],\n+                        [\"whilelo\",   \"__ sve_whilelo(p3, __ S, r7, r2);\",               \"whilelo\\tp3.s, x7, x2\"],\n+                        [\"whilels\",   \"__ sve_whilels(p4, __ D, r17, r10);\",             \"whilels\\tp4.d, x17, x10\"],\n@@ -1596,30 +1620,30 @@\n-                       [\"abs\", \"ZPZ\"],\n-                       [\"add\", \"ZPZ\", \"dn\"],\n-                       [\"asr\", \"ZPZ\", \"dn\"],\n-                       [\"cnt\", \"ZPZ\"],\n-                       [\"lsl\", \"ZPZ\", \"dn\"],\n-                       [\"lsr\", \"ZPZ\", \"dn\"],\n-                       [\"mul\", \"ZPZ\", \"dn\"],\n-                       [\"neg\", \"ZPZ\"],\n-                       [\"not\", \"ZPZ\"],\n-                       [\"smax\", \"ZPZ\", \"dn\"],\n-                       [\"smin\", \"ZPZ\", \"dn\"],\n-                       [\"sub\", \"ZPZ\", \"dn\"],\n-                       [\"fabs\", \"ZPZ\"],\n-                       [\"fadd\", \"ZPZ\", \"dn\"],\n-                       [\"fdiv\", \"ZPZ\", \"dn\"],\n-                       [\"fmax\", \"ZPZ\", \"dn\"],\n-                       [\"fmin\", \"ZPZ\", \"dn\"],\n-                       [\"fmul\", \"ZPZ\", \"dn\"],\n-                       [\"fneg\", \"ZPZ\"],\n-                       [\"frintm\", \"ZPZ\"],\n-                       [\"frintn\", \"ZPZ\"],\n-                       [\"frintp\", \"ZPZ\"],\n-                       [\"fsqrt\", \"ZPZ\"],\n-                       [\"fsub\", \"ZPZ\", \"dn\"],\n-                       [\"fmla\", \"ZPZZ\"],\n-                       [\"fmls\", \"ZPZZ\"],\n-                       [\"fnmla\", \"ZPZZ\"],\n-                       [\"fnmls\", \"ZPZZ\"],\n-                       [\"mla\", \"ZPZZ\"],\n-                       [\"mls\", \"ZPZZ\"],\n+                       [\"abs\", \"ZPZ\", \"m\"],\n+                       [\"add\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"asr\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"cnt\", \"ZPZ\", \"m\"],\n+                       [\"lsl\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"lsr\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"mul\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"neg\", \"ZPZ\", \"m\"],\n+                       [\"not\", \"ZPZ\", \"m\"],\n+                       [\"smax\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"smin\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"sub\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fabs\", \"ZPZ\", \"m\"],\n+                       [\"fadd\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fdiv\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmax\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmin\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmul\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fneg\", \"ZPZ\", \"m\"],\n+                       [\"frintm\", \"ZPZ\", \"m\"],\n+                       [\"frintn\", \"ZPZ\", \"m\"],\n+                       [\"frintp\", \"ZPZ\", \"m\"],\n+                       [\"fsqrt\", \"ZPZ\", \"m\"],\n+                       [\"fsub\", \"ZPZ\", \"m\", \"dn\"],\n+                       [\"fmla\", \"ZPZZ\", \"m\"],\n+                       [\"fmls\", \"ZPZZ\", \"m\"],\n+                       [\"fnmla\", \"ZPZZ\", \"m\"],\n+                       [\"fnmls\", \"ZPZZ\", \"m\"],\n+                       [\"mla\", \"ZPZZ\", \"m\"],\n+                       [\"mls\", \"ZPZZ\", \"m\"],\n@@ -1630,0 +1654,4 @@\n+                       [\"cmpeq\", \"PPZZ\", \"z\"],\n+                       [\"cmpge\", \"PPZZ\", \"z\"],\n+                       [\"cmpgt\", \"PPZZ\", \"z\"],\n+                       [\"cmpne\", \"PPZZ\", \"z\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":63,"deletions":35,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -726,0 +726,1 @@\n+    __ fmovhid(r0, v1);                                \/\/       fmov    x0, v1.d[1]\n@@ -745,0 +746,2 @@\n+    __ sve_dup(z4, __ B, r3);                          \/\/       dup     z4.b, w3\n+    __ sve_dup(z14, __ H, r22);                        \/\/       dup     z14.h, w22\n@@ -760,0 +763,11 @@\n+    __ sve_cntb(r9);                                   \/\/       cntb    x9\n+    __ sve_cnth(r10);                                  \/\/       cnth    x10\n+    __ sve_cntw(r11);                                  \/\/       cntw    x11\n+    __ sve_cntd(r12);                                  \/\/       cntd    x12\n+    __ sve_brka(p2, p0, p2, false);                    \/\/       brka    p2.b, p0\/z, p2.b\n+    __ sve_brka(p1, p2, p3, true);                     \/\/       brka    p1.b, p2\/m, p3.b\n+    __ sve_incp(r0, __ B, p2);                         \/\/       incp    x0, p2.b\n+    __ sve_whilelt(p0, __ B, r1, r28);                 \/\/       whilelt p0.b, x1, x28\n+    __ sve_whilele(p2, __ H, r11, r8);                 \/\/       whilele p2.h, x11, x8\n+    __ sve_whilelo(p3, __ S, r7, r2);                  \/\/       whilelo p3.s, x7, x2\n+    __ sve_whilels(p4, __ D, r17, r10);                \/\/       whilels p4.d, x17, x10\n@@ -935,0 +949,4 @@\n+    __ sve_cmpeq(p5, __ S, p6, z5, z19);               \/\/       cmpeq   p5.s, p6\/z, z5.s, z19.s\n+    __ sve_cmpge(p4, __ S, p5, z16, z29);              \/\/       cmpge   p4.s, p5\/z, z16.s, z29.s\n+    __ sve_cmpgt(p5, __ D, p0, z4, z17);               \/\/       cmpgt   p5.d, p0\/z, z4.d, z17.d\n+    __ sve_cmpne(p1, __ D, p5, z4, z23);               \/\/       cmpne   p1.d, p5\/z, z4.d, z23.d\n@@ -937,9 +955,9 @@\n-    __ sve_andv(v21, __ S, p6, z5);                    \/\/       andv s21, p6, z5.s\n-    __ sve_orv(v21, __ S, p4, z22);                    \/\/       orv s21, p4, z22.s\n-    __ sve_eorv(v29, __ B, p5, z19);                   \/\/       eorv b29, p5, z19.b\n-    __ sve_smaxv(v4, __ B, p4, z23);                   \/\/       smaxv b4, p4, z23.b\n-    __ sve_sminv(v19, __ D, p1, z23);                  \/\/       sminv d19, p1, z23.d\n-    __ sve_fminv(v19, __ S, p0, z8);                   \/\/       fminv s19, p0, z8.s\n-    __ sve_fmaxv(v14, __ D, p6, z17);                  \/\/       fmaxv d14, p6, z17.d\n-    __ sve_fadda(v21, __ S, p1, z30);                  \/\/       fadda s21, p1, s21, z30.s\n-    __ sve_uaddv(v10, __ B, p5, z12);                  \/\/       uaddv d10, p5, z12.b\n+    __ sve_andv(v19, __ H, p0, z8);                    \/\/       andv h19, p0, z8.h\n+    __ sve_orv(v14, __ D, p6, z17);                    \/\/       orv d14, p6, z17.d\n+    __ sve_eorv(v21, __ B, p1, z30);                   \/\/       eorv b21, p1, z30.b\n+    __ sve_smaxv(v10, __ B, p5, z12);                  \/\/       smaxv b10, p5, z12.b\n+    __ sve_sminv(v9, __ S, p1, z24);                   \/\/       sminv s9, p1, z24.s\n+    __ sve_fminv(v4, __ S, p6, z6);                    \/\/       fminv s4, p6, z6.s\n+    __ sve_fmaxv(v27, __ D, p6, z13);                  \/\/       fmaxv d27, p6, z13.d\n+    __ sve_fadda(v30, __ D, p5, z22);                  \/\/       fadda d30, p5, d30, z22.d\n+    __ sve_uaddv(v30, __ H, p7, z9);                   \/\/       uaddv d30, p7, z9.h\n@@ -964,7 +982,7 @@\n-    0x14000000,     0x17ffffd7,     0x140002fb,     0x94000000,\n-    0x97ffffd4,     0x940002f8,     0x3400000a,     0x34fffa2a,\n-    0x34005eaa,     0x35000008,     0x35fff9c8,     0x35005e48,\n-    0xb400000b,     0xb4fff96b,     0xb4005deb,     0xb500001d,\n-    0xb5fff91d,     0xb5005d9d,     0x10000013,     0x10fff8b3,\n-    0x10005d33,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36305cb6,     0x3758000c,     0x375ff7cc,     0x37585c4c,\n+    0x14000000,     0x17ffffd7,     0x1400030d,     0x94000000,\n+    0x97ffffd4,     0x9400030a,     0x3400000a,     0x34fffa2a,\n+    0x340060ea,     0x35000008,     0x35fff9c8,     0x35006088,\n+    0xb400000b,     0xb4fff96b,     0xb400602b,     0xb500001d,\n+    0xb5fff91d,     0xb5005fdd,     0x10000013,     0x10fff8b3,\n+    0x10005f73,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305ef6,     0x3758000c,     0x375ff7cc,     0x37585e8c,\n@@ -975,13 +993,13 @@\n-    0x54005a20,     0x54000001,     0x54fff541,     0x540059c1,\n-    0x54000002,     0x54fff4e2,     0x54005962,     0x54000002,\n-    0x54fff482,     0x54005902,     0x54000003,     0x54fff423,\n-    0x540058a3,     0x54000003,     0x54fff3c3,     0x54005843,\n-    0x54000004,     0x54fff364,     0x540057e4,     0x54000005,\n-    0x54fff305,     0x54005785,     0x54000006,     0x54fff2a6,\n-    0x54005726,     0x54000007,     0x54fff247,     0x540056c7,\n-    0x54000008,     0x54fff1e8,     0x54005668,     0x54000009,\n-    0x54fff189,     0x54005609,     0x5400000a,     0x54fff12a,\n-    0x540055aa,     0x5400000b,     0x54fff0cb,     0x5400554b,\n-    0x5400000c,     0x54fff06c,     0x540054ec,     0x5400000d,\n-    0x54fff00d,     0x5400548d,     0x5400000e,     0x54ffefae,\n-    0x5400542e,     0x5400000f,     0x54ffef4f,     0x540053cf,\n+    0x54005c60,     0x54000001,     0x54fff541,     0x54005c01,\n+    0x54000002,     0x54fff4e2,     0x54005ba2,     0x54000002,\n+    0x54fff482,     0x54005b42,     0x54000003,     0x54fff423,\n+    0x54005ae3,     0x54000003,     0x54fff3c3,     0x54005a83,\n+    0x54000004,     0x54fff364,     0x54005a24,     0x54000005,\n+    0x54fff305,     0x540059c5,     0x54000006,     0x54fff2a6,\n+    0x54005966,     0x54000007,     0x54fff247,     0x54005907,\n+    0x54000008,     0x54fff1e8,     0x540058a8,     0x54000009,\n+    0x54fff189,     0x54005849,     0x5400000a,     0x54fff12a,\n+    0x540057ea,     0x5400000b,     0x54fff0cb,     0x5400578b,\n+    0x5400000c,     0x54fff06c,     0x5400572c,     0x5400000d,\n+    0x54fff00d,     0x540056cd,     0x5400000e,     0x54ffefae,\n+    0x5400566e,     0x5400000f,     0x54ffef4f,     0x5400560f,\n@@ -1019,1 +1037,1 @@\n-    0xbd1b1869,     0x5800441b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800465b,     0x1800000b,     0xf8945060,\n@@ -1106,50 +1124,54 @@\n-    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x4cc0ac3f,\n-    0x05a08020,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,\n-    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,\n-    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,\n-    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n-    0x25b8efe2,     0x25f8f007,     0xa400a3e0,     0xa4a8a7ea,\n-    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n-    0xe400fbf6,     0xe408ffff,     0xe547e400,     0xe4014be0,\n-    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n-    0xe59f5d08,     0x1e601000,     0x1e603000,     0x1e621000,\n-    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n-    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n-    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n-    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n-    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n-    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n-    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n-    0x1e7e3000,     0xf8208193,     0xf83101b6,     0xf83c13fe,\n-    0xf821239a,     0xf824309e,     0xf826535e,     0xf8304109,\n-    0xf82c7280,     0xf8216058,     0xf8a08309,     0xf8ba03d0,\n-    0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,\n-    0xf8a2418a,     0xf8ac71af,     0xf8a26287,     0xf8fa8090,\n-    0xf8e20184,     0xf8f01215,     0xf8f022ab,     0xf8f7334c,\n-    0xf8f751dc,     0xf8eb4038,     0xf8ec715f,     0xf8f06047,\n-    0xf863826d,     0xf8710070,     0xf86113cb,     0xf86521e8,\n-    0xf87d301e,     0xf8745287,     0xf87742bc,     0xf87b70b9,\n-    0xf8616217,     0xb83f8185,     0xb82901fc,     0xb83d13f6,\n-    0xb83320bf,     0xb82e33f0,     0xb830529b,     0xb830416c,\n-    0xb82973c6,     0xb831639b,     0xb8be8147,     0xb8b4008a,\n-    0xb8b81231,     0xb8b623a3,     0xb8af3276,     0xb8b35056,\n-    0xb8af4186,     0xb8b071ab,     0xb8b763c1,     0xb8f38225,\n-    0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,\n-    0xb8ff5278,     0xb8f14389,     0xb8fb70ef,     0xb8f563f7,\n-    0xb87983e2,     0xb87b0150,     0xb8771073,     0xb8702320,\n-    0xb87a3057,     0xb870508c,     0xb87c43be,     0xb87070db,\n-    0xb86961fd,     0xce273c87,     0xce080ac9,     0xce7e8e9b,\n-    0xce808b45,     0xce79806e,     0xce758768,     0xcec0835a,\n-    0xce608ad8,     0x043100c4,     0x046105e3,     0x65c900a6,\n-    0x65d60a87,     0x65c80545,     0x0416a63e,     0x04001f8b,\n-    0x0450979a,     0x04dabe0d,     0x045381a5,     0x04918b4f,\n-    0x049006cb,     0x0497a264,     0x045eadd1,     0x04881062,\n-    0x040a04d7,     0x04810f71,     0x04dca450,     0x65c084c3,\n-    0x65cd8d93,     0x65c69a68,     0x65878ae0,     0x65c29db3,\n-    0x049da0e6,     0x6582b911,     0x65c0b6d6,     0x65c1a1e2,\n-    0x65cda494,     0x65c18107,     0x65af1493,     0x65e52b36,\n-    0x65ab4ed0,     0x65f06a8d,     0x0451448f,     0x049c7c86,\n-    0x0429335d,     0x04bc3162,     0x047a3027,     0x04e831d1,\n-    0x049a38b5,     0x049832d5,     0x0419367d,     0x040832e4,\n-    0x04ca26f3,     0x65872113,     0x65c63a2e,     0x659827d5,\n-    0x0401358a,\n+    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x9eae0020,\n+    0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,     0x0470e7e1,\n+    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n+    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n+    0x042053ff,     0x047f5401,     0x25208028,     0x2538cfe0,\n+    0x2578d001,     0x25b8efe2,     0x25f8f007,     0x05203864,\n+    0x05603ace,     0xa400a3e0,     0xa4a8a7ea,     0xa547a814,\n+    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n+    0xe408ffff,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f15000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,\n+    0x25104042,     0x25104871,     0x252c8840,     0x253c1420,\n+    0x25681572,     0x25a21ce3,     0x25ea1e34,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8208193,\n+    0xf83101b6,     0xf83c13fe,     0xf821239a,     0xf824309e,\n+    0xf826535e,     0xf8304109,     0xf82c7280,     0xf8216058,\n+    0xf8a08309,     0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,\n+    0xf8a2310b,     0xf8aa522f,     0xf8a2418a,     0xf8ac71af,\n+    0xf8a26287,     0xf8fa8090,     0xf8e20184,     0xf8f01215,\n+    0xf8f022ab,     0xf8f7334c,     0xf8f751dc,     0xf8eb4038,\n+    0xf8ec715f,     0xf8f06047,     0xf863826d,     0xf8710070,\n+    0xf86113cb,     0xf86521e8,     0xf87d301e,     0xf8745287,\n+    0xf87742bc,     0xf87b70b9,     0xf8616217,     0xb83f8185,\n+    0xb82901fc,     0xb83d13f6,     0xb83320bf,     0xb82e33f0,\n+    0xb830529b,     0xb830416c,     0xb82973c6,     0xb831639b,\n+    0xb8be8147,     0xb8b4008a,     0xb8b81231,     0xb8b623a3,\n+    0xb8af3276,     0xb8b35056,     0xb8af4186,     0xb8b071ab,\n+    0xb8b763c1,     0xb8f38225,     0xb8e202d0,     0xb8ed12aa,\n+    0xb8fd219b,     0xb8fb3023,     0xb8ff5278,     0xb8f14389,\n+    0xb8fb70ef,     0xb8f563f7,     0xb87983e2,     0xb87b0150,\n+    0xb8771073,     0xb8702320,     0xb87a3057,     0xb870508c,\n+    0xb87c43be,     0xb87070db,     0xb86961fd,     0xce273c87,\n+    0xce080ac9,     0xce7e8e9b,     0xce808b45,     0xce79806e,\n+    0xce758768,     0xcec0835a,     0xce608ad8,     0x043100c4,\n+    0x046105e3,     0x65c900a6,     0x65d60a87,     0x65c80545,\n+    0x0416a63e,     0x04001f8b,     0x0450979a,     0x04dabe0d,\n+    0x045381a5,     0x04918b4f,     0x049006cb,     0x0497a264,\n+    0x045eadd1,     0x04881062,     0x040a04d7,     0x04810f71,\n+    0x04dca450,     0x65c084c3,     0x65cd8d93,     0x65c69a68,\n+    0x65878ae0,     0x65c29db3,     0x049da0e6,     0x6582b911,\n+    0x65c0b6d6,     0x65c1a1e2,     0x65cda494,     0x65c18107,\n+    0x65af1493,     0x65e52b36,     0x65ab4ed0,     0x65f06a8d,\n+    0x0451448f,     0x049c7c86,     0x0429335d,     0x04bc3162,\n+    0x047a3027,     0x04e831d1,     0x2493b8a5,     0x249d9604,\n+    0x24d18095,     0x24d7b491,     0x045a2113,     0x04d83a2e,\n+    0x041927d5,     0x0408358a,     0x048a2709,     0x658738c4,\n+    0x65c639bb,     0x65d836de,     0x04413d3e,\n@@ -1158,0 +1180,1 @@\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":103,"deletions":80,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -63,5 +63,8 @@\n-  HeapRegion hr0(0, &bot, mr0);\n-  HeapRegion hr1(1, &bot, mr1);\n-  HeapRegion hr2(2, &bot, mr2);\n-  HeapRegion hr3(3, &bot, mr3);\n-  HeapRegion hr4(4, &bot, mr4);\n+  G1CardSetConfiguration config;\n+\n+  HeapRegion hr0(0, &bot, mr0, &config);\n+  HeapRegion hr1(1, &bot, mr1, &config);\n+  HeapRegion hr2(2, &bot, mr2, &config);\n+  HeapRegion hr3(3, &bot, mr3, &config);\n+  HeapRegion hr4(4, &bot, mr4, &config);\n+\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+class G1CardSetTest : public ::testing::Test {\n+\n+  class G1CountCardsClosure : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    size_t _num_cards;\n+\n+    G1CountCardsClosure() : _num_cards(0) { }\n+    void do_card(uint region_idx, uint card_idx) override {\n+      _num_cards++;\n+    }\n+  };\n+\n+  static WorkGang* _workers;\n+  static uint _max_workers;\n+\n+  static WorkGang* workers() {\n+    if (_workers == NULL) {\n+      _max_workers = os::processor_count();\n+      _workers = new WorkGang(\"G1CardSetTest Work Gang\", _max_workers, false, false);\n+      _workers->initialize_workers();\n+      _workers->update_active_workers(_max_workers);\n+    }\n+    return _workers;\n+  }\n+\n+  \/\/ Check whether iteration agrees with the expected number of entries. If the\n+  \/\/ add has been single-threaded, we can also check whether the occupied()\n+  \/\/ (which is an estimate in that case) agrees.\n+  static void check_iteration(G1CardSet* card_set,\n+                              const size_t expected,\n+                              const bool add_was_single_threaded = true);\n+\n+public:\n+  G1CardSetTest() { }\n+  ~G1CardSetTest() { }\n+\n+  static uint next_random(uint& seed, uint i) {\n+    \/\/ ParkMiller random number generator\n+    seed = (seed * 279470273u) % 0xfffffffb;\n+    return (seed % i);\n+  }\n+\n+  static void cardset_basic_test();\n+  static void cardset_mt_test();\n+\n+  static void add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results);\n+  static void contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards);\n+\n+  static void translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards);\n+\n+  static void iterate_cards(G1CardSet* card_set, G1CardSet::G1CardSetCardIterator* cl);\n+};\n+\n+WorkGang* G1CardSetTest::_workers = NULL;\n+uint G1CardSetTest::_max_workers = 0;\n+\n+void G1CardSetTest::add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results) {\n+  for (uint i = 0; i < num_cards; i++) {\n+\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    G1AddCardResult res = card_set->add_card(region_idx, card_idx);\n+    if (results != NULL) {\n+      ASSERT_TRUE(res == results[i]);\n+    }\n+  }\n+}\n+\n+class G1CheckCardClosure : public G1CardSet::G1CardSetCardIterator {\n+  G1CardSet* _card_set;\n+\n+  uint _cards_per_region;\n+  uint* _cards_to_expect;\n+  uint _num_cards;\n+\n+  bool _wrong_region_idx;\n+\n+public:\n+  G1CheckCardClosure(G1CardSet* card_set, uint cards_per_region, uint* cards_to_expect, uint num_cards) :\n+    _card_set(card_set),\n+    _cards_per_region(cards_per_region),\n+    _cards_to_expect(cards_to_expect),\n+    _num_cards(num_cards),\n+    _wrong_region_idx(false) {\n+  }\n+\n+  void do_card(uint region_idx, uint card_idx) override {\n+    uint card = _cards_per_region * region_idx + card_idx;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] == card) {\n+        _cards_to_expect[i] = (uint)-1;\n+      }\n+    }\n+  }\n+\n+  bool all_found() const {\n+    bool all_good = true;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] != (uint)-1) {\n+        log_error(gc)(\"Could not find card %u in region %u\",\n+                      _cards_to_expect[i] % _cards_per_region,\n+                      _cards_to_expect[i] \/ _cards_per_region);\n+        all_good = false;\n+      }\n+    }\n+    return all_good;\n+  }\n+};\n+\n+void G1CardSetTest::contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    ASSERT_TRUE(card_set->contains_card(region_idx, card_idx));\n+  }\n+\n+  G1CheckCardClosure cl(card_set, cards_per_region, cards, num_cards);\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(cl.all_found());\n+}\n+\n+\/\/ Offsets the card indexes in the cards array by the region_idx.\n+void G1CardSetTest::translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    cards[i] = cards_per_region * region_idx + cards[i];\n+  }\n+}\n+\n+class G1CountCardsOccupied : public G1CardSet::G1CardSetPtrIterator {\n+  size_t _num_occupied;\n+\n+public:\n+  G1CountCardsOccupied() : _num_occupied(0) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    _num_occupied += num_occupied;\n+  }\n+\n+  size_t num_occupied() const { return _num_occupied; }\n+};\n+\n+void G1CardSetTest::check_iteration(G1CardSet* card_set, const size_t expected, const bool single_threaded) {\n+\n+  class CheckIterator : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    G1CardSet* _card_set;\n+    size_t _num_found;\n+\n+    CheckIterator(G1CardSet* card_set) : _card_set(card_set), _num_found(0) { }\n+\n+    void do_card(uint region_idx, uint card_idx) override {\n+      ASSERT_TRUE(_card_set->contains_card(region_idx, card_idx));\n+      _num_found++;\n+    }\n+  } cl(card_set);\n+\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(expected == cl._num_found);\n+  \/\/ We can assert this only if we are single-threaded.\n+  if (single_threaded) {\n+    ASSERT_EQ(card_set->occupied(), cl._num_found);\n+  }\n+}\n+\n+void G1CardSetTest::cardset_basic_test() {\n+\n+  const uint CardsPerRegion = 2048;\n+  const double FullCardSetThreshold = 0.8;\n+  const double BitmapCoarsenThreshold = 0.9;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 28, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 1, 2, 3 };\n+    G1AddCardResult results1[] = { Added, Added, Added };\n+    translate_cards(CardsPerRegion, 99, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+\n+    check_iteration(&card_set, 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 17 };\n+    G1AddCardResult results1[] = { Added, Added, Added, Found };\n+    translate_cards(CardsPerRegion, 100, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    \/\/ -1 because of the duplicate at the end.\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1) - 1);\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1) - 1);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1) - 1);\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 18 \/* for region 100 *\/,\n+                      1,  128, 35, 17 \/* for region 990 *\/\n+                    };\n+    translate_cards(CardsPerRegion, 100, &cards1[0], 4);\n+    translate_cards(CardsPerRegion, 990, &cards1[4], 4);\n+\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[100];\n+    for (uint i = 0; i < ARRAY_SIZE(cards1); i++) {\n+      cards1[i] = i + 3;\n+      translate_cards(CardsPerRegion, i, &cards1[i], 1);\n+    }\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+\n+    ASSERT_TRUE(card_set.num_containers() == ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    \/\/ Generate non-prime numbers from 1 to 1000\n+    uint count = 0;\n+    for (uint i = 2; i < 33; i++) {\n+      if (!card_set.contains_card(100, i)) {\n+        for (uint j = i * i; j < 1000; j += i) {\n+          G1AddCardResult res = card_set.add_card(100, j);\n+          count += (res == Added);\n+        }\n+      }\n+    }\n+\n+    G1CountCardsOccupied cl;\n+    card_set.iterate_containers(&cl);\n+\n+    ASSERT_TRUE(count == card_set.occupied());\n+    ASSERT_TRUE(card_set.occupied() == cl.num_occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+  { \/\/ Test coarsening to full\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint count = 0;\n+    uint i = 10;\n+    uint bitmap_threshold = config.cards_in_howl_bitmap_threshold();\n+    for (; i <  bitmap_threshold + 10; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    G1AddCardResult res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 1);\n+    \/\/ Adding above card should have coarsened Bitmap -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(config.num_cards_in_howl_bitmap() == card_set.occupied());\n+\n+    res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    uint threshold = config.cards_in_howl_threshold();\n+    uint adjusted_threshold = config.cards_in_howl_bitmap_threshold() * config.num_buckets_in_howl();\n+    i = config.num_cards_in_howl_bitmap();\n+    count = i;\n+    for (; i <  threshold; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    res = card_set.add_card(99, CardsPerRegion - 1);\n+    \/\/ Adding above card should have coarsened Howl -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(CardsPerRegion == card_set.occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    res = card_set.add_card(99, CardsPerRegion - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == config.max_cards_in_region());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+}\n+\n+class G1CardSetMtTestTask : public AbstractGangTask {\n+  G1CardSet* _card_set;\n+\n+  size_t _added;\n+  size_t _found;\n+\n+public:\n+  G1CardSetMtTestTask(G1CardSet* card_set) :\n+    AbstractGangTask(\"\"),\n+    _card_set(card_set),\n+    _added(0),\n+    _found(0) { }\n+\n+  void work(uint worker_id) {\n+    uint seed = worker_id;\n+    size_t added = 0;\n+    size_t found = 0;\n+\n+    for (uint i = 0; i < 100000; i++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      G1AddCardResult res = _card_set->add_card(region, card);\n+\n+      ASSERT_TRUE(res == Added || res == Found);\n+      if (res == Added) {\n+        added++;\n+      } else if (res == Found) {\n+        found++;\n+      }\n+    }\n+    Atomic::add(&_added, added);\n+    Atomic::add(&_found, found);\n+  }\n+\n+  size_t added() const { return _added; }\n+  size_t found() const { return _found; }\n+};\n+\n+void G1CardSetTest::cardset_mt_test() {\n+  const uint CardsPerRegion = 16384;\n+  const double FullCardSetThreshold = 1.0;\n+  const uint BitmapCoarsenThreshold = 1.0;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 120, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  G1CardSet card_set(&config, &mm);\n+\n+  const uint num_workers = workers()->active_workers();\n+\n+  G1CardSetMtTestTask cl(&card_set);\n+\n+  {\n+    GCTraceTime(Error, gc) x(\"Cardset test\");\n+    _workers->run_task(&cl, num_workers);\n+  }\n+\n+  size_t num_found = 0;\n+  \/\/ Now check the contents of the card set.\n+  for (uint i = 0; i < num_workers; i++) {\n+    uint seed = i;\n+\n+    for (uint j = 0; j < 100000; j++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      bool contains = card_set.contains_card(region, card);\n+      ASSERT_TRUE(contains);\n+\n+      num_found += contains;\n+    }\n+  }\n+\n+  ASSERT_TRUE(num_found == cl.added() + cl.found());\n+\n+  G1CountCardsClosure count_cards;\n+  card_set.iterate_cards(count_cards);\n+\n+  check_iteration(&card_set, count_cards._num_cards, false \/* add_was_single_threaded *\/);\n+\n+  \/\/ During coarsening we try to unblock concurrent threads as soon as possible,\n+  \/\/ so we do not add the cards from the smaller CardSetContainer to the larger\n+  \/\/ one immediately, allowing addition by concurrent threads after allocating\n+  \/\/ the space immediately. So the amount of \"successfully added\" results may be\n+  \/\/ (and in case of many threads typically is) higher than the number of unique\n+  \/\/ cards.\n+  ASSERT_TRUE(count_cards._num_cards <= cl.added());\n+}\n+\n+TEST_VM(G1CardSetTest, basic_cardset_test) {\n+  G1CardSetTest::cardset_basic_test();\n+}\n+\n+TEST_VM(G1CardSetTest, mt_cardset_test) {\n+  G1CardSetTest::cardset_mt_test();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CardSetContainersTest : public ::testing::Test {\n+public:\n+  G1CardSetContainersTest() { }\n+  ~G1CardSetContainersTest() { }\n+\n+  static uint cards_per_inlineptr_set(uint bits_per_card) {\n+    return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+  }\n+\n+  static void cardset_inlineptr_test(uint bits_per_card);\n+  static void cardset_array_test(uint cards_per_array);\n+  static void cardset_bitmap_test(uint threshold, uint size_in_bits);\n+};\n+\n+class G1FindCardsInRange : public StackObj {\n+  uint _num_cards;\n+  uint _range_min;\n+  bool* _cards_found;\n+public:\n+  G1FindCardsInRange(uint range_min, uint range_max) :\n+    _num_cards(range_max - range_min + 1),\n+    _range_min(range_min),\n+    _cards_found(NEW_C_HEAP_ARRAY(bool, _num_cards, mtGC)) {\n+    for (uint i = 0; i < _num_cards; i++) {\n+      _cards_found[i] = false;\n+    }\n+  }\n+\n+  void verify_all_found() {\n+    verify_part_found(_num_cards);\n+  }\n+\n+  void verify_part_found(uint num) {\n+    for (uint i = 0; i < num; i++) {\n+      ASSERT_TRUE(_cards_found[i]);\n+    }\n+  }\n+\n+  ~G1FindCardsInRange() {\n+    FREE_C_HEAP_ARRAY(mtGC, _cards_found);\n+  }\n+  void operator()(uint card) {\n+    ASSERT_TRUE((card - _range_min) < _num_cards);\n+    ASSERT_FALSE(_cards_found[card - _range_min]); \/\/ Must not have been found yet.\n+    _cards_found[card - _range_min] = true;\n+  }\n+};\n+\n+void G1CardSetContainersTest::cardset_inlineptr_test(uint bits_per_card) {\n+  const uint CardsPerSet = cards_per_inlineptr_set(bits_per_card);\n+\n+  G1AddCardResult res;\n+\n+  G1CardSet::CardSetPtr value = G1CardSetInlinePtr();\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+      ASSERT_TRUE(res == Added);\n+    }\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+    }\n+  }\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(CardsPerSet + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Boundary cards should not be in the set.\n+  {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(!cards.contains(0, bits_per_card));\n+    ASSERT_TRUE(!cards.contains(CardsPerSet + 1, bits_per_card));\n+  }\n+\n+  \/\/ Verify iteration finds all cards too and only those.\n+  {\n+    G1FindCardsInRange found(1, CardsPerSet);\n+    G1CardSetInlinePtr cards(value);\n+    cards.iterate(found, bits_per_card);\n+    found.verify_all_found();\n+  }\n+}\n+\n+void G1CardSetContainersTest::cardset_array_test(uint cards_per_array) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetArray::size_in_bytes(cards_per_array), mtGC);\n+  G1CardSetArray* cards = new (cardset_data) G1CardSetArray(1, cards_per_array);\n+\n+  ASSERT_TRUE(cards->contains(1)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_entries() == 1); \/\/ Check it's the only one.\n+\n+  G1AddCardResult res;\n+\n+  \/\/ Add some elements\n+  for (uint i = 1; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  \/\/ Check they are in the container.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(cards_per_array + 1);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0));\n+  ASSERT_TRUE(!cards->contains(cards_per_array + 1));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, cards_per_array);\n+    cards->iterate(found);\n+    found.verify_all_found();\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+void G1CardSetContainersTest::cardset_bitmap_test(uint threshold, uint size_in_bits) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetBitMap::size_in_bytes(size_in_bits), mtGC);\n+  G1CardSetBitMap* cards = new (cardset_data) G1CardSetBitMap(1, size_in_bits);\n+\n+  ASSERT_TRUE(cards->contains(1, size_in_bits)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_bits_set() == 1); \/\/ Should be the only one.\n+\n+  G1AddCardResult res;\n+\n+  for (uint i = 1; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(threshold + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0, size_in_bits));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, threshold + 1);\n+    cards->iterate(found, size_in_bits, 0);\n+    found.verify_part_found(threshold);\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_inptr_test) {\n+  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+\n+  for (uint i = min; i <= max; i++) {\n+    G1CardSetContainersTest::cardset_inlineptr_test(i - CardTable::card_shift);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_array_test) {\n+  uint array_sizes[] = { 5, 9, 63, 77, 127 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(array_sizes); i++) {\n+    size_t const max_cards_in_set = ARRAY_SIZE(array_sizes);\n+    G1CardSetContainersTest::cardset_array_test(max_cards_in_set);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_bitmap_test) {\n+  uint bit_sizes[] = { 64, 2048 };\n+  uint threshold_sizes[] = { 17, 330 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(bit_sizes); i++) {\n+    G1CardSetContainersTest::cardset_bitmap_test(threshold_sizes[i], bit_sizes[i]);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -44,1 +44,0 @@\n-  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -48,0 +47,1 @@\n+  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -54,1 +54,0 @@\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -58,0 +57,1 @@\n+  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -82,3 +82,0 @@\n-\n-  \/\/ Enabling all is not the same as G1VerifyAll\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1HeapVerifier.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,2 +145,3 @@\n-    while (queue.peek()->time() < now) {\n-      TestTask* task = (TestTask*) queue.pop();\n+    while (queue.front()->time() < now) {\n+      TestTask* task = (TestTask*) queue.front();\n+      queue.remove_front();\n@@ -156,1 +157,2 @@\n-    G1ServiceTask* task = queue.pop();\n+    G1ServiceTask* task = queue.front();\n+    queue.remove_front();\n@@ -162,1 +164,1 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, pop_empty,\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, remove_from_empty,\n@@ -165,1 +167,1 @@\n-  queue.pop();\n+  queue.remove_front();\n@@ -168,1 +170,1 @@\n-TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, peek_empty,\n+TEST_VM_ASSERT_MSG(G1ServiceTaskQueue, get_from_empty,\n@@ -171,1 +173,1 @@\n-  queue.peek();\n+  queue.front();\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1ServiceThread.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-class ScopedDisabledBiasedLocking {\n-  bool _orig;\n-public:\n-  ScopedDisabledBiasedLocking() : _orig(UseBiasedLocking) { UseBiasedLocking = false; }\n-  ~ScopedDisabledBiasedLocking() { UseBiasedLocking = _orig; }\n-};\n-\n@@ -59,4 +52,0 @@\n-  \/\/ Need to disable biased locking to easily\n-  \/\/ create oops that \"must_be_preseved\"\n-  ScopedDisabledBiasedLocking dbl;\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+#ifndef LP64\n+\/\/ These tests below are about alignment issues when mixing Amalloc and AmallocWords.\n+\/\/ Since on 64-bit these APIs offer the same alignment, they only matter for 32-bit.\n+\n+TEST_VM(Arena, mixed_alignment_allocation) {\n+  \/\/ Test that mixed alignment allocations work and provide allocations with the correct\n+  \/\/ alignment\n+  Arena ar(mtTest);\n+  void* p1 = ar.AmallocWords(BytesPerWord);\n+  void* p2 = ar.Amalloc(BytesPerLong);\n+  ASSERT_TRUE(is_aligned(p1, BytesPerWord));\n+  ASSERT_TRUE(is_aligned(p2, ARENA_AMALLOC_ALIGNMENT));\n+}\n+\n+TEST_VM(Arena, Arena_with_crooked_initial_size) {\n+  \/\/ Test that an arena with a crooked, not 64-bit aligned initial size\n+  \/\/ works\n+  Arena ar(mtTest, 4097);\n+  void* p1 = ar.AmallocWords(BytesPerWord);\n+  void* p2 = ar.Amalloc(BytesPerLong);\n+  ASSERT_TRUE(is_aligned(p1, BytesPerWord));\n+  ASSERT_TRUE(is_aligned(p2, ARENA_AMALLOC_ALIGNMENT));\n+}\n+\n+TEST_VM(Arena, Arena_grows_large_unaligned) {\n+  \/\/ Test that if the arena grows with a large unaligned value, nothing bad happens.\n+  \/\/ We trigger allocation of a new, large, unaligned chunk with a non-standard size\n+  \/\/ (only possible on 32-bit when allocating with word alignment).\n+  \/\/ Then we alloc some more. If Arena::grow() does not correctly align, on 32-bit\n+  \/\/ something should assert at some point.\n+  Arena ar(mtTest, 100); \/\/ first chunk is small\n+  void* p = ar.AmallocWords(Chunk::size + BytesPerWord); \/\/ if Arena::grow() misaligns, this asserts\n+  \/\/ some more allocations for good measure\n+  for (int i = 0; i < 100; i ++) {\n+    ar.Amalloc(1);\n+  }\n+}\n+\n+#endif \/\/  LP64\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -40,0 +42,23 @@\n+\n+TEST_VM(InstanceKlass, class_loader_printer) {\n+  ResourceMark rm;\n+  oop loader = SystemDictionary::java_platform_loader();\n+  stringStream st;\n+  loader->print_on(&st);\n+  \/\/ See if injected loader_data field is printed in string\n+  ASSERT_TRUE(strstr(st.as_string(), \"internal 'loader_data'\") != NULL) << \"Must contain internal fields\";\n+  st.reset();\n+  \/\/ See if mirror injected fields are printed.\n+  oop mirror = vmClasses::ClassLoader_klass()->java_mirror();\n+  mirror->print_on(&st);\n+  ASSERT_TRUE(strstr(st.as_string(), \"internal 'protection_domain'\") != NULL) << \"Must contain internal fields\";\n+  \/\/ We should test other printing functions too.\n+#ifndef PRODUCT\n+  st.reset();\n+  \/\/ method printing is non-product\n+  Method* method = vmClasses::ClassLoader_klass()->methods()->at(0);  \/\/ we know there's a method here!\n+  method->print_on(&st);\n+  ASSERT_TRUE(strstr(st.as_string(), \"method holder:\") != NULL) << \"Must contain method_holder field\";\n+  ASSERT_TRUE(strstr(st.as_string(), \"'java\/lang\/ClassLoader'\") != NULL) << \"Must be in ClassLoader\";\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/oops\/test_instanceKlass.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -54,6 +53,0 @@\n-static void assert_not_test_pattern(Handle object, const char* pattern) {\n-  stringStream st;\n-  object->print_on(&st);\n-  ASSERT_FALSE(test_pattern(&st, pattern)) << pattern << \" found in \" << st.as_string();\n-}\n-\n@@ -96,21 +89,1 @@\n-  if (UseBiasedLocking && BiasedLocking::enabled()) {\n-    \/\/ Can't test this with biased locking disabled.\n-    \/\/ Biased locking is initially enabled for this java.lang.Byte object.\n-    assert_test_pattern(h_obj, \"is_biased\");\n-\n-    \/\/ Lock using biased locking.\n-    BasicObjectLock lock;\n-    lock.set_obj(obj);\n-    markWord prototype_header = obj->klass()->prototype_header();\n-    markWord mark = obj->mark();\n-    markWord biased_mark = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n-    obj->set_mark(biased_mark);\n-    \/\/ Look for the biased_locker in markWord, not prototype_header.\n-#ifdef _LP64\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x0000000000000000\");\n-#else\n-    assert_not_test_pattern(h_obj, \"mark(is_biased biased_locker=0x00000000\");\n-#endif\n-  }\n-\n-  \/\/ Same thread tries to lock it again.\n+  \/\/ Thread tries to lock it.\n@@ -121,2 +94,0 @@\n-\n-  \/\/ This is no longer biased, because ObjectLocker revokes the bias.\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,17 @@\n+static void startTestThread(JavaThread* thread, const char* name) {\n+  EXCEPTION_MARK;\n+  HandleMark hm(THREAD);\n+  Handle thread_oop;\n+\n+  \/\/ This code can be called from the main thread, which is _thread_in_native,\n+  \/\/ or by an existing JavaTestThread, which is _thread_in_vm.\n+  if (THREAD->thread_state() == _thread_in_native) {\n+    ThreadInVMfromNative tivfn(THREAD);\n+    thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n+  } else {\n+    thread_oop = JavaThread::create_system_thread_object(name, false \/* not visible *\/, CHECK);\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n+  }\n+}\n+\n@@ -47,1 +65,0 @@\n-public:\n@@ -50,12 +67,4 @@\n-  VMThreadBlocker() {}\n-  virtual ~VMThreadBlocker() {}\n-  const char* get_thread_name_string(char* buf, int buflen) const {\n-    return \"VMThreadBlocker\";\n-  }\n-  void run() {\n-    this->set_thread_state(_thread_in_vm);\n-    {\n-      MutexLocker ml(Threads_lock);\n-      Threads::add(this);\n-    }\n-    VM_StopSafepoint ss(&_ready, &_unblock);\n+\n+  static void blocker_thread_entry(JavaThread* thread, TRAPS) {\n+    VMThreadBlocker* t = static_cast<VMThreadBlocker*>(thread);\n+    VM_StopSafepoint ss(&t->_ready, &t->_unblock);\n@@ -65,6 +74,1 @@\n-  \/\/ Override as JavaThread::post_run() calls JavaThread::exit which\n-  \/\/ expects a valid thread object oop.\n-  virtual void post_run() {\n-    Threads::remove(this, false);\n-    this->smr_delete();\n-  }\n+  VMThreadBlocker() : JavaThread(&blocker_thread_entry) {};\n@@ -72,6 +76,10 @@\n-  void doit() {\n-    if (os::create_thread(this, os::os_thread)) {\n-      os::start_thread(this);\n-    } else {\n-      ASSERT_TRUE(false);\n-    }\n+  virtual ~VMThreadBlocker() {}\n+\n+public:\n+  \/\/ Convenience method for client code\n+  static VMThreadBlocker* start() {\n+    const char* name = \"VMThreadBlocker\";\n+    VMThreadBlocker* thread = new VMThreadBlocker();\n+    JavaThread::vm_exit_on_osthread_failure(thread);\n+    startTestThread(thread, name);\n+    return thread;\n@@ -79,0 +87,1 @@\n+\n@@ -89,1 +98,0 @@\n-public:\n@@ -91,0 +99,2 @@\n+\n+protected:\n@@ -92,1 +102,2 @@\n-    : _post(post) {\n+    : JavaThread(&test_thread_entry), _post(post) {\n+    JavaThread::vm_exit_on_osthread_failure(this);\n@@ -96,10 +107,4 @@\n-  const char* get_thread_name_string(char* buf, int buflen) const {\n-    return \"JavaTestThread\";\n-  }\n-\n-  void pre_run() {\n-    this->set_thread_state(_thread_in_vm);\n-    {\n-      MutexLocker ml(Threads_lock);\n-      Threads::add(this);\n-    }\n+public:\n+  \/\/ simplified starting for callers and subclasses\n+  void doit() {\n+    startTestThread(this, \"JavaTestThread\");\n@@ -110,18 +115,4 @@\n-  void run() {\n-    main_run();\n-  }\n-\n-  \/\/ Override as JavaThread::post_run() calls JavaThread::exit which\n-  \/\/ expects a valid thread object oop. And we need to call signal.\n-  void post_run() {\n-    Threads::remove(this, false);\n-    _post->signal();\n-    this->smr_delete();\n-  }\n-\n-  void doit() {\n-    if (os::create_thread(this, os::os_thread)) {\n-      os::start_thread(this);\n-    } else {\n-      ASSERT_TRUE(false);\n-    }\n+  static void test_thread_entry(JavaThread* thread, TRAPS) {\n+    JavaTestThread* t = static_cast<JavaTestThread*>(thread);\n+    t->main_run();\n+    t->_post->signal();\n@@ -133,1 +124,0 @@\n-public:\n@@ -135,0 +125,1 @@\n+public:\n@@ -150,2 +141,2 @@\n-  VMThreadBlocker* blocker = new VMThreadBlocker();\n-  blocker->doit();\n+  VMThreadBlocker* blocker = VMThreadBlocker::start();\n+\n@@ -165,2 +156,2 @@\n-  VMThreadBlocker* blocker = new VMThreadBlocker();\n-  blocker->doit();\n+  VMThreadBlocker* blocker = VMThreadBlocker::start();\n+\n","filename":"test\/hotspot\/gtest\/threadHelper.inline.hpp","additions":51,"deletions":60,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1068,0 +1068,2 @@\n+  Semaphore run;\n+\n@@ -1069,2 +1071,2 @@\n-  MT_BD_Thread(Semaphore* post, TestTable::BulkDeleteTask* bd)\n-    : JavaTestThread(post), _bd(bd){}\n+  MT_BD_Thread(Semaphore* post)\n+    : JavaTestThread(post) {}\n@@ -1073,0 +1075,1 @@\n+    run.wait();\n@@ -1077,0 +1080,5 @@\n+  void set_bd_task(TestTable::BulkDeleteTask* bd) {\n+    _bd = bd;\n+    run.signal();\n+  }\n+\n@@ -1101,2 +1109,0 @@\n-    TestTable::BulkDeleteTask bdt(cht, true \/* mt *\/ );\n-    EXPECT_TRUE(bdt.prepare(this)) << \"Uncontended prepare must work.\";\n@@ -1104,0 +1110,1 @@\n+    \/\/ Must create and start threads before acquiring mutex inside BulkDeleteTask.\n@@ -1106,1 +1113,1 @@\n-      tt[i] = new MT_BD_Thread(&done, &bdt);\n+      tt[i] = new MT_BD_Thread(&done);\n@@ -1110,0 +1117,7 @@\n+    TestTable::BulkDeleteTask bdt(cht, true \/* mt *\/ );\n+    EXPECT_TRUE(bdt.prepare(this)) << \"Uncontended prepare must work.\";\n+\n+    for (int i = 0; i < 4; i++) {\n+      tt[i]->set_bd_task(&bdt);\n+    }\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/lockFreeQueue.inline.hpp\"\n-#include \"utilities\/pair.hpp\"\n-#include \"threadHelper.inline.hpp\"\n-#include \"unittest.hpp\"\n-#include <new>\n-\n-class LockFreeQueueTestElement {\n-  typedef LockFreeQueueTestElement Element;\n-\n-  Element* volatile _entry;\n-  Element* volatile _entry1;\n-  size_t _id;\n-\n-  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n-  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n-\n-public:\n-  class TestQueue: public LockFreeQueue<Element, &entry_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-  class TestQueue1: public LockFreeQueue<Element, &entry1_ptr> {\n-  public:\n-    Element* pop() {\n-      using Status = LockFreeQueuePopStatus;\n-      while (true) {\n-        Pair<Status, Element*> pop_result = try_pop();\n-        if (pop_result.first == Status::success) {\n-          return pop_result.second;\n-        }\n-        \/\/ Retry until success.\n-      }\n-    }\n-  };\n-\n-  LockFreeQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n-  size_t id() const { return _id; }\n-  void set_id(size_t value) { _id = value; }\n-  Element* next() { return _entry; }\n-  Element* next1() { return _entry1; }\n-};\n-\n-typedef LockFreeQueueTestElement Element;\n-typedef Element::TestQueue TestQueue;\n-typedef Element::TestQueue1 TestQueue1;\n-\n-static void initialize(Element* elements, size_t size, TestQueue* queue) {\n-  for (size_t i = 0; i < size; ++i) {\n-    elements[i].set_id(i);\n-  }\n-  ASSERT_TRUE(queue->empty());\n-  ASSERT_EQ(0u, queue->length());\n-  ASSERT_TRUE(queue->pop() == NULL);\n-  ASSERT_TRUE(queue->top() == NULL);\n-\n-  for (size_t id = 0; id < size; ++id) {\n-    ASSERT_EQ(id, queue->length());\n-    Element* e = &elements[id];\n-    ASSERT_EQ(id, e->id());\n-    queue->push(*e);\n-    ASSERT_FALSE(queue->empty());\n-    \/\/ top() is always the oldest element.\n-    ASSERT_EQ(&elements[0], queue->top());\n-  }\n-}\n-\n-class LockFreeQueueTestBasics : public ::testing::Test {\n-public:\n-  LockFreeQueueTestBasics();\n-\n-  static const size_t nelements = 10;\n-  Element elements[nelements];\n-  TestQueue queue;\n-};\n-\n-const size_t LockFreeQueueTestBasics::nelements;\n-\n-LockFreeQueueTestBasics::LockFreeQueueTestBasics() : queue() {\n-  initialize(elements, nelements, &queue);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, pop) {\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_FALSE(queue.empty());\n-    ASSERT_EQ(nelements - i, queue.length());\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, append) {\n-  TestQueue other_queue;\n-  ASSERT_TRUE(other_queue.empty());\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.top() == NULL);\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-\n-  Pair<Element*, Element*> pair = queue.take_all();\n-  other_queue.append(*pair.first, *pair.second);\n-  ASSERT_EQ(nelements, other_queue.length());\n-  ASSERT_TRUE(queue.empty());\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue.top() == NULL);\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, other_queue.length());\n-    Element* e = other_queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-  }\n-  ASSERT_EQ(0u, other_queue.length());\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n-}\n-\n-TEST_F(LockFreeQueueTestBasics, two_queues) {\n-  TestQueue1 queue1;\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-\n-  for (size_t id = 0; id < nelements; ++id) {\n-    queue1.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, queue1.length());\n-  Element* e0 = queue.top();\n-  Element* e1 = queue1.top();\n-  while (true) {\n-    ASSERT_EQ(e0, e1);\n-    if (e0 == NULL) break;\n-    e0 = e0->next();\n-    e1 = e1->next1();\n-  }\n-\n-  for (size_t i = 0; i < nelements; ++i) {\n-    ASSERT_EQ(nelements - i, queue.length());\n-    ASSERT_EQ(nelements - i, queue1.length());\n-\n-    Element* e = queue.pop();\n-    ASSERT_TRUE(e != NULL);\n-    ASSERT_EQ(&elements[i], e);\n-    ASSERT_EQ(i, e->id());\n-\n-    Element* e1 = queue1.pop();\n-    ASSERT_TRUE(e1 != NULL);\n-    ASSERT_EQ(&elements[i], e1);\n-    ASSERT_EQ(i, e1->id());\n-\n-    ASSERT_EQ(e, e1);\n-  }\n-  ASSERT_EQ(0u, queue.length());\n-  ASSERT_EQ(0u, queue1.length());\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue1.pop() == NULL);\n-}\n-\n-class LockFreeQueueTestThread : public JavaTestThread {\n-  uint _id;\n-  TestQueue* _from;\n-  TestQueue* _to;\n-  volatile size_t* _processed;\n-  size_t _process_limit;\n-  size_t _local_processed;\n-  volatile bool _ready;\n-\n-public:\n-  LockFreeQueueTestThread(Semaphore* post,\n-                          uint id,\n-                          TestQueue* from,\n-                          TestQueue* to,\n-                          volatile size_t* processed,\n-                          size_t process_limit) :\n-    JavaTestThread(post),\n-    _id(id),\n-    _from(from),\n-    _to(to),\n-    _processed(processed),\n-    _process_limit(process_limit),\n-    _local_processed(0),\n-    _ready(false)\n-  {}\n-\n-  virtual void main_run() {\n-    Atomic::release_store_fence(&_ready, true);\n-    while (true) {\n-      Element* e = _from->pop();\n-      if (e != NULL) {\n-        _to->push(*e);\n-        Atomic::inc(_processed);\n-        ++_local_processed;\n-      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n-        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n-        return;\n-      }\n-    }\n-  }\n-\n-  bool ready() const { return Atomic::load_acquire(&_ready); }\n-};\n-\n-TEST_VM(LockFreeQueueTest, stress) {\n-  Semaphore post;\n-  TestQueue initial_queue;\n-  TestQueue start_queue;\n-  TestQueue middle_queue;\n-  TestQueue final_queue;\n-  volatile size_t stage1_processed = 0;\n-  volatile size_t stage2_processed = 0;\n-\n-  const size_t nelements = 10000;\n-  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n-  for (size_t id = 0; id < nelements; ++id) {\n-    ::new (&elements[id]) Element(id);\n-    initial_queue.push(elements[id]);\n-  }\n-  ASSERT_EQ(nelements, initial_queue.length());\n-\n-  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n-  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n-  \/\/ - all threads in a stage count the number of elements processed in\n-  \/\/   their corresponding stageN_processed counter.\n-\n-  const uint stage1_threads = 2;\n-  const uint stage2_threads = 2;\n-  const uint nthreads = stage1_threads + stage2_threads;\n-  LockFreeQueueTestThread* threads[nthreads] = {};\n-\n-  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n-    TestQueue* from = &start_queue;\n-    TestQueue* to = &middle_queue;\n-    volatile size_t* processed = &stage1_processed;\n-    if (i >= stage1_threads) {\n-      from = &middle_queue;\n-      to = &final_queue;\n-      processed = &stage2_processed;\n-    }\n-    threads[i] =\n-      new LockFreeQueueTestThread(&post, i, from, to, processed, nelements);\n-    threads[i]->doit();\n-    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n-  }\n-\n-  \/\/ Transfer elements to start_queue to start test.\n-  Pair<Element*, Element*> pair = initial_queue.take_all();\n-  start_queue.append(*pair.first, *pair.second);\n-\n-  \/\/ Wait for all threads to complete.\n-  for (uint i = 0; i < nthreads; ++i) {\n-    post.wait();\n-  }\n-\n-  \/\/ Verify expected state.\n-  ASSERT_EQ(nelements, stage1_processed);\n-  ASSERT_EQ(nelements, stage2_processed);\n-  ASSERT_EQ(0u, initial_queue.length());\n-  ASSERT_EQ(0u, start_queue.length());\n-  ASSERT_EQ(0u, middle_queue.length());\n-  ASSERT_EQ(nelements, final_queue.length());\n-  while (final_queue.pop() != NULL) {}\n-\n-  FREE_C_HEAP_ARRAY(Element, elements);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeQueue.cpp","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+#include \"utilities\/pair.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+#include <new>\n+\n+class NonblockingQueueTestElement {\n+  typedef NonblockingQueueTestElement Element;\n+\n+  Element* volatile _entry;\n+  Element* volatile _entry1;\n+  size_t _id;\n+\n+  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n+  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n+\n+public:\n+  using TestQueue = NonblockingQueue<Element, &entry_ptr>;\n+  using TestQueue1 = NonblockingQueue<Element, &entry1_ptr>;\n+\n+  NonblockingQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n+  size_t id() const { return _id; }\n+  void set_id(size_t value) { _id = value; }\n+  Element* next() { return _entry; }\n+  Element* next1() { return _entry1; }\n+};\n+\n+typedef NonblockingQueueTestElement Element;\n+typedef Element::TestQueue TestQueue;\n+typedef Element::TestQueue1 TestQueue1;\n+\n+static void initialize(Element* elements, size_t size, TestQueue* queue) {\n+  for (size_t i = 0; i < size; ++i) {\n+    elements[i].set_id(i);\n+  }\n+  ASSERT_TRUE(queue->empty());\n+  ASSERT_EQ(0u, queue->length());\n+  ASSERT_TRUE(queue->is_end(queue->first()));\n+  ASSERT_TRUE(queue->pop() == NULL);\n+\n+  for (size_t id = 0; id < size; ++id) {\n+    ASSERT_EQ(id, queue->length());\n+    Element* e = &elements[id];\n+    ASSERT_EQ(id, e->id());\n+    queue->push(*e);\n+    ASSERT_FALSE(queue->empty());\n+    \/\/ first() is always the oldest element.\n+    ASSERT_EQ(&elements[0], queue->first());\n+  }\n+}\n+\n+class NonblockingQueueTestBasics : public ::testing::Test {\n+public:\n+  NonblockingQueueTestBasics();\n+\n+  static const size_t nelements = 10;\n+  Element elements[nelements];\n+  TestQueue queue;\n+};\n+\n+const size_t NonblockingQueueTestBasics::nelements;\n+\n+NonblockingQueueTestBasics::NonblockingQueueTestBasics() : queue() {\n+  initialize(elements, nelements, &queue);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, pop) {\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_FALSE(queue.empty());\n+    ASSERT_EQ(nelements - i, queue.length());\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, append) {\n+  TestQueue other_queue;\n+  ASSERT_TRUE(other_queue.empty());\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.is_end(other_queue.first()));\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+\n+  Pair<Element*, Element*> pair = queue.take_all();\n+  other_queue.append(*pair.first, *pair.second);\n+  ASSERT_EQ(nelements, other_queue.length());\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.is_end(queue.first()));\n+  ASSERT_TRUE(queue.pop() == NULL);\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, other_queue.length());\n+    Element* e = other_queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+}\n+\n+TEST_F(NonblockingQueueTestBasics, two_queues) {\n+  TestQueue1 queue1;\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+\n+  for (size_t id = 0; id < nelements; ++id) {\n+    queue1.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, queue1.length());\n+  Element* e0 = queue.first();\n+  Element* e1 = queue1.first();\n+  ASSERT_TRUE(e0 != NULL);\n+  ASSERT_TRUE(e1 != NULL);\n+  ASSERT_FALSE(queue.is_end(e0));\n+  ASSERT_FALSE(queue1.is_end(e1));\n+  while (!queue.is_end(e0) && !queue1.is_end(e1)) {\n+    ASSERT_EQ(e0, e1);\n+    e0 = e0->next();\n+    e1 = e1->next1();\n+  }\n+  ASSERT_TRUE(queue.is_end(e0));\n+  ASSERT_TRUE(queue1.is_end(e1));\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, queue.length());\n+    ASSERT_EQ(nelements - i, queue1.length());\n+\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+\n+    Element* e1 = queue1.pop();\n+    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_EQ(&elements[i], e1);\n+    ASSERT_EQ(i, e1->id());\n+\n+    ASSERT_EQ(e, e1);\n+  }\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_EQ(0u, queue1.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+}\n+\n+class NonblockingQueueTestThread : public JavaTestThread {\n+  uint _id;\n+  TestQueue* _from;\n+  TestQueue* _to;\n+  volatile size_t* _processed;\n+  size_t _process_limit;\n+  size_t _local_processed;\n+  volatile bool _ready;\n+\n+public:\n+  NonblockingQueueTestThread(Semaphore* post,\n+                             uint id,\n+                             TestQueue* from,\n+                             TestQueue* to,\n+                             volatile size_t* processed,\n+                             size_t process_limit) :\n+    JavaTestThread(post),\n+    _id(id),\n+    _from(from),\n+    _to(to),\n+    _processed(processed),\n+    _process_limit(process_limit),\n+    _local_processed(0),\n+    _ready(false)\n+  {}\n+\n+  virtual void main_run() {\n+    Atomic::release_store_fence(&_ready, true);\n+    while (true) {\n+      Element* e = _from->pop();\n+      if (e != NULL) {\n+        _to->push(*e);\n+        Atomic::inc(_processed);\n+        ++_local_processed;\n+      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n+        return;\n+      }\n+    }\n+  }\n+\n+  bool ready() const { return Atomic::load_acquire(&_ready); }\n+};\n+\n+TEST_VM(NonblockingQueueTest, stress) {\n+  Semaphore post;\n+  TestQueue initial_queue;\n+  TestQueue start_queue;\n+  TestQueue middle_queue;\n+  TestQueue final_queue;\n+  volatile size_t stage1_processed = 0;\n+  volatile size_t stage2_processed = 0;\n+\n+  const size_t nelements = 10000;\n+  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n+  for (size_t id = 0; id < nelements; ++id) {\n+    ::new (&elements[id]) Element(id);\n+    initial_queue.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, initial_queue.length());\n+\n+  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n+  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n+  \/\/ - all threads in a stage count the number of elements processed in\n+  \/\/   their corresponding stageN_processed counter.\n+\n+  const uint stage1_threads = 2;\n+  const uint stage2_threads = 2;\n+  const uint nthreads = stage1_threads + stage2_threads;\n+  NonblockingQueueTestThread* threads[nthreads] = {};\n+\n+  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n+    TestQueue* from = &start_queue;\n+    TestQueue* to = &middle_queue;\n+    volatile size_t* processed = &stage1_processed;\n+    if (i >= stage1_threads) {\n+      from = &middle_queue;\n+      to = &final_queue;\n+      processed = &stage2_processed;\n+    }\n+    threads[i] =\n+      new NonblockingQueueTestThread(&post, i, from, to, processed, nelements);\n+    threads[i]->doit();\n+    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n+  }\n+\n+  \/\/ Transfer elements to start_queue to start test.\n+  Pair<Element*, Element*> pair = initial_queue.take_all();\n+  start_queue.append(*pair.first, *pair.second);\n+\n+  \/\/ Wait for all threads to complete.\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+\n+  \/\/ Verify expected state.\n+  ASSERT_EQ(nelements, stage1_processed);\n+  ASSERT_EQ(nelements, stage2_processed);\n+  ASSERT_EQ(0u, initial_queue.length());\n+  ASSERT_EQ(0u, start_queue.length());\n+  ASSERT_EQ(0u, middle_queue.length());\n+  ASSERT_EQ(nelements, final_queue.length());\n+  while (final_queue.pop() != NULL) {}\n+\n+  FREE_C_HEAP_ARRAY(Element, elements);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -43,4 +43,0 @@\n-\n-serviceability\/dcmd\/framework\/HelpTest.java                   8268433 windows-x64\n-serviceability\/dcmd\/framework\/InvalidCommandTest.java         8268433 windows-x64\n-serviceability\/dcmd\/framework\/VMVersionTest.java              8268433 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+applications\/jcstress\/copy.java 8229852 linux-x64\n+\n@@ -111,2 +113,0 @@\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java 8214032 generic-all\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java 8224150 generic-all\n@@ -115,1 +115,0 @@\n-serviceability\/jvmti\/CompiledMethodLoad\/Zombie.java 8245877 linux-aarch64\n@@ -122,0 +121,2 @@\n+serviceability\/dcmd\/gc\/HeapDumpAllTest.java 8270341 generic-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccessStressGCM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @author Yi Yang\n+ * @bug 8265518\n+ * @summary C1 intrinsic support for jdk.internal.util.Preconditions.checkIndex\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*TestCheckIndexC1Intrinsic.check*\n+ *                   -XX:CompileCommand=compileonly,*TestCheckIndexC1Intrinsic.check*\n+ *                   compiler.c1.TestCheckIndexC1Intrinsic\n+ *\/\n+\n+package compiler.c1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.util.Preconditions;\n+\n+public class TestCheckIndexC1Intrinsic {\n+    static int limit = 100;\n+\n+    private static class MyException extends RuntimeException {\n+        public MyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    static void check0() {\n+        long res = Preconditions.checkIndex(0, 1, null);\n+        Asserts.assertEquals((int)res, 0);\n+        try {\n+            Preconditions.checkIndex(1, 1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, -1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, Integer.MIN_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Long.MAX_VALUE, Long.MAX_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        res = Preconditions.checkIndex(Long.MAX_VALUE - 1, Long.MAX_VALUE, null);\n+        Asserts.assertEquals(res, Long.MAX_VALUE - 1);\n+\n+        try {\n+            \/\/ read fields\n+            Preconditions.checkIndex(limit + 1, limit, (s, integers) -> new MyException(\"Reason:\" + s + \"::\" + integers));\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch(MyException e){\n+            \/\/ got it!\n+        }\n+    }\n+\n+    static void check1(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check2(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check3(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            Asserts.assertTrue(i == 9999);\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check4(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check5(int i) {\n+        Preconditions.checkIndex(i, 99999, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check6(long i) {\n+        Preconditions.checkIndex(i, 99999L, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check7(int i) {\n+        Preconditions.checkIndex(i, 99999, null);\n+    }\n+\n+    static void check8(long i) {\n+        Preconditions.checkIndex(i, 99999L, null);\n+    }\n+\n+    static void check9(int i) {\n+        Preconditions.checkIndex(i, i + 1, null);\n+    }\n+\n+    static void check10(long i) {\n+        Preconditions.checkIndex(i, i + 1L, null);\n+    }\n+\n+    public static void main(String... args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            check0();\n+\n+            check1(i);\n+            check2((long) i);\n+            check3(i);\n+            check4((long) i);\n+\n+            check5(i);\n+            check6((long) i);\n+            check7(i);\n+            check8((long) i);\n+\n+            check9(i);\n+            check10((long)i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestCheckIndexC1Intrinsic.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+            \"-XX:CompileThreshold=500\",\n@@ -72,0 +73,1 @@\n+            \"-XX:CompileThreshold=500\",\n@@ -91,0 +93,1 @@\n+            \"-XX:CompileThreshold=500\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestRangeCheckEliminated.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8062950\n- * @requires vm.flavor == \"server\"\n- * @library \/test\/lib\n- * @run driver compiler.c2.Test8062950\n- *\/\n-\n-package compiler.c2;\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class Test8062950 {\n-    private static final String CLASSNAME = \"DoesNotExist\";\n-    public static void main(String[] args) throws Exception {\n-        ProcessTools.executeTestJvm(\"-Xcomp\",\n-                                    \"-XX:-TieredCompilation\",\n-                                    \"-XX:-UseOptoBiasInlining\",\n-                                    CLASSNAME)\n-                    .shouldHaveExitValue(1)\n-                    .shouldContain(\"Error: Could not find or load main class \" + CLASSNAME)\n-                    .shouldNotContain(\"A fatal error has been detected\")\n-                    .shouldNotContain(\"Internal Error\")\n-                    .shouldNotContain(\"HotSpot Virtual Machine Error\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test8062950.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestJumpTable.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReplaceEquivPhis.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -30,0 +31,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260585\n+ * @summary AArch64: Wrong code generated for shifting right and accumulating four unsigned short integers.\n+ * @requires vm.compiler2.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestShiftRightAndAccumulate.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8217990\n- * @summary With -XX:+UseOptoBiasInlining loading the markword is replaced by 0L if EliminateLocks is disabled. assert(dmw->is_neutral()) failed: invariant fails.\n- * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n- *\n- * @library \/test\/lib \/test\/hotspot\/jtreg\n- *\n- * @build sun.hotspot.WhiteBox\n- *\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n- *                   -XX:CompileCommand=compileonly,*.TestUseOptoBiasInliningWithoutEliminateLocks::dontinline_testMethod\n- *                   -XX:CompileCommand=dontinline,*::dontinline_*\n- *                   -XX:-EliminateLocks\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                   -Xbatch\n- *                   -XX:-TieredCompilation\n- *                   compiler.c2.TestUseOptoBiasInliningWithoutEliminateLocks\n- *\/\n-\n-package compiler.c2;\n-\n-import sun.hotspot.WhiteBox;\n-\n-public class TestUseOptoBiasInliningWithoutEliminateLocks {\n-\n-    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) {\n-        new TestUseOptoBiasInliningWithoutEliminateLocks().run();\n-    }\n-\n-    public boolean warmupDone;\n-\n-    public void run() {\n-        for(int i = 0; i < 30000; i++) {\n-            dontinline_testMethod();\n-        }\n-        warmupDone = true;\n-        dontinline_testMethod();\n-    }\n-\n-    public void dontinline_testMethod() {\n-        PointXY l1 = new PointXY(4.0f, 2.0f);\n-        synchronized (l1) {\n-            dontinline_deopt();\n-        }\n-    }\n-\n-    public void dontinline_deopt() {\n-        if (warmupDone) {\n-            WB.deoptimizeFrames(false);\n-        }\n-    }\n-\n-    static class PointXY {\n-\n-        public float fritz;\n-        public float felix;\n-\n-        public PointXY(float fritz_param, float felix_param) {\n-            this.fritz = fritz_param;\n-\/\/            this.felix = felix_param;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUseOptoBiasInliningWithoutEliminateLocks.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -71,2 +71,2 @@\n-        \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n-        \"-XX:+PreferInterpreterNativeStubs\", REPLAY_FILE_OPTION};\n+        \"-XX:+CICountNative\", \"-XX:CICrashAt=1\", \"-XX:+DumpReplayDataOnError\",\n+        REPLAY_FILE_OPTION};\n@@ -79,0 +79,4 @@\n+    static interface Lambda {\n+        int value();\n+    }\n+\n@@ -81,1 +85,4 @@\n-            for (int i = 0; i < 20_000; i++) {\n+            \/\/ explicitly trigger native compilation\n+            Lambda start = () -> 0;\n+\n+            for (int i = start.value(); i < 20_000; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                if (!out.getOutput().contains(\"-XX:+TieredCompilation not supported in this VM\")) {\n+                if (Platform.isTieredSupported()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode compiler.codegen.ClearArrayTest\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*ClearArrayTest.test\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:-IdealizeClearArrayNode\n+ *                   compiler.codegen.ClearArrayTest\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/ClearArrayTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8001183\n+ * @summary incorrect results of char vectors right shift operation\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect2.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8270459\n+ * @summary the last specified inlining option should overwrite all previous\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled | vm.compiler2.enabled\n+ *\n+ * @run driver compiler.compilercontrol.TestConflictInlineCommands\n+ *\/\n+\n+package compiler.compilercontrol;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestConflictInlineCommands {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:CompileCommand=inline,*TestConflictInlineCommands::caller\",\n+                \"-XX:CompileCommand=dontinline,*TestConflictInlineCommands::caller\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*Launcher::main\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                Launcher.class.getName());\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.shouldContain(\"disallowed by CompileCommand\");\n+        analyzer.shouldNotContain(\"force inline by CompileCommand\");\n+\n+        pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:CompileCommand=dontinline,*TestConflictInlineCommands::*caller\",\n+                \"-XX:CompileCommand=inline,*TestConflictInlineCommands::caller\",\n+                \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*Launcher::main\",\n+                \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+                Launcher.class.getName());\n+\n+        analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.shouldContain(\"force inline by CompileCommand\");\n+        analyzer.shouldNotContain(\"disallowed by CompileCommand\");\n+    }\n+\n+    static int sum;\n+\n+    public static int caller(int a , int b) {\n+        return a + b;\n+    }\n+\n+    static class Launcher {\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 1000; i++) {\n+                for (int j = 0; j < 1000; j++) {\n+                    sum += caller(i, 0);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/TestConflictInlineCommands.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8270366\n+ * @summary Test corner cases of integer associative rules\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement TestAssociative\n+ *\n+ *\/\n+\n+public class TestAssociative {\n+    private static class IntParams {\n+        int a;\n+        int b;\n+        int c;\n+        public IntParams(int a, int b, int c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n+\n+    private static class LongParams {\n+        long a;\n+        long b;\n+        long c;\n+        public LongParams(long a, long b, long c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n+\n+    private static final IntParams[]  intParamsArray = {\n+        new IntParams(17, 34, 10),\n+        new IntParams(Integer.MAX_VALUE - 4, 34, 10),\n+        new IntParams(7, Integer.MAX_VALUE, 10),\n+        new IntParams(7, Integer.MAX_VALUE, Integer.MAX_VALUE),\n+        new IntParams(10, Integer.MIN_VALUE, Integer.MIN_VALUE),\n+        new IntParams(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE)\n+    };\n+\n+    private static final LongParams[] longParamsArray = {\n+        new LongParams(17, 34, 10),\n+        new LongParams(Long.MAX_VALUE - 4, 34, 10),\n+        new LongParams(7, Long.MAX_VALUE, 10),\n+        new LongParams(7, Long.MAX_VALUE, Long.MAX_VALUE),\n+        new LongParams(10, Long.MIN_VALUE, Long.MIN_VALUE),\n+        new LongParams(Long.MAX_VALUE, Long.MAX_VALUE, Long.MAX_VALUE)\n+    };\n+\n+    \/\/ Integer\n+    private static interface IntAssociativeTest {\n+        public int test(int a, int b, int c);\n+    }\n+\n+    \/\/ Integer Add\n+    private static class IntAssociativeTest0 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b + a * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest1 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b + b * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest2 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * c +  b * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest3 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b + c * a;\n+        }\n+    }\n+\n+    \/\/ Integer Substract\n+    private static class IntAssociativeTest4 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b - a * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest5 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b - b * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest6 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * c -  b * c;\n+        }\n+    }\n+\n+    private static class IntAssociativeTest7 implements IntAssociativeTest {\n+        public int test(int a, int b, int c) {\n+            return a * b - c * a;\n+        }\n+    }\n+\n+\n+    \/\/ Long\n+    private static interface LongAssociativeTest {\n+        public long test(long a, long b, long c);\n+    }\n+\n+    \/\/ Long Add\n+    private static class LongAssociativeTest0 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b + a * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest1 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b + b * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest2 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * c +  b * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest3 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b + c * a;\n+        }\n+    }\n+\n+    \/\/ Long Substract\n+    private static class LongAssociativeTest4 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b - a * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest5 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b - b * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest6 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * c -  b * c;\n+        }\n+    }\n+\n+    private static class LongAssociativeTest7 implements LongAssociativeTest {\n+        public long test(long a, long b, long c) {\n+            return a * b - c * a;\n+        }\n+    }\n+\n+    private static void runIntTest(IntAssociativeTest t) {\n+        for (IntParams p : intParamsArray) {\n+            int result = t.test(p.a, p.b, p.c);\n+            for (int i = 0; i < 20_000; i++) {\n+                if (result != t.test(p.a, p.b, p.c)) {\n+                    throw new RuntimeException(\"incorrect result\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void runLongTest(LongAssociativeTest t) {\n+        for (LongParams p : longParamsArray) {\n+            long result = t.test(p.a, p.b, p.c);\n+            for (int i = 0; i < 20_000; i++) {\n+                if (result != t.test(p.a, p.b, p.c)) {\n+                    throw new RuntimeException(\"incorrect result\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final IntAssociativeTest[] intTests = {\n+        new IntAssociativeTest0(),\n+        new IntAssociativeTest1(),\n+        new IntAssociativeTest2(),\n+        new IntAssociativeTest3(),\n+        new IntAssociativeTest4(),\n+        new IntAssociativeTest5(),\n+        new IntAssociativeTest6(),\n+        new IntAssociativeTest7()\n+    };\n+\n+    private static final LongAssociativeTest[] longTests = {\n+        new LongAssociativeTest0(),\n+        new LongAssociativeTest1(),\n+        new LongAssociativeTest2(),\n+        new LongAssociativeTest3(),\n+        new LongAssociativeTest4(),\n+        new LongAssociativeTest5(),\n+        new LongAssociativeTest6(),\n+        new LongAssociativeTest7()\n+    };\n+\n+    public static void main(String[] args) {\n+        for (IntAssociativeTest t: intTests) {\n+            runIntTest(t);\n+        }\n+\n+        for (LongAssociativeTest t: longTests) {\n+            runLongTest(t);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/integerArithmetic\/TestAssociative.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -81,4 +81,7 @@\n-            \/* a method is not mature in Xcomp mode with tiered compilation disabled,\n-               see NonTieredCompPolicy::is_mature *\/\n-            Asserts.assertEQ(isMature, !(Platform.isComp() && !TIERED),\n-                    \"Unexpected isMature state for multiple times invoked method\");\n+            \/\/ The method may or may not be mature if it's compiled with limited profile.\n+            if (compLevel != CompilerWhiteBoxTest.COMP_LEVEL_LIMITED_PROFILE) {\n+               \/* a method is not mature in Xcomp mode with tiered compilation disabled,\n+                 see NonTieredCompPolicy::is_mature *\/\n+               Asserts.assertEQ(isMature, !(Platform.isComp() && !TIERED),\n+                       \"Unexpected isMature state for multiple times invoked method\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IsMatureTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269592\n+ *\n+ * @requires vm.jvmci\n+ *\n+ * @library \/ \/test\/lib\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.stack\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   compiler.jvmci.compilerToVM.IterateFramesNative\n+ * @run main\/othervm -Xcomp -Xbootclasspath\/a:.\n+ *                   -XX:CompileOnly=compiler.jvmci.compilerToVM.IterateFramesNative::callerNative\n+ *                   -XX:CompileOnly=jdk.vm.ci.hotspot.CompilerToVM::iterateFrames\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -Dcompiler.jvmci.compilerToVM.IterateFramesNative.checkCompiled=true\n+ *                   compiler.jvmci.compilerToVM.IterateFramesNative\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.common.CTVMUtilities;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.code.stack.InspectedFrameVisitor;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.hotspot.HotSpotStackFrameReference;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class IterateFramesNative {\n+    private static final WhiteBox WB;\n+    private static final Method NATIVE_METHOD;\n+    private static final Method ITERATE_FRAMES_METHOD;\n+    private static final ResolvedJavaMethod NATIVE_METHOD_RESOLVED;\n+    private static final ResolvedJavaMethod NATIVE_CALLBACK_METHOD_RESOLVED;\n+    private static final boolean CHECK_COMPILED;\n+\n+    static {\n+        Method nativeCallbackMethod;\n+        WB = WhiteBox.getWhiteBox();\n+        try {\n+            NATIVE_METHOD = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n+                    Runnable.class);\n+            nativeCallbackMethod = IterateFramesNative.class.getDeclaredMethod(\"testNativeFrameCallback\",\n+                    Helper.class, int.class);\n+            ITERATE_FRAMES_METHOD = CompilerToVMHelper.CompilerToVMClass().getDeclaredMethod(\n+                    \"iterateFrames\",\n+                    ResolvedJavaMethod[].class,\n+                    ResolvedJavaMethod[].class,\n+                    int.class,\n+                    InspectedFrameVisitor.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new Error(\"Can't get executable for test method\", e);\n+        }\n+        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(NATIVE_METHOD);\n+        NATIVE_CALLBACK_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(nativeCallbackMethod);\n+        CHECK_COMPILED = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.IterateFramesNative.checkCompiled\");\n+\n+        loadNativeLibrary();\n+    }\n+\n+    public static void main(String[] args) {\n+        new IterateFramesNative().test();\n+    }\n+\n+    private void test() {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD + 1; i++) {\n+            testNativeFrame(\"someString\", i);\n+        }\n+    }\n+\n+    \/**\n+    * Loads native library(libIterateFramesNative.so)\n+    *\/\n+    protected static void loadNativeLibrary() {\n+        System.loadLibrary(\"IterateFramesNative\");\n+    }\n+\n+    public static native void callerNative(Runnable runnable);\n+\n+    private void testNativeFrame(String str, int iteration) {\n+        Helper innerHelper = new Helper(str);\n+\n+        callerNative(() -> testNativeFrameCallback(innerHelper, iteration));\n+\n+        Asserts.assertEQ(innerHelper.string, NATIVE_METHOD_RESOLVED.getName(),\n+            \"Native frame not found?: \" + NATIVE_METHOD_RESOLVED.getName());\n+\n+        if (CHECK_COMPILED) {\n+            Asserts.assertTrue(WB.isMethodCompiled(ITERATE_FRAMES_METHOD),\n+                \"Expected native method to be compiled: \" + ITERATE_FRAMES_METHOD);\n+            Asserts.assertTrue(WB.isMethodCompiled(NATIVE_METHOD),\n+                \"Expected native method to be compiled: \" + NATIVE_METHOD);\n+        }\n+    }\n+\n+    private void testNativeFrameCallback(Helper helper, int iteration) {\n+        HotSpotStackFrameReference initialFrame = CompilerToVMHelper.iterateFrames(\n+            null,\n+            null,\n+            0,\n+            f -> {\n+                HotSpotStackFrameReference frame = (HotSpotStackFrameReference) f;\n+                Asserts.assertNotNull(frame, \"got null frame for native method\");\n+                return frame;\n+            });\n+        Asserts.assertNotNull(initialFrame, \"frame must not be null\");\n+        Asserts.assertEQ(initialFrame.getMethod().getName(), \"iterateFrames\",\n+            \"Expected initial frame method to be CompilerToVM.iterateFrames\");\n+\n+        AtomicInteger frameCounter = new AtomicInteger();\n+        ResolvedJavaMethod[] methods = new ResolvedJavaMethod[] {NATIVE_METHOD_RESOLVED, NATIVE_CALLBACK_METHOD_RESOLVED};\n+        CompilerToVMHelper.iterateFrames(\n+            methods,\n+            methods,\n+            0,\n+            f -> {\n+                HotSpotStackFrameReference frame = (HotSpotStackFrameReference) f;\n+                Asserts.assertNotNull(frame, \"got null frame for native method\");\n+                int index = frameCounter.getAndIncrement();\n+                if (index == 0) {\n+                    Asserts.assertTrue(frame.isMethod(NATIVE_CALLBACK_METHOD_RESOLVED),\n+                        \"unexpected method: \" + frame.getMethod().getName());\n+                } else if (index == 1) {\n+                    Asserts.assertTrue(frame.isMethod(NATIVE_METHOD_RESOLVED),\n+                        \"unexpected method: \" + frame.getMethod().getName());\n+                    helper.string = frame.getMethod().getName();\n+                    Asserts.assertFalse(frame.hasVirtualObjects(),\n+                        \"native frames do not have virtual objects\");\n+                    return frame; \/\/ stop\n+                }\n+                return null;\n+            });\n+    }\n+\n+    private class Helper {\n+        public String string;\n+\n+        public Helper(String s) {\n+            this.string = s;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IterateFramesNative.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#include \"jni.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CHECK_EXCEPTIONS if ((*env)->ExceptionCheck(env)) return\n+\n+JNIEXPORT void JNICALL Java_compiler_jvmci_compilerToVM_IterateFramesNative_callerNative(JNIEnv *env, jobject obj, jobject runnable) {\n+  jclass cls = (*env)->GetObjectClass(env, runnable);\n+  jmethodID runMethodID = (*env)->GetMethodID(env, cls, \"run\", \"()V\");\n+  CHECK_EXCEPTIONS;\n+  (*env)->CallVoidMethod(env, runnable, runMethodID);\n+  CHECK_EXCEPTIONS;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/libIterateFramesNative.c","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -274,1 +274,1 @@\n-                       irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n+                        irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n@@ -455,2 +455,2 @@\n-            CompLevel complevel = forceCompileAnno.value();\n-            TestFormat.check(complevel != CompLevel.SKIP && complevel != CompLevel.WAIT_FOR_COMPILATION,\n+            CompLevel compLevel = forceCompileAnno.value();\n+            TestFormat.check(compLevel != CompLevel.SKIP && compLevel != CompLevel.WAIT_FOR_COMPILATION,\n@@ -458,1 +458,1 @@\n-            complevel = restrictCompLevel(forceCompileAnno.value());\n+            compLevel = restrictCompLevel(forceCompileAnno.value());\n@@ -460,1 +460,2 @@\n-                complevel = complevel.flipCompLevel();\n+                compLevel = compLevel.flipCompLevel();\n+                compLevel = restrictCompLevel(compLevel.flipCompLevel());\n@@ -463,1 +464,1 @@\n-                complevel = complevel.excludeCompilationRandomly(ex);\n+                compLevel = compLevel.excludeCompilationRandomly(ex);\n@@ -465,3 +466,3 @@\n-            if (complevel != CompLevel.SKIP) {\n-                enqueueForCompilation(ex, complevel);\n-                forceCompileMap.put(ex, complevel);\n+            if (compLevel != CompLevel.SKIP) {\n+                enqueueForCompilation(ex, compLevel);\n+                forceCompileMap.put(ex, compLevel);\n@@ -497,1 +498,1 @@\n-                                     \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n+                                            \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n@@ -523,0 +524,1 @@\n+            compLevel = restrictCompLevel(compLevel.flipCompLevel());\n@@ -714,2 +716,2 @@\n-                         \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n-                         + m + \". Use @Warmup at @Run method instead.\");\n+                                \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n+                                + m + \". Use @Warmup at @Run method instead.\");\n@@ -851,1 +853,1 @@\n-                         \"Invalid compilation request with level \" + compLevel);\n+                      \"Invalid compilation request with level \" + compLevel);\n@@ -894,1 +896,1 @@\n-               (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n+                (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n@@ -949,1 +951,1 @@\n-        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS || FLIP_C1_C2 ||\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268261\n+ * @summary Test idom data after unswitching loop following by full unroll.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestIdomAfterLoopUnswitching::*\n+ *                   -Xcomp -XX:-TieredCompilation TestIdomAfterLoopUnswitching\n+ *\/\n+\n+public class TestIdomAfterLoopUnswitching {\n+\n+    public static void main(String[] k) {\n+        test1();\n+        test2();\n+    }\n+\n+    public static void test1() {\n+        float h = 0;\n+        for (int j = 0; j < 3; ++j) {\n+            float k = 9;\n+            float[] fla = new float[2];\n+            for (int n = 0; n < 5; ++n) {\n+                if (j >= 1) {\n+                    if (n <= 1) {\n+                        h += k;\n+                    }\n+                }\n+            }\n+            for (int l12 = 0; l12 < 9; ++l12) {\n+                for (int o = 0; o < 1; ++o) {\n+                    fla[0] += 1.0f;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void test2() {\n+        float[] fla = new float[1000];\n+        for (int i = 0; i < 1000; i++) {\n+            for (float fl2 : fla) {\n+                fla[100] = 1.0f;\n+            }\n+        }\n+        for (int i = 0; i < 3; i++) {\n+            for (int j = 0; j < 14; j++) {\n+                fla[2] = fla[j];\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIdomAfterLoopUnswitching.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -42,2 +42,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n@@ -60,2 +58,0 @@\n-                                    \/\/ to prevent biased locking handshakes from changing the timing of this test\n-                                    \"-XX:-UseBiasedLocking\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8183543\n+ * @summary C2 compilation often fails on aarch64 with \"failed spill-split-recycle sanity check\"\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-Inline\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+PreserveFramePointer\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   compiler.regalloc.TestC2IntPressure\n+ *\/\n+\n+package compiler.regalloc;\n+\n+import sun.hotspot.WhiteBox;\n+\n+public class TestC2IntPressure {\n+\n+  static volatile int vol_f;\n+\n+  static void not_inlined() {\n+    \/\/ Do nothing\n+  }\n+\n+  static int test(TestC2IntPressure arg) {\n+    TestC2IntPressure a = arg;\n+    int res = 0;\n+    not_inlined();\n+    res = a.vol_f;\n+    return res;\n+  }\n+\n+  public static void main(String args[]) {\n+    TestC2IntPressure arg = new TestC2IntPressure();\n+    for (int i = 0; i < 10000; i++) {\n+      test(arg);\n+    }\n+    try {\n+      var method = TestC2IntPressure.class.getDeclaredMethod(\"test\", TestC2IntPressure.class);\n+      if (!WhiteBox.getWhiteBox().isMethodCompiled(method)) {\n+        throw new Error(\"test method didn't get compiled\");\n+      }\n+    } catch (NoSuchMethodException e) {\n+      throw new Error(\"TESTBUG : \" + e, e);\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-    protected static final String RTM_BIASED_LOCKING_WARNING\n-            = \"Biased locking is not supported with RTM locking; \"\n-            + \"ignoring UseBiasedLocking flag\";\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMLocking and UseBiasedLocking\n- *          options combination on CPU, OS, and VM with rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionWithBiasedLocking\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionWithBiasedLocking {\n-\n-    public void runTestCases() throws Throwable {\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_BIASED_LOCKING_WARNING;\n-        String shouldPassMessage = \"JVM startup should pass with both \"\n-                + \"-XX:+UseRTMLocking and \"\n-                + \"-XX:-UseBiasedLocking flags set without any warnings\";\n-        \/\/ verify that we will not get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                shouldPassMessage, ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:-UseBiasedLocking\");\n-\n-        \/\/ verify that we will get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null,\n-                \"JVM startup should pass when both -XX:+UseRTMLocking and \"\n-                        + \"-XX:+UseBiasedLocking flags set\",\n-                \"Flags -XX:+UseRTMLocking\"\n-                        + \" and -XX:+UseBiasedLocking conflicts. \"\n-                        + \"Warning should be shown.\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-        \/\/ verify that UseBiasedLocking is false when we use rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseBiasedLocking\",\n-                \"false\",\n-                \"Value of option 'UseBiasedLocking' should be false if\"\n-                        + \"-XX:+UseRTMLocking flag set.\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can't turn on biased locking when\n-        \/\/ using rtm locking\n-        CommandLineOptionTest\n-                .verifyOptionValueForSameVM(\n-                        \"UseBiasedLocking\",\n-                        \"false\",\n-                        \"Value of option 'UseBiasedLocking' should be false if\"\n-                                + \"both -XX:+UseRTMLocking and \"\n-                                + \"-XX:+UseBiasedLocking flags set.\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionWithBiasedLocking().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionWithBiasedLocking.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8032011\n- * @summary biased locking's revoke_bias locks monitor in compiled frame with eliminated lock\n- *\n- * @run main\/othervm -XX:-UseOnStackReplacement\n- *      -XX:CompileCommand=dontinline,compiler.uncommontrap.TestLockEliminatedAtDeopt$A::m2\n- *      -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0\n- *      compiler.uncommontrap.TestLockEliminatedAtDeopt\n- *\/\n-\n-package compiler.uncommontrap;\n-\n-public class TestLockEliminatedAtDeopt {\n-\n-    static class A {\n-        void m() {\n-        }\n-\n-        \/\/ This lock is not eliminated but biased to main thread on\n-        \/\/ first call\n-        synchronized void m2(boolean trap) {\n-            if (trap) {\n-                new B();\n-            }\n-        }\n-    }\n-\n-    static class B extends A {\n-        void m() {\n-        }\n-    }\n-\n-    static void m1(boolean trap) {\n-        A a = new A();\n-        \/\/ This lock is eliminated by c2\n-        synchronized(a) {\n-            a.m2(trap);\n-            a.m();\n-        }\n-    }\n-\n-     public static void main(String[] args) {\n-        for (int i = 0; i < 20000; i++) {\n-            m1(false);\n-        }\n-        \/\/ Trigger uncommon trap in A.m2() (class unloaded) and\n-        \/\/ deoptimization of m1() (CHA invalidated). Uncommon trap\n-        \/\/ code locks monitor in m1's frame where's it's eliminated.\n-        m1(true);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestLockEliminatedAtDeopt.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -XX:NewSize=10m -XX:+FullGCALot -XX:FullGCALotInterval=120 -XX:+UseBiasedLocking gc.TestFullGCALot\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n-  *\/\n+ *\/\n@@ -56,0 +55,7 @@\n+\n+\/*\n+ * @test TestSystemGCLargePages\n+ * @summary Runs System.gc() with different flags.\n+ * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestSystemGC.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestG1RemSetFlags\n+ * @requires vm.gc.G1\n+ * @summary Verify that the remembered set flags are updated as expected\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.management\/sun.management\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestG1RemSetFlags\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RemSetFlags {\n+\n+  private static void checkG1RemSetFlags(String[] flags, int exitValue) throws Exception {\n+    ArrayList<String> flagList = new ArrayList<String>();\n+    flagList.addAll(Arrays.asList(flags));\n+    flagList.add(\"-XX:+UseG1GC\");\n+    flagList.add(\"-XX:+PrintFlagsFinal\");\n+    flagList.add(\"-version\");\n+\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(exitValue);\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=16\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=16\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=7\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlMaxNumBuckets=7\"  },  1);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -47,0 +49,2 @@\n+import sun.hotspot.WhiteBox;\n+\n@@ -66,4 +70,10 @@\n-        testVerifyFlags(false, false, filteredOpts);\n-        testVerifyFlags(true,  true,  filteredOpts);\n-        testVerifyFlags(true,  false, filteredOpts);\n-        testVerifyFlags(false, true,  filteredOpts);\n+        \/\/ Young GC\n+        testVerifyFlags(false, false, false, filteredOpts);\n+        testVerifyFlags(true,  true,  false, filteredOpts);\n+        testVerifyFlags(true,  false, false, filteredOpts);\n+        testVerifyFlags(false, true,  false, filteredOpts);\n+        \/\/ Full GC\n+        testVerifyFlags(false, false, true, filteredOpts);\n+        testVerifyFlags(true,  true,  true, filteredOpts);\n+        testVerifyFlags(true,  false, true, filteredOpts);\n+        testVerifyFlags(false, true,  true, filteredOpts);\n@@ -74,0 +84,1 @@\n+                                       boolean doFullGC,\n@@ -80,0 +91,3 @@\n+                                       \"-Xbootclasspath\/a:.\",\n+                                       \"-XX:+UnlockDiagnosticVMOptions\",\n+                                       \"-XX:+WhiteBoxAPI\",\n@@ -84,1 +98,0 @@\n-                                       \"-XX:+UnlockDiagnosticVMOptions\",\n@@ -89,1 +102,2 @@\n-                                       GarbageProducer.class.getName() });\n+                                       GarbageProducer.class.getName(),\n+                                       doFullGC ? \"t\" : \"f\" });\n@@ -114,4 +128,6 @@\n-            int j = 0;\n-            for(int i = 0; i<1000; i++) {\n-                garbage[j] = new long[10000];\n-                j = (j+1)%garbage.length;\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+            if (args[0].equals(\"t\")) {\n+                wb.fullGC();\n+            } else {\n+                wb.youngGC();\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestVerifyBeforeAndAfterGCFlags.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+        \/\/   Humongous Regions: f->g\n@@ -81,1 +82,0 @@\n-        \/\/   Humongous Regions: f->g\n@@ -90,3 +90,3 @@\n-            int total = Integer.parseInt(getSumValue(lines[i + 2]));\n-            int candidate = Integer.parseInt(getSumValue(lines[i + 3]));\n-            int reclaimed = Integer.parseInt(getSumValue(lines[i + 4]));\n+            int total = Integer.parseInt(getSumValue(lines[i + 3]));\n+            int candidate = Integer.parseInt(getSumValue(lines[i + 4]));\n+            int reclaimed = Integer.parseInt(getSumValue(lines[i + 5]));\n@@ -94,2 +94,2 @@\n-            int before = Integer.parseInt(lines[i + 5].substring(0, 1));\n-            int after = Integer.parseInt(lines[i + 5].substring(3, 4));\n+            int before = Integer.parseInt(lines[i].substring(0, 1));\n+            int after = Integer.parseInt(lines[i].substring(3, 4));\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsLog.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestEvacuationFailure\n+ * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   gc.g1.TestEvacuationFailure\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestEvacuationFailure {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                  \"-Xmx32M\",\n+                                                                  \"-Xmn16M\",\n+                                                                  \"-XX:+G1EvacuationFailureALot\",\n+                                                                  \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                                  \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                                  \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                  \"-XX:-G1UsePreventiveGC\",\n+                                                                  \"-Xlog:gc\",\n+                                                                  GCTestWithEvacuationFailure.class.getName());\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldContain(\"(Evacuation Failure)\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static class GCTestWithEvacuationFailure {\n+        private static byte[] garbage;\n+        private static byte[] largeObject;\n+        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n+\n+        public static void main(String [] args) {\n+            largeObject = new byte[16 * 1024 * 1024];\n+            System.out.println(\"Creating garbage\");\n+            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n+            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n+            \/\/ which is larger than G1EvacuationFailureALotInterval.\n+            for (int i = 0; i < 16 * 1024; i++) {\n+                holder[i % holder.length] = new byte[1024];\n+            }\n+            System.out.println(\"Done\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -104,3 +104,8 @@\n-        new LogMessageWithLevel(\"Merged Sparse\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Fine\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Coarse\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Full\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl BitMap\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Full\", Level.DEBUG),\n@@ -138,0 +143,1 @@\n+        new LogMessageWithLevel(\"Sample Collection Set Candidates\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        runTest(false, \"-XX:ConcGCThreads=4\", \"-XX:ParallelGCThreads=3\");\n+        runTest(true, \"-XX:ConcGCThreads=4\", \"-XX:ParallelGCThreads=3\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestMarkStackSizes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:G1RSetSparseRegionEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:+UnlockExperimentalVMOptions -XX:G1RemSetArrayOfCardsEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoEagerReclaimOfHumongousRegions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Platform;\n@@ -55,0 +56,3 @@\n+        if (Platform.isDebugBuild()) {\n+            testYoungEvacFail();\n+        }\n@@ -118,0 +122,20 @@\n+    private static void testYoungEvacFail() throws Exception {\n+        OutputAnalyzer output;\n+        output = testWithVerificationType(new String[] {\"young-evac-fail\"},\n+                                          new String[] {\"-XX:+G1EvacuationFailureALot\",\n+                                                        \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                        \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                        \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                        \"-XX:-G1UsePreventiveGC\"});\n+        output.shouldHaveExitValue(0);\n+\n+        verifyCollection(\"Pause Young (Normal)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Concurrent Start)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Prepare Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Remark\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Cleanup\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Full\", false, false, false, output.getStdout());\n+    }\n+\n+\n@@ -124,1 +148,1 @@\n-        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, concurrent-start, mixed, remark, cleanup and full\");\n+        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\");\n@@ -134,1 +158,1 @@\n-    private static OutputAnalyzer testWithVerificationType(String[] types) throws Exception {\n+    private static OutputAnalyzer testWithVerificationType(String[] types, String... extraOpts) throws Exception {\n@@ -154,0 +178,2 @@\n+        Collections.addAll(basicOpts, extraOpts);\n+\n@@ -158,0 +184,1 @@\n+\n@@ -231,0 +258,3 @@\n+\n+        \/\/ This class triggers GCs; we need to make sure that in all of the young gcs\n+        \/\/ at least some objects survive so that evacuation failure can happen.\n@@ -244,0 +274,2 @@\n+\n+            used = alloc1M();\n@@ -245,0 +277,1 @@\n+            partialFree(used);\n@@ -252,0 +285,1 @@\n+            used = alloc1M();\n@@ -253,0 +287,3 @@\n+            partialFree(used);\n+\n+            used = alloc1M();\n@@ -254,0 +291,1 @@\n+            partialFree(used);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -142,2 +142,2 @@\n-        if (newCollectionTime <= collectionTime) {\n-            throw new RuntimeException(\"Collector has not run some more\");\n+        if (newCollectionTime < collectionTime) {\n+            throw new RuntimeException(\"Collection time ran backwards\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestOldGenCollectionUsage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        \"-Xlog:gc=debug,gc+phases=trace\",\n+        \"-Xlog:gc,gc+plab=debug\",\n@@ -199,1 +199,1 @@\n-                .filter(line -> line.contains(\"space exhausted\"))\n+                .filter(line -> line.contains(\"(Evacuation Failure)\"))\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,5 +193,6 @@\n-        return new HashMap<>(\n-                getEntries().entryStream()\n-                .filter(gcLogItem -> extractId == gcIds.contains(gcLogItem.getKey()))\n-                .collect(Collectors.toMap(gcLogItem -> gcLogItem.getKey(),\n-                                gcLogItem -> gcLogItem.getValue().get(type).filter(fieldNames)\n+        var map = new HashMap<>(\n+                        getEntries().entryStream()\n+                        .filter(gcLogItem -> extractId == gcIds.contains(gcLogItem.getKey()))\n+                        .collect(Collectors.toMap(gcLogItem -> gcLogItem.getKey(),\n+                                        gcLogItem -> gcLogItem.getValue().get(type).filter(fieldNames)\n+                                )\n@@ -199,2 +200,5 @@\n-                )\n-        );\n+                 );\n+        if (map.isEmpty()) {\n+            throw new RuntimeException(\"Cannot find relevant PLAB statistics in the log\");\n+        }\n+        return map;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/lib\/LogParser.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    static final String phaseReconsiderSoftReferences = \"Reconsider SoftReferences\";\n@@ -140,1 +139,0 @@\n-        String phase1Regex = gcLogTimeRegex + phaseRegex(phaseReconsiderSoftReferences) + balanceRegex + subphaseRegex(\"SoftRef\", p);\n@@ -151,1 +149,0 @@\n-                           phase1Regex +\n@@ -223,1 +220,1 @@\n-        BigDecimal sumOfSubPhasesTime = getTimeValue(phaseReconsiderSoftReferences, 2);\n+        BigDecimal sumOfSubPhasesTime = BigDecimal.ZERO;\n@@ -228,3 +225,3 @@\n-        \/\/ If there are 4 phases, we should allow 0.2 tolerance.\n-        final BigDecimal toleranceFor4SubPhases = BigDecimal.valueOf(0.2);\n-        if (!greaterThanOrApproximatelyEqual(refProcTime, sumOfSubPhasesTime, toleranceFor4SubPhases)) {\n+        \/\/ If there are 3 phases, we should allow 0.2 tolerance.\n+        final BigDecimal toleranceFor3SubPhases = BigDecimal.valueOf(0.2);\n+        if (!greaterThanOrApproximatelyEqual(refProcTime, sumOfSubPhasesTime, toleranceFor3SubPhases)) {\n","filename":"test\/hotspot\/jtreg\/gc\/logging\/TestPrintReferences.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=passive\n@@ -54,1 +54,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=aggressive\n@@ -82,1 +82,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=adaptive\n@@ -99,1 +99,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=static\n@@ -111,1 +111,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=compact\n@@ -123,1 +123,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=iu-aggressive\n@@ -151,1 +151,1 @@\n- * @test TestAllocHumongousFragment\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocHumongousFragment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=passive\n@@ -54,1 +54,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=aggressive\n@@ -86,1 +86,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=adaptive\n@@ -103,1 +103,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=static\n@@ -115,1 +115,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=compact\n@@ -127,1 +127,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=no-tlab\n@@ -140,1 +140,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=iu-aggressive\n@@ -172,1 +172,1 @@\n- * @test TestAllocIntArrays\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=passive\n@@ -54,1 +54,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=aggressive\n@@ -86,1 +86,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=adaptive\n@@ -103,1 +103,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=static\n@@ -115,1 +115,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=compact\n@@ -127,1 +127,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=no-tlab\n@@ -140,1 +140,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=iu-aggressive\n@@ -172,1 +172,1 @@\n- * @test TestAllocObjectArrays\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjectArrays.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocObjects\n+ * @test id=passive\n@@ -52,1 +52,1 @@\n- * @test TestAllocObjects\n+ * @test id=aggressive\n@@ -88,1 +88,1 @@\n- * @test TestAllocObjects\n+ * @test id=adaptive\n@@ -108,1 +108,1 @@\n- * @test TestAllocObjects\n+ * @test id=static\n@@ -123,1 +123,1 @@\n- * @test TestAllocObjects\n+ * @test id=compact\n@@ -138,1 +138,1 @@\n- * @test TestAllocObjects\n+ * @test id=iu-aggressive\n@@ -168,1 +168,1 @@\n- * @test TestAllocObjects\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestArrayCopyCheckCast\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyCheckCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @test TestArrayCopyStress\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestArrayCopyStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=passive\n@@ -44,1 +44,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=aggressive\n@@ -55,1 +55,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=adaptive\n@@ -66,1 +66,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=static\n@@ -77,1 +77,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=compact\n@@ -88,1 +88,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=iu-aggressive\n@@ -99,1 +99,1 @@\n- * @test TestDynamicSoftMaxHeapSize\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestElasticTLAB\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestElasticTLAB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestEvilSyncBug\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestEvilSyncBug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestGCThreadGroups\n+ * @test id=passive\n@@ -38,1 +38,1 @@\n- * @test TestGCThreadGroups\n+ * @test id=default\n@@ -80,1 +80,1 @@\n- * @test TestGCThreadGroups\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestGCThreadGroups.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHeapUncommit\n+ * @test id=passive\n@@ -54,1 +54,1 @@\n- * @test TestHeapUncommit\n+ * @test id=adaptive\n@@ -88,1 +88,1 @@\n- * @test TestHeapUncommit\n+ * @test id=iu\n@@ -109,1 +109,1 @@\n- * @test TestHeapUncommit\n+ * @test id=default-lp\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHeapUncommit.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHumongousThreshold\n+ * @test id=default\n@@ -72,1 +72,1 @@\n- * @test TestHumongousThreshold\n+ * @test id=16b\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestLargeObjectAlignment\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLargeObjectAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=passive\n@@ -43,1 +43,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=aggressive\n@@ -65,1 +65,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=adaptive\n@@ -75,1 +75,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=static\n@@ -85,1 +85,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=compact\n@@ -95,1 +95,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=iu-aggressive\n@@ -117,1 +117,1 @@\n- * @test TestLotsOfCycles\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestLotsOfCycles.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestObjIterWithHeapDump\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestObjItrWithHeapDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestParallelRefprocSanity\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestParallelRefprocSanity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestPeriodicGC\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\/* @test\n+\/* @test id=satb\n@@ -38,1 +38,1 @@\n-\/* @test\n+\/* @test id=iu\n@@ -50,1 +50,1 @@\n-\/* @test\n+\/* @test id=satb-100\n@@ -63,1 +63,1 @@\n-\/* @test\n+\/* @test id=iu-100\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceRefersToShenandoah.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\/* @test\n+\/* @test id=satb-100\n@@ -39,1 +39,1 @@\n-\/* @test\n+\/* @test id=iu-100\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestReferenceShortcutCycle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestRefprocSanity\n+ * @test id=default\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -45,1 +45,1 @@\n- * @test TestRefprocSanity\n+ * @test id=iu\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm -Xmx128m -Xms128m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -67,2 +67,2 @@\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-    static final int WINDOW = 10_000;\n+    static final long TARGET_MB = Long.getLong(\"target\", 1_000); \/\/ 1 Gb allocation\n+    static final int WINDOW = 1_000;\n@@ -72,0 +72,2 @@\n+    static Object sink;\n+\n@@ -73,1 +75,1 @@\n-        long count = TARGET_MB * 1024 * 1024 \/ 32;\n+        long count = TARGET_MB * 1024 * 1024 \/ 128;\n@@ -90,1 +92,6 @@\n-            while (rq.poll() != null); \/\/ drain\n+\n+            \/\/ Do allocations to force GCs\n+            sink = new byte[100];\n+\n+            \/\/ Drain the refqueue\n+            while (rq.poll() != null);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRefprocSanity.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestRegionSampling\n+ * @test id=passive\n@@ -41,1 +41,1 @@\n- * @test TestRegionSampling\n+ * @test id=adaptive\n@@ -50,1 +50,1 @@\n- * @test TestRegionSampling\n+ * @test id=static\n@@ -59,1 +59,1 @@\n- * @test TestRegionSampling\n+ * @test id=compact\n@@ -68,1 +68,1 @@\n- * @test TestRegionSampling\n+ * @test id=aggressive\n@@ -77,1 +77,1 @@\n- * @test TestRegionSampling\n+ * @test id=iu-aggressive\n@@ -86,1 +86,1 @@\n- * @test TestRegionSampling\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRegionSampling.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestResizeTLAB\n+ * @test id=passive\n@@ -62,1 +62,1 @@\n- * @test TestResizeTLAB\n+ * @test id=aggressive\n@@ -82,1 +82,1 @@\n- * @test TestResizeTLAB\n+ * @test id=adaptive\n@@ -102,1 +102,1 @@\n- * @test TestResizeTLAB\n+ * @test id=static\n@@ -122,1 +122,1 @@\n- * @test TestResizeTLAB\n+ * @test id=compact\n@@ -142,1 +142,1 @@\n- * @test TestResizeTLAB\n+ * @test id=iu-aggressive\n@@ -162,1 +162,1 @@\n- * @test TestResizeTLAB\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestResizeTLAB.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestRetainObjects\n+ * @test id=passive\n@@ -52,1 +52,1 @@\n- * @test TestRetainObjects\n+ * @test id=aggressive\n@@ -72,1 +72,1 @@\n- * @test TestRetainObjects\n+ * @test id=adaptive\n@@ -87,1 +87,1 @@\n- * @test TestRetainObjects\n+ * @test id=static\n@@ -97,1 +97,1 @@\n- * @test TestRetainObjects\n+ * @test id=compact\n@@ -107,1 +107,1 @@\n- * @test TestRetainObjects\n+ * @test id=no-tlab\n@@ -118,1 +118,1 @@\n- * @test TestRetainObjects\n+ * @test id=iu-aggressive\n@@ -138,1 +138,1 @@\n- * @test TestRetainObjects\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestRetainObjects.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestSieveObjects\n+ * @test id=passive\n@@ -54,1 +54,1 @@\n- * @test TestSieveObjects\n+ * @test id=aggressive\n@@ -76,1 +76,1 @@\n- * @test TestSieveObjects\n+ * @test id=adaptive\n@@ -94,1 +94,1 @@\n- * @test TestSieveObjects\n+ * @test id=static\n@@ -106,1 +106,1 @@\n- * @test TestSieveObjects\n+ * @test id=compact\n@@ -118,1 +118,1 @@\n- * @test TestSieveObjects\n+ * @test id=no-tlab\n@@ -131,1 +131,1 @@\n- * @test TestSieveObjects\n+ * @test id=iu-aggressive\n@@ -153,1 +153,1 @@\n- * @test TestSieveObjects\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestSmallHeap\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSmallHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestStringDedup\n+ * @test id=passive\n@@ -47,1 +47,1 @@\n- * @test TestStringDedup\n+ * @test id=default\n@@ -52,1 +52,0 @@\n- * @modules java.base\/jdk.internal.misc:open\n@@ -70,1 +69,1 @@\n- * @test TestStringDedup\n+ * @test id=iu\n@@ -75,1 +74,0 @@\n- * @modules java.base\/jdk.internal.misc:open\n@@ -92,2 +90,0 @@\n-import sun.misc.*;\n-\n@@ -96,1 +92,0 @@\n-    private static Unsafe unsafe;\n@@ -104,4 +99,0 @@\n-            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-            field.setAccessible(true);\n-            unsafe = (Unsafe) field.get(null);\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedup.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @test TestStringDedupStress\n+ * @test id=passive\n@@ -31,1 +31,0 @@\n- * @modules java.base\/jdk.internal.misc:open\n@@ -47,1 +46,1 @@\n- * @test TestStringDedupStress\n+ * @test id=default\n@@ -52,1 +51,0 @@\n- * @modules java.base\/jdk.internal.misc:open\n@@ -78,1 +76,1 @@\n- * @test TestStringDedupStress\n+ * @test id=iu\n@@ -83,1 +81,0 @@\n- * @modules java.base\/jdk.internal.misc:open\n@@ -114,2 +111,0 @@\n-import sun.misc.*;\n-\n@@ -118,1 +113,0 @@\n-    private static Unsafe unsafe;\n@@ -128,4 +122,0 @@\n-            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-            field.setAccessible(true);\n-            unsafe = (Unsafe) field.get(null);\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringDedupStress.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestStringInternCleanup\n+ * @test id=passive\n@@ -52,1 +52,1 @@\n- * @test TestStringInternCleanup\n+ * @test id=default\n@@ -79,1 +79,1 @@\n- * @test TestStringInternCleanup\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestStringInternCleanup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestVerifyJCStress\n+ * @test id=passive\n@@ -44,1 +44,1 @@\n- * @test TestVerifyJCStress\n+ * @test id=default\n@@ -62,1 +62,1 @@\n- * @test TestVerifyJCStress\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyJCStress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestVerifyLevels\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestVerifyLevels.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestWithLogLevel\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWithLogLevel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestWrongArrayMember\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWrongArrayMember.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * @test 8238385\n+ * @test\n+ * @bug 8238385\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/FoldIfAfterExpansion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestC1ArrayCopyNPE\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestC1ArrayCopyNPE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestC1VectorizedMismatch\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestC1VectorizedMismatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestClone\n+ * @test id=default\n@@ -51,1 +51,1 @@\n- * @test TestClone\n+ * @test id=default-verify\n@@ -82,1 +82,1 @@\n- * @test TestClone\n+ * @test id=aggressive\n@@ -108,1 +108,1 @@\n- * @test TestClone\n+ * @test id=no-coops\n@@ -140,1 +140,1 @@\n- * @test TestClone\n+ * @test id=no-coops-verify\n@@ -177,1 +177,1 @@\n- * @test TestClone\n+ * @test id=no-coops-aggressive\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestClone.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestExpandedWBLostNullCheckDep\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestExpandedWBLostNullCheckDep.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestMaybeNullUnsafeAccess\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestMaybeNullUnsafeAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestNullCheck\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestNullCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @test TestReferenceCAS\n+ * @test id=default\n@@ -43,1 +43,1 @@\n- * @test TestReferenceCAS\n+ * @test id=no-coops\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestReferenceCAS.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestUnsafeOffheapSwap\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestUnsafeOffheapSwap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test TestWriteBarrierClearControl\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestWriteBarrierClearControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestJNICritical\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNICritical.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestJNIGlobalRefs\n+\/* @test id=aggressive-verify\n@@ -35,1 +35,1 @@\n-\/* @test TestJNIGlobalRefs\n+\/* @test id=aggressive\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestPinnedGarbage\n+\/* @test id=passive\n@@ -42,1 +42,1 @@\n-\/* @test TestPinnedGarbage\n+\/* @test id=aggressive\n@@ -51,1 +51,7 @@\n- *\n+ *\/\n+\n+\/* @test id=verify\n+ * @summary Test that garbage in the pinned region does not crash VM\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestPinnedGarbage.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* @test TestStringCriticalWithDedup\n+ * @summary Test string deduplication should not cause string critical to crash VM\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/java.lang:open\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive -XX:+UseStringDeduplication -XX:-CompactStrings\n+ *      -XX:+ShenandoahVerify -XX:+ShenandoahDegeneratedGC -XX:ShenandoahTargetNumRegions=4096\n+ *      TestStringCriticalWithDedup\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive -XX:+UseStringDeduplication -XX:-CompactStrings\n+ *      -XX:+ShenandoahVerify -XX:-ShenandoahDegeneratedGC -XX:ShenandoahTargetNumRegions=4096\n+ *      TestStringCriticalWithDedup\n+ *\/\n+\n+\/* @test TestPinnedGarbage\n+ * @summary Test string deduplication should not cause string critical to crash VM\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/java.lang:open\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive -XX:+UseStringDeduplication -XX:-CompactStrings\n+ *      -XX:ShenandoahTargetNumRegions=4096\n+ *      TestStringCriticalWithDedup\n+ *\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx256m\n+ *      -XX:+UseShenandoahGC -XX:+UseStringDeduplication -XX:-CompactStrings\n+ *      -XX:ShenandoahTargetNumRegions=4096 -XX:+ShenandoahVerify\n+ *      TestStringCriticalWithDedup\n+ *\/\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.concurrent.*;\n+import java.lang.reflect.*;\n+\n+public class TestStringCriticalWithDedup {\n+    private static Field valueField;\n+\n+    static {\n+        System.loadLibrary(\"TestStringCriticalWithDedup\");\n+        try {\n+            valueField = String.class.getDeclaredField(\"value\");\n+            valueField.setAccessible(true);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static final int NUM_RUNS      = 100;\n+    private static final int STRING_COUNT    = 1 << 16;\n+    private static final int LITTLE_GARBAGE_COUNT = 1 << 5;\n+    private static final int PINNED_STRING_COUNT = 1 << 4;\n+\n+    private static native long pin(String s);\n+    private static native void unpin(String s, long p);\n+\n+\n+    private static volatile MyClass sink;\n+    public static void main(String[] args) {\n+        ThreadLocalRandom rng = ThreadLocalRandom.current();\n+        for (int i = 0; i < NUM_RUNS; i++) {\n+            test(rng);\n+        }\n+    }\n+\n+    private static Object getValue(String string) {\n+        try {\n+            return valueField.get(string);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void pissiblePinString(ThreadLocalRandom rng, List<Tuple> pinnedList, String s) {\n+        int oneInCounter = STRING_COUNT \/ PINNED_STRING_COUNT;\n+        if (rng.nextInt(oneInCounter) == 1) {\n+            long v = pin(s);\n+            Object value = getValue(s);\n+            pinnedList.add(new Tuple(s, value, v));\n+        }\n+    }\n+\n+    private static void test(ThreadLocalRandom rng) {\n+        String[] strArray = new String[STRING_COUNT];\n+        List<Tuple> pinnedStrings = new ArrayList<>(PINNED_STRING_COUNT);\n+        for (int i = 0; i < STRING_COUNT; i++) {\n+            \/\/ Create some garbage inbetween, so strings can be scattered in\n+            \/\/ different regions\n+            createLittleGarbage(rng);\n+\n+            strArray[i] = new String(\"Hello\" + (i % 10));\n+            pissiblePinString(rng, pinnedStrings, strArray[i]);\n+        }\n+\n+        \/\/ Let deduplication thread to run a bit\n+        try {\n+            Thread.sleep(10);\n+        } catch(Exception e) {\n+        }\n+\n+        for (int i = 0; i < pinnedStrings.size(); i ++) {\n+            Tuple p = pinnedStrings.get(i);\n+            String s = p.getString();\n+            if (getValue(s) != p.getValue()) {\n+                System.out.println(getValue(s) + \" != \" + p.getValue());\n+                throw new RuntimeException(\"String value should be pinned\");\n+            }\n+            unpin(p.getString(), p.getValuePointer());\n+        }\n+    }\n+\n+    private static void createLittleGarbage(ThreadLocalRandom rng) {\n+        int count = rng.nextInt(LITTLE_GARBAGE_COUNT);\n+        for (int index = 0; index < count; index ++) {\n+            sink = new MyClass();\n+        }\n+    }\n+\n+    private static class Tuple {\n+        String s;\n+        Object value;\n+        long   valuePointer;\n+        public Tuple(String s, Object value, long vp) {\n+            this.s = s;\n+            this.value = value;\n+            this.valuePointer = vp;\n+        }\n+\n+        public String getString() {\n+            return s;\n+        }\n+        public Object getValue() { return value; }\n+        public long getValuePointer() {\n+            return valuePointer;\n+        }\n+    }\n+\n+    private static class MyClass {\n+        public long[] payload = new long[10];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestStringCriticalWithDedup.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <jni.h>\n+#include <string.h>\n+#include <stdint.h>\n+\n+JNIEXPORT jlong JNICALL\n+Java_TestStringCriticalWithDedup_pin(JNIEnv *env, jclass unused, jstring s) {\n+  const jchar* a = (*env)->GetStringCritical(env, s, NULL);\n+  return (jlong)(uintptr_t)a;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestStringCriticalWithDedup_unpin(JNIEnv *env, jclass unused, jstring s, jlong v) {\n+  jchar* a = (jchar*)(uintptr_t)v;\n+  (*env)->ReleaseStringCritical(env, s, a);\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/libTestStringCriticalWithDedup.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHeapDump\n+ * @test id=aggressive\n@@ -31,1 +31,5 @@\n- * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx128m -XX:ShenandoahGCHeuristics=aggressive                        TestHeapDump\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n+ *      TestHeapDump\n@@ -36,1 +40,1 @@\n- * @test TestHeapDump\n+ * @test id=no-coops-aggressive\n@@ -42,1 +46,5 @@\n- * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx128m -XX:ShenandoahGCHeuristics=aggressive -XX:-UseCompressedOops TestHeapDump\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n+ *      -XX:-UseCompressedOops TestHeapDump\n@@ -46,1 +54,1 @@\n- * @test TestHeapDump\n+ * @test id=aggressive-strdedup\n@@ -51,1 +59,5 @@\n- * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx128m -XX:ShenandoahGCHeuristics=aggressive                         -XX:+UseStringDeduplication TestHeapDump\n+ * @run main\/othervm\/native\/timeout=300 -agentlib:TestHeapDump\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xmx128m\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n+ *      -XX:+UseStringDeduplication TestHeapDump\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jvmti\/TestHeapDump.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestChurnNotifications\n+ * @test id=passive\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -42,1 +43,1 @@\n- * @test TestChurnNotifications\n+ * @test id=aggressive\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -53,1 +55,1 @@\n- * @test TestChurnNotifications\n+ * @test id=adaptive\n@@ -55,0 +57,1 @@\n+ * @library \/test\/lib \/\n@@ -64,1 +67,1 @@\n- * @test TestChurnNotifications\n+ * @test id=static\n@@ -66,0 +69,1 @@\n+ * @library \/test\/lib \/\n@@ -75,1 +79,1 @@\n- * @test TestChurnNotifications\n+ * @test id=compact\n@@ -77,0 +81,1 @@\n+ * @library \/test\/lib \/\n@@ -86,1 +91,1 @@\n- * @test TestChurnNotifications\n+ * @test id=iu\n@@ -88,0 +93,1 @@\n+ * @library \/test\/lib \/\n@@ -107,0 +113,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -124,0 +132,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -162,9 +172,0 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (churnBytes.get() == 0) {\n-            Thread.sleep(1000);\n-        }\n-        Thread.sleep(5000);\n-\n-        long actual = churnBytes.get();\n-\n@@ -173,0 +174,20 @@\n+        long actual = 0;\n+\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actual = churnBytes.get();\n+            if (minExpected <= actual) {\n+                \/\/ Wait some more to test if we are breaking the maximum boundary.\n+                Thread.sleep(5000);\n+                actual = churnBytes.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestMemoryMXBeans\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryMXBeans.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestMemoryPools\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestMemoryPools.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestPauseNotifications\n+ * @test id=passive\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -42,1 +43,1 @@\n- * @test TestPauseNotifications\n+ * @test id=aggressive\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -52,1 +54,1 @@\n- * @test TestPauseNotifications\n+ * @test id=adaptive\n@@ -54,0 +56,1 @@\n+ * @library \/test\/lib \/\n@@ -62,1 +65,1 @@\n- * @test TestPauseNotifications\n+ * @test id=static\n@@ -64,0 +67,1 @@\n+ * @library \/test\/lib \/\n@@ -72,1 +76,1 @@\n- * @test TestPauseNotifications\n+ * @test id=compact\n@@ -74,0 +78,1 @@\n+ * @library \/test\/lib \/\n@@ -82,1 +87,1 @@\n- * @test TestPauseNotifications\n+ * @test id=iu\n@@ -84,0 +89,1 @@\n+ * @library \/test\/lib \/\n@@ -101,0 +107,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -111,0 +119,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -113,0 +123,2 @@\n+        final AtomicLong pausesCount = new AtomicLong();\n+        final AtomicLong cyclesCount = new AtomicLong();\n@@ -120,3 +132,1 @@\n-                    System.out.println(info.getGcInfo().toString());\n-                    System.out.println(info.getGcName());\n-                    System.out.println();\n+                    System.out.println(\"Received: \" + info.getGcName());\n@@ -129,0 +139,1 @@\n+                            pausesCount.incrementAndGet();\n@@ -131,0 +142,1 @@\n+                            cyclesCount.incrementAndGet();\n@@ -151,4 +163,24 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (pausesDuration.get() == 0) {\n-            Thread.sleep(1000);\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        long actualPauses = 0;\n+        long actualCycles = 0;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long minExpected = 10;\n+\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actualPauses = pausesCount.get();\n+            actualCycles = cyclesCount.get();\n+            if (minExpected <= actualPauses && minExpected <= actualCycles) {\n+                \/\/ Wait a little bit to catch the lingering notifications.\n+                Thread.sleep(5000);\n+                actualPauses = pausesCount.get();\n+                actualCycles = cyclesCount.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n@@ -156,7 +188,0 @@\n-        Thread.sleep(5000);\n-\n-        long pausesActual = pausesDuration.get();\n-        long cyclesActual = cyclesDuration.get();\n-\n-        long minExpected = 1;\n-        long maxExpected = Long.MAX_VALUE;\n@@ -165,2 +190,2 @@\n-            String msg = \"Pauses expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + pausesActual;\n-            if (minExpected <= pausesActual && pausesActual <= maxExpected) {\n+            String msg = \"Pauses expected = [\" + minExpected + \"; +inf], actual = \" + actualPauses;\n+            if (minExpected <= actualPauses) {\n@@ -174,2 +199,2 @@\n-            String msg = \"Cycles expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + cyclesActual;\n-            if (minExpected <= cyclesActual && cyclesActual <= maxExpected) {\n+            String msg = \"Cycles expected = [\" + minExpected + \"; +inf], actual = \" + actualCycles;\n+            if (minExpected <= actualCycles) {\n@@ -183,2 +208,6 @@\n-            String msg = \"Cycle duration (\" + cyclesActual + \"), pause duration (\" + pausesActual + \")\";\n-            if (pausesActual <= cyclesActual) {\n+            long actualPauseDuration = pausesDuration.get();\n+            long actualCycleDuration = cyclesDuration.get();\n+\n+            String msg = \"Pauses duration (\" + actualPauseDuration + \") is expected to be not larger than cycles duration (\" + actualCycleDuration + \")\";\n+\n+            if (actualPauseDuration <= actualCycleDuration) {\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":55,"deletions":26,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocLargeObj\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargeObj.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocLargerThanHeap\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocLargerThanHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAllocSmallObj\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestAllocSmallObj.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestClassLoaderLeak\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestThreadFailure\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestAlwaysPreTouch\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestAlwaysPreTouch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestArgumentRanges\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestArgumentRanges.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestClassUnloadingArguments\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestClassUnloadingArguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestEnabled\n+ * @test id=default\n@@ -35,1 +35,1 @@\n- * @test TestEnabledAlready\n+ * @test id=already\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestEnabled.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestExplicitGC\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestExplicitGC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestExplicitGCNoConcurrent\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestExplicitGCNoConcurrent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHeuristicsUnlock\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHeuristicsUnlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHumongousMoves\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousMoves.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestHumongousThresholdArgs\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestLoopMiningArguments\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestLoopMiningArguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestModeUnlock\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestObjectAlignment\n+ * @test id=default\n@@ -40,1 +40,1 @@\n- * @test TestObjectAlignment\n+ * @test id=16b\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestObjectAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestPacing\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestPacing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestParallelRegionStride\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestParallelRegionStride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestRegionSizeArgs\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestRegionSizeArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestSelectiveBarrierFlags\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSelectiveBarrierFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestSingleThreaded\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSingleThreaded.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestSoftMaxHeapSize\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestSoftMaxHeapSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestThreadCounts\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestThreadCounts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test TestThreadCountsOverride\n+ * @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestThreadCountsOverride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestWrongBarrierDisable\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierDisable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* @test TestWrongBarrierEnable\n+\/* @test\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestWrongBarrierEnable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    private static final int CARDSIZE = 512; \/\/ Card size in bytes.\n+\n@@ -232,2 +234,2 @@\n-        \/\/ threshold for sparce -> fine\n-        final int FINE = WB.getIntxVMFlag(\"G1RSetSparseRegionEntries\").intValue();\n+        \/\/ Threshold for Array of Cards -> Howl\n+        final int ARRAY_TO_HOWL_THRESHOLD = WB.getUintVMFlag(\"G1RemSetArrayOfCardsEntries\").intValue();\n@@ -235,2 +237,4 @@\n-        \/\/ threshold for fine -> coarse\n-        final int COARSE = WB.getIntxVMFlag(\"G1RSetRegionEntries\").intValue();\n+        \/\/ Threshold for Howl -> Full\n+        int coarsenHowlToFullPercent = WB.getUintVMFlag(\"G1RemSetCoarsenHowlToFullPercent\").intValue();\n+        int cardsPerRegion = WB.getSizeTVMFlag(\"G1HeapRegionSize\").intValue() \/ CARDSIZE;\n+        final int HOWL_TO_FULL_THRESHOLD = (cardsPerRegion * coarsenHowlToFullPercent) \/ 100;\n@@ -244,2 +248,7 @@\n-        int[] regToRegRefCounts = {0, FINE \/ 2, 0, FINE, (FINE + COARSE) \/ 2, 0,\n-            COARSE, COARSE + 10, FINE + 1, FINE \/ 2, 0};\n+        int[] regToRegRefCounts = {\n+            0, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0, ARRAY_TO_HOWL_THRESHOLD,\n+            (ARRAY_TO_HOWL_THRESHOLD + HOWL_TO_FULL_THRESHOLD) \/ 2, 0,\n+            HOWL_TO_FULL_THRESHOLD, HOWL_TO_FULL_THRESHOLD + 10,\n+            ARRAY_TO_HOWL_THRESHOLD + 1, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0};\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @test TestGCBasherWithShenandoah\n+ * @test id=passive\n@@ -49,1 +49,1 @@\n- * @test TestGCBasherWithShenandoah\n+ * @test id=aggressive\n@@ -72,1 +72,1 @@\n- * @test TestGCBasherWithShenandoah\n+ * @test id=adaptive\n@@ -90,1 +90,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=compact\n@@ -103,1 +103,1 @@\n- * @test TestGCBasherWithShenandoah\n+ * @test id=iu-aggressive\n@@ -126,1 +126,1 @@\n- * @test TestGCBasherWithShenandoah\n+ * @test id=iu\n@@ -144,1 +144,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=passive-deopt-nmethod\n@@ -165,1 +165,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=aggressive-deopt-nmethod\n@@ -191,1 +191,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=adaptive-deopt-nmethod\n@@ -211,1 +211,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=compact-deopt-nmethod\n@@ -225,1 +225,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=iu-aggressive-deopt-nmethod\n@@ -251,1 +251,1 @@\n- * @test TestGCBasherDeoptWithShenandoah\n+ * @test id=iu-deopt-nmethod\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithShenandoah.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestGCLockerWithShenandoah\n+ * @test id=default\n@@ -44,1 +44,1 @@\n- * @test TestGCLockerWithShenandoah\n+ * @test id=aggressive\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=passive\n@@ -55,1 +55,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=aggressive\n@@ -77,1 +77,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=adaptive\n@@ -94,1 +94,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=compact\n@@ -106,1 +106,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=iu-aggressive\n@@ -128,1 +128,1 @@\n- * @test TestGCOldWithShenandoah\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gcold\/TestGCOldWithShenandoah.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestSystemGCWithShenandoah\n+ * @test id=default\n@@ -45,1 +45,1 @@\n- * @test TestSystemGCWithShenandoah\n+ * @test id=iu\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,14 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationAgeThreshold\n+ * @run driver gc.stringdedup.TestStringDeduplicationAgeThreshold G1\n+ *\/\n+\n+\/*\n+ * @test TestStringDeduplicationAgeThreshold\n+ * @summary Test string deduplication age threshold\n+ * @bug 8029075\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationAgeThreshold Shenandoah\n@@ -41,0 +54,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,14 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationFullGC\n+ * @run driver gc.stringdedup.TestStringDeduplicationFullGC G1\n+ *\/\n+\n+\/*\n+ * @test TestStringDeduplicationFullGC\n+ * @summary Test string deduplication during full GC\n+ * @bug 8029075\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationFullGC Shenandoah\n@@ -41,0 +54,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationFullGC.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,1 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationInterned\n+ * @run driver gc.stringdedup.TestStringDeduplicationInterned G1\n@@ -41,0 +41,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationInterned.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,14 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationPrintOptions\n+ * @run driver gc.stringdedup.TestStringDeduplicationPrintOptions G1\n+ *\/\n+\n+\/*\n+ * @test TestStringDeduplicationPrintOptions\n+ * @summary Test string deduplication print options\n+ * @bug 8029075\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationPrintOptions Shenandoah\n@@ -41,0 +54,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationPrintOptions.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,14 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationTableResize\n+ * @run driver gc.stringdedup.TestStringDeduplicationTableResize G1\n+ *\/\n+\n+\/*\n+ * @test TestStringDeduplicationTableResize\n+ * @summary Test string deduplication table resize\n+ * @bug 8029075\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationTableResize Shenandoah\n@@ -41,0 +54,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTableResize.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    private static String selectedGC = null;\n+\n@@ -66,0 +68,4 @@\n+    public static void selectGC(String[] args) {\n+        selectedGC = args[0];\n+    }\n+\n@@ -229,0 +235,1 @@\n+        args.add(\"-XX:+Use\" + selectedGC + \"GC\");\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationTools.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc == \"null\" | vm.gc == \"G1\" | vm.gc == \"Shenandoah\"\n+ * @requires vm.gc.G1\n@@ -36,1 +36,14 @@\n- * @run driver gc.stringdedup.TestStringDeduplicationYoungGC\n+ * @run driver gc.stringdedup.TestStringDeduplicationYoungGC G1\n+ *\/\n+\n+\/*\n+ * @test TestStringDeduplicationYoungGC\n+ * @summary Test string deduplication during young GC\n+ * @bug 8029075\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc:open\n+ * @modules java.base\/java.lang:open\n+ *          java.management\n+ * @run driver gc.stringdedup.TestStringDeduplicationYoungGC Shenandoah\n@@ -41,0 +54,1 @@\n+        TestStringDeduplicationTools.selectGC(args);\n","filename":"test\/hotspot\/jtreg\/gc\/stringdedup\/TestStringDeduplicationYoungGC.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        command.add(\"--gtest_catch_exceptions=0\" + resultFile);\n+        command.add(\"--gtest_catch_exceptions=0\");\n","filename":"test\/hotspot\/jtreg\/gtest\/GTestWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:BiasedLockingStartupDelay=4000 -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n+ * @run main\/othervm -XX:+PrintCommandLineFlags -XX:-ShowMessageBoxOnError -XX:ParallelGCThreads=4 -XX:MaxRAM=1G -XX:ErrorFile=\"file\" PrintAsFlag\n","filename":"test\/hotspot\/jtreg\/runtime\/7167069\/PrintAsFlag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-        excludeTestMaxRange(\"G1RSetRegionEntries\");\n-        excludeTestMaxRange(\"G1RSetSparseRegionEntries\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,7 +45,3 @@\n-        {\"-Xint\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xint\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:+UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:-UseBiasedLocking\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:+UseOptoBiasInlining\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:-UseOptoBiasInlining\"}\n+        {\"-Xint\"},\n+        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\"},\n+        {\"-Xcomp\", \"-XX:-TieredCompilation\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnValueBasedClassTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n@@ -62,1 +62,1 @@\n-        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 8 \/* mtInternal *\/ );\n+        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 9 \/* mtInternal *\/ );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocSiteTypeChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n- * @requires vm.compMode==\"Xmixed\" &\n+ * @requires vm.compMode == \"Xmixed\" &\n+ *           vm.compiler2.enabled &\n@@ -113,1 +114,3 @@\n-        wb.enqueueMethodForCompilation(cons,  CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!wb.enqueueMethodForCompilation(cons, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION)) {\n+            throw new RuntimeException(\"Failed to queue constructor for compilation\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Nestmates\/protectionDomain\/TestDifferentProtectionDomains.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.util.concurrent.Semaphore;\n+\n@@ -27,1 +29,1 @@\n-    private Object thread_sync = null;\n+    private Semaphore mainSync = null;\n@@ -29,1 +31,1 @@\n-    public ClassLoadingThread(ClassLoader loader, Object sync) {\n+    public ClassLoadingThread(ClassLoader loader, Semaphore sem) {\n@@ -31,1 +33,1 @@\n-        thread_sync = sync;\n+        mainSync = sem;\n@@ -50,3 +52,3 @@\n-            \/\/ Wake up the second thread\n-            synchronized (thread_sync) {\n-                thread_sync.notify();\n+            \/\/ Signal main thread to start t2.\n+            if (mainSync != null) {\n+                mainSync.release();\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.concurrent.Semaphore;\n@@ -63,1 +64,0 @@\n-    private Object thread_sync = new Object();\n@@ -65,0 +65,1 @@\n+    private static Semaphore mainSem = new Semaphore(0);\n@@ -69,4 +70,3 @@\n-        \/\/ Wake up the second thread here.\n-        synchronized (thread_sync) {\n-            thread_sync.notify();\n-        }\n+        \/\/ Signal main thread to start t2.\n+        mainSem.release();\n+\n@@ -139,1 +139,1 @@\n-            threads[i] = new ClassLoadingThread(this, thread_sync);\n+            threads[i] = new ClassLoadingThread(this, parallel ? null : mainSem);\n@@ -145,6 +145,4 @@\n-                synchronized(thread_sync) {\n-                    try {\n-                        ThreadPrint.println(\"t2 waits\");\n-                        thread_sync.wait();\n-                    } catch (InterruptedException e) {}\n-                }\n+                try {\n+                    ThreadPrint.println(\"Main thread calls mainSem.acquire()\");\n+                    mainSem.acquire();\n+                } catch (InterruptedException e) {}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,1 +31,33 @@\n- * @run driver SharedBaseAddress\n+ * @run driver SharedBaseAddress 0\n+ *\/\n+\n+\/**\n+ * @test SharedBaseAddress\n+ * @bug 8265705 8267351\n+ * @summary Test variety of values for SharedBaseAddress, making sure\n+ *          VM handles normal values as well as edge values w\/o a crash.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver SharedBaseAddress 1\n+ *\/\n+\n+\/**\n+ * @test SharedBaseAddress\n+ * @bug 8265705 8267351\n+ * @summary Test variety of values for SharedBaseAddress, making sure\n+ *          VM handles normal values as well as edge values w\/o a crash.\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @run driver SharedBaseAddress 0 provoke\n+ *\/\n+\n+\/**\n+ * @test SharedBaseAddress\n+ * @bug 8265705 8267351\n+ * @summary Test variety of values for SharedBaseAddress, making sure\n+ *          VM handles normal values as well as edge values w\/o a crash.\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @run driver SharedBaseAddress 1 provoke\n@@ -61,0 +93,8 @@\n+        int mid = testTable.length \/ 2;\n+        int start = args[0].equals(\"0\") ? 0 : mid;\n+        int end   = args[0].equals(\"0\") ? mid : testTable.length;\n+        boolean provoke = (args.length > 1 && args[1].equals(\"provoke\"));\n+\n+        \/\/ provoke == true: we want to increase the chance that mapping the generated archive at the designated base\n+        \/\/ succeeds, to test Klass pointer encoding at that weird location. We do this by sizing heap + class space\n+        \/\/ small, and by switching off compressed oops.\n@@ -62,11 +102,7 @@\n-        for (int run = 0; run < 2; run ++) {\n-            \/\/ We run twice:\n-            \/\/ Once, where we want to increase the chance that mapping the generated archive at the designated base\n-            \/\/ succeeds, to test Klass pointer encoding at that weird location. We do this by sizing heap + class space\n-            \/\/ small, and by switching off compressed oops.\n-            \/\/ On the second run, we don't do this but instead go with default parameters. This is more of a test of\n-            \/\/ CDS' ability to recover if mapping at runtime fails.\n-            for (String testEntry : testTable) {\n-                String filename = \"SharedBaseAddress-base\" + testEntry + \"-run\" + run + \".jsa\";\n-                System.out.println(\"sharedBaseAddress = \" + testEntry);\n-                CDSOptions opts = (new CDSOptions())\n+        \/\/ provoke == false:  we just go with default parameters. This is more of a test of\n+        \/\/ CDS' ability to recover if mapping at runtime fails.\n+        for (int i = start; i < end; i++) {\n+            String testEntry = testTable[i];\n+            String filename = \"SharedBaseAddress-base\" + testEntry + \".jsa\";\n+            System.out.println(\"sharedBaseAddress = \" + testEntry);\n+            CDSOptions opts = (new CDSOptions())\n@@ -82,12 +118,16 @@\n-                if (run == 0 && Platform.is64bit()) {\n-                    opts.addPrefix(\"-Xmx128m\")\n-                        .addPrefix(\"-XX:CompressedClassSpaceSize=32m\")\n-                        .addPrefix(\"-XX:-UseCompressedOops\");\n-                }\n-                CDSTestUtils.createArchiveAndCheck(opts);\n-                OutputAnalyzer out = CDSTestUtils.runWithArchiveAndCheck(opts);\n-                if (testEntry.equals(\"0\")) {\n-                    out.shouldContain(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\")\n-                            .shouldContain(\"Try to map archive(s) at an alternative address\")\n-                            .shouldNotMatch(failedPattern);\n-                }\n+            if (provoke) {\n+                opts.addPrefix(\"-Xmx128m\")\n+                    .addPrefix(\"-XX:CompressedClassSpaceSize=32m\")\n+                    .addPrefix(\"-XX:-UseCompressedOops\");\n+            }\n+            if (Platform.isDebugBuild()) {\n+                \/\/ Make VM start faster in debug build with large heap.\n+                opts.addPrefix(\"-XX:-ZapUnusedHeapArea\");\n+            }\n+\n+            CDSTestUtils.createArchiveAndCheck(opts);\n+            OutputAnalyzer out = CDSTestUtils.runWithArchiveAndCheck(opts);\n+            if (testEntry.equals(\"0\")) {\n+                out.shouldContain(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\")\n+                   .shouldContain(\"Try to map archive(s) at an alternative address\")\n+                   .shouldNotMatch(failedPattern);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedBaseAddress.java","additions":64,"deletions":24,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Non jar file in the classpath will be skipped during dump time and runtime.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver NonJarInClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NonJarInClasspath {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"hellomore\", \"HelloMore\");\n+\n+        String outDir = CDSTestUtils.getOutputDir();\n+        String newFile = \"non-exist.jar\";\n+        String nonJarPath = outDir + File.separator + newFile;\n+        String classPath = appJar + File.pathSeparator + nonJarPath + File.pathSeparator + appJar2;\n+        File nonJar = new File(outDir, newFile);\n+        nonJar.createNewFile();\n+\n+        TestCommon.testDump(classPath, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        TestCommon.run(\n+            \"-cp\", classPath,\n+            \"-Xlog:class+load\",\n+            \"Hello\")\n+          .assertNormalExit(out -> {\n+              out.shouldContain(\"Hello source: shared objects file\");\n+          });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonJarInClasspath.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -65,1 +65,1 @@\n-                               \"Pre JDK 6 class not supported by CDS\");\n+                               \"Skipping Hello: Old class has been linked\");\n@@ -86,1 +86,1 @@\n-                               \"Pre JDK 6 class not supported by CDS\");\n+                               \"Skipping Hello: Old class has been linked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                                   \"Pre JDK 6 class not supported by CDS: 49.0 OldInfDefMeth\");\n+                                   \"Skipping OldInfDefMeth: Old class has been linked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldInfExtendsInfDefMeth.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                                   \"Pre JDK 6 class not supported by CDS: 49.0 OldSuper\",\n+                                   \"Skipping OldSuper: Old class has been linked\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldSuperClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                                   \"Pre JDK 6 class not supported by CDS: 49.0 OldInf\",\n+                                   \"Skipping OldInf: Old class has been linked\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldSuperInf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                                   \"Pre JDK 6 class not supported by CDS: 49.0 OldInf\",\n+                                   \"Skipping OldInf: Old class has been linked\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldSuperInfIndirect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency on\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency auto\n@@ -72,0 +73,3 @@\n+    public static boolean shareAuto;       \/\/ true  == -Xshare:auto\n+                                           \/\/ false == -Xshare:on\n+\n@@ -83,0 +87,2 @@\n+    public static final String HELLO_WORLD = \"Hello World\";\n+\n@@ -342,1 +348,1 @@\n-        OutputAnalyzer output = TestCommon.execCommon(execArgs);\n+        OutputAnalyzer output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -364,0 +370,8 @@\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"One arg of 'on' or 'auto' to run the test\");\n+        }\n+        if (!args[0].equals(\"on\") && !args[0].equals(\"auto\")) {\n+            throw new RuntimeException(\"Arg must be 'on' or 'auto'\");\n+        }\n+        shareAuto = args[0].equals(\"auto\");\n+\n@@ -383,1 +397,1 @@\n-        OutputAnalyzer output = TestCommon.execCommon(execArgs);\n+        OutputAnalyzer output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -386,1 +400,1 @@\n-            TestCommon.checkExecReturn(output, 0, true, \"Hello World\");\n+            TestCommon.checkExecReturn(output, 0, true, HELLO_WORLD);\n@@ -400,1 +414,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -403,0 +417,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -407,1 +424,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -410,6 +427,3 @@\n-\n-        \/\/ use the same archive as above, but run with -Xshare:auto\n-        System.out.println(\"\\n2b. Corrupt _jvm_ident run with -Xshare:auto\\n\");\n-        output = TestCommon.execAuto(execArgs);\n-        output.shouldContain(\"The shared archive file was created by a different version or build of HotSpot\");\n-        output.shouldContain(\"Hello World\");\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -420,1 +434,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -423,0 +437,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -427,1 +444,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -430,0 +447,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n@@ -445,1 +465,1 @@\n-        output = TestCommon.execCommon(execArgs);\n+        output = shareAuto ? TestCommon.execAuto(execArgs) : TestCommon.execCommon(execArgs);\n@@ -448,0 +468,3 @@\n+        if (shareAuto) {\n+            output.shouldContain(HELLO_WORLD);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Handling of duplicated classes in dynamic archive with custom loader\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build DuplicatedCustomApp CustomLoadee CustomLoadee2 CustomLoadee3 CustomLoadee3Child\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar DuplicatedCustomApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar custom.jar CustomLoadee\n+ *                  CustomLoadee2 CustomInterface2_ia CustomInterface2_ib\n+ *                  CustomLoadee3 CustomLoadee3Child\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar DuplicatedCustomTest\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DuplicatedCustomTest extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(DuplicatedCustomTest::testDefaultBase);\n+    }\n+\n+    private static void testDefaultBase() throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"custom.jar\");\n+        String mainAppClass = \"DuplicatedCustomApp\";\n+        String numberOfLoops = \"2\";\n+\n+        dump(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Written dynamic archive 0x\")\n+                      .shouldContain(\"Skipping CustomLoadee: Duplicated unregistered class\")\n+                      .shouldHaveExitValue(0);\n+                });\n+\n+        run(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds=debug\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"DuplicatedCustomApp source: shared objects file (top)\")\n+                      .shouldContain(\"CustomLoadee source: shared objects file (top)\")\n+                      .shouldHaveExitValue(0);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DuplicatedCustomTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+        \/\/ 1. Host class loaded by a custom loader is initialized during dump time.\n@@ -51,1 +52,1 @@\n-            \"-cp\", appJar, mainClass, appJar)\n+            \"-cp\", appJar, mainClass, appJar, \"init\")\n@@ -59,1 +60,1 @@\n-            \"-cp\", appJar, mainClass, appJar)\n+            \"-cp\", appJar, mainClass, appJar, \"init\")\n@@ -62,0 +63,17 @@\n+                      .shouldContain(\"LambHello source: shared objects file (top)\")\n+                      .shouldHaveExitValue(0);\n+            });\n+\n+        \/\/ 2. Host class loaded by a custom loader is NOT initialized during dump time.\n+        dump(topArchiveName,\n+            \"-Xlog:class+load,cds=debug,cds+dynamic\",\n+            \"-cp\", appJar, mainClass, appJar)\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0);\n+            });\n+\n+        run(topArchiveName,\n+            \"-Xlog:class+load,class+unload\",\n+            \"-cp\", appJar, mainClass, appJar)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"LambHello source: shared objects file (top)\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaCustomLoader.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-                \/\/ Nest host should be skipped since it is not in the linked state.\n-                output.shouldContain(\"Skipping Outer: Not linked\")\n+                \/\/ Nest host should not be skipped although it is not in the linked state.\n+                output.shouldNotContain(\"Skipping Outer: Not linked\")\n@@ -78,2 +78,1 @@\n-                \/\/ Only the Inner class is loaded from the dynamic archive.\n-                \/\/ The nest host (Outer) and its lambda proxy are not loaded\n+                \/\/ Only the nest host (Outer) and the Inner class are loaded\n@@ -81,1 +80,2 @@\n-                output.shouldMatch(\"class.load.*Outer.source:.*lambda_proxy_shutdown.jar\")\n+                \/\/ The lambda proxy is not loaded from the dynamic archive.\n+                output.shouldMatch(\"class.load.*Outer.source:.*shared.*objects.*file.*(top)\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaProxyDuringShutdown.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,3 +87,0 @@\n-                       .shouldContain(\"Pre JDK 6 class not supported by CDS: 49.0 \" + loadeesArray[0])\n-                       .shouldMatch(\"Skipping \" + loadeesArray[1] +\":.*\" + loadeesArray[0] + \" is excluded\")\n-                       .shouldMatch(\"Skipping \" + loadeesArray[2] +\": super.*\" + loadeesArray[1] + \" is excluded\")\n@@ -108,1 +105,1 @@\n-                    output.shouldMatch(\".class.load. \" + loadee + \" source:.*\" + loadeesJar);\n+                    output.shouldContain(loadee + \" source: shared objects file (top)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/OldClassAndInf.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                 output.shouldContain(\"ArchiveClassesAtExit has failed\")\n+                 output.shouldContain(\"Dynamic dump has failed\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestDynamicDumpAtOom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+        boolean init = false;\n+        if (args.length ==2 && args[1].equals(\"init\")) {\n+            init = true;\n+        }\n+\n@@ -41,1 +46,1 @@\n-        Class c = Class.forName(className, true, urlClassLoader);\n+        Class c = Class.forName(className, init, urlClassLoader);\n@@ -44,2 +49,0 @@\n-        Object o = c.newInstance();\n-\n@@ -51,3 +54,6 @@\n-        Method method = c.getMethod(\"main\", String[].class);\n-        String[] params = null;\n-        method.invoke(null, (Object)params);\n+        if (init) {\n+            Object o = c.newInstance();\n+            Method method = c.getMethod(\"main\", String[].class);\n+            String[] params = null;\n+            method.invoke(null, (Object)params);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/CustomLoaderApp.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import sun.hotspot.WhiteBox;\n+\n+public class DuplicatedCustomApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static URLClassLoader loaders[];\n+\n+    \/\/ If DuplicatedCustomApp.class is loaded from JAR file, it means we are dumping the\n+    \/\/ dynamic archive.\n+    static boolean is_dynamic_dumping = !wb.isSharedClass(DuplicatedCustomApp.class);\n+    static boolean is_running_with_dynamic_archive = !is_dynamic_dumping;\n+\n+    public static void main(String args[]) throws Exception {\n+        String path = args[0];\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        System.out.println(path);\n+        System.out.println(url);\n+\n+        int num_loops = 1;\n+        if (args.length > 1) {\n+            num_loops = Integer.parseInt(args[1]);\n+        }\n+        loaders = new URLClassLoader[num_loops];\n+        for (int i = 0; i < num_loops; i++) {\n+            loaders[i] = new URLClassLoader(urls);\n+        }\n+\n+        if (is_dynamic_dumping) {\n+            \/\/ Try to load the super interfaces of CustomLoadee2 in different orders\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 1) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ia\");\n+            }\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 2) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ib\");\n+            }\n+        }\n+\n+        for (int i = 0; i < num_loops; i++) {\n+            System.out.println(\"============================ LOOP = \" + i);\n+            URLClassLoader urlClassLoader = loaders[i];\n+            test(i, urlClassLoader, \"CustomLoadee\");\n+            test(i, urlClassLoader, \"CustomInterface2_ia\");\n+            test(i, urlClassLoader, \"CustomInterface2_ib\");\n+            test(i, urlClassLoader, \"CustomLoadee2\");\n+            test(i, urlClassLoader, \"CustomLoadee3\");\n+            test(i, urlClassLoader, \"CustomLoadee3Child\");\n+        }\n+    }\n+\n+    private static void test(int i, URLClassLoader urlClassLoader, String name) throws Exception {\n+        Class c = urlClassLoader.loadClass(name);\n+        try {\n+            c.newInstance(); \/\/ make sure the class is linked so it can be archived\n+        } catch (Throwable t) {}\n+        boolean is_shared = wb.isSharedClass(c);\n+\n+        System.out.println(\"Class = \" + c + \", loaded from \" + (is_shared ? \"CDS\" : \"Jar\"));\n+        System.out.println(\"Loader = \" + c.getClassLoader());\n+\n+        \/\/ [1] Check that the loaded class is defined by the correct loader\n+        if (c.getClassLoader() != urlClassLoader) {\n+            throw new RuntimeException(\"c.getClassLoader() == \" + c.getClassLoader() +\n+                                       \", expected == \" + urlClassLoader);\n+        }\n+\n+        if (is_running_with_dynamic_archive) {\n+            \/\/ There's only one copy of the shared class of <name> in the\n+            \/\/ CDS archive.\n+            if (i == 0) {\n+                \/\/ The first time we must be able to load it from CDS.\n+                if (!is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from CDS\");\n+                }\n+            } else {\n+                \/\/ All subsequent times, we must load this from JAR file.\n+                if (is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from JAR\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/DuplicatedCustomApp.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -62,2 +62,1 @@\n-            \/\/ i = 1 -- dump with agent = disable BiasedLocking\n-            \/\/ i = 2 -- dump with agent = enable BiasedLocking\n+            \/\/ i = 1 -- dump with agent\n@@ -67,1 +66,0 @@\n-            String biasedLock = (i != 2) ? \"-showversion\" : \"-XX:+UseBiasedLocking\";\n@@ -72,1 +70,1 @@\n-                                    agentArg, agentArg2, biasedLock);\n+                                    agentArg, agentArg2);\n@@ -79,1 +77,1 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2, biasedLock,\n+                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    protected static void test(String fileName, long pid,\n+    protected static OutputAnalyzer test(String fileName, long pid,\n@@ -203,0 +203,1 @@\n+        return output;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDumpBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        test(\"02.jsa\", pid, noBoot,  EXPECT_FAIL);\n+        test(\"02.jsa\", pid, noBoot,  EXPECT_PASS);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDynamicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8265465\n+ * @bug 8265465 8267075\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -46,0 +47,16 @@\n+    static final String promptStdout = \"please check stdout file\";\n+    static final String promptStderr = \"or stderr file\";\n+\n+    static void checkContainAbsoluteLogPath(OutputAnalyzer output) throws Exception {\n+       String stdText = output.getOutput();\n+       if (stdText.contains(promptStdout) &&\n+           stdText.contains(promptStderr)) {\n+           int a = stdText.indexOf(promptStdout);\n+           int b = stdText.indexOf(promptStderr);\n+           String stdOutFileName = stdText.substring(a + promptStdout.length() + 1, b - 1).trim();\n+           File   stdOutFile = new File(stdOutFileName);\n+           if (!stdOutFile.isAbsolute()) {\n+               throw new RuntimeException(\"Failed to set file name in absolute for prompting message\");\n+           }\n+        }\n+    }\n@@ -70,1 +87,0 @@\n-        app.stopApp();\n@@ -74,0 +90,7 @@\n+        \/\/ Illegal character in file name\n+        localFileName = \"mystatic:.jsa\";\n+        OutputAnalyzer output = test(localFileName, pid, noBoot,  EXPECT_FAIL);\n+        checkFileExistence(localFileName, false\/*exist*\/);\n+        checkContainAbsoluteLogPath(output);\n+        app.stopApp();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.test.lib.cds.CDSTestUtils;\n@@ -58,2 +57,0 @@\n-        boolean dynamicMode = CDSTestUtils.DYNAMIC_DUMP;\n-\n@@ -61,7 +58,2 @@\n-        \/\/ which have been linked during static CDS dump.\n-        \/\/ Dynamic CDS dump doesn't support old class.\n-        if (!dynamicMode) {\n-            output.shouldContain(\"Skipping OldSuper: Old class has been linked\");\n-        } else {\n-            output.shouldContain(\"Pre JDK 6 class not supported by CDS: 49.0 OldSuper\");\n-        }\n+        \/\/ which have been linked during CDS dump.\n+        output.shouldContain(\"Skipping OldSuper: Old class has been linked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/dumpingWithAgent\/OldClassWithJavaAgent.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268720\n+ * @summary Constant pool NameAndType entries with valid but incompatible method\n+ *          name and signature shouldn't cause an exception until referenced by\n+ *          a method_ref.\n+ * @compile nonVoidInitSig.jcod\n+ * @run main\/othervm -Xverify:remote NameAndTypeSig\n+ *\/\n+\n+\/\/ Test constant pool NameAndType descriptors with valid but incompatible method\n+\/\/ names and signatures.\n+public class NameAndTypeSig {\n+    public static void main(String args[]) throws Throwable {\n+\n+        \/\/ Test that an unreferenced NameAndType with a valid name and signature\n+        \/\/ is allowed even for name and signature pairs such as <init>()D.\n+        Class newClass = Class.forName(\"nonVoidInitSig\");\n+\n+        \/\/ Test that a NameAndType with a valid name and signature is allowed for\n+        \/\/ name and signature pairs such as <init>()D, but not allowed by a cp\n+        \/\/ Method_ref.\n+        try {\n+            Class newClass2 = Class.forName(\"nonVoidInitSigCFE\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class nonVoidInitSigCFE has illegal signature\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+\n+        \/\/ Test that a NameAndType with a valid name and invalid signature throws a\n+        \/\/ ClassFormatError exception with a message containing the name <init> and\n+        \/\/ the bad signature.\n+        try {\n+            Class newClass2 = Class.forName(\"voidInitBadSig\");\n+            throw new RuntimeException(\"Expected ClassFormatError exception not thrown\");\n+        } catch (java.lang.ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Method \\\"<init>\\\" in class voidInitBadSig has illegal signature \\\"()))V\\\"\")) {\n+                throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+        System.out.println(\"Test NameAndTypeSig passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/NameAndTypeSig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The constant pool in this class contains an unused NameAndType entry (#20)\n+\/\/ that points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+class nonVoidInitSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()D.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSig\n+\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#3) that\n+\/\/ points to method <init> and signature ()D.  This is a valid NameAndType\n+\/\/ because <init> is a valid method name and ()D is a valid method signature.\n+\/\/ But, a cp Methodref (#1) that points to NameAndType with a method named\n+\/\/ <init> and a non-void return type, is invalid.\n+class nonVoidInitSigCFE {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #19; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"nonVoidInitSigCFE\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"nonVoidInitSigCFE.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()D\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class nonVoidInitSigCFE\n+\n+\n+\/\/ The constant pool in this class contains a cp NameAndType entry (#20) that\n+\/\/ points to method <init> and signature ()))V.  This is an invalid NameAndType\n+\/\/ entry and should throw a ClassFormatError exception, with a message containing\n+\/\/ the name <init> and the bad signature, even thought the NameAndType is not\n+\/\/ referenced by a cp Methodref.\n+class voidInitBadSig {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  62; \/\/ version\n+  [21] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1     at 0x0A\n+    class #4; \/\/ #2     at 0x0F\n+    NameAndType #5 #6; \/\/ #3     at 0x12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x17\n+    Utf8 \"<init>\"; \/\/ #5     at 0x2A\n+    Utf8 \"()V\"; \/\/ #6     at 0x33\n+    class #8; \/\/ #7     at 0x39\n+    Utf8 \"voidInitBadSig\"; \/\/ #8     at 0x3C\n+    Method #7 #3; \/\/ #9     at 0x47\n+    Utf8 \"Code\"; \/\/ #10     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x53\n+    Utf8 \"func\"; \/\/ #12     at 0x65\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #13     at 0x6C\n+    Utf8 \"Exceptions\"; \/\/ #14     at 0x85\n+    class #16; \/\/ #15     at 0x92\n+    Utf8 \"java\/lang\/Throwable\"; \/\/ #16     at 0x95\n+    Utf8 \"SourceFile\"; \/\/ #17     at 0xAB\n+    Utf8 \"voidInitBadSig.java\"; \/\/ #18     at 0xB8\n+    Utf8 \"()))V\"; \/\/ #19\n+    NameAndType #5 #19; \/\/ #20 \/\/ Unused, points to <init>()))V.\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0xD4\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index       : <init>\n+      #6; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 29) { \/\/ Code at 0xDC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70001B1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0xF3\n+              [1] { \/\/ line_number_table\n+                0  1; \/\/  at 0xFF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0xFF\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : func\n+      #13; \/\/ descriptor_index : ([Ljava\/lang\/String;)V\n+      [2] { \/\/ Attributes\n+        Attr(#10, 37) { \/\/ Code at 0x0107\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[9]{\n+            0xBB000759B700094C;\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x0122\n+              [2] { \/\/ line_number_table\n+                0  4; \/\/  at 0x012E\n+                8  5; \/\/  at 0x0132\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#14, 4) { \/\/ Exceptions at 0x0132\n+          [1] { \/\/ Exceptions\n+            #15; \/\/  at 0x013C\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#17, 2) { \/\/ SourceFile at 0x013E\n+      #18;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class voidInitBadSig\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/nonVoidInitSig.jcod","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -31,2 +31,3 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI HandshakeDirectTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot HandshakeDirectTest\n@@ -38,0 +39,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +44,1 @@\n-    static final int DIRECT_HANDSHAKES_MARK = 500000;\n+    static final int DIRECT_HANDSHAKES_MARK = 300000;\n@@ -44,1 +46,0 @@\n-    static Semaphore[] handshakeSem = new Semaphore[WORKING_THREADS];\n@@ -46,1 +47,0 @@\n-    static boolean[] isBiased = new boolean[WORKING_THREADS];\n@@ -52,0 +52,1 @@\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -53,10 +54,3 @@\n-        while (true) {\n-            try {\n-                if (!isBiased[me]) {\n-                    handshakeSem[me].acquire();\n-                    synchronized(locks[me]) {\n-                        isBiased[me] = true;\n-                    }\n-                    handshakeSem[me].release();\n-                }\n-\n+        while (handshakeCount.get() < DIRECT_HANDSHAKES_MARK) {\n+            boolean walked = false;\n+            synchronized(locks[me]) {\n@@ -69,13 +63,5 @@\n-                handshakeSem[handshakee].acquire();\n-                if (isBiased[handshakee]) {\n-                    \/\/ Revoke biased lock\n-                    synchronized(locks[handshakee]) {\n-                        handshakeCount.incrementAndGet();\n-                    }\n-                    \/\/ Create new lock to be biased\n-                    locks[handshakee] = new Object();\n-                    isBiased[handshakee] = false;\n-                }\n-                handshakeSem[handshakee].release();\n-                if (handshakeCount.get() >= DIRECT_HANDSHAKES_MARK) {\n-                    break;\n+                \/\/ Inflate locks[handshakee] if possible\n+                System.identityHashCode(locks[handshakee]);\n+                walked = wb.handshakeReadMonitors(workingThreads[handshakee]);\n+                if (walked) {\n+                    handshakeCount.incrementAndGet();\n@@ -83,2 +69,0 @@\n-            } catch(InterruptedException ie) {\n-                throw new Error(\"Unexpected interrupt\");\n@@ -86,0 +70,1 @@\n+            locks[me] = new Object();\n@@ -92,5 +77,0 @@\n-        \/\/ Initialize semaphores\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            handshakeSem[i] = new Semaphore(1);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":15,"deletions":35,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263640\n+ * @summary In case of a class path is longer than O_BUFLEN, the class path\n+ *          should not be truncated in the output from jcmd VM.command_line.\n+ * @library \/test\/lib\n+ * @run driver JcmdCmdLine\n+ *\/\n+\n+import java.io.File;\n+import java.util.List;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class JcmdCmdLine {\n+    private static LingeredApp theApp = null;\n+    private static final int BUFFER_LEN = 2000;\n+    private static final String JCMD_OPT = \"VM.command_line\";\n+    private static final String CLASS_PATH_LINE = \"java_class_path (initial):\";\n+    private static final String TRUNCATE_WARNING = \"outputStream::do_vsnprintf output truncated\";\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            theApp = new LingeredApp();\n+            theApp.setUseDefaultClasspath(false);\n+            String classPath = System.getProperty(\"test.class.path\");\n+            while (classPath.length() < BUFFER_LEN) {\n+                classPath += File.pathSeparator + classPath;\n+            }\n+            LingeredApp.startAppExactJvmOpts(theApp, \"-cp\",  classPath);\n+            long pid = theApp.getPid();\n+\n+            PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(String.valueOf(pid));\n+            OutputAnalyzer output = cmdExecutor.execute(JCMD_OPT, true\/*silent*\/);\n+            output.shouldHaveExitValue(0);\n+            boolean seenClassPath = false;\n+            List<String> lines = output.asLines();\n+            for (int i = 0; i < lines.size(); i++) {\n+                String line = lines.get(i);\n+                if (line.startsWith(CLASS_PATH_LINE)) {\n+                    seenClassPath = true;\n+                    if (!line.endsWith(classPath)) {\n+                        throw new RuntimeException(\"Incomplete java_class_path line.\");\n+                    }\n+                }\n+            }\n+            if (!seenClassPath) {\n+                throw new RuntimeException(\"Missing java_class_path line.\");\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+            if (theApp.getOutput().getStderr().contains(TRUNCATE_WARNING)) {\n+                throw new RuntimeException(\"Unexpected truncation warning.\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jcmd\/JcmdCmdLine.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test TestPrimitiveArrayCriticalWithBadParam\n+ * @bug 8269697\n+ * @summary -Xcheck:jni should catch wrong parameter passed to GetPrimitiveArrayCritical\n+ * @library \/test\/lib\n+ * @run main\/native TestPrimitiveArrayCriticalWithBadParam\n+ *\/\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+\n+public class TestPrimitiveArrayCriticalWithBadParam {\n+    static {\n+        System.loadLibrary(\"TestBadParam\");\n+    }\n+\n+    private static native void pin(Object[] a);\n+    private static native void unpin(Object[] a);\n+\n+    public static void main(String[] args) {\n+        if (args.length > 0) {\n+            test();\n+        } else {\n+            runTest();\n+        }\n+    }\n+\n+    private static void runTest() {\n+        List<String> pbArgs = new ArrayList<>();\n+        pbArgs.add(\"-Xcheck:jni\");\n+        pbArgs.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        pbArgs.add(TestPrimitiveArrayCriticalWithBadParam.class.getName());\n+        pbArgs.add(\"test\");\n+        try {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(pbArgs.toArray(new String[0]));\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+            \/\/ -Xcheck:jni should warn the bad parameter\n+            analyzer.shouldContain(\"FATAL ERROR in native method: Primitive type array expected but not received for JNI array operation\");\n+            analyzer.shouldNotHaveExitValue(0);\n+        } catch (IOException e) {\n+            throw  new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void test() {\n+        Object[] objs = new Object[10];\n+        for (int i = 0; i < objs.length; i++) {\n+            objs[i] = new MyClass();\n+        }\n+        pin(objs);\n+        System.out.println(\"Object array pinned\");\n+        unpin(objs);\n+    }\n+    public static class MyClass {\n+        public Object ref = new Object();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <jni.h>\n+#include <string.h>\n+\n+static jint* pinned;\n+\n+JNIEXPORT void JNICALL\n+Java_TestPrimitiveArrayCriticalWithBadParam_pin(JNIEnv *env, jclass unused, jarray a) {\n+  pinned = (*env)->GetPrimitiveArrayCritical(env, a, 0);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestPrimitiveArrayCriticalWithBadParam_unpin(JNIEnv *env, jclass unused, jarray a) {\n+  (*env)->ReleasePrimitiveArrayCritical(env, a, pinned, 0);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libTestBadParam.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149383\n- * @summary -Xlog:biasedlocking should have logging from statements in the source code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver BiasedLockingTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BiasedLockingTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Biased locking enabled\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[biasedlocking]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                                  \"-Xlog:biasedlocking\",\n-                                                                  \"-XX:BiasedLockingStartupDelay=0\",\n-                                                                  InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-Xlog:biasedlocking=off\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) {\n-            System.out.println(\"Biased Locking test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BiasedLockingTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        output.shouldContain(\"Thread started\");\n+        output.shouldMatch(\"Thread .* started\");\n@@ -65,1 +65,1 @@\n-\n+        output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ThreadLoggingTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8129579\n+ * @bug 8219579\n@@ -36,1 +36,1 @@\n-        System.out.println(\"Regression test for bug 819579\");\n+        System.out.println(\"Regression test for bug 8219579\");\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestSigParse.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        this(className, new ArgumentHandler(new String[0]));\n+        this(className, new ArgumentHandler(new String[] {\"-transport.address=dynamic\"}));\n@@ -80,1 +80,5 @@\n-            pipe.println(\"quit\");\n+            if (pipe.isConnected()) {\n+                pipe.println(\"quit\");\n+            } else {\n+                System.out.println(\"WARNING: IOPipe is not connected\");\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    public void run(CommandExecutor executor) throws IOException {\n+    public void run(CommandExecutor executor, boolean overwrite) throws IOException {\n@@ -55,1 +55,1 @@\n-        if (dump.exists()) {\n+        if (!overwrite && dump.exists()) {\n@@ -57,0 +57,2 @@\n+        } else if (overwrite) {\n+            dump.createNewFile();\n@@ -59,1 +61,1 @@\n-        String cmd = \"GC.heap_dump \" + heapDumpArgs + \" \" + dump.getAbsolutePath();\n+        String cmd = \"GC.heap_dump \" + (overwrite ? \"-overwrite \" : \"\") + heapDumpArgs + \" \" + dump.getAbsolutePath();\n@@ -88,1 +90,6 @@\n-        run(new PidJcmdExecutor());\n+        run(new PidJcmdExecutor(), false);\n+    }\n+\n+    @Test\n+    public void pidRewrite() throws IOException {\n+        run(new PidJcmdExecutor(), true);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/HeapDumpTest.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command VM.trim_libc_heap\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng TrimLibcHeapTest\n+ *\/\n+public class TrimLibcHeapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"System.trim_native_heap\");\n+        output.reportDiagnosticSummary();\n+        output.shouldMatch(\"(Done|Not available)\"); \/\/ Not available could happen on Linux + non-glibc (eg. muslc)\n+        if (output.firstMatch(\"Done\") != null) {\n+            output.shouldMatch(\"(Virtual size before|RSS before|Swap before|No details available)\");\n+        }\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            channel.connect();\n+            channel.connect(launcher.getJdwpPort());\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/AllModulesCommandTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import java.io.IOException;\n-import java.net.ServerSocket;\n@@ -28,1 +26,1 @@\n-import jdk.test.lib.Utils;\n+import jdk.test.lib.JDWP;\n@@ -58,1 +56,1 @@\n-    private static int jdwpPort = -1;\n+    private int jdwpPort = -1;\n@@ -120,1 +118,1 @@\n-        return \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=\" + getJdwpPort();\n+        return \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\";\n@@ -124,1 +122,1 @@\n-     * Find an available port for the JDWP session\n+     * Gets JDWP port debuggee is listening on.\n@@ -128,5 +126,2 @@\n-    public static int getJdwpPort() {\n-        if (jdwpPort == -1) {\n-            jdwpPort = findFreePort();\n-            assertFalse(jdwpPort == -1, \"Can not find vailbale port for JDWP\");\n-        }\n+    public int getJdwpPort() {\n+        assertFalse(jdwpPort == -1, \"JDWP port is not detected\");\n@@ -136,8 +131,0 @@\n-    private static int findFreePort() {\n-        try (ServerSocket socket = new ServerSocket(0)) {\n-            return socket.getLocalPort();\n-        } catch (IOException e) {\n-        }\n-        return -1;\n-    }\n-\n@@ -155,0 +142,6 @@\n+        if (jdwpPort == -1) {\n+            JDWP.ListenAddress addr = JDWP.parseListenAddress(line);\n+            if (addr != null) {\n+                jdwpPort = Integer.parseInt(addr.address());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/DebuggeeLauncher.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    public void connect() throws IOException {\n-        sock = new Socket(\"localhost\", DebuggeeLauncher.getJdwpPort());\n+    public void connect(int jdwpPort) throws IOException {\n+        sock = new Socket(\"localhost\", jdwpPort);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/JdwpChannel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -55,1 +55,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -67,1 +67,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -79,37 +79,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorStackDepthInfo\/GetOwnedMonitorStackDepthInfoWithEATest.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -124,1 +124,1 @@\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -135,1 +135,1 @@\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  \/\/ Do 100000 iterations and expect maxIteration \/ multiplier samples.\n-  private static final int maxIteration = 100000;\n+  \/\/ Do 200000 iterations and expect maxIteration \/ multiplier samples.\n+  private static final int maxIteration = 200_000;\n@@ -43,0 +43,6 @@\n+  \/\/ 15% error ensures a sanity test without becoming flaky.\n+  \/\/ Flakiness is due to the fact that this test is dependent on the sampling interval, which is a\n+  \/\/ statistical geometric variable around the sampling interval. This means that the test could be\n+  \/\/ unlucky and not achieve the mean average fast enough for the test case.\n+  private static final int acceptedErrorPercentage = 15;\n+\n@@ -88,5 +94,1 @@\n-        \/\/ 10% error ensures a sanity test without becoming flaky.\n-        \/\/ Flakiness is due to the fact that this test is dependent on the sampling interval, which is a\n-        \/\/ statistical geometric variable around the sampling interval. This means that the test could be\n-        \/\/ unlucky and not achieve the mean average fast enough for the test case.\n-        if (HeapMonitor.statsHaveExpectedNumberSamples((int) expected, 10)) {\n+        if (HeapMonitor.statsHaveExpectedNumberSamples((int) expected, acceptedErrorPercentage)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    int allocationIterations = 10;\n+    int allocationIterations = 20;\n@@ -61,1 +61,1 @@\n-    boolean success = (errorPercentage < 10.0);\n+    boolean success = (errorPercentage < 15.0);\n@@ -67,1 +67,1 @@\n-      throw new RuntimeException(\"Interval average over 10% for interval \" + interval + \" -> \"\n+      throw new RuntimeException(\"Interval average over 15% for interval \" + interval + \" -> \"\n@@ -77,1 +77,1 @@\n-    \/\/ the 10% mark. So try again to squash flakiness.\n+    \/\/ the 15% mark. So try again to squash flakiness.\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-  \/\/ Do 200000 iterations and expect maxIteration \/ multiplier samples.\n-  private static final int maxIteration = 200000;\n+  \/\/ Do 400000 iterations and expect maxIteration \/ multiplier samples.\n+  private static final int maxIteration = 400_000;\n@@ -43,1 +43,5 @@\n-  private native static boolean statsHaveExpectedNumberSamples(int expected, int percentError);\n+  \/\/ 15% error ensures a sanity test without becoming flaky.\n+  \/\/ Flakiness is due to the fact that this test is dependent on the sampling interval, which is a\n+  \/\/ statistical geometric variable around the sampling interval. This means that the test could be\n+  \/\/ unlucky and not achieve the mean average fast enough for the test case.\n+  private static final int acceptedErrorPercentage = 15;\n@@ -86,5 +90,1 @@\n-    \/\/ 10% error ensures a sanity test without becoming flaky.\n-    \/\/ Flakiness is due to the fact that this test is dependent on the sampling interval, which is a\n-    \/\/ statistical geometric variable around the sampling interval. This means that the test could be\n-    \/\/ unlucky and not achieve the mean average fast enough for the test case.\n-    if (!HeapMonitor.statsHaveExpectedNumberSamples((int) expected, 10)) {\n+    if (!HeapMonitor.statsHaveExpectedNumberSamples((int) expected, acceptedErrorPercentage)) {\n@@ -111,5 +111,1 @@\n-    \/\/ 10% error ensures a sanity test without becoming flaky.\n-    \/\/ Flakiness is due to the fact that this test is dependent on the sampling interval, which is a\n-    \/\/ statistical geometric variable around the sampling interval. This means that the test could be\n-    \/\/ unlucky and not achieve the mean average fast enough for the test case.\n-    if (!HeapMonitor.statsHaveExpectedNumberSamples((int) expected, 10)) {\n+    if (!HeapMonitor.statsHaveExpectedNumberSamples((int) expected, acceptedErrorPercentage)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-                    \"InvocationCounter::count_increment\",\n-                    \"markWord::epoch_mask_in_place\"));\n+                    \"InvocationCounter::count_increment\"));\n@@ -96,1 +95,0 @@\n-        \/\/ longConstant markWord::biased_lock_bits 1\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-                \"type DictionaryEntry KlassHashtableEntry\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbVmStructsDump.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-            out.shouldMatch(\"\\\".+\\\" #\\\\d+ daemon prio=\\\\d+ tid=0x[0-9a-f]+ nid=0x[0-9a-f]+ .+ \\\\[0x[0-9a-f]+]\");\n-            out.shouldMatch(\"\\\"main\\\" #\\\\d+ prio=\\\\d+ tid=0x[0-9a-f]+ nid=0x[0-9a-f]+ .+ \\\\[0x[0-9a-f]+]\");\n+            \/\/ The character class \\p{XDigit} matches any hexadecimal character.\n+            out.shouldMatch(\"\\\".+\\\" #\\\\d+ daemon prio=\\\\d+ tid=0x\\\\p{XDigit}+ nid=\\\\d+ .+ \\\\[0x\\\\p{XDigit}+]\");\n+            out.shouldMatch(\"\\\"main\\\" #\\\\d+ prio=\\\\d+ tid=0x\\\\p{XDigit}+ nid=\\\\d+ .+ \\\\[0x\\\\p{XDigit}+]\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/JhsdbThreadInfoTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    class Test implements Runnable {\n+    class Test implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+import nsk.share.gc.OOMStress;\n@@ -102,1 +103,1 @@\n-    class Test implements Runnable {\n+    class Test implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft001\/soft001.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft003\/soft003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/soft004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft005\/soft005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+import nsk.share.gc.OOMStress;\n@@ -102,1 +103,1 @@\n-    class Test implements Runnable {\n+    class Test implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak001\/weak001.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak003\/weak003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/weak004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak005\/weak005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak006\/weak006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    class Worker implements Runnable {\n+    class Worker implements Runnable, OOMStress {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak007\/weak007.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import vm.share.gc.HeapOOMEException;\n@@ -33,1 +34,0 @@\n-import metaspace.stressHierarchy.common.exceptions.GotWrongOOMEException;\n@@ -112,2 +112,2 @@\n-        } catch (GotWrongOOMEException e) {\n-            log.info(\"GotWrongOOMEExc: \" + e.getMessage());\n+        } catch (HeapOOMEException e) {\n+            log.info(\"HeapOOMEException: \" + e.getMessage());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/StressHierarchyBaseClass.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package metaspace.stressHierarchy.common.exceptions;\n-\n-\/**\n- * Usually this means that we got OOME:heap while trying to gain OOME:metaspace.\n- * We pass test in this case as this breaks test logic. We have dedicated test configurations\n- * for OOME:heap provoking class unloading, that why we are not missing test coverage here.\n- *\/\n-public class GotWrongOOMEException extends RuntimeException {\n-\n-    private static final long serialVersionUID = 1L;\n-\n-    public GotWrongOOMEException(String string) {\n-        super(string);\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/exceptions\/GotWrongOOMEException.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -81,1 +81,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodLoad event received during wrong phase %s\\n\",\n@@ -85,1 +85,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodLoad event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodLoad\/compmethload001\/compmethload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    if (phase != JVMTI_PHASE_LIVE) {\n+    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n@@ -113,1 +113,1 @@\n-        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during non-live phase %s\\n\",\n+        NSK_COMPLAIN1(\"TEST FAILED: CompiledMethodUnload event received during wrong phase %s\\n\",\n@@ -117,1 +117,1 @@\n-        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the live phase as expected\\n\\n\");\n+        NSK_DISPLAY0(\"CHECK PASSED: CompiledMethodUnload event received during the start or live phase as expected\\n\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001\/compmethunload001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-import java.io.*;\n-import java.util.*;\n-\n@@ -32,0 +29,2 @@\n+import java.io.PrintStream;\n+\n@@ -41,5 +40,3 @@\n-    private Node root;\n-    private int numberOfNodes;\n-    private float branchiness;\n-    private int size;\n-    private ExecutionController controller;\n+    private final Node root;\n+    private final float branchiness;\n+    private final ExecutionController controller;\n@@ -65,1 +62,0 @@\n-        initTree();\n@@ -69,8 +65,0 @@\n-        this.numberOfNodes = numberOfNodes;\n-        this.branchiness = branchiness;\n-        this.size = size;\n-        this.controller = controller;\n-        initTree();\n-    }\n-\n-    private void initTree() {\n@@ -79,2 +67,1 @@\n-                                             + numberOfNodes + \", must be at \"\n-                                             + \"least 1.\");\n+                    + numberOfNodes + \", must be at least 1.\");\n@@ -82,1 +69,1 @@\n-        if ( (branchiness >= 1) || (branchiness <= 0) ) {\n+        if ((branchiness >= 1) || (branchiness <= 0)) {\n@@ -84,3 +71,1 @@\n-                                             + numberOfNodes + \", must be at \"\n-                                             + \"greater than 0 and less than \"\n-                                             + \" 1.\");\n+                    + branchiness + \", must be greater than 0 and less than 1.\");\n@@ -90,1 +75,1 @@\n-                                             + size + \", must be at least 1.\");\n+                    + size + \", must be at least 1.\");\n@@ -94,1 +79,3 @@\n-        root = createTree(numberOfNodes, size);\n+        this.branchiness = branchiness;\n+        this.controller = controller;\n+        this.root = createTree(numberOfNodes, size);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/NonbranchyTree.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,0 +44,8 @@\n+\n+\/\/ Checks return code for JNI calls that don't raise exceptions\n+\/\/ and generate fatal error\n+#define CHECK(jniCall) do { \\\n+  if ((jniCall) != 0) { \\\n+    env->FatalError(\"Error invoking JNI method: \" #jniCall); \\\n+  } \\\n+} while (0)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/jnihelper.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    const char **str;\n-    char **checkstr;\n+  const char **str;\n+  char **checkstr;\n@@ -41,3 +41,3 @@\n-    const jchar **str;\n-    char **checkstr;\n-    int *size;\n+  const jchar **str;\n+  char **checkstr;\n+  int *size;\n@@ -48,26 +48,27 @@\n-                    jint nstr, jint printperiod) {\n-\n-    int i,j;\n-    size_t k;\n-    static CHAR_ARRAY *element;\n-    unsigned char digest[DIGESTLENGTH];\n-    static int allocs=0;\n-    static size_t strsize=0;\n-    static unsigned int compared=1;\n-\n-    const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n-    const char *name=\"setpass\";\n-    const char *sig=\"(Z)V\";\n-    const char *halt=\"halt\";\n-    const char *haltSig=\"()V\";\n-    jstring tmpstr;\n-    jclass clazz;\n-    jmethodID methodID;\n-\n-    env->MonitorEnter(jobj); CE\n-    if (!allocs) {\n-        element = (CHAR_ARRAY *)c_malloc(env, sizeof(CHAR_ARRAY));\n-        element->str = (const char **)c_malloc(env, nstr*sizeof(const char *));\n-        element->checkstr = (char **)c_malloc(env, nstr*sizeof(char *));\n-        for (j=0;j<nstr;j++)\n-            element->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH*sizeof(char));\n+                                         jint nstr, jint printperiod) {\n+\n+  int i, j;\n+  size_t k;\n+  static CHAR_ARRAY *element;\n+  unsigned char digest[DIGESTLENGTH];\n+  static int allocs = 0;\n+  static size_t strsize = 0;\n+  static unsigned int compared = 1;\n+\n+  const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n+  const char *name = \"setpass\";\n+  const char *sig = \"(Z)V\";\n+  const char *halt = \"halt\";\n+  const char *haltSig = \"()V\";\n+  jstring tmpstr;\n+  jclass clazz;\n+  jmethodID methodID;\n+\n+  CHECK(env->MonitorEnter(jobj));\n+\n+  if (!allocs) {\n+    element = (CHAR_ARRAY *)c_malloc(env, sizeof(CHAR_ARRAY));\n+    element->str = (const char **)c_malloc(env, nstr * sizeof(const char*));\n+    element->checkstr = (char **)c_malloc(env, nstr * sizeof(char*));\n+    for (j = 0; j < nstr; j++) {\n+      element->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n@@ -75,2 +76,19 @@\n-    for (j=0;j<DIGESTLENGTH;j++) {\n-        digest[j]=0;\n+  }\n+  for (j = 0; j < DIGESTLENGTH; j++) {\n+    digest[j] = 0;\n+  }\n+  element->str[allocs] = env->GetStringUTFChars(jstr, 0); CE\n+  if (strlen(element->str[allocs]) != (size_t) env->GetStringUTFLength(jstr)) {\n+    printf(\"Length is wrong in string No. %d\\n\", allocs);\n+  } else {\n+    strsize += strlen(element->str[allocs]) + 1;\n+  }\n+  for (k = 0; k < strlen(element->str[allocs]); k++) {\n+    digest[k % DIGESTLENGTH] += element->str[allocs][k];\n+  }\n+  memcpy(element->checkstr[allocs], digest, DIGESTLENGTH);\n+  allocs++;\n+  if (allocs % printperiod == 0) {\n+    printf(\"Check string for thread %s is \", element->str[allocs - 1]);\n+    for (j = 0; j < DIGESTLENGTH; j++) {\n+      printf(\"%02x\", digest[j]);\n@@ -78,8 +96,27 @@\n-    element->str[allocs] = env->GetStringUTFChars(jstr,0); CE\n-    if (strlen(element->str[allocs]) !=\n-        (size_t) env->GetStringUTFLength(jstr))\n-        printf(\"Length is wrong in string No. %d\\n\",allocs);\n-    else\n-        strsize += strlen(element->str[allocs])+1;\n-    for (k = 0; k < strlen(element->str[allocs]); k++) {\n-       digest[k % DIGESTLENGTH] += element->str[allocs][k];\n+    printf(\"\\n\");\n+  }\n+  if (allocs == nstr) {\n+    printf(\"JNI UTF8 strings memory = %zd\\n\", strsize);\n+    tmpstr = env->NewStringUTF(element->str[allocs - 1]); CE\n+    for (j = 0; j < nstr; j++) {\n+\n+      for (i = 0; i < DIGESTLENGTH; i++) {\n+        digest[i] = 0;\n+      }\n+      for (k = 0; k < strlen(element->str[j]); k++) {\n+        digest[k % DIGESTLENGTH] += element->str[j][k];\n+      }\n+      if (memcmp(digest, element->checkstr[j], DIGESTLENGTH) == 0) {\n+        env->ReleaseStringUTFChars(jstr, element->str[j]); CE\n+        element->str[j] = NULL;\n+        element->checkstr[j] = NULL;\n+      } else {\n+        compared = 0;\n+        printf(\"The element No. %d has been corrupted %s vs %s\\n\", j,\n+               element->str[j], element->checkstr[j]);\n+        printf(\"Digest string  is %s [\", element->str[j]);\n+        for (i = 0; i < DIGESTLENGTH; i++) {\n+          printf(\"ch[%d] = %02x\", i, digest[i]);\n+        }\n+        printf(\"Digest end\\n\");\n+      }\n@@ -87,7 +124,4 @@\n-    memcpy(element->checkstr[allocs],digest,DIGESTLENGTH);\n-    allocs++;\n-    if (allocs % printperiod == 0) {\n-        printf(\"Check string for thread %s is \", element->str[allocs-1]);\n-        for (j=0;j<DIGESTLENGTH;j++)\n-            printf(\"%02x\", digest[j]);\n-        printf(\"\\n\");\n+    allocs = 0;\n+    strsize = 0;\n+    for (j = 0; j < nstr; j++) {\n+      free(element->checkstr[j]);\n@@ -95,40 +129,7 @@\n-    if (allocs == nstr) {\n-        printf(\"JNI UTF8 strings memory=%zd\\n\", strsize);\n-        tmpstr=env->NewStringUTF(element->str[allocs-1]); CE\n-        for (j=0; j<nstr; j++) {\n-\n-            for (i=0;i<DIGESTLENGTH;i++) {\n-                digest[i]=0;\n-            }\n-            for (k=0; k < strlen(element->str[j]); k++) {\n-                digest[k % DIGESTLENGTH] += element->str[j][k];\n-            }\n-            if (memcmp(digest,element->checkstr[j],DIGESTLENGTH) == 0) {\n-                env->ReleaseStringUTFChars(jstr,element->str[j]); CE\n-                element->str[j] = NULL;\n-                element->checkstr[j] = NULL;\n-            }\n-            else {\n-                compared=0;\n-                printf(\"The element No. %d has been corrupted %s vs %s\\n\",j, element->str[j],element->checkstr[j]);\n-                printf(\"Digest string  is %s [\", element->str[j]);\n-                for (i=0;i<DIGESTLENGTH;i++)\n-                    printf(\"ch[%d]=%02x\", i, digest[i]);\n-                printf(\"Digest end\\n\");\n-            }\n-        }\n-        allocs=0;\n-        strsize = 0;\n-        for (j=0;j<nstr;j++)\n-            free(element->checkstr[j]);\n-        free(element->checkstr);\n-        free((void *)(element->str));\n-        free(element);\n-        clazz=env->FindClass(clsName); CE\n-        if (!compared) {\n-            methodID=env->GetStaticMethodID(clazz, name, sig); CE\n-            env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n-        }\n-        \/\/methodID=env->GetStaticMethodID(clazz, halt, haltSig); CE\n-        \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n-        return(tmpstr);\n+    free(element->checkstr);\n+    free((void *)(element->str));\n+    free(element);\n+    clazz = env->FindClass(clsName); CE\n+    if (!compared) {\n+      methodID = env->GetStaticMethodID(clazz, name, sig); CE\n+      env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n@@ -136,2 +137,6 @@\n-    env->MonitorExit(jobj); CE\n-    return (env->NewStringUTF(element->str[allocs-1]));\n+    \/\/methodID = env->GetStaticMethodID(clazz, halt, haltSig); CE\n+    \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n+    return tmpstr;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return (env->NewStringUTF(element->str[allocs - 1]));\n@@ -142,31 +147,28 @@\n-                    jint nstr, jint printperiod) {\n-\n-    int i,j;\n-    static JCHAR_ARRAY *javachars;\n-    unsigned char digest[DIGESTLENGTH];\n-    static int index=0;\n-    static long len=0;\n-    static unsigned int equal=1;\n-    char *elem;\n-    int elem_len = -1;\n-\n-    const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n-    const char *name=\"setpass\";\n-    const char *sig=\"(Z)V\";\n-    const char *halt=\"halt\";\n-    const char *haltSig=\"()V\";\n-    jstring tmpstr;\n-    jclass clazz;\n-    jmethodID methodID;\n-\n-    env->MonitorEnter(jobj); CE\n-    if (!index) {\n-        javachars = (JCHAR_ARRAY *)c_malloc(env, sizeof(JCHAR_ARRAY));\n-        javachars->str = (const jchar **)c_malloc(env, nstr*sizeof(const jchar *));\n-        javachars->checkstr = (char **)c_malloc(env, nstr*sizeof(char *));\n-        javachars->size = (int *)c_malloc(env, nstr*sizeof(int));\n-        for (j=0;j<nstr;j++)\n-            javachars->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH*sizeof(char));\n-    }\n-    for (j=0;j<DIGESTLENGTH;j++) {\n-        digest[j]=0;\n+                                         jint nstr, jint printperiod) {\n+\n+  int i, j;\n+  static JCHAR_ARRAY *javachars;\n+  unsigned char digest[DIGESTLENGTH];\n+  static int index = 0;\n+  static long len = 0;\n+  static unsigned int equal = 1;\n+  char *elem;\n+  int elem_len = -1;\n+\n+  const char *clsName = \"nsk\/stress\/jni\/JNIter001\";\n+  const char *name = \"setpass\";\n+  const char *sig = \"(Z)V\";\n+  const char *halt = \"halt\";\n+  const char *haltSig = \"()V\";\n+  jstring tmpstr;\n+  jclass clazz;\n+  jmethodID methodID;\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (!index) {\n+    javachars = (JCHAR_ARRAY *)c_malloc(env, sizeof(JCHAR_ARRAY));\n+    javachars->str = (const jchar **)c_malloc(env, nstr * sizeof(const jchar*));\n+    javachars->checkstr = (char **)c_malloc(env, nstr * sizeof(char*));\n+    javachars->size = (int *)c_malloc(env, nstr * sizeof(int));\n+    for (j = 0; j < nstr; j++) {\n+      javachars->checkstr[j] = (char *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n@@ -174,7 +176,22 @@\n-    javachars->str[index] = env->GetStringChars(jstr,0); CE\n-    javachars->size[index] = env->GetStringUTFLength(jstr); CE\n-    elem_len = javachars->size[index];\n-    len += elem_len;\n-    elem = (char*) c_malloc(env, elem_len*sizeof(char));\n-    for (j=0; j < elem_len; j++) {\n-        elem[j] = (char) javachars->str[index][j];\n+  }\n+  for (j = 0; j < DIGESTLENGTH; j++) {\n+    digest[j] = 0;\n+  }\n+  javachars->str[index] = env->GetStringChars(jstr, 0); CE\n+  javachars->size[index] = env->GetStringUTFLength(jstr); CE\n+  elem_len = javachars->size[index];\n+  len += elem_len;\n+  elem = (char*) c_malloc(env, elem_len * sizeof(char));\n+  for (j = 0; j < elem_len; j++) {\n+    elem[j] = (char) javachars->str[index][j];\n+  }\n+\n+  \/\/memcpy(digest, elem, javachars->size[index]);\n+  for (j = 0; j < elem_len; j++) {\n+    digest[j % DIGESTLENGTH] += elem[j];\n+  }\n+  memcpy(javachars->checkstr[index++], digest, DIGESTLENGTH);\n+  if (index % printperiod == 0) {\n+    printf(\"Check string sum for thread %.*s is \", elem_len, elem);\n+    for (j = 0; j < DIGESTLENGTH; j++) {\n+      printf(\"%02x\", digest[j]);\n@@ -182,4 +199,31 @@\n-\n-    \/\/memcpy(digest, elem, javachars->size[index]);\n-    for (j=0;j<elem_len; j++) {\n-        digest[j % DIGESTLENGTH]+=elem[j];\n+    printf(\"\\n\");\n+  }\n+  free(elem);\n+  if (index == nstr) {\n+    printf(\"JNI Unicode strings memory = %ld\\n\", len);\n+    tmpstr = env->NewString(javachars->str[index - 1], elem_len); CE\n+    for (j = 0; j < nstr; j++) {\n+      elem = (char*) c_malloc(env, javachars->size[j] * sizeof(char));\n+      for (i = 0; i < javachars->size[j]; i++) {\n+        elem[i] = (char) javachars->str[j][i];\n+      }\n+      \/\/memcpy(digest, elem, javachars->size[j]);\n+      for (i = 0; i < DIGESTLENGTH; i++) {\n+        digest[i] = 0;\n+      }\n+      for (i = 0; i < javachars->size[j]; i++) {\n+        digest[i % DIGESTLENGTH] += elem[i];\n+      }\n+      free(elem);\n+      if (memcmp(digest, javachars->checkstr[j], javachars->size[j]) == 0) {\n+        env->ReleaseStringChars(jstr, javachars->str[j]); CE\n+        javachars->str[j] = NULL;\n+        javachars->checkstr[j] = NULL;\n+        javachars->size[j] = 0;\n+      } else {\n+        equal = 0;\n+        printf(\"The Unicode element No. %d has been corrupted\\n\", j);\n+        for (i = 0; i < DIGESTLENGTH; i++) {\n+          printf(\"digest[%d] = %02x checkstr[%d] = %02x\\n\", i, digest[i], i, javachars->checkstr[j][i]);\n+        }\n+      }\n@@ -187,6 +231,4 @@\n-    memcpy(javachars->checkstr[index++],digest,DIGESTLENGTH);\n-    if (index % printperiod == 0) {\n-        printf(\"Check string sum for thread %.*s is \", elem_len, elem);\n-        for (j=0;j<DIGESTLENGTH;j++)\n-            printf(\"%02x\", digest[j]);\n-        printf(\"\\n\");\n+    index = 0;\n+    len = 0;\n+    for (j = 0; j < nstr; j++) {\n+      free(javachars->checkstr[j]);\n@@ -194,47 +236,8 @@\n-    free(elem);\n-    if (index == nstr) {\n-        printf(\"JNI Unicode strings memory=%ld\\n\",len);\n-        tmpstr=env->NewString(javachars->str[index-1],elem_len); CE\n-        for (j=0; j<nstr; j++) {\n-            elem = (char*) c_malloc(env, javachars->size[j]*sizeof(char));\n-            for (i=0; i < javachars->size[j]; i++) {\n-                elem[i] = (char) javachars->str[j][i];\n-            }\n-            \/\/memcpy(digest, elem, javachars->size[j]);\n-            for (i=0;i<DIGESTLENGTH;i++) {\n-                digest[i]=0;\n-            }\n-            for (i=0;i<javachars->size[j]; i++) {\n-                digest[i % DIGESTLENGTH]+=elem[i];\n-            }\n-            free(elem);\n-            if (memcmp(digest,javachars->checkstr[j],javachars->size[j]) == 0) {\n-                env->ReleaseStringChars(jstr,javachars->str[j]); CE\n-                javachars->str[j] = NULL;\n-                javachars->checkstr[j] = NULL;\n-                javachars->size[j] = 0;\n-            }\n-            else {\n-                equal=0;\n-                printf(\"The Unicode element No. %d has been corrupted\\n\",j);\n-                for (i=0;i<DIGESTLENGTH;i++) {\n-                    printf(\"digest[%d]=%02x checkstr[%d]=%02x\\n\",i,digest[i],i,javachars->checkstr[j][i]);\n-                }\n-            }\n-        }\n-        index=0;\n-        len = 0;\n-        for (j=0;j<nstr;j++)\n-            free(javachars->checkstr[j]);\n-        free(javachars->checkstr);\n-        free((void *)(javachars->str));\n-        free(javachars->size);\n-        free(javachars);\n-        clazz=env->FindClass(clsName); CE\n-        if (!equal) {\n-            methodID=env->GetStaticMethodID(clazz, name, sig); CE\n-            env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n-        }\n-        \/\/methodID=env->GetStaticMethodID(clazz, halt, haltSig); CE\n-        \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n-        return(tmpstr);\n+    free(javachars->checkstr);\n+    free((void *)(javachars->str));\n+    free(javachars->size);\n+    free(javachars);\n+    clazz = env->FindClass(clsName); CE\n+    if (!equal) {\n+      methodID = env->GetStaticMethodID(clazz, name, sig); CE\n+      env->CallStaticVoidMethod(clazz, methodID, JNI_FALSE); CE\n@@ -242,2 +245,6 @@\n-    env->MonitorExit(jobj); CE\n-    return(env->NewString(javachars->str[index-1],elem_len));\n+    \/\/methodID = env->GetStaticMethodID(clazz, halt, haltSig); CE\n+    \/\/env->CallStaticVoidMethod(clazz, methodID); CE\n+    return tmpstr;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return env->NewString(javachars->str[index - 1], elem_len);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress001.cpp","additions":195,"deletions":188,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  va_start(ap,methodID);\n-  tmp=env->NewObjectV(clazz, methodID, ap);\n+  va_start(ap, methodID);\n+  tmp = env->NewObjectV(clazz, methodID, ap);\n@@ -42,1 +42,1 @@\n-              jlong lng, jcharArray jChArr, jfloat flt, jdouble dbl) {\n+                                          jlong lng, jcharArray jChArr, jfloat flt, jdouble dbl) {\n@@ -49,8 +49,9 @@\n-  const char *classname=\"nsk\/stress\/jni\/objectsJNI\";\n-  const char *name=\"<init>\";\n-  const char *sig=\"(Ljava\/lang\/String;IJ[CFD)V\";\n-  const char *upperClassName=\"nsk\/stress\/jni\/jnistress002\";\n-  const char *fieldName=\"jniStringAllocSize\";\n-  const char *fieldSig=\"I\";\n-  const char *setpass=\"halt\";\n-  const char *setpassSig=\"()V\";\n+  jfieldID fieldID;\n+  const char *classname = \"nsk\/stress\/jni\/objectsJNI\";\n+  const char *name = \"<init>\";\n+  const char *sig = \"(Ljava\/lang\/String;IJ[CFD)V\";\n+  const char *upperClassName = \"nsk\/stress\/jni\/jnistress002\";\n+  const char *fieldName = \"jniStringAllocSize\";\n+  const char *fieldSig = \"I\";\n+  const char *setpass = \"halt\";\n+  const char *setpassSig = \"()V\";\n@@ -59,1 +60,1 @@\n-  env->MonitorEnter(jobj); CE\n+  CHECK(env->MonitorEnter(jobj));\n@@ -61,7 +62,7 @@\n-  env->MonitorExit(jobj); CE\n-  paramArr[0].l=jstr;\n-  paramArr[1].i=intgr;\n-  paramArr[2].j=lng;\n-  paramArr[3].l=jChArr;\n-  paramArr[4].f=flt;\n-  paramArr[5].d=dbl;\n+  CHECK(env->MonitorExit(jobj));\n+  paramArr[0].l = jstr;\n+  paramArr[1].i = intgr;\n+  paramArr[2].j = lng;\n+  paramArr[3].l = jChArr;\n+  paramArr[4].f = flt;\n+  paramArr[5].d = dbl;\n@@ -69,7 +70,3 @@\n-  clazz=env->FindClass(classname); CE\n-  obj=env->NewObjectArray((jsize)3,clazz,\n-                 env->AllocObject(clazz)); CE\n-  if (obj == NULL) {\n-    fprintf(stderr,\"Can not construct the object Array for  %s\\n\", classname);\n-    return(NULL);\n-  }\n+  clazz = env->FindClass(classname); CE\n+  element = env->AllocObject(clazz); CE\n+  obj = env->NewObjectArray((jsize)3, clazz, element); CE\n@@ -77,5 +74,1 @@\n-  methodID=env->GetMethodID(clazz,name,sig); CE\n-  if (methodID == NULL) {\n-    fprintf(stderr,\"Can not get the ID of <init> for %s\\n\", classname);\n-    return(NULL);\n-  }\n+  methodID = env->GetMethodID(clazz, name, sig); CE\n@@ -83,5 +76,5 @@\n-  element=env->NewObject(clazz,methodID,\n-                jstr, intgr, lng, jChArr, flt, dbl); CE\n-  env->SetObjectArrayElement(obj,0,element); CE\n-  element=env->NewObjectA(clazz,methodID,paramArr); CE\n-  env->SetObjectArrayElement(obj,1,element); CE\n+  element = env->NewObject(clazz, methodID,\n+                           jstr, intgr, lng, jChArr, flt, dbl); CE\n+  env->SetObjectArrayElement(obj, 0, element); CE\n+  element = env->NewObjectA(clazz, methodID, paramArr); CE\n+  env->SetObjectArrayElement(obj, 1, element); CE\n@@ -89,2 +82,2 @@\n-                jstr, intgr, lng, jChArr, flt, dbl); CE\n-  env->SetObjectArrayElement(obj,2,element); CE\n+                            jstr, intgr, lng, jChArr, flt, dbl); CE\n+  env->SetObjectArrayElement(obj, 2, element); CE\n@@ -92,6 +85,6 @@\n-  clazzUp=env->FindClass(upperClassName); CE\n-  if (classCount == env->GetStaticIntField(clazzUp,\n-      env->GetStaticFieldID(clazzUp,fieldName,fieldSig))) {\n-    classname=\"nsk\/stress\/jni\/JNIter002\";\n-    clazz=env->FindClass(classname); CE\n-    methodID=env->GetStaticMethodID(clazz, setpass, setpassSig); CE\n+  clazzUp = env->FindClass(upperClassName); CE\n+  fieldID = env->GetStaticFieldID(clazzUp, fieldName, fieldSig); CE\n+  if (classCount == env->GetStaticIntField(clazzUp, fieldID)) {\n+    classname = \"nsk\/stress\/jni\/JNIter002\";\n+    clazz = env->FindClass(classname); CE\n+    methodID = env->GetStaticMethodID(clazz, setpass, setpassSig); CE\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress002.cpp","additions":38,"deletions":45,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,10 +43,10 @@\n-    jarray *arrayArray;\n-    jboolean *boolBuf;\n-    jbyte *byteBuf;\n-    jchar *charBuf;\n-    jshort *shortBuf;\n-    jint *intBuf;\n-    jlong *longBuf;\n-    jfloat *floatBuf;\n-    jdouble *doubleBuf;\n-    jobjectArray objectsArray;\n+  jarray *arrayArray;\n+  jboolean *boolBuf;\n+  jbyte *byteBuf;\n+  jchar *charBuf;\n+  jshort *shortBuf;\n+  jint *intBuf;\n+  jlong *longBuf;\n+  jfloat *floatBuf;\n+  jdouble *doubleBuf;\n+  jobjectArray objectsArray;\n@@ -54,5 +54,6 @@\n-    int i;\n-    int SIZE=size;\n-    const char *classname=\"java\/lang\/Object\";\n-    jclass clazz = env->FindClass(classname); CE\n-    objectsArray = env->NewObjectArray(8,clazz, env->AllocObject(clazz));\n+  int i;\n+  int SIZE = size;\n+  const char *classname = \"java\/lang\/Object\";\n+  jclass clazz = env->FindClass(classname); CE\n+  jobject obj = env->AllocObject(clazz); CE\n+  objectsArray = env->NewObjectArray(8, clazz, obj); CE\n@@ -60,9 +61,9 @@\n-    arrayArray=(jarray *)malloc(8*sizeof(jarray)); CE\n-    arrayArray[BOOL]=env->NewBooleanArray(SIZE); CE\n-    arrayArray[BYTE]=env->NewByteArray(SIZE); CE\n-    arrayArray[CHAR]=env->NewCharArray(SIZE); CE\n-    arrayArray[SHORT]=env->NewShortArray(SIZE); CE\n-    arrayArray[INT]=env->NewIntArray(SIZE); CE\n-    arrayArray[LONG]=env->NewLongArray(SIZE); CE\n-    arrayArray[FLOAT]=env->NewFloatArray(SIZE); CE\n-    arrayArray[DOUBLE]=env->NewDoubleArray(SIZE); CE\n+  arrayArray = (jarray *)c_malloc(env, 8*sizeof(jarray));\n+  arrayArray[BOOL] = env->NewBooleanArray(SIZE); CE\n+  arrayArray[BYTE] = env->NewByteArray(SIZE); CE\n+  arrayArray[CHAR] = env->NewCharArray(SIZE); CE\n+  arrayArray[SHORT] = env->NewShortArray(SIZE); CE\n+  arrayArray[INT] = env->NewIntArray(SIZE); CE\n+  arrayArray[LONG] = env->NewLongArray(SIZE); CE\n+  arrayArray[FLOAT] = env->NewFloatArray(SIZE); CE\n+  arrayArray[DOUBLE] = env->NewDoubleArray(SIZE); CE\n@@ -70,2 +71,3 @@\n-    for (i=0;i<8;i++)\n-    { env->SetObjectArrayElement(objectsArray,i,arrayArray[i]); CE }\n+  for (i = 0; i < 8; i++) {\n+    env->SetObjectArrayElement(objectsArray, i,arrayArray[i]); CE\n+  }\n@@ -73,8 +75,8 @@\n-    boolBuf=(jboolean *)malloc(SIZE*sizeof(jboolean));\n-    byteBuf=(jbyte *)malloc(SIZE*sizeof(jbyte));\n-    charBuf=(jchar *)malloc(SIZE*sizeof(jchar));\n-    shortBuf=(jshort *)malloc(SIZE*sizeof(jshort));\n-    intBuf=(jint *)malloc(SIZE*sizeof(jint));\n-    longBuf=(jlong *)malloc(SIZE*sizeof(jlong));\n-    floatBuf=(jfloat *)malloc(SIZE*sizeof(jfloat));\n-    doubleBuf=(jdouble *)malloc(SIZE*sizeof(jdouble));\n+  boolBuf = (jboolean *)c_malloc(env, SIZE * sizeof(jboolean));\n+  byteBuf = (jbyte *)c_malloc(env, SIZE * sizeof(jbyte));\n+  charBuf = (jchar *)c_malloc(env, SIZE * sizeof(jchar));\n+  shortBuf = (jshort *)c_malloc(env, SIZE * sizeof(jshort));\n+  intBuf = (jint *)c_malloc(env, SIZE * sizeof(jint));\n+  longBuf = (jlong *)c_malloc(env, SIZE * sizeof(jlong));\n+  floatBuf = (jfloat *)c_malloc(env, SIZE * sizeof(jfloat));\n+  doubleBuf = (jdouble *)c_malloc(env, SIZE * sizeof(jdouble));\n@@ -82,3 +84,2 @@\n-    for (i=0;i<SIZE;i++) {\n-    if (i%2 == 0) boolBuf[i]=JNI_TRUE;\n-    else boolBuf[i]=JNI_FALSE;\n+  for (i = 0; i < SIZE; i++) {\n+    boolBuf[i] = (i % 2 == 0) ? JNI_TRUE : JNI_FALSE;\n@@ -86,7 +87,7 @@\n-      byteBuf[i]=(jbyte)random();\n-      charBuf[i]=(jchar)random();\n-      shortBuf[i]=(jshort)random();\n-      intBuf[i]=(jint)random();\n-      longBuf[i]=(jlong)random();\n-      floatBuf[i]=(jfloat)((random()));\n-      doubleBuf[i]=(jdouble)((random()));\n+      byteBuf[i] = (jbyte)random();\n+      charBuf[i] = (jchar)random();\n+      shortBuf[i] = (jshort)random();\n+      intBuf[i] = (jint)random();\n+      longBuf[i] = (jlong)random();\n+      floatBuf[i] = (jfloat)((random()));\n+      doubleBuf[i] = (jdouble)((random()));\n@@ -94,16 +95,16 @@\n-    byteBuf[i]=(jbyte)109;\n-    charBuf[i]=(jchar)214;\n-    shortBuf[i]=(jshort)9223;\n-    intBuf[i]=(jint)872634;\n-    longBuf[i]=(jlong)276458276;\n-    floatBuf[i]=(jfloat)235.4576284;\n-    doubleBuf[i]=(jdouble)98275.716253567;\n-    }\n-    env->SetBooleanArrayRegion((jbooleanArray) arrayArray[BOOL],0,i,boolBuf); CE\n-    env->SetByteArrayRegion((jbyteArray) arrayArray[BYTE],0,i,byteBuf); CE\n-    env->SetCharArrayRegion((jcharArray) arrayArray[CHAR],0,i,charBuf); CE\n-    env->SetShortArrayRegion((jshortArray) arrayArray[SHORT],0,i,shortBuf); CE\n-    env->SetIntArrayRegion((jintArray) arrayArray[INT],0,i,intBuf); CE\n-    env->SetLongArrayRegion((jlongArray) arrayArray[LONG],0,i,longBuf); CE\n-    env->SetFloatArrayRegion((jfloatArray) arrayArray[FLOAT],0,i,floatBuf); CE\n-    env->SetDoubleArrayRegion((jdoubleArray) arrayArray[DOUBLE],0,i,doubleBuf); CE\n+    byteBuf[i] = (jbyte)109;\n+    charBuf[i] = (jchar)214;\n+    shortBuf[i] = (jshort)9223;\n+    intBuf[i] = (jint)872634;\n+    longBuf[i] = (jlong)276458276;\n+    floatBuf[i] = (jfloat)235.4576284;\n+    doubleBuf[i] = (jdouble)98275.716253567;\n+  }\n+  env->SetBooleanArrayRegion((jbooleanArray) arrayArray[BOOL], 0, i, boolBuf); CE\n+  env->SetByteArrayRegion((jbyteArray) arrayArray[BYTE], 0, i, byteBuf); CE\n+  env->SetCharArrayRegion((jcharArray) arrayArray[CHAR], 0, i, charBuf); CE\n+  env->SetShortArrayRegion((jshortArray) arrayArray[SHORT], 0, i, shortBuf); CE\n+  env->SetIntArrayRegion((jintArray) arrayArray[INT], 0, i, intBuf); CE\n+  env->SetLongArrayRegion((jlongArray) arrayArray[LONG], 0, i, longBuf); CE\n+  env->SetFloatArrayRegion((jfloatArray) arrayArray[FLOAT], 0, i, floatBuf); CE\n+  env->SetDoubleArrayRegion((jdoubleArray) arrayArray[DOUBLE], 0, i, doubleBuf); CE\n@@ -111,9 +112,9 @@\n-    free(doubleBuf);\n-    free(floatBuf);\n-    free(longBuf);\n-    free(intBuf);\n-    free(shortBuf);\n-    free(byteBuf);\n-    free(charBuf);\n-    free(boolBuf);\n-    free(arrayArray);\n+  free(doubleBuf);\n+  free(floatBuf);\n+  free(longBuf);\n+  free(intBuf);\n+  free(shortBuf);\n+  free(byteBuf);\n+  free(charBuf);\n+  free(boolBuf);\n+  free(arrayArray);\n@@ -121,1 +122,1 @@\n-    return objectsArray;\n+  return objectsArray;\n@@ -126,1 +127,1 @@\n-                jobjectArray orig, jobjectArray clone, jint limit) {\n+                                                  jobjectArray orig, jobjectArray clone, jint limit) {\n@@ -128,1 +129,1 @@\n-#define SWAP(param1, param2) tmparr=param2; param2=param1; param1=tmparr;\n+#define SWAP(param1, param2) tmparr = param2; param2 = param1; param1 = tmparr;\n@@ -131,11 +132,11 @@\n-    static volatile long count=0;\n-    jarray *arrayOrig, *arrayClone;\n-    jboolean *boolOrig, *boolClone;\n-    jbyte *byteOrig, *byteClone;\n-    jchar *charOrig, *charClone;\n-    jshort *shortOrig, *shortClone;\n-    jint *intOrig, *intClone;\n-    jlong *longOrig, *longClone;\n-    jfloat *floatOrig, *floatClone;\n-    jdouble *doubleOrig, *doubleClone;\n-    int i;\n+  static volatile long count = 0;\n+  jarray *arrayOrig, *arrayClone;\n+  jboolean *boolOrig, *boolClone;\n+  jbyte *byteOrig, *byteClone;\n+  jchar *charOrig, *charClone;\n+  jshort *shortOrig, *shortClone;\n+  jint *intOrig, *intClone;\n+  jlong *longOrig, *longClone;\n+  jfloat *floatOrig, *floatClone;\n+  jdouble *doubleOrig, *doubleClone;\n+  int i;\n@@ -143,2 +144,2 @@\n-    if ((orig == NULL) || (clone == NULL)) {\n-    fprintf(stderr,\"JNI received a NULL array from Java\\n\");\n+  if ((orig == NULL) || (clone == NULL)) {\n+    fprintf(stderr, \"JNI received a NULL array from Java\\n\");\n@@ -146,2 +147,2 @@\n-    }\n-    if (count == limit) {\n+  }\n+  if (count == limit) {\n@@ -155,3 +156,3 @@\n-    clazz=env->FindClass(classname); CE\n-        jmethod=env->GetMethodID(clazz, setdone, setdonesig); CE\n-        env->CallVoidMethod(jobj, jmethod); CE\n+    clazz = env->FindClass(classname); CE\n+    jmethod = env->GetMethodID(clazz, setdone, setdonesig); CE\n+    env->CallVoidMethod(jobj, jmethod); CE\n@@ -160,10 +161,10 @@\n-    }\n-    env->MonitorEnter(jobj); CE\n-    ++count;\n-    env->MonitorExit(jobj); CE\n-    arrayOrig=(jarray *)malloc(8*sizeof(jarray));\n-    arrayClone=(jarray *)malloc(8*sizeof(jarray));\n-    for (i=0;i<8;i++) {\n-    arrayOrig[i]=(jarray) env->GetObjectArrayElement(orig,i); CE\n-    arrayClone[i]=(jarray) env->GetObjectArrayElement(clone,i); CE\n-    }\n+  }\n+  CHECK(env->MonitorEnter(jobj));\n+  ++count;\n+  CHECK(env->MonitorExit(jobj));\n+  arrayOrig = (jarray *)c_malloc(env, 8 * sizeof(jarray));\n+  arrayClone = (jarray *)c_malloc(env, 8 * sizeof(jarray));\n+  for (i = 0; i < 8; i++) {\n+    arrayOrig[i] = (jarray) env->GetObjectArrayElement(orig, i); CE\n+    arrayClone[i] = (jarray) env->GetObjectArrayElement(clone, i); CE\n+  }\n@@ -171,10 +172,10 @@\n-    \/* Take the elements from Java arrays into native buffers *\/\n-    \/* Use Get<Type>ArrayElements *\/\n-    boolOrig = env->GetBooleanArrayElements((jbooleanArray) arrayOrig[BOOL],0); CE\n-    byteOrig = env->GetByteArrayElements((jbyteArray) arrayOrig[BYTE],0); CE\n-    charOrig = env->GetCharArrayElements((jcharArray) arrayOrig[CHAR],0); CE\n-    shortOrig = env->GetShortArrayElements((jshortArray) arrayOrig[SHORT],0); CE\n-    intOrig = env->GetIntArrayElements((jintArray) arrayOrig[INT],0); CE\n-    longOrig = env->GetLongArrayElements((jlongArray) arrayOrig[LONG],0); CE\n-    floatOrig = env->GetFloatArrayElements((jfloatArray) arrayOrig[FLOAT],0); CE\n-    doubleOrig = env->GetDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE],0); CE\n+  \/* Take the elements from Java arrays into native buffers *\/\n+  \/* Use Get<Type>ArrayElements *\/\n+  boolOrig = env->GetBooleanArrayElements((jbooleanArray) arrayOrig[BOOL], 0); CE\n+  byteOrig = env->GetByteArrayElements((jbyteArray) arrayOrig[BYTE], 0); CE\n+  charOrig = env->GetCharArrayElements((jcharArray) arrayOrig[CHAR], 0); CE\n+  shortOrig = env->GetShortArrayElements((jshortArray) arrayOrig[SHORT], 0); CE\n+  intOrig = env->GetIntArrayElements((jintArray) arrayOrig[INT], 0); CE\n+  longOrig = env->GetLongArrayElements((jlongArray) arrayOrig[LONG], 0); CE\n+  floatOrig = env->GetFloatArrayElements((jfloatArray) arrayOrig[FLOAT], 0); CE\n+  doubleOrig = env->GetDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE], 0); CE\n@@ -182,9 +183,9 @@\n-    \/* Alloc some memory for cloned arrays buffers *\/\n-    boolClone=(jboolean *)malloc(SIZE(BOOL)*sizeof(jboolean));\n-    byteClone=(jbyte *)malloc(SIZE(BYTE)*sizeof(jbyte));\n-    charClone=(jchar *)malloc(SIZE(CHAR)*sizeof(jchar));\n-    shortClone=(jshort *)malloc(SIZE(SHORT)*sizeof(jshort));\n-    intClone=(jint *)malloc(SIZE(INT)*sizeof(jint));\n-    longClone=(jlong *)malloc(SIZE(LONG)*sizeof(jlong));\n-    floatClone=(jfloat *)malloc(SIZE(FLOAT)*sizeof(jfloat));\n-    doubleClone=(jdouble *)malloc(SIZE(DOUBLE)*sizeof(jdouble));\n+  \/* Alloc some memory for cloned arrays buffers *\/\n+  boolClone = (jboolean *)c_malloc(env, SIZE(BOOL) * sizeof(jboolean));\n+  byteClone = (jbyte *)c_malloc(env, SIZE(BYTE) * sizeof(jbyte));\n+  charClone = (jchar *)c_malloc(env, SIZE(CHAR) * sizeof(jchar));\n+  shortClone = (jshort *)c_malloc(env, SIZE(SHORT) * sizeof(jshort));\n+  intClone = (jint *)c_malloc(env, SIZE(INT) * sizeof(jint));\n+  longClone = (jlong *)c_malloc(env, SIZE(LONG) * sizeof(jlong));\n+  floatClone = (jfloat *)c_malloc(env, SIZE(FLOAT) * sizeof(jfloat));\n+  doubleClone = (jdouble *)c_malloc(env, SIZE(DOUBLE) * sizeof(jdouble));\n@@ -194,8 +195,8 @@\n-    env->GetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL],0,SIZE(BOOL),boolClone); CE\n-    env->GetByteArrayRegion((jbyteArray) arrayClone[BYTE],0,SIZE(BYTE),byteClone); CE\n-    env->GetCharArrayRegion((jcharArray) arrayClone[CHAR],0,SIZE(CHAR),charClone); CE\n-    env->GetShortArrayRegion((jshortArray) arrayClone[SHORT],0,SIZE(SHORT),shortClone); CE\n-    env->GetIntArrayRegion((jintArray) arrayClone[INT],0,SIZE(INT),intClone); CE\n-    env->GetLongArrayRegion((jlongArray) arrayClone[LONG],0,SIZE(LONG),longClone); CE\n-    env->GetFloatArrayRegion((jfloatArray) arrayClone[FLOAT],0,SIZE(FLOAT),floatClone); CE\n-    env->GetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleClone); CE\n+  env->GetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL], 0, SIZE(BOOL), boolClone); CE\n+  env->GetByteArrayRegion((jbyteArray) arrayClone[BYTE], 0, SIZE(BYTE), byteClone); CE\n+  env->GetCharArrayRegion((jcharArray) arrayClone[CHAR], 0, SIZE(CHAR), charClone); CE\n+  env->GetShortArrayRegion((jshortArray) arrayClone[SHORT], 0, SIZE(SHORT), shortClone); CE\n+  env->GetIntArrayRegion((jintArray) arrayClone[INT], 0, SIZE(INT), intClone); CE\n+  env->GetLongArrayRegion((jlongArray) arrayClone[LONG], 0, SIZE(LONG), longClone); CE\n+  env->GetFloatArrayRegion((jfloatArray) arrayClone[FLOAT], 0, SIZE(FLOAT), floatClone); CE\n+  env->GetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE], 0, SIZE(DOUBLE), doubleClone); CE\n@@ -206,11 +207,11 @@\n-\/*\n-Can't change the pointer into the Java structure.  It's illegal JNI.\n-    SWAP(boolOrig,boolClone)\n-    SWAP(byteOrig,byteClone)\n-    SWAP(charOrig,charClone)\n-    SWAP(shortOrig,shortClone)\n-    SWAP(intOrig,intClone)\n-    SWAP(longOrig,longClone)\n-    SWAP(floatOrig,floatClone)\n-    SWAP(doubleOrig,doubleClone)\n-*\/\n+  \/*\n+    Can't change the pointer into the Java structure.  It's illegal JNI.\n+    SWAP(boolOrig, boolClone)\n+    SWAP(byteOrig, byteClone)\n+    SWAP(charOrig, charClone)\n+    SWAP(shortOrig, shortClone)\n+    SWAP(intOrig, intClone)\n+    SWAP(longOrig, longClone)\n+    SWAP(floatOrig, floatClone)\n+    SWAP(doubleOrig, doubleClone)\n+  *\/\n@@ -218,21 +219,21 @@\n-    \/* Coping new values of elements back to Java and releasing native buffers *\/\n-    \/* Use Set<Type>ArrayRegion *\/\n-\/*\n-Use Orig pointers to get the original effect of the test.\n-    env->SetBooleanArrayRegion(arrayClone[BOOL],0,SIZE(BOOL),boolClone);\n-    env->SetByteArrayRegion(arrayClone[BYTE],0,SIZE(BYTE),byteClone);\n-    env->SetCharArrayRegion(arrayClone[CHAR],0,SIZE(CHAR),charClone);\n-    env->SetShortArrayRegion(arrayClone[SHORT],0,SIZE(SHORT),shortClone);\n-    env->SetIntArrayRegion(arrayClone[INT],0,SIZE(INT),intClone);\n-    env->SetLongArrayRegion(arrayClone[LONG],0,SIZE(LONG),longClone);\n-    env->SetFloatArrayRegion(arrayClone[FLOAT],0,SIZE(FLOAT),floatClone);\n-    env->SetDoubleArrayRegion(arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleClone);\n-*\/\n-    env->SetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL],0,SIZE(BOOL),boolOrig); CE\n-    env->SetByteArrayRegion((jbyteArray) arrayClone[BYTE],0,SIZE(BYTE),byteOrig); CE\n-    env->SetCharArrayRegion((jcharArray) arrayClone[CHAR],0,SIZE(CHAR),charOrig); CE\n-    env->SetShortArrayRegion((jshortArray) arrayClone[SHORT],0,SIZE(SHORT),shortOrig); CE\n-    env->SetIntArrayRegion((jintArray) arrayClone[INT],0,SIZE(INT),intOrig); CE\n-    env->SetLongArrayRegion((jlongArray) arrayClone[LONG],0,SIZE(LONG),longOrig); CE\n-    env->SetFloatArrayRegion((jfloatArray) arrayClone[FLOAT],0,SIZE(FLOAT),floatOrig); CE\n-    env->SetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE],0,SIZE(DOUBLE),doubleOrig); CE\n+  \/* Coping new values of elements back to Java and releasing native buffers *\/\n+  \/* Use Set<Type>ArrayRegion *\/\n+  \/*\n+    Use Orig pointers to get the original effect of the test.\n+    env->SetBooleanArrayRegion(arrayClone[BOOL], 0,SIZE(BOOL), boolClone);\n+    env->SetByteArrayRegion(arrayClone[BYTE], 0,SIZE(BYTE), byteClone);\n+    env->SetCharArrayRegion(arrayClone[CHAR], 0,SIZE(CHAR), charClone);\n+    env->SetShortArrayRegion(arrayClone[SHORT], 0,SIZE(SHORT), shortClone);\n+    env->SetIntArrayRegion(arrayClone[INT], 0,SIZE(INT), intClone);\n+    env->SetLongArrayRegion(arrayClone[LONG], 0,SIZE(LONG), longClone);\n+    env->SetFloatArrayRegion(arrayClone[FLOAT], 0,SIZE(FLOAT), floatClone);\n+    env->SetDoubleArrayRegion(arrayClone[DOUBLE], 0,SIZE(DOUBLE), doubleClone);\n+  *\/\n+  env->SetBooleanArrayRegion((jbooleanArray) arrayClone[BOOL], 0, SIZE(BOOL), boolOrig); CE\n+  env->SetByteArrayRegion((jbyteArray) arrayClone[BYTE], 0, SIZE(BYTE), byteOrig); CE\n+  env->SetCharArrayRegion((jcharArray) arrayClone[CHAR], 0, SIZE(CHAR), charOrig); CE\n+  env->SetShortArrayRegion((jshortArray) arrayClone[SHORT], 0, SIZE(SHORT), shortOrig); CE\n+  env->SetIntArrayRegion((jintArray) arrayClone[INT], 0, SIZE(INT), intOrig); CE\n+  env->SetLongArrayRegion((jlongArray) arrayClone[LONG], 0, SIZE(LONG), longOrig); CE\n+  env->SetFloatArrayRegion((jfloatArray) arrayClone[FLOAT], 0, SIZE(FLOAT), floatOrig); CE\n+  env->SetDoubleArrayRegion((jdoubleArray) arrayClone[DOUBLE], 0, SIZE(DOUBLE), doubleOrig); CE\n@@ -240,10 +241,10 @@\n-    \/* Use Release<Type>ArrayElements *\/\n-    env->ReleaseDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE],doubleOrig,0); CE\n-    env->ReleaseFloatArrayElements((jfloatArray) arrayOrig[FLOAT],floatOrig,0); CE\n-    env->ReleaseLongArrayElements((jlongArray) arrayOrig[LONG],longOrig,0); CE\n-    env->ReleaseIntArrayElements((jintArray) arrayOrig[INT],intOrig,0); CE\n-    env->ReleaseShortArrayElements((jshortArray) arrayOrig[SHORT],shortOrig,0); CE\n-    env->ReleaseCharArrayElements((jcharArray) arrayOrig[CHAR],charOrig,0); CE\n-    env->ReleaseByteArrayElements((jbyteArray) arrayOrig[BYTE],byteOrig,0); CE\n-    env->ReleaseBooleanArrayElements((jbooleanArray) arrayOrig[BOOL],boolOrig,0); CE\n-    free(arrayOrig);\n+  \/* Use Release<Type>ArrayElements *\/\n+  env->ReleaseDoubleArrayElements((jdoubleArray) arrayOrig[DOUBLE], doubleOrig, 0); CE\n+  env->ReleaseFloatArrayElements((jfloatArray) arrayOrig[FLOAT], floatOrig, 0); CE\n+  env->ReleaseLongArrayElements((jlongArray) arrayOrig[LONG], longOrig, 0); CE\n+  env->ReleaseIntArrayElements((jintArray) arrayOrig[INT], intOrig, 0); CE\n+  env->ReleaseShortArrayElements((jshortArray) arrayOrig[SHORT], shortOrig, 0); CE\n+  env->ReleaseCharArrayElements((jcharArray) arrayOrig[CHAR], charOrig, 0); CE\n+  env->ReleaseByteArrayElements((jbyteArray) arrayOrig[BYTE], byteOrig, 0); CE\n+  env->ReleaseBooleanArrayElements((jbooleanArray) arrayOrig[BOOL], boolOrig, 0); CE\n+  free(arrayOrig);\n@@ -251,9 +252,9 @@\n-    free(doubleClone);\n-    free(floatClone);\n-    free(longClone);\n-    free(intClone);\n-    free(shortClone);\n-    free(byteClone);\n-    free(charClone);\n-    free(boolClone);\n-    free(arrayClone);\n+  free(doubleClone);\n+  free(floatClone);\n+  free(longClone);\n+  free(intClone);\n+  free(shortClone);\n+  free(byteClone);\n+  free(charClone);\n+  free(boolClone);\n+  free(arrayClone);\n@@ -261,1 +262,1 @@\n-    return JNI_TRUE;\n+  return JNI_TRUE;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress003.cpp","additions":181,"deletions":180,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,23 +37,21 @@\n-    unsigned char digest[DIGESTLENGTH];\n-    jchar *tmp;\n-    static jint upper = 0;\n-    jcharArray jArr;\n-    int i;\n-    const jchar *critstr;\n-    char *str;\n-    jint len=env->GetStringUTFLength(jstr); CE\n-\n-    for (i=0;i<DIGESTLENGTH;i++) {\n-      digest[i]=0;\n-    }\n-    str=(char *)malloc(len*sizeof(char));\n-\/*     const char *threadName=env->GetStringUTFChars(jstr, 0); *\/\n-\n-    env->MonitorEnter(jobj); CE\n-    if (upper == 0) tmp = (jchar *) malloc(DIGESTLENGTH*sizeof(char));\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    critstr=env->GetStringCritical(jstr, 0); CE\n-    for (i=0;i<len;i++)\n+  unsigned char digest[DIGESTLENGTH];\n+  jchar *tmp;\n+  static jint upper = 0;\n+  jcharArray jArr;\n+  int i;\n+  const jchar *critstr;\n+  char *str;\n+  jint len = env->GetStringUTFLength(jstr); CE\n+\n+  for (i = 0; i < DIGESTLENGTH; i++) {\n+    digest[i] = 0;\n+  }\n+  str = (char *)c_malloc(env, len * sizeof(char));\n+  \/*     const char *threadName = env->GetStringUTFChars(jstr, 0); *\/\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (upper == 0) {\n+    tmp = (jchar *) c_malloc(env, DIGESTLENGTH * sizeof(char));\n+  }\n+  critstr = env->GetStringCritical(jstr, 0); CE\n+  for (i = 0; i < len; i++) {\n@@ -61,17 +59,13 @@\n-    env->ReleaseStringCritical(jstr,critstr); CE\n-    for (i=0;i<len;i++) {\n-        digest[i % DIGESTLENGTH]+=str[i];\n-    }\n-    free(str);\n-\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    memcpy(tmp,digest,DIGESTLENGTH);\n-    jArr=env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); CE\n-    len=env->GetArrayLength(jArr); CE\n-    env->SetCharArrayRegion(jArr,0,len,tmp); CE\n-\/*     ++upper; *\/\n-    env->MonitorExit(jobj); CE\n-    return jArr;\n+  }\n+  env->ReleaseStringCritical(jstr, critstr); CE\n+  for (i = 0; i < len; i++) {\n+    digest[i % DIGESTLENGTH] += str[i];\n+  }\n+  free(str);\n+  memcpy(tmp, digest, DIGESTLENGTH);\n+  jArr = env->NewCharArray(DIGESTLENGTH \/ sizeof(jchar)); CE\n+  len = env->GetArrayLength(jArr); CE\n+  env->SetCharArrayRegion(jArr, 0, len, tmp); CE\n+  \/*     ++upper; *\/\n+  CHECK(env->MonitorExit(jobj));\n+  return jArr;\n@@ -82,25 +76,25 @@\n-            jcharArray cArr, jint limit) {\n-\n-    unsigned char digest[DIGESTLENGTH];\n-    jchar *tmp;\n-\/*     jcharArray jArr; *\/\n-    const jchar *critstr;\n-    jint strlen;\n-    char *str;\n-    jboolean ret=JNI_TRUE;\n-    int i;\n-    static jint upper = 0;\n-    jint len;\n-    jchar *ch;\n-\n-    for (i=0;i<DIGESTLENGTH;i++) {\n-      digest[i]=0;\n-    }\n-    strlen =  env->GetStringUTFLength(jstr); CE\n-    str = (char *)malloc(strlen*sizeof(char));\n-\n-    len =env->GetArrayLength(cArr); CE\n-\n-    env->MonitorEnter(jobj); CE\n-    if (upper>limit) {\n-    env->MonitorExit(jobj); CE\n+                                            jcharArray cArr, jint limit) {\n+\n+  unsigned char digest[DIGESTLENGTH];\n+  jchar *tmp;\n+  \/*     jcharArray jArr; *\/\n+  const jchar *critstr;\n+  jint strlen;\n+  char *str;\n+  jboolean ret = JNI_TRUE;\n+  int i;\n+  static jint upper = 0;\n+  jint len;\n+  jchar *ch;\n+\n+  for (i = 0; i < DIGESTLENGTH; i++) {\n+    digest[i] = 0;\n+  }\n+  strlen =  env->GetStringUTFLength(jstr); CE\n+  str = (char *)c_malloc(env, strlen * sizeof(char));\n+\n+  len =env->GetArrayLength(cArr); CE\n+\n+  CHECK(env->MonitorEnter(jobj));\n+  if (upper > limit) {\n+    CHECK(env->MonitorExit(jobj));\n@@ -108,8 +102,4 @@\n-    }\n-    tmp=(jchar *)malloc(DIGESTLENGTH*sizeof(char));\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    critstr=env->GetStringCritical(jstr, 0); CE\n-    for (i=0;i<strlen;i++)\n+  }\n+  tmp = (jchar *)c_malloc(env, DIGESTLENGTH * sizeof(char));\n+  critstr = env->GetStringCritical(jstr, 0); CE\n+  for (i = 0; i < strlen; i++) {\n@@ -117,26 +107,21 @@\n-    env->ReleaseStringCritical(jstr,critstr); CE\n-    for (i=0;i<strlen; i++) {\n-      digest[i % DIGESTLENGTH]+=str[i % DIGESTLENGTH];\n-    }\n-\n-    free(str);\n-\n-    if (env->ExceptionOccurred()) {\n-        env->ExceptionDescribe();\n-        env->ExceptionClear();\n-    }\n-    memcpy(tmp,digest,DIGESTLENGTH);\n-\n-\/*     jArr=env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); *\/\n-\/*     len=env->GetArrayLength(jArr); *\/\n-\/*     env->SetCharArrayRegion(jArr,0,len,tmp); *\/\n-\/*     ++upper; *\/\n-\/*     env->MonitorExit(jobj); *\/\n-\n-\/* Compare  *\/\n-\/*     env->MonitorEnter(jobj); *\/\n-\n-    ch=(jchar *)env->GetPrimitiveArrayCritical(cArr,0); CE\n-\n-    printf(\"Comparing: \");\n-    for (i=0;i<len;i++)\n+  }\n+  env->ReleaseStringCritical(jstr, critstr); CE\n+  for (i = 0; i < strlen; i++) {\n+    digest[i % DIGESTLENGTH] += str[i % DIGESTLENGTH];\n+  }\n+  free(str);\n+  memcpy(tmp, digest, DIGESTLENGTH);\n+\n+  \/*     jArr = env->NewCharArray(DIGESTLENGTH\/sizeof(jchar)); *\/\n+  \/*     len = env->GetArrayLength(jArr); *\/\n+  \/*     env->SetCharArrayRegion(jArr, 0, len, tmp); *\/\n+  \/*     ++upper; *\/\n+  \/*     env->MonitorExit(jobj); *\/\n+\n+  \/* Compare  *\/\n+  \/*     env->MonitorEnter(jobj); *\/\n+\n+  ch = (jchar *)env->GetPrimitiveArrayCritical(cArr, 0); CE\n+\n+  printf(\"Comparing: \");\n+  for (i = 0; i < len; i++) {\n@@ -144,3 +129,5 @@\n-        printf(\"Error in %d\\n\",i);\n-        printf(\"ch[%d]=%02x tmp[%d]=%02x\\n\",i,ch[i],i,tmp[i]);\n-        ret=JNI_FALSE;\n+      printf(\"Error in %d\\n\", i);\n+      printf(\"ch[%d] = %02x tmp[%d] = %02x\\n\", i, ch[i], i, tmp[i]);\n+      ret = JNI_FALSE;\n+    } else {\n+      printf(\"ch[%d] = %02x tmp[%d] = %02x\\n\", i, ch[i], i, tmp[i]);\n@@ -148,9 +135,8 @@\n-    else {\n-        printf(\"ch[%d]=%02x tmp[%d]=%02x\\n\",i,ch[i],i,tmp[i]);\n-    }\n-    printf(\"\\n\");\n-    env->ReleasePrimitiveArrayCritical(cArr,ch,0); CE\n-    ++upper;\n-    if (!(upper % 500))\n-    fprintf(stderr,\"There are %d elements now.\\n\", upper);\n-    if (upper == limit) {\n+  }\n+  printf(\"\\n\");\n+  env->ReleasePrimitiveArrayCritical(cArr, ch, 0); CE\n+  ++upper;\n+  if ((upper % 500) == 0) {\n+    fprintf(stderr, \"There are %d elements now.\\n\", upper);\n+  }\n+  if (upper == limit) {\n@@ -159,2 +145,2 @@\n-    char *name = (char*) \"halt\";\n-    char *sig = (char*) \"()V\";\n+    const char* name = \"halt\";\n+    const char* sig = \"()V\";\n@@ -162,2 +148,2 @@\n-    clazz=env->GetObjectClass(jobj); CE\n-    methodID=env->GetStaticMethodID(clazz, name, sig); CE\n+    clazz = env->GetObjectClass(jobj); CE\n+    methodID = env->GetStaticMethodID(clazz, name, sig); CE\n@@ -166,4 +152,4 @@\n-    ret=JNI_TRUE;\n-    }\n-    env->MonitorExit(jobj); CE\n-    return ret;\n+    ret = JNI_TRUE;\n+  }\n+  CHECK(env->MonitorExit(jobj));\n+  return ret;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress004.cpp","additions":106,"deletions":120,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jnihelper.h\"\n@@ -30,2 +31,0 @@\n-#define CHECK_EXCEPTION     { if (env->ExceptionOccurred()) { fprintf(stderr, \"Unexpected exception:\\n\"); env->ExceptionDescribe(); env->ExceptionClear(); exit(97); } }\n-\n@@ -34,10 +33,16 @@\n-    jclass clazz;\n-    static int Exceptcalls=0;\n-    const char *name;\n-    const char *mess;\n-    jmethodID jmethod;\n-    const char *iter = \"nsk\/stress\/jni\/JNIter005\";\n-\/\/    const char *inc = \"nsk\/stress\/jni\/jnistress005\/incCount\";\n-    const char *incSig = \"()V\";\n-    const char *fldName = \"counts\";\n-    const char *fldSig = \"I\";\n+  jclass clazz;\n+  static int Exceptcalls = 0;\n+  const char *name;\n+  const char *mess;\n+  jmethodID jmethod;\n+  const char *iter = \"nsk\/stress\/jni\/JNIter005\";\n+  \/\/    const char *inc = \"nsk\/stress\/jni\/jnistress005\/incCount\";\n+  const char *incSig = \"()V\";\n+  const char *fldName = \"counts\";\n+  const char *fldSig = \"I\";\n+\n+  \/*     incClazz = env->FindClass(iter); *\/\n+  \/*     jmethod = env->GetStaticMethodID(incClazz, inc, incSig); *\/\n+  \/*     env->CallStaticVoidMethod(incClazz, jmethod); *\/\n+  \/*     jfld = env->GetFieldID(incClazz, fldName, fldSig); *\/\n+  \/*     printf(\"JNI: Count is %d\\n\", env->GetIntField(jobj, jfld)); *\/\n@@ -45,9 +50,1 @@\n-\/*     incClazz = env->FindClass(iter); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     jmethod=env->GetStaticMethodID(incClazz, inc, incSig); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     env->CallStaticVoidMethod(incClazz, jmethod); *\/\n-\/*     CHECK_EXCEPTION *\/\n-\/*     jfld = env->GetFieldID(incClazz, fldName, fldSig); *\/\n-\/*     printf(\"JNI: Count is %d\\n\", env->GetIntField(jobj, jfld)); *\/\n-\/*     CHECK_EXCEPTION *\/\n+  CHECK(env->MonitorEnter(jobj));\n@@ -55,6 +52,6 @@\n-    env->MonitorEnter(jobj);\n-    CHECK_EXCEPTION\n-    if (!env->Throw(tobj)) {\n-    if (env->ExceptionOccurred())\n-        if (Exceptcalls % 1000 == 0)\n-        fprintf(stderr, \"NATIVE: Throw has been catched in native\\n\");\n+  if (env->Throw(tobj) == 0) {\n+    if (env->ExceptionOccurred()) {\n+      if (Exceptcalls % 1000 == 0) {\n+        fprintf(stderr, \"NATIVE: Throw has been caught in native\\n\");\n+      }\n+    }\n@@ -63,1 +60,3 @@\n-    } else fprintf(stderr, \"Throw failed\\n\");\n+  } else {\n+    fprintf(stderr, \"Throw failed\\n\");\n+  }\n@@ -65,2 +64,1 @@\n-    env->MonitorExit(jobj);\n-    CHECK_EXCEPTION\n+  CHECK(env->MonitorExit(jobj));\n@@ -68,27 +66,27 @@\n-    switch (Exceptcalls % 23) {\n-      case 0: name=\"java\/lang\/ArithmeticException\"; break;\n-      case 1: name=\"java\/lang\/ArrayIndexOutOfBoundsException\"; break;\n-      case 2: name=\"java\/lang\/ArrayStoreException\"; break;\n-      case 3: name=\"java\/lang\/ClassCastException\"; break;\n-      case 4: name=\"java\/lang\/ClassNotFoundException\"; break;\n-      case 5: name=\"java\/lang\/CloneNotSupportedException\"; break;\n-      case 6: name=\"java\/lang\/IllegalAccessException\"; break;\n-      case 7: name=\"java\/lang\/IllegalArgumentException\"; break;\n-      case 8: name=\"java\/lang\/IllegalMonitorStateException\"; break;\n-      case 9: name=\"java\/lang\/IllegalStateException\"; break;\n-      case 10: name=\"java\/lang\/IllegalThreadStateException\"; break;\n-      case 11: name=\"java\/lang\/IndexOutOfBoundsException\"; break;\n-      case 12: name=\"java\/lang\/InstantiationException\"; break;\n-      case 13: name=\"java\/lang\/InterruptedException\"; break;\n-      case 14: name=\"java\/lang\/NegativeArraySizeException\"; break;\n-      case 15: name=\"java\/lang\/NoSuchFieldException\"; break;\n-      case 16: name=\"java\/lang\/NoSuchMethodException\"; break;\n-      case 17: name=\"java\/lang\/NullPointerException\"; break;\n-      case 18: name=\"java\/lang\/NumberFormatException\"; break;\n-      case 19: name=\"java\/lang\/RuntimeException\"; break;\n-      case 20: name=\"java\/lang\/SecurityException\"; break;\n-      case 21: name=\"java\/lang\/StringIndexOutOfBoundsException\"; break;\n-      case 22: name=\"java\/lang\/UnsupportedOperationException\"; break;\n-      default: name=\"java\/lang\/Exception\";\n-    }\n-    mess=name;\n+  switch (Exceptcalls % 23) {\n+  case 0: name = \"java\/lang\/ArithmeticException\"; break;\n+  case 1: name = \"java\/lang\/ArrayIndexOutOfBoundsException\"; break;\n+  case 2: name = \"java\/lang\/ArrayStoreException\"; break;\n+  case 3: name = \"java\/lang\/ClassCastException\"; break;\n+  case 4: name = \"java\/lang\/ClassNotFoundException\"; break;\n+  case 5: name = \"java\/lang\/CloneNotSupportedException\"; break;\n+  case 6: name = \"java\/lang\/IllegalAccessException\"; break;\n+  case 7: name = \"java\/lang\/IllegalArgumentException\"; break;\n+  case 8: name = \"java\/lang\/IllegalMonitorStateException\"; break;\n+  case 9: name = \"java\/lang\/IllegalStateException\"; break;\n+  case 10: name = \"java\/lang\/IllegalThreadStateException\"; break;\n+  case 11: name = \"java\/lang\/IndexOutOfBoundsException\"; break;\n+  case 12: name = \"java\/lang\/InstantiationException\"; break;\n+  case 13: name = \"java\/lang\/InterruptedException\"; break;\n+  case 14: name = \"java\/lang\/NegativeArraySizeException\"; break;\n+  case 15: name = \"java\/lang\/NoSuchFieldException\"; break;\n+  case 16: name = \"java\/lang\/NoSuchMethodException\"; break;\n+  case 17: name = \"java\/lang\/NullPointerException\"; break;\n+  case 18: name = \"java\/lang\/NumberFormatException\"; break;\n+  case 19: name = \"java\/lang\/RuntimeException\"; break;\n+  case 20: name = \"java\/lang\/SecurityException\"; break;\n+  case 21: name = \"java\/lang\/StringIndexOutOfBoundsException\"; break;\n+  case 22: name = \"java\/lang\/UnsupportedOperationException\"; break;\n+  default: name = \"java\/lang\/Exception\";\n+  }\n+  mess = name;\n@@ -96,17 +94,13 @@\n-    CHECK_EXCEPTION\n-    clazz = env->FindClass(name);\n-    CHECK_EXCEPTION\n-    if (env->ThrowNew(clazz, mess)) {\n-      const char *pass = \"setpass\";\n-      const char *passSig = \"(Z)V\";\n-      jclass incClazz;\n-      fprintf(stderr, \"ThrowNew failed\\n\");\n-      CHECK_EXCEPTION;\n-      incClazz = env->FindClass(iter);\n-      CHECK_EXCEPTION;\n-      jmethod=env->GetStaticMethodID(incClazz, pass, passSig);\n-      CHECK_EXCEPTION\n-      env->CallStaticVoidMethod(incClazz, jmethod, JNI_FALSE);\n-      CHECK_EXCEPTION\n-    }\n-\/*     printf(\"JNI: count %d\\n\", Exceptcalls); *\/\n+  clazz = env->FindClass(name); CE\n+  if (env->ThrowNew(clazz, mess) != 0) {\n+    const char *pass = \"setpass\";\n+    const char *passSig = \"(Z)V\";\n+    jclass incClazz;\n+    fprintf(stderr, \"ThrowNew failed\\n\");\n+    CE;\n+    \/\/ ThrowNew failed but didn't itself raise an exception\n+    incClazz = env->FindClass(iter); CE\n+    jmethod=env->GetStaticMethodID(incClazz, pass, passSig); CE\n+    env->CallStaticVoidMethod(incClazz, jmethod, JNI_FALSE); CE\n+  }\n+  \/*     printf(\"JNI: count %d\\n\", Exceptcalls); *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress005.cpp","additions":69,"deletions":75,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-    static jobject *globRefsArray = 0;\n-    static int upper = 0;\n+  static jobject *globRefsArray = 0;\n+  static int upper = 0;\n@@ -37,11 +37,11 @@\n-    jclass clazz;\n-    jmethodID jmethod;\n-    jboolean res=JNI_FALSE;\n-    const char *classname = \"nsk\/stress\/jni\/JNIter006\";\n-    const char *getmethodname=\"get_i\";\n-    const char *setmethodname=\"set_i\";\n-    const char *getsig=\"()I\";\n-    const char *setsig=\"(I)V\";\n-    const char *setdone = \"halt\";\n-    const char *setdonesig = \"()V\";\n-    int i = 0;\n+  jclass clazz;\n+  jmethodID jmethod;\n+  jboolean res = JNI_FALSE;\n+  const char *classname = \"nsk\/stress\/jni\/JNIter006\";\n+  const char *getmethodname = \"get_i\";\n+  const char *setmethodname = \"set_i\";\n+  const char *getsig = \"()I\";\n+  const char *setsig = \"(I)V\";\n+  const char *setdone = \"halt\";\n+  const char *setdonesig = \"()V\";\n+  int i = 0;\n@@ -49,1 +49,3 @@\n-    if (upper >= LIMIT) return JNI_TRUE;\n+  if (upper >= LIMIT) {\n+    return JNI_TRUE;\n+  }\n@@ -51,3 +53,3 @@\n-    if (upper == 0) {\n-        globRefsArray=(jobject*)(malloc(LIMIT*sizeof(jobject)));\n-    }\n+  if (upper == 0) {\n+    globRefsArray = (jobject*)c_malloc(env, LIMIT * sizeof(jobject));\n+  }\n@@ -55,2 +57,2 @@\n-    globRefsArray[upper]=env->NewGlobalRef(tobj); CE\n-    if (env->IsSameObject(tobj, globRefsArray[upper])) {\n+  globRefsArray[upper] = env->NewGlobalRef(tobj); CE\n+  if (env->IsSameObject(tobj, globRefsArray[upper])) {\n@@ -58,5 +60,4 @@\n-    clazz=env->GetObjectClass(globRefsArray[upper]); CE\n-    }\n-    else {\n-    fprintf(stderr,\"Objects are different\\n\");\n-    env->MonitorExit(jobj); CE\n+    clazz = env->GetObjectClass(globRefsArray[upper]); CE\n+  } else {\n+    fprintf(stderr, \"Objects are different\\n\");\n+    CHECK(env->MonitorExit(jobj));\n@@ -64,14 +65,14 @@\n-    }\n-    jmethod=env->GetStaticMethodID(clazz, setmethodname, setsig); CE\n-    env->CallStaticVoidMethod(clazz, jmethod, (jint)upper); CE\n-    env->MonitorEnter(jobj); CE\n-    ++upper;\n-    res=JNI_TRUE;\n-    env->MonitorExit(jobj); CE\n-\/* If upper == LIMIT than flush ref's array and set *\/\n-\/* 'done' flag in JNIter006 class to JNI_TRUE *\/\n-    if (upper == LIMIT) {\n-    fprintf(stderr,\"\\n\\tTotal memory allocated: %zd bytes\\n\",\n-        LIMIT*sizeof(jobject));\n-    clazz=env->FindClass(classname); CE\n-    jmethod=env->GetMethodID(clazz, setdone, setdonesig); CE\n+  }\n+  jmethod = env->GetStaticMethodID(clazz, setmethodname, setsig); CE\n+  env->CallStaticVoidMethod(clazz, jmethod, (jint)upper); CE\n+  CHECK(env->MonitorEnter(jobj));\n+  ++upper;\n+  res = JNI_TRUE;\n+  CHECK(env->MonitorExit(jobj));\n+  \/* If upper == LIMIT than flush ref's array and set *\/\n+  \/* 'done' flag in JNIter006 class to JNI_TRUE *\/\n+  if (upper == LIMIT) {\n+    fprintf(stderr, \"\\n\\tTotal memory allocated: %zd bytes\\n\",\n+            LIMIT * sizeof(jobject));\n+    clazz = env->FindClass(classname); CE\n+    jmethod = env->GetMethodID(clazz, setdone, setdonesig); CE\n@@ -80,2 +81,2 @@\n-    for (i=0;i<LIMIT;i++) {\n-        env->DeleteGlobalRef(globRefsArray[i]); CE\n+    for (i = 0; i < LIMIT; i++) {\n+      env->DeleteGlobalRef(globRefsArray[i]); CE\n@@ -83,3 +84,3 @@\n-        free(globRefsArray);\n-    }\n-    return res;\n+    free(globRefsArray);\n+  }\n+  return res;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress006.cpp","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,4 @@\n-    jclass clazz;\n-    jfieldID fld;\n-    jint value;\n-    const char *str = env->GetStringUTFChars(name, 0); CE\n+  jclass clazz;\n+  jfieldID fld;\n+  jint value;\n+  const char *str = env->GetStringUTFChars(name, 0); CE\n@@ -37,9 +37,9 @@\n-    if (env->MonitorEnter(jobj))\n-        printf(\"Error in monitor lock\\n\");\n-    clazz = env->GetObjectClass(jobj); CE\n-    fld = env->GetStaticFieldID(clazz, \"nativeCount\", \"I\"); CE\n-    value = env->GetStaticIntField(clazz, fld); CE\n-    env->SetStaticIntField(clazz, fld, (jint)(++value)); CE\n-    env->MonitorExit(jobj); CE\n-    if (value % 1000 == 0)\n-        printf(\"in %s Count after %u\\n\", str, value);\n+  CHECK(env->MonitorEnter(jobj));\n+  clazz = env->GetObjectClass(jobj); CE\n+  fld = env->GetStaticFieldID(clazz, \"nativeCount\", \"I\"); CE\n+  value = env->GetStaticIntField(clazz, fld); CE\n+  env->SetStaticIntField(clazz, fld, (jint)(++value)); CE\n+  CHECK(env->MonitorExit(jobj));\n+  if (value % 1000 == 0) {\n+    printf(\"in %s Count after %u\\n\", str, value);\n+  }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress007.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,1 +59,2 @@\n-    NSK_JNI_VERIFY(pEnv, NULL != (arguments = pEnv->NewObjectArray(ARGS_COUNT, objectClass, NULL)));\n+    if (!NSK_JNI_VERIFY(pEnv, NULL != (arguments = pEnv->NewObjectArray(ARGS_COUNT, objectClass, NULL))))\n+        return NULL;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/jni\/nativeAndMH\/nativeAndMH.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package vm.share.gc;\n+\n+\/**\n+ * This class is used to distinguish between OOME in metaspace and OOME in heap when triggering class unloading.\n+ *\/\n+public class HeapOOMEException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public HeapOOMEException(String string) {\n+        super(string);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/HeapOOMEException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import metaspace.stressHierarchy.common.exceptions.GotWrongOOMEException;\n@@ -53,1 +52,1 @@\n-                    throw new GotWrongOOMEException(\"Got OOME in heap while triggering OOME in metaspace. Test result can't be valid.\");\n+                    throw new HeapOOMEException(\"Got OOME in heap while triggering OOME in metaspace. Test result can't be valid.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingMetaspace.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package transform;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.InputStream;\n+\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.Result;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+import static jaxp.library.JAXPTestUtilities.compareWithGold;\n+import static jaxp.library.JAXPTestUtilities.compareStringWithGold;\n+import org.testng.Assert;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8268457\n+ * @library \/javax\/xml\/jaxp\/libs\n+ * @run testng transform.SurrogateTest\n+ * @summary XML Transformer outputs Unicode supplementary character incorrectly to HTML\n+ *\/\n+@Listeners({jaxp.library.FilePolicy.class})\n+public class SurrogateTest {\n+\n+    final static String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+\n+    @Test\n+    public void toHTMLTest() throws Exception {\n+        String out = \"SurrogateTest1out.html\";\n+        String expected = TEST_SRC + File.separator + \"SurrogateTest1.html\";\n+        String xsl = TEST_SRC + File.separator + \"SurrogateTest1.xsl\";\n+\n+        try (FileInputStream tFis = new FileInputStream(xsl);\n+            InputStream fis = this.getClass().getResourceAsStream(\"SurrogateTest1.xml\");\n+            FileOutputStream fos = new FileOutputStream(out)) {\n+\n+            Source tSrc = new StreamSource(tFis);\n+            TransformerFactory tf = TransformerFactory.newInstance();\n+            Transformer t = tf.newTransformer(tSrc);\n+            t.setOutputProperty(\"method\", \"html\");\n+\n+            Source src = new StreamSource(fis);\n+            Result res = new StreamResult(fos);\n+            t.transform(src, res);\n+        }\n+        compareWithGold(expected, out);\n+    }\n+\n+    @Test\n+    public void handlerTest() throws Exception {\n+        File xmlFile = new File(TEST_SRC, \"SurrogateTest2.xml\");\n+        SAXParserFactory spf = SAXParserFactory.newInstance();\n+        spf.setNamespaceAware(true);\n+        SAXParser sp = spf.newSAXParser();\n+        TestHandler th = new TestHandler();\n+        sp.parse(xmlFile, th);\n+        compareStringWithGold(TEST_SRC + File.separator + \"SurrogateTest2.txt\", th.sb.toString());\n+    }\n+\n+    private static class TestHandler extends DefaultHandler {\n+        private StringBuilder sb = new StringBuilder();\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            sb.append( localName + \"@attr:\" + attributes.getValue(\"attr\") + '\\n');\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\">\r\n+<html>\r\n+    <head>\r\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\">\r\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\">\r\n+    <\/head>\r\n+    <body>\r\n+        <form>\r\n+            <input id=\"tag1\" value=\"\">\r\n+        <\/form>\r\n+    <\/body>\r\n+<\/html>\r\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.html","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<root>\n+    <tag1><\/tag1>\n+<\/root>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n+<xsl:stylesheet xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" version=\"1.0\">\r\n+  <xsl:output doctype-public=\"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\"\r\n+   doctype-system=\"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\"\r\n+   encoding=\"UTF-8\" indent=\"yes\" method=\"html\" omit-xml-declaration=\"yes\"\/>\r\n+  <xsl:template match=\"\/\">\r\n+    <html>\r\n+      <head>\r\n+        <META http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\"\/>\r\n+      <\/head>\r\n+      <body>\r\n+        <xsl:for-each select=\"root\">\r\n+          <form>\r\n+            <xsl:for-each select=\"tag1\">\r\n+              <input id=\"tag1\">\r\n+                <xsl:attribute name=\"value\">\r\n+                  <xsl:value-of select=\".\"\/>\r\n+                <\/xsl:attribute>\r\n+              <\/input>\r\n+            <\/xsl:for-each>\r\n+          <\/form>\r\n+        <\/xsl:for-each>\r\n+      <\/body>\r\n+    <\/html>\r\n+  <\/xsl:template>\r\n+<\/xsl:stylesheet>\r\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest1.xsl","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+root@attr:null\n+tag1@attr:\n+tag2@attr:\n+tag3@attr:\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest2.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<root>\n+    <tag1 attr=\"\"\/>\n+    <tag2 attr=\"\"\/>\n+    <tag3 attr=\"\"\/>\n+<\/root>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SurrogateTest2.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -557,0 +557,1 @@\n+java\/lang\/invoke\/RicochetTest.java                              8251969 generic-all\n@@ -666,1 +667,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/BuypassCA.java  8243543 generic-all\n@@ -669,1 +669,0 @@\n-security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/LetsEncryptCA.java 8270280 generic-all\n@@ -748,1 +747,0 @@\n-javax\/swing\/JFileChooser\/FileSystemView\/SystemIconTest.java 8268280 windows-x64\n@@ -829,1 +827,0 @@\n-jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java        8263461 linux-x64\n@@ -831,0 +828,1 @@\n+jdk\/jfr\/event\/oldobject\/TestObjectSize.java                     8269418 macosx-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -52,1 +52,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks\n@@ -60,1 +60,1 @@\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -68,25 +68,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n- * @run driver EATests\n- *                 -XX:+UnlockDiagnosticVMOptions\n- *                 -Xms256m -Xmx256m\n- *                 -Xbootclasspath\/a:.\n- *                 -XX:CompileCommand=dontinline,*::dontinline_*\n- *                 -XX:+WhiteBoxAPI\n- *                 -Xbatch\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -103,1 +79,1 @@\n- *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n@@ -235,1 +211,0 @@\n-        new EARelockingSimple_2Target()                                                     .run();\n@@ -241,2 +216,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3Target()                             .run();\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4Target()                             .run();\n@@ -352,1 +325,0 @@\n-        new EARelockingSimple_2()                                                     .run(this);\n@@ -358,2 +330,0 @@\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_3()                             .run(this);\n-        new EARelockingArgEscapeLWLockedInCalleeFrame_4()                             .run(this);\n@@ -796,2 +766,0 @@\n-    public static final long BiasedLockingBulkRebiasThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRebiasThreshold\");\n-    public static final long BiasedLockingBulkRevokeThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRevokeThreshold\");\n@@ -812,2 +780,0 @@\n-    public volatile Object biasToBeRevoked;\n-\n@@ -1057,40 +1023,0 @@\n-    \/**\n-     * Trigger bulk rebiasing for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRebiasAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRebiasThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Trigger bulk revoke of biases for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n-     * @param cls The class to bulk rebias\n-     *\/\n-    public void dontinline_bulkRevokeAfterWarmup(Class<?> cls) {\n-        if (warmupDone) {\n-            try {\n-                for (int i=0; i < BiasedLockingBulkRevokeThreshold+2; i++) {\n-                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n-                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n-                        checkSum++;\n-                    }\n-                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n-                }\n-            } catch (Throwable e) {\n-                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n-            }\n-        }\n-    }\n-\n@@ -1767,32 +1693,0 @@\n-\/**\n- * Test if the bias of an object O that escapes globally is revoked correctly if local objects\n- * escape through JVMTI. O is referenced by field l0.\n- * This tests a regression of a previous version of the implementation.\n- *\/\n-class EARelockingSimple_2 extends EATestCaseBaseDebugger {\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingSimple_2Target extends EATestCaseBaseTarget {\n-\n-    public XYVal l0;\n-\n-    public void dontinline_testMethod() {\n-        l0 = new XYVal(4, 2);         \/\/ GobalEscape\n-        XYVal l1 = new XYVal(4, 2);\n-        synchronized (l0) {\n-            synchronized (l1) {\n-                dontinline_brkpt();\n-            }\n-        }\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -1997,99 +1891,0 @@\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}.\n- * A bulk rebias operation is triggered at a position where all locks on the local object referenced\n- * by l1 are eliminated. This leaves the object with an outdated biased locking epoch which has to be\n- * considered when relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_3Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_3Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRebiasAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/**\n- * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_3}.\n- * But instead of a bulk rebias a bulk revoke operation is triggered.\n- * This leaves the object with a stale bias as the prototype header of its calls lost its bias\n- * pattern in the bulk revoke which has to be considered during relocking.\n- * This tests a regression in a previous version.\n- *\/\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4 extends EATestCaseBaseDebugger {\n-\n-    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_4Target.XYValLocal.class.getName();\n-\n-    public void runTestCase() throws Exception {\n-        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n-        printStack(bpe.thread());\n-        @SuppressWarnings(\"unused\")\n-        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n-    }\n-}\n-\n-class EARelockingArgEscapeLWLockedInCalleeFrame_4Target extends EATestCaseBaseTarget {\n-\n-    \/\/ Using local type to avoid side effects on biased locking heuristics\n-    public static class XYValLocal extends XYVal {\n-        public XYValLocal(int x, int y) {\n-            super(x,y);\n-        }\n-    }\n-\n-    public void dontinline_testMethod() {\n-        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n-        synchronized (l1) {                    \/\/ eliminated\n-            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n-            \/\/ trigger bulk rebias\n-            dontinline_bulkRevokeAfterWarmup(l1.getClass());\n-            \/\/ Now the epoch of l1 does not match the epoch of its class.\n-            \/\/ This has to be considered when relocking because of JVMTI access\n-            dontinline_brkpt();\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean testFrameShouldBeDeoptimized() {\n-        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n-        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n-    }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":5,"deletions":210,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.JDWP;\n@@ -40,1 +41,0 @@\n-import java.util.ArrayList;\n@@ -45,2 +45,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -79,1 +77,0 @@\n-    private static Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(\\\\d+)\\\\b\");\n@@ -85,4 +82,3 @@\n-            Matcher m = listenRegexp.matcher(s);\n-            if (m.find()) {\n-                \/\/ m.group(1) is transport, m.group(2) is port\n-                return Integer.parseInt(m.group(2));\n+            JDWP.ListenAddress addr = JDWP.parseListenAddress(s);\n+            if (addr != null) {\n+                return Integer.parseInt(addr.address());\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpAllowTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -46,0 +44,2 @@\n+\n+import jdk.test.lib.JDWP;\n@@ -98,3 +98,0 @@\n-    \/* warm-up predicate for debuggee *\/\n-    private static Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n-\n@@ -102,2 +99,2 @@\n-        Matcher m = listenRegexp.matcher(line);\n-        if (!m.matches()) {\n+        JDWP.ListenAddress addr = JDWP.parseListenAddress(line);\n+        if (addr == null) {\n@@ -106,2 +103,1 @@\n-        \/\/ address is 2nd group\n-        address = m.group(2);\n+        address = addr.address();\n","filename":"test\/jdk\/com\/sun\/jdi\/RunToExit.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.lib.JDWP;\n@@ -35,2 +36,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -127,3 +126,1 @@\n-        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n-        String[] debuggeeListen = new String[2];\n-        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        JDWP.ListenAddress[] listenAddress = new JDWP.ListenAddress[1];\n@@ -134,7 +131,2 @@\n-                        Matcher m = listenRegexp.matcher(s);\n-                        if (!m.matches()) {\n-                            return false;\n-                        }\n-                        debuggeeListen[0] = m.group(1);\n-                        debuggeeListen[1] = m.group(2);\n-                        return true;\n+                        listenAddress[0] = JDWP.parseListenAddress(s);\n+                        return listenAddress[0] != null;\n@@ -143,2 +135,2 @@\n-            transport = debuggeeListen[0];\n-            address = debuggeeListen[1];\n+            transport = listenAddress[0].transport();\n+            address = listenAddress[0].address();\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8251496\n+ * @bug 8251496 8268960\n@@ -28,0 +28,3 @@\n+ * @modules jdk.httpserver\/com.sun.net.httpserver:+open\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n@@ -31,0 +34,17 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n@@ -32,0 +52,5 @@\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.DataProvider;\n@@ -34,0 +59,4 @@\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertThrows;\n@@ -38,0 +67,4 @@\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n@@ -39,1 +72,1 @@\n-    public void TestDefaultConstructor() {\n+    public static void testDefaultConstructor() {\n@@ -43,0 +76,241 @@\n+\n+    @Test\n+    public static void testNull() {\n+        final Headers h = new Headers();\n+        h.put(\"Foo\", List.of(\"Bar\"));\n+\n+        final var mapNullKey = new HashMap<String, List<String>>();\n+        mapNullKey.put(null, List.of(\"Bar\"));\n+\n+        final var mapNullList = new HashMap<String, List<String>>();\n+        mapNullList.put(\"Foo\", null);\n+\n+        final var listWithNull = new LinkedList<String>();\n+        listWithNull.add(null);\n+\n+        final var mapNullInList = new HashMap<String, List<String>>();\n+        mapNullInList.put(\"Foo\", listWithNull);\n+\n+        assertThrows(NPE, () -> h.add(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.add(\"Foo\", null));\n+\n+        assertThrows(NPE, () -> h.compute(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.compute(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfAbsent(null, (k) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfAbsent(\"Foo-foo\", (k) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfPresent(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfPresent(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.containsKey(null));\n+\n+        assertThrows(NPE, () -> h.containsValue(null));\n+\n+        assertThrows(NPE, () -> h.get(null));\n+\n+        assertThrows(NPE, () -> h.getFirst(null));\n+\n+        assertThrows(NPE, () -> h.getOrDefault(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.merge(null, List.of(\"Bar\"), (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", listWithNull, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo\", List.of(\"Bar\"), (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.put(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.put(\"Foo\", null));\n+        assertThrows(NPE, () -> h.put(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.putAll(mapNullKey));\n+        assertThrows(NPE, () -> h.putAll(mapNullList));\n+        assertThrows(NPE, () -> h.putAll(mapNullInList));\n+\n+        assertThrows(NPE, () -> h.putIfAbsent(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", null));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.remove(null));\n+\n+        assertThrows(NPE, () -> h.remove(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\"), List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), listWithNull));\n+\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> listWithNull));\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> null));\n+\n+        assertThrows(NPE, () -> h.set(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.set(\"Foo\", null));\n+    }\n+\n+    @DataProvider\n+    public Object[][] responseHeaders() {\n+        final var listWithNull = new LinkedList<String>();\n+        listWithNull.add(null);\n+        return new Object[][] {\n+                {null,  List.of(\"Bar\")},\n+                {\"Foo\", null},\n+                {\"Foo\", listWithNull}\n+        };\n+    }\n+\n+    \/**\n+     * Confirms HttpExchange::sendResponseHeaders throws NPE if response headers\n+     * contain a null key or value.\n+     *\/\n+    @Test(dataProvider = \"responseHeaders\")\n+    public void testNullResponseHeaders(String headerKey, List<String> headerVal)\n+            throws Exception {\n+        var handler = new Handler(headerKey, headerVal);\n+        var server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            assertThrows(IOE, () -> client.send(request, HttpResponse.BodyHandlers.ofString()));\n+            assertEquals(throwable.get().getClass(), NPE);\n+            assertTrue(Arrays.stream(throwable.get().getStackTrace())\n+                    .anyMatch(e -> e.getClassName().equals(\"sun.net.httpserver.HttpExchangeImpl\")\n+                            || e.getMethodName().equals(\"sendResponseHeaders\")));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private static CompletableFuture<Throwable> throwable = new CompletableFuture<>();\n+\n+    private record Handler(String headerKey, List<String> headerVal) implements HttpHandler {\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                putHeaders(exchange.getResponseHeaders(), headerKey, headerVal);\n+                try {\n+                    exchange.sendResponseHeaders(200, resp.length);\n+                } catch (Throwable t) {  \/\/ expect NPE\n+                    throwable.complete(t);\n+                    throw t;\n+                }\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    private static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    \/**\n+     * Sets headers reflectively to be able to set a null key or value.\n+     *\/\n+    private static void putHeaders(Headers headers,\n+                                   String headerKey,\n+                                   List<String> headerVal) {\n+        try {\n+            final var map = new HashMap<String, List<String>>();\n+            map.put(headerKey, headerVal);\n+            var mapField = Headers.class.getDeclaredField(\"map\");\n+            mapField.setAccessible(true);\n+            mapField.set(headers, map);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Could not set headers reflectively\", e);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] headerPairs() {\n+        final var h1 = new Headers();\n+        final var h2 = new Headers();\n+        final var h3 = new Headers();\n+        final var h4 = new Headers();\n+        final var h5 = new Headers();\n+        h1.put(\"Accept-Encoding\", List.of(\"gzip, deflate\"));\n+        h2.put(\"accept-encoding\", List.of(\"gzip, deflate\"));\n+        h3.put(\"AccePT-ENCoding\", List.of(\"gzip, deflate\"));\n+        h4.put(\"ACCept-EncodING\", List.of(\"gzip, deflate\"));\n+        h5.put(\"ACCEPT-ENCODING\", List.of(\"gzip, deflate\"));\n+\n+        final var headers = List.of(h1, h2, h3, h4, h5);\n+        return headers.stream()  \/\/ cartesian product of headers\n+                .flatMap(header1 -> headers.stream().map(header2 -> new Headers[] { header1, header2 }))\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"headerPairs\")\n+    public static void testEqualsAndHashCode(Headers h1, Headers h2) {\n+        \/\/ avoid testng's asserts(Map, Map) as they don't call Headers::equals\n+        assertTrue(h1.equals(h2), \"Headers differ\");\n+        assertEquals(h1.hashCode(), h2.hashCode(), \"hashCode differ for \"\n+                + List.of(h1, h2));\n+    }\n+\n+    @Test\n+    public static void testEqualsMap() {\n+        final var h = new Headers();\n+        final var m = new HashMap<String, List<String>>();\n+        assertTrue(h.equals(m));\n+        assertTrue(m.equals(h));\n+        assertFalse(h.equals(null), \"null cannot be equal to Headers\");\n+    }\n+\n+    @Test\n+    public static void testToString() {\n+        final var h = new Headers();\n+        h.put(\"Accept-Encoding\", List.of(\"gzip, deflate\"));\n+        assertTrue(h.toString().equals(\"Headers { {Accept-encoding=[gzip, deflate]} }\"));\n+    }\n+\n+    @Test\n+    public static void testPutAll() {\n+        final var h0 = new Headers();\n+        final var map = new HashMap<String, List<String>>();\n+        map.put(\"a\", null);\n+        assertThrows(NPE, () -> h0.putAll(map));\n+\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h0.putAll(Map.of(\"a\", list)));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\n\"))));\n+\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var h2 = new Headers();\n+        h2.putAll(Map.of(\"a\", List.of(\"1\"), \"b\", List.of(\"2\")));\n+        assertTrue(h1.equals(h2));\n+    }\n+\n+    @Test\n+    public static void testReplaceAll() {\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h1.replaceAll((k, v) -> list));\n+        assertThrows(IAE, () -> h1.replaceAll((k, v) -> List.of(\"\\n\")));\n+\n+        h1.replaceAll((k, v) -> {\n+            String s = h1.get(k).get(0);\n+            return List.of(s+s);\n+        });\n+        final var h2 = new Headers();\n+        h2.put(\"a\", List.of(\"11\"));\n+        h2.put(\"b\", List.of(\"22\"));\n+        assertTrue(h1.equals(h2));\n+    }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":277,"deletions":3,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269692\n+ * @summary HttpContext::createContext should throw IllegalArgumentException\n+ *          if context already exists\n+ * @run testng\/othervm HttpContextTest\n+ *\/\n+\n+import java.io.IOException;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+\n+public class HttpContextTest {\n+\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+\n+    @Test\n+    public static void test() throws IOException {\n+        final var server = HttpServer.create(null, 0);\n+        final var path = \"\/foo\/\";\n+\n+        assertThrows(IAE, () -> server.removeContext(path));\n+        HttpContext context = server.createContext(path);\n+        assertEquals(context.getPath(), path);\n+        assertThrows(IAE, () -> server.createContext(path));\n+        assertThrows(IAE, () -> server.createContext(path, new Handler()));\n+\n+        context.setHandler(new Handler());\n+        assertThrows(IAE, () -> server.createContext(path));\n+        assertThrows(IAE, () -> server.createContext(path, new Handler()));\n+        server.removeContext(context);\n+        assertThrows(IAE, () -> server.removeContext(path));\n+\n+        context = server.createContext(path, new Handler());\n+        assertEquals(context.getPath(), path);\n+        assertThrows(IAE, () -> server.createContext(path));\n+        assertThrows(IAE, () -> server.createContext(path, new Handler()));\n+        server.removeContext(path);\n+        assertThrows(IAE, () -> server.removeContext(path));\n+    }\n+\n+    \/**\n+     * Confirms that it is possible to create a subcontext, a context whose path\n+     * shares the prefix of an existing context.\n+     *\/\n+    @Test\n+    public static void testSubcontext() throws IOException {\n+        final var server = HttpServer.create(null, 0);\n+        server.createContext(\"\/foo\/bar\/\");\n+        server.createContext(\"\/foo\/\");\n+\n+        server.createContext(\"\/foo\");\n+        server.createContext(\"\/foo\/bar\");\n+    }\n+\n+    \/**\n+     * A no-op handler\n+     *\/\n+    static class Handler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException { }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HttpContextTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270286\n+ * @summary Test for HttpServerProvider::loadProviderFromProperty\n+ * @run testng\/othervm\n+ *      -Dcom.sun.net.httpserver.HttpServerProvider=HttpServerProviderTest$ProviderP\n+ *      HttpServerProviderTest\n+ * @run testng\/othervm\n+ *      -Dcom.sun.net.httpserver.HttpServerProvider=HttpServerProviderTest$ProviderPNPC\n+ *      HttpServerProviderTest\n+ * @run testng\/othervm\n+ *      -Dcom.sun.net.httpserver.HttpServerProvider=HttpServerProviderTest$ProviderNP\n+ *      HttpServerProviderTest\n+ * @run testng\/othervm\n+ *      -Dcom.sun.net.httpserver.HttpServerProvider=HttpServerProviderTest$ProviderT\n+ *      HttpServerProviderTest\n+ * @run testng\/othervm\n+ *      -Dcom.sun.net.httpserver.HttpServerProvider=DoesNotExist\n+ *      HttpServerProviderTest\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.InetSocketAddress;\n+import java.util.ServiceConfigurationError;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsServer;\n+import com.sun.net.httpserver.spi.HttpServerProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.expectThrows;\n+\n+public class HttpServerProviderTest {\n+    public final static String PROPERTY_KEY = \"com.sun.net.httpserver.HttpServerProvider\";\n+\n+    @Test\n+    public void test() throws Exception {\n+        var provider = System.getProperty(PROPERTY_KEY);\n+        switch (provider) {\n+            case \"HttpServerProviderTest$ProviderP\" -> testPublic();\n+            case \"HttpServerProviderTest$ProviderPNPC\" -> testPublicNonPublicConstructor();\n+            case \"HttpServerProviderTest$ProviderNP\" -> testNonPublic();\n+            case \"HttpServerProviderTest$ProviderT\" -> testThrowingConstructor();\n+            default -> testBadData();\n+        }\n+    }\n+\n+    private void testPublic() throws Exception {\n+        var n = ProviderP.class.getName();\n+        assertEquals(System.getProperty(PROPERTY_KEY), n);\n+\n+        var p = HttpServerProvider.provider();\n+        assertNull(p.createHttpServer(null, 0));\n+        assertNull(p.createHttpsServer(null, 0));\n+    }\n+\n+    private void testPublicNonPublicConstructor() {\n+        var n = ProviderPNPC.class.getName();\n+        assertEquals(System.getProperty(PROPERTY_KEY), n);\n+\n+        var e = expectThrows(ServiceConfigurationError.class, HttpServerProvider::provider);\n+        assertEquals(e.getClass(), ServiceConfigurationError.class);\n+        assertEquals(e.getCause().getClass(), IllegalAccessException.class);\n+    }\n+\n+    private void testNonPublic() {\n+        var n = ProviderNP.class.getName();\n+        assertEquals(System.getProperty(PROPERTY_KEY), n);\n+\n+        var e = expectThrows(ServiceConfigurationError.class, HttpServerProvider::provider);\n+        assertEquals(e.getClass(), ServiceConfigurationError.class);\n+        assertEquals(e.getCause().getClass(), IllegalAccessException.class);\n+    }\n+\n+    private void testThrowingConstructor() {\n+        var cn = ProviderT.class.getName();\n+        assertEquals(System.getProperty(PROPERTY_KEY), cn);\n+\n+        var e = expectThrows(ServiceConfigurationError.class, HttpServerProvider::provider);\n+        assertEquals(e.getClass(), ServiceConfigurationError.class);\n+        assertEquals(e.getCause().getClass(), InvocationTargetException.class);\n+        assertEquals(e.getCause().getCause().getMessage(), \"throwing constructor\");\n+    }\n+\n+    private void testBadData() {\n+        var cn = \"DoesNotExist\";\n+        assertEquals(System.getProperty(PROPERTY_KEY), cn);\n+\n+        var e = expectThrows(ServiceConfigurationError.class, HttpServerProvider::provider);\n+        assertEquals(e.getClass(), ServiceConfigurationError.class);\n+        assertEquals(e.getCause().getClass(), ClassNotFoundException.class);\n+    }\n+\n+    \/**\n+     * Test provider that is public (P)\n+     *\/\n+    public static class ProviderP extends HttpServerProvider {\n+        public ProviderP() { super(); }\n+        @Override\n+        public HttpServer createHttpServer(InetSocketAddress addr, int backlog) { return null; }\n+        @Override\n+        public HttpsServer createHttpsServer(InetSocketAddress addr, int backlog) { return null; }\n+    }\n+\n+    \/**\n+     * Test provider that is public with a non-public constructor (PNPC)\n+     *\/\n+    public static class ProviderPNPC extends HttpServerProvider {\n+        \/*package-private*\/ ProviderPNPC() { super(); }\n+        @Override\n+        public HttpServer createHttpServer(InetSocketAddress addr, int backlog) { return null; }\n+        @Override\n+        public HttpsServer createHttpsServer(InetSocketAddress addr, int backlog) { return null; }\n+    }\n+\n+    \/**\n+     * Test provider that is not public (NP)\n+     *\/\n+    \/*package-private*\/ static class ProviderNP extends HttpServerProvider {\n+        \/*package-private*\/ ProviderNP() { super(); }\n+        @Override\n+        public HttpServer createHttpServer(InetSocketAddress addr, int backlog) { return null; }\n+        @Override\n+        public HttpsServer createHttpsServer(InetSocketAddress addr, int backlog) { return null; }\n+    }\n+\n+    \/**\n+     * Test provider with a constructor that throws\n+     *\/\n+    public static class ProviderT extends HttpServerProvider {\n+        public ProviderT() { throw new AssertionError(\"throwing constructor\"); }\n+        @Override\n+        public HttpServer createHttpServer(InetSocketAddress addr, int backlog) { return null; }\n+        @Override\n+        public HttpsServer createHttpsServer(InetSocketAddress addr, int backlog) { return null; }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HttpServerProviderTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl Test1\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test1.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8269481\n+ * @summary Tests that file descriptors are closed\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm CloseDescriptors\n+ *\/\n+\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import com.sun.nio.sctp.MessageInfo;\n+import com.sun.nio.sctp.SctpMultiChannel;\n+\n+public class CloseDescriptors {\n+\n+    private static final int NUM      = 5;\n+    private static final int SIZE     = 1024;\n+    private static final int MAX_DESC = 3;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Util.isSCTPSupported()) {\n+            System.out.println(\"SCTP protocol is not supported\");\n+            System.out.println(\"Test cannot be run\");\n+            return;\n+        }\n+\n+        List<String> lsofDirs = List.of(\"\/usr\/bin\", \"\/usr\/sbin\");\n+        Optional<Path> lsof = lsofDirs.stream()\n+                .map(s -> Path.of(s, \"lsof\"))\n+                .filter(f -> Files.isExecutable(f))\n+                .findFirst();\n+        if (!lsof.isPresent()) {\n+            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n+            System.out.println(\"Test cannot be run\");\n+            return;\n+        }\n+\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            int port = ss.getLocalPort();\n+\n+            Thread server = new Server(port);\n+            server.start();\n+            Thread.sleep(100); \/\/ wait for server to be ready\n+\n+            System.out.println(\"begin\");\n+            for (int i = 0; i < 5; ++i) {\n+                System.out.println(i);\n+                doIt(port);\n+                Thread.sleep(100);\n+            }\n+            System.out.println(\"end\");\n+            server.join();\n+        }\n+\n+        long pid = ProcessHandle.current().pid();\n+        ProcessBuilder pb = new ProcessBuilder(\n+                lsof.get().toString(), \"-U\", \"-a\", \"-p\", Long.toString(pid));\n+        Process p = pb.start();\n+        Object[] lines = p.inputReader().lines().toArray();\n+        p.waitFor();\n+\n+        int nfds = lines.length - 1;\n+        if (nfds > MAX_DESC) {\n+            throw new RuntimeException(\"Number of open descriptors \" +\n+                nfds + \" > \" + MAX_DESC);\n+        }\n+    }\n+\n+    static void doIt(int port) throws Exception {\n+        InetSocketAddress sa = new InetSocketAddress(\"localhost\", port);\n+\n+        for (int i = 0; i < NUM; ++i) {\n+            System.out.println(\"  \" + i);\n+            SctpMultiChannel channel = SctpMultiChannel.open();\n+            channel.configureBlocking(true);\n+            MessageInfo info = MessageInfo.createOutgoing(sa, 0);\n+            ByteBuffer buffer = ByteBuffer.allocateDirect(SIZE);\n+            channel.send(buffer, info);\n+            channel.close();\n+\n+            Thread.sleep(200);\n+        }\n+    }\n+\n+    static class Server extends Thread {\n+        int port;\n+\n+        Server(int port) {\n+            this.port = port;\n+        }\n+\n+        @Override\n+        public void run() {\n+            for (int i = 0; i < NUM; i++) {\n+                try {\n+                    SctpMultiChannel sm = SctpMultiChannel.open();\n+                    InetSocketAddress sa =\n+                        new InetSocketAddress(\"localhost\", port);\n+                    sm.bind(sa);\n+                    ByteBuffer buffer = ByteBuffer.allocateDirect(SIZE);\n+                    MessageInfo info = sm.receive(buffer, null, null);\n+                    sm.close();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/CloseDescriptors.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @summary Verifies the client property xawt.mwm_decor_title for Linux.\n+ *          Note: the test requires GNOME Shell window manager and will automatically\n+ *          pass with any other WM.\n+ * @requires (os.family == \"linux\")\n+ * @run main WindowTitleVisibleTestLinuxGnome\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.*;\n+import java.nio.charset.StandardCharsets;\n+import java.io.File;\n+import javax.imageio.*;\n+\n+public class WindowTitleVisibleTestLinuxGnome\n+{\n+    private static WindowTitleVisibleTestLinuxGnome theTest;\n+\n+    private Robot robot;\n+\n+    private JFrame frame;\n+    private JRootPane rootPane;\n+\n+    private Rectangle titleBarBounds;\n+    private BufferedImage titleBarImageVisible;\n+    private BufferedImage titleBarImageNotVisible;\n+\n+    private int DELAY = 1000;\n+\n+    public WindowTitleVisibleTestLinuxGnome() {\n+        try {\n+            robot = new Robot();\n+        } catch (AWTException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void performTest() {\n+        constructAndShowFrame();\n+\n+        robot.delay(DELAY);\n+\n+        Insets insets = frame.getInsets();\n+        Rectangle bounds = frame.getBounds();\n+        titleBarBounds = new Rectangle(bounds.x, bounds.y, bounds.width, insets.top);\n+        captureTitleBarVisible();\n+\n+        robot.delay(DELAY);\n+\n+        hideTitleBar();\n+\n+        robot.delay(DELAY);\n+\n+        captureTitleBarNotVisible();\n+\n+        if (imagesEqual(titleBarImageVisible, titleBarImageNotVisible)) {\n+            throw new RuntimeException(\"Test failed: title bars shown and hidden are the same.\");\n+        }\n+\n+        runSwing(() -> frame.dispose());\n+\n+        frame = null;\n+        rootPane = null;\n+    }\n+\n+    private static boolean imagesEqual(BufferedImage img1, BufferedImage img2) {\n+        for (int px = 0; px < img1.getWidth(); px++) {\n+            for (int py = 0; py < img1.getHeight(); py++) {\n+                int rgb1 = img1.getRGB(px, py);\n+                int rgb2 = img2.getRGB(px, py);\n+                if (rgb1 != rgb2) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private void captureTitleBarNotVisible() {\n+        titleBarImageNotVisible = robot.createScreenCapture(titleBarBounds);\n+    }\n+\n+    private void hideTitleBar() {\n+        runSwing( () -> {\n+            rootPane.putClientProperty(\"xawt.mwm_decor_title\", false);\n+            frame.setVisible(false);\n+            frame.setVisible(true);\n+        });\n+    }\n+\n+    private void captureTitleBarVisible() {\n+        titleBarImageVisible = robot.createScreenCapture(titleBarBounds);\n+    }\n+\n+    private void constructAndShowFrame() {\n+        runSwing(() -> {\n+            frame = new JFrame(\"IIIIIIIIIIIIIIII\");\n+            frame.setBounds(100, 100, 300, 150);\n+            rootPane = frame.getRootPane();\n+            rootPane.putClientProperty(\"xawt.mwm_decor_title\", true);\n+            JComponent contentPane = (JComponent) frame.getContentPane();\n+            JPanel comp = new JPanel();\n+            contentPane.add(comp);\n+            comp.setBackground(Color.RED);\n+            frame.setVisible(true);\n+        });\n+    }\n+\n+    public void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    private static void runSwing(Runnable r) {\n+        try {\n+            SwingUtilities.invokeAndWait(r);\n+        } catch (InterruptedException e) {\n+        } catch (InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String getWindowManagerID() {\n+        String WMID = null;\n+        try {\n+            Process p = new ProcessBuilder(\"xprop\", \"-root\", \"_NET_SUPPORTING_WM_CHECK\").start();\n+            System.out.println( new String(p.getErrorStream().readAllBytes(), StandardCharsets.UTF_8) );\n+            String stdout = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n+            final String windowID = stdout.substring(stdout.lastIndexOf(\" \")).strip();\n+\n+            p = new ProcessBuilder(\"xprop\", \"-id\", windowID, \"_NET_WM_NAME\").start();\n+            System.out.println( new String(p.getErrorStream().readAllBytes(), StandardCharsets.UTF_8) );\n+            stdout = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n+            WMID = stdout.substring(stdout.lastIndexOf(\"=\")).strip();\n+            System.out.println(\"WM name: \" + WMID);\n+        }\n+        catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        return WMID;\n+    }\n+\n+    public static void main(String[] args) {\n+        final String WMID = getWindowManagerID();\n+        if (WMID == null) {\n+            System.out.println(\"Failed to determine Window Manager. The test will not run and is considered passed.\");\n+            return;\n+        } else if (!WMID.toLowerCase().contains(\"gnome\")) {\n+            System.out.println(\"Window Manager \" + WMID + \" is not supported, only GNOME is. The test will not run and is considered passed.\");\n+            return;\n+        }\n+\n+        try {\n+            runSwing(() -> theTest = new WindowTitleVisibleTestLinuxGnome());\n+            theTest.performTest();\n+        } finally {\n+            if (theTest != null) {\n+                runSwing(() -> theTest.dispose());\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Window\/WindowTitleVisibleTest\/WindowTitleVisibleTestLinuxGnome.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -101,1 +101,1 @@\n-       \"For On Top tests all windows should stay behind the owner window.\\n\" +\n+       \"For On Top tests all windows should stay behind the print dialog \\n\" +\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/DialogOwnerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8262731\n+   @key headful printer\n+   @summary Verify that \"PrinterJob.print\" throws the expected exception,\n+            if \"Printable.print\" throws an exception.\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN PE\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN RE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT PE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT RE\n+ *\/\n+\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.SwingUtilities;\n+\n+public class ExceptionFromPrintableIsIgnoredTest {\n+    private enum TestThreadType {MAIN, EDT}\n+    private enum TestExceptionType {PE, RE}\n+\n+    private volatile Throwable printError;\n+\n+    public static void main(String[] args) {\n+        if (args.length < 2) {\n+            throw new RuntimeException(\"Two arguments are expected:\"\n+                    + \" test thread type and test exception type.\");\n+        }\n+\n+        new ExceptionFromPrintableIsIgnoredTest(\n+            TestThreadType.valueOf(args[0]),\n+            TestExceptionType.valueOf(args[1]));\n+    }\n+\n+    public ExceptionFromPrintableIsIgnoredTest(\n+            final TestThreadType threadType,\n+            final TestExceptionType exceptionType) {\n+        System.out.println(String.format(\n+                \"Test started. threadType='%s', exceptionType='%s'\",\n+                threadType, exceptionType));\n+\n+        String osName = System.getProperty(\"os.name\");\n+        boolean isOSX = osName.toLowerCase().startsWith(\"mac\");\n+        if ((exceptionType == TestExceptionType.RE) && !isOSX) {\n+            System.out.println(\n+                \"Currently this test scenario can be verified only on macOS.\");\n+            return;\n+        }\n+\n+        printError = null;\n+\n+        if (threadType == TestThreadType.MAIN) {\n+            runTest(exceptionType);\n+        } else if (threadType == TestThreadType.EDT) {\n+            try {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        runTest(exceptionType);\n+                    }\n+                });\n+            } catch (InterruptedException | InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        if (printError == null) {\n+            throw new RuntimeException(\"No exception was thrown.\");\n+        } else if (!(printError instanceof PrinterException)) {\n+            throw new RuntimeException(\"Unexpected exception was thrown.\");\n+        }\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    private void runTest(final TestExceptionType exceptionType) {\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        if (job.getPrintService() == null) {\n+            System.out.println(\"No printers are available.\");\n+            return;\n+        }\n+\n+        job.setPrintable(new Printable() {\n+            @Override\n+            public int print(Graphics graphics, PageFormat pageFormat,\n+                    int pageIndex) throws PrinterException {\n+                if (pageIndex > 1) {\n+                    return NO_SUCH_PAGE;\n+                }\n+                if (exceptionType == TestExceptionType.PE) {\n+                    throw new PrinterException(\n+                        \"Exception from 'Printable.print'.\");\n+                } else if (exceptionType == TestExceptionType.RE) {\n+                    throw new RuntimeException(\n+                        \"Exception from 'Printable.print'.\");\n+                }\n+                return PAGE_EXISTS;\n+            }\n+        });\n+\n+        try {\n+            job.print();\n+        } catch (Throwable t) {\n+            printError = t;\n+\n+            System.out.println(\"'PrinterJob.print' threw the exception:\");\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/ExceptionFromPrintableIsIgnoredTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4847239\n+ * @summary Verify directory parameter behavior in File.createTempFile(String,String,File)\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryPermission;\n+import java.nio.file.attribute.AclFileAttributeView;\n+import java.nio.file.attribute.PosixFileAttributeView;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class TargetDirectory {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Target directory exists and is writable\n+        Path dir = Path.of(\"target\");\n+        File target = Files.createDirectory(dir).toFile();\n+        File tmp = File.createTempFile(\"passes\", null, target);\n+        if (!Files.exists(tmp.toPath())) {\n+            throw new RuntimeException(\"Temp file not created\");\n+        }\n+        tmp.delete();\n+\n+        \/\/ Make target directory read-only\n+        if (Files.getFileStore(dir).supportsFileAttributeView(\"posix\")) {\n+            PosixFileAttributeView view =\n+                Files.getFileAttributeView(dir, PosixFileAttributeView.class);\n+            Set<PosixFilePermission> perms = new HashSet<>();\n+            perms.add(PosixFilePermission.valueOf(\"OWNER_READ\"));\n+            view.setPermissions(perms);\n+        } else if (Files.getFileStore(dir).supportsFileAttributeView(\"acl\")) {\n+            AclFileAttributeView view = Files.getFileAttributeView(dir,\n+                AclFileAttributeView.class);\n+            List<AclEntry> entries = new ArrayList<>();\n+            for (AclEntry entry : view.getAcl()) {\n+                Set<AclEntryPermission> perms =\n+                    new HashSet<>(entry.permissions());\n+                perms.remove(AclEntryPermission.ADD_FILE);\n+                entries.add(AclEntry.newBuilder().setType(entry.type())\n+                    .setPrincipal(entry.principal()).setPermissions(perms)\n+                    .build());\n+            }\n+            view.setAcl(entries);\n+        } else {\n+            throw new RuntimeException(\"Required attribute view not supported\");\n+        }\n+\n+        \/\/ Target directory exists but is read-only\n+        try {\n+            File.createTempFile(\"readonly\", null, target);\n+            throw new RuntimeException(\"Exception not thrown for read-only target directory\");\n+        } catch (IOException expected) {\n+        } finally {\n+            target.delete();\n+        }\n+\n+        \/\/ Target directory does not exist\n+        try {\n+            File.createTempFile(\"nonexistent\", null, new File(\"void\"));\n+            throw new RuntimeException(\"Exception not thrown for non-existent target directory\");\n+        } catch (IOException expected) {\n+        }\n+\n+        \/\/ Target is a file, not a directory\n+        target = Files.createFile(Path.of(\"file\")).toFile();\n+        try {\n+            File.createTempFile(\"file\", null, target);\n+            throw new RuntimeException(\"Exception not thrown for file target\");\n+        } catch (IOException expected) {\n+        } finally {\n+            target.delete();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/File\/createTempFile\/TargetDirectory.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class1 loads a native library that calls ClassLoader.findClass in JNI_OnLoad.\n+ * Class1 runs concurrently with another thread that opens a signed jar file.\n+ *\/\n+class Class1 {\n+    static {\n+        System.loadLibrary(\"loadLibraryDeadlock\");\n+        System.out.println(\"Signed jar loaded from native library.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/Class1.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryDeadlock class triggers the deadlock between the two\n+ * lock objects - ZipFile object and ClassLoader.loadedLibraryNames hashmap.\n+ * Thread #2 loads a signed jar which leads to acquiring the lock objects in\n+ * natural order (ZipFile then HashMap) - loading a signed jar may involve\n+ * Providers initialization. Providers may load native libraries.\n+ * Thread #1 acquires the locks in reverse order, first entering loadLibrary\n+ * called from Class1, then acquiring ZipFile during the search for a class\n+ * triggered from JNI.\n+ *\/\n+import java.lang.*;\n+\n+public class LoadLibraryDeadlock {\n+\n+    public static void main(String[] args) {\n+        Thread t1 = new Thread() {\n+            public void run() {\n+                try {\n+                    \/\/ an instance of unsigned class that loads a native library\n+                    Class<?> c1 = Class.forName(\"Class1\");\n+                    Object o = c1.newInstance();\n+                } catch (ClassNotFoundException |\n+                         InstantiationException |\n+                         IllegalAccessException e) {\n+                    System.out.println(\"Class Class1 not found.\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        Thread t2 = new Thread() {\n+            public void run() {\n+                try {\n+                    \/\/ load a class from a signed jar, which locks the JarFile\n+                    Class<?> c2 = Class.forName(\"p.Class2\");\n+                    System.out.println(\"Signed jar loaded.\");\n+                } catch (ClassNotFoundException e) {\n+                    System.out.println(\"Class Class2 not found.\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        t2.start();\n+        t1.start();\n+        try {\n+            t1.join();\n+            t2.join();\n+        } catch (InterruptedException ignore) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/LoadLibraryDeadlock.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Checks if there's no deadlock between the two lock objects -\n+ *          class loading lock and ClassLoader.loadedLibraryNames hashmap.\n+ * @library \/test\/lib\n+ * @build LoadLibraryDeadlock Class1 p.Class2\n+ * @run main\/othervm\/native -Xcheck:jni TestLoadLibraryDeadlock\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.*;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.lang.ProcessBuilder;\n+import java.lang.Process;\n+import java.nio.file.Paths;\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.spi.ToolProvider;\n+\n+public class TestLoadLibraryDeadlock {\n+\n+    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n+\n+    private static final String KEYSTORE = \"keystore.jks\";\n+    private static final String STOREPASS = \"changeit\";\n+    private static final String KEYPASS = \"changeit\";\n+    private static final String ALIAS = \"test\";\n+    private static final String DNAME = \"CN=test\";\n+    private static final String VALIDITY = \"366\";\n+\n+    private static String testClassPath = System.getProperty(\"test.classes\");\n+    private static String testLibraryPath = System.getProperty(\"test.nativepath\");\n+    private static String classPathSeparator = System.getProperty(\"path.separator\");\n+\n+    private static OutputAnalyzer runCommand(File workingDirectory, String... commands) throws Throwable {\n+        ProcessBuilder pb = new ProcessBuilder(commands);\n+        pb.directory(workingDirectory);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return ProcessTools.executeProcess(pb);\n+    }\n+\n+    private static OutputAnalyzer runCommandInTestClassPath(String... commands) throws Throwable {\n+        return runCommand(new File(testClassPath), commands);\n+    }\n+\n+    private static OutputAnalyzer genKey() throws Throwable {\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, KEYSTORE));\n+        String keytool = JDKToolFinder.getJDKTool(\"keytool\");\n+        return runCommandInTestClassPath(keytool,\n+                \"-storepass\", STOREPASS,\n+                \"-keypass\", KEYPASS,\n+                \"-keystore\", KEYSTORE,\n+                \"-keyalg\", \"rsa\", \"-keysize\", \"2048\",\n+                \"-genkeypair\",\n+                \"-alias\", ALIAS,\n+                \"-dname\", DNAME,\n+                \"-validity\", VALIDITY\n+        );\n+    }\n+\n+    private static void createJar(String outputJar, String... classes) throws Throwable {\n+        List<String> args = new ArrayList<>();\n+        Collections.addAll(args, \"cvf\", Paths.get(testClassPath, outputJar).toString());\n+        for (String c : classes) {\n+            Collections.addAll(args, \"-C\", testClassPath, c);\n+        }\n+        if (JAR.run(System.out, System.err, args.toArray(new String[0])) != 0) {\n+            throw new RuntimeException(\"jar operation failed\");\n+        }\n+    }\n+\n+    private static OutputAnalyzer signJar(String jarToSign) throws Throwable {\n+        String jarsigner = JDKToolFinder.getJDKTool(\"jarsigner\");\n+        return runCommandInTestClassPath(jarsigner,\n+                \"-keystore\", KEYSTORE,\n+                \"-storepass\", STOREPASS,\n+                jarToSign, ALIAS\n+        );\n+    }\n+\n+    private static Process runJavaCommand(String... command) throws Throwable {\n+        String java = JDKToolFinder.getJDKTool(\"java\");\n+        List<String> commands = new ArrayList<>();\n+        Collections.addAll(commands, java);\n+        Collections.addAll(commands, command);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return new ProcessBuilder(commands.toArray(new String[0]))\n+                .redirectErrorStream(true)\n+                .directory(new File(testClassPath))\n+                .start();\n+    }\n+\n+    private static OutputAnalyzer jcmd(long pid, String command) throws Throwable {\n+        String jcmd = JDKToolFinder.getJDKTool(\"jcmd\");\n+        return runCommandInTestClassPath(jcmd,\n+                String.valueOf(pid),\n+                command\n+        );\n+    }\n+\n+    private static String readAvailable(final InputStream is) throws Throwable {\n+        final List<String> list = Collections.synchronizedList(new ArrayList<String>());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        Future<String> future = executor.submit(new Callable<String>() {\n+            public String call() {\n+                String result = new String();\n+                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n+                try {\n+                    while(true) {\n+                        String s = reader.readLine();\n+                        if (s.length() > 0) {\n+                            list.add(s);\n+                            result += s + \"\\n\";\n+                        }\n+                    }\n+                } catch (IOException ignore) {}\n+                return result;\n+            }\n+        });\n+        try {\n+            return future.get(1000, TimeUnit.MILLISECONDS);\n+        } catch (Exception ignoreAll) {\n+            future.cancel(true);\n+            return String.join(\"\\n\", list);\n+        }\n+    }\n+\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        genKey()\n+                .shouldHaveExitValue(0);\n+\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"a.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"b.jar\"));\n+        FileUtils.deleteFileIfExistsWithRetry(\n+                Paths.get(testClassPath, \"c.jar\"));\n+\n+        createJar(\"a.jar\",\n+                \"LoadLibraryDeadlock.class\",\n+                \"LoadLibraryDeadlock$1.class\",\n+                \"LoadLibraryDeadlock$2.class\");\n+\n+        createJar(\"b.jar\",\n+                \"Class1.class\");\n+\n+        createJar(\"c.jar\",\n+                \"p\/Class2.class\");\n+\n+        signJar(\"c.jar\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ load trigger class\n+        Process process = runJavaCommand(\"-cp\",\n+                \"a.jar\" + classPathSeparator +\n+                \"b.jar\" + classPathSeparator +\n+                \"c.jar\",\n+                \"-Djava.library.path=\" + testLibraryPath,\n+                \"LoadLibraryDeadlock\");\n+\n+        \/\/ wait for a while to grab some output\n+        process.waitFor(5, TimeUnit.SECONDS);\n+\n+        \/\/ dump available output\n+        String output = readAvailable(process.getInputStream());\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(output);\n+        dump(outputAnalyzer);\n+\n+        \/\/ if the process is still running, get the thread dump\n+        OutputAnalyzer outputAnalyzerJcmd = jcmd(process.pid(), \"Thread.print\");\n+        dump(outputAnalyzerJcmd);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Java-level deadlock\") == 0,\n+                \"Found a deadlock.\");\n+\n+        \/\/ if no deadlock, make sure all components have been loaded\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class1 not found.\") == 0,\n+                \"Unable to load class. Class1 not found.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Class Class2 not found.\") == 0,\n+                \"Unable to load class. Class2 not found.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded.\") > 0,\n+                \"Unable to load native library.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded.\") > 0,\n+                \"Unable to load signed jar.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Signed jar loaded from native library.\") > 0,\n+                \"Unable to load signed jar from native library.\");\n+\n+        if (!process.waitFor(5, TimeUnit.SECONDS)) {\n+            \/\/ if the process is still frozen, fail the test even though\n+            \/\/ the \"deadlock\" text hasn't been found\n+            process.destroyForcibly();\n+            Asserts.assertTrue(process.waitFor() == 0,\n+                    \"Process frozen.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/TestLoadLibraryDeadlock.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+\/*\n+ * Native library that loads an arbitrary class from a (signed) jar.\n+ * This triggers the search in jars, and the lock in ZipFile is acquired\n+ * as a result.\n+ *\/\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    printf(\"Native library loaded.\\n\");\n+    fflush(stdout);\n+\n+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+        return JNI_EVERSION; \/* JNI version not supported *\/\n+    }\n+\n+    \/\/ find any class which triggers the search in jars\n+    cl = (*env)->FindClass(env, \"p\/Class2\");\n+\n+    return JNI_VERSION_1_2;\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/libloadLibraryDeadlock.c","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class2 is loaded from Thread #2 that checks jar signature and from\n+ * Thread #1 that loads a native library.\n+ *\/\n+package p;\n+\n+class Class2 {}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryDeadlock\/p\/Class2.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnload class calls ClassLoader.loadedLibrary from multiple threads\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Loads a native library from multiple class loaders and multiple\n+ *          threads. This creates a race for loading the library. The winner\n+ *          loads the library in two threads. All threads except two would fail\n+ *          with UnsatisfiedLinkError when the class being loaded is already\n+ *          loaded in a different class loader that won the race. The test\n+ *          checks that the loaded class is GC'ed, that means the class loader\n+ *          is GC'ed and the native library is unloaded.\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnload\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.util.ForceGC;\n+import java.lang.*;\n+import java.lang.reflect.*;\n+import java.lang.ref.WeakReference;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import p.Class1;\n+\n+public class LoadLibraryUnload {\n+\n+    private static class TestLoader extends URLClassLoader {\n+        public TestLoader() throws Exception {\n+            super(new URL[] { Path.of(System.getProperty(\"test.classes\")).toUri().toURL() });\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                Class<?> clazz = findLoadedClass(name);\n+                if (clazz == null) {\n+                    try {\n+                        clazz = findClass(name);\n+                    } catch (ClassNotFoundException ignore) {\n+                    }\n+                    if (clazz == null) {\n+                        clazz = super.loadClass(name);\n+                    }\n+                }\n+                return clazz;\n+            }\n+        }\n+    }\n+\n+    private static class LoadLibraryFromClass implements Runnable {\n+        Object object;\n+        Method method;\n+\n+        public LoadLibraryFromClass(Class<?> fromClass) {\n+            try {\n+                this.object = fromClass.newInstance();\n+                this.method = fromClass.getDeclaredMethod(\"loadLibrary\");\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                method.invoke(object);\n+            } catch (ReflectiveOperationException roe) {\n+                throw new RuntimeException(roe);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Class<?> clazz = null;\n+        List<Thread> threads = new ArrayList<>();\n+\n+        for (int i = 0 ; i < 5 ; i++) {\n+            \/\/ 5 loaders and 10 threads in total.\n+            \/\/ winner loads the library in 2 threads\n+            clazz = new TestLoader().loadClass(\"p.Class1\");\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+            threads.add(new Thread(new LoadLibraryFromClass(clazz)));\n+        }\n+\n+        final Set<Throwable> exceptions = ConcurrentHashMap.newKeySet();\n+        threads.forEach( t -> {\n+            t.setUncaughtExceptionHandler((th, ex) -> {\n+                \/\/ collect the root cause of each failure\n+                Throwable rootCause = ex;\n+                while((ex = ex.getCause()) != null) {\n+                    rootCause = ex;\n+                }\n+                exceptions.add(rootCause);\n+            });\n+            t.start();\n+        });\n+\n+        \/\/ wait for all threads to finish\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        \/\/ expect all errors to be UnsatisfiedLinkError\n+        boolean allAreUnsatisfiedLinkError = exceptions\n+                .stream()\n+                .map(e -> e instanceof UnsatisfiedLinkError)\n+                .reduce(true, (i, a) -> i && a);\n+\n+        \/\/ expect exactly 8 errors\n+        Asserts.assertTrue(exceptions.size() == 8,\n+                \"Expected to see 8 failing threads\");\n+\n+        Asserts.assertTrue(allAreUnsatisfiedLinkError,\n+                \"All errors have to be UnsatisfiedLinkError\");\n+\n+        WeakReference<Class<?>> wClass = new WeakReference<>(clazz);\n+\n+        \/\/ release strong refs\n+        clazz = null;\n+        threads = null;\n+        exceptions.clear();\n+        ForceGC gc = new ForceGC();\n+        if (!gc.await(() -> wClass.refersTo(null))) {\n+            throw new RuntimeException(\"Class1 hasn't been GC'ed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnload.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * LoadLibraryUnloadTest ensures all objects (NativeLibrary) are deallocated\n+ * when loaded in concurrent mode.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8266310\n+ * @summary Checks that JNI_OnLoad is invoked only once when multiple threads\n+ *          call System.loadLibrary concurrently, and JNI_OnUnload is invoked\n+ *          when the native library is loaded from a custom class loader.\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnload p.Class1\n+ * @run main\/othervm\/native -Xcheck:jni LoadLibraryUnloadTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.*;\n+\n+import java.lang.ProcessBuilder;\n+import java.lang.Process;\n+import java.io.File;\n+import java.util.*;\n+\n+public class LoadLibraryUnloadTest {\n+\n+    private static String testClassPath = System.getProperty(\"test.classes\");\n+    private static String testLibraryPath = System.getProperty(\"test.nativepath\");\n+    private static String classPathSeparator = System.getProperty(\"path.separator\");\n+\n+    private static Process runJavaCommand(String... command) throws Throwable {\n+        String java = JDKToolFinder.getJDKTool(\"java\");\n+        List<String> commands = new ArrayList<>();\n+        Collections.addAll(commands, java);\n+        Collections.addAll(commands, command);\n+        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n+        return new ProcessBuilder(commands.toArray(new String[0]))\n+                .redirectErrorStream(true)\n+                .directory(new File(testClassPath))\n+                .start();\n+    }\n+\n+    private final static long countLines(OutputAnalyzer output, String string) {\n+        return output.asLines()\n+                     .stream()\n+                     .filter(s -> s.contains(string))\n+                     .count();\n+    }\n+\n+    private final static void dump(OutputAnalyzer output) {\n+        output.asLines()\n+              .stream()\n+              .forEach(s -> System.out.println(s));\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        Process process = runJavaCommand(\n+                \"-Dtest.classes=\" + testClassPath,\n+                \"-Djava.library.path=\" + testLibraryPath,\n+                \"LoadLibraryUnload\");\n+\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+        dump(outputAnalyzer);\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library loaded from Class1.\") == 2,\n+                \"Native library expected to be loaded in 2 threads.\");\n+\n+        long refCount = countLines(outputAnalyzer, \"Native library loaded.\");\n+\n+        Asserts.assertTrue(refCount > 0, \"Failed to load native library.\");\n+\n+        System.out.println(\"Native library loaded in \" + refCount + \" threads\");\n+\n+        Asserts.assertTrue(refCount == 1, \"Native library is loaded more than once.\");\n+\n+        Asserts.assertTrue(\n+                countLines(outputAnalyzer, \"Native library unloaded.\") == refCount,\n+                \"Failed to unload native library\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    JNIEnv *env;\n+\n+    printf(\"Native library loaded.\\n\");\n+    fflush(stdout);\n+\n+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK) {\n+        return JNI_EVERSION; \/* JNI version not supported *\/\n+    }\n+\n+    return JNI_VERSION_1_2;\n+}\n+\n+JNIEXPORT void JNICALL\n+JNI_OnUnload(JavaVM *vm, void *reserved) {\n+\n+    printf(\"Native library unloaded.\\n\");\n+    fflush(stdout);\n+}\n+\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/libloadLibraryUnload.c","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Class1 loads a native library.\n+ *\/\n+package p;\n+\n+public class Class1 {\n+\n+    public Class1() {\n+    }\n+\n+    \/\/ method called from java threads\n+    public void loadLibrary() throws Exception {\n+        System.loadLibrary(\"loadLibraryUnload\");\n+        System.out.println(\"Native library loaded from Class1.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/p\/Class1.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,8 @@\n-import java.util.function.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.DoubleUnaryOperator;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.LongUnaryOperator;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.DoubleStream;\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n@@ -28,1 +35,1 @@\n- * @bug 8241374\n+ * @bug 6506405 8241374\n@@ -30,0 +37,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -32,0 +40,30 @@\n+    private static final double GELFOND = Math.exp(Math.PI);\n+    private static final double TAU     = 2.0*Math.PI;\n+\n+    \/\/ Values for testing float and double abs\n+    private static final double[] FLOATING_POINT_VALUES = new double[] {\n+        0.0,\n+        -0.0,\n+        +0.0,\n+        Double.MIN_VALUE,\n+        Double.MIN_NORMAL,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Float.MIN_VALUE,\n+        Float.MIN_NORMAL,\n+        Float.NEGATIVE_INFINITY,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+        Double.longBitsToDouble((1 << DoubleConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+        DoubleConsts.MAG_BIT_MASK >>> 1,\n+        Float.intBitsToFloat((1 << FloatConsts.SIGNIFICAND_WIDTH) |\n+           ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1)),\n+        FloatConsts.MAG_BIT_MASK >>> 1,\n+        Math.E,\n+        GELFOND,\n+        Math.PI,\n+        TAU\n+    };\n+\n@@ -39,0 +77,2 @@\n+        errors += testFloatAbs();\n+        errors += testDoubleAbs();\n@@ -45,0 +85,2 @@\n+    \/\/ --------------------------------------------------------------------\n+\n@@ -146,0 +188,61 @@\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testFloatAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.mapToObj(d -> (float)d).\n+            forEach(f -> {errors.addAndGet(testFloatAbs(f));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testFloatAbs(float f) {\n+        int errors  = testFloatAbs(\"Math.abs\", Math::abs, f);\n+        errors     += testFloatAbs(\"Math.abs\", Math::abs, -f);\n+        errors     += testFloatAbs(\"StrictMath.abs\", StrictMath::abs, f);\n+        errors     += testFloatAbs(\"StrictMath.abs\", StrictMath::abs, -f);\n+        return errors;\n+    }\n+\n+    private static int testFloatAbs(String testName,\n+                                    UnaryOperator<Float> absFunc, float f) {\n+        float result = absFunc.apply(-f);\n+        if (Float.isNaN(f) && Float.isNaN(result)) {\n+            return 0;\n+        }\n+\n+        float expected = f == -0.0F ? 0.0F : (f < 0.0F ? -f : f);\n+        return Tests.test(testName, f, result, expected);\n+    }\n+\n+    \/\/ --------------------------------------------------------------------\n+\n+    private static int testDoubleAbs() {\n+        DoubleStream doubles = DoubleStream.of(FLOATING_POINT_VALUES);\n+\n+        final AtomicInteger errors = new AtomicInteger();\n+        doubles.forEach(d -> {errors.addAndGet(testDoubleAbs(d));});\n+\n+        return errors.get();\n+    }\n+\n+    private static int testDoubleAbs(double d) {\n+        int errors  = testDoubleAbs(\"Math.abs\", Math::abs, d);\n+        errors     += testDoubleAbs(\"Math.abs\", Math::abs, -d);\n+        errors     += testDoubleAbs(\"StrictMath.abs\", StrictMath::abs, d);\n+        errors     += testDoubleAbs(\"StrictMath.abs\", StrictMath::abs, -d);\n+        return errors;\n+    }\n+\n+    private static int testDoubleAbs(String testName,\n+                                     DoubleUnaryOperator absFunc, double d) {\n+        double result = absFunc.applyAsDouble(-d);\n+        if (Double.isNaN(d) && Double.isNaN(result)) {\n+            return 0;\n+        }\n+\n+        double expected = d == -0.0F ? 0.0F : (d < 0.0F ? -d : d);\n+        return Tests.test(testName, d, result, expected);\n+    }\n","filename":"test\/jdk\/java\/lang\/Math\/AbsTests.java","additions":106,"deletions":3,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @bug 6708398\n+ * @bug 6708398 8075806\n@@ -59,2 +59,3 @@\n-     * Test Math.addExact, multiplyExact, subtractExact, incrementExact,\n-     * decrementExact, negateExact methods with {@code int} arguments.\n+     * Test Math.addExact, multiplyExact, divideExact, subtractExact,\n+     * incrementExact, decrementExact, negateExact methods with\n+     * {@code int} arguments.\n@@ -135,0 +136,33 @@\n+        boolean exceptionExpected = false;\n+        try {\n+            \/\/ Test divideExact\n+            BigInteger q = null;\n+            try {\n+                q = BigInteger.valueOf(x).divide(BigInteger.valueOf(y));\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            int quotient = 0;\n+            if (q != null) {\n+                try {\n+                    quotient = q.intValueExact();\n+                } catch (ArithmeticException e) {\n+                    exceptionExpected = true;\n+                }\n+            }\n+            int z = Math.divideExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != quotient) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + quotient);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: int Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n@@ -185,2 +219,3 @@\n-     * Test Math.addExact, multiplyExact, subtractExact, incrementExact,\n-     * decrementExact, negateExact, toIntExact methods with {@code long} arguments.\n+     * Test Math.addExact, multiplyExact, divideExact, subtractExact,\n+     * incrementExact, decrementExact, negateExact, toIntExact methods\n+     * with {@code long} arguments.\n@@ -272,0 +307,20 @@\n+        try {\n+            \/\/ Test divideExact\n+            resultBig = null;\n+            try {\n+                resultBig = xBig.divide(yBig);\n+            } catch (ArithmeticException ex) {\n+            }\n+            long quotient = Math.divideExact(x, y);\n+            if (resultBig == null) {\n+                fail(\"FAIL: long Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            checkResult(\"long Math.divideExact\", x, y, quotient, resultBig);\n+        } catch (ArithmeticException ex) {\n+            if (resultBig != null && inLongRange(resultBig)) {\n+                fail(\"FAIL: long Math.divideExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/lang\/Math\/ExactArithTests.java","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 5100935\n+ * @bug 5100935 8188044\n@@ -35,0 +35,1 @@\n+import java.util.function.BiFunction;\n@@ -52,4 +53,19 @@\n-    \/\/ Check Math.multiplyHigh(x,y) against multiplyHighBigInt(x,y)\n-    private static boolean check(long x, long y) {\n-        long p1 = multiplyHighBigInt(x, y);\n-        long p2 = Math.multiplyHigh(x, y);\n+    \/\/ Calculate high 64 bits of unsigned 128 product using signed multiply\n+    private static long unsignedMultiplyHigh(long x, long y) {\n+        long x0 = x & 0xffffffffL;\n+        long x1 = x >>> 32;\n+        long y0 = y & 0xffffffffL;\n+        long y1 = y >>> 32;\n+\n+        long t = x1 * y0 + ((x0 * y0) >>> 32);\n+        long z0 = x0 * y1 + (t & 0xffffffffL);\n+        long z1 = t >>> 32;\n+\n+        return x1 * y1 + z1 + (z0 >>> 32);\n+    }\n+\n+    \/\/ Compare results of two functions for a pair of values\n+    private static boolean check(BiFunction<Long,Long,Long> reference,\n+        BiFunction<Long,Long,Long> multiply, long x, long y) {\n+        long p1 = reference.apply(x, y);\n+        long p2 = multiply.apply(x, y);\n@@ -64,1 +80,13 @@\n-    private static int testMultiplyHigh() {\n+    \/\/ Check Math.multiplyHigh(x,y) against multiplyHighBigInt(x,y)\n+    private static boolean checkSigned(long x, long y) {\n+        return check((a,b) -> multiplyHighBigInt(a,b),\n+            (a,b) -> Math.multiplyHigh(a, b), x, y);\n+    }\n+\n+    \/\/ Check Math.unsignedMultiplyHigh(x,y) against unsignedMultiplyHigh(x,y)\n+    private static boolean checkUnsigned(long x, long y) {\n+        return check((a,b) -> unsignedMultiplyHigh(a,b),\n+            (a,b) -> Math.unsignedMultiplyHigh(a, b), x, y);\n+    }\n+\n+    private static int test(BiFunction<Long,Long,Boolean> chk) {\n@@ -87,1 +115,1 @@\n-            if(!check(xy[0], xy[1])) {\n+            if(!chk.apply(xy[0], xy[1])) {\n@@ -94,1 +122,1 @@\n-            if (!check(rnd.nextLong(), rnd.nextLong())) {\n+            if (!chk.apply(rnd.nextLong(), rnd.nextLong())) {\n@@ -102,0 +130,8 @@\n+    private static int testMultiplyHigh() {\n+        return test((x,y) -> checkSigned(x,y));\n+    }\n+\n+    private static int testUnsignedMultiplyHigh() {\n+        return test((x,y) -> checkUnsigned(x,y));\n+    }\n+\n@@ -103,1 +139,1 @@\n-        int failures = testMultiplyHigh();\n+        int failures = testMultiplyHigh() + testUnsignedMultiplyHigh();\n","filename":"test\/jdk\/java\/lang\/Math\/MultiplicationTests.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,9 @@\n+    static int testStrictVsNonstrictPowCase(double input1, double input2) {\n+        double smResult = StrictMath.pow(input1, input2);\n+        double mResult = Math.pow(input1, input2);\n+        return Tests.testUlpDiff(\n+            \"StrictMath.pow(double, double) vs Math.pow(double, double)\",\n+            input1, input2, mResult, smResult, 2.0\n+        );\n+    }\n+\n@@ -209,0 +218,1 @@\n+                    failures += testStrictVsNonstrictPowCase(x, y);\n@@ -211,0 +221,1 @@\n+                    failures += testStrictVsNonstrictPowCase(x, y);\n","filename":"test\/jdk\/java\/lang\/Math\/PowTests.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-     private static void fail(Throwable ex, String s, Throwable got) {\n+    private static void fail(Throwable ex, String s, Throwable got) {\n@@ -52,1 +52,0 @@\n-\/\/          x.printStackTrace();\n@@ -97,1 +96,1 @@\n-                 new StringIndexOutOfBoundsException(\"start -1, end 2, length 7\"),\n+                 new StringIndexOutOfBoundsException(\"Range [-1, 2) out of bounds for length 7\"),\n@@ -105,1 +104,1 @@\n-                 new StringIndexOutOfBoundsException(\"start 7, end 6, length 6\"),\n+                 new StringIndexOutOfBoundsException(\"Range [7, 6) out of bounds for length 6\"),\n@@ -112,1 +111,1 @@\n-                 new StringIndexOutOfBoundsException(\"start 2, end 1, length 7\"),\n+                 new StringIndexOutOfBoundsException(\"Range [2, 1) out of bounds for length 7\"),\n@@ -119,1 +118,1 @@\n-        if (!ok)\n+        if (!ok) {\n@@ -121,1 +120,1 @@\n-        else\n+        } else {\n@@ -123,0 +122,1 @@\n+        }\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/Exceptions.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-\/\/          x.printStackTrace();\n@@ -97,1 +96,1 @@\n-                 new StringIndexOutOfBoundsException(\"start -1, end 2, length 7\"),\n+                 new StringIndexOutOfBoundsException(\"Range [-1, 2) out of bounds for length 7\"),\n@@ -104,1 +103,1 @@\n-                 new StringIndexOutOfBoundsException(\"start 7, end 6, length 6\"),\n+                 new StringIndexOutOfBoundsException(\"Range [7, 6) out of bounds for length 6\"),\n@@ -111,1 +110,1 @@\n-                 new StringIndexOutOfBoundsException(\"start 2, end 1, length 7\"),\n+                 new StringIndexOutOfBoundsException(\"Range [2, 1) out of bounds for length 7\"),\n@@ -118,1 +117,1 @@\n-        if (!ok)\n+        if (!ok) {\n@@ -120,1 +119,1 @@\n-        else\n+        } else {\n@@ -122,0 +121,1 @@\n+        }\n@@ -123,1 +123,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/Exceptions.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266791\n+ * @summary Annotation property which is compiled as an array property but\n+ *          changed observed as a singular element should throw an\n+ *          AnnotationTypeMismatchException\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArityTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class ArityTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation with a member with a non-array type where the annotation\n+         * defines an array property of this type. This can happen if the annotation class is recompiled\n+         * without recompiling the code that declares an annotation of this type. In the example, a\n+         * class is defined to be annotated as\n+         *\n+         * @AnAnnotation(value = {\"v\"}) \/\/ should no longer be an array\n+         * class Carrier { }\n+         *\n+         * where @AnAnnotation expects a singular value.\n+         *\/\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n+        AnnotationVisitor v2 = v.visitArray(\"value\");\n+        v2.visit(null, \"v\");\n+        v2.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        byte[] b = writer.toByteArray();\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(ArityTypeMismatchTest.class.getClassLoader());\n+        cl.init(b);\n+        AnAnnotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(AnAnnotation.class);\n+        try {\n+            String value = sample.value();\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (AnnotationTypeMismatchException e) {\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(\"Array with component tag: s\")) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface AnAnnotation {\n+        String value();\n+    }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        public void init(byte[] b) {\n+            defineClass(\"sample.Carrier\", b, 0, b.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArityTypeMismatchTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+                { 62,   0,  Set.of() },                      \/\/ JDK 18\n@@ -107,1 +108,5 @@\n-                { 62,   0,  Set.of()},                       \/\/ JDK 18\n+                { 62,   0,  Set.of(STATIC) },                \/\/ JDK 18\n+                { 62,   0,  Set.of(TRANSITIVE) },\n+                { 62,   0,  Set.of(STATIC, TRANSITIVE) },\n+\n+                { 63,   0,  Set.of()},                       \/\/ JDK 19\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl AddressNotSet\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/AddressNotSet.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketExample\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketExample\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketExample.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketMulticasting\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketMulticasting.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl DatagramTimeout\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramTimeout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl InterruptibleDatagramSocket\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/InterruptibleDatagramSocket.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl ReuseAddressTest\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/ReuseAddressTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SendCheck\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendCheck.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl=false SendDatagramToBadAddress\n+ * @run main\/othervm SendDatagramToBadAddress\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendDatagramToBadAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n- * @run testng\/othervm -Djava.security.manager=allow -Djdk.net.usePlainDatagramSocketImpl SendPortZero\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendPortZero.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SendReceiveMaxSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv4Stack=true SendReceiveMaxSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv6Addresses=true SendReceiveMaxSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendReceiveMaxSize.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetDatagramSocketImplFactory\/ADatagramSocket.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import java.io.IOException;\n+import java.nio.channels.DatagramChannel;\n+\n@@ -27,6 +30,49 @@\n-  public DatagramSocketImpl createDatagramSocketImpl() {\n-    try {\n-        return DefaultDatagramSocketImplFactory.createDatagramSocketImpl(false);\n-    } catch (SocketException se) {\n-        assert false;\n-    }\n+    static class MyDatagramSocketImpl extends DatagramSocketImpl {\n+        DatagramSocket ds;\n+\n+        @Override\n+        protected void create() throws SocketException {\n+            try {\n+                ds = DatagramChannel.open().socket();\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage());}\n+        }\n+\n+        @Override\n+        protected void bind(int lport, InetAddress laddr) throws SocketException {\n+            ds.bind(new InetSocketAddress(laddr, lport));\n+            localPort = ds.getLocalPort();\n+        }\n+\n+        @Override\n+        protected void send(DatagramPacket p) throws IOException {\n+            ds.send(p);\n+        }\n+\n+        @Override\n+        protected int peek(InetAddress i) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected int peekData(DatagramPacket p) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void receive(DatagramPacket p) throws IOException {\n+            ds.receive(p);\n+        }\n+\n+        @Override\n+        protected void setTTL(byte ttl) throws IOException {\n+        }\n+\n+        @Override\n+        protected byte getTTL() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void setTimeToLive(int ttl) throws IOException {\n+\n+        }\n@@ -34,1 +80,90 @@\n-    return null;\n+        @Override\n+        protected int getTimeToLive() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void join(InetAddress inetaddr) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void leave(InetAddress inetaddr) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void close() {\n+            ds.close();\n+        }\n+\n+        @Override\n+        public void setOption(int optID, Object value) throws SocketException {\n+            try {\n+                if (optID == SocketOptions.SO_SNDBUF) {\n+                    if (((Integer) value).intValue() < 0)\n+                        throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n+                    ds.setOption(StandardSocketOptions.SO_SNDBUF, (Integer) value);\n+                } else if (optID == SocketOptions.SO_RCVBUF) {\n+                    if (((Integer) value).intValue() < 0)\n+                        throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n+                    ds.setOption(StandardSocketOptions.SO_RCVBUF, (Integer) value);\n+                } else if (optID == SocketOptions.SO_REUSEADDR) {\n+                    ds.setOption(StandardSocketOptions.SO_REUSEADDR, (Boolean) value);\n+                } else if (optID == SocketOptions.SO_REUSEPORT) {\n+                    ds.setOption(StandardSocketOptions.SO_REUSEPORT, (Boolean) value);\n+                } else if (optID == SocketOptions.SO_BROADCAST) {\n+                     ds.setOption(StandardSocketOptions.SO_BROADCAST, (Boolean) value);\n+                } else if (optID == SocketOptions.IP_TOS) {\n+                    int i = ((Integer) value).intValue();\n+                    if (i < 0 || i > 255)\n+                        throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n+                    ds.setOption(StandardSocketOptions.IP_TOS, (Integer) value);\n+                } else if (optID == SocketOptions.IP_MULTICAST_LOOP) {\n+                    boolean enable = (boolean) value;\n+                    \/\/ Legacy ds.setOption expects true to mean 'disabled'\n+                    ds.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, !enable);\n+                } else {\n+                    throw new AssertionError(\"unknown option :\" + optID);\n+                }\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage()); }\n+        }\n+\n+        @Override\n+        public Object getOption(int optID) throws SocketException {\n+            try {\n+                if (optID == SocketOptions.SO_SNDBUF) {\n+                    return ds.getOption(StandardSocketOptions.SO_SNDBUF);\n+                } else if (optID == SocketOptions.SO_RCVBUF) {\n+                    return ds.getOption(StandardSocketOptions.SO_RCVBUF);\n+                } else if (optID == SocketOptions.SO_REUSEADDR) {\n+                    return ds.getOption(StandardSocketOptions.SO_REUSEADDR);\n+                } else if (optID == SocketOptions.SO_REUSEPORT) {\n+                    return ds.getOption(StandardSocketOptions.SO_REUSEPORT);\n+                } else if (optID == SocketOptions.SO_BROADCAST) {\n+                    return ds.getOption(StandardSocketOptions.SO_BROADCAST);\n+                } else if (optID == SocketOptions.IP_TOS) {\n+                    return ds.getOption(StandardSocketOptions.IP_TOS);\n+                } else if (optID == SocketOptions.IP_MULTICAST_LOOP) {\n+                    boolean disabled = (boolean) ds.getOption(StandardSocketOptions.IP_MULTICAST_LOOP);\n+                    \/\/ Legacy getOption returns true when disabled\n+                    return Boolean.valueOf(!disabled);\n+                } else {\n+                    throw new AssertionError(\"unknown option: \" + optID);\n+                }\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage()); }\n+        }\n+    }\n+    @Override\n+    public MyDatagramSocketImpl createDatagramSocketImpl() {\n+        return new MyDatagramSocketImpl();\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetDatagramSocketImplFactory\/java.base\/java\/net\/MyDatagramSocketImplFactory.java","additions":143,"deletions":8,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetGetReceiveBufferSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetGetReceiveBufferSize.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetGetSendBufferSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv4Stack=true SetGetSendBufferSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetGetSendBufferSize.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl TestAfterClose\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/TestAfterClose.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedDatagramSockets\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl B6427403\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/B6427403.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl MulticastAddresses\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/MulticastAddresses.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl NoSetNetworkInterface\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/NoSetNetworkInterface.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl Promiscuous\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/Promiscuous.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n- * @run testng\/othervm -Djava.security.manager=allow -Djdk.net.usePlainDatagramSocketImpl SendPortZero\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SendPortZero.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetLoopbackMode\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackMode.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true\n- *                   -Djdk.net.usePlainDatagramSocketImpl SetLoopbackModeIPv4\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetLoopbackOption\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackOption.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetOutgoingIf\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetOutgoingIf.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetTTLAndGetTTL\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLAndGetTTL.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetTTLTo0\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLTo0.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedMulticastSockets\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/UnreferencedMulticastSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary java.net.PlainSocketImpl backlog value bug avoidance\n+ * @summary java.net.SocketImpl backlog value bug avoidance\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/BigBacklog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary ClassCastException in PlainSocketImpl.accept() when using custom socketImpl\n+ * @summary ClassCastException in SocketImpl.accept() when using custom socketImpl\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/CustomSocketImplFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary java.net.PlainSocketImpl {set,get}Option throws SocketException\n+ * @summary java.net.SocketImpl {set,get}Option throws SocketException\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/SetOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl AcceptCauseFileDescriptorLeak root\n","filename":"test\/jdk\/java\/net\/ServerSocket\/AcceptCauseFileDescriptorLeak.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl UnreferencedSockets\n","filename":"test\/jdk\/java\/net\/ServerSocket\/UnreferencedSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl AddressTest\n","filename":"test\/jdk\/java\/net\/Socket\/AddressTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl ConnectionReset\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectionReset.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @summary SocketImpl.socketAccept() handles EINTR incorrectly\n@@ -30,2 +30,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 0\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 5000\n","filename":"test\/jdk\/java\/net\/Socket\/SocketAcceptInterruptTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @summary SocketImpl.socketAccept() handles EINTR incorrectly\n@@ -30,1 +30,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 3000\n@@ -32,1 +31,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 0\n","filename":"test\/jdk\/java\/net\/Socket\/SocketReadInterruptTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl AsyncClose\n","filename":"test\/jdk\/java\/net\/Socket\/asyncClose\/AsyncClose.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8221481\n- * @modules java.base\/java.net:+open java.base\/sun.nio.ch:+open\n- * @run testng CompareSocketOptions\n- * @summary Compare the set of socket options supported by the old and new SocketImpls\n- *\/\n-\n-import java.io.IOException;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketImpl;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class CompareSocketOptions {\n-\n-    \/**\n-     * Test that the old and new platform SocketImpl support the same set of\n-     * client socket options.\n-     *\/\n-    public void testClientSocketSupportedOptions() throws IOException {\n-        Socket s1 = new Socket(createOldSocketImpl(false)) { };\n-        Socket s2 = new Socket(createNewSocketImpl(false)) { };\n-        assertEquals(s1.supportedOptions(), s2.supportedOptions());\n-    }\n-\n-    \/**\n-     * Test that the old and new platform SocketImpl support the same set of\n-     * server socket options.\n-     *\/\n-    public void testServerSocketSupportedOptions() throws IOException {\n-        ServerSocket ss1 = new ServerSocket(createOldSocketImpl(true)) { };\n-        ServerSocket ss2 = new ServerSocket(createNewSocketImpl(true)) { };\n-        assertEquals(ss1.supportedOptions(), ss2.supportedOptions());\n-    }\n-\n-    private static SocketImpl createOldSocketImpl(boolean server) {\n-        return newPlatformSocketImpl(\"java.net.PlainSocketImpl\", server);\n-    }\n-\n-    private static SocketImpl createNewSocketImpl(boolean server) {\n-        return newPlatformSocketImpl(\"sun.nio.ch.NioSocketImpl\", server);\n-    }\n-\n-    private static SocketImpl newPlatformSocketImpl(String name, boolean server) {\n-        try {\n-            var ctor = Class.forName(name).getDeclaredConstructor(boolean.class);\n-            ctor.setAccessible(true);\n-            return (SocketImpl) ctor.newInstance(server);\n-        } catch (Exception e) {\n-            fail(\"Should not get here\", e);\n-            return null;\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/SocketImpl\/CompareSocketOptions.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl AfterClose\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl AfterClose\n","filename":"test\/jdk\/java\/net\/SocketOption\/AfterClose.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl NullsAndBadValues\n","filename":"test\/jdk\/java\/net\/SocketOption\/NullsAndBadValues.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl OptionsTest\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl OptionsTest\n","filename":"test\/jdk\/java\/net\/SocketOption\/OptionsTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl RequiredOptions\n","filename":"test\/jdk\/java\/net\/SocketOption\/RequiredOptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,6 +42,0 @@\n- *          DigestEchoClientSSL SSL\n- * @run main\/othervm\/timeout=300\n- *          -Djdk.http.auth.proxying.disabledSchemes=\n- *          -Djdk.http.auth.tunneling.disabledSchemes=\n- *          DigestEchoClientSSL SSL PROXY\n- * @run main\/othervm\/timeout=300\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClientSSL.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268294\n+ * @modules java.net.http\/jdk.internal.net.http.websocket:open jdk.httpserver\n+ * @run main\/othervm\n+ *      --add-reads java.net.http=ALL-UNNAMED\n+ *      --add-reads java.net.http=jdk.httpserver\n+ *      java.net.http\/jdk.internal.net.http.websocket.WebSocketAndHttpTest\n+ *\/\n+public final class WebSocketServerDriver { }\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketServerDriver.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * No implementation provided for onInit() because that must always be\n+ * implemented by user\n+ *\/\n+abstract class DefaultMessageStreamHandler implements MessageStreamHandler {\n+\n+    public void onText(CharSequence data, boolean last) {}\n+\n+    public void onBinary(ByteBuffer data, boolean last) {}\n+\n+    public void onPing(ByteBuffer data) {}\n+\n+    public void onPong(ByteBuffer data) {}\n+\n+    public void onClose(int statusCode, CharSequence reason) {}\n+\n+    public void onComplete() {}\n+\n+    public void onError(Throwable e) {}\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/DefaultMessageStreamHandler.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+\/**\n+ * WebSocket server listener interface, which is the same as the client API\n+ * in java.net.http. See MessageStreamResponder for how listener methods\n+ * can send response messages back to the client\n+ *\n+ * All MessageStreamConsumer methods must be implemented (plus the handler method\n+ * declared here). DefaultMessageStreamHandler provides empty implementations of all\n+ * that can be extended, except for onInit() which must always be implemented.\n+ *\n+ *    void onText(CharSequence data, boolean last);\n+ *\n+ *    void onBinary(ByteBuffer data, boolean last);\n+ *\n+ *    void onPing(ByteBuffer data);\n+ *\n+ *    void onPong(ByteBuffer data);\n+ *\n+ *    void onClose(int statusCode, CharSequence reason);\n+ *\n+ *    void onComplete();\n+ *\n+ *    void onError(Throwable e);\n+ *\/\n+interface MessageStreamHandler extends MessageStreamConsumer {\n+\n+    \/**\n+     * called before any of the methods above to supply a\n+     * MessageStreamResponder for any new connection, which can be used to send replies\n+     * sendText(), sendBinary(), sendClose() etc\n+     *\/\n+    void onInit(MessageStreamResponder responder);\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamHandler.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.util.List;\n+\n+\/**\n+ * One of these supplied for each incoming client connection for use\n+ * by user written MessageStreamConsumer.\n+ *\/\n+interface MessageStreamResponder {\n+\n+    public void sendText(CharBuffer src, boolean last) throws IOException;\n+\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException;\n+\n+    public void sendPing(ByteBuffer src) throws IOException;\n+\n+    public void sendPong(ByteBuffer src) throws IOException;\n+\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException;\n+\n+    public void close();\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamResponder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.WebSocket;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * This is the client side of the test invoked from WebSocketAndHttpTest:\n+ *\n+ * The two args are the addresses of a (local) Websocket and Http server\n+ *\n+ * The test first sends a request to the WS server and in the listener\n+ * which handles the response, it tries to send a request to the http\n+ * server. This hangs if the listener was invoked from the selector\n+ * manager thread. If invoked from a different thread then the http\n+ * response is received and the response string is mapped to string\n+ * \"succeeded\"\n+ *\/\n+public class WebSocketAndHttpClient {\n+\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        HttpClient httpClient = HttpClient.newBuilder().executor(executorService).build();\n+\n+        WebSocketTest wsTest = new WebSocketTest(httpClient, args[0]);\n+        HttpTest httpTest = new HttpTest(httpClient, args[1]);\n+\n+        final CompletableFuture<String> result = new CompletableFuture<>();\n+\n+        wsTest.listen(message -> {\n+            try {\n+                String r = httpTest.getData(message);\n+                result.complete(r);\n+            } catch (Exception e) {\n+                result.completeExceptionally(e);\n+            }\n+        });\n+\n+        wsTest.sendData(\"TEST_DATA\");\n+\n+        System.out.println(\"Wait for result\");\n+        try {\n+            result.join();\n+            System.out.println(\"Result: success\");\n+        } finally {\n+            executorService.shutdownNow();\n+        }\n+    }\n+\n+    static class WebSocketTest {\n+        final HttpClient httpClient;\n+        final String server;\n+        volatile WebSocket webSocket;\n+\n+        WebSocketTest(HttpClient httpClient, String server) {\n+            this.httpClient = httpClient;\n+            this.server = server;\n+        }\n+\n+        public void listen(Consumer<String> consumer) {\n+            URI uri = URI.create(server);\n+            System.out.println(\"WS API client - Connecting to \" + uri.toString());\n+            CompletableFuture<WebSocket> cf = httpClient.newWebSocketBuilder()\n+                .buildAsync(uri, new WebSocket.Listener() {\n+                    @Override\n+                    public CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {\n+                        System.out.println(\"WS API client - received data: \" + data);\n+                        consumer.accept(data.toString());\n+                        return null;\n+                    }\n+                    public void onError(WebSocket webSocket, Throwable error) {\n+                        System.out.println(\"WS API client - error\");\n+                        error.printStackTrace();\n+                    }\n+                });\n+            System.out.println(\"CF created\");\n+            webSocket = cf.join();\n+            System.out.println(\"Websocket created\");\n+        }\n+\n+        void sendData(String data) {\n+            System.out.println(\"WS API client - sending data via WebSocket: {}\" + data);\n+            webSocket.sendText(data, true).join();\n+        }\n+    }\n+\n+    static class HttpTest {\n+        final HttpClient httpClient;\n+        final String baseUrl;\n+\n+        HttpTest(HttpClient httpClient, String baseUrl) {\n+            this.httpClient = httpClient;\n+            this.baseUrl = baseUrl;\n+        }\n+\n+        private String getData(String data) throws Exception {\n+            URI uri = URI.create(baseUrl + \"?param=\" + data);\n+            HttpRequest request = HttpRequest.newBuilder().GET().uri(uri).build();\n+            System.out.println(\"Http API Client - send HTTP GET request with parameter {}\" + data);\n+            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            return send.body();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpClient.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.*;\n+import java.nio.CharBuffer;\n+import java.io.*;\n+\n+import com.sun.net.httpserver.*;\n+\n+public class WebSocketAndHttpTest {\n+    static class WHandler extends DefaultMessageStreamHandler {\n+        volatile MessageStreamResponder responder;\n+\n+        public void onText(CharSequence data, boolean last) {\n+            System.out.println(\"onText: \" + data);\n+            System.out.println(\"onText: \" + Thread.currentThread());\n+            try {\n+                responder.sendText(CharBuffer.wrap(data), true);\n+                System.out.println(\"onText: send ok\");\n+            } catch (IOException e) {\n+                System.out.println(\"onText: \" + e);\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        public void onInit(MessageStreamResponder responder) {\n+            System.out.println(\"onInit\");\n+            this.responder = responder;\n+        }\n+    }\n+\n+    static HttpHandler httpHandler = (ex) -> ex.sendResponseHeaders(200, -1);\n+\n+    public static void main(String[] args) throws Exception {\n+        HttpServer hserver = null;\n+        try {\n+            WebSocketServer server = new WebSocketServer(new WHandler());\n+            server.open();\n+            URI uri = server.getURI();\n+\n+            hserver = HttpServer.create(new InetSocketAddress(0), 4);\n+            hserver.createContext(\"\/\", httpHandler);\n+            hserver.start();\n+\n+            int port = hserver.getAddress().getPort();\n+            URI huri = new URI(\"http:\/\/127.0.0.1:\" + port + \"\/foo\");\n+\n+            WebSocketAndHttpClient.main(new String[]{uri.toString(), huri.toString()});\n+        } finally {\n+            hserver.stop(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+\n+public class WebSocketResponder implements MessageStreamResponder {\n+\n+    final MessageStreamConsumer consumer;\n+    final LinkedList<ByteBuffer> queue;\n+    volatile boolean closed = false;\n+\n+    final MessageEncoder encoder;\n+    final MessageDecoder decoder;\n+\n+    static final int BUF_SIZE = 1024;\n+\n+    public WebSocketResponder(MessageStreamConsumer consumer) {\n+        this.consumer = consumer;\n+        this.queue = new LinkedList<>();\n+        this.decoder = new MessageDecoder(consumer, true);\n+        this.encoder = new MessageEncoder(true);\n+    }\n+\n+    \/\/ own thread\n+    public void readLoop(SocketChannel chan) throws IOException {\n+        chan.configureBlocking(true);\n+        boolean eof = false;\n+        ByteBuffer buf = ByteBuffer.allocate(8 * 1024);\n+        Frame.Reader reader = new Frame.Reader();\n+        try {\n+            while (!eof) {\n+                int count;\n+                buf.clear();\n+                eof = ((count=chan.read(buf)) == -1);\n+                if (!eof) {\n+                    buf.flip();\n+                    reader.readFrame(buf, decoder);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!closed)\n+                throw e;\n+        }\n+    }\n+\n+    \/\/ own thread\n+    public void writeLoop(SocketChannel chan) throws IOException {\n+        \/\/ read queue and send data\n+        while (true) {\n+            ByteBuffer buf;\n+            synchronized(queue) {\n+                while (queue.isEmpty()) {\n+                    try {\n+                        queue.wait();\n+                    } catch (InterruptedException e) {\n+                        throw new IOException(e);\n+                    }\n+                    if (queue.isEmpty() && closed) {\n+                        chan.close();\n+                        return;\n+                    }\n+                }\n+                buf = queue.remove(0);\n+            }\n+            chan.write(buf);\n+        }\n+    }\n+\n+    \/**\n+     * Public methods below used y MessageStreamHandler to send replies\n+     * to client.\n+     *\/\n+    @Override\n+    public void sendText(CharBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeText(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeBinary(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPing(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePing(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPong(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePong(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeClose(statusCode, reason, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+        close();\n+    }\n+\n+    private void sendMessage(List<ByteBuffer> bufs) throws IOException {\n+        if (closed)\n+            throw new IOException(\"closed\");\n+        synchronized(queue) {\n+            queue.addAll(bufs);\n+            queue.notify();\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized(queue) {\n+            closed = true;\n+            queue.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketResponder.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardSocketOptions;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.CharacterCodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static java.lang.System.err;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * WebSocket Server. This is a copy of the DummyWebSocketServer test class\n+ * but which also supports sending and receiving of websocket messages\n+ * using a simple API once the connection has been established\n+ *\n+ * MessageStreamHandler is the \"listener\" API to be implemented for handling\n+ * incoming messages. MessageStreamResponder is used by that handler to send\n+ * responses back to the client.\n+ *\n+ * Performs simpler version of the WebSocket Opening Handshake over HTTP (i.e.\n+ * no proxying, cookies, etc.) Supports sequential connections, one at a time,\n+ * i.e. in order for a client to connect to the server the previous client must\n+ * disconnect first.\n+ *\n+ * Expected client request:\n+ *\n+ *     GET \/chat HTTP\/1.1\n+ *     Host: server.example.com\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n+ *     Origin: http:\/\/example.com\n+ *     Sec-WebSocket-Protocol: chat, superchat\n+ *     Sec-WebSocket-Version: 13\n+ *\n+ * This server response:\n+ *\n+ *     HTTP\/1.1 101 Switching Protocols\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n+ *     Sec-WebSocket-Protocol: chat\n+ *\/\n+public class WebSocketServer implements Closeable {\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private final Thread thread;\n+    private volatile ServerSocketChannel ssc;\n+    private volatile InetSocketAddress address;\n+    private ByteBuffer read = ByteBuffer.allocate(16384);\n+    private final CountDownLatch readReady = new CountDownLatch(1);\n+    private final MessageStreamHandler handler;\n+    private final WebSocketResponder responder;\n+    private volatile int receiveBufferSize;\n+\n+    private static class Credentials {\n+        private final String name;\n+        private final String password;\n+        private Credentials(String name, String password) {\n+            this.name = name;\n+            this.password = password;\n+        }\n+        public String name() { return name; }\n+        public String password() { return password; }\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler) {\n+        this(handler, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer() {\n+        this(null, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer(String username, String password) {\n+        this(null, defaultMapping(), username, password);\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler,\n+                           BiFunction<List<String>,Credentials,List<String>> mapping,\n+                           String username, String password) {\n+        requireNonNull(mapping);\n+        this.handler = handler;\n+        if (handler == null) {\n+            this.responder = null;\n+        } else {\n+            this.responder = new WebSocketResponder(handler);\n+            handler.onInit(this.responder);\n+        }\n+        Credentials credentials = username != null ?\n+                new Credentials(username, password) : null;\n+\n+        thread = new Thread(() -> {\n+            try {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    err.println(\"Accepting next connection at: \" + ssc);\n+                    SocketChannel channel = ssc.accept();\n+                    err.println(\"Accepted: \" + channel);\n+                    try {\n+                        channel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                        channel.configureBlocking(true);\n+                        while (true) {\n+                            StringBuilder request = new StringBuilder();\n+                            if (!readRequest(channel, request)) {\n+                                throw new IOException(\"Bad request:[\" + request + \"]\");\n+                            }\n+                            List<String> strings = asList(request.toString().split(\"\\r\\n\"));\n+                            List<String> response = mapping.apply(strings, credentials);\n+                            writeResponse(channel, response);\n+\n+                            if (response.get(0).startsWith(\"HTTP\/1.1 401\")) {\n+                                err.println(\"Sent 401 Authentication response \" + channel);\n+                                continue;\n+                            } else {\n+                                serve(channel);\n+                                break;\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        err.println(\"Error in connection: \" + channel + \", \" + e);\n+                    } finally {\n+                        err.println(\"Closed: \" + channel);\n+                        close(channel);\n+                        readReady.countDown();\n+                    }\n+                }\n+            } catch (ClosedByInterruptException ignored) {\n+            } catch (Exception e) {\n+                e.printStackTrace(err);\n+            } finally {\n+                close(ssc);\n+                err.println(\"Stopped at: \" + getURI());\n+            }\n+        });\n+        thread.setName(\"WebSocketServer\");\n+        thread.setDaemon(false);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void read(SocketChannel ch) throws IOException {\n+        responder.readLoop(ch);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void write(SocketChannel ch) throws IOException {\n+        responder.writeLoop(ch);\n+    }\n+\n+    protected final void serve(SocketChannel channel)\n+            throws InterruptedException\n+    {\n+        Thread reader = new Thread(() -> {\n+            try {\n+                read(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        Thread writer = new Thread(() -> {\n+            try {\n+                write(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        reader.start();\n+        writer.start();\n+        try {\n+            reader.join();\n+        } finally {\n+            reader.interrupt();\n+            try {\n+                writer.join();\n+            } finally {\n+                writer.interrupt();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer read() throws InterruptedException {\n+        readReady.await();\n+        return read.duplicate().asReadOnlyBuffer().flip();\n+    }\n+\n+    public void setReceiveBufferSize(int bufsize) {\n+        assert ssc == null : \"Must configure before calling open()\";\n+        this.receiveBufferSize = bufsize;\n+    }\n+\n+    public void open() throws IOException {\n+        err.println(\"Starting\");\n+        if (!started.compareAndSet(false, true)) {\n+            throw new IllegalStateException(\"Already started\");\n+        }\n+        ssc = ServerSocketChannel.open();\n+        try {\n+            ssc.configureBlocking(true);\n+            var bufsize = receiveBufferSize;\n+            if (bufsize > 0) {\n+                err.printf(\"Configuring receive buffer size to %d%n\", bufsize);\n+                try {\n+                    ssc.setOption(StandardSocketOptions.SO_RCVBUF, bufsize);\n+                } catch (IOException x) {\n+                    err.printf(\"Failed to configure receive buffer size to %d%n\", bufsize);\n+                }\n+            }\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            address = (InetSocketAddress) ssc.getLocalAddress();\n+            thread.start();\n+        } catch (IOException e) {\n+            close(ssc);\n+            throw e;\n+        }\n+        err.println(\"Started at: \" + getURI());\n+    }\n+\n+    @Override\n+    public void close() {\n+        err.println(\"Stopping: \" + getURI());\n+        thread.interrupt();\n+        close(ssc);\n+    }\n+\n+    URI getURI() {\n+        if (!started.get()) {\n+            throw new IllegalStateException(\"Not yet started\");\n+        }\n+        return URI.create(\"ws:\/\/localhost:\" + address.getPort());\n+    }\n+\n+    private boolean readRequest(SocketChannel channel, StringBuilder request)\n+            throws IOException\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(512);\n+        while (channel.read(buffer) != -1) {\n+            \/\/ read the complete HTTP request headers, there should be no body\n+            CharBuffer decoded;\n+            buffer.flip();\n+            try {\n+                decoded = ISO_8859_1.newDecoder().decode(buffer);\n+            } catch (CharacterCodingException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            request.append(decoded);\n+            if (Pattern.compile(\"\\r\\n\\r\\n\").matcher(request).find())\n+                return true;\n+            buffer.clear();\n+        }\n+        return false;\n+    }\n+\n+    private void writeResponse(SocketChannel channel, List<String> response)\n+            throws IOException\n+    {\n+        String s = response.stream().collect(Collectors.joining(\"\\r\\n\"))\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuffer encoded;\n+        try {\n+            encoded = ISO_8859_1.newEncoder().encode(CharBuffer.wrap(s));\n+        } catch (CharacterCodingException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        while (encoded.hasRemaining()) {\n+            channel.write(encoded);\n+        }\n+    }\n+\n+    private static BiFunction<List<String>,Credentials,List<String>> defaultMapping() {\n+        return (request, credentials) -> {\n+            List<String> response = new LinkedList<>();\n+            Iterator<String> iterator = request.iterator();\n+            if (!iterator.hasNext()) {\n+                throw new IllegalStateException(\"The request is empty\");\n+            }\n+            String statusLine = iterator.next();\n+            if (!(statusLine.startsWith(\"GET \/\") && statusLine.endsWith(\" HTTP\/1.1\"))) {\n+                throw new IllegalStateException\n+                        (\"Unexpected status line: \" + request.get(0));\n+            }\n+            response.add(\"HTTP\/1.1 101 Switching Protocols\");\n+            Map<String, List<String>> requestHeaders = new HashMap<>();\n+            while (iterator.hasNext()) {\n+                String header = iterator.next();\n+                String[] split = header.split(\": \");\n+                if (split.length != 2) {\n+                    throw new IllegalStateException\n+                            (\"Unexpected header: \" + header\n+                                     + \", split=\" + Arrays.toString(split));\n+                }\n+                requestHeaders.computeIfAbsent(split[0], k -> new ArrayList<>()).add(split[1]);\n+\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Protocol\")) {\n+                throw new IllegalStateException(\"Subprotocols are not expected\");\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Extensions\")) {\n+                throw new IllegalStateException(\"Extensions are not expected\");\n+            }\n+            expectHeader(requestHeaders, \"Connection\", \"Upgrade\");\n+            response.add(\"Connection: Upgrade\");\n+            expectHeader(requestHeaders, \"Upgrade\", \"websocket\");\n+            response.add(\"Upgrade: websocket\");\n+            expectHeader(requestHeaders, \"Sec-WebSocket-Version\", \"13\");\n+            List<String> key = requestHeaders.get(\"Sec-WebSocket-Key\");\n+            if (key == null || key.isEmpty()) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key is missing\");\n+            }\n+            if (key.size() != 1) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key has too many values : \" + key);\n+            }\n+            MessageDigest sha1 = null;\n+            try {\n+                sha1 = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new InternalError(e);\n+            }\n+            String x = key.get(0) + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n+            sha1.update(x.getBytes(ISO_8859_1));\n+            String v = Base64.getEncoder().encodeToString(sha1.digest());\n+            response.add(\"Sec-WebSocket-Accept: \" + v);\n+\n+            \/\/ check authorization credentials, if required by the server\n+            if (credentials != null && !authorized(credentials, requestHeaders)) {\n+                response.clear();\n+                response.add(\"HTTP\/1.1 401 Unauthorized\");\n+                response.add(\"Content-Length: 0\");\n+                response.add(\"WWW-Authenticate: Basic realm=\\\"dummy server realm\\\"\");\n+            }\n+\n+            return response;\n+        };\n+    }\n+\n+    \/\/ Checks credentials in the request against those allowable by the server.\n+    private static boolean authorized(Credentials credentials,\n+                                      Map<String,List<String>> requestHeaders) {\n+        List<String> authorization = requestHeaders.get(\"Authorization\");\n+        if (authorization == null)\n+            return false;\n+\n+        if (authorization.size() != 1) {\n+            throw new IllegalStateException(\"Authorization unexpected count:\" + authorization);\n+        }\n+        String header = authorization.get(0);\n+        if (!header.startsWith(\"Basic \"))\n+            throw new IllegalStateException(\"Authorization not Basic: \" + header);\n+\n+        header = header.substring(\"Basic \".length());\n+        String values = new String(Base64.getDecoder().decode(header), UTF_8);\n+        int sep = values.indexOf(':');\n+        if (sep < 1) {\n+            throw new IllegalStateException(\"Authorization not colon: \" +  values);\n+        }\n+        String name = values.substring(0, sep);\n+        String password = values.substring(sep + 1);\n+\n+        if (name.equals(credentials.name()) && password.equals(credentials.password()))\n+            return true;\n+\n+        return false;\n+    }\n+\n+    protected static String expectHeader(Map<String, List<String>> headers,\n+                                         String name,\n+                                         String value) {\n+        List<String> v = headers.get(name);\n+        if (v == null) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s' header, not present in %s\",\n+                           name, headers));\n+        }\n+        if (!v.contains(value)) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s: %s', actual: '%s: %s'\",\n+                           name, value, name, v)\n+            );\n+        }\n+        return value;\n+    }\n+\n+    private static void close(AutoCloseable... acs) {\n+        for (AutoCloseable ac : acs) {\n+            try {\n+                ac.close();\n+            } catch (Exception ignored) { }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketServer.java","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl TcpTest -d\n","filename":"test\/jdk\/java\/net\/ipv6tests\/TcpTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+#if[byte]\n+        $Type$Buffer direct1 = $Type$Buffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+#end[byte]\n+\n+#if[!char]\n+        $Type$Buffer nondirect1 = $Type$Buffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+#end[!char]\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/Basic-X.java.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1137,0 +1137,20 @@\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+        ByteBuffer direct1 = ByteBuffer.allocateDirect(cap);\n+        if (!direct1.toString().equals(Basic.toString(direct1))) {\n+           fail(\"Direct buffer toString is incorrect: \"\n+                  + direct1.toString() + \" vs \" + Basic.toString(direct1));\n+        }\n+\n+\n+\n+        ByteBuffer nondirect1 = ByteBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n+    }\n+\n@@ -1158,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicByte.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicChar.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        DoubleBuffer nondirect1 = DoubleBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicDouble.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        FloatBuffer nondirect1 = FloatBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicFloat.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        IntBuffer nondirect1 = IntBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicInt.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        LongBuffer nondirect1 = LongBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicLong.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+\n+\n+\n+\n@@ -36,0 +40,6 @@\n+\n+\n+\n+\n+\n+\n@@ -454,0 +464,67 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -1058,0 +1135,20 @@\n+    }\n+\n+    public static void testToString() {\n+        final int cap = 10;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        ShortBuffer nondirect1 = ShortBuffer.allocate(cap);\n+        if (!nondirect1.toString().equals(Basic.toString(nondirect1))) {\n+           fail(\"Heap buffer toString is incorrect: \"\n+                  + nondirect1.toString() + \" vs \" + Basic.toString(nondirect1));\n+        }\n+\n@@ -1081,0 +1178,2 @@\n+\n+        testToString();\n","filename":"test\/jdk\/java\/nio\/Buffer\/BasicShort.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -911,0 +911,14 @@\n+    @Test\n+    public void test_isPositive() {\n+        assertEquals(Duration.ofNanos(0).isPositive(), false);\n+        assertEquals(Duration.ofSeconds(0).isPositive(), false);\n+        assertEquals(Duration.ofNanos(1).isPositive(), true);\n+        assertEquals(Duration.ofSeconds(1).isPositive(), true);\n+        assertEquals(Duration.ofSeconds(1, 1).isPositive(), true);\n+        assertEquals(Duration.ofSeconds(Long.MAX_VALUE, 999_999_999).isPositive(), true);\n+        assertEquals(Duration.ofNanos(-1).isPositive(), false);\n+        assertEquals(Duration.ofSeconds(-1).isPositive(), false);\n+        assertEquals(Duration.ofSeconds(-1, -1).isPositive(), false);\n+        assertEquals(Duration.ofSeconds(Long.MIN_VALUE).isPositive(), false);\n+    }\n+\n@@ -918,0 +932,1 @@\n+        assertEquals(Duration.ofSeconds(Long.MAX_VALUE, 999_999_999).isNegative(), false);\n@@ -921,0 +936,1 @@\n+        assertEquals(Duration.ofSeconds(Long.MIN_VALUE).isNegative(), true);\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKDuration.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * 8216332 8214245 8237599 8241055 8247546 8258259 8037397\n+ * 8216332 8214245 8237599 8241055 8247546 8258259 8037397 8269753\n@@ -201,0 +201,1 @@\n+        errorMessageCaretIndentation();\n@@ -5292,0 +5293,18 @@\n+        report(\"Dropped classes with intersection.\");\n+\n+    }\n+\n+    \/\/This test is for 8269753\n+    private static void errorMessageCaretIndentation() {\n+        String pattern = \"\\t**\";\n+\n+        try {\n+            var res = Pattern.compile(pattern);\n+        } catch (PatternSyntaxException e) {\n+            var message = e.getMessage();\n+            var sep = System.lineSeparator();\n+            if (!message.contains(sep + \"\\t ^\")){\n+                failCount++;\n+            }\n+        }\n+        report(\"Correct caret indentation for patterns with tabs\");\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.util.Arrays;\n@@ -26,0 +27,1 @@\n+import java.util.List;\n@@ -40,4 +42,4 @@\n-    public final String supportedProtocols;\n-    public final String enabledProtocols;\n-    public final String supportedCipherSuites;\n-    public final String enabledCipherSuites;\n+    public final List<String> supportedProtocols;\n+    public final List<String> enabledProtocols;\n+    public final List<String> supportedCipherSuites;\n+    public final List<String> enabledCipherSuites;\n@@ -57,7 +59,20 @@\n-        version = attributes[0].replaceAll(\".*=\", \"\");\n-        supportedProtocols = attributes[1].replaceAll(\".*=\", \"\");\n-        enabledProtocols = attributes[2].replaceAll(\".*=\", \"\");\n-        supportedCipherSuites = attributes[3].replaceAll(\".*=\", \"\");\n-        enabledCipherSuites = attributes[4].replaceAll(\".*=\", \"\");\n-        supportsSNI = Boolean.valueOf(attributes[5].replaceAll(\".*=\", \"\"));\n-        supportsALPN = Boolean.valueOf(attributes[6].replaceAll(\".*=\", \"\"));\n+        version = parseAttribute(attributes[0]);\n+        supportedProtocols = parseListAttribute(attributes[1]);\n+        enabledProtocols = parseListAttribute(attributes[2]);\n+        supportedCipherSuites = parseListAttribute(attributes[3]);\n+        enabledCipherSuites = parseListAttribute(attributes[4]);\n+        supportsSNI = parseBooleanAttribute(attributes[5]);\n+        supportsALPN = parseBooleanAttribute(attributes[6]);\n+    }\n+\n+    private List<String> parseListAttribute(String attribute) {\n+        attribute = parseAttribute(attribute);\n+        return Arrays.asList(attribute.split(\",\"));\n+    }\n+\n+    private boolean parseBooleanAttribute(String attribute) {\n+        attribute = parseAttribute(attribute);\n+        return Boolean.parseBoolean(attribute);\n+    }\n+    private String parseAttribute(String attribute) {\n+        return attribute.replaceAll(\".*=\", \"\");\n","filename":"test\/jdk\/javax\/net\/ssl\/compatibility\/JdkInfo.java","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    private static int locx, locy, frw, frh;\n+    private static volatile int locx, locy, frw, frh;\n@@ -79,0 +79,1 @@\n+                    frame.setUndecorated(true);\n@@ -105,6 +106,8 @@\n-            Rectangle bounds = frame.getBounds();\n-            Insets insets = frame.getInsets();\n-            locx = bounds.x + insets.left;\n-            locy = bounds.y + insets.top;\n-            frw = bounds.width - insets.left - insets.right;\n-            frh = bounds.height - insets.top - insets.bottom;\n+            SwingUtilities.invokeAndWait(() -> {\n+                        Rectangle bounds = frame.getBounds();\n+                        Insets insets = frame.getInsets();\n+                        locx = bounds.x + insets.left;\n+                        locy = bounds.y + insets.top;\n+                        frw = bounds.width - insets.left - insets.right;\n+                        frh = bounds.height - insets.top - insets.bottom;\n+                    });\n","filename":"test\/jdk\/javax\/swing\/JComponent\/7154030\/bug7154030.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            ImageIcon icon = (ImageIcon) fsv.getSystemIcon(file, size, size);\n+            Icon i = fsv.getSystemIcon(file, size, size);\n@@ -78,0 +78,11 @@\n+            if (i == null) {\n+                throw new RuntimeException(file.getAbsolutePath() + \" icon is null\");\n+            }\n+\n+            if (!(i instanceof ImageIcon)) {\n+                \/\/ Default UI resource icon returned - it is not covered\n+                \/\/ by new implementation so we can not test it\n+                continue;\n+            }\n+\n+            ImageIcon icon = (ImageIcon) i;\n@@ -82,4 +93,0 @@\n-            if (icon == null) {\n-                throw new RuntimeException(\"icon is null!!!\");\n-            }\n-\n@@ -88,1 +95,2 @@\n-                        icon.getIconWidth() + \" when requested \" + size);\n+                        icon.getIconWidth() + \" when requested \" + size +\n+                         \" for file \" + file.getAbsolutePath());\n@@ -95,1 +103,1 @@\n-                            + size + \" in the multi resolution icon\");\n+                            + size + \" in the multi resolution icon \" + file.getAbsolutePath());\n@@ -99,1 +107,2 @@\n-                    throw new RuntimeException(\"icon is supposed to be multi-resolution but it is not\");\n+                    throw new RuntimeException(\"icon is supposed to be\" +\n+                            \" multi-resolution but it is not for \" + file.getAbsolutePath());\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSystemView\/SystemIconTest.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *      -XX:StartFlightRecording\n+ *      -XX:StartFlightRecording:jdk.ExecutionSample#enabled=false\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/log\/TestVerbosity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            \"RebuildFreeList\"\n+            \"RebuildFreeList\",\n+            \"SampleCandidates\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import java.io.File;\n-import java.nio.file.Paths;\n+import java.lang.ref.Reference;\n@@ -30,0 +29,1 @@\n+import jdk.jfr.Recording;\n@@ -31,1 +31,0 @@\n-import jdk.jfr.consumer.RecordingFile;\n@@ -33,0 +32,1 @@\n+import jdk.test.lib.jfr.EventNames;\n@@ -35,0 +35,2 @@\n+import sun.hotspot.WhiteBox;\n+\n@@ -38,0 +40,1 @@\n+ * @bug 8263461\n@@ -42,0 +45,1 @@\n+ * @requires vm.debug\n@@ -43,1 +47,6 @@\n- * @run main jdk.jfr.event.gc.detailed.TestEvacuationFailedEvent\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *          -Xmx32m -Xms32m -XX:+UnlockExperimentalVMOptions -XX:+G1EvacuationFailureALot\n+ *          -XX:G1EvacuationFailureALotCount=100 -XX:G1EvacuationFailureALotInterval=1\n+ *          -Xlog:gc=debug -XX:+UseG1GC jdk.jfr.event.gc.detailed.TestEvacuationFailedEvent\n@@ -45,0 +54,1 @@\n+\n@@ -47,3 +57,1 @@\n-    private final static String EVENT_SETTINGS_FILE = System.getProperty(\"test.src\", \".\") + File.separator + \"evacuationfailed-testsettings.jfc\";\n-    private final static String JFR_FILE = \"TestEvacuationFailedEvent.jfr\";\n-    private final static int BYTES_TO_ALLOCATE = 1024 * 512;\n+    private final static String EVENT_NAME = EventNames.EvacuationFailed;\n@@ -52,3 +60,4 @@\n-        String[] vmFlags = {\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseFastUnorderedTimeStamps\",\n-            \"-Xmx64m\", \"-Xmn60m\", \"-XX:-UseDynamicNumberOfGCThreads\", \"-XX:ParallelGCThreads=3\",\n-            \"-XX:MaxTenuringThreshold=0\", \"-Xlog:gc*=debug\", \"-XX:+UseG1GC\"};\n+        Recording recording = new Recording();\n+        \/\/ activate the event we are interested in and start recording\n+        recording.enable(EVENT_NAME);\n+        recording.start();\n@@ -56,4 +65,4 @@\n-        if (!ExecuteOOMApp.execute(EVENT_SETTINGS_FILE, JFR_FILE, vmFlags, BYTES_TO_ALLOCATE)) {\n-            System.out.println(\"OOM happened in the other thread(not test thread). Skip test.\");\n-            \/\/ Skip test, process terminates due to the OOME error in the different thread\n-            return;\n+        Object[] data = new Object[1024];\n+\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = new byte[5 * 1024];\n@@ -61,0 +70,6 @@\n+        \/\/ Guarantee one young gc.\n+        WhiteBox.getWhiteBox().youngGC();\n+        \/\/ Keep alive data.\n+        Reference.reachabilityFence(data);\n+\n+        recording.stop();\n@@ -62,1 +77,2 @@\n-        List<RecordedEvent> events = RecordingFile.readAllEvents(Paths.get(JFR_FILE));\n+        \/\/ Verify recording\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n@@ -72,0 +88,1 @@\n+        recording.close();\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n--->\n-<configuration version=\"2.0\" label=\"TestSettings\" description=\"Configuration for testing promotion failed event\" provider=\"Oracle\">\n-\n-    <event name=\"jdk.EvacuationFailed\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">0 ms<\/setting>\n-    <\/event>\n-<\/configuration>\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/evacuationfailed-testsettings.jfc","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.oldobject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm  -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectSize\n+ *\/\n+public class TestObjectSize {\n+\n+    private interface Leak {\n+    }\n+    private static class Leak1 implements Leak {\n+        private long field1;\n+    }\n+    private static class Leak2 implements Leak {\n+        private long field1;\n+        private long field2;\n+    }\n+    private static class Leak3 implements Leak {\n+        private long field1;\n+        private long field2;\n+        private long field3;\n+    }\n+\n+    public static List<Object> leak = new ArrayList<>(OldObjects.MIN_SIZE);\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+\n+        final Random rand = new Random(1L);\n+\n+        long sizeLeak1, sizeLeak2, sizeLeak3;\n+\n+        do {\n+            sizeLeak1 = -1;\n+            sizeLeak2 = -1;\n+            sizeLeak3 = -1;\n+\n+            try (Recording recording = new Recording()) {\n+                leak.clear();\n+                recording.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                recording.start();\n+\n+                for (int i = 0; i < 1000; i++) {\n+                    switch (rand.nextInt(3)) {\n+                    case 0: leak.add(new Leak1()); break;\n+                    case 1: leak.add(new Leak2()); break;\n+                    case 2: leak.add(new Leak3()); break;\n+                    }\n+                }\n+\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Events.hasEvents(events);\n+                for (RecordedEvent e : events) {\n+                    RecordedObject object = e.getValue(\"object\");\n+                    RecordedClass type = object.getValue(\"type\");\n+                    long objectSize = e.getLong(\"objectSize\");\n+                    System.err.println(\"type = \" + type.getName() + \", objectSize = \" + e.getLong(\"objectSize\"));\n+                    if (objectSize <= 0) {\n+                        throw new Exception(\"Object size for \" + type.getName() + \" is lower or equal to 0\");\n+                    }\n+                    if (type.getName().equals(Leak1.class.getName())) {\n+                        sizeLeak1 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak2.class.getName())) {\n+                        sizeLeak2 = objectSize;\n+                    }\n+                    if (type.getName().equals(Leak3.class.getName())) {\n+                        sizeLeak3 = objectSize;\n+                    }\n+                }\n+            }\n+        } while (sizeLeak1 == -1 || sizeLeak2 == -1 || sizeLeak3 == -1);\n+\n+        if (sizeLeak3 <= sizeLeak2) {\n+            throw new Exception(\"Object size for \" + Leak3.class.getName() + \" is lower or equal to size for\" + Leak2.class.getName());\n+        }\n+        if (sizeLeak2 <= sizeLeak1) {\n+            throw new Exception(\"Object size for \" + Leak2.class.getName() + \" is lower or equal to size for\" + Leak1.class.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectSize.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,305 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.runtime;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.*;\n-import java.util.concurrent.FutureTask;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UseBiasedLocking jdk.jfr.event.runtime.TestBiasedLockRevocationEvents\n- *\/\n-public class TestBiasedLockRevocationEvents {\n-\n-    public static void main(String[] args) throws Throwable {\n-        testSingleRevocation();\n-        testBulkRevocation();\n-        testSelfRevocation();\n-        testExitedThreadRevocation();\n-        testBulkRevocationNoRebias();\n-        testRevocationSafepointIdCorrelation();\n-    }\n-\n-    \/\/ Default value of BiasedLockingBulkRebiasThreshold is 20, and BiasedLockingBulkRevokeTreshold is 40.\n-    \/\/ Using a value that will hit the first threshold once, and the second one the next time.\n-    private static final int BULK_REVOKE_THRESHOLD = 25;\n-\n-    static void touch(Object lock) {\n-        synchronized(lock) {\n-        }\n-    }\n-\n-    static Thread triggerRevocation(int numRevokes, Class<?> lockClass) throws Throwable {\n-        Object[] locks = new Object[numRevokes];\n-        for (int i = 0; i < locks.length; ++i) {\n-            locks[i] = lockClass.getDeclaredConstructor().newInstance();\n-            touch(locks[i]);\n-        }\n-\n-        Thread biasBreaker = new Thread(\"BiasBreaker\") {\n-            @Override\n-            public void run() {\n-                for (Object lock : locks) {\n-                    touch(lock);\n-                }\n-            }\n-        };\n-\n-        biasBreaker.start();\n-        biasBreaker.join();\n-\n-        return biasBreaker;\n-    }\n-\n-    \/\/ Basic stack trace validation, checking the name of the leaf method\n-    static void validateStackTrace(RecordedStackTrace stackTrace, String leafMethodName) {\n-        List<RecordedFrame> frames = stackTrace.getFrames();\n-        Asserts.assertFalse(frames.isEmpty());\n-        String name = frames.get(0).getMethod().getName();\n-        Asserts.assertEquals(name, leafMethodName);\n-    }\n-\n-    \/\/ Validates that the given stack trace refers to lock.touch(); in triggerRevocation\n-    static void validateStackTrace(RecordedStackTrace stackTrace) {\n-        validateStackTrace(stackTrace, \"touch\");\n-    }\n-\n-    \/\/ Retrieve all biased lock revocation events related to the provided lock class, sorted by start time\n-    static List<RecordedEvent> getRevocationEvents(Recording recording, String eventTypeName, String fieldName, Class<?> lockClass) throws Throwable {\n-        return Events.fromRecording(recording).stream()\n-                .filter(e -> e.getEventType().getName().equals(eventTypeName))\n-                .filter(e -> ((RecordedClass)e.getValue(fieldName)).getName().equals(lockClass.getName()))\n-                .sorted(Comparator.comparing(RecordedEvent::getStartTime))\n-                .collect(Collectors.toList());\n-    }\n-\n-    static void testSingleRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(1, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertEventThread(event, \"previousOwner\", Thread.currentThread());\n-\n-        RecordedClass lockClass = event.getValue(\"lockClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, biasBreaker);\n-        Events.assertField(event, \"disableBiasing\").equal(false);\n-\n-        RecordedClass lockClass = event.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClass.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testSelfRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockSelfRevocation);\n-        recording.start();\n-\n-        MyLock l = new MyLock();\n-        touch(l);\n-        Thread.holdsLock(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockSelfRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-\n-        validateStackTrace(event.getStackTrace(), \"holdsLock\");\n-    }\n-\n-    static void testExitedThreadRevocation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockRevocation);\n-        recording.start();\n-\n-        FutureTask<MyLock> lockerTask = new FutureTask<>(() -> {\n-           MyLock l = new MyLock();\n-           touch(l);\n-           return l;\n-        });\n-\n-        Thread locker = new Thread(lockerTask, \"BiasLocker\");\n-        locker.start();\n-        locker.join();\n-\n-        \/\/ Even after joining, the VM has a bit more work to do before the thread is actually removed\n-        \/\/ from the threads list. Ensure that this has happened before proceeding.\n-        while (true) {\n-            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-            OutputAnalyzer oa = jcmd.execute(\"Thread.print\", true);\n-            String lockerThreadFound = oa.firstMatch(\"BiasLocker\");\n-            if (lockerThreadFound == null) {\n-                break;\n-            }\n-        };\n-\n-        MyLock l = lockerTask.get();\n-        touch(l);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockRevocation, \"lockClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 1);\n-\n-        RecordedEvent event = events.get(0);\n-        Events.assertEventThread(event, Thread.currentThread());\n-        \/\/ Previous owner will usually be null, but can also be a thread that\n-        \/\/ was created after the BiasLocker thread exited due to address reuse.\n-        RecordedThread prevOwner = event.getValue(\"previousOwner\");\n-        if (prevOwner != null) {\n-            Asserts.assertNE(prevOwner.getJavaName(), \"BiasLocker\");\n-        }\n-        validateStackTrace(event.getStackTrace());\n-    }\n-\n-    static void testBulkRevocationNoRebias() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.start();\n-\n-        Thread biasBreaker0 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-        Thread biasBreaker1 = triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = getRevocationEvents(recording, EventNames.BiasedLockClassRevocation, \"revokedClass\", MyLock.class);\n-        Asserts.assertEQ(events.size(), 2);\n-\n-        \/\/ The rebias event should occur before the noRebias one\n-        RecordedEvent eventRebias = events.get(0);\n-        RecordedEvent eventNoRebias = events.get(1);\n-\n-        Events.assertEventThread(eventRebias, biasBreaker0);\n-        Events.assertField(eventRebias, \"disableBiasing\").equal(false);\n-\n-        Events.assertEventThread(eventNoRebias, biasBreaker1);\n-        Events.assertField(eventNoRebias, \"disableBiasing\").equal(true);\n-\n-        RecordedClass lockClassRebias = eventRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassRebias.getName(), MyLock.class.getName());\n-        RecordedClass lockClassNoRebias = eventNoRebias.getValue(\"revokedClass\");\n-        Asserts.assertEquals(lockClassNoRebias.getName(), MyLock.class.getName());\n-\n-        validateStackTrace(eventRebias.getStackTrace());\n-        validateStackTrace(eventNoRebias.getStackTrace());\n-    }\n-\n-    static void testRevocationSafepointIdCorrelation() throws Throwable {\n-        class MyLock {};\n-\n-        Recording recording = new Recording();\n-\n-        recording.enable(EventNames.BiasedLockClassRevocation);\n-        recording.enable(EventNames.ExecuteVMOperation);\n-        recording.start();\n-\n-        triggerRevocation(BULK_REVOKE_THRESHOLD, MyLock.class);\n-\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-\n-        \/\/ Determine which safepoints included bulk revocation VM operations\n-        Set<Long> vmOperationsBulk = new HashSet<>();\n-\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.ExecuteVMOperation)) {\n-                String operation = event.getValue(\"operation\");\n-                Long safepointId = event.getValue(\"safepointId\");\n-\n-                if (operation.equals(\"BulkRevokeBias\")) {\n-                    vmOperationsBulk.add(safepointId);\n-                }\n-            }\n-        }\n-\n-        int bulkRevokeCount = 0;\n-\n-        \/\/ Match all revoke events to a corresponding VMOperation event\n-        for (RecordedEvent event : events) {\n-            if (event.getEventType().getName().equals(EventNames.BiasedLockClassRevocation)) {\n-                Long safepointId = event.getValue(\"safepointId\");\n-                String lockClass = ((RecordedClass)event.getValue(\"revokedClass\")).getName();\n-                if (lockClass.toString().equals(MyLock.class.getName())) {\n-                    Asserts.assertTrue(vmOperationsBulk.contains(safepointId));\n-                    bulkRevokeCount++;\n-                }\n-            }\n-        }\n-\n-        Asserts.assertGT(bulkRevokeCount, 0);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBiasedLockRevocationEvents.java","additions":0,"deletions":305,"binary":false,"changes":305,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.stop\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdStopWithoutFilename\n+ *\/\n+public class TestJcmdStopWithoutFilename {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        JcmdHelper.jcmd(\"JFR.start name=test\");\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldNotContain(\"written to\");\n+\n+        String filename = \"output.jfr\";\n+        JcmdHelper.jcmd(\"JFR.start name=test filename=\" + filename);\n+        output = JcmdHelper.jcmd(\"JFR.stop name=test\");\n+        output.shouldContain(\"written to\").shouldContain(filename);\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdStopWithoutFilename.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * @test\n+ * @bug 8190753 8011146\n+ * @summary Verify that using zip filesystem for opening an outputstream for a zip entry whose\n+ * compressed size is large, doesn't run into \"Negative initial size\" exception\n+ * @run testng\/manual\/othervm LargeCompressedEntrySizeTest\n+ *\/\n+public class LargeCompressedEntrySizeTest {\n+\n+    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n+    private static final String ZIP_FILE_NAME = \"8190753-test-compressed-size.zip\";\n+\n+    @BeforeMethod\n+    public void setUp() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    \/**\n+     * Delete the files created for use by the test\n+     *\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n+    }\n+\n+\n+    \/**\n+     * Using zip filesystem, creates a zip file and writes out a zip entry whose compressed size is\n+     * expected to be greater than 2gb.\n+     *\/\n+    @Test\n+    public void testLargeCompressedSizeWithZipFS() throws Exception {\n+        final Path zipFile = Path.of(ZIP_FILE_NAME);\n+        final long largeEntrySize = 6L * 1024L * 1024L * 1024L; \/\/ large value which exceeds Integer.MAX_VALUE\n+        try (FileSystem fs = FileSystems.newFileSystem(zipFile, Collections.singletonMap(\"create\", \"true\"))) {\n+            try (OutputStream os = Files.newOutputStream(fs.getPath(LARGE_FILE_NAME))) {\n+                long remaining = largeEntrySize;\n+                \/\/ create a chunk of random bytes which we keep writing out\n+                final int chunkSize = 102400;\n+                final byte[] chunk = new byte[chunkSize];\n+                new Random().nextBytes(chunk);\n+                final long start = System.currentTimeMillis();\n+                for (long l = 0; l < largeEntrySize; l += chunkSize) {\n+                    final int numToWrite = (int) Math.min(remaining, chunkSize);\n+                    os.write(chunk, 0, numToWrite);\n+                    remaining -= numToWrite;\n+                }\n+                System.out.println(\"Took \" + TimeUnit.SECONDS.toSeconds(System.currentTimeMillis() - start)\n+                        + \" seconds to generate entry of size \" + largeEntrySize);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeCompressedEntrySizeTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Random;\n+\n+\n+\/**\n+ * @test\n+ * @summary Verify that the outputstream created for zip file entries, through the ZipFileSystem\n+ * works fine for varying sizes of the zip file entries\n+ * @bug 8190753 8011146\n+ * @run testng\/timeout=300 ZipFSOutputStreamTest\n+ *\/\n+public class ZipFSOutputStreamTest {\n+    \/\/ List of files to be added to the ZIP file along with their sizes in bytes\n+    private static final Map<String, Long> ZIP_ENTRIES = Map.of(\n+            \"f1\", Integer.MAX_VALUE + 1L, \/\/ a value which when cast to an integer, becomes a negative value\n+            \"f2\", 25L * 1024L * 1024L, \/\/ 25 MB\n+            \"d1\/f3\", 1234L,\n+            \"d1\/d2\/f4\", 0L);\n+\n+    private static final Path ZIP_FILE = Path.of(\"zipfs-outputstream-test.zip\");\n+\n+    @BeforeMethod\n+    public void setUp() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() throws IOException {\n+        deleteFiles();\n+    }\n+\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n+\n+    @DataProvider(name = \"zipFSCreationEnv\")\n+    private Object[][] zipFSCreationEnv() {\n+        return new Object[][]{\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"true\")}, \/\/ STORED\n+                {Map.of(\"create\", \"true\", \"noCompression\", \"false\")} \/\/ DEFLATED\n+\n+        };\n+    }\n+\n+    \/**\n+     * Create a zip filesystem and write out entries of varying sizes using the outputstream returned\n+     * by the ZipFileSystem. Then verify that the generated zip file entries are as expected,\n+     * both in size and content\n+     *\/\n+    @Test(dataProvider = \"zipFSCreationEnv\")\n+    public void testOutputStream(final Map<String, ?> env) throws Exception {\n+        final byte[] chunk = new byte[1024];\n+        new Random().nextBytes(chunk);\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE, env)) {\n+            \/\/ create the zip with varying sized entries\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                if (entryPath.getParent() != null) {\n+                    Files.createDirectories(entryPath.getParent());\n+                }\n+                try (final OutputStream os = Files.newOutputStream(entryPath)) {\n+                    writeAsChunks(os, chunk, entry.getValue());\n+                }\n+            }\n+        }\n+        \/\/ now verify the written content\n+        try (final FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE)) {\n+            for (final Map.Entry<String, Long> entry : ZIP_ENTRIES.entrySet()) {\n+                final Path entryPath = zipfs.getPath(entry.getKey());\n+                try (final InputStream is = Files.newInputStream(entryPath)) {\n+                    final byte[] buf = new byte[chunk.length];\n+                    int numRead;\n+                    long totalRead = 0;\n+                    while ((numRead = is.read(buf)) != -1) {\n+                        totalRead += numRead;\n+                        \/\/ verify the content\n+                        for (int i = 0, chunkoffset = (int) ((totalRead - numRead) % chunk.length);\n+                             i < numRead; i++, chunkoffset++) {\n+                            Assert.assertEquals(buf[i], chunk[chunkoffset % chunk.length],\n+                                    \"Unexpected content in \" + entryPath);\n+                        }\n+                    }\n+                    Assert.assertEquals(totalRead, (long) entry.getValue(),\n+                            \"Unexpected number of bytes read from zip entry \" + entryPath);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Repeatedly writes out to the outputstream, the chunk of data, till the number of bytes\n+     * written to the stream equals the totalSize\n+     *\/\n+    private static void writeAsChunks(final OutputStream os, final byte[] chunk,\n+                                      final long totalSize) throws IOException {\n+        long remaining = totalSize;\n+        for (long l = 0; l < totalSize; l += chunk.length) {\n+            final int numToWrite = (int) Math.min(remaining, chunk.length);\n+            os.write(chunk, 0, numToWrite);\n+            remaining -= numToWrite;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSOutputStreamTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,7 +35,18 @@\n- *  Class 2:\n- *      https:\/\/valid.domainplus.ca22.ssl.buypass.no\/CA2Class2   (valid)\n- *      https:\/\/revoked.domainplus.ca22.ssl.buypass.no        (revoked)\n- *\n- *  Class3:\n- *      https:\/\/valid.business.ca23.ssl.buypass.no    (valid)\n- *      https:\/\/revoked.business.ca23.ssl.buypass.no    (revoked)\n+ *  Buypass Class 3 CA 2\n+ *  https:\/\/valid.qcevident.ca23.ssl.buypass.no\/\n+ *  https:\/\/revoked.qcevident.ca23.ssl.buypass.no\/\n+ *  https:\/\/expired.qcevident.ca23.ssl.buypass.no\/\n+ *  https:\/\/valid.evident.ca23.ssl.buypass.no\/\n+ *  https:\/\/revoked.evident.ca23.ssl.buypass.no\/\n+ *  https:\/\/expired.evident.ca23.ssl.buypass.no\/\n+ *  https:\/\/valid.businessplus.ca23.ssl.buypass.no\n+ *  https:\/\/revoked.businessplus.ca23.ssl.buypass.no\n+ *  https:\/\/expired.businessplus.ca23.ssl.buypass.no\n+\n+ *  Buypass Class 2 CA 2\n+ *  https:\/\/valid.business.ca22.ssl.buypass.no\n+ *  https:\/\/revoked.business.ca22.ssl.buypass.no\n+ *  https:\/\/expired.business.ca22.ssl.buypass.no\n+ *  https:\/\/valid.domain.ca22.ssl.buypass.no\n+ *  https:\/\/revoked.domain.ca22.ssl.buypass.no\n+ *  https:\/\/expired.domain.ca22.ssl.buypass.no\/\n@@ -68,29 +79,32 @@\n-    private static final String INT_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIFCzCCAvOgAwIBAgIBGDANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd\\n\"\n-            + \"MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg\\n\"\n-            + \"Q2xhc3MgMiBSb290IENBMB4XDTEwMTAyNjEwMTYxN1oXDTMwMTAyNjEwMTYxN1ow\\n\"\n-            + \"SzELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MR0w\\n\"\n-            + \"GwYDVQQDDBRCdXlwYXNzIENsYXNzIDIgQ0EgMjCCASIwDQYJKoZIhvcNAQEBBQAD\\n\"\n-            + \"ggEPADCCAQoCggEBAJyrZ8aWSw0PkdLsyswzK\/Ny\/A5\/uU6EqQ99c6omDMpI+yNo\\n\"\n-            + \"HjUO42ryrATs4YHla+xj+MieWyvz9HYaCnrGL0CE4oX8M7WzD+g8h6tUCS0AakJx\\n\"\n-            + \"dC5PBocUkjQGZ5ZAoF92ms6C99qfQXhHx7lBP\/AZT8sCWP0chOf9\/cNxCplspYVJ\\n\"\n-            + \"HkQjKN3VGa+JISavCcBqf33ihbPZ+RaLjOTxoaRaWTvlkFxHqsaZ3AsW71qSJwaE\\n\"\n-            + \"55l9\/qH45vn5mPrHQJ8h5LjgQcN5KBmxUMoA2iT\/VSLThgcgl+Iklbcv9rs6aaMC\\n\"\n-            + \"JH+zKbub+RyRijmyzD9YBr+ZTaowHvJs9G59uZMCAwEAAaOB9jCB8zAPBgNVHRMB\\n\"\n-            + \"Af8EBTADAQH\/MB8GA1UdIwQYMBaAFMmAd+BikoL1RpzzuvdMw964o605MB0GA1Ud\\n\"\n-            + \"DgQWBBSSrWWJsgAPy1ENwSPslE6PwQQ\/dzAOBgNVHQ8BAf8EBAMCAQYwEQYDVR0g\\n\"\n-            + \"BAowCDAGBgRVHSAAMD0GA1UdHwQ2MDQwMqAwoC6GLGh0dHA6Ly9jcmwuYnV5cGFz\\n\"\n-            + \"cy5uby9jcmwvQlBDbGFzczJSb290Q0EuY3JsMD4GCCsGAQUFBwEBBDIwMDAuBggr\\n\"\n-            + \"BgEFBQcwAYYiaHR0cDovL29jc3AuYnV5cGFzcy5uby9vY3NwL0JQT2NzcDANBgkq\\n\"\n-            + \"hkiG9w0BAQsFAAOCAgEAq8IVUouNdeHQljyp8xpa9GC7rpSRXGRRTolSXNa9TUfU\\n\"\n-            + \"48Z0Vj3x9jT58I+I8P7fKp+p4Wdu0kcwxOXsooP8hdGLqXY4nV9amkNRiTs99xa3\\n\"\n-            + \"Qu\/KdLeAPEeeKztxDCLXGmsC4+1G6DuDrOkwSm9Tm+HxSZRGR4Qo3mU3CCSz37us\\n\"\n-            + \"q7I0mnY4cCeBPQ3zW5J7k7KmMpUlxOPnLpaASY2JhoeiWIWddH6LUsMkZk1jDv+M\\n\"\n-            + \"Hyw2JWZUEUMCZoxLZ7F+4xP7v8wcEtICFo6tZIaawq9p\/S6+mJLcoQ7wdQBM0+NA\\n\"\n-            + \"cc1MnSbPz75WP4cFhVf1SFq5gBBMCgzYaw+A9bJxDgqV3IMG6TtWfOWz7KhMV+EL\\n\"\n-            + \"iVp0fXua2GITRwr+htWnID3ShbHOtCMUm9qrqC6aWNPvJqqKLdhgU9bQ\/s5o05a0\\n\"\n-            + \"D8NFT07l8yY6+ge+PPHOidnZrTNFIF9dtEdtyXGNrcqhZF0QvqeV1yZ\/Kf2+W4pa\\n\"\n-            + \"Wor82CuDZNfcf0lje3guk+oZexxpIO57eGJQh9iGLM5dBeEMF7+f5j\/1\/rGsf6vA\\n\"\n-            + \"KkudpjiTl1v\/GoO2zMDTTQVcjEsLSYSV0+s2p5QTXuAXrL0\/ER3KQRvewIAtmzFg\\n\"\n-            + \"IaPy7t2TV0olHISRMvaEz4Guh2biuO\/N6SP3pkk3dsMxiEVw7Xc+ouCb03Rz3aA=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 1b781c6d5e34ce1f77\n+    \/\/ Valid from: Mon Mar 25 05:17:10 PDT 2019 until: Sat Oct 26 02:16:17 PDT 2030\n+    private static final String INT_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIFKTCCAxGgAwIBAgIJG3gcbV40zh93MA0GCSqGSIb3DQEBCwUAME4xCzAJBgNV\\n\" +\n+            \"BAYTAk5PMR0wGwYDVQQKDBRCdXlwYXNzIEFTLTk4MzE2MzMyNzEgMB4GA1UEAwwX\\n\" +\n+            \"QnV5cGFzcyBDbGFzcyAyIFJvb3QgQ0EwHhcNMTkwMzI1MTIxNzEwWhcNMzAxMDI2\\n\" +\n+            \"MDkxNjE3WjBLMQswCQYDVQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMx\\n\" +\n+            \"NjMzMjcxHTAbBgNVBAMMFEJ1eXBhc3MgQ2xhc3MgMiBDQSAyMIIBIjANBgkqhkiG\\n\" +\n+            \"9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnKtnxpZLDQ+R0uzKzDMr83L8Dn+5ToSpD31z\\n\" +\n+            \"qiYMykj7I2geNQ7javKsBOzhgeVr7GP4yJ5bK\/P0dhoKesYvQITihfwztbMP6DyH\\n\" +\n+            \"q1QJLQBqQnF0Lk8GhxSSNAZnlkCgX3aazoL32p9BeEfHuUE\/8BlPywJY\/RyE5\/39\\n\" +\n+            \"w3EKmWylhUkeRCMo3dUZr4khJq8JwGp\/feKFs9n5FouM5PGhpFpZO+WQXEeqxpnc\\n\" +\n+            \"CxbvWpInBoTnmX3+ofjm+fmY+sdAnyHkuOBBw3koGbFQygDaJP9VItOGByCX4iSV\\n\" +\n+            \"ty\/2uzppowIkf7Mpu5v5HJGKObLMP1gGv5lNqjAe8mz0bn25kwIDAQABo4IBCzCC\\n\" +\n+            \"AQcwDwYDVR0TAQH\/BAUwAwEB\/zAfBgNVHSMEGDAWgBTJgHfgYpKC9Uac87r3TMPe\\n\" +\n+            \"uKOtOTAdBgNVHQ4EFgQUkq1libIAD8tRDcEj7JROj8EEP3cwDgYDVR0PAQH\/BAQD\\n\" +\n+            \"AgEGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjARBgNVHSAECjAIMAYG\\n\" +\n+            \"BFUdIAAwPQYDVR0fBDYwNDAyoDCgLoYsaHR0cDovL2NybC5idXlwYXNzLm5vL2Ny\\n\" +\n+            \"bC9CUENsYXNzMlJvb3RDQS5jcmwwMwYIKwYBBQUHAQEEJzAlMCMGCCsGAQUFBzAB\\n\" +\n+            \"hhdodHRwOi8vb2NzcC5idXlwYXNzLmNvbTANBgkqhkiG9w0BAQsFAAOCAgEApNka\\n\" +\n+            \"48a+qhJXXS9R24p34CWnirlyxPMhxFfQyvPFXnwBQGHvrm7H5KY3\/9\/etShFXdY\/\\n\" +\n+            \"N05Aq6UnE8my8jR4iHMm2e9iEf4v+O2E2JGH\/5\/H8wup160GBAsp4zAmJIT8KEgh\\n\" +\n+            \"YAA1j+NaClVryZfEaaDfAdF6LbU3cW0ZgooILPMeeCEXso23KsdCD1Q+SMvD6nQJ\\n\" +\n+            \"86iTvzWPY2GFJyEmvG\/N2f29nBaHxWwZBwCfWB4Hqsw9wdKfY5M9SE\/AGSLZ7LRM\\n\" +\n+            \"BmkkF9nqkWxxISadx12nbxn0LsU2k8Xyt830DqhHGSoYHEC\/iGxbU4Bub8NC0uw\/\\n\" +\n+            \"QNBj5Gd5cXLFhRUWLLBTq4p6P6kLc7JudpM4FNQ+stWK\/eDZylbDLN3iCBRnHH4p\\n\" +\n+            \"qg6HAlWuieiAKVsidBMxPUyDLJ\/8Dt+aW8Z3vCNcYC2n7wqrLZz5e4FG+Wn9teFW\\n\" +\n+            \"Rt5pO6ZUZAkDS59ZVojbbjOdQzNw3QHtZl0IMHeNYXJlPIUlHi4hGL3maGZ9sBF+\\n\" +\n+            \"AMfMLDu56+J2DewIuTXPzCeJeSTam\/ybNt5FxTznxCSCIDqwmZMy3AQEz9nGSbE8\\n\" +\n+            \"zfwB5VT2ijLB0PpPX4YbLf33Vodf0NAkBUv6N5It30XiTUPhdk+caBYPoljz\/J9U\\n\" +\n+            \"15T5+EGHs8ccHQWyYQ6gqYk8o4JgP4rSJqO1sMI=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -98,1 +112,1 @@\n-    \/\/ Owner: CN=valid.domainplus.ca22.ssl.buypass.no\n+    \/\/ Owner: CN=valid.domain.ca22.ssl.buypass.no\n@@ -100,29 +114,36 @@\n-    \/\/ Serial number: f0673c7183c95b38c93\n-    \/\/ Valid from: Mon Jan 25 00:20:55 PST 2016 until: Fri Jan 25 14:59:00 PST 2019\n-    private static final String VALID_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIEgzCCA2ugAwIBAgIKDwZzxxg8lbOMkzANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\"\n-            + \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\"\n-            + \"FEJ1eXBhc3MgQ2xhc3MgMiBDQSAyMB4XDTE2MDEyNTA4MjA1NVoXDTE5MDEyNTIy\\n\"\n-            + \"NTkwMFowLzEtMCsGA1UEAwwkdmFsaWQuZG9tYWlucGx1cy5jYTIyLnNzbC5idXlw\\n\"\n-            + \"YXNzLm5vMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwhA0eVz8ADqx\\n\"\n-            + \"dcrIZUzCf1n+kaBFyEF4WteUMtM4ta7szTm19f1\/O4LRwr+pI5qQDgWHnHMX9sit\\n\"\n-            + \"rKOJPfMRgWrViaQ5y9QCZ4h2BIuDe61XVGkEcUiOoNojLRvDrbjpknI69nb1wbjn\\n\"\n-            + \"fpmCQVjYXoandr7RsexdWG4e+s6rk5Jk\/zAUzU3Vbi0lmDJ62Dd+Dk3\/IVrSebOp\\n\"\n-            + \"eIDniRX4vjIeucnDDTQ1VqSIN+gYNR\/bMxXKFbScGAG+BpgZMwetJBJhTi7zlOgR\\n\"\n-            + \"4zAtdvvpJNN1pmNCsmJaM25WQgH6a05cTQtgYN\/\/MKqTDww7z+LfK37mOxh3vBTu\\n\"\n-            + \"TR5S6VxzQQIDAQABo4IBgzCCAX8wCQYDVR0TBAIwADAfBgNVHSMEGDAWgBSSrWWJ\\n\"\n-            + \"sgAPy1ENwSPslE6PwQQ\/dzAdBgNVHQ4EFgQUIs9OWkfc6S1c8mbYgi6Ns1kzh0Mw\\n\"\n-            + \"DgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAf\\n\"\n-            + \"BgNVHSAEGDAWMAoGCGCEQgEaAQIEMAgGBmeBDAECATA6BgNVHR8EMzAxMC+gLaAr\\n\"\n-            + \"hilodHRwOi8vY3JsLmJ1eXBhc3Mubm8vY3JsL0JQQ2xhc3MyQ0EyLmNybDAvBgNV\\n\"\n-            + \"HREEKDAmgiR2YWxpZC5kb21haW5wbHVzLmNhMjIuc3NsLmJ1eXBhc3Mubm8wdQYI\\n\"\n-            + \"KwYBBQUHAQEEaTBnMC4GCCsGAQUFBzABhiJodHRwOi8vb2NzcC5idXlwYXNzLm5v\\n\"\n-            + \"L29jc3AvQlBPY3NwMDUGCCsGAQUFBzAChilodHRwOi8vY3J0LmJ1eXBhc3Mubm8v\\n\"\n-            + \"Y3J0L0JQQ2xhc3MyQ0EyLmNlcjANBgkqhkiG9w0BAQsFAAOCAQEAjDPxDQnnzH+v\\n\"\n-            + \"Mnj8dRM6NPBVXl4JNofWlwqzYdu+HauFeF3AOZVVyr\/YbOR9\/ewDrScOvrGohndV\\n\"\n-            + \"7Si0l5hz3fo51Ra81TyR8kWR7nJC2joidT1X4a0hF9zu8CNQNVmkOhoACgeuv42R\\n\"\n-            + \"NDwmj9TfpNRyC4RA7\/NzXMeRJYfOrh18S9VHhCzsWScd9td3u7hrhBOPPOql9f2K\\n\"\n-            + \"t9Hcevo+cceE6bGYwbW6xNr3iPOh31shMxgRUMojVamtH70tYMi+0e0lrzXdxgGO\\n\"\n-            + \"ISnXBS2HptakUIxF3feTOjBhhh5vb9RJxfdJA\/\/\/ggkR3L51MfjrusucpNoz3k3P\\n\"\n-            + \"f5e7ZlSJ6g==\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 34e2bff8063debd18d79\n+    \/\/ Valid from: Mon Sep 23 04:12:34 PDT 2019 until: Mon Oct 11 14:59:00 PDT 2021\n+    private static final String VALID_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIF8jCCBNqgAwIBAgIKNOK\/+AY969GNeTANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\" +\n+            \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\" +\n+            \"FEJ1eXBhc3MgQ2xhc3MgMiBDQSAyMB4XDTE5MDkyMzExMTIzNFoXDTIxMTAxMTIx\\n\" +\n+            \"NTkwMFowKzEpMCcGA1UEAwwgdmFsaWQuZG9tYWluLmNhMjIuc3NsLmJ1eXBhc3Mu\\n\" +\n+            \"bm8wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCeu\/8j7y55R3OucDek\\n\" +\n+            \"gtdoVOEJQb2XaCR4OwiRzn74hLYhKGdFmFwSp+bPCT62NzjdK1urVeKrCQdC1Gkm\\n\" +\n+            \"e7iSOsHHO5aC8oxkgdv8mwEwwvH7xHCcpEVLDlE5Oc0d4cS4QIwFAhNIC77slixL\\n\" +\n+            \"fEdupc5e8FfQf3MlnhX+8gpgRzTx3iw8sb3gUwi3+7PRommHOhC7Ll+iI9LiLODJ\\n\" +\n+            \"qrkHnCbM2HJMK+SGTOQ\/whiQwMCnkLaEG0WO1rYc4BGRGfFb8qmQWw\/tDKkEey7X\\n\" +\n+            \"nLIFHSC33OiexQshAwRIAE7r1h9gMY1aAAB2Uxwi9\/3l6fsd\/VPmK7s7lYTBsrpK\\n\" +\n+            \"r4bTAgMBAAGjggL2MIIC8jAJBgNVHRMEAjAAMB8GA1UdIwQYMBaAFJKtZYmyAA\/L\\n\" +\n+            \"UQ3BI+yUTo\/BBD93MB0GA1UdDgQWBBSy+COaEmU2\/BeF4g1OglFvAEYkIDAOBgNV\\n\" +\n+            \"HQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB8GA1Ud\\n\" +\n+            \"IAQYMBYwCgYIYIRCARoBAgQwCAYGZ4EMAQIBMDoGA1UdHwQzMDEwL6AtoCuGKWh0\\n\" +\n+            \"dHA6Ly9jcmwuYnV5cGFzcy5uby9jcmwvQlBDbGFzczJDQTIuY3JsMCsGA1UdEQQk\\n\" +\n+            \"MCKCIHZhbGlkLmRvbWFpbi5jYTIyLnNzbC5idXlwYXNzLm5vMGoGCCsGAQUFBwEB\\n\" +\n+            \"BF4wXDAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuYnV5cGFzcy5jb20wNQYIKwYB\\n\" +\n+            \"BQUHMAKGKWh0dHA6Ly9jcnQuYnV5cGFzcy5uby9jcnQvQlBDbGFzczJDQTIuY2Vy\\n\" +\n+            \"MIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdwC72d+8H4pxtZOUI5eqkntHOFeV\\n\" +\n+            \"CqtS6BqQlmQ2jh7RhQAAAW1d0tivAAAEAwBIMEYCIQDFRAH98gYpvMMTVa3d5Wcq\\n\" +\n+            \"0tOwpZZyUHiOjUlR3SD14QIhAKZp0cdwFpm+hh0taFVSTmluGsHmXPMCIQq9hLAB\\n\" +\n+            \"VYgyAHYApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFtXdLbFwAA\\n\" +\n+            \"BAMARzBFAiBhr7KQc9yO3zb1iLlE0JW9whR0\/bhrPDkk5BYnBKjzFAIhAMMTdHfk\\n\" +\n+            \"1ljso5jKzIUcBpSW0HnTcuKiB3VxGpL7GFVWAHUAb1N2rDHwMRnYmQCkURX\/dxUc\\n\" +\n+            \"EdkCwQApBo2yCJo32RMAAAFtXdLYSAAABAMARjBEAiADoZr6Cp5AGM1eT2aUeRaQ\\n\" +\n+            \"kv0vRaegjRGIhKRCvRGyFAIgWLU\/7zh28LI8vAyWr8mpDqlUXvF13i3zSD3whq4L\\n\" +\n+            \"Lu4wDQYJKoZIhvcNAQELBQADggEBAJH1RhTuMbhEOYlw+Efbx7PP7EEC\/GQ1ijET\\n\" +\n+            \"vZS45jFQyTKhFUcdP2QPAtEVo1nS8PBs0txQJBf0xceWUjer9ruxiAS+JlW21AOi\\n\" +\n+            \"Uq9Kahpj5k63Z7tN8KTeOUE8wZGmHyvVcPP6mkC94RbjYIb4gd13eYxd2Vv1a7YX\\n\" +\n+            \"dNI+J3g7sX5ijssfJxzDd0hORj2584YY2WiKKvIGxwDnLkxk09i3IvjEKsAi4Cgn\\n\" +\n+            \"5798X5sSL1Q9C6gHEWt+cB5UtfILCfbLNRczS9zGku6gjh1c8dB7zc63mn7oCf1C\\n\" +\n+            \"gnQ2xqwbZb3Wau8CPwcMqJWgQZLQFPbZd+4Xo5SDDqYppV4oN2A=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -130,1 +151,1 @@\n-    \/\/ Owner: CN=revoked.domainplus.ca22.ssl.buypass.no\n+    \/\/ Owner: CN=revoked.domain.ca22.ssl.buypass.no\n@@ -132,29 +153,36 @@\n-    \/\/ Serial number: f07a517dfc19ea8bf8f\n-    \/\/ Valid from: Mon Jan 25 00:22:09 PST 2016 until: Fri Jan 25 14:59:00 PST 2019\n-    private static final String REVOKED_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIEhzCCA2+gAwIBAgIKDwelF9\/Bnqi\/jzANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\"\n-            + \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\"\n-            + \"FEJ1eXBhc3MgQ2xhc3MgMiBDQSAyMB4XDTE2MDEyNTA4MjIwOVoXDTE5MDEyNTIy\\n\"\n-            + \"NTkwMFowMTEvMC0GA1UEAwwmcmV2b2tlZC5kb21haW5wbHVzLmNhMjIuc3NsLmJ1\\n\"\n-            + \"eXBhc3Mubm8wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDjp\/5BLRjH\\n\"\n-            + \"03XNNT2YXqg+txclRaUu88Rjbj4oEudFbkGTl+oBhmXX4QjM4WGvgw1AHW7nePWF\\n\"\n-            + \"\/j3aR1kWJCl\/ZOe097mb0V0dIwK6u6RVx9ERd4ITa\/cmUJjy1+D+vCsT0elJY1vf\\n\"\n-            + \"vbwCdaloS7MZDG3wmJGxrUz7fo7t\/JdsW481Ymau3xVTQ+45MusPmOE8RZ6nggIQ\\n\"\n-            + \"dZIA00XPhlQwg5ivuPwtcNNZIkk1fkU+5J+RUOI5qHA9zH2s1Hly6PzTATCxSDSi\\n\"\n-            + \"zqAmBH0ehrWqCWiKH5P3J8dCRA6qa2n5pD71CweLrUsbmztkBHUlYKlZ0fP6bGiI\\n\"\n-            + \"ZDMBLL\/aFQybAgMBAAGjggGFMIIBgTAJBgNVHRMEAjAAMB8GA1UdIwQYMBaAFJKt\\n\"\n-            + \"ZYmyAA\/LUQ3BI+yUTo\/BBD93MB0GA1UdDgQWBBQZICByGObE\/pJISOcMavbKRl2L\\n\"\n-            + \"+zAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC\\n\"\n-            + \"MB8GA1UdIAQYMBYwCgYIYIRCARoBAgQwCAYGZ4EMAQIBMDoGA1UdHwQzMDEwL6At\\n\"\n-            + \"oCuGKWh0dHA6Ly9jcmwuYnV5cGFzcy5uby9jcmwvQlBDbGFzczJDQTIuY3JsMDEG\\n\"\n-            + \"A1UdEQQqMCiCJnJldm9rZWQuZG9tYWlucGx1cy5jYTIyLnNzbC5idXlwYXNzLm5v\\n\"\n-            + \"MHUGCCsGAQUFBwEBBGkwZzAuBggrBgEFBQcwAYYiaHR0cDovL29jc3AuYnV5cGFz\\n\"\n-            + \"cy5uby9vY3NwL0JQT2NzcDA1BggrBgEFBQcwAoYpaHR0cDovL2NydC5idXlwYXNz\\n\"\n-            + \"Lm5vL2NydC9CUENsYXNzMkNBMi5jZXIwDQYJKoZIhvcNAQELBQADggEBAAdjMdlP\\n\"\n-            + \"qYNK+YkrqTgQV0dblIazL\/cIhMPByjnEkfxew9tDxpcMWafIFKcgM\/QxYJG\/mzoL\\n\"\n-            + \"sSQ9pzzuGLQX7eAPA3rlWoQBusOeOaC3HQqy73kGStd7H8HPa3m+q47Z6JG0w+Fb\\n\"\n-            + \"rk8odrml+8rAEPLBlldB39xJuNVHjmlyTEDSC4azEXjfV4+kj8uE86sm+AoTt4Ba\\n\"\n-            + \"tEZSbKp70oH63QKBAEHORMM4gXeP+WG276p3kTcL1VUfgQw7vVmGN0C8DjhK4BAC\\n\"\n-            + \"0PUChr8agu0F5YcqpGxjLemMnDrqW+Bi\/JYmGhEjWTiLSyYSlvJb1dAFUyPlc958\\n\"\n-            + \"pmOu5xTMEatiPFI=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 34e4b97261795f98c495\n+    \/\/ Valid from: Mon Sep 23 04:52:42 PDT 2019 until: Thu Sep 23 14:59:00 PDT 2021\n+    private static final String REVOKED_CLASS_2 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIF9zCCBN+gAwIBAgIKNOS5cmF5X5jElTANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\" +\n+            \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\" +\n+            \"FEJ1eXBhc3MgQ2xhc3MgMiBDQSAyMB4XDTE5MDkyMzExNTI0MloXDTIxMDkyMzIx\\n\" +\n+            \"NTkwMFowLTErMCkGA1UEAwwicmV2b2tlZC5kb21haW4uY2EyMi5zc2wuYnV5cGFz\\n\" +\n+            \"cy5ubzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOiChajGbQktGjbl\\n\" +\n+            \"k\/i5PtqfMN6cMyjJdOirxzXdUG8dT+QErC5zcElCwuyy5MH7DQJRbSYsPxQmr6z5\\n\" +\n+            \"OSheBxX0lPPLjJFfEafBZ+Fw1xmCVy3Xjt3GEl85iqv5y0\/E\/UlQPc0f7s6WxU0L\\n\" +\n+            \"cItkyN0rWAa+uQY018qDFn+gDYIKWPzTCf5nkXIgob\/IgBM1Bj7vSZ\/LI1iB+I+G\\n\" +\n+            \"dgLbSGBlJgK6lhCTc1tunZlSbKdPM2Th8Hbl6Uk7WormR\/8SrGQA9AAd7BWa43V5\\n\" +\n+            \"HHvf\/oArsx0afp3zXNiMw9RgHVHI5uUAzkNnL8NMUpI1sK7\/ndTlm0nXsHpPKrPo\\n\" +\n+            \"e+NpKaMCAwEAAaOCAvkwggL1MAkGA1UdEwQCMAAwHwYDVR0jBBgwFoAUkq1libIA\\n\" +\n+            \"D8tRDcEj7JROj8EEP3cwHQYDVR0OBBYEFDoBaIahoDhRhA3WVyT\/XukqZzmAMA4G\\n\" +\n+            \"A1UdDwEB\/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHwYD\\n\" +\n+            \"VR0gBBgwFjAKBghghEIBGgECBDAIBgZngQwBAgEwOgYDVR0fBDMwMTAvoC2gK4Yp\\n\" +\n+            \"aHR0cDovL2NybC5idXlwYXNzLm5vL2NybC9CUENsYXNzMkNBMi5jcmwwLQYDVR0R\\n\" +\n+            \"BCYwJIIicmV2b2tlZC5kb21haW4uY2EyMi5zc2wuYnV5cGFzcy5ubzBqBggrBgEF\\n\" +\n+            \"BQcBAQReMFwwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmJ1eXBhc3MuY29tMDUG\\n\" +\n+            \"CCsGAQUFBzAChilodHRwOi8vY3J0LmJ1eXBhc3Mubm8vY3J0L0JQQ2xhc3MyQ0Ey\\n\" +\n+            \"LmNlcjCCAX8GCisGAQQB1nkCBAIEggFvBIIBawFpAHYAu9nfvB+KcbWTlCOXqpJ7\\n\" +\n+            \"RzhXlQqrUugakJZkNo4e0YUAAAFtXfeApgAABAMARzBFAiARoEDgK57YWEW2R21d\\n\" +\n+            \"jFMphF5c9PypIwbZFHiWxdyCyAIhALsjjtPGgcrT\/7KebYFPuKDyQO6rc8YYvm0z\\n\" +\n+            \"Q+Xt7NhxAHYApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFtXfeD\\n\" +\n+            \"eQAABAMARzBFAiBCXKlCGkqa85QVqMR5dYDDz3F5aQgLXPubrQLX7cAZ0wIhALRr\\n\" +\n+            \"p8F6OfIdccSUhzEcNdtensQ\/7zxgn81bUzn1ar9EAHcAb1N2rDHwMRnYmQCkURX\/\\n\" +\n+            \"dxUcEdkCwQApBo2yCJo32RMAAAFtXfeBSQAABAMASDBGAiEAyrR31T85HGekHZdD\\n\" +\n+            \"r\/m6flxqQaUIGcAJ5WcrBuIBuYkCIQD0rDdm+vM5\/lNXIfjjrPLhATFEvrxpXJvu\\n\" +\n+            \"+sW4Ntm94jANBgkqhkiG9w0BAQsFAAOCAQEAjbMEFeNXFy3YQSr8O0+fY7qwaAzk\\n\" +\n+            \"vq65Ef\/B2zvqO375+JI21grUikmFUnDiAaM8Y+8PJkOXDiuxR2\/XCLsXpxCcPqQh\\n\" +\n+            \"V0MZlqXtjKZjBACILBX7aqGibojJTIlo0Dkd+LfPwswfXscTbb1CUXpUPn7CiUj5\\n\" +\n+            \"0WwfvjjQXny0NAB6WEkBMEBx6\/Q75dvltoV9N1BZVer9hov6UTDuSad86faX2QF2\\n\" +\n+            \"aIEjrTJY3m2HqnIYf\/lQxuDUDW0h7ddGGsIEBDM8z7M\/rvT068ssRqJ8uecGjMaz\\n\" +\n+            \"JElX8VDgMux2kyjTAiAFD5QO+KTfySri9QXptik3wo66zDOmkVES1snvVQ==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -170,1 +198,1 @@\n-                \"Mon Jan 25 00:24:47 PST 2016\", System.out);\n+                \"Mon Sep 23 04:53:18 PDT 2019\", System.out);\n@@ -178,29 +206,32 @@\n-    private static final String INT_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIFCzCCAvOgAwIBAgIBGDANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd\\n\"\n-            + \"MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg\\n\"\n-            + \"Q2xhc3MgMyBSb290IENBMB4XDTEwMTAyNjA5MTYxN1oXDTMwMTAyNjA5MTYxN1ow\\n\"\n-            + \"SzELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MR0w\\n\"\n-            + \"GwYDVQQDDBRCdXlwYXNzIENsYXNzIDMgQ0EgMjCCASIwDQYJKoZIhvcNAQEBBQAD\\n\"\n-            + \"ggEPADCCAQoCggEBAL1OFdoURRXuCuwTBJpuCKDE8Euzcg0AeCRGq3VdagbChyCE\\n\"\n-            + \"CQ5vYWwmpHCyFl1b+r2KyWdQBBdG+msAcIYZal5cjZzrTWvbkfiAD\/OneMjhqYB0\\n\"\n-            + \"pTQIXbTjpPUMOjFM8waNZcqGJqC9H+Z9NkjK5THAK0oOOfKNPHg1MeImbOHVw0fR\\n\"\n-            + \"48WnNrPpnQDt+SbPFSvw+dACDAybx1XgjMPq7pmZDWbkajOz4yCvrgZm6jvAPeT3\\n\"\n-            + \"qkBFh7zOZ3IZVdfmRjVahx0iXp5TJ1SsrRr\/uCiae1O+NR\/\/XDG3dl9j17HsFlhY\\n\"\n-            + \"Rl6EvEfVV0OcW94Ret9uBUF73ANZl0b+gwCXnV0CAwEAAaOB9jCB8zAPBgNVHRMB\\n\"\n-            + \"Af8EBTADAQH\/MB8GA1UdIwQYMBaAFEe4zf\/lb+74suwvTg75JbCOPGvDMB0GA1Ud\\n\"\n-            + \"DgQWBBQiMC7S+\/ZLysC4O9IExOly5pebDDAOBgNVHQ8BAf8EBAMCAQYwEQYDVR0g\\n\"\n-            + \"BAowCDAGBgRVHSAAMD0GA1UdHwQ2MDQwMqAwoC6GLGh0dHA6Ly9jcmwuYnV5cGFz\\n\"\n-            + \"cy5uby9jcmwvQlBDbGFzczNSb290Q0EuY3JsMD4GCCsGAQUFBwEBBDIwMDAuBggr\\n\"\n-            + \"BgEFBQcwAYYiaHR0cDovL29jc3AuYnV5cGFzcy5uby9vY3NwL0JQT2NzcDANBgkq\\n\"\n-            + \"hkiG9w0BAQsFAAOCAgEAaOLyxpj2t9k9Rzkxkcj\/teTNOWxBLPZDi+eFx3u7laf2\\n\"\n-            + \"mX\/ZUSSE4g7OiKnD7ozWk9Qgocn3rBWGDKsp676RwWV97Elofz73Oebei6P3Gg\/9\\n\"\n-            + \"CD8y6rf8xHRxru5d1ZQ1NkWdPwYI38jlt3LaDjJKZjJW7pOPIMRvw1Y1AY3mYgCJ\\n\"\n-            + \"Qqpw8jgukHIP0454DPzkUXzg\/ZVJG0swmFmjYfARleSPidcs5BJx5ngpcUS4745g\\n\"\n-            + \"mN9PQ578+ROIbML4Jx83myivlyTQSPdYSwzSswb1RVBJmiF9qC0B1hivCrs4BATu\\n\"\n-            + \"YeaPV6CiNDr0jGnbxAskz7QDNR6uJSUKX3L9iY2TB\/4\/5hJ9TZ\/YDI6OEG\/wVtBz\\n\"\n-            + \"5FkU0ucztyQa4UG1mXR8Zbs\/zt9Fj0Xn8f5IM3dB\/s\/r8c1AFDIcLRUqP\/LkI9Wj\\n\"\n-            + \"XovWr79PEJcIfIln0AfzYfBBxCRE+4QHcVhci6p\/mbyl2a+Rf8ZGNTiDLaWSZp5x\\n\"\n-            + \"jqdaq5UQaoZK8XQ+JVR0etep\/KPgVMXq5Zv16YEb2vjs\/\/RfxT8psDZLe\/37+Bs4\\n\"\n-            + \"AG9sdT\/bsH7HDQwodTon\/HvMmxt4EiU\/1Sjco4Fok9VmSE2UVjIghajbbTSKR3LV\\n\"\n-            + \"UuU19x12fKp+htO8L+wVlGgxXb9WvDBNHCe6RmR4jqavmvrAyCPtrx3cXwqGmXA=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 1be0dc6a3e7f220475\n+    \/\/ Valid from: Mon Mar 25 05:12:16 PDT 2019 until: Sat Oct 26 01:16:17 PDT 2030\n+    private static final String INT_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIFKTCCAxGgAwIBAgIJG+Dcaj5\/IgR1MA0GCSqGSIb3DQEBCwUAME4xCzAJBgNV\\n\" +\n+            \"BAYTAk5PMR0wGwYDVQQKDBRCdXlwYXNzIEFTLTk4MzE2MzMyNzEgMB4GA1UEAwwX\\n\" +\n+            \"QnV5cGFzcyBDbGFzcyAzIFJvb3QgQ0EwHhcNMTkwMzI1MTIxMjE2WhcNMzAxMDI2\\n\" +\n+            \"MDgxNjE3WjBLMQswCQYDVQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMx\\n\" +\n+            \"NjMzMjcxHTAbBgNVBAMMFEJ1eXBhc3MgQ2xhc3MgMyBDQSAyMIIBIjANBgkqhkiG\\n\" +\n+            \"9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvU4V2hRFFe4K7BMEmm4IoMTwS7NyDQB4JEar\\n\" +\n+            \"dV1qBsKHIIQJDm9hbCakcLIWXVv6vYrJZ1AEF0b6awBwhhlqXlyNnOtNa9uR+IAP\\n\" +\n+            \"86d4yOGpgHSlNAhdtOOk9Qw6MUzzBo1lyoYmoL0f5n02SMrlMcArSg458o08eDUx\\n\" +\n+            \"4iZs4dXDR9Hjxac2s+mdAO35Js8VK\/D50AIMDJvHVeCMw+rumZkNZuRqM7PjIK+u\\n\" +\n+            \"BmbqO8A95PeqQEWHvM5nchlV1+ZGNVqHHSJenlMnVKytGv+4KJp7U741H\/9cMbd2\\n\" +\n+            \"X2PXsewWWFhGXoS8R9VXQ5xb3hF6324FQXvcA1mXRv6DAJedXQIDAQABo4IBCzCC\\n\" +\n+            \"AQcwDwYDVR0TAQH\/BAUwAwEB\/zAfBgNVHSMEGDAWgBRHuM3\/5W\/u+LLsL04O+SWw\\n\" +\n+            \"jjxrwzAdBgNVHQ4EFgQUIjAu0vv2S8rAuDvSBMTpcuaXmwwwDgYDVR0PAQH\/BAQD\\n\" +\n+            \"AgEGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjARBgNVHSAECjAIMAYG\\n\" +\n+            \"BFUdIAAwPQYDVR0fBDYwNDAyoDCgLoYsaHR0cDovL2NybC5idXlwYXNzLm5vL2Ny\\n\" +\n+            \"bC9CUENsYXNzM1Jvb3RDQS5jcmwwMwYIKwYBBQUHAQEEJzAlMCMGCCsGAQUFBzAB\\n\" +\n+            \"hhdodHRwOi8vb2NzcC5idXlwYXNzLmNvbTANBgkqhkiG9w0BAQsFAAOCAgEAo42Y\\n\" +\n+            \"fp96nUiZbZsqvYBID3Sqtx3jJfU8gNHFeXgkS0pxYHHYUwsVSVRjw+BGVEGUswpF\\n\" +\n+            \"MaYMCZD37ZL0JpvvXWrCDaMb\/GqDJAQHLLTyVKPGGGIWCZH\/FrhnNvcpt2XXA8lU\\n\" +\n+            \"Ujzp5nZPuqvenzQ\/aXHI4sH5sN\/QjyKVMSa\/6RbWBeQmvIdgyM+0jIR5\/r6UGiKM\\n\" +\n+            \"ar55trZgnlIbvQJ\/w8QTmI\/NwvA5CtRaOslQBxeKoAR0BuA\/lRWnocXa\/BM5uO6P\\n\" +\n+            \"ULL7ct\/uI1bS+YThHXHmFybI6kDf+RhRzWY9165ZP96PBph6smQkxPDAz2b8v+mh\\n\" +\n+            \"LThH+5hkqnoetYfK2MdBYinceGPP3gZ+uBSDDI2o6vdVvdg7G96GP1OEtgTEqZa3\\n\" +\n+            \"glVafckpn\/8F5CisypdQuZ5zyy\/6SXZCKkPcikR87ysSKnjtteXbxMWVtwkeBALT\\n\" +\n+            \"K7DbJA+5aOCYRNj6CJGULQKiGlC01\/ipORKewf5J3yus81lLHzBmgQMA5l9RL8rV\\n\" +\n+            \"6dI246mPpQ+8WDLsDrK3ydSDv5izgdVHzhL0tT2u4vwSq2WUqCgi4xLIA1N\/fA2H\\n\" +\n+            \"xEW7zh0X\/3YVz++g\/6bd7iqRD9nRRZxACekRbza7AqU5xN1UjvVtCJQ9VC74K9KP\\n\" +\n+            \"pBoLWE2Bz5ksL9VUc4kS+WGORvZrSE1EpBq6cHc=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -208,2 +239,2 @@\n-    \/\/ Owner: SERIALNUMBER=983163327, CN=valid.business.ca23.ssl.buypass.no,\n-    \/\/ O=BUYPASS AS, L=OSLO, OID.2.5.4.17=0484, C=NO\n+    \/\/ Owner: SERIALNUMBER=983163327, CN=valid.businessplus.ca23.ssl.buypass.no, O=BUYPASS AS,\n+    \/\/ L=OSLO, OID.2.5.4.17=0484, C=NO\n@@ -211,30 +242,38 @@\n-    \/\/ Serial number: 97631b91e98293b35c8\n-    \/\/ Valid from: Fri Feb 06 00:57:04 PST 2015 until: Fri Feb 09 14:59:00 PST 2018\n-    private static final String VALID_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIE1DCCA7ygAwIBAgIKCXYxuR6YKTs1yDANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\"\n-            + \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\"\n-            + \"FEJ1eXBhc3MgQ2xhc3MgMyBDQSAyMB4XDTE1MDIwNjA4NTcwNFoXDTE4MDIwOTIy\\n\"\n-            + \"NTkwMFowgYExCzAJBgNVBAYTAk5PMQ0wCwYDVQQRDAQwNDg0MQ0wCwYDVQQHDARP\\n\"\n-            + \"U0xPMRMwEQYDVQQKDApCVVlQQVNTIEFTMSswKQYDVQQDDCJ2YWxpZC5idXNpbmVz\\n\"\n-            + \"cy5jYTIzLnNzbC5idXlwYXNzLm5vMRIwEAYDVQQFEwk5ODMxNjMzMjcwggEiMA0G\\n\"\n-            + \"CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCbahUoF2A7upqIxDQKraZ+aEOzNkHF\\n\"\n-            + \"1fIQEtUMQS1OTB8la7pWsBnv1gk9Ja2ifIrwdSxAjefL3SXR47h4vxUMnufMnkTk\\n\"\n-            + \"PERXft\/XR8\/jZQZRpznnN\/V89ctb8qcVhHCooTIELOBzF9QAmDnawZQogwhDNLNy\\n\"\n-            + \"kLtWsl75X547DS\/Z5hsqCqXPyOiFzkHY59uamYu48TF9d7HwQ741H0YhehoxTl\/O\\n\"\n-            + \"YqzW2wqYxqhQuCX5IuYER7G\/P3G6UAm+VB9aujtWW+TBT9+iWh0aT+C7ezDtREse\\n\"\n-            + \"lwb44svf8S3iW18KlSF8EMT0qwqNpA8njOCQiSgluYD+Uk9E5f8505UzAgMBAAGj\\n\"\n-            + \"ggGBMIIBfTAJBgNVHRMEAjAAMB8GA1UdIwQYMBaAFCIwLtL79kvKwLg70gTE6XLm\\n\"\n-            + \"l5sMMB0GA1UdDgQWBBQncKIaP6HdQV8RIBO+dddWDSKvJjAOBgNVHQ8BAf8EBAMC\\n\"\n-            + \"BaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB8GA1UdIAQYMBYwCgYI\\n\"\n-            + \"YIRCARoBAwQwCAYGZ4EMAQICMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHA6Ly9jcmwu\\n\"\n-            + \"YnV5cGFzcy5uby9jcmwvQlBDbGFzczNDQTIuY3JsMC0GA1UdEQQmMCSCInZhbGlk\\n\"\n-            + \"LmJ1c2luZXNzLmNhMjMuc3NsLmJ1eXBhc3Mubm8wdQYIKwYBBQUHAQEEaTBnMC4G\\n\"\n-            + \"CCsGAQUFBzABhiJodHRwOi8vb2NzcC5idXlwYXNzLm5vL29jc3AvQlBPY3NwMDUG\\n\"\n-            + \"CCsGAQUFBzAChilodHRwOi8vY3J0LmJ1eXBhc3Mubm8vY3J0L0JQQ2xhc3MzQ0Ey\\n\"\n-            + \"LmNlcjANBgkqhkiG9w0BAQsFAAOCAQEAqeA3IqMPn\/az52twbNnimXIhIb7tWj7U\\n\"\n-            + \"NSBqr+httoQvNo7NbtVCgO\/fM3\/t0YN7rgZfP07QTn7L7CwoddrgHbnuCuFr9UhD\\n\"\n-            + \"df7cfY3cwDhWx+YKgXTkRZpXXrOPqeY2+9gaJlcQCnw66t5EBa4lSBnN0ZtkB4lT\\n\"\n-            + \"ujFP6BAyzZAjRdXWUidtErDWZri1uLmWAP0kQNez2toOcQ0XpbrbL8+nQtvOVOJv\\n\"\n-            + \"b\/c8WoaoC14C32mAeC5bx4dQ3mpf3hQv9man1SPjY\/rsDsWWjsaJAijl3YPtP2bU\\n\"\n-            + \"JRCCM7qfZWrY8\/uBLG2llfjviKV9I6sT76w7TnawPsz+SkDXFm\/nwg==\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 267b7a9f0c3da9b94b39\n+    \/\/ Valid from: Mon Sep 23 04:17:42 PDT 2019 until: Mon Oct 11 14:59:00 PDT 2021\n+    private static final String VALID_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGUTCCBTmgAwIBAgIKJnt6nww9qblLOTANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\" +\n+            \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\" +\n+            \"FEJ1eXBhc3MgQ2xhc3MgMyBDQSAyMB4XDTE5MDkyMzExMTc0MloXDTIxMTAxMTIx\\n\" +\n+            \"NTkwMFowgYUxCzAJBgNVBAYTAk5PMQ0wCwYDVQQRDAQwNDg0MQ0wCwYDVQQHDARP\\n\" +\n+            \"U0xPMRMwEQYDVQQKDApCVVlQQVNTIEFTMS8wLQYDVQQDDCZ2YWxpZC5idXNpbmVz\\n\" +\n+            \"c3BsdXMuY2EyMy5zc2wuYnV5cGFzcy5ubzESMBAGA1UEBRMJOTgzMTYzMzI3MIIB\\n\" +\n+            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArqj6dPVIQUULBV\/S+u2\/Rfko\\n\" +\n+            \"3BljX\/KMEAclJHPu6AbJ2Dw5oLqCynOfTwLmGl3IRBQuDUAuoLdaptIhaXR2VTsF\\n\" +\n+            \"8SWdHNXkykC2eD0XkAUdTuKgRm\/3U4f0T3XQsjwKOEQGECwGEWJekBL73retSRWe\\n\" +\n+            \"Ccc19NpSKZ5rmRnQSlKLfqUyihmw2xXmIWwEmBq0OOyG8ic3C11Zxh6yUOtlZJqB\\n\" +\n+            \"lWqbAAOK5SXTNV0qozwgkSvtAtJvUo2++rng35Oj8MvjKQjLi92NnSpjbj3rUivW\\n\" +\n+            \"++44X94IgoF9dITkSMnubXhaTLnciM08R8jmCFj877NRrVJRmcJhPfP1yHnR3wID\\n\" +\n+            \"AQABo4IC+jCCAvYwCQYDVR0TBAIwADAfBgNVHSMEGDAWgBQiMC7S+\/ZLysC4O9IE\\n\" +\n+            \"xOly5pebDDAdBgNVHQ4EFgQUKJCKAxRR7K6pedVONDSn58EOzQcwDgYDVR0PAQH\/\\n\" +\n+            \"BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAfBgNVHSAEGDAW\\n\" +\n+            \"MAoGCGCEQgEaAQMEMAgGBmeBDAECAjA6BgNVHR8EMzAxMC+gLaArhilodHRwOi8v\\n\" +\n+            \"Y3JsLmJ1eXBhc3Mubm8vY3JsL0JQQ2xhc3MzQ0EyLmNybDAxBgNVHREEKjAogiZ2\\n\" +\n+            \"YWxpZC5idXNpbmVzc3BsdXMuY2EyMy5zc2wuYnV5cGFzcy5ubzBqBggrBgEFBQcB\\n\" +\n+            \"AQReMFwwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmJ1eXBhc3MuY29tMDUGCCsG\\n\" +\n+            \"AQUFBzAChilodHRwOi8vY3J0LmJ1eXBhc3Mubm8vY3J0L0JQQ2xhc3MzQ0EyLmNl\\n\" +\n+            \"cjCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHYAu9nfvB+KcbWTlCOXqpJ7RzhX\\n\" +\n+            \"lQqrUugakJZkNo4e0YUAAAFtXdd3CgAABAMARzBFAiEA\/pTOtw6i2DJS0R56KwVF\\n\" +\n+            \"Huy+LonG7bICWAe1vnCNud4CIE7\/KRDu9Jys24rtmLz9yCNYJfZDvooK5PT9+rWR\\n\" +\n+            \"OC4+AHUApLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BAAAAFtXdd54gAA\\n\" +\n+            \"BAMARjBEAiB09qp4sGA+Kxg823hea3ZyTV7mU1ZQ9j9fqqX8KZ1mpwIgUICM2H0Y\\n\" +\n+            \"8z+V9m+6SutZ5WTD+Arg3K8O6\/dvyKu0QmEAdQBvU3asMfAxGdiZAKRRFf93FRwR\\n\" +\n+            \"2QLBACkGjbIImjfZEwAAAW1d13cSAAAEAwBGMEQCIFLqxvNOKVFlTjHPXwk93VeW\\n\" +\n+            \"zCqFtcxJkunD\/iiv0Kn9AiBoyvUrjYn4MPTht9zb0OyaSMWb00\/HXP\/4AVmUzHrz\\n\" +\n+            \"YzANBgkqhkiG9w0BAQsFAAOCAQEAsmQAOn1f1CbvnOpggS2efmy1pQXvvw+YeCYP\\n\" +\n+            \"bElO578h7scn8al4N7huQZ\/z14BELe0chGWNA\/ReW5nAu3SUOiv+E8\/kv9i9Y8ul\\n\" +\n+            \"MJPL62nXW6Z\/mkyystuBNtON420iWL\/gS\/vduxSZE\/iBB4znctDpXS917\/XWf31Y\\n\" +\n+            \"ZonemF3MSfi\/s9V0Ic82ZY\/+HZ4NLTDyKRd4kFF58OoH9RZNb6g8MbTp+gPadiUG\\n\" +\n+            \"UcfPGV3yGiugQa7WHTl7QJ9ishyafiZ4hpeKem6TMDEztgGyLIZ4MSxQvoeI2jJP\\n\" +\n+            \"KjHd5fW\/HClbEcrN+w0a0MUNMaAOaZfMS7jS6sDpaVL8D0EX5A==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -242,2 +281,2 @@\n-    \/\/ Owner: SERIALNUMBER=983163327, CN=revoked.business.ca23.ssl.buypass.no,\n-    \/\/ O=BUYPASS AS, L=OSLO, OID.2.5.4.17=0402, C=NO\n+    \/\/ Owner: SERIALNUMBER=983163327, CN=revoked.businessplus.ca23.ssl.buypass.no, O=BUYPASS AS,\n+    \/\/ L=OSLO, OID.2.5.4.17=0484, C=NO\n@@ -245,28 +284,38 @@\n-    private static final String REVOKED_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\"\n-            + \"MIIE2DCCA8CgAwIBAgIKARno\/wYhPtNtmjANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\"\n-            + \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\"\n-            + \"FEJ1eXBhc3MgQ2xhc3MgMyBDQSAyMB4XDTEzMDIwMTA5MTE0NFoXDTE2MDIwMTA5\\n\"\n-            + \"MTE0NFowgYMxCzAJBgNVBAYTAk5PMQ0wCwYDVQQRDAQwNDAyMQ0wCwYDVQQHDARP\\n\"\n-            + \"U0xPMRMwEQYDVQQKDApCVVlQQVNTIEFTMS0wKwYDVQQDDCRyZXZva2VkLmJ1c2lu\\n\"\n-            + \"ZXNzLmNhMjMuc3NsLmJ1eXBhc3Mubm8xEjAQBgNVBAUTCTk4MzE2MzMyNzCCASIw\\n\"\n-            + \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMmBUI0wNCz4kLikR5wog4QTUEmO\\n\"\n-            + \"XoGgjnQv0cKfDogbewK+0ngdyyR8dZOqSauQTGLlPTpo6DEWpD3Jqrr444MV6Vc1\\n\"\n-            + \"AGWnjk3T+KT5tKl6qJOQq17Y+HEnsTEzCo1kieVygpSu7FBa2OnhHNmLWThhGUEi\\n\"\n-            + \"mLqrEyfjMSb9zacvo06Zr7S8BauLRB3aM5BeMVF7Bj\/9f\/FvnB\/y1cRDLG32WRCx\\n\"\n-            + \"K9IAFwCaJkfWsXx+bnaO4uEQwLFZ96p7L5mr+QNvI6QuweIY1hDM3RDM6HQkGTK9\\n\"\n-            + \"8iHSzGBSCGwOM24Ym3XM5vTbiV5uLno+QEYlJL\/+qbYvarbO2gPF+6A6M10CAwEA\\n\"\n-            + \"AaOCAYMwggF\/MAkGA1UdEwQCMAAwHwYDVR0jBBgwFoAUIjAu0vv2S8rAuDvSBMTp\\n\"\n-            + \"cuaXmwwwHQYDVR0OBBYEFNI2C2XKZkNRHZrHLkBhCMeDRN0KMA4GA1UdDwEB\/wQE\\n\"\n-            + \"AwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHwYDVR0gBBgwFjAK\\n\"\n-            + \"BghghEIBGgEDBDAIBgZngQwBAgIwOgYDVR0fBDMwMTAvoC2gK4YpaHR0cDovL2Ny\\n\"\n-            + \"bC5idXlwYXNzLm5vL2NybC9CUENsYXNzM0NBMi5jcmwwLwYDVR0RBCgwJoIkcmV2\\n\"\n-            + \"b2tlZC5idXNpbmVzcy5jYTIzLnNzbC5idXlwYXNzLm5vMHUGCCsGAQUFBwEBBGkw\\n\"\n-            + \"ZzAuBggrBgEFBQcwAYYiaHR0cDovL29jc3AuYnV5cGFzcy5uby9vY3NwL0JQT2Nz\\n\"\n-            + \"cDA1BggrBgEFBQcwAoYpaHR0cDovL2NydC5idXlwYXNzLm5vL2NydC9CUENsYXNz\\n\"\n-            + \"M0NBMi5jZXIwDQYJKoZIhvcNAQELBQADggEBAGNQe9cgrw\/mN7bChof205NRS+TH\\n\"\n-            + \"A8f0JcKk1KrPYYW+ilyp6j3My26Sm9a4ZyKRhAS8fCxYUXWzfNvJNFYv2ttLuegl\\n\"\n-            + \"SFfeXjSJJZW9+wC5oRLta++62UTTxXp0Zf5UkMsHZCIjvnk0yGWZa0phyRCH89ca\\n\"\n-            + \"4vfRTOGNTNfX3d0jm\/+fm70UNYHKZ\/VcxVj0vH2Ij\/kDUy7r2cw1gQ65RDUotnTu\\n\"\n-            + \"Yt59y3COyMZeYNMcuoss2XWnedFoD7fwCSkNqVbwjCxGVkL1+ivbWhqlCefaniZX\\n\"\n-            + \"Wy35oP1635RSxHbCMU9msmUO7FS8n1VH2edEC797gduK5pn2aBhy\/MW0unU=\\n\"\n-            + \"-----END CERTIFICATE-----\";\n+    \/\/ Serial number: 267cee3fab06c615fb27\n+    \/\/ Valid from: Mon Sep 23 04:56:56 PDT 2019 until: Thu Sep 23 14:59:00 PDT 2021\n+    private static final String REVOKED_CLASS_3 = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIGWDCCBUCgAwIBAgIKJnzuP6sGxhX7JzANBgkqhkiG9w0BAQsFADBLMQswCQYD\\n\" +\n+            \"VQQGEwJOTzEdMBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMM\\n\" +\n+            \"FEJ1eXBhc3MgQ2xhc3MgMyBDQSAyMB4XDTE5MDkyMzExNTY1NloXDTIxMDkyMzIx\\n\" +\n+            \"NTkwMFowgYcxCzAJBgNVBAYTAk5PMQ0wCwYDVQQRDAQwNDg0MQ0wCwYDVQQHDARP\\n\" +\n+            \"U0xPMRMwEQYDVQQKDApCVVlQQVNTIEFTMTEwLwYDVQQDDChyZXZva2VkLmJ1c2lu\\n\" +\n+            \"ZXNzcGx1cy5jYTIzLnNzbC5idXlwYXNzLm5vMRIwEAYDVQQFEwk5ODMxNjMzMjcw\\n\" +\n+            \"ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtpNExWd+hjl\/ouL\/B\/pdc\\n\" +\n+            \"InUzEywQO3rzXs3psBdQ1lDhG\/9Fcq78uqyri4edtJNDGb1XadktKeRC+NtUqMkE\\n\" +\n+            \"IFOXvaVjLxa61c8K5mh3CVDrAiPyxVcnm8vkuQPMsy1BTOl9TZq9heIukG\/lcfzW\\n\" +\n+            \"6tU6mOD9yx1NzXSVN5cvDCbbDnEZiJSuazXI4O02as66SWI27WKsk21+SKCGAtGC\\n\" +\n+            \"kI0PW4FrXm43\/jxX1CoImIfTLkDInMq7HHsQRsGQ3OjbJLfRz\/2obyjHUU5ki6vd\\n\" +\n+            \"z16mA5ITLFIG36HxbPn337175R9RwOpWkN84xVlL3VQdznCVoiOjzBiOMpdm0Jwp\\n\" +\n+            \"AgMBAAGjggL\/MIIC+zAJBgNVHRMEAjAAMB8GA1UdIwQYMBaAFCIwLtL79kvKwLg7\\n\" +\n+            \"0gTE6XLml5sMMB0GA1UdDgQWBBSGUQTUB4BilG\/EMaHHDAYNPewf8zAOBgNVHQ8B\\n\" +\n+            \"Af8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB8GA1UdIAQY\\n\" +\n+            \"MBYwCgYIYIRCARoBAwQwCAYGZ4EMAQICMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHA6\\n\" +\n+            \"Ly9jcmwuYnV5cGFzcy5uby9jcmwvQlBDbGFzczNDQTIuY3JsMDMGA1UdEQQsMCqC\\n\" +\n+            \"KHJldm9rZWQuYnVzaW5lc3NwbHVzLmNhMjMuc3NsLmJ1eXBhc3Mubm8wagYIKwYB\\n\" +\n+            \"BQUHAQEEXjBcMCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5idXlwYXNzLmNvbTA1\\n\" +\n+            \"BggrBgEFBQcwAoYpaHR0cDovL2NydC5idXlwYXNzLm5vL2NydC9CUENsYXNzM0NB\\n\" +\n+            \"Mi5jZXIwggF\/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB2ALvZ37wfinG1k5Qjl6qS\\n\" +\n+            \"e0c4V5UKq1LoGpCWZDaOHtGFAAABbV37Y7oAAAQDAEcwRQIgYbaNSR3R5x9p9sYJ\\n\" +\n+            \"UzRDdd\/lbELb05u9GqlLtl4M61YCIQCTBecXTbMs4zuG\/wu722HZy\/XgD6fiQySp\\n\" +\n+            \"FhHDO3CYagB2AKS5CZC0GFgUh7sTosxncAo8NZgE+RvfuON3zQ7IDdwQAAABbV37\\n\" +\n+            \"Y7wAAAQDAEcwRQIgD8j40M03oLMCg5WmFBN7VL6169F7rKatE12btLQRYtYCIQC0\\n\" +\n+            \"rDhQiZP7j14Y4JqEFQx6UHl3dvxLxZTDW34Z54IUWQB3AG9Tdqwx8DEZ2JkApFEV\\n\" +\n+            \"\/3cVHBHZAsEAKQaNsgiaN9kTAAABbV37YOUAAAQDAEgwRgIhANTGHD1g2pbsTtoN\\n\" +\n+            \"CJ2m6nfxm9jB3huftKGDjeo7EyxHAiEA3EYNUc6hr+4Q9lMAphUgpW6oyaNCsIzl\\n\" +\n+            \"izbNhq8dBRYwDQYJKoZIhvcNAQELBQADggEBADUuO4MmYjPkmkik5tjUPiiDDXEQ\\n\" +\n+            \"A41jr72qmdleYdkhnaKAJa8Enn6j\/ySRV0enA7yqJeNp1qgPQFvlOh3TqFB3Ae5b\\n\" +\n+            \"XAfL2B7vKbegpjKm8dVH5RurqVm9xZcXb1nbwfu2k3lqqsp\/uwqvLBItJDvA8pfi\\n\" +\n+            \"2R46sEtj2gFpAlKFDwepuaklqhrvEoIjIaAL0RrGfKY0oRQw1YMbPNIebsVaWr04\\n\" +\n+            \"rt6tlxrq7PyW1w9Mt3445WA1NzSWc7pAjFLfY6u87QaPHI4ES31H9xxRDsxmr6Y3\\n\" +\n+            \"BJmiWd5uUxev0nVw0saqvlo4yAEBq4rI\/DieKcQI4qEI8myzoS0R0azMfLM=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -280,6 +329,0 @@\n-        if (ocspEnabled) {\n-            \/\/ Revoked test certificate is expired\n-            \/\/ and backdated revocation check is only possible with OCSP\n-            pathValidator.setValidationDate(\"July 01, 2013\");\n-        }\n-\n@@ -289,1 +332,1 @@\n-                \"Wed Feb 06 02:56:32 PST 2013\", System.out);\n+                \"Mon Sep 23 04:57:31 PDT 2019\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/BuypassCA.java","additions":239,"deletions":196,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-    \/\/ Serial number: 3626488cf28e94f1719074128bbb58a7829\n-    \/\/ Valid from: Thu Apr 08 15:58:32 PDT 2021 until: Wed Jul 07 15:58:32 PDT 2021\n+    \/\/ Serial number: 4f1333011635d76d6356c5f1fb8a7273617\n+    \/\/ Valid from: Fri Jun 25 08:18:10 PDT 2021 until: Thu Sep 23 08:18:09 PDT 2021\n@@ -122,1 +122,1 @@\n-            \"MIIFSjCCBDKgAwIBAgISA2JkiM8o6U8XGQdBKLu1ingpMA0GCSqGSIb3DQEBCwUA\\n\" +\n+            \"MIIFSTCCBDGgAwIBAgISBPEzMBFjXXbWNWxfH7inJzYXMA0GCSqGSIb3DQEBCwUA\\n\" +\n@@ -124,1 +124,1 @@\n-            \"EwJSMzAeFw0yMTA0MDgyMjU4MzJaFw0yMTA3MDcyMjU4MzJaMC0xKzApBgNVBAMT\\n\" +\n+            \"EwJSMzAeFw0yMTA2MjUxNTE4MTBaFw0yMTA5MjMxNTE4MDlaMC0xKzApBgNVBAMT\\n\" +\n@@ -126,8 +126,8 @@\n-            \"DQEBAQUAA4IBDwAwggEKAoIBAQC1NecSgcQLX4K94pR0HBaUun8wi++lyNTGkpoY\\n\" +\n-            \"4xGB7M\/WMnJpR8Y+49sO6QSe7fyU18zMjunT3Z5ahQtQi27dGU+xS7KUJUZl2NSJ\\n\" +\n-            \"4MLf717cSbBmDBvZiqmuXmUuy5Ehhabk1jBx1NgsR9uqsJFyILPc9sEAKq6MwT7N\\n\" +\n-            \"CnaVW1QhpUB9F5Zlc8cmHuhMsyrxGTM3h6P7QeVpqBT91mBEukvWUb01eifk134v\\n\" +\n-            \"Sv1gXblr2bksHd9fiIoQvEUnSK9hXcRilDpOjaF5qkiNsQPpuEZqM56XyfOSeaCr\\n\" +\n-            \"1HtEYa5Y+SXZ4G4Jt4AZt44WKoDwika9Iex826rETvAFaiTFAgMBAAGjggJdMIIC\\n\" +\n-            \"WTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC\\n\" +\n-            \"MAwGA1UdEwEB\/wQCMAAwHQYDVR0OBBYEFEwvrwbqSUpGjtFPPpoXpNO77gJuMB8G\\n\" +\n+            \"DQEBAQUAA4IBDwAwggEKAoIBAQCkCp4fq7FnN5lfAWX0vhCcyC5WO9TuU6ckuYYj\\n\" +\n+            \"8\/wQ8GQ\/FIl+vXCAmHIfIX14irQN8TISeVdMOP0C7sa73d3GSawX7qMaRhddXn7V\\n\" +\n+            \"EL+4CbHQ6qit5YkakwhHz9tKbYX16wPj+inn22kJVwi8iLbhYB9WWSvv7OyiNSHv\\n\" +\n+            \"nmlYUkMv8+9UhgPT4yCKF1OEI5ajUOuecjOKc+EzsT\/JqPRErvBOIKn3PRn4h8UM\\n\" +\n+            \"0BJDrDtZMpkvD4\/lyRs3g\/BLsf3DQjlEgKit0hvc72yyhiDbKd41EmBoQC5rNF7o\\n\" +\n+            \"B0CnBXhDLHbC\/YRunVrYGsF0h2J9hw4055BdaXbS2BJnPEFnAgMBAAGjggJcMIIC\\n\" +\n+            \"WDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC\\n\" +\n+            \"MAwGA1UdEwEB\/wQCMAAwHQYDVR0OBBYEFJBkf3Z\/ICoCTUx3JCgrBeoMyedQMB8G\\n\" +\n@@ -139,12 +139,12 @@\n-            \"cmcwggEEBgorBgEEAdZ5AgQCBIH1BIHyAPAAdgBElGUusO7Or8RAB9io\/ijA2uaC\\n\" +\n-            \"vtjLMbU\/0zOWtbaBqAAAAXiz7FLbAAAEAwBHMEUCIA8aoTszzeBJMP0aOhnMVizJ\\n\" +\n-            \"mQe6c+OHAjG+dP1y9bD2AiEA0oJOb9ZKys+OE0JP5JT0kjdYH8U3ibJ+k6nHKMOI\\n\" +\n-            \"CdgAdgD2XJQv0XcwIhRUGAgwlFaO400TGTO\/3wwvIAvMTvFk4wAAAXiz7FLQAAAE\\n\" +\n-            \"AwBHMEUCIGTdYSTO0IXQ6HSLwwGw1rlkH+lmg7EFpC+A25lhgtWCAiEAgi\/7FtTG\\n\" +\n-            \"KWKkWLU7ZP1AqIaaWlyXzRK2myrYKcBE804wDQYJKoZIhvcNAQELBQADggEBAByr\\n\" +\n-            \"Q4mfzlT+4OBDI4hFjdrPHeHgePUK0HsmQ7GPNwe3pIxTQYs6fKIv+jb4mzKiggLy\\n\" +\n-            \"882L+cYLfafggIpRjcoV9bAR2ceea+7uiyat54w5UZYLAmHgAdd4Y7OAUcrTL8rg\\n\" +\n-            \"SAXNECrCGIfh0PwxyoJEgxcJnOoGgD5lVAycspUl3u3itmu9tcjcZA7CD5t2xPTQ\\n\" +\n-            \"j\/eoqH+5fHGXIvZuZxRVllWRwtLHRNafYiotLAW0P1i0i3wevTqmQ8ABVUuzYmJE\\n\" +\n-            \"hjTktcZqbYIZqkDalLcGXJm8FFILQHv\/vhXd\/G2IbPODYgjTS7e4jCTXg2eIf17Z\\n\" +\n-            \"yzs5yR8FPDdK48UWPgU=\\n\" +\n+            \"cmcwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQCUILwejtWNbIhzH4KLIiwN0dpN\\n\" +\n+            \"XmxPlD1h204vWE2iwgAAAXpD9t6nAAAEAwBGMEQCIHwF9NcPqsovYp56lhqFkWYj\\n\" +\n+            \"QCATATrLzzxgUoLDYRwgAiBBecqe5Ub32I+q9oqH1nbK\/s8QadcafIL3bkrRVbFB\\n\" +\n+            \"TAB2AH0+8viP\/4hVaCTCwMqeUol5K8UOeAl\/LmqXaJl+IvDXAAABekP23sYAAAQD\\n\" +\n+            \"AEcwRQIgGli\/1mmKKnZ0uxDIX7ySqAyD2C7FTf+y3py2S0Xcv4YCIQCZve3cqKZ2\\n\" +\n+            \"lrEyyaMeLZA+PIxUMniHx3gDkro0sKLzOzANBgkqhkiG9w0BAQsFAAOCAQEAle42\\n\" +\n+            \"p58OTusm7DAOcdK4ld+pJu2bz9F940Wrnql08rciRjGIVpp5PhMNFm9AOaptKPNY\\n\" +\n+            \"h62V2GEOVaLxmvr9\/8EDFcCCPAGV1DNYrG9aTKaiXk7IzO4UxKbzox4iUcuop\/zB\\n\" +\n+            \"uofxT8uBLmT4XYZrQXXKj1KdfJGzgeoXqBv5PPCiP3hmBQixoJnSKImnUIXWh4O8\\n\" +\n+            \"kBtmgII5ug0q+jI3LvpJuv7xQsaNYFBcmFiQQ7YRt4W99GMdbYGjhzT8iBDEH7nG\\n\" +\n+            \"MsqWuwB5TN5vIuw2aWxcfaqKayq7UPA4rJePWdD\/5RzKlQKLQx0BA3AL+3Nnj1fT\\n\" +\n+            \"NEKwCWWylIND6z\/9Xw==\\n\" +\n@@ -171,3 +171,0 @@\n-        \/\/ Perform backdate check as test artifacts expire in July 2021\n-        pathValidator.setValidationDate(\"June 15, 2021\");\n-\n@@ -181,1 +178,1 @@\n-                \"Thu Apr 08 17:05:26 PDT 2021\", System.out);\n+                \"Fri Jun 25 09:18:12 PDT 2021\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/LetsEncryptCA.java","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @build TestHttpsServer HttpCallback\n+ * @library \/test\/lib\n@@ -37,3 +36,14 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpRetryException;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.security.KeyStore;\n+import java.util.concurrent.Executors;\n@@ -42,1 +52,13 @@\n-public class ChunkedOutputStream implements HttpCallback {\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+\n+public class ChunkedOutputStream implements HttpHandler {\n@@ -60,20 +82,7 @@\n-    public void request(HttpTransaction req) {\n-        try {\n-            \/\/ this is needed (count++ doesn't work), 'cause we\n-            \/\/ are doing concurrent tests\n-            String path = req.getRequestURI().getPath();\n-            if (path.equals(\"\/d0\")) {\n-                count = 0;\n-            } else if (path.equals(\"\/d01\")) {\n-                count = 1;\n-            } else if (path.equals(\"\/d3\")) {\n-                count = 2;\n-            } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n-                count = 3;\n-            } else if (path.equals(\"\/d6\")) {\n-                count = 3;\n-            }  else if (path.equals(\"\/d7\")) {\n-                count = 4;\n-            }  else if (path.equals(\"\/d8\")) {\n-                count = 5;\n-            }\n+    private static String getAuthority() {\n+        InetAddress address = server.getAddress().getAddress();\n+        String hostaddr = address.getHostAddress();\n+        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n+        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n+        return hostaddr + \":\" + server.getAddress().getPort();\n+    }\n@@ -81,1 +90,22 @@\n-            switch (count) {\n+    public void handle(HttpExchange req) throws IOException {\n+        \/\/ this is needed (count++ doesn't work), 'cause we\n+        \/\/ are doing concurrent tests\n+        System.out.println(\"Request Received\");\n+        String path = req.getRequestURI().getPath();\n+        if (path.equals(\"\/d0\")) {\n+            count = 0;\n+        } else if (path.equals(\"\/d01\")) {\n+            count = 1;\n+        } else if (path.equals(\"\/d3\")) {\n+            count = 2;\n+        } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n+            count = 3;\n+        } else if (path.equals(\"\/d6\")) {\n+            count = 3;\n+        }  else if (path.equals(\"\/d7\")) {\n+            count = 4;\n+        }  else if (path.equals(\"\/d8\")) {\n+            count = 5;\n+        }\n+\n+        switch (count) {\n@@ -84,1 +114,5 @@\n-                String reqbody = req.getRequestEntityBody();\n+\n+                String reqbody = \"\";\n+                try(InputStream inputStream = req.getRequestBody()) {\n+                    reqbody = new String(inputStream.readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n@@ -86,2 +120,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -89,1 +123,1 @@\n-                String chunk = req.getRequestHeader(\"Transfer-encoding\");\n+                String chunk = req.getRequestHeaders().getFirst(\"Transfer-encoding\");\n@@ -91,2 +125,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -94,1 +128,0 @@\n-                req.setResponseEntityBody(reqbody);\n@@ -96,1 +129,1 @@\n-                    req.setResponseHeader(\"Connection\", \"close\");\n+                    req.getResponseHeaders().set(\"Connection\", \"close\");\n@@ -98,3 +131,3 @@\n-                req.sendResponse(200, \"OK\");\n-                if (count == 1) {\n-                    req.orderlyClose();\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -104,1 +137,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -106,2 +139,2 @@\n-                    req.sendResponse(500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -109,2 +142,1 @@\n-                int clen = Integer.parseInt (\n-                        req.getRequestHeader(\"Content-length\"));\n+                int clen = Integer.parseInt (req.getRequestHeaders().getFirst(\"Content-length\"));\n@@ -112,2 +144,7 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n+                }\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -115,4 +152,0 @@\n-                req.setResponseEntityBody (reqbody);\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n@@ -121,4 +154,6 @@\n-                req.setResponseHeader(\"Location\", \"https:\/\/foo.bar\/\");\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(307, \"Temporary Redirect\");\n-                req.orderlyClose();\n+                if (path.equals(\"\/d6\")) {\n+                    reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n+                req.getResponseHeaders().set(\"Location\", \"https:\/\/foo.bar\/\");\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(307, -1);\n@@ -128,1 +163,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -130,2 +165,2 @@\n-                    req.sendResponse(501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -133,3 +168,2 @@\n-                req.setResponseHeader(\"Connection\", \"close\");\n-                req.sendResponse(200, \"OK\");\n-                req.orderlyClose();\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, -1);\n@@ -138,2 +172,1 @@\n-                req.sendResponse(404, \"Not Found\");\n-                req.orderlyClose();\n+                req.sendResponseHeaders(404, -1);\n@@ -141,3 +174,0 @@\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n@@ -145,7 +175,1 @@\n-    }\n-\n-    public boolean dropPlainTextConnections() {\n-        System.out.println(\"Unrecognized SSL message, plaintext connection?\");\n-        System.out.println(\"TestHttpsServer receveived rogue connection: ignoring it.\");\n-        rogueCount.incrementAndGet();\n-        return true;\n+        req.close();\n@@ -182,3 +206,0 @@\n-            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n-            \/\/ has ben called.\n-            if (rogueCount.get() == rogue) throw x;\n@@ -199,1 +220,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -216,1 +237,1 @@\n-        os.write (str2.getBytes());\n+        os.write (str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -233,1 +254,1 @@\n-        os.write(str2.getBytes());\n+        os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -251,1 +272,1 @@\n-            os.write(str2.getBytes());\n+            os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -266,1 +287,1 @@\n-        os.write(str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -313,1 +334,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -316,0 +337,1 @@\n+        ChunkedOutputStream chunkedOutputStream = new ChunkedOutputStream();\n@@ -336,4 +358,26 @@\n-                server = new TestHttpsServer(\n-                        new ChunkedOutputStream(), 1, 10, loopback, 0);\n-                System.out.println(\"Server started: listening on: \" + server.getAuthority());\n-                testPlainText(server.getAuthority());\n+                \/\/ create and initialize a SSLContext\n+                KeyStore ks = KeyStore.getInstance(\"JKS\");\n+                KeyStore ts = KeyStore.getInstance(\"JKS\");\n+                char[] passphrase = \"passphrase\".toCharArray();\n+\n+                ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+                ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(ks, passphrase);\n+\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(ts);\n+\n+                SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+                sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+                server = HttpsServer.create(new InetSocketAddress(loopback, 0), 10);\n+                server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+                server.createContext(\"\/\", chunkedOutputStream);\n+                server.setExecutor(Executors.newSingleThreadExecutor());\n+                server.start();\n+\n+                System.out.println(\"Server started: listening on: \" + getAuthority());\n+                testPlainText(getAuthority());\n@@ -342,7 +386,7 @@\n-                test1(\"https:\/\/\" + server.getAuthority() + \"\/d01\");\n-                test3(\"https:\/\/\" + server.getAuthority() + \"\/d3\");\n-                test4(\"https:\/\/\" + server.getAuthority() + \"\/d4\");\n-                test5(\"https:\/\/\" + server.getAuthority() + \"\/d5\");\n-                test6(\"https:\/\/\" + server.getAuthority() + \"\/d6\");\n-                test7(\"https:\/\/\" + server.getAuthority() + \"\/d7\");\n-                test8(\"https:\/\/\" + server.getAuthority() + \"\/d8\");\n+                test1(\"https:\/\/\" + getAuthority() + \"\/d01\");\n+                test3(\"https:\/\/\" + getAuthority() + \"\/d3\");\n+                test4(\"https:\/\/\" + getAuthority() + \"\/d4\");\n+                test5(\"https:\/\/\" + getAuthority() + \"\/d5\");\n+                test6(\"https:\/\/\" + getAuthority() + \"\/d6\");\n+                test7(\"https:\/\/\" + getAuthority() + \"\/d7\");\n+                test8(\"https:\/\/\" + getAuthority() + \"\/d8\");\n@@ -351,1 +395,1 @@\n-                    server.terminate();\n+                    server.stop(1);\n@@ -355,1 +399,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -368,1 +412,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":139,"deletions":95,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-\n-    \/**\n-     * Tells whether the server should simply close the\n-     * connection and ignore the request when the first\n-     * byte received by the server looks like a plain\n-     * text connection.\n-     * @return true if the request should be ignored.\n-     **\/\n-    default boolean dropPlainTextConnections() {\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpsServer.ServerWorker server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SocketChannel ch;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpsServer.ServerWorker server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SocketChannel ch) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.ch = ch;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (ch.toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return ch;\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- *        HttpCallback TestHttpsServer ClosedChannelList\n- *        HttpTransaction TunnelProxy\n+ *        ClosedChannelList\n+ *        TunnelProxy\n@@ -43,5 +43,22 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n-import java.util.*;\n-\n+import java.io.FileInputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.ProxySelector;\n+import java.net.URL;\n+import java.security.KeyStore;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n@@ -52,1 +69,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -69,1 +86,0 @@\n-\n@@ -71,1 +87,0 @@\n-\n@@ -74,3 +89,1 @@\n-            System.setProperty(\"https.proxyPort\",\n-                        (new Integer(proxy.getLocalPort())).toString() );\n-\n+            ProxySelector.setDefault(ProxySelector.of(new InetSocketAddress(firstNonLoAddress, proxy.getLocalPort())));\n@@ -78,4 +91,0 @@\n-\n-            if (httpTrans.hasBadRequest) {\n-                throw new RuntimeException(\"Test failed : bad http request\");\n-            }\n@@ -87,1 +96,1 @@\n-               server.terminate();\n+               server.stop(1);\n@@ -138,1 +147,1 @@\n-    public static void startHttpServer() throws IOException {\n+    public static void startHttpServer() throws  Exception {\n@@ -142,1 +151,23 @@\n-        server = new TestHttpsServer(httpTrans, 1, 10, firstNonLoAddress, 0);\n+        \/\/ create and initialize a SSLContext\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+        ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        server = HttpsServer.create(new InetSocketAddress(firstNonLoAddress, 0), 10);\n+        server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+        server.createContext(\"\/\", httpTrans);\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -147,1 +178,1 @@\n-        System.out.println(\"https server listen on: \" + server.getLocalPort());\n+        System.out.println(\"https server listen on: \" + server.getAddress().getPort());\n@@ -150,1 +181,1 @@\n-                            server.getLocalPort(), \"\/\");\n+                            server.getAddress().getPort(), \"\/\");\n@@ -153,0 +184,4 @@\n+        if(uc.getResponseCode() != 200) {\n+            uc.disconnect();\n+            throw new RuntimeException(\"Test failed : bad http request with response code : \"+ uc.getResponseCode());\n+        }\n@@ -163,2 +198,1 @@\n-class SimpleHttpTransaction implements HttpCallback {\n-    public boolean hasBadRequest = false;\n+class SimpleHttpTransaction implements HttpHandler {\n@@ -169,1 +203,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -175,2 +209,2 @@\n-                trans.addResponseHeader(\"Location\", location);\n-                trans.sendResponse(302, \"Moved Temporarily\");\n+                trans.getResponseHeaders().set(\"Location\", location);\n+                trans.sendResponseHeaders(302, -1);\n@@ -178,10 +212,1 @@\n-                \/\/ if the bug exsits, it'll send 2 GET commands\n-                \/\/ check 2nd GET here\n-                String duplicatedGet = trans.getRequestHeader(null);\n-                if (duplicatedGet != null &&\n-                    duplicatedGet.toUpperCase().indexOf(\"GET\") >= 0) {\n-                    trans.sendResponse(400, \"Bad Request\");\n-                    hasBadRequest = true;\n-                } else {\n-                    trans.sendResponse(200, \"OK\");\n-                }\n+                trans.sendResponseHeaders(200, -1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6216082.java","additions":63,"deletions":38,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,20 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n@@ -33,1 +49,0 @@\n-import java.util.*;\n@@ -46,1 +61,0 @@\n-     * @param cb the callback object which is invoked to handle each\n@@ -58,2 +72,0 @@\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n@@ -77,2 +89,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -98,2 +108,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -252,1 +260,0 @@\n-            HttpTransaction msg;\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,983 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.security.*;\n-\n-\/**\n- * This class implements a simple HTTPS server. It uses multiple threads to\n- * handle connections in parallel, and will spin off a new thread to handle\n- * each request. (this is easier to implement with SSLEngine)\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If you make a change in here, please don't forget to make the\n- * corresponding change in the J2SE equivalent.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpsServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/\/ ssl related fields\n-    static SSLContext sslCtx;\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb) throws IOException {\n-        this(cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this(cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, int port)\n-        throws IOException {\n-        this(cb, threads, cperthread, null, port);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param address the InetAddress to bind to. {@code Null} means the\n-     *  wildcard address.\n-     * @param port the port number to bind the server to. {@code Zero}\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpsServer(HttpCallback cb, int threads, int cperthread, InetAddress address, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open();\n-        InetSocketAddress addr = new InetSocketAddress(address, port);\n-        schan.socket().bind(addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-\n-        try {\n-            \/\/ create and initialize a SSLContext\n-            KeyStore ks = KeyStore.getInstance(\"JKS\");\n-            KeyStore ts = KeyStore.getInstance(\"JKS\");\n-            char[] passphrase = \"passphrase\".toCharArray();\n-\n-            ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-            ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-            tmf.init(ts);\n-\n-            sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-            servers = new Server[threads];\n-            for (int i=0; i<threads; i++) {\n-                servers[i] = new Server(cb, schan, cperthread);\n-                servers[i].start();\n-            }\n-        } catch (Exception ex) {\n-            throw new RuntimeException(\"test failed. cause: \"+ex.getMessage());\n-        }\n-    }\n-\n-    \/** Tell all threads in the server to exit within 5 seconds.\n-     *  This is an abortive termination. Just prior to the thread exiting\n-     *  all channels in that thread waiting to be closed are forceably closed.\n-     *\/\n-\n-    public void terminate() {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        boolean shutdown;\n-\n-        Server(HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate(512);\n-            clist = new ClosedChannelList();\n-            try {\n-                selector = Selector.open();\n-                schan.configureBlocking(false);\n-                listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println(\"Server could not start: \" + e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public synchronized void terminate() {\n-            shutdown = true;\n-        }\n-\n-        public void run()  {\n-            try {\n-                while (true) {\n-                    selector.select(1000);\n-                    Set selected = selector.selectedKeys();\n-                    Iterator iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = (SelectionKey)iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking(true);\n-                            SSLEngine sslEng = sslCtx.createSSLEngine();\n-                            sslEng.setUseClientMode(false);\n-                            new ServerWorker(cb, sock, sslEng).start();\n-                            nconn ++;\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed = false;\n-                                SocketChannel chan = (SocketChannel)key.channel();\n-                                if (key.attachment() != null) {\n-                                    closed = consume(chan);\n-                                }\n-\n-                                if (closed) {\n-                                    chan.close();\n-                                    key.cancel();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register(selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-\n-                    synchronized (this) {\n-                        if (shutdown) {\n-                            clist.terminate();\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println(\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-         * return true if connection closed\n-         *\/\n-        boolean consume(SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear();\n-                int c = chan.read(consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static class ServerWorker extends Thread {\n-        private ByteBuffer inNetBB;\n-        private ByteBuffer outNetBB;\n-        private ByteBuffer inAppBB;\n-        private ByteBuffer outAppBB;\n-\n-        SSLEngine sslEng;\n-        SocketChannel schan;\n-        HttpCallback cb;\n-        HandshakeStatus currentHSStatus;\n-        boolean initialHSComplete;\n-        boolean handshakeStarted;\n-        \/*\n-         * All inbound data goes through this buffer.\n-         *\n-         * It might be nice to use a cache of ByteBuffers so we're\n-         * not alloc\/dealloc'ing all over the place.\n-         *\/\n-\n-        \/*\n-         * Application buffers, also used for handshaking\n-         *\/\n-        private int appBBSize;\n-\n-        ServerWorker(HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {\n-            this.sslEng = sslEng;\n-            this.schan = schan;\n-            this.cb = cb;\n-            currentHSStatus = HandshakeStatus.NEED_UNWRAP;\n-            initialHSComplete = false;\n-            int netBBSize = sslEng.getSession().getPacketBufferSize();\n-            inNetBB =  ByteBuffer.allocate(netBBSize);\n-            outNetBB = ByteBuffer.allocate(netBBSize);\n-            appBBSize = sslEng.getSession().getApplicationBufferSize();\n-            inAppBB = ByteBuffer.allocate(appBBSize);\n-            outAppBB = ByteBuffer.allocate(appBBSize);\n-        }\n-\n-        public SSLEngine getSSLEngine() {\n-            return sslEng;\n-        }\n-\n-        public ByteBuffer outNetBB() {\n-            return outNetBB;\n-        }\n-\n-        public ByteBuffer outAppBB() {\n-            return outAppBB;\n-        }\n-\n-        public void run () {\n-            try {\n-                SSLEngineResult result;\n-\n-                while (!initialHSComplete) {\n-\n-                    switch (currentHSStatus) {\n-\n-                    case NEED_UNWRAP:\n-                        int bytes = schan.read(inNetBB);\n-                        if (!handshakeStarted && bytes > 0) {\n-                            handshakeStarted = true;\n-                            int byte0 = inNetBB.get(0);\n-                            if (byte0 != 0x16) {\n-                                \/\/ first byte of a TLS connection is supposed to be\n-                                \/\/ 0x16. If not it may be a plain text connection.\n-                                \/\/\n-                                \/\/ Sometime a rogue client may try to open a plain\n-                                \/\/ connection with our server. Calling this method\n-                                \/\/ gives a chance to the test logic to ignore such\n-                                \/\/ rogue connections.\n-                                \/\/\n-                                if (cb.dropPlainTextConnections()) {\n-                                    try { schan.close(); } catch (IOException x) { };\n-                                    return;\n-                                }\n-                                \/\/ else sslEng.unwrap will throw later on...\n-                            }\n-                        }\n-\n-needIO:\n-                        while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {\n-                            \/*\n-                             * Don't need to resize requestBB, since no app data should\n-                             * be generated here.\n-                             *\/\n-                            inNetBB.flip();\n-                            result = sslEng.unwrap(inNetBB, inAppBB);\n-                            inNetBB.compact();\n-                            currentHSStatus = result.getHandshakeStatus();\n-\n-                            switch (result.getStatus()) {\n-\n-                            case OK:\n-                                switch (currentHSStatus) {\n-                                case NOT_HANDSHAKING:\n-                                    throw new IOException(\n-                                                          \"Not handshaking during initial handshake\");\n-\n-                                case NEED_TASK:\n-                                    Runnable task;\n-                                    while ((task = sslEng.getDelegatedTask()) != null) {\n-                                        task.run();\n-                                        currentHSStatus = sslEng.getHandshakeStatus();\n-                                    }\n-                                    break;\n-                                }\n-\n-                                break;\n-\n-                            case BUFFER_UNDERFLOW:\n-                                break needIO;\n-\n-                            default: \/\/ BUFFER_OVERFLOW\/CLOSED:\n-                                throw new IOException(\"Received\" + result.getStatus() +\n-                                                      \"during initial handshaking\");\n-                            }\n-                        }\n-\n-                        \/*\n-                         * Just transitioned from read to write.\n-                         *\/\n-                        if (currentHSStatus != HandshakeStatus.NEED_WRAP) {\n-                            break;\n-                        }\n-\n-                        \/\/ Fall through and fill the write buffer.\n-\n-                    case NEED_WRAP:\n-                        \/*\n-                         * The flush above guarantees the out buffer to be empty\n-                         *\/\n-                        outNetBB.clear();\n-                        result = sslEng.wrap(inAppBB, outNetBB);\n-                        outNetBB.flip();\n-                        schan.write (outNetBB);\n-                        outNetBB.compact();\n-                        currentHSStatus = result.getHandshakeStatus();\n-\n-                        switch (result.getStatus()) {\n-                        case OK:\n-\n-                            if (currentHSStatus == HandshakeStatus.NEED_TASK) {\n-                                Runnable task;\n-                                while ((task = sslEng.getDelegatedTask()) != null) {\n-                                    task.run();\n-                                    currentHSStatus = sslEng.getHandshakeStatus();\n-                                }\n-                            }\n-\n-                            break;\n-\n-                        default: \/\/ BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\/CLOSED:\n-                            throw new IOException(\"Received\" + result.getStatus() +\n-                                                  \"during initial handshaking\");\n-                        }\n-                        break;\n-\n-                    case FINISHED:\n-                        initialHSComplete = true;\n-                        break;\n-                    default: \/\/ NOT_HANDSHAKING\/NEED_TASK\n-                        throw new RuntimeException(\"Invalid Handshaking State\" +\n-                                                   currentHSStatus);\n-                    } \/\/ switch\n-                }\n-                \/\/ read the application data; using non-blocking mode\n-                schan.configureBlocking(false);\n-                read(schan, sslEng);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read(SocketChannel chan, SSLEngine sslEng) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream(new NioInputStream(chan, sslEng, inNetBB, inAppBB));\n-                String requestline = readLine(is);\n-                MessageHeader mhead = new MessageHeader(is);\n-                String clen = mhead.findValue(\"Content-Length\");\n-                String trferenc = mhead.findValue(\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals(\"chunked\"))\n-                    data = new String(readChunkedData(is));\n-                else if (clen != null)\n-                    data = new String(readNormalData(is, Integer.parseInt(clen)));\n-                String[] req = requestline.split(\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI(req[1]);\n-                    msg = new HttpTransaction(this, cmd, uri, mhead, data, null, chan);\n-                    cb.request(msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction(this, cmd, null, null, null, null, chan);\n-                    msg.sendResponse(501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData(InputStream is, int len) throws IOException {\n-            byte[] buf  = new byte[len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData(InputStream is) throws IOException {\n-            LinkedList l = new LinkedList();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add(readNormalData(is, len));\n-                total += len;\n-                readCRLF(is); \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte[total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy(b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen(InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine(InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte[512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String(b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel(SocketChannel ch) throws IOException {\n-            ch.socket().shutdownOutput();\n-        }\n-\n-        synchronized void abortiveCloseChannel(SocketChannel ch) throws IOException {\n-            Socket s = ch.socket();\n-            s.setSoLinger(true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer inNetBB;\n-        ByteBuffer inAppBB;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream(SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = chan;\n-            selector = Selector.open();\n-            this.inNetBB = inNetBB;\n-            this.inAppBB = inAppBB;\n-            key = chan.register(selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read(byte[] b) throws IOException {\n-            return read(b, 0, b.length);\n-        }\n-\n-        public synchronized int read() throws IOException {\n-            return read(one, 0, 1);\n-        }\n-\n-        public synchronized int read(byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining();\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn > srclen ? srclen : canreturn;\n-                inAppBB.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put(b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available() throws IOException {\n-            if (closed)\n-                throw new IOException(\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            inAppBB.clear();\n-            int bytes = channel.read(inNetBB);\n-\n-            int needed = sslEng.getSession().getApplicationBufferSize();\n-            if (needed > inAppBB.remaining()) {\n-                inAppBB = ByteBuffer.allocate(needed);\n-            }\n-            inNetBB.flip();\n-            SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);\n-            inNetBB.compact();\n-            available = result.bytesProduced();\n-\n-            if (available > 0)\n-                inAppBB.flip();\n-            else if (available == -1)\n-                throw new IOException(\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block() throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available();\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark(int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate(readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset() throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException(\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        ByteBuffer outNetBB;\n-        ByteBuffer outAppBB;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream(SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = channel;\n-            this.outNetBB = outNetBB;\n-            this.outAppBB = outAppBB;\n-            selector = Selector.open();\n-            key = channel.register(selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte[1];\n-        }\n-\n-        public synchronized void write(int b) throws IOException {\n-            one[0] = (byte)b;\n-            write(one, 0, 1);\n-        }\n-\n-        public synchronized void write(byte[] b) throws IOException {\n-            write(b, 0, b.length);\n-        }\n-\n-        public synchronized void write(byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException(\"stream is closed\");\n-\n-            outAppBB = ByteBuffer.allocate(len);\n-            outAppBB.put(b, off, len);\n-            outAppBB.flip();\n-            int n;\n-            outNetBB.clear();\n-            int needed = sslEng.getSession().getPacketBufferSize();\n-            if (outNetBB.capacity() < needed) {\n-                outNetBB = ByteBuffer.allocate(needed);\n-            }\n-            SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);\n-            outNetBB.flip();\n-            int newLen = ret.bytesProduced();\n-            while ((n = channel.write (outNetBB)) < newLen) {\n-                newLen -= n;\n-                if (newLen == 0)\n-                    return;\n-                selector.select();\n-                selector.selectedKeys().clear();\n-            }\n-        }\n-\n-        public void close() throws IOException {\n-            if (closed)\n-                return;\n-            channel.close();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue(int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond(String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put(condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition(String condition) {\n-        BValue cond = getCond(condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous(String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get(name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException(\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue();\n-                conditions.put(name, cond);\n-                iv = new IValue(N-1);\n-                rv.put(name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get(name);\n-                iv.v--;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition(name);\n-        } else {\n-            setCondition(name);\n-            synchronized (conditions) {\n-                clearCondition(name);\n-                rv.remove(name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get(condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove(condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":0,"deletions":983,"binary":false,"changes":983,"status":"deleted"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270946\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @summary Check that X509CertImpl.getFingerprint does not return null when\n+ *          there are errors calculating the fingerprint\n+ *\/\n+\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.X509Certificate;\n+import sun.security.x509.X509CertImpl;\n+import sun.security.util.Debug;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.CertUtils;\n+\n+public class GetFingerprintError {\n+\n+    private static final Debug dbg = Debug.getInstance(\"certpath\");\n+\n+    public static void main(String[] args) throws Exception {\n+        X509Certificate cert = CertUtils.getCertFromString(CertUtils.RSA_CERT);\n+\n+        \/\/ test invalid MessageDigest algorithm\n+        Asserts.assertNull(X509CertImpl.getFingerprint(\"NoSuchAlg\", cert, dbg));\n+\n+        \/\/ test cert with bad encoding\n+        X509Certificate fcert = new X509CertificateWithBadEncoding(cert);\n+        Asserts.assertNull(X509CertImpl.getFingerprint(\"SHA-256\", fcert, dbg));\n+    }\n+\n+    private static class X509CertificateWithBadEncoding\n+            extends CertUtils.ForwardingX509Certificate {\n+        private X509CertificateWithBadEncoding(X509Certificate cert) {\n+            super(cert);\n+        }\n+        @Override\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            throw new CertificateEncodingException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/X509CertImpl\/GetFingerprintError.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,6 @@\n+    public AdditionalLauncher setShortcuts(boolean menu, boolean shortcut) {\n+        withMenuShortcut = menu;\n+        withShortcut = shortcut;\n+        return this;\n+    }\n+\n@@ -146,0 +152,12 @@\n+        if (withShortcut != null) {\n+            if (TKit.isLinux()) {\n+                properties.add(Map.entry(\"linux-shortcut\", withShortcut.toString()));\n+            } else if (TKit.isWindows()) {\n+                properties.add(Map.entry(\"win-shortcut\", withShortcut.toString()));\n+            }\n+        }\n+\n+        if (TKit.isWindows() && withMenuShortcut != null)  {\n+            properties.add(Map.entry(\"win-menu\", withMenuShortcut.toString()));\n+        }\n+\n@@ -181,1 +199,1 @@\n-                withLinuxDesktopFile = true;\n+                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n@@ -189,1 +207,1 @@\n-                withLinuxDesktopFile = true;\n+                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n@@ -200,2 +218,2 @@\n-                withLinuxDesktopFile = Stream.of(\"--linux-shortcut\").anyMatch(\n-                        cmd::hasArgument);\n+                withLinuxDesktopFile = (Boolean.FALSE != withShortcut) &&\n+                        Stream.of(\"--linux-shortcut\").anyMatch(cmd::hasArgument);\n@@ -215,0 +233,12 @@\n+    private void verifyShortcuts(JPackageCommand cmd) throws IOException {\n+        if (TKit.isLinux() && !cmd.isImagePackageType()\n+                && withShortcut != null) {\n+            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            if (withShortcut) {\n+                TKit.assertFileExists(desktopFile);\n+            } else {\n+                TKit.assertPathExists(desktopFile, false);\n+            }\n+        }\n+    }\n+\n@@ -217,0 +247,1 @@\n+        verifyShortcuts(cmd);\n@@ -243,0 +274,2 @@\n+    private Boolean withMenuShortcut;\n+    private Boolean withShortcut;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-        Assert.assertArrayEquals(new String[0],\n-                file.getAddLauncherNames().toArray(String[]::new));\n+\n+        Assert.assertEquals(0, file.getAddLaunchers().size());\n@@ -122,1 +122,1 @@\n-    public void testAddLauncherNames() throws IOException {\n+    public void testAddLaunchers() throws IOException {\n@@ -139,4 +139,8 @@\n-        List<String> addLauncherNames = aif.getAddLauncherNames();\n-        Assert.assertEquals(2, addLauncherNames.size());\n-        Assert.assertTrue(addLauncherNames.contains(\"Launcher2Name\"));\n-        Assert.assertTrue(addLauncherNames.contains(\"Launcher3Name\"));\n+        List<AppImageFile.LauncherInfo> addLaunchers = aif.getAddLaunchers();\n+        Assert.assertEquals(2, addLaunchers.size());\n+        List<String> names = new ArrayList<String>();\n+        names.add(addLaunchers.get(0).getName());\n+        names.add(addLaunchers.get(1).getName());\n+\n+        Assert.assertTrue(names.contains(\"Launcher2Name\"));\n+        Assert.assertTrue(names.contains(\"Launcher3Name\"));\n@@ -153,1 +157,1 @@\n-        Assert.assertNull(file.getAddLauncherNames());\n+        Assert.assertNull(file.getAddLaunchers());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.JPackageCommand;\n+\n+\/*\n+ * @test\n+ * @summary jpackage with values of --dest parameter breaking jpackage launcher\n+ * @requires (os.family == \"linux\")\n+ * @bug 8268974\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile LinuxWeirdOutputDirTest.java\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=LinuxWeirdOutputDirTest\n+ *\/\n+public class LinuxWeirdOutputDirTest {\n+\n+    @Test\n+    @Parameter(\"bin\")\n+    @Parameter(\"lib\")\n+    public void test(String outputPath) {\n+        JPackageCommand cmd = JPackageCommand.helloAppImage();\n+        cmd.setArgumentValue(\"--dest\", cmd.outputDir().resolve(outputPath));\n+        cmd.executeAndAssertHelloAppImageCreated();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/linux\/LinuxWeirdOutputDirTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.io.File;\n+import java.util.Map;\n+import java.lang.invoke.MethodHandles;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.FileAssociations;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Test;\n+\n+\/**\n+ * Test --add-launcher parameter with shortcuts (platform permitting).\n+ * Output of the test should be AddLShortcutTest*.* installer.\n+ * The output installer should provide the same functionality as the\n+ * default installer (see description of the default installer in\n+ * SimplePackageTest.java) plus install extra application launchers with and\n+ * without various shortcuts to be tested manually.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --add-launcher\n+ * @key jpackagePlatformPackage\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile AddLShortcutTest.java\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AddLShortcutTest\n+ *\/\n+\n+public class AddLShortcutTest {\n+\n+    @Test\n+    public void test() {\n+        \/\/ Configure several additional launchers with each combination of\n+        \/\/ possible shortcut hints in add-launcher property file.\n+        \/\/ default is true so Foo (no property), and Bar (properties set to \"true\")\n+        \/\/ will have shortcuts while other launchers with some properties set\n+        \/\/ to \"false\" will have none.\n+\n+        PackageTest packageTest = new PackageTest().configureHelloApp();\n+        packageTest.addInitializer(cmd -> {\n+            cmd.addArguments(\"--arguments\", \"Duke\", \"--arguments\", \"is\",\n+                    \"--arguments\", \"the\", \"--arguments\", \"King\");\n+            if (TKit.isWindows()) {\n+                cmd.addArguments(\"--win-shortcut\", \"--win-menu\");\n+            } else if (TKit.isLinux()) {\n+                cmd.addArguments(\"--linux-shortcut\");\n+            }\n+        });\n+\n+        new FileAssociations(\n+                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n+                packageTest);\n+\n+        new AdditionalLauncher(\"Foo\")\n+                .setDefaultArguments(\"yep!\")\n+                .setIcon(GOLDEN_ICON)\n+                .applyTo(packageTest);\n+\n+        new AdditionalLauncher(\"Bar\")\n+                .setDefaultArguments(\"one\", \"two\", \"three\")\n+                .setIcon(GOLDEN_ICON)\n+                .setShortcuts(true, true)\n+                .applyTo(packageTest);\n+\n+        new AdditionalLauncher(\"Launcher3\")\n+                .setDefaultArguments()\n+                .setIcon(GOLDEN_ICON)\n+                .setShortcuts(false, false)\n+                .applyTo(packageTest);\n+\n+        new AdditionalLauncher(\"Launcher4\")\n+                .setDefaultArguments()\n+                .setIcon(GOLDEN_ICON)\n+                .setShortcuts(true, false)\n+                .applyTo(packageTest);\n+\n+        new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments()\n+                .setIcon(GOLDEN_ICON)\n+                .setShortcuts(false, true)\n+                .applyTo(packageTest);\n+\n+        packageTest.run();\n+    }\n+\n+    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+            \"resources\", \"icon\" + TKit.ICON_SUFFIX));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -75,0 +75,1 @@\n+tools\/jdeprscan\/tests\/jdk\/jdeprscan\/TestRelease.java                            8270060    generic-all    java.util.SplittableRandom extends a non-exported class\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.util.Elements;\n+import javax.tools.Diagnostic;\n+import javax.tools.FileObject;\n+\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTreePathScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.TreePath;\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import jdk.javadoc.doclet.Taglet;\n+\n+\/**\n+ * A taglet to be called in the context of the standard doclet.\n+ * When invoked, it scans the entire enclosing doc comment, and\n+ * reports diagnostics at all instances of selected node kinds,\n+ * so that a test can verify the contents of the diagnostics.\n+ *\/\n+public class MyTaglet implements Taglet {\n+    private DocletEnvironment docEnv;\n+    private Reporter reporter;\n+\n+    @Override\n+    public void init(DocletEnvironment docEnv, Doclet doclet) {\n+        this.docEnv = docEnv;\n+        reporter = ((StandardDoclet) doclet).getReporter();\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return EnumSet.allOf(Location.class);\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"scanMe\";\n+    }\n+\n+    @Override\n+    public String toString(List<? extends DocTree> tags, Element element) {\n+        DocTrees trees = docEnv.getDocTrees();\n+        Elements elements = docEnv.getElementUtils();\n+        DocTreePath dtp;\n+        \/\/ Use reflection to access the file object underlying a doc-files\/*.html file\n+        \/\/ in order to access a DocCommentTree for the file.\n+        \/\/ Note that using reflective access inside javadoc requires the -XDallowInternalAccess option.\n+        \/\/ Note also that technically the doc comment tree that is found may be a different instance\n+        \/\/ to the current instance, but since we only want to scan it and report diagnostics,\n+        \/\/ that should not matter.\n+        if (element.getClass().getSimpleName().equals(\"DocFileElement\")) {\n+            try {\n+                Method getFileObjectMethod = element.getClass().getMethod(\"getFileObject\");\n+                FileObject fo = (FileObject) getFileObjectMethod.invoke(element);\n+                DocCommentTree dct = trees.getDocCommentTree(fo);\n+                dtp = trees.getDocTreePath(fo, elements.getPackageElement(\"p\"));\n+            } catch (ReflectiveOperationException e) {\n+                return \"MyTaglet[\" + e + \"]\";\n+            }\n+        } else {\n+            DocCommentTree dct = trees.getDocCommentTree(element);\n+            TreePath tp = trees.getPath(element);\n+            dtp = new DocTreePath(tp, dct);\n+        }\n+\n+        scan(dtp);\n+\n+        return \"MyTaglet[\" + element + \"]\";\n+    }\n+\n+    \/**\n+     * Scans a DocCommentTree, generating diagnostics for selected nodes.\n+     * Information about the expected position is encoded within the\n+     * text of the diagnostic, surrounded by {@code >>> <<<}.\n+     *\n+     * @param dtp the path to scan\n+     *\/\n+    void scan(DocTreePath dtp) {\n+        DocTreePathScanner<Void, Void> s = new DocTreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitDocComment(DocCommentTree t, Void p) {\n+                \/\/ By default, DocTreeScanner does not include the preamble and postamble\n+                scan(t.getPreamble(), p);\n+                super.visitDocComment(t, p);\n+                scan(t.getPostamble(), p);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitComment(CommentTree t, Void p) {\n+                report(t, t.getBody());\n+                return super.visitComment(t, p);\n+            }\n+\n+            @Override\n+            public Void visitDocType(DocTypeTree t, Void p) {\n+                report(t, t.getText());\n+                return super.visitDocType(t, p);\n+            }\n+\n+            @Override\n+            public Void visitReference(ReferenceTree t, Void p) {\n+                report(t, t.getSignature());\n+                return super.visitReference(t, p);\n+            }\n+\n+            @Override\n+            public Void visitText(TextTree t, Void p) {\n+                report(t, t.getBody());\n+                return super.visitText(t, p);\n+            }\n+\n+            void report(DocTree t, String s) {\n+                int pad = 3;\n+                assert (s.length() > 2 * pad + 3) : \">>>\" + s + \"<<<\";\n+                int mid = s.length() \/ 2;\n+                String detail = s.substring(mid - pad, mid) + \"[\" + s.charAt(mid) + \"]\" + s.substring(mid + 1, mid + pad + 1);\n+                \/\/ The diagnostic is reported at a position in a range of characters\n+                \/\/ in the middle of the string; the characters are encoded within the\n+                \/\/ message of the diagnostic, with {@code [ ]} surrounding the character\n+                \/\/ that should be indicated by the caret.\n+                reporter.print(Diagnostic.Kind.WARNING, getCurrentPath(),\n+                        mid - pad, mid, mid + pad + 1,\n+                        \"length: \" + s.length() + \" mid: \" + mid + \" >>>\" + detail + \"<<<\");\n+            }\n+        };\n+        s.scan(dtp, null);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocTreeDiags\/MyTaglet.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8268420\n+ * @summary  new Reporter method to report a diagnostic within a DocTree node\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.* MyTaglet\n+ * @run main TestDocTreeDiags\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.DocumentationTool;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests the ability to write diagnostics related to a (start,pos,end) range in those\n+ * DocTrees that wrap a String value.\n+ *\n+ * Ideally, this would be tested by using a custom doclet which scans all the doc comments,\n+ * generating diagnostics for eligible nodes. However, one of the cases that is tested is\n+ * a DocTypeTree, which only occurs in the context of an HTML file in a doc-files subdirectory,\n+ * which is very specific to the Standard Doclet. Therefore, we use the Standard Doclet\n+ * in conjunction with a non-standard use of a custom taglet, which is used to access and\n+ * scan the doc comments that enclose the tags that trigger the taglet.\n+ *\/\n+public class TestDocTreeDiags extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestDocTreeDiags tester = new TestDocTreeDiags();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())} );\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src;\n+    DocumentationTool tool;\n+\n+    boolean showOutput = false; \/\/ set true for to set output written by javadoc\n+\n+    TestDocTreeDiags() throws IOException {\n+        src = Path.of(\"src\");\n+        \/\/ Note: the following comments are somewhat stylized, and need to follow some\n+        \/\/ simple rules to avoid exceptions and false positives.\n+        \/\/ 1. Each fragment must be at least 7 (and preferably 9) characters long,\n+        \/\/    in order to contain the range that will be generated in the diagnostic.\n+        \/\/ 2. There must be no non-trivial duplication in the fragments, particularly\n+        \/\/    in the area where the range of characters will be generated for the\n+        \/\/    diagnostic. This is because we use String.indexOf to determine the\n+        \/\/    expected values of the range.\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/**\n+                     * First sentence. &quot;  Second sentence.\n+                     * {@link java.lang.String first phrase; &quot;  second phrase }\n+                     * And now ... <!-- this is a comment --> and so it was.\n+                     * @scanMe\n+                     *\/\n+                    public class C {\n+                        \/**\n+                         * Sentence for method m(). More details for the method.\n+                         * Embedded {@link java.lang.Object} link.\n+                         * And another <!-- unusual comment --> strange comment.\n+                         * @scanMe\n+                         *\/\n+                         public void m() { }\n+                    }\n+                    \"\"\");\n+        tb.writeFile(src.resolve(\"p\").resolve(\"doc-files\").resolve(\"extra.html\"),\n+                \"\"\"\n+                    <!doctype doctype-description>\n+                    <html>\n+                    <head><title>Document Title<\/title><\/head>\n+                    <body>\n+                    Extra content. More content.\n+                    @scanMe\n+                    <\/body>\n+                    <\/html>\n+                    \"\"\"\n+                );\n+\n+        tool = ToolProvider.getSystemDocumentationTool();\n+    }\n+\n+    \/**\n+     * Tests the diagnostics generated to the output stream when there is no\n+     * diagnostic listener in use.\n+     *\n+     * By default, in this context, the start and end of the range of characters are not\n+     * presented. The caret should point at the preferred position for the diagnostic.\n+     *\/\n+    @Test\n+    public void testStdout(Path base) throws Exception {\n+        StringWriter outWriter = new StringWriter();\n+        javadoc(outWriter, null, base.resolve(\"api\"));\n+\n+        \/\/ analyze and verify the generated diagnostics\n+        List<String> lines = outWriter.toString().lines().toList();\n+        Iterator<String> iter = lines.iterator();\n+        while (iter.hasNext()) {\n+            String l = iter.next();\n+            if (l.startsWith(\"src\")) {\n+                checkDiag(null, l, iter.next(), iter.next());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests the diagnostics received by a DiagnosticListener.\n+     *\n+     * In this context, various detailed coordinate information is available.\n+     *\/\n+    @Test\n+    public void testDiagListener(Path base) throws Exception {\n+        StringWriter outWriter = new StringWriter();\n+        DiagnosticListener dl = diagnostic -> {\n+            if (diagnostic.getPosition() != -1) {\n+                List<String> lines = List.of(diagnostic.toString().split(\"\\\\R\"));\n+                assert lines.size() == 3;\n+                String msgLine = lines.get(0);\n+                String srcLine = lines.get(1);\n+                String caretLine = lines.get(2);\n+                checkDiag(diagnostic, msgLine, srcLine, caretLine);\n+            }\n+        };\n+        javadoc(outWriter, dl, base.resolve(\"api\"));\n+    }\n+\n+    \/**\n+     * Runs javadoc on package {@code p} in the {@code src} directory,\n+     * using the specified writer and optional diagnostic listener.\n+     *\n+     * @param writer the writer\n+     * @param dl     the diagnostic listener, or {@code null}\n+     * @param outDir the output directory\n+     *\n+     * @throws IOException if an IO error occurs\n+     *\/\n+    void javadoc(StringWriter writer, DiagnosticListener dl, Path outDir) throws IOException {\n+        Files.createDirectories(outDir);\n+        try (StandardJavaFileManager fm = tool.getStandardFileManager(null, null, null)) {\n+            fm.setLocationFromPaths(StandardLocation.SOURCE_PATH, List.of(src));\n+            fm.setLocationFromPaths(DocumentationTool.Location.DOCUMENTATION_OUTPUT, List.of(outDir));\n+            fm.setLocationFromPaths(DocumentationTool.Location.TAGLET_PATH, List.of(Path.of(System.getProperty(\"test.classes\"))));\n+            Iterable<? extends JavaFileObject> files = Collections.emptyList();\n+            Iterable<String> options = List.of(\"-taglet\", MyTaglet.class.getName(), \"-XDaccessInternalAPI\", \"p\");\n+            DocumentationTool.DocumentationTask t = tool.getTask(writer, fm, dl, null, options, files);\n+\n+            checking(\"exit\");\n+            boolean ok = t.call();\n+\n+            if (showOutput) {\n+                out.println(\"OUT: >>>\" + writer.toString().replace(\"\\n\", NL) + \"<<<\");\n+            }\n+\n+            if (ok) {\n+                passed(\"javadoc exited OK, as expected\");\n+            } else {\n+                failed(\"javadoc failed\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks the diagnostic output against information encoded in the diagnostics.\n+     *\n+     * The message in the message line contains a string that indicates where the\n+     * caret should be pointing in the source line.\n+     *\n+     * @param diag          the diagnostic, or null\n+     * @param msgLine       file:line: message   >>>detail<<<\n+     * @param srcLine       the source line\n+     * @param caretLine     the line with the caret\n+     *\/\n+    void checkDiag(Diagnostic diag, String msgLine, String srcLine, String caretLine) {\n+        if (diag != null) {\n+            out.printf(\"DIAG:  %d:%d:%d  %d:%d vvv%n%s%n^^^%n\",\n+                    diag.getStartPosition(), diag.getPosition(), diag.getEndPosition(),\n+                    diag.getLineNumber(), diag.getColumnNumber(),\n+                    diag.toString().replace(\"\\\\R\", NL) );\n+        }\n+        out.println(msgLine);\n+        out.println(srcLine);\n+        out.println(caretLine);\n+\n+        String srcFileLine = msgLine.substring(0, msgLine.indexOf(\": \"));\n+        int caretIndex = caretLine.indexOf('^');\n+        Pattern p = Pattern.compile(\">>>([^<]*)<<<\");\n+        Matcher m = p.matcher(msgLine);\n+        if (!m.find()) {\n+            throw new IllegalArgumentException(\"detail pattern not found: \" + msgLine);\n+        }\n+        String rawDetail = m.group(1);\n+        String detail = rawDetail.replaceAll(\"[\\\\[\\\\]]\", \"\");\n+\n+        if (diag != null) {\n+            checking(\"coords-column: \" + srcFileLine);\n+            int col = (int) diag.getColumnNumber();\n+            \/\/ line and column are 1-based, so col should be 1 more than caretIndex\n+            if (col - 1 == caretIndex) {\n+                passed(\"col: \" + col + \" caret: \" + caretIndex);\n+            } else {\n+                failed(\"col: \" + col + \" caret: \" + caretIndex);\n+            }\n+\n+            checking(\"coords-start-end: \" + srcFileLine);\n+            String fileStr = readFile(\".\", msgLine.substring(0, msgLine.indexOf(\":\")));\n+            int start = (int) diag.getStartPosition();\n+            int end = (int) diag.getEndPosition();\n+            String fileRange = fileStr.substring(start, end);\n+            if (fileRange.equals(detail)) {\n+                passed(\"file: >>>\" + fileRange + \"<<<  message: >>>\" + detail + \"<<<\");\n+            } else {\n+                failed(\"file: >>>\" + fileRange + \"<<<  message: >>>\" + detail + \"<<<\");\n+            }\n+        }\n+\n+        checking(\"message-caret: \" + srcFileLine);\n+        int srcIndex = srcLine.indexOf(detail);\n+        int pad = (detail.length() - 1) \/ 2;\n+        int srcIndexPad = srcIndex + pad;\n+        if (srcIndexPad == caretIndex) {\n+            passed(\"src: \" + srcIndexPad + \" caret: \" + caretIndex);\n+        } else {\n+            failed(\"src: \" + srcIndexPad + \" caret: \" + caretIndex);\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocTreeDiags\/TestDocTreeDiags.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8266082\n+ * @summary javac should not crash when seeing type annotations in links\n+ * @compile\/fail\/ref=CrashInAnnotateTest.out -Xdoclint -XDrawDiagnostics CrashInAnnotateTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+\/** {@link #equals(@Deprecated Object)}\n+ *  {@link java.util.Map.@Deprecated Entry#getKey()}\n+ *\/\n+class CrashInAnnotateTest {\n+}\n+\n+\/** {@link #compare(Object, List<List<@Deprecated Object>>)} *\/\n+class CrashInAnnotateTest2 {\n+    void compare(Object o, List<List<Object>> l) {}\n+}\n+\n+\/** {@link @Deprecated java.lang.Object#hashCode()} *\/\n+class CrashInAnnotateTest3 { }\n+\n+\/** {@link CrashInAnnotateTest4.@java.lang.Deprecated Inner#aField}\n+ *  {@link java.util.Map.@Deprecated#getKey()}\n+ *\/\n+class CrashInAnnotateTest4 {\n+    class Inner {\n+        Object aField;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+CrashInAnnotateTest.java:10:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:11:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:16:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:18:10: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:21:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:24:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:25:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:28:5: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:29:16: compiler.warn.proc.messager: no comment\n+6 errors\n+3 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ *                                      RELEASE_18\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-        SEVENTEEN(\"17\", 61);\n+        SEVENTEEN(\"17\", 61),\n+        EIGHTEEN(\"18\", 62);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.ref.annotations.not.allowed\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** {@link #equals(@Deprecated Object)} *\/\n+class NoAnnotationsInLink {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoAnnotationsInLink.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225559\n+ * @summary assertion error at TransTypes.visitApply\n+ * @compile ProtectedConstructorTest.java\n+ *\/\n+\n+import pkg.Bar;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ProtectedConstructorTest {\n+    public void foo() {\n+        supply(getSupplier(new Bar<>(){}));\n+        CompletableFuture<List<String>> completableFuture = getCompletableFuture(getSupplier(new Bar<>(){}));\n+        completableFuture = getCompletableFuture(() -> getList(null, new Bar<>() {}));\n+    }\n+\n+    static <U> Supplier<U> getSupplier(Bar<U> t) {\n+        return null;\n+    }\n+\n+    static <U> void supply(Supplier<U> supplier) {}\n+    static <U> CompletableFuture<U> getCompletableFuture(Supplier<U> supplier) { return null; }\n+    <T> List<T> getList(final Supplier<List<T>> supplier, Bar<T> t) { return null; }\n+}\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/protectedConstructor\/ProtectedConstructorTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+public abstract class Bar<T> {\n+    protected Bar() {}\n+    protected Bar(Class<?> c) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/protectedConstructor\/pkg\/Bar.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8261006\n+ * @summary 'super' qualified method references cannot occur in a static context\n+ * @compile\/fail\/ref=MethodReferenceInConstructorInvocation.out -XDrawDiagnostics MethodReferenceInConstructorInvocation.java\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public class MethodReferenceInConstructorInvocation {\n+    interface Bar {\n+        default String getString() {\n+            return \"\";\n+        }\n+    }\n+\n+    static class Foo implements Bar {\n+\n+        Foo() {\n+            this(Bar.super::getString);\n+        }\n+        Foo(Supplier<String> sString) {}\n+\n+        Foo(int i) { this(Bar.super.getString()); }\n+        Foo(String s) {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodReferenceInConstructorInvocation.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+MethodReferenceInConstructorInvocation.java:20:21: compiler.err.cant.ref.before.ctor.called: super\n+MethodReferenceInConstructorInvocation.java:24:30: compiler.err.cant.ref.before.ctor.called: super\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodReferenceInConstructorInvocation.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -124,1 +124,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -134,1 +134,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -144,1 +144,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -165,1 +165,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -184,1 +184,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -205,1 +205,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -226,1 +226,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -247,1 +247,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 17\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 17\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,2 @@\n-        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\");\n+        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\",\n+               \"15\", \"16\", \"17\", \"18\");\n@@ -75,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"61.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"62.0\";\n@@ -88,1 +89,2 @@\n-        SEVENTEEN(false,  \"61.0\", \"17\", Versions::checksrc17);\n+        SEVENTEEN(false, \"61.0\", \"17\", Versions::checksrc17),\n+        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18);\n@@ -139,1 +141,1 @@\n-            for (int j = i; j > 0; j--) {\n+            for (int j = i - 1; j >= 0; j--) {\n@@ -158,1 +160,1 @@\n-            if (i == sourceTargets.length) {\n+            if (i == sourceTargets.length - 1) {\n@@ -304,1 +306,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+        expectedFail(args, List.of(\"New17.java\"));\n@@ -310,1 +312,8 @@\n-                                  \"New14.java\", \"New15.java\", \"New16.java\"));\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n+       \/\/ Add expectedFail after new language features added in a later release.\n+    }\n+\n+   protected void checksrc18(List<String> args) {\n+       printargs(\"checksrc18\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n@@ -538,0 +547,15 @@\n+\n+        \/*\n+         * Create a file with a new feature in 17, not in 16 : sealed classes\n+         *\/\n+        writeSourceFile(\"New17.java\",\n+            \"\"\"\n+            public class New17 {\n+                public static sealed class Seal {}\n+\n+                public static final class Pinniped extends Seal {}\n+                public static final class TaperedThread extends Seal {}\n+                public static final class Wax extends Seal {}\n+            }\n+            \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class JDWP {\n+\n+    public record ListenAddress(String transport, String address) {\n+    }\n+\n+    \/\/ lazy initialized\n+    private static Pattern listenRegexp;\n+\n+    \/**\n+     * Parses debuggee output to get listening transport and address.\n+     * Returns null if the string specified does not contain required info.\n+     *\/\n+    public static ListenAddress parseListenAddress(String debuggeeOutput) {\n+        if (listenRegexp == null) {\n+            listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        }\n+        Matcher m = listenRegexp.matcher(debuggeeOutput);\n+        if (m.find()) {\n+            return new ListenAddress(m.group(1), m.group(2));\n+        }\n+        return null;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/JDWP.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Objects;\n@@ -266,3 +267,1 @@\n-        if (index < 0 || index >= getLength()) {\n-            throw new ArrayIndexOutOfBoundsException(index);\n-        }\n+        Objects.checkIndex(index, getLength());\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -162,1 +162,6 @@\n-                    \/\/ Check dump data header and print stack trace.\n+                } catch (Exception e) {\n+                    out.delete();\n+                    throw new IOException(\"Cannot decompress the compressed hprof file\", e);\n+                }\n+                \/\/ Check dump data header and print stack trace.\n+                try {\n@@ -172,0 +177,2 @@\n+                    } else {\n+                        throw new IOException(\"Unrecognized magic number found in decompressed data: \" + i);\n@@ -173,2 +180,2 @@\n-                } catch (Exception e) {\n-                    throw new IOException(\"Can not decompress the compressed hprof file\", e);\n+                } finally {\n+                    out.delete();\n@@ -176,1 +183,0 @@\n-                out.delete();\n@@ -181,1 +187,0 @@\n-        return null;\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/Reader.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -83,3 +83,0 @@\n-    public final static String BiasedLockRevocation = PREFIX + \"BiasedLockRevocation\";\n-    public final static String BiasedLockSelfRevocation = PREFIX + \"BiasedLockSelfRevocation\";\n-    public final static String BiasedLockClassRevocation = PREFIX + \"BiasedLockClassRevocation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.math.BigInteger;\n@@ -41,0 +42,1 @@\n+import java.security.InvalidKeyException;\n@@ -43,0 +45,2 @@\n+import java.security.NoSuchProviderException;\n+import java.security.Principal;\n@@ -44,0 +48,2 @@\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n@@ -49,0 +55,1 @@\n+import java.security.cert.CertificateEncodingException;\n@@ -50,0 +57,1 @@\n+import java.security.cert.CertificateExpiredException;\n@@ -51,0 +59,1 @@\n+import java.security.cert.CertificateNotYetValidException;\n@@ -62,0 +71,1 @@\n+import java.util.Date;\n@@ -633,0 +643,63 @@\n+\n+    \/**\n+     * This class is useful for overriding one or more methods of an\n+     * X509Certificate for testing purposes.\n+     *\/\n+    public static class ForwardingX509Certificate extends X509Certificate {\n+        private final X509Certificate cert;\n+        public ForwardingX509Certificate(X509Certificate cert) {\n+            this.cert = cert;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+           return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() throws CertificateExpiredException,\n+            CertificateNotYetValidException { \/* always pass *\/ }\n+        public void checkValidity(Date date) throws CertificateExpiredException,\n+            CertificateNotYetValidException { \/* always pass *\/ }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return cert.getNotBefore(); }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+            InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertUtils.java","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-    return getMethodCompilationLevel(method, false \/*not ost*\/);\n+    return getMethodCompilationLevel(method, false \/*not osr*\/);\n@@ -608,0 +608,1 @@\n+  public native boolean handshakeReadMonitors(Thread t);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import sun.security.util.DisabledAlgorithmConstraints;\n+\n+import java.security.AlgorithmConstraints;\n+import java.security.CryptoPrimitive;\n+import java.util.concurrent.TimeUnit;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static sun.security.util.DisabledAlgorithmConstraints.PROPERTY_TLS_DISABLED_ALGS;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.util=ALL-UNNAMED\"})\n+@State(Scope.Thread)\n+public class AlgorithmConstraintsPermits {\n+\n+    AlgorithmConstraints tlsDisabledAlgConstraints;\n+    Set<CryptoPrimitive> primitives = EnumSet.of(CryptoPrimitive.KEY_AGREEMENT);\n+\n+    @Param({\"SSLv3\", \"DES\", \"NULL\", \"TLS1.3\"})\n+    String algorithm;\n+\n+    @Setup\n+    public void setup() {\n+        tlsDisabledAlgConstraints = new DisabledAlgorithmConstraints(PROPERTY_TLS_DISABLED_ALGS);\n+    }\n+\n+    @Benchmark\n+    public boolean permits() {\n+        return tlsDisabledAlgConstraints.permits(primitives, algorithm, null);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/AlgorithmConstraintsPermits.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+@Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/sun.security.ssl=ALL-UNNAMED\", \"--add-opens\", \"java.base\/sun.security.ssl=ALL-UNNAMED\"})\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class CipherSuiteBench {\n+\n+    Method nameOf;\n+\n+    @Param({\"TLS_AES_256_GCM_SHA384\",\n+            \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\",\n+            \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\",\n+            \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\" })\n+    String cipherSuite;\n+\n+    @Setup\n+    public void initilizeClass() throws ClassNotFoundException, NoSuchMethodException {\n+        Class<?> cs = Class.forName(\"sun.security.ssl.CipherSuite\");\n+        nameOf = cs.getDeclaredMethod(\"nameOf\", String.class);\n+        nameOf.setAccessible(true);\n+    }\n+\n+    @Benchmark\n+    public Object benchmarkCipherSuite() throws InvocationTargetException, IllegalAccessException {\n+        return nameOf.invoke(null,cipherSuite);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/CipherSuiteBench.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import javax.crypto.BadPaddingException;\n@@ -31,2 +30,0 @@\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.NoSuchPaddingException;\n@@ -35,4 +32,0 @@\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.InvalidParameterSpecException;\n@@ -40,0 +33,7 @@\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using byte[]\n+ * as input and output buffers for single and multi-part testing.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n@@ -43,3 +43,0 @@\n-    @Param({\"AES\/GCM\/NoPadding\"})\n-    private String algorithm;\n-\n@@ -49,1 +46,1 @@\n-    @Param({\"\"+16*1024})\n+    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n@@ -52,1 +49,0 @@\n-    byte[] data;\n@@ -54,0 +50,1 @@\n+    byte[] in, out;\n@@ -58,1 +55,0 @@\n-    byte[] aad;\n@@ -61,2 +57,2 @@\n-    public static final int IV_BUFFER_SIZE = 32;\n-    public static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n@@ -64,0 +60,1 @@\n+    int updateLen = 0;\n@@ -72,1 +69,1 @@\n-    public void setup() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidParameterSpecException {\n+    public void setup() throws Exception {\n@@ -74,1 +71,0 @@\n-        assert algorithm.split(\"\/\")[1].compareToIgnoreCase(\"GCM\") == 0;\n@@ -76,0 +72,1 @@\n+        \/\/ Setup key material\n@@ -80,2 +77,3 @@\n-        aad = fillSecureRandom(new byte[5]);\n-        encryptCipher = makeCipher(prov, algorithm);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n@@ -83,4 +81,12 @@\n-        encryptCipher.updateAAD(aad);\n-        decryptCipher = makeCipher(prov, algorithm);\n-        data = fillRandom(new byte[dataSize]);\n-        encryptedData = encryptCipher.doFinal(data);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new byte[encryptedData.length];\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+        updateLen = in.length \/ 2;\n+\n@@ -90,1 +96,1 @@\n-    public byte[] encrypt() throws BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeyException {\n+    public void encrypt() throws Exception {\n@@ -93,2 +99,1 @@\n-        encryptCipher.updateAAD(aad);\n-        return encryptCipher.doFinal(data);\n+        encryptCipher.doFinal(in, 0, in.length, out, 0);\n@@ -98,4 +103,14 @@\n-    public byte[] decrypt() throws BadPaddingException, IllegalBlockSizeException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException {\n-        decryptCipher.init(Cipher.DECRYPT_MODE, ks, encryptCipher.getParameters().getParameterSpec(GCMParameterSpec.class));\n-        decryptCipher.updateAAD(aad);\n-        return decryptCipher.doFinal(encryptedData);\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        int outOfs = encryptCipher.update(in, 0, updateLen, out, 0);\n+        encryptCipher.doFinal(in, updateLen, in.length - updateLen,\n+            out, outOfs);\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, 0, encryptedData.length, out, 0);\n@@ -104,0 +119,9 @@\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.update(encryptedData, 0, updateLen, out, 0);\n+        decryptCipher.doFinal(encryptedData, updateLen,\n+            encryptedData.length - updateLen, out, 0);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMBench.java","additions":54,"deletions":30,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This performance tests runs AES\/GCM encryption and decryption using heap and\n+ * direct ByteBuffers as input and output buffers for single and multi-part\n+ * operations.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMByteBuffer extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"1024\", \"1500\", \"4096\", \"16384\"})\n+    private int dataSize;\n+\n+    @Param({\"direct\", \"heap\"})\n+    private String dataMethod;\n+\n+    byte[] data;\n+    ByteBuffer encryptedData;\n+    ByteBuffer in, out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+    int updateLen = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        data = fillRandom(new byte[dataSize]);\n+        if (dataMethod.equalsIgnoreCase(\"direct\")) {\n+            in = ByteBuffer.allocateDirect(data.length);\n+            in.put(data);\n+            in.flip();\n+            encryptedData = ByteBuffer.allocateDirect(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocateDirect(encryptedData.capacity());\n+        } else if (dataMethod.equalsIgnoreCase(\"heap\")) {\n+            in = ByteBuffer.wrap(data);\n+            encryptedData = ByteBuffer.allocate(\n+                encryptCipher.getOutputSize(data.length));\n+            out = ByteBuffer.allocate(encryptedData.capacity());\n+        }\n+\n+        encryptCipher.doFinal(in, encryptedData);\n+        encryptedData.flip();\n+        in.flip();\n+        updateLen = in.remaining() \/ 2;\n+    }\n+\n+    @Benchmark\n+    public void encrypt() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void encryptMultiPart() throws Exception {\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        in.limit(updateLen);\n+        encryptCipher.update(in, out);\n+        in.limit(in.capacity());\n+        encryptCipher.doFinal(in, out);\n+        out.flip();\n+        in.flip();\n+    }\n+\n+    @Benchmark\n+    public void decrypt() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+    @Benchmark\n+    public void decryptMultiPart() throws Exception {\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        int len = encryptedData.remaining();\n+        encryptedData.limit(updateLen);\n+        decryptCipher.update(encryptedData, out);\n+        encryptedData.limit(len);\n+\n+        decryptCipher.doFinal(encryptedData, out);\n+        encryptedData.flip();\n+        out.flip();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMByteBuffer.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,2 @@\n-public class AESGCMBench extends org.openjdk.bench.javax.crypto.full.AESGCMBench {\n-\n-\n-    @Param({\"AES\/GCM\/NoPadding\"})\n-    private String algorithm;\n+public class AESGCMBench extends\n+    org.openjdk.bench.javax.crypto.full.AESGCMBench {\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMBench.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.small;\n+\n+import org.openjdk.jmh.annotations.Param;\n+\n+public class AESGCMByteBuffer extends\n+    org.openjdk.bench.javax.crypto.full.AESGCMByteBuffer {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"1024\"})\n+    private int dataSize;\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/small\/AESGCMByteBuffer.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\",\n+    \"-Djdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK=1\"})\n+public class TestLoadStoreBytes {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  private byte[] srcArray;\n+\n+  private byte[] dstArray;\n+\n+\n+  private ByteBuffer srcBufferHeap;\n+\n+  private ByteBuffer dstBufferHeap;\n+\n+  private ByteBuffer srcBufferNative;\n+\n+  private ByteBuffer dstBufferNative;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegmentImplicit;\n+\n+  private MemorySegment dstSegmentImplicit;\n+\n+  private ByteBuffer srcBufferSegmentImplicit;\n+\n+  private ByteBuffer dstBufferSegmentImplicit;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+  byte[] a, b, c;\n+\n+  @Setup\n+  public void setup() {\n+    srcArray = new byte[size];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (byte) i;\n+    }\n+\n+\n+    srcBufferHeap = ByteBuffer.allocate(size);\n+    dstBufferHeap = ByteBuffer.allocate(size);\n+\n+    srcBufferNative = ByteBuffer.allocateDirect(size);\n+    dstBufferNative = ByteBuffer.allocateDirect(size);\n+\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n+    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+\n+\n+    srcAddress = CLinker.allocateMemory(size);\n+    dstAddress = CLinker.allocateMemory(size);\n+\n+    a = new byte[size];\n+    b = new byte[size];\n+    c = new byte[size];\n+  }\n+\n+\n+  @Benchmark\n+  public void array() {\n+\/\/    final var srcArray = this.srcArray;\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void array2() {\n+\/\/    final var srcArray = this.srcArray;\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteArray(SPECIES, srcArray, i, ByteOrder.nativeOrder());\n+      v.intoByteArray(dstArray, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i ++) {\n+      var v = srcArray[i];\n+      dstArray[i] = v;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+      ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ByteVector av = ByteVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ByteVector bv = ByteVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeap() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeapScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = srcBufferHeap.get(i);\n+      dstBufferHeap.put(i, v);\n+    }\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void bufferNative() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNativeScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = srcBufferNative.get(i);\n+      dstBufferNative.put(i, v);\n+    }\n+  }\n+\n+\n+  @Benchmark\n+  public void bufferSegmentImplicit() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void segmentImplicitScalar() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n+      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+\n+      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class TestLoadStoreShort {\n+  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n+\n+  @Param(\"256\")\n+  private int size;\n+\n+  private int longSize;\n+\n+  private short[] srcArray;\n+\n+  private short[] dstArray;\n+\n+\n+  private ByteBuffer srcBufferHeap;\n+\n+  private ByteBuffer dstBufferHeap;\n+\n+  private ByteBuffer srcBufferNative;\n+\n+  private ByteBuffer dstBufferNative;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegmentImplicit;\n+\n+  private MemorySegment dstSegmentImplicit;\n+\n+  private ByteBuffer srcBufferSegmentImplicit;\n+\n+  private ByteBuffer dstBufferSegmentImplicit;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+\/\/  private byte[] bigArray = new byte[Integer.MAX_VALUE];\n+\n+  private volatile short[] a, b, c;\n+  @Setup\n+  public void setup() {\n+    var longSize = size \/ Short.BYTES;\n+    srcArray = new short[longSize];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (short) i;\n+    }\n+\n+\n+    srcBufferHeap = ByteBuffer.allocate(size);\n+    dstBufferHeap = ByteBuffer.allocate(size);\n+\n+    srcBufferNative = ByteBuffer.allocateDirect(size);\n+    dstBufferNative = ByteBuffer.allocateDirect(size);\n+\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n+    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+\n+\n+    srcAddress = CLinker.allocateMemory(size);\n+    dstAddress = CLinker.allocateMemory(size);\n+\n+    this.longSize = longSize;\n+\n+    a = new short[size];\n+    b = new short[size];\n+    c = new short[size];\n+\n+  }\n+\n+  @TearDown\n+  public void tearDown() {\n+    CLinker.freeMemory(srcAddress);\n+    CLinker.freeMemory(dstAddress);\n+  }\n+\n+  @Benchmark\n+  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void array() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferHeap() {\n+    for (int i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNative() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferNativeAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n+      v = v.add(v);\n+      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentImplicit() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void bufferSegmentConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+\n+      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -141,3 +142,1 @@\n-            if ((index < 0) || (index >= count)) {\n-                throw new StringIndexOutOfBoundsException(index);\n-            }\n+            Objects.checkIndex(index, count);\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/CopyLoop.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,12 +113,0 @@\n-    \/**\n-     * Same as {@link #testRecursiveSynchronization()} but the first call\n-     * to this method will generate the identity hashcode for this object\n-     * which effectively disables biased locking as they occupy the same\n-     * bits in the object header.\n-     *\/\n-    @Benchmark\n-    public void testRecursiveSynchronizationNoBias() {\n-        System.identityHashCode(this);\n-        factorial = fact(10);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}