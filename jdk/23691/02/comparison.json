{"files":[{"patch":"@@ -1120,0 +1120,1 @@\n+  ResourceMark rm;\n@@ -2361,1 +2362,30 @@\n-    \/\/ see if this phi should be sliced\n+\n+    \/\/ See if this Phi should be sliced. Determine the merge width of input\n+    \/\/ MergeMems and check if there is a direct loop to self, as illustrated\n+    \/\/ below.\n+    \/\/\n+    \/\/               +-------------+\n+    \/\/               |             |\n+    \/\/ (base_memory) v             |\n+    \/\/              MergeMem       |\n+    \/\/                 |           |\n+    \/\/                 v           |\n+    \/\/                Phi (this)   |\n+    \/\/                 |           |\n+    \/\/                 +-----------+\n+    \/\/\n+    \/\/ Generally, there are issues with non-termination with such circularity\n+    \/\/ (see comment further below). However, if there is a direct loop to self,\n+    \/\/ splitting the Phi through the MergeMem will result in the below.\n+    \/\/\n+    \/\/               +---+\n+    \/\/               |   |\n+    \/\/               v   |\n+    \/\/              Phi  |\n+    \/\/               |\\  |\n+    \/\/               | +-+\n+    \/\/ (base_memory) v\n+    \/\/              MergeMem\n+    \/\/\n+    \/\/ This split breaks the circularity and consequently does not lead to\n+    \/\/ non-termination.\n@@ -2363,1 +2393,1 @@\n-    bool saw_self = false;\n+    bool split_must_terminate = false; \/\/ Is splitting guaranteed to terminate?\n@@ -2375,1 +2405,3 @@\n-        saw_self = saw_self || (n->base_memory() == this);\n+        if (n->base_memory() == this) {\n+          split_must_terminate = true;\n+        }\n@@ -2379,2 +2411,59 @@\n-    \/\/ This restriction is temporarily necessary to ensure termination:\n-    if (!saw_self && adr_type() == TypePtr::BOTTOM)  merge_width = 0;\n+    \/\/ There are cases with circular dependencies between bottom Phis\n+    \/\/ and MergeMems. Below is a minimal example.\n+    \/\/\n+    \/\/               +------------+\n+    \/\/               |            |\n+    \/\/ (base_memory) v            |\n+    \/\/              MergeMem      |\n+    \/\/                 |          |\n+    \/\/                 v          |\n+    \/\/                Phi (this)  |\n+    \/\/                 |          |\n+    \/\/                 v          |\n+    \/\/                Phi         |\n+    \/\/                 |          |\n+    \/\/                 +----------+\n+    \/\/\n+    \/\/ Here, we cannot break the circularity through a self-loop as there\n+    \/\/ are two Phis involved. Repeatedly splitting the Phis through the\n+    \/\/ MergeMem leads to non-termination. We check for non-termination below.\n+    \/\/ Only check for non-termination if necessary.\n+    if (!split_must_terminate && adr_type() == TypePtr::BOTTOM &&\n+        merge_width > Compile::AliasIdxRaw) {\n+      ResourceMark rm;\n+      VectorSet visited;\n+      Node_List worklist;\n+      worklist.push(this);\n+      visited.set(this->_idx);\n+      auto maybe_add_to_worklist = [&](Node* input) {\n+        if (input != nullptr &&\n+            (input->is_MergeMem() || input->is_memory_phi()) &&\n+            !visited.test_set(input->_idx)) {\n+          worklist.push(input);\n+          assert(input->adr_type() == TypePtr::BOTTOM,\n+                 \"should only visit bottom memory\");\n+        }\n+      };\n+      split_must_terminate = true; \/\/ Assume no circularity until proven otherwise.\n+      while (split_must_terminate && worklist.size() > 0) {\n+        Node* n = worklist.pop();\n+        if (n->is_MergeMem()) {\n+          Node* input = n->as_MergeMem()->base_memory();\n+          if (input == this) {\n+            split_must_terminate = false;\n+            break;\n+          }\n+          maybe_add_to_worklist(input);\n+        } else {\n+          assert(n->is_memory_phi(), \"invariant\");\n+          for (uint i = PhiNode::Input; i < n->req(); i++) {\n+            Node* input = n->in(i);\n+            if (input == this) {\n+              split_must_terminate = false;\n+              break;\n+            }\n+            maybe_add_to_worklist(input);\n+          }\n+        }\n+      }\n+    }\n@@ -2382,1 +2471,1 @@\n-    if (merge_width > Compile::AliasIdxRaw) {\n+    if (split_must_terminate && merge_width > Compile::AliasIdxRaw) {\n@@ -2413,3 +2502,2 @@\n-        \/\/ We know that at least one MergeMem->base_memory() == this\n-        \/\/ (saw_self == true). If all other inputs also references this phi\n-        \/\/ (directly or through data nodes) - it is a dead loop.\n+        \/\/ If all inputs reference this phi (directly or through data nodes) -\n+        \/\/ it is a dead loop.\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":97,"deletions":9,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.codegen;\n+\n+\/**\n+ * @test\n+ * @bug 8333393\n+ * @summary Test that loads are not scheduled too late.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=dontinline,*::dontInline\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:LoopMaxUnroll=0 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*Test*::test\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.codegen.TestGCMLoadPlacement\n+ * @run main compiler.codegen.TestGCMLoadPlacement\n+ *\/\n+\n+public class TestGCMLoadPlacement {\n+\n+    public static void main(String[] args) {\n+        int c = 0;\n+        try {\n+            Test1.run();\n+        } catch (Exception e) {\n+            c++; System.out.println(\"Test1 failure\");\n+        }\n+        try {\n+            Test2.run();\n+        } catch (Exception e) {\n+            c++; System.out.println(\"Test2 failure\");\n+        }\n+        try {\n+            Test3.run();\n+        } catch (Exception e) {\n+            c++; System.out.println(\"Test3 failure\");\n+        }\n+        try {\n+            Test4.run();\n+        } catch (Exception e) {\n+            c++; System.out.println(\"Test4 failure\");\n+        }\n+        try {\n+            Test5.run();\n+        } catch (Exception e) {\n+            c++; System.out.println(\"Test5 failure\");\n+        }\n+        if (c > 0) {\n+            throw new RuntimeException(\"Test failures: \" + c);\n+        }\n+    }\n+\n+    static class Test1 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int i = 0; i < 50; ++i)\n+                for (int j = 0; j < 50; ++j) {\n+                    if (flag) { return 0; } \/\/ Forces peeling\n+                    iFld = 0;\n+                    for (int k = 0; k < 1; ++k) {\n+                    }\n+                }\n+            int res = iFld; \/\/ This load needs to schedule before the loop below ...\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 42;\n+            }\n+            \/\/ ... and was incorrectly scheduled here.\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test1 t = new Test1();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test2 {\n+        static void run() {\n+            for (int i = 0; i < 500; i++) {\n+                int res = test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"res = \" + res);\n+                }\n+            }\n+        }\n+\n+        static int test() {\n+            int res = 0;\n+            int array[] = new int[50];\n+            for (int j = 0; j < array.length; j++) {\n+                array[j] = 0;\n+            }\n+            int x = array[0];\n+            for (int i = 5; i < 10; i++) {\n+                array[0] = 42;\n+                for (int j = 0; j < 10; j++) {\n+                    dontInline();\n+                    res = x;\n+                }\n+            }\n+            return res;\n+        }\n+\n+        static void dontInline() {}\n+    }\n+\n+    static class Test3 {\n+        static boolean flag;\n+        static int N = 400;\n+        long instanceCount;\n+        float fFld = 2.957F;\n+        volatile short sFld;\n+        int iArrFld[] = new int[N];\n+\n+        int test() {\n+            int i22 = 7, i25, i27, i28 = 5, i29, i31, i33;\n+            for (i25 = 229; i25 > 2; --i25) {\n+                if (flag) { return 9; }\n+                iArrFld[1] *= instanceCount;\n+                for (i27 = 4; i27 < 116; ++i27) {\n+                }\n+            }\n+            i22 += fFld;\n+            for (i29 = 23; 8 < i29; i29--) {\n+                for (i31 = 2; i31 < 17; i31++) {\n+                    if (flag) { return 9; }\n+                    i28 = sFld;\n+                }\n+                for (i33 = 1; 7 > i33; ++i33) {\n+                    if (flag) { return 9; }\n+                    fFld = instanceCount;\n+                }\n+            }\n+            return i22;\n+        }\n+\n+        static void run() {\n+            Test3 r = new Test3();\n+            int result = r.test();\n+            if (result != 9) {\n+                throw new RuntimeException(\"Expected 9 but found \" + result);\n+            }\n+        }\n+    }\n+\n+    static class Test4 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld;\n+\n+        int test() {\n+            for (int j = 0; j < 50; ++j) {\n+                iFld = 0;\n+                if (flag) { return 0; }\n+\n+                for (int k = 0; k < 2000; ++k) {\n+                }\n+            }\n+\n+            int res = iFld;\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 1;\n+            }\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test4 t = new Test4();\n+            for (int i = 0; i < 10; i++) {\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Test5 {\n+        static boolean flag;\n+        volatile byte volFld;\n+        int iFld, iFld2;\n+\n+        int test() {\n+            for (int j = 0; j < 50; ++j) {\n+                iFld2 = 0;\n+                if (flag) { return 0; }\n+\n+                for (int k = 0; k < 2000; ++k) {\n+                }\n+            }\n+\n+            int res = iFld;\n+            for (int i = 0; i < 50; ++i) {\n+                volFld = 0;\n+                iFld -= 1;\n+            }\n+            return res;\n+        }\n+\n+        static void run() {\n+            Test5 t = new Test5();\n+            for (int i = 0; i < 10; i++) {\n+                t.iFld = 0;\n+                int res = t.test();\n+                if (res != 0) {\n+                    throw new RuntimeException(\"Unexpected result: \" + res);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMLoadPlacement.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"}]}