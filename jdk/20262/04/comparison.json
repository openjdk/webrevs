{"files":[{"patch":"@@ -728,1 +728,1 @@\n-        $1_CFLAGS_CPU=\"-mcpu=powerpc64 -mtune=power5\"\n+        $1_CFLAGS_CPU=\"-mcpu=power8 -mtune=power8\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2000,1 +2000,1 @@\n-  inline void waitrsv(); \/\/ >=Power7\n+  inline void waitrsv();\n@@ -2031,1 +2031,0 @@\n-  \/\/ >= Power7\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -211,2 +211,1 @@\n-inline void Assembler::isel(Register d, Register a, Register b, int c) { guarantee(VM_Version::has_isel(), \"opcode not supported on this hardware\");\n-                                                                         emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n+inline void Assembler::isel(Register d, Register a, Register b, int c) { emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n@@ -704,1 +703,1 @@\n-inline bool Assembler::lxarx_hint_exclusive_access()                                          { return VM_Version::has_lxarxeh(); }\n+inline bool Assembler::lxarx_hint_exclusive_access()                                          { return true; }\n@@ -778,6 +777,3 @@\n-inline void Assembler::cmpb(   Register a, Register s, Register b) { guarantee(VM_Version::has_cmpb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n-inline void Assembler::popcntb(Register a, Register s)             { guarantee(VM_Version::has_popcntb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n-inline void Assembler::popcntw(Register a, Register s)             { guarantee(VM_Version::has_popcntw(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::cmpb(   Register a, Register s, Register b) { emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n+inline void Assembler::popcntb(Register a, Register s)             { emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::popcntw(Register a, Register s)             { emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n@@ -838,2 +834,1 @@\n-inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fcfids(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -845,4 +840,2 @@\n-inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrt(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n-inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrts(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -1056,2 +1049,1 @@\n-inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { guarantee(VM_Version::has_vand(), \"opcode not supported on this hardware\");\n-                                                                                        emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n+inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -543,1 +543,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -545,3 +544,3 @@\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n+      \/\/ move src to dst register\n+      if (code == Bytecodes::_i2d) {\n+        __ mtfprwa(rdst, src->as_register());\n@@ -549,7 +548,1 @@\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2d) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n+        __ mtfprd(rdst, src->as_register_lo());\n@@ -557,1 +550,1 @@\n-      __ fcfid(rdst, rsrc);\n+      __ fcfid(rdst, rdst);\n@@ -562,1 +555,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -564,3 +556,3 @@\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n+      \/\/ move src to dst register\n+      if (code == Bytecodes::_i2f) {\n+        __ mtfprwa(rdst, src->as_register());\n@@ -568,14 +560,1 @@\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2f) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      if (VM_Version::has_fcfids()) {\n-        __ fcfids(rdst, rsrc);\n-      } else {\n-        assert(code == Bytecodes::_i2f, \"fcfid+frsp needs fixup code to avoid rounding incompatibility\");\n-        __ fcfid(rdst, rsrc);\n-        __ frsp(rdst, rdst);\n+        __ mtfprd(rdst, src->as_register_lo());\n@@ -583,0 +562,1 @@\n+      __ fcfids(rdst, rdst);\n@@ -595,1 +575,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -597,1 +576,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n+      Address       addr = Address();\n@@ -601,6 +580,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register(), 0);\n-      }\n+      __ li(dst->as_register(), 0);\n@@ -609,5 +583,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register(), rsrc);\n-      }\n+      __ mffprd(dst->as_register(), rsrc);\n@@ -619,1 +589,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -621,1 +590,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n+      Address       addr = Address();\n@@ -625,6 +594,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register_lo(), 0);\n-      }\n+      __ li(dst->as_register_lo(), 0);\n@@ -633,5 +597,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register_lo(), rsrc);\n-      }\n+      __ mffprd(dst->as_register_lo(), rsrc);\n@@ -1584,2 +1544,1 @@\n-  \/\/ Try to use isel on >=Power7.\n-  if (VM_Version::has_isel() && result->is_cpu_register()) {\n+  if (result->is_cpu_register()) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":17,"deletions":58,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -717,8 +717,6 @@\n-      if (VM_Version::has_fsqrt()) {\n-        assert(x->number_of_arguments() == 1, \"wrong type\");\n-        LIRItem value(x->argument_at(0), this);\n-        value.load_item();\n-        LIR_Opr dst = rlock_result(x);\n-        __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n-        break;\n-      } \/\/ else fallthru\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n@@ -738,1 +736,1 @@\n-          runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);\n+\t        \/* run interpreted *\/\n@@ -822,72 +820,0 @@\n-  if (!VM_Version::has_mtfprd()) {\n-    switch (x->op()) {\n-\n-      \/\/ int -> float: force spill\n-      case Bytecodes::_l2f: {\n-        if (!VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-          \/\/ fcfid+frsp needs fixup code to avoid rounding incompatibility.\n-          address entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);\n-          LIR_Opr result = call_runtime(x->value(), entry, x->type(), nullptr);\n-          set_result(x, result);\n-          return;\n-        } \/\/ else fallthru\n-      }\n-      case Bytecodes::_l2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        LIR_Opr tmp = force_to_spill(value.result(), T_DOUBLE);\n-        __ convert(x->op(), tmp, reg);\n-        return;\n-      }\n-      case Bytecodes::_i2f:\n-      case Bytecodes::_i2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        \/\/ Convert i2l first.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, value.result(), tmp1);\n-        LIR_Opr tmp2 = force_to_spill(tmp1, T_DOUBLE);\n-        __ convert(x->op(), tmp2, reg);\n-        return;\n-      }\n-\n-      \/\/ float -> int: result will be stored\n-      case Bytecodes::_f2l:\n-      case Bytecodes::_d2l: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        set_vreg_flag(reg, must_start_in_memory);\n-        __ convert(x->op(), value.result(), reg);\n-        return;\n-      }\n-      case Bytecodes::_f2i:\n-      case Bytecodes::_d2i: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        \/\/ Convert l2i afterwards.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        set_vreg_flag(tmp1, must_start_in_memory);\n-        __ convert(x->op(), value.result(), tmp1);\n-        __ convert(Bytecodes::_l2i, tmp1, reg);\n-        return;\n-      }\n-\n-      \/\/ Within same category: just register conversions.\n-      case Bytecodes::_i2b:\n-      case Bytecodes::_i2c:\n-      case Bytecodes::_i2s:\n-      case Bytecodes::_i2l:\n-      case Bytecodes::_l2i:\n-      case Bytecodes::_f2d:\n-      case Bytecodes::_d2f:\n-        break;\n-\n-      default: ShouldNotReachHere();\n-    }\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":7,"deletions":81,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -237,8 +237,1 @@\n-  if (VM_Version::has_isel()) {\n-    isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n-  } else {\n-    Label Lskip;\n-    blt(CR0, Lskip);\n-    mr(cnt1, cnt2);\n-    bind(Lskip);\n-  }\n+  isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -129,6 +129,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n-        } else {\n-          __ std(as_Register(from_reg), -8, R1_SP);\n-          __ lfd(as_FloatRegister(to_reg), -8, R1_SP);\n-        }\n+        __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n@@ -167,6 +162,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n-        } else {\n-          __ stfd(as_FloatRegister(from_reg), -8, R1_SP);\n-          __ ld(as_Register(to_reg), -8, R1_SP);\n-        }\n+        __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -363,7 +363,2 @@\n-  if (VM_Version::has_isel()) {\n-    __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n-    __ isel(dst, CR0, Assembler::equal, false, tmp1);\n-  } else {\n-    __ bne(CR0, done);\n-    __ xori(dst, tmp1, markWord::lock_mask_in_place);\n-  }\n+  __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n+  __ isel(dst, CR0, Assembler::equal, false, tmp1);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  product(bool, SuperwordUseVSX, false,                                     \\\n+  product(bool, SuperwordUseVSX, true,                                      \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,6 +311,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mtfprd(d, l);\n-  } else {\n-    std(l, 0, R15_esp);\n-    lfd(d, 0, R15_esp);\n-  }\n+  mtfprd(d, l);\n@@ -320,6 +315,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mffprd(l, d);\n-  } else {\n-    stfd(d, 0, R15_esp);\n-    ld(l, 0, R15_esp);\n-  }\n+  mffprd(l, d);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1573,4 +1573,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n@@ -1583,15 +1579,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, tmp3, dest_current_value, exchange_value, addr_base);\n-    modval = tmp1;\n-    shift_amount = tmp2;\n-    val32 = tmp3;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-  }\n@@ -1602,1 +1583,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1609,4 +1590,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n-\n@@ -1615,7 +1592,0 @@\n-  if (instruction_type != size) {\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(modval, dest_current_value, is_add ? modval : exchange_value);\n-    clrldi(modval, modval, (size == 1) ? 56 : 48);\n-    slw(modval, modval, shift_amount);\n-    xorr(modval, val32, modval);\n-  }\n@@ -1623,1 +1593,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1648,2 +1618,1 @@\n-                                       Register addr_base, Register tmp1, Register tmp2,\n-                                       Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n+                                       Register addr_base, Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n@@ -1651,5 +1620,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n-\n@@ -1660,20 +1624,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n-    shift_amount = tmp1;\n-    val32 = tmp2;\n-    modval = tmp2;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(exchange_value, compare_value, exchange_value);\n-    clrldi(exchange_value, exchange_value, (size == 1) ? 56 : 48);\n-    slw(exchange_value, exchange_value, shift_amount);\n-  }\n-\n@@ -1683,1 +1627,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1690,3 +1634,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n@@ -1708,5 +1649,1 @@\n-  if (instruction_type != size) {\n-    xorr(modval, val32, exchange_value);\n-  }\n-\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1723,2 +1660,1 @@\n-                                     Register addr_base, Register tmp1, Register tmp2,\n-                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -1735,2 +1671,1 @@\n-                            int_flag_success != exchange_value && int_flag_success != addr_base &&\n-                            int_flag_success != tmp1 && int_flag_success != tmp2);\n+                            int_flag_success != exchange_value && int_flag_success != addr_base);\n@@ -1762,1 +1697,1 @@\n-  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -3738,1 +3673,0 @@\n-  assert(!VM_Version::has_vpmsumb(), \"Vector version should be used instead!\");\n@@ -3871,97 +3805,0 @@\n-\/**\n- * @param crc   register containing existing CRC (32-bit)\n- * @param buf   register pointing to input byte buffer (byte*)\n- * @param len   register containing number of bytes\n- * @param table register pointing to CRC table\n- *\n- * uses R9..R12 as work register. Must be saved\/restored by caller!\n- *\/\n-void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,\n-                                        Register t0,  Register t1,  Register t2,  Register t3,\n-                                        Register tc0, Register tc1, Register tc2, Register tc3,\n-                                        bool invertCRC) {\n-  assert_different_registers(crc, buf, len, table);\n-\n-  Label L_mainLoop, L_tail;\n-  Register  tmp          = t0;\n-  Register  data         = t0;\n-  Register  tmp2         = t1;\n-  const int mainLoop_stepping  = 4;\n-  const int tailLoop_stepping  = 1;\n-  const int log_stepping       = exact_log2(mainLoop_stepping);\n-  const int mainLoop_alignment = 32; \/\/ InputForNewCode > 4 ? InputForNewCode : 32;\n-  const int complexThreshold   = 2*mainLoop_stepping;\n-\n-  \/\/ Don't test for len <= 0 here. This pathological case should not occur anyway.\n-  \/\/ Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles\n-  \/\/ for all well-behaved cases. The situation itself is detected and handled correctly\n-  \/\/ within update_byteLoop_crc32.\n-  assert(tailLoop_stepping == 1, \"check tailLoop_stepping!\");\n-\n-  BLOCK_COMMENT(\"kernel_crc32_1word {\");\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-\n-  \/\/ Check for short (<mainLoop_stepping) buffer.\n-  cmpdi(CR0, len, complexThreshold);\n-  blt(CR0, L_tail);\n-\n-  \/\/ Pre-mainLoop alignment did show a slight (1%) positive effect on performance.\n-  \/\/ We leave the code in for reference. Maybe we need alignment when we exploit vector instructions.\n-  {\n-    \/\/ Align buf addr to mainLoop_stepping boundary.\n-    neg(tmp2, buf);                              \/\/ Calculate # preLoop iterations for alignment.\n-    rldicl(tmp2, tmp2, 0, 64-log_stepping);      \/\/ Rotate tmp2 0 bits, insert into tmp2, anding with mask with 1s from 62..63.\n-\n-    if (complexThreshold > mainLoop_stepping) {\n-      sub(len, len, tmp2);                       \/\/ Remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    } else {\n-      sub(tmp, len, tmp2);                       \/\/ Remaining bytes for main loop.\n-      cmpdi(CR0, tmp, mainLoop_stepping);\n-      blt(CR0, L_tail);                         \/\/ For less than one mainloop_stepping left, do only tail processing\n-      mr(len, tmp);                              \/\/ remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    }\n-    update_byteLoop_crc32(crc, buf, tmp2, table, data, false);\n-  }\n-\n-  srdi(tmp2, len, log_stepping);                 \/\/ #iterations for mainLoop\n-  andi(len, len, mainLoop_stepping-1);           \/\/ remaining bytes for tailLoop\n-  mtctr(tmp2);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  Register crc_rv = crc;\n-#else\n-  Register crc_rv = tmp;                         \/\/ Load_reverse needs separate registers to work on.\n-                                                 \/\/ Occupies tmp, but frees up crc.\n-  load_reverse_32(crc_rv, crc);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc;\n-#endif\n-\n-  int reconstructTableOffset = crc32_table_columns(table, tc0, tc1, tc2, tc3);\n-\n-  align(mainLoop_alignment);                     \/\/ Octoword-aligned loop address. Shows 2% improvement.\n-  BIND(L_mainLoop);\n-    update_1word_crc32(crc_rv, buf, table, 0, mainLoop_stepping, crc_rv, t1, t2, t3, tc0, tc1, tc2, tc3);\n-    bdnz(L_mainLoop);\n-\n-#ifndef VM_LITTLE_ENDIAN\n-  load_reverse_32(crc, crc_rv);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc_rv;                                  \/\/ Tmp uses it's original register again.\n-#endif\n-\n-  \/\/ Restore original table address for tailLoop.\n-  if (reconstructTableOffset != 0) {\n-    addi(table, table, -reconstructTableOffset);\n-  }\n-\n-  \/\/ Process last few (<complexThreshold) bytes of buffer.\n-  BIND(L_tail);\n-  update_byteLoop_crc32(crc, buf, len, table, data, false);\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-  BLOCK_COMMENT(\"} kernel_crc32_1word\");\n-}\n@@ -4082,5 +3919,3 @@\n-  \/\/ If supported set DSCR pre-fetch to deepest.\n-  if (VM_Version::has_mfdscr()) {\n-    load_const_optimized(t0, VM_Version::_dscr_val | 7);\n-    mtdscr(t0);\n-  }\n+  \/\/ Set DSCR pre-fetch to deepest.\n+  load_const_optimized(t0, VM_Version::_dscr_val | 7);\n+  mtdscr(t0);\n@@ -4230,4 +4065,2 @@\n-  if (VM_Version::has_mfdscr()) {\n-    load_const_optimized(t0, VM_Version::_dscr_val);\n-    mtdscr(t0);\n-  }\n+  load_const_optimized(t0, VM_Version::_dscr_val);\n+  mtdscr(t0);\n@@ -4305,5 +4138,1 @@\n-  if (VM_Version::has_vpmsumb()) {\n-    kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n-  } else {\n-    kernel_crc32_1word(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, t0, !is_crc32c);\n-  }\n+  kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":14,"deletions":185,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -502,2 +502,1 @@\n-                         Register addr_base, Register tmp1, Register tmp2,\n-                         Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n+                         Register addr_base,Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n@@ -506,2 +505,1 @@\n-                       Register addr_base, Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -550,5 +548,5 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n-                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, semantics,\n+                    cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -560,4 +558,4 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -571,1 +569,1 @@\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, noreg, noreg,\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -470,12 +470,4 @@\n-    if (VM_Version::has_isel()) {\n-      cmpdi(CR0, src, 0);\n-      Register co = encode_heap_oop_not_null(d, src);\n-      assert(co == d, \"sanity\");\n-      isel_0(d, CR0, Assembler::equal);\n-    } else {\n-      Label isNull;\n-      or_(d, src, src); \/\/ move and compare 0\n-      beq(CR0, isNull);\n-      encode_heap_oop_not_null(d, src);\n-      bind(isNull);\n-    }\n+    cmpdi(CR0, src, 0);\n+    Register co = encode_heap_oop_not_null(d, src);\n+    assert(co == d, \"sanity\");\n+    isel_0(d, CR0, Assembler::equal);\n@@ -513,5 +505,1 @@\n-    if (VM_Version::has_isel()) {\n-      use_isel = true;\n-    } else {\n-      beq(CR0, isNull);\n-    }\n+    use_isel = true;\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -161,1 +161,0 @@\n-  \/\/ false means that conversion is done by runtime call\n@@ -165,1 +164,1 @@\n-    return VM_Version::has_fcfids();\n+    return true;\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2068,1 +2068,0 @@\n-      return VM_Version::has_fsqrt();\n@@ -2070,1 +2069,0 @@\n-      return VM_Version::has_vsx();\n@@ -2079,1 +2077,1 @@\n-      return (UsePopCountInstruction && VM_Version::has_popcntw());\n+      return (UsePopCountInstruction);\n@@ -2083,1 +2081,0 @@\n-\n@@ -2931,0 +2928,5 @@\n+    \/\/ use isel instruction with Power 7\n+    cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n+    encodeP_subNode    *n_sub_base = new encodeP_subNode();\n+    encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n+    cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n@@ -2932,37 +2934,4 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_subNode    *n_sub_base = new encodeP_subNode();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      n_cond_set->add_req(n_region, n_compare, n_shift);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-      nodes->push(n_cond_set);\n+    n_compare->add_req(n_region, n_src);\n+    n_compare->_opnds[0] = op_crx;\n+    n_compare->_opnds[1] = op_src;\n+    n_compare->_opnds[2] = new immL16Oper(0);\n@@ -2970,40 +2939,25 @@\n-    } else {\n-      \/\/ before Power 7\n-      moveRegNode        *n_move     = new moveRegNode();\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();\n-\n-      n_move->add_req(n_region, n_src);\n-      n_move->_opnds[0] = op_dst;\n-      n_move->_opnds[1] = op_src;\n-      ra_->set_oop(n_move, true); \/\/ Until here, 'n_move' still produces an oop.\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->add_prec(n_move);\n-\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_compare, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_crx;\n-      n_sub_base->_opnds[2] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_move->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_move);\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-    }\n+    n_sub_base->add_req(n_region, n_src);\n+    n_sub_base->_opnds[0] = op_dst;\n+    n_sub_base->_opnds[1] = op_src;\n+    n_sub_base->_bottom_type = _bottom_type;\n+\n+    n_shift->add_req(n_region, n_sub_base);\n+    n_shift->_opnds[0] = op_dst;\n+    n_shift->_opnds[1] = op_dst;\n+    n_shift->_bottom_type = _bottom_type;\n+\n+    n_cond_set->add_req(n_region, n_compare, n_shift);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n+\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+\n+    nodes->push(n_compare);\n+    nodes->push(n_sub_base);\n+    nodes->push(n_shift);\n+    nodes->push(n_cond_set);\n@@ -3049,15 +3003,6 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-\n-      decodeN_addNode *n_add_base = new decodeN_addNode();\n-      n_add_base->add_req(n_region, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n-\n-      cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n-      n_cond_set->add_req(n_region, n_compare, n_add_base);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n+    \/\/ use isel instruction with Power 7\n+    decodeN_addNode *n_add_base = new decodeN_addNode();\n+    n_add_base->add_req(n_region, n_shift);\n+    n_add_base->_opnds[0] = op_dst;\n+    n_add_base->_opnds[1] = op_dst;\n+    n_add_base->_bottom_type = _bottom_type;\n@@ -3065,16 +3010,6 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_cond_set, true);\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-      nodes->push(n_cond_set);\n-\n-    } else {\n-      \/\/ before Power 7\n-      cond_add_baseNode *n_add_base = new cond_add_baseNode();\n+    cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n+    n_cond_set->add_req(n_region, n_compare, n_add_base);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n@@ -3082,5 +3017,2 @@\n-      n_add_base->add_req(n_region, n_compare, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_crx;\n-      n_add_base->_opnds[2] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n+    assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n+    ra_->set_oop(n_cond_set, true);\n@@ -3088,2 +3020,4 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_add_base, true);\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n@@ -3091,3 +3025,4 @@\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    nodes->push(n_compare);\n+    nodes->push(n_shift);\n+    nodes->push(n_add_base);\n+    nodes->push(n_cond_set);\n@@ -3095,4 +3030,0 @@\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-    }\n@@ -6790,1 +6721,1 @@\n-            CompressedOops::base_disjoint() && VM_Version::has_isel());\n+            CompressedOops::base_disjoint());\n@@ -7170,1 +7101,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7185,13 +7115,0 @@\n-instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7215,1 +7132,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7230,13 +7146,0 @@\n-instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7260,1 +7163,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7275,5 +7177,0 @@\n-\/\/ Conditional move for RegN. Only cmov(reg, reg).\n-instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n@@ -7281,8 +7178,0 @@\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7306,1 +7195,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7321,13 +7209,0 @@\n-instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7398,1 +7273,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7403,1 +7277,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7415,18 +7289,0 @@\n-instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7436,1 +7292,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7441,1 +7296,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7453,18 +7308,0 @@\n-instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7550,1 +7387,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7555,1 +7392,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7562,13 +7399,0 @@\n-instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7578,1 +7402,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7583,1 +7407,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7590,13 +7414,0 @@\n-instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7606,1 +7417,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7611,1 +7422,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7618,13 +7429,0 @@\n-instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7634,1 +7432,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7639,1 +7437,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7646,13 +7444,0 @@\n-instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7785,1 +7570,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7790,1 +7575,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7797,13 +7582,0 @@\n-instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7813,1 +7585,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7818,1 +7590,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7831,19 +7603,0 @@\n-instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7853,1 +7606,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7858,1 +7611,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7865,13 +7618,0 @@\n-instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7881,1 +7621,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7886,1 +7626,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7899,19 +7639,0 @@\n-instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8061,1 +7782,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8076,16 +7796,0 @@\n-instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8095,1 +7799,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8110,16 +7813,0 @@\n-instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8161,1 +7848,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8176,17 +7862,0 @@\n-instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8195,1 +7864,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8210,16 +7878,0 @@\n-instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -9514,1 +9166,0 @@\n-\/\/ VM_Version::has_fsqrt() decides if this node will be used.\n@@ -9529,1 +9180,0 @@\n-  predicate(VM_Version::has_fsqrts());\n@@ -10031,1 +9681,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10151,12 +9800,0 @@\n-\/\/----------Moves between long and float\n-\n-instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE src);\n-  predicate(false);\n-\n-  format %{ \"storeD  $src, $dst \\t\/\/ STACK\" %}\n-  size(4);\n-  ins_encode( enc_stfd(src, dst) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -10188,21 +9825,0 @@\n-\/\/ Move long value from long stack-location to double register.\n-instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"LFD     $dst, $src \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_lfd(dst, src) );\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Move long value from long register to double stack-location.\n-instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STD     $src, $dst \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_std(src, dst) );\n-  ins_pipe(pipe_class_memory);\n-%}\n@@ -10608,53 +10224,0 @@\n-instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovI   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovI_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovI_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-\n-    \/\/ precedences for new nodes\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -10716,16 +10279,0 @@\n-\/\/ Double to Int conversion, NaN is mapped to 0.\n-instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{\n-  match(Set dst (ConvD2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2IRaw_regD(tmpD, src);                         \/\/ Convert float to int (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10736,1 +10283,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10761,16 +10307,0 @@\n-\/\/ Float to Int conversion, NaN is mapped to 0.\n-instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{\n-  match(Set dst (ConvF2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2IRaw_regF(tmpF, src);                         \/\/ Convert float to int (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10781,1 +10311,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10872,50 +10401,0 @@\n-instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovL   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovL_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConL16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovL_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConL16Node();\n-    MachNode *m2 = new cmovL_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immL16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -10974,16 +10453,0 @@\n-\/\/ Float to Long conversion, NaN is mapped to 0.\n-instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{\n-  match(Set dst (ConvF2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2LRaw_regF(tmpF, src);                         \/\/ Convert float to long (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10994,1 +10457,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11019,16 +10481,0 @@\n-\/\/ Double to Long conversion, NaN is mapped to 0.\n-instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{\n-  match(Set dst (ConvD2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2LRaw_regD(tmpD, src);                         \/\/ Convert float to long (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11039,1 +10485,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11078,19 +10523,0 @@\n-\/\/ Integer to Float conversion.\n-instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(!VM_Version::has_fcfids());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regD tmpD2;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(tmpD2, tmpD);        \/\/ Convert to double.\n-    convD2F_reg(dst, tmpD2);             \/\/ Convert double to float.\n-  %}\n-%}\n-\n@@ -11110,16 +10536,0 @@\n-\/\/ Integer to Float conversion. Special version for Power7.\n-instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11130,1 +10540,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11140,14 +10549,0 @@\n-\/\/ L2F to avoid runtime call.\n-instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{\n-  match(Set dst (ConvL2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regL_to_stkL(tmpS, src);             \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11158,1 +10553,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11173,16 +10567,0 @@\n-\/\/ Integer to Double conversion.\n-instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2D src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(dst, tmpD);          \/\/ Convert to double.\n-  %}\n-%}\n@@ -11193,1 +10571,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11203,11 +10580,0 @@\n-\/\/ Long to Double conversion\n-instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{\n-  match(Set dst (ConvL2D src));\n-  ins_cost(DEFAULT_COST + MEMORY_REF_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    moveL2D_stack_reg(tmpD, src);\n-    convL2DRaw_regD(dst, tmpD);\n-  %}\n-%}\n@@ -11218,1 +10584,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -12813,19 +12178,0 @@\n-instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MinI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andL_reg_reg(doz, diff, sm); \/\/ <=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -12836,1 +12182,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -12846,19 +12191,0 @@\n-instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MaxI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andcL_reg_reg(doz, diff, sm); \/\/ >=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -12869,1 +12195,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -12884,1 +12209,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -12897,1 +12222,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -13256,1 +12581,1 @@\n-  predicate(VM_Version::has_ldbrx() && (n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n+  predicate((n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n@@ -13268,1 +12593,0 @@\n-  predicate(VM_Version::has_ldbrx());\n@@ -13349,1 +12673,0 @@\n-  predicate(VM_Version::has_stdbrx());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":79,"deletions":756,"binary":false,"changes":835,"status":"modified"},{"patch":"@@ -812,4 +812,2 @@\n-    if (VM_Version::has_mfdscr()) {\n-      __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n-      __ mtdscr(tmp1);\n-    }\n+    __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n+    __ mtdscr(tmp1);\n@@ -927,19 +925,0 @@\n-       if (!VM_Version::has_vsx()) {\n-\n-        __ bind(l_8);\n-        \/\/ Use unrolled version for mass copying (copy 32 elements a time)\n-        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-        \/\/ Therefore, the following sequence is made for the good of both.\n-        __ ld(tmp1, 0, R3_ARG1);\n-        __ ld(tmp2, 8, R3_ARG1);\n-        __ ld(tmp3, 16, R3_ARG1);\n-        __ ld(tmp4, 24, R3_ARG1);\n-        __ std(tmp1, 0, R4_ARG2);\n-        __ std(tmp2, 8, R4_ARG2);\n-        __ std(tmp3, 16, R4_ARG2);\n-        __ std(tmp4, 24, R4_ARG2);\n-        __ addi(R3_ARG1, R3_ARG1, 32);\n-        __ addi(R4_ARG2, R4_ARG2, 32);\n-        __ bdnz(l_8);\n-\n-      } else { \/\/ Processor supports VSX, so use it to mass copy.\n@@ -951,4 +930,2 @@\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-          __ mtdscr(tmp2);\n-        }\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+        __ mtdscr(tmp2);\n@@ -975,4 +952,2 @@\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-          __ mtdscr(tmp2);\n-        }\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+        __ mtdscr(tmp2);\n@@ -980,1 +955,0 @@\n-      } \/\/ VSX\n@@ -1223,19 +1197,2 @@\n-        if (!VM_Version::has_vsx()) {\n-\n-          __ bind(l_8);\n-          \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n-          \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-          \/\/ Therefore, the following sequence is made for the good of both.\n-          __ ld(tmp1, 0, R3_ARG1);\n-          __ ld(tmp2, 8, R3_ARG1);\n-          __ ld(tmp3, 16, R3_ARG1);\n-          __ ld(tmp4, 24, R3_ARG1);\n-          __ std(tmp1, 0, R4_ARG2);\n-          __ std(tmp2, 8, R4_ARG2);\n-          __ std(tmp3, 16, R4_ARG2);\n-          __ std(tmp4, 24, R4_ARG2);\n-          __ addi(R3_ARG1, R3_ARG1, 32);\n-          __ addi(R4_ARG2, R4_ARG2, 32);\n-          __ bdnz(l_8);\n-\n-        } else { \/\/ Processor supports VSX, so use it to mass copy.\n+\n+        \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1247,4 +1204,2 @@\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-            __ mtdscr(tmp2);\n-          }\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+          __ mtdscr(tmp2);\n@@ -1270,4 +1225,3 @@\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-            __ mtdscr(tmp2);\n-          }\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+          __ mtdscr(tmp2);\n+          \n@@ -1275,1 +1229,0 @@\n-        }\n@@ -1430,1 +1383,1 @@\n-     if (!VM_Version::has_vsx()) {\n+    \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1432,17 +1385,2 @@\n-      __ bind(l_6);\n-      \/\/ Use unrolled version for mass copying (copy 8 elements a time).\n-      \/\/ Load feeding store gets zero latency on power6, however not on power 5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_6);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+    \/\/ Prefetch the data into the L2 cache.\n+    __ dcbt(R3_ARG1, 0);\n@@ -1450,2 +1388,3 @@\n-      \/\/ Prefetch the data into the L2 cache.\n-      __ dcbt(R3_ARG1, 0);\n+    \/\/ If supported set DSCR pre-fetch to deepest.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+    __ mtdscr(tmp2);\n@@ -1453,5 +1392,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+    __ li(tmp1, 16);\n@@ -1459,1 +1394,4 @@\n-      __ li(tmp1, 16);\n+    \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n+    \/\/ loop contains < 8 instructions that fit inside a single\n+    \/\/ i-cache sector.\n+    __ align(32);\n@@ -1461,4 +1399,10 @@\n-      \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n-      \/\/ loop contains < 8 instructions that fit inside a single\n-      \/\/ i-cache sector.\n-      __ align(32);\n+    __ bind(l_7);\n+    \/\/ Use loop with VSX load\/store instructions to\n+    \/\/ copy 8 elements a time.\n+    __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n+    __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n+    __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n+    __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n+    __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n+    __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n+    __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n@@ -1466,10 +1410,3 @@\n-      __ bind(l_7);\n-      \/\/ Use loop with VSX load\/store instructions to\n-      \/\/ copy 8 elements a time.\n-      __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n-      __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n-      __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n-      __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n-      __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n-      __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n-      __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n+    \/\/ Restore DSCR pre-fetch value.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+    __ mtdscr(tmp2);\n@@ -1477,5 +1414,0 @@\n-      \/\/ Restore DSCR pre-fetch value.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n@@ -1483,1 +1415,0 @@\n-    } \/\/ VSX\n@@ -1598,17 +1529,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else {  \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1618,5 +1533,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1643,5 +1556,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n-     }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n@@ -1734,18 +1644,1 @@\n-    if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_4);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1756,5 +1649,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1781,4 +1672,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n@@ -1786,1 +1675,0 @@\n-    } \/\/ VSX\n@@ -1879,17 +1767,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1899,5 +1771,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1924,5 +1794,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n-     }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":55,"deletions":188,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-  \/\/ <= Power7 Little Endian: 4 tables for byte folding\n-  \/\/ <= Power7 Big Endian: 1 table for single byte folding + 4 tables for multi-byte folding\n@@ -83,1 +81,0 @@\n-  const bool use_vector = VM_Version::has_vpmsumb();\n@@ -86,1 +83,1 @@\n-  const int size = use_vector ? CRC32_TABLE_SIZE + vector_size : (4 BIG_ENDIAN_ONLY(+1)) * CRC32_TABLE_SIZE;\n+  const int size = CRC32_TABLE_SIZE + vector_size;\n@@ -94,37 +91,2 @@\n-  LITTLE_ENDIAN_ONLY(if (use_vector)) {\n-    for (int i = 0; i < 256; ++i) {\n-      ptr[i] = fold_byte(i, reverse_poly);\n-    }\n-  }\n-\n-  if (!use_vector) {\n-    BIG_ENDIAN_ONLY(ptr = (juint*)(consts + CRC32_TABLE_SIZE);)\n-    \/\/ <= Power7: 4 tables\n-    for (int i = 0; i < 256; ++i) {\n-      juint a = fold_byte(i, reverse_poly),\n-            b = fold_byte(a, reverse_poly),\n-            c = fold_byte(b, reverse_poly),\n-            d = fold_byte(c, reverse_poly);\n-#ifndef VM_LITTLE_ENDIAN\n-      a = byteswap(a);\n-      b = byteswap(b);\n-      c = byteswap(c);\n-      d = byteswap(d);\n-#endif\n-      ptr[i         ] = a;\n-      ptr[i +    256] = b;\n-      ptr[i + 2* 256] = c;\n-      ptr[i + 3* 256] = d;\n-    }\n-#if 0\n-    for (int i = 0; i < 4; ++i) {\n-      tty->print_cr(\"table %d:\", i);\n-      for (int j = 0; j < 32; ++j) {\n-        for (int k = 0; k < 8; ++k) {\n-          tty->print(\"%08x \", ptr[i*256 + j*8 + k]);\n-        }\n-        tty->cr();\n-      }\n-    }\n-#endif\n-    return consts;\n+  for (int i = 0; i < 256; ++i) {\n+    ptr[i] = fold_byte(i, reverse_poly);\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1080,1 +1080,1 @@\n-    case Interpreter::java_lang_math_sqrt: use_instruction = VM_Version::has_fsqrt(); break;\n+    case Interpreter::java_lang_math_sqrt: use_instruction = true; break;\n@@ -1093,1 +1093,1 @@\n-    case Interpreter::java_lang_math_sqrt : runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);  break;\n+    case Interpreter::java_lang_math_sqrt : \/* run interpreted *\/  break;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,8 +322,1 @@\n-  if (VM_Version::has_isel()) {\n-    __ isel_0(R17_tos, CR0, Assembler::equal);\n-  } else {\n-    Label not_sentinel;\n-    __ bne(CR0, not_sentinel);\n-    __ li(R17_tos, 0);\n-    __ bind(not_sentinel);\n-  }\n+  __ isel_0(R17_tos, CR0, Assembler::equal);\n@@ -1537,7 +1530,1 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        \/\/ Comment: alternatively, load with sign extend could be done by lfiwax.\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        __ fcfid(F15_ftos, F15_ftos);\n-        __ frsp(F15_ftos, F15_ftos);\n-      }\n+      __ fcfids(F15_ftos, F15_ftos);\n@@ -1547,9 +1534,2 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        __ move_l_to_d();\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        \/\/ Avoid rounding problem when result should be 0x3f800001: need fixup code before fcfid+frsp.\n-        __ mr(R3_ARG1, R17_tos);\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::l2f));\n-        __ fmr(F15_ftos, F1_RET);\n-      }\n+      __ move_l_to_d();\n+      __ fcfids(F15_ftos, F15_ftos);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -67,8 +67,0 @@\n-    } else if (VM_Version::has_lqarx()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 8);\n-    } else if (VM_Version::has_popcntw()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 7);\n-    } else if (VM_Version::has_cmpb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 6);\n-    } else if (VM_Version::has_popcntb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 5);\n@@ -84,4 +76,0 @@\n-    case  8: if (!VM_Version::has_lqarx()  ) break;\n-    case  7: if (!VM_Version::has_popcntw()) break;\n-    case  6: if (!VM_Version::has_cmpb()   ) break;\n-    case  5: if (!VM_Version::has_popcntb()) break;\n@@ -95,3 +83,1 @@\n-  if (PowerArchitecturePPC64 >= 8 && has_mfdscr()) {\n-    config_dscr();\n-  }\n+  config_dscr();\n@@ -112,8 +98,1 @@\n-  \/\/ Power7 and later.\n-  if (PowerArchitecturePPC64 > 6) {\n-    if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n-      FLAG_SET_ERGO(UsePopCountInstruction, true);\n-    }\n-  }\n-\n-  if (!VM_Version::has_isel() && FLAG_IS_DEFAULT(ConditionalMoveLimit)) {\n+  if (FLAG_IS_DEFAULT(ConditionalMoveLimit)) {\n@@ -123,10 +102,0 @@\n-  if (PowerArchitecturePPC64 >= 8) {\n-    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n-      FLAG_SET_ERGO(SuperwordUseVSX, true);\n-    }\n-  } else {\n-    if (SuperwordUseVSX) {\n-      warning(\"SuperwordUseVSX specified, but needs at least Power8.\");\n-      FLAG_SET_DEFAULT(SuperwordUseVSX, false);\n-    }\n-  }\n@@ -145,7 +114,2 @@\n-    if (SuperwordUseVSX) {\n-      if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {\n-        FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);\n-      }\n-    } else if (UseVectorByteReverseInstructionsPPC64) {\n-      warning(\"UseVectorByteReverseInstructionsPPC64 specified, but needs SuperwordUseVSX.\");\n-      FLAG_SET_DEFAULT(UseVectorByteReverseInstructionsPPC64, false);\n+    if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {\n+      FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);\n@@ -201,17 +165,2 @@\n-               \"ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n-               (has_fsqrt()   ? \" fsqrt\"   : \"\"),\n-               (has_isel()    ? \" isel\"    : \"\"),\n-               (has_lxarxeh() ? \" lxarxeh\" : \"\"),\n-               (has_cmpb()    ? \" cmpb\"    : \"\"),\n-               (has_popcntb() ? \" popcntb\" : \"\"),\n-               (has_popcntw() ? \" popcntw\" : \"\"),\n-               (has_fcfids()  ? \" fcfids\"  : \"\"),\n-               (has_vand()    ? \" vand\"    : \"\"),\n-               (has_lqarx()   ? \" lqarx\"   : \"\"),\n-               (has_vcipher() ? \" aes\"     : \"\"),\n-               (has_vpmsumb() ? \" vpmsumb\" : \"\"),\n-               (has_mfdscr()  ? \" mfdscr\"  : \"\"),\n-               (has_vsx()     ? \" vsx\"     : \"\"),\n-               (has_ldbrx()   ? \" ldbrx\"   : \"\"),\n-               (has_stdbrx()  ? \" stdbrx\"  : \"\"),\n-               (has_vshasig() ? \" sha\"     : \"\"),\n+               \"ppc64%s%s%s\",\n+               (\" sha\"),\n@@ -286,8 +235,2 @@\n-  if (has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAES)) {\n-      UseAES = true;\n-    }\n-  } else if (UseAES) {\n-    if (!FLAG_IS_DEFAULT(UseAES))\n-      warning(\"AES instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAES, false);\n+  if (FLAG_IS_DEFAULT(UseAES)) {\n+    UseAES = true;\n@@ -296,8 +239,2 @@\n-  if (UseAES && has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-      UseAESIntrinsics = true;\n-    }\n-  } else if (UseAESIntrinsics) {\n-    if (!FLAG_IS_DEFAULT(UseAESIntrinsics))\n-      warning(\"AES intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESIntrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n+    UseAESIntrinsics = true;\n@@ -325,8 +262,2 @@\n-  if (has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA)) {\n-      UseSHA = true;\n-    }\n-  } else if (UseSHA) {\n-    if (!FLAG_IS_DEFAULT(UseSHA))\n-      warning(\"SHA instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSHA, false);\n+  if (FLAG_IS_DEFAULT(UseSHA)) {\n+    UseSHA = true;\n@@ -340,7 +271,3 @@\n-  if (UseSHA && has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n-    }\n-  } else if (UseSHA256Intrinsics) {\n-    warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n+\n+  if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n@@ -349,7 +276,2 @@\n-  if (UseSHA && has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n-    }\n-  } else if (UseSHA512Intrinsics) {\n-    warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n@@ -367,6 +289,0 @@\n-  if (UseSecondarySupersTable && PowerArchitecturePPC64 < 7) {\n-    if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n-      warning(\"UseSecondarySupersTable requires Power7 or later.\");\n-    }\n-    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":17,"deletions":101,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -104,12 +104,0 @@\n-  static bool has_fsqrt()   { return (_features & fsqrt_m) != 0; }\n-  static bool has_fsqrts()  { return (_features & fsqrts_m) != 0; }\n-  static bool has_isel()    { return (_features & isel_m) != 0; }\n-  static bool has_lxarxeh() { return (_features & lxarxeh_m) !=0; }\n-  static bool has_cmpb()    { return (_features & cmpb_m) != 0; }\n-  static bool has_popcntb() { return (_features & popcntb_m) != 0; }\n-  static bool has_popcntw() { return (_features & popcntw_m) != 0; }\n-  static bool has_fcfids()  { return (_features & fcfids_m) != 0; }\n-  static bool has_vand()    { return (_features & vand_m) != 0; }\n-  static bool has_lqarx()   { return (_features & lqarx_m) != 0; }\n-  static bool has_vcipher() { return (_features & vcipher_m) != 0; }\n-  static bool has_vpmsumb() { return (_features & vpmsumb_m) != 0; }\n@@ -117,4 +105,0 @@\n-  static bool has_vsx()     { return (_features & vsx_m) != 0; }\n-  static bool has_ldbrx()   { return (_features & ldbrx_m) != 0; }\n-  static bool has_stdbrx()  { return (_features & stdbrx_m) != 0; }\n-  static bool has_vshasig() { return (_features & vshasig_m) != 0; }\n@@ -124,2 +108,0 @@\n-  static bool has_mtfprd()  { return has_vpmsumb(); } \/\/ alias for P8\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -143,6 +143,0 @@\n-#ifndef PV_7\n-  #define PV_7 0x200000          \/* Power PC 7 *\/\n-#endif\n-#ifndef PV_7_Compat\n-  #define PV_7_Compat 0x208000   \/* Power PC 7 *\/\n-#endif\n@@ -1239,27 +1233,0 @@\n-  case PV_7:\n-    strncpy(buf, \"Power PC 7\", buflen);\n-    break;\n-  case PV_6_1:\n-    strncpy(buf, \"Power PC 6 DD1.x\", buflen);\n-    break;\n-  case PV_6:\n-    strncpy(buf, \"Power PC 6\", buflen);\n-    break;\n-  case PV_5:\n-    strncpy(buf, \"Power PC 5\", buflen);\n-    break;\n-  case PV_5_2:\n-    strncpy(buf, \"Power PC 5_2\", buflen);\n-    break;\n-  case PV_5_3:\n-    strncpy(buf, \"Power PC 5_3\", buflen);\n-    break;\n-  case PV_5_Compat:\n-    strncpy(buf, \"PV_5_Compat\", buflen);\n-    break;\n-  case PV_6_Compat:\n-    strncpy(buf, \"PV_6_Compat\", buflen);\n-    break;\n-  case PV_7_Compat:\n-    strncpy(buf, \"PV_7_Compat\", buflen);\n-    break;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -249,13 +249,1 @@\n-  volatile int *dest_base = (volatile int*)((uintptr_t)dest & ~3);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  const unsigned int shift_amount        = ((uintptr_t)dest & 3) * 8;\n-#else\n-  const unsigned int shift_amount        = ((~(uintptr_t)dest) & 3) * 8;\n-#endif\n-  const unsigned int masked_compare_val  = ((unsigned int)(unsigned char)compare_value),\n-                     masked_exchange_val = ((unsigned int)(unsigned char)exchange_value),\n-                     xor_value           = (masked_compare_val ^ masked_exchange_val) << shift_amount;\n-\n-  unsigned int old_value, value32;\n-\n+  unsigned int old_value, loaded_value;\n@@ -265,4 +253,0 @@\n-    \/* simple guard *\/\n-    \"   lbz     %[old_value], 0(%[dest])                  \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n-    \"   bne-    2f                                        \\n\"\n@@ -271,1 +255,1 @@\n-    \"   lwarx   %[value32], 0, %[dest_base]               \\n\"\n+    \"   lbarx   %[old_value], 0, %[dest]                  \\n\"\n@@ -273,3 +257,1 @@\n-    \"   srd     %[old_value], %[value32], %[shift_amount] \\n\"\n-    \"   clrldi  %[old_value], %[old_value], 56            \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n+    \"   cmpw    %[compare_value], %[old_value] \\n\"\n@@ -278,2 +260,1 @@\n-    \"   xor     %[value32], %[xor_value], %[value32]      \\n\"\n-    \"   stwcx.  %[value32], 0, %[dest_base]               \\n\"\n+    \"   stbcx.  %[exchange_value], 0, %[dest]             \\n\"\n@@ -285,3 +266,2 @@\n-      [value32]             \"=&r\"   (value32),\n-                            \"=m\"    (*dest),\n-                            \"=m\"    (*dest_base)\n+      [loaded_value]             \"=&r\"   (loaded_value),\n+                            \"=m\"    (*dest)\n@@ -289,7 +269,4 @@\n-    : [dest]                \"b\"     (dest),\n-      [dest_base]           \"b\"     (dest_base),\n-      [shift_amount]        \"r\"     (shift_amount),\n-      [masked_compare_val]  \"r\"     (masked_compare_val),\n-      [xor_value]           \"r\"     (xor_value),\n-                            \"m\"     (*dest),\n-                            \"m\"     (*dest_base)\n+    : [dest]            \"b\"     (dest),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}