{"files":[{"patch":"@@ -718,1 +718,1 @@\n-        $1_CFLAGS_CPU=\"-mcpu=powerpc64 -mtune=power5\"\n+        $1_CFLAGS_CPU=\"-mcpu=powerpc64 -mtune=power8\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -778,6 +778,3 @@\n-inline void Assembler::cmpb(   Register a, Register s, Register b) { guarantee(VM_Version::has_cmpb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n-inline void Assembler::popcntb(Register a, Register s)             { guarantee(VM_Version::has_popcntb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n-inline void Assembler::popcntw(Register a, Register s)             { guarantee(VM_Version::has_popcntw(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::cmpb(   Register a, Register s, Register b) { emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n+inline void Assembler::popcntb(Register a, Register s)             { emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::popcntw(Register a, Register s)             { emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1586,1 +1586,1 @@\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n+  const int instruction_type = size;\n@@ -1657,3 +1657,2 @@\n-                                       RegisterOrConstant compare_value, Register exchange_value,\n-                                       Register addr_base, Register tmp1, Register tmp2,\n-                                       Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n+RegisterOrConstant compare_value, Register exchange_value,\n+Register addr_base, Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n@@ -1664,1 +1663,1 @@\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n+  const int instruction_type = size;\n@@ -1670,20 +1669,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n-    shift_amount = tmp1;\n-    val32 = tmp2;\n-    modval = tmp2;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(exchange_value, compare_value, exchange_value);\n-    clrldi(exchange_value, exchange_value, (size == 1) ? 56 : 48);\n-    slw(exchange_value, exchange_value, shift_amount);\n-  }\n-\n@@ -1733,2 +1712,1 @@\n-                                     Register addr_base, Register tmp1, Register tmp2,\n-                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -1745,2 +1723,1 @@\n-                            int_flag_success != exchange_value && int_flag_success != addr_base &&\n-                            int_flag_success != tmp1 && int_flag_success != tmp2);\n+                            int_flag_success != exchange_value && int_flag_success != addr_base);\n@@ -1772,1 +1749,1 @@\n-  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base,\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":7,"deletions":30,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -502,2 +502,1 @@\n-                         Register addr_base, Register tmp1, Register tmp2,\n-                         Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n+                         Register addr_base,Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n@@ -506,2 +505,1 @@\n-                       Register addr_base, Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -550,5 +548,5 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n-                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, semantics,\n+                    cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -560,4 +558,4 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -571,1 +569,1 @@\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, noreg, noreg,\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2079,1 +2079,1 @@\n-      return (UsePopCountInstruction && VM_Version::has_popcntw());\n+      return (UsePopCountInstruction);\n@@ -2083,1 +2083,0 @@\n-\n@@ -7393,1 +7392,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7398,1 +7396,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7410,18 +7408,0 @@\n-instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7431,1 +7411,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7436,1 +7415,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7448,18 +7427,0 @@\n-instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7545,1 +7506,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7550,1 +7511,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7557,13 +7518,0 @@\n-instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7573,1 +7521,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7578,1 +7526,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7585,13 +7533,0 @@\n-instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7601,1 +7536,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7606,1 +7541,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7613,13 +7548,0 @@\n-instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7629,1 +7551,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7634,1 +7556,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7641,13 +7563,0 @@\n-instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7780,1 +7689,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7785,1 +7694,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7792,13 +7701,0 @@\n-instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7808,1 +7704,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7813,1 +7709,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7826,19 +7722,0 @@\n-instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7848,1 +7725,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7853,1 +7730,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7860,13 +7737,0 @@\n-instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7876,1 +7740,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7881,1 +7745,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7894,19 +7758,0 @@\n-instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8056,1 +7901,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8071,16 +7915,0 @@\n-instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8090,1 +7918,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8105,16 +7932,0 @@\n-instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8156,1 +7967,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8171,17 +7981,0 @@\n-instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8190,1 +7983,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8205,16 +7997,0 @@\n-instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -12901,1 +12677,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -12914,1 +12690,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":21,"deletions":245,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -67,8 +67,0 @@\n-    } else if (VM_Version::has_lqarx()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 8);\n-    } else if (VM_Version::has_popcntw()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 7);\n-    } else if (VM_Version::has_cmpb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 6);\n-    } else if (VM_Version::has_popcntb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 5);\n@@ -84,4 +76,0 @@\n-    case  8: if (!VM_Version::has_lqarx()  ) break;\n-    case  7: if (!VM_Version::has_popcntw()) break;\n-    case  6: if (!VM_Version::has_cmpb()   ) break;\n-    case  5: if (!VM_Version::has_popcntb()) break;\n@@ -95,3 +83,1 @@\n-  if (PowerArchitecturePPC64 >= 8 && has_mfdscr()) {\n-    config_dscr();\n-  }\n+  config_dscr();\n@@ -112,3 +98,1 @@\n-  \/\/ Power7 and later.\n-  if (PowerArchitecturePPC64 > 6) {\n-    if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n+  if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n@@ -116,1 +100,0 @@\n-    }\n@@ -123,2 +106,1 @@\n-  if (PowerArchitecturePPC64 >= 8) {\n-    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n+  if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n@@ -126,6 +108,0 @@\n-    }\n-  } else {\n-    if (SuperwordUseVSX) {\n-      warning(\"SuperwordUseVSX specified, but needs at least Power8.\");\n-      FLAG_SET_DEFAULT(SuperwordUseVSX, false);\n-    }\n@@ -205,3 +181,3 @@\n-               (has_cmpb()    ? \" cmpb\"    : \"\"),\n-               (has_popcntb() ? \" popcntb\" : \"\"),\n-               (has_popcntw() ? \" popcntw\" : \"\"),\n+               \"cmpb\",\n+               \"popcntb\",\n+               \"popcntw\",\n@@ -210,1 +186,1 @@\n-               (has_lqarx()   ? \" lqarx\"   : \"\"),\n+               \"lqarx\",\n@@ -367,6 +343,0 @@\n-  if (UseSecondarySupersTable && PowerArchitecturePPC64 < 7) {\n-    if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n-      warning(\"UseSecondarySupersTable requires Power7 or later.\");\n-    }\n-    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":7,"deletions":37,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -108,3 +108,0 @@\n-  static bool has_cmpb()    { return (_features & cmpb_m) != 0; }\n-  static bool has_popcntb() { return (_features & popcntb_m) != 0; }\n-  static bool has_popcntw() { return (_features & popcntw_m) != 0; }\n@@ -113,1 +110,0 @@\n-  static bool has_lqarx()   { return (_features & lqarx_m) != 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,6 +143,0 @@\n-#ifndef PV_7\n-  #define PV_7 0x200000          \/* Power PC 7 *\/\n-#endif\n-#ifndef PV_7_Compat\n-  #define PV_7_Compat 0x208000   \/* Power PC 7 *\/\n-#endif\n@@ -1246,27 +1240,0 @@\n-  case PV_7:\n-    strncpy(buf, \"Power PC 7\", buflen);\n-    break;\n-  case PV_6_1:\n-    strncpy(buf, \"Power PC 6 DD1.x\", buflen);\n-    break;\n-  case PV_6:\n-    strncpy(buf, \"Power PC 6\", buflen);\n-    break;\n-  case PV_5:\n-    strncpy(buf, \"Power PC 5\", buflen);\n-    break;\n-  case PV_5_2:\n-    strncpy(buf, \"Power PC 5_2\", buflen);\n-    break;\n-  case PV_5_3:\n-    strncpy(buf, \"Power PC 5_3\", buflen);\n-    break;\n-  case PV_5_Compat:\n-    strncpy(buf, \"PV_5_Compat\", buflen);\n-    break;\n-  case PV_6_Compat:\n-    strncpy(buf, \"PV_6_Compat\", buflen);\n-    break;\n-  case PV_7_Compat:\n-    strncpy(buf, \"PV_7_Compat\", buflen);\n-    break;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -249,13 +249,1 @@\n-  volatile int *dest_base = (volatile int*)((uintptr_t)dest & ~3);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  const unsigned int shift_amount        = ((uintptr_t)dest & 3) * 8;\n-#else\n-  const unsigned int shift_amount        = ((~(uintptr_t)dest) & 3) * 8;\n-#endif\n-  const unsigned int masked_compare_val  = ((unsigned int)(unsigned char)compare_value),\n-                     masked_exchange_val = ((unsigned int)(unsigned char)exchange_value),\n-                     xor_value           = (masked_compare_val ^ masked_exchange_val) << shift_amount;\n-\n-  unsigned int old_value, value32;\n-\n+  unsigned int old_value, loaded_value;\n@@ -265,4 +253,0 @@\n-    \/* simple guard *\/\n-    \"   lbz     %[old_value], 0(%[dest])                  \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n-    \"   bne-    2f                                        \\n\"\n@@ -271,1 +255,1 @@\n-    \"   lwarx   %[value32], 0, %[dest_base]               \\n\"\n+    \"   lbarx   %[old_value], 0, %[dest]               \\n\"\n@@ -273,3 +257,1 @@\n-    \"   srd     %[old_value], %[value32], %[shift_amount] \\n\"\n-    \"   clrldi  %[old_value], %[old_value], 56            \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n+    \"   cmpw    %[compare_value], %[old_value] \\n\"\n@@ -278,2 +260,1 @@\n-    \"   xor     %[value32], %[xor_value], %[value32]      \\n\"\n-    \"   stwcx.  %[value32], 0, %[dest_base]               \\n\"\n+    \"   stbcx.  %[exchange_value], 0, %[dest]               \\n\"\n@@ -285,11 +266,7 @@\n-      [value32]             \"=&r\"   (value32),\n-                            \"=m\"    (*dest),\n-                            \"=m\"    (*dest_base)\n-    \/* in *\/\n-    : [dest]                \"b\"     (dest),\n-      [dest_base]           \"b\"     (dest_base),\n-      [shift_amount]        \"r\"     (shift_amount),\n-      [masked_compare_val]  \"r\"     (masked_compare_val),\n-      [xor_value]           \"r\"     (xor_value),\n-                            \"m\"     (*dest),\n-                            \"m\"     (*dest_base)\n+      [loaded_value]             \"=&r\"   (loaded_value),\n+                            \"=m\"    (*dest)\n+  \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":11,"deletions":34,"binary":false,"changes":45,"status":"modified"}]}