{"files":[{"patch":"@@ -718,1 +718,1 @@\n-        $1_CFLAGS_CPU=\"-mcpu=powerpc64 -mtune=power8\"\n+        $1_CFLAGS_CPU=\"-mcpu=power8 -mtune=power8\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,2 +211,1 @@\n-inline void Assembler::isel(Register d, Register a, Register b, int c) { guarantee(VM_Version::has_isel(), \"opcode not supported on this hardware\");\n-                                                                         emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n+inline void Assembler::isel(Register d, Register a, Register b, int c) { emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n@@ -835,2 +834,1 @@\n-inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fcfids(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -842,4 +840,2 @@\n-inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrt(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n-inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrts(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -1052,2 +1048,1 @@\n-inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { guarantee(VM_Version::has_vand(), \"opcode not supported on this hardware\");\n-                                                                                        emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n+inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -543,1 +543,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -546,2 +545,3 @@\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n+      \/\/ move src to dst register\n+      if (code == Bytecodes::_i2d) {\n+        __ mtfprwa(rdst, src->as_register());\n@@ -549,7 +549,1 @@\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2d) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n+        __ mtfprd(rdst, src->as_register_lo());\n@@ -557,0 +551,1 @@\n+      rsrc = rdst;\n@@ -562,1 +557,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -565,2 +559,3 @@\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n+      \/\/ move src to dst register\n+      if (code == Bytecodes::_i2f) {\n+        __ mtfprwa(rdst, src->as_register());\n@@ -568,14 +563,1 @@\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2f) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      if (VM_Version::has_fcfids()) {\n-        __ fcfids(rdst, rsrc);\n-      } else {\n-        assert(code == Bytecodes::_i2f, \"fcfid+frsp needs fixup code to avoid rounding incompatibility\");\n-        __ fcfid(rdst, rsrc);\n-        __ frsp(rdst, rdst);\n+        __ mtfprd(rdst, src->as_register_lo());\n@@ -583,0 +565,2 @@\n+      rsrc = rdst;\n+      __ fcfids(rdst, rsrc);\n@@ -595,1 +579,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -597,1 +580,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n+      Address       addr = Address();\n@@ -601,6 +584,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register(), 0);\n-      }\n+      __ li(dst->as_register(), 0);\n@@ -609,5 +587,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register(), rsrc);\n-      }\n+      __ mffprd(dst->as_register(), rsrc);\n@@ -619,1 +593,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -621,1 +594,1 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n+      Address       addr = Address();\n@@ -625,6 +598,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register_lo(), 0);\n-      }\n+      __ li(dst->as_register_lo(), 0);\n@@ -633,5 +601,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register_lo(), rsrc);\n-      }\n+      __ stfd(rsrc, addr.disp(), addr.base());\n@@ -1585,1 +1549,1 @@\n-  if (VM_Version::has_isel() && result->is_cpu_register()) {\n+  if (result->is_cpu_register()) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":18,"deletions":54,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -717,8 +717,6 @@\n-      if (VM_Version::has_fsqrt()) {\n-        assert(x->number_of_arguments() == 1, \"wrong type\");\n-        LIRItem value(x->argument_at(0), this);\n-        value.load_item();\n-        LIR_Opr dst = rlock_result(x);\n-        __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n-        break;\n-      } \/\/ else fallthru\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n@@ -822,72 +820,0 @@\n-  if (!VM_Version::has_mtfprd()) {\n-    switch (x->op()) {\n-\n-      \/\/ int -> float: force spill\n-      case Bytecodes::_l2f: {\n-        if (!VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-          \/\/ fcfid+frsp needs fixup code to avoid rounding incompatibility.\n-          address entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);\n-          LIR_Opr result = call_runtime(x->value(), entry, x->type(), nullptr);\n-          set_result(x, result);\n-          return;\n-        } \/\/ else fallthru\n-      }\n-      case Bytecodes::_l2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        LIR_Opr tmp = force_to_spill(value.result(), T_DOUBLE);\n-        __ convert(x->op(), tmp, reg);\n-        return;\n-      }\n-      case Bytecodes::_i2f:\n-      case Bytecodes::_i2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        \/\/ Convert i2l first.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, value.result(), tmp1);\n-        LIR_Opr tmp2 = force_to_spill(tmp1, T_DOUBLE);\n-        __ convert(x->op(), tmp2, reg);\n-        return;\n-      }\n-\n-      \/\/ float -> int: result will be stored\n-      case Bytecodes::_f2l:\n-      case Bytecodes::_d2l: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        set_vreg_flag(reg, must_start_in_memory);\n-        __ convert(x->op(), value.result(), reg);\n-        return;\n-      }\n-      case Bytecodes::_f2i:\n-      case Bytecodes::_d2i: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        \/\/ Convert l2i afterwards.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        set_vreg_flag(tmp1, must_start_in_memory);\n-        __ convert(x->op(), value.result(), tmp1);\n-        __ convert(Bytecodes::_l2i, tmp1, reg);\n-        return;\n-      }\n-\n-      \/\/ Within same category: just register conversions.\n-      case Bytecodes::_i2b:\n-      case Bytecodes::_i2c:\n-      case Bytecodes::_i2s:\n-      case Bytecodes::_i2l:\n-      case Bytecodes::_l2i:\n-      case Bytecodes::_f2d:\n-      case Bytecodes::_d2f:\n-        break;\n-\n-      default: ShouldNotReachHere();\n-    }\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":6,"deletions":80,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -237,8 +237,1 @@\n-  if (VM_Version::has_isel()) {\n-    isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n-  } else {\n-    Label Lskip;\n-    blt(CR0, Lskip);\n-    mr(cnt1, cnt2);\n-    bind(Lskip);\n-  }\n+  isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -129,6 +129,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n-        } else {\n-          __ std(as_Register(from_reg), -8, R1_SP);\n-          __ lfd(as_FloatRegister(to_reg), -8, R1_SP);\n-        }\n+        __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n@@ -167,6 +162,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n-        } else {\n-          __ stfd(as_FloatRegister(from_reg), -8, R1_SP);\n-          __ ld(as_Register(to_reg), -8, R1_SP);\n-        }\n+        __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -363,7 +363,2 @@\n-  if (VM_Version::has_isel()) {\n-    __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n-    __ isel(dst, CR0, Assembler::equal, false, tmp1);\n-  } else {\n-    __ bne(CR0, done);\n-    __ xori(dst, tmp1, markWord::lock_mask_in_place);\n-  }\n+  __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n+  __ isel(dst, CR0, Assembler::equal, false, tmp1);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  product(bool, SuperwordUseVSX, false,                                     \\\n+  product(bool, SuperwordUseVSX, true,                                     \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,6 +311,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mtfprd(d, l);\n-  } else {\n-    std(l, 0, R15_esp);\n-    lfd(d, 0, R15_esp);\n-  }\n+  mtfprd(d, l);\n@@ -320,6 +315,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mffprd(l, d);\n-  } else {\n-    stfd(d, 0, R15_esp);\n-    ld(l, 0, R15_esp);\n-  }\n+  mffprd(l, d);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1583,4 +1583,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n-  const int instruction_type = size;\n@@ -1588,0 +1584,1 @@\n+  const int instruction_type = size;\n@@ -1593,15 +1590,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, tmp3, dest_current_value, exchange_value, addr_base);\n-    modval = tmp1;\n-    shift_amount = tmp2;\n-    val32 = tmp3;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-  }\n@@ -1619,4 +1601,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n-\n@@ -1625,7 +1603,0 @@\n-  if (instruction_type != size) {\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(modval, dest_current_value, is_add ? modval : exchange_value);\n-    clrldi(modval, modval, (size == 1) ? 56 : 48);\n-    slw(modval, modval, shift_amount);\n-    xorr(modval, val32, modval);\n-  }\n@@ -1657,2 +1628,2 @@\n-RegisterOrConstant compare_value, Register exchange_value,\n-Register addr_base, Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n+                                       Register addr_base, Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n@@ -1660,3 +1631,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n@@ -1679,3 +1647,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n@@ -1697,4 +1662,0 @@\n-  if (instruction_type != size) {\n-    xorr(modval, val32, exchange_value);\n-  }\n-\n@@ -3726,1 +3687,0 @@\n-  assert(!VM_Version::has_vpmsumb(), \"Vector version should be used instead!\");\n@@ -4293,5 +4253,1 @@\n-  if (VM_Version::has_vpmsumb()) {\n-    kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n-  } else {\n-    kernel_crc32_1word(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, t0, !is_crc32c);\n-  }\n+  kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":48,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -470,12 +470,4 @@\n-    if (VM_Version::has_isel()) {\n-      cmpdi(CR0, src, 0);\n-      Register co = encode_heap_oop_not_null(d, src);\n-      assert(co == d, \"sanity\");\n-      isel_0(d, CR0, Assembler::equal);\n-    } else {\n-      Label isNull;\n-      or_(d, src, src); \/\/ move and compare 0\n-      beq(CR0, isNull);\n-      encode_heap_oop_not_null(d, src);\n-      bind(isNull);\n-    }\n+    cmpdi(CR0, src, 0);\n+    Register co = encode_heap_oop_not_null(d, src);\n+    assert(co == d, \"sanity\");\n+    isel_0(d, CR0, Assembler::equal);\n@@ -513,5 +505,1 @@\n-    if (VM_Version::has_isel()) {\n-      use_isel = true;\n-    } else {\n-      beq(CR0, isNull);\n-    }\n+    use_isel = true;\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-  \/\/ false means that conversion is done by runtime call\n@@ -168,1 +167,1 @@\n-    return VM_Version::has_fcfids();\n+    return true;\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2068,1 +2068,0 @@\n-      return VM_Version::has_fsqrt();\n@@ -2070,1 +2069,0 @@\n-      return VM_Version::has_vsx();\n@@ -2925,0 +2923,5 @@\n+    \/\/ use isel instruction with Power 7\n+    cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n+    encodeP_subNode    *n_sub_base = new encodeP_subNode();\n+    encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n+    cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n@@ -2926,37 +2929,4 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_subNode    *n_sub_base = new encodeP_subNode();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      n_cond_set->add_req(n_region, n_compare, n_shift);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-      nodes->push(n_cond_set);\n+    n_compare->add_req(n_region, n_src);\n+    n_compare->_opnds[0] = op_crx;\n+    n_compare->_opnds[1] = op_src;\n+    n_compare->_opnds[2] = new immL16Oper(0);\n@@ -2964,40 +2934,25 @@\n-    } else {\n-      \/\/ before Power 7\n-      moveRegNode        *n_move     = new moveRegNode();\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();\n-\n-      n_move->add_req(n_region, n_src);\n-      n_move->_opnds[0] = op_dst;\n-      n_move->_opnds[1] = op_src;\n-      ra_->set_oop(n_move, true); \/\/ Until here, 'n_move' still produces an oop.\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->add_prec(n_move);\n-\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_compare, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_crx;\n-      n_sub_base->_opnds[2] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_move->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_move);\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-    }\n+    n_sub_base->add_req(n_region, n_src);\n+    n_sub_base->_opnds[0] = op_dst;\n+    n_sub_base->_opnds[1] = op_src;\n+    n_sub_base->_bottom_type = _bottom_type;\n+\n+    n_shift->add_req(n_region, n_sub_base);\n+    n_shift->_opnds[0] = op_dst;\n+    n_shift->_opnds[1] = op_dst;\n+    n_shift->_bottom_type = _bottom_type;\n+\n+    n_cond_set->add_req(n_region, n_compare, n_shift);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n+\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+\n+    nodes->push(n_compare);\n+    nodes->push(n_sub_base);\n+    nodes->push(n_shift);\n+    nodes->push(n_cond_set);\n@@ -3043,8 +2998,6 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-\n-      decodeN_addNode *n_add_base = new decodeN_addNode();\n-      n_add_base->add_req(n_region, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n+    \/\/ use isel instruction with Power 7\n+    decodeN_addNode *n_add_base = new decodeN_addNode();\n+    n_add_base->add_req(n_region, n_shift);\n+    n_add_base->_opnds[0] = op_dst;\n+    n_add_base->_opnds[1] = op_dst;\n+    n_add_base->_bottom_type = _bottom_type;\n@@ -3052,23 +3005,6 @@\n-      cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n-      n_cond_set->add_req(n_region, n_compare, n_add_base);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_cond_set, true);\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-      nodes->push(n_cond_set);\n-\n-    } else {\n-      \/\/ before Power 7\n-      cond_add_baseNode *n_add_base = new cond_add_baseNode();\n+    cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n+    n_cond_set->add_req(n_region, n_compare, n_add_base);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n@@ -3076,5 +3012,2 @@\n-      n_add_base->add_req(n_region, n_compare, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_crx;\n-      n_add_base->_opnds[2] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n+    assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n+    ra_->set_oop(n_cond_set, true);\n@@ -3082,2 +3015,4 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_add_base, true);\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n@@ -3085,3 +3020,4 @@\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    nodes->push(n_compare);\n+    nodes->push(n_shift);\n+    nodes->push(n_add_base);\n+    nodes->push(n_cond_set);\n@@ -3089,4 +3025,0 @@\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-    }\n@@ -6784,1 +6716,1 @@\n-            CompressedOops::base_disjoint() && VM_Version::has_isel());\n+            CompressedOops::base_disjoint());\n@@ -7164,1 +7096,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7179,13 +7110,0 @@\n-instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7209,1 +7127,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7224,13 +7141,1 @@\n-instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n+ \n@@ -7254,1 +7159,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7269,5 +7173,0 @@\n-\/\/ Conditional move for RegN. Only cmov(reg, reg).\n-instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n@@ -7275,8 +7174,0 @@\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -7300,1 +7191,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7315,13 +7205,0 @@\n-instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -9285,1 +9162,0 @@\n-\/\/ VM_Version::has_fsqrt() decides if this node will be used.\n@@ -9300,1 +9176,0 @@\n-  predicate(VM_Version::has_fsqrts());\n@@ -9824,1 +9699,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10512,1 +10386,0 @@\n-  predicate(!VM_Version::has_mtfprd());\n@@ -10529,1 +10402,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10557,1 +10429,0 @@\n-  predicate(!VM_Version::has_mtfprd());\n@@ -10574,1 +10445,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10770,1 +10640,0 @@\n-  predicate(!VM_Version::has_mtfprd());\n@@ -10787,1 +10656,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10815,1 +10683,0 @@\n-  predicate(!VM_Version::has_mtfprd());\n@@ -10832,1 +10699,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10874,1 +10740,0 @@\n-  predicate(!VM_Version::has_fcfids());\n@@ -10906,1 +10771,0 @@\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n@@ -10923,1 +10787,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -10936,1 +10799,0 @@\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n@@ -10951,1 +10813,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -10969,1 +10830,0 @@\n-  predicate(!VM_Version::has_mtfprd());\n@@ -10986,1 +10846,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11011,1 +10870,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -12629,1 +12487,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -12662,1 +12519,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -13049,1 +12905,1 @@\n-  predicate(VM_Version::has_ldbrx() && (n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n+  predicate((n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n@@ -13061,1 +12917,0 @@\n-  predicate(VM_Version::has_ldbrx());\n@@ -13142,1 +12997,0 @@\n-  predicate(VM_Version::has_stdbrx());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":59,"deletions":205,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -812,4 +812,2 @@\n-    if (VM_Version::has_mfdscr()) {\n-      __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n-      __ mtdscr(tmp1);\n-    }\n+    __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n+    __ mtdscr(tmp1);\n@@ -927,1 +925,0 @@\n-       if (!VM_Version::has_vsx()) {\n@@ -945,36 +942,0 @@\n-      } else { \/\/ Processor supports VSX, so use it to mass copy.\n-\n-        \/\/ Prefetch the data into the L2 cache.\n-        __ dcbt(R3_ARG1, 0);\n-\n-        \/\/ If supported set DSCR pre-fetch to deepest.\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-          __ mtdscr(tmp2);\n-        }\n-\n-        __ li(tmp1, 16);\n-\n-        \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n-        \/\/ loop contains < 8 instructions that fit inside a single\n-        \/\/ i-cache sector.\n-        __ align(32);\n-\n-        __ bind(l_10);\n-        \/\/ Use loop with VSX load\/store instructions to\n-        \/\/ copy 32 elements a time.\n-        __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n-        __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n-        __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n-        __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n-        __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n-        __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n-        __ bdnz(l_10);                       \/\/ Dec CTR and loop if not zero.\n-\n-        \/\/ Restore DSCR pre-fetch value.\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-          __ mtdscr(tmp2);\n-        }\n-\n-      } \/\/ VSX\n@@ -1223,51 +1184,0 @@\n-        if (!VM_Version::has_vsx()) {\n-\n-          __ bind(l_8);\n-          \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n-          \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-          \/\/ Therefore, the following sequence is made for the good of both.\n-          __ ld(tmp1, 0, R3_ARG1);\n-          __ ld(tmp2, 8, R3_ARG1);\n-          __ ld(tmp3, 16, R3_ARG1);\n-          __ ld(tmp4, 24, R3_ARG1);\n-          __ std(tmp1, 0, R4_ARG2);\n-          __ std(tmp2, 8, R4_ARG2);\n-          __ std(tmp3, 16, R4_ARG2);\n-          __ std(tmp4, 24, R4_ARG2);\n-          __ addi(R3_ARG1, R3_ARG1, 32);\n-          __ addi(R4_ARG2, R4_ARG2, 32);\n-          __ bdnz(l_8);\n-\n-        } else { \/\/ Processor supports VSX, so use it to mass copy.\n-\n-          \/\/ Prefetch src data into L2 cache.\n-          __ dcbt(R3_ARG1, 0);\n-\n-          \/\/ If supported set DSCR pre-fetch to deepest.\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-            __ mtdscr(tmp2);\n-          }\n-          __ li(tmp1, 16);\n-\n-          \/\/ Backbranch target aligned to 32-byte. It's not aligned 16-byte\n-          \/\/ as loop contains < 8 instructions that fit inside a single\n-          \/\/ i-cache sector.\n-          __ align(32);\n-\n-          __ bind(l_9);\n-          \/\/ Use loop with VSX load\/store instructions to\n-          \/\/ copy 16 elements a time.\n-          __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load from src.\n-          __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst.\n-          __ lxvd2x(tmp_vsr2, R3_ARG1, tmp1);  \/\/ Load from src + 16.\n-          __ stxvd2x(tmp_vsr2, R4_ARG2, tmp1); \/\/ Store to dst + 16.\n-          __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32.\n-          __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32.\n-          __ bdnz(l_9);                        \/\/ Dec CTR and loop if not zero.\n-\n-          \/\/ Restore DSCR pre-fetch value.\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-            __ mtdscr(tmp2);\n-          }\n@@ -1275,1 +1185,16 @@\n-        }\n+        __ bind(l_8);\n+        \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n+        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n+        \/\/ Therefore, the following sequence is made for the good of both.\n+        __ ld(tmp1, 0, R3_ARG1);\n+        __ ld(tmp2, 8, R3_ARG1);\n+        __ ld(tmp3, 16, R3_ARG1);\n+        __ ld(tmp4, 24, R3_ARG1);\n+        __ std(tmp1, 0, R4_ARG2);\n+        __ std(tmp2, 8, R4_ARG2);\n+        __ std(tmp3, 16, R4_ARG2);\n+        __ std(tmp4, 24, R4_ARG2);\n+        __ addi(R3_ARG1, R3_ARG1, 32);\n+        __ addi(R4_ARG2, R4_ARG2, 32);\n+        __ bdnz(l_8);\n+\n@@ -1430,1 +1355,1 @@\n-     if (!VM_Version::has_vsx()) {\n+    \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1432,17 +1357,2 @@\n-      __ bind(l_6);\n-      \/\/ Use unrolled version for mass copying (copy 8 elements a time).\n-      \/\/ Load feeding store gets zero latency on power6, however not on power 5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_6);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+    \/\/ Prefetch the data into the L2 cache.\n+    __ dcbt(R3_ARG1, 0);\n@@ -1450,2 +1360,3 @@\n-      \/\/ Prefetch the data into the L2 cache.\n-      __ dcbt(R3_ARG1, 0);\n+    \/\/ If supported set DSCR pre-fetch to deepest.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+    __ mtdscr(tmp2);\n@@ -1453,5 +1364,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+    __ li(tmp1, 16);\n@@ -1459,1 +1366,4 @@\n-      __ li(tmp1, 16);\n+    \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n+    \/\/ loop contains < 8 instructions that fit inside a single\n+    \/\/ i-cache sector.\n+    __ align(32);\n@@ -1461,4 +1371,10 @@\n-      \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n-      \/\/ loop contains < 8 instructions that fit inside a single\n-      \/\/ i-cache sector.\n-      __ align(32);\n+    __ bind(l_7);\n+    \/\/ Use loop with VSX load\/store instructions to\n+    \/\/ copy 8 elements a time.\n+    __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n+    __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n+    __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n+    __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n+    __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n+    __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n+    __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n@@ -1466,10 +1382,3 @@\n-      __ bind(l_7);\n-      \/\/ Use loop with VSX load\/store instructions to\n-      \/\/ copy 8 elements a time.\n-      __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n-      __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n-      __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n-      __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n-      __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n-      __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n-      __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n+    \/\/ Restore DSCR pre-fetch value.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+    __ mtdscr(tmp2);\n@@ -1477,5 +1386,0 @@\n-      \/\/ Restore DSCR pre-fetch value.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n@@ -1483,1 +1387,0 @@\n-    } \/\/ VSX\n@@ -1598,17 +1501,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else {  \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1618,5 +1505,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1643,1 +1528,0 @@\n-      if (VM_Version::has_mfdscr()) {\n@@ -1646,2 +1530,0 @@\n-      }\n-     }\n@@ -1734,18 +1616,1 @@\n-    if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_4);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1756,5 +1621,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1781,4 +1644,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n@@ -1786,1 +1647,0 @@\n-    } \/\/ VSX\n@@ -1879,17 +1739,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1899,5 +1743,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1924,5 +1766,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n-     }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":58,"deletions":219,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  const bool use_vector = VM_Version::has_vpmsumb();\n@@ -86,1 +85,1 @@\n-  const int size = use_vector ? CRC32_TABLE_SIZE + vector_size : (4 BIG_ENDIAN_ONLY(+1)) * CRC32_TABLE_SIZE;\n+  const int size = CRC32_TABLE_SIZE + vector_size;\n@@ -94,37 +93,2 @@\n-  LITTLE_ENDIAN_ONLY(if (use_vector)) {\n-    for (int i = 0; i < 256; ++i) {\n-      ptr[i] = fold_byte(i, reverse_poly);\n-    }\n-  }\n-\n-  if (!use_vector) {\n-    BIG_ENDIAN_ONLY(ptr = (juint*)(consts + CRC32_TABLE_SIZE);)\n-    \/\/ <= Power7: 4 tables\n-    for (int i = 0; i < 256; ++i) {\n-      juint a = fold_byte(i, reverse_poly),\n-            b = fold_byte(a, reverse_poly),\n-            c = fold_byte(b, reverse_poly),\n-            d = fold_byte(c, reverse_poly);\n-#ifndef VM_LITTLE_ENDIAN\n-      a = byteswap(a);\n-      b = byteswap(b);\n-      c = byteswap(c);\n-      d = byteswap(d);\n-#endif\n-      ptr[i         ] = a;\n-      ptr[i +    256] = b;\n-      ptr[i + 2* 256] = c;\n-      ptr[i + 3* 256] = d;\n-    }\n-#if 0\n-    for (int i = 0; i < 4; ++i) {\n-      tty->print_cr(\"table %d:\", i);\n-      for (int j = 0; j < 32; ++j) {\n-        for (int k = 0; k < 8; ++k) {\n-          tty->print(\"%08x \", ptr[i*256 + j*8 + k]);\n-        }\n-        tty->cr();\n-      }\n-    }\n-#endif\n-    return consts;\n+  for (int i = 0; i < 256; ++i) {\n+    ptr[i] = fold_byte(i, reverse_poly);\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":3,"deletions":39,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1080,1 +1080,1 @@\n-    case Interpreter::java_lang_math_sqrt: use_instruction = VM_Version::has_fsqrt(); break;\n+    case Interpreter::java_lang_math_sqrt: use_instruction = true; break;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,8 +322,1 @@\n-  if (VM_Version::has_isel()) {\n-    __ isel_0(R17_tos, CR0, Assembler::equal);\n-  } else {\n-    Label not_sentinel;\n-    __ bne(CR0, not_sentinel);\n-    __ li(R17_tos, 0);\n-    __ bind(not_sentinel);\n-  }\n+  __ isel_0(R17_tos, CR0, Assembler::equal);\n@@ -1537,7 +1530,1 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        \/\/ Comment: alternatively, load with sign extend could be done by lfiwax.\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        __ fcfid(F15_ftos, F15_ftos);\n-        __ frsp(F15_ftos, F15_ftos);\n-      }\n+      __ fcfids(F15_ftos, F15_ftos);\n@@ -1547,9 +1534,2 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        __ move_l_to_d();\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        \/\/ Avoid rounding problem when result should be 0x3f800001: need fixup code before fcfid+frsp.\n-        __ mr(R3_ARG1, R17_tos);\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::l2f));\n-        __ fmr(F15_ftos, F1_RET);\n-      }\n+      __ move_l_to_d();\n+      __ fcfids(F15_ftos, F15_ftos);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -98,5 +98,1 @@\n-  if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n-      FLAG_SET_ERGO(UsePopCountInstruction, true);\n-  }\n-\n-  if (!VM_Version::has_isel() && FLAG_IS_DEFAULT(ConditionalMoveLimit)) {\n+  if (FLAG_IS_DEFAULT(ConditionalMoveLimit)) {\n@@ -106,7 +102,2 @@\n-  if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n-      FLAG_SET_ERGO(SuperwordUseVSX, true);\n-  }\n-  MaxVectorSize = SuperwordUseVSX ? 16 : 8;\n-  if (FLAG_IS_DEFAULT(AlignVector)) {\n-    FLAG_SET_ERGO(AlignVector, false);\n-  }\n+\n+  MaxVectorSize = 16;\n@@ -121,7 +112,2 @@\n-    if (SuperwordUseVSX) {\n-      if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {\n-        FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);\n-      }\n-    } else if (UseVectorByteReverseInstructionsPPC64) {\n-      warning(\"UseVectorByteReverseInstructionsPPC64 specified, but needs SuperwordUseVSX.\");\n-      FLAG_SET_DEFAULT(UseVectorByteReverseInstructionsPPC64, false);\n+    if (FLAG_IS_DEFAULT(UseVectorByteReverseInstructionsPPC64)) {\n+      FLAG_SET_ERGO(UseVectorByteReverseInstructionsPPC64, true);\n@@ -177,3 +163,1 @@\n-               \"ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n-               (has_fsqrt()   ? \" fsqrt\"   : \"\"),\n-               (has_isel()    ? \" isel\"    : \"\"),\n+               \"ppc64%s%s%s%s%s\",\n@@ -181,8 +165,0 @@\n-               \"cmpb\",\n-               \"popcntb\",\n-               \"popcntw\",\n-               (has_fcfids()  ? \" fcfids\"  : \"\"),\n-               (has_vand()    ? \" vand\"    : \"\"),\n-               \"lqarx\",\n-               (has_vcipher() ? \" aes\"     : \"\"),\n-               (has_vpmsumb() ? \" vpmsumb\" : \"\"),\n@@ -190,3 +166,0 @@\n-               (has_vsx()     ? \" vsx\"     : \"\"),\n-               (has_ldbrx()   ? \" ldbrx\"   : \"\"),\n-               (has_stdbrx()  ? \" stdbrx\"  : \"\"),\n@@ -262,8 +235,2 @@\n-  if (has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAES)) {\n-      UseAES = true;\n-    }\n-  } else if (UseAES) {\n-    if (!FLAG_IS_DEFAULT(UseAES))\n-      warning(\"AES instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAES, false);\n+  if (FLAG_IS_DEFAULT(UseAES)) {\n+    UseAES = true;\n@@ -272,8 +239,2 @@\n-  if (UseAES && has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-      UseAESIntrinsics = true;\n-    }\n-  } else if (UseAESIntrinsics) {\n-    if (!FLAG_IS_DEFAULT(UseAESIntrinsics))\n-      warning(\"AES intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESIntrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n+    UseAESIntrinsics = true;\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":10,"deletions":49,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-  static bool has_fsqrt()   { return (_features & fsqrt_m) != 0; }\n@@ -106,1 +105,0 @@\n-  static bool has_isel()    { return (_features & isel_m) != 0; }\n@@ -108,4 +106,0 @@\n-  static bool has_fcfids()  { return (_features & fcfids_m) != 0; }\n-  static bool has_vand()    { return (_features & vand_m) != 0; }\n-  static bool has_vcipher() { return (_features & vcipher_m) != 0; }\n-  static bool has_vpmsumb() { return (_features & vpmsumb_m) != 0; }\n@@ -113,3 +107,0 @@\n-  static bool has_vsx()     { return (_features & vsx_m) != 0; }\n-  static bool has_ldbrx()   { return (_features & ldbrx_m) != 0; }\n-  static bool has_stdbrx()  { return (_features & stdbrx_m) != 0; }\n@@ -120,2 +111,0 @@\n-  static bool has_mtfprd()  { return has_vpmsumb(); } \/\/ alias for P8\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    \"   lbarx   %[old_value], 0, %[dest]               \\n\"\n+    \"   lbarx   %[old_value], 0, %[dest]                  \\n\"\n@@ -260,1 +260,1 @@\n-    \"   stbcx.  %[exchange_value], 0, %[dest]               \\n\"\n+    \"   stbcx.  %[exchange_value], 0, %[dest]             \\n\"\n@@ -268,1 +268,1 @@\n-  \/* in *\/\n+    \/* in *\/\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}