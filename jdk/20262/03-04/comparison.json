{"files":[{"patch":"@@ -2000,1 +2000,1 @@\n-  inline void waitrsv(); \/\/ >=Power7\n+  inline void waitrsv();\n@@ -2031,1 +2031,0 @@\n-  \/\/ >= Power7\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -703,1 +703,1 @@\n-inline bool Assembler::lxarx_hint_exclusive_access()                                          { return VM_Version::has_lxarxeh(); }\n+inline bool Assembler::lxarx_hint_exclusive_access()                                          { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-      FloatRegister rsrc;\n@@ -551,2 +550,1 @@\n-      rsrc = rdst;\n-      __ fcfid(rdst, rsrc);\n+      __ fcfid(rdst, rdst);\n@@ -558,1 +556,0 @@\n-      FloatRegister rsrc;\n@@ -565,2 +562,1 @@\n-      rsrc = rdst;\n-      __ fcfids(rdst, rsrc);\n+      __ fcfids(rdst, rdst);\n@@ -601,1 +597,1 @@\n-      __ stfd(rsrc, addr.disp(), addr.base());\n+      __ mffprd(dst->as_register_lo(), rsrc);\n@@ -1548,1 +1544,0 @@\n-  \/\/ Try to use isel on >=Power7.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-          runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);\n+\t        \/* run interpreted *\/\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  product(bool, SuperwordUseVSX, true,                                     \\\n+  product(bool, SuperwordUseVSX, true,                                      \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1574,1 +1574,0 @@\n-  const int instruction_type = size;\n@@ -1584,1 +1583,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1594,1 +1593,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1621,2 +1620,0 @@\n-  const int instruction_type = size;\n-\n@@ -1630,1 +1627,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1652,1 +1649,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -3808,97 +3805,0 @@\n-\/**\n- * @param crc   register containing existing CRC (32-bit)\n- * @param buf   register pointing to input byte buffer (byte*)\n- * @param len   register containing number of bytes\n- * @param table register pointing to CRC table\n- *\n- * uses R9..R12 as work register. Must be saved\/restored by caller!\n- *\/\n-void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,\n-                                        Register t0,  Register t1,  Register t2,  Register t3,\n-                                        Register tc0, Register tc1, Register tc2, Register tc3,\n-                                        bool invertCRC) {\n-  assert_different_registers(crc, buf, len, table);\n-\n-  Label L_mainLoop, L_tail;\n-  Register  tmp          = t0;\n-  Register  data         = t0;\n-  Register  tmp2         = t1;\n-  const int mainLoop_stepping  = 4;\n-  const int tailLoop_stepping  = 1;\n-  const int log_stepping       = exact_log2(mainLoop_stepping);\n-  const int mainLoop_alignment = 32; \/\/ InputForNewCode > 4 ? InputForNewCode : 32;\n-  const int complexThreshold   = 2*mainLoop_stepping;\n-\n-  \/\/ Don't test for len <= 0 here. This pathological case should not occur anyway.\n-  \/\/ Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles\n-  \/\/ for all well-behaved cases. The situation itself is detected and handled correctly\n-  \/\/ within update_byteLoop_crc32.\n-  assert(tailLoop_stepping == 1, \"check tailLoop_stepping!\");\n-\n-  BLOCK_COMMENT(\"kernel_crc32_1word {\");\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-\n-  \/\/ Check for short (<mainLoop_stepping) buffer.\n-  cmpdi(CR0, len, complexThreshold);\n-  blt(CR0, L_tail);\n-\n-  \/\/ Pre-mainLoop alignment did show a slight (1%) positive effect on performance.\n-  \/\/ We leave the code in for reference. Maybe we need alignment when we exploit vector instructions.\n-  {\n-    \/\/ Align buf addr to mainLoop_stepping boundary.\n-    neg(tmp2, buf);                              \/\/ Calculate # preLoop iterations for alignment.\n-    rldicl(tmp2, tmp2, 0, 64-log_stepping);      \/\/ Rotate tmp2 0 bits, insert into tmp2, anding with mask with 1s from 62..63.\n-\n-    if (complexThreshold > mainLoop_stepping) {\n-      sub(len, len, tmp2);                       \/\/ Remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    } else {\n-      sub(tmp, len, tmp2);                       \/\/ Remaining bytes for main loop.\n-      cmpdi(CR0, tmp, mainLoop_stepping);\n-      blt(CR0, L_tail);                         \/\/ For less than one mainloop_stepping left, do only tail processing\n-      mr(len, tmp);                              \/\/ remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    }\n-    update_byteLoop_crc32(crc, buf, tmp2, table, data, false);\n-  }\n-\n-  srdi(tmp2, len, log_stepping);                 \/\/ #iterations for mainLoop\n-  andi(len, len, mainLoop_stepping-1);           \/\/ remaining bytes for tailLoop\n-  mtctr(tmp2);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  Register crc_rv = crc;\n-#else\n-  Register crc_rv = tmp;                         \/\/ Load_reverse needs separate registers to work on.\n-                                                 \/\/ Occupies tmp, but frees up crc.\n-  load_reverse_32(crc_rv, crc);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc;\n-#endif\n-\n-  int reconstructTableOffset = crc32_table_columns(table, tc0, tc1, tc2, tc3);\n-\n-  align(mainLoop_alignment);                     \/\/ Octoword-aligned loop address. Shows 2% improvement.\n-  BIND(L_mainLoop);\n-    update_1word_crc32(crc_rv, buf, table, 0, mainLoop_stepping, crc_rv, t1, t2, t3, tc0, tc1, tc2, tc3);\n-    bdnz(L_mainLoop);\n-\n-#ifndef VM_LITTLE_ENDIAN\n-  load_reverse_32(crc, crc_rv);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc_rv;                                  \/\/ Tmp uses it's original register again.\n-#endif\n-\n-  \/\/ Restore original table address for tailLoop.\n-  if (reconstructTableOffset != 0) {\n-    addi(table, table, -reconstructTableOffset);\n-  }\n-\n-  \/\/ Process last few (<complexThreshold) bytes of buffer.\n-  BIND(L_tail);\n-  update_byteLoop_crc32(crc, buf, len, table, data, false);\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-  BLOCK_COMMENT(\"} kernel_crc32_1word\");\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":104,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -7146,1 +7146,0 @@\n- \n@@ -9801,12 +9800,0 @@\n-\/\/----------Moves between long and float\n-\n-instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE src);\n-  predicate(false);\n-\n-  format %{ \"storeD  $src, $dst \\t\/\/ STACK\" %}\n-  size(4);\n-  ins_encode( enc_stfd(src, dst) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -9838,21 +9825,0 @@\n-\/\/ Move long value from long stack-location to double register.\n-instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"LFD     $dst, $src \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_lfd(dst, src) );\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Move long value from long register to double stack-location.\n-instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STD     $src, $dst \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_std(src, dst) );\n-  ins_pipe(pipe_class_memory);\n-%}\n@@ -10258,53 +10224,0 @@\n-instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovI   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovI_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovI_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-\n-    \/\/ precedences for new nodes\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -10366,15 +10279,0 @@\n-\/\/ Double to Int conversion, NaN is mapped to 0.\n-instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{\n-  match(Set dst (ConvD2I src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2IRaw_regD(tmpD, src);                         \/\/ Convert float to int (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10409,15 +10307,0 @@\n-\/\/ Float to Int conversion, NaN is mapped to 0.\n-instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{\n-  match(Set dst (ConvF2I src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2IRaw_regF(tmpF, src);                         \/\/ Convert float to int (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10518,50 +10401,0 @@\n-instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovL   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovL_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConL16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovL_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConL16Node();\n-    MachNode *m2 = new cmovL_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immL16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -10620,15 +10453,0 @@\n-\/\/ Float to Long conversion, NaN is mapped to 0.\n-instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{\n-  match(Set dst (ConvF2L src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2LRaw_regF(tmpF, src);                         \/\/ Convert float to long (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10663,15 +10481,0 @@\n-\/\/ Double to Long conversion, NaN is mapped to 0.\n-instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{\n-  match(Set dst (ConvD2L src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2LRaw_regD(tmpD, src);                         \/\/ Convert float to long (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -10720,18 +10523,0 @@\n-\/\/ Integer to Float conversion.\n-instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regD tmpD2;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(tmpD2, tmpD);        \/\/ Convert to double.\n-    convD2F_reg(dst, tmpD2);             \/\/ Convert double to float.\n-  %}\n-%}\n-\n@@ -10751,15 +10536,0 @@\n-\/\/ Integer to Float conversion. Special version for Power7.\n-instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -10779,13 +10549,0 @@\n-\/\/ L2F to avoid runtime call.\n-instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{\n-  match(Set dst (ConvL2F src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regL_to_stkL(tmpS, src);             \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -10810,15 +10567,0 @@\n-\/\/ Integer to Double conversion.\n-instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2D src));\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(dst, tmpD);          \/\/ Convert to double.\n-  %}\n-%}\n@@ -10838,11 +10580,0 @@\n-\/\/ Long to Double conversion\n-instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{\n-  match(Set dst (ConvL2D src));\n-  ins_cost(DEFAULT_COST + MEMORY_REF_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    moveL2D_stack_reg(tmpD, src);\n-    convL2DRaw_regD(dst, tmpD);\n-  %}\n-%}\n@@ -12447,19 +12178,0 @@\n-instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MinI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andL_reg_reg(doz, diff, sm); \/\/ <=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -12479,19 +12191,0 @@\n-instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MaxI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andcL_reg_reg(doz, diff, sm); \/\/ >=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":307,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -926,15 +926,28 @@\n-        __ bind(l_8);\n-        \/\/ Use unrolled version for mass copying (copy 32 elements a time)\n-        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-        \/\/ Therefore, the following sequence is made for the good of both.\n-        __ ld(tmp1, 0, R3_ARG1);\n-        __ ld(tmp2, 8, R3_ARG1);\n-        __ ld(tmp3, 16, R3_ARG1);\n-        __ ld(tmp4, 24, R3_ARG1);\n-        __ std(tmp1, 0, R4_ARG2);\n-        __ std(tmp2, 8, R4_ARG2);\n-        __ std(tmp3, 16, R4_ARG2);\n-        __ std(tmp4, 24, R4_ARG2);\n-        __ addi(R3_ARG1, R3_ARG1, 32);\n-        __ addi(R4_ARG2, R4_ARG2, 32);\n-        __ bdnz(l_8);\n+        \/\/ Prefetch the data into the L2 cache.\n+        __ dcbt(R3_ARG1, 0);\n+\n+        \/\/ If supported set DSCR pre-fetch to deepest.\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+        __ mtdscr(tmp2);\n+\n+        __ li(tmp1, 16);\n+\n+        \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n+        \/\/ loop contains < 8 instructions that fit inside a single\n+        \/\/ i-cache sector.\n+        __ align(32);\n+\n+        __ bind(l_10);\n+        \/\/ Use loop with VSX load\/store instructions to\n+        \/\/ copy 32 elements a time.\n+        __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n+        __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n+        __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n+        __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n+        __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n+        __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n+        __ bdnz(l_10);                       \/\/ Dec CTR and loop if not zero.\n+\n+        \/\/ Restore DSCR pre-fetch value.\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+        __ mtdscr(tmp2);\n@@ -1185,15 +1198,30 @@\n-        __ bind(l_8);\n-        \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n-        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-        \/\/ Therefore, the following sequence is made for the good of both.\n-        __ ld(tmp1, 0, R3_ARG1);\n-        __ ld(tmp2, 8, R3_ARG1);\n-        __ ld(tmp3, 16, R3_ARG1);\n-        __ ld(tmp4, 24, R3_ARG1);\n-        __ std(tmp1, 0, R4_ARG2);\n-        __ std(tmp2, 8, R4_ARG2);\n-        __ std(tmp3, 16, R4_ARG2);\n-        __ std(tmp4, 24, R4_ARG2);\n-        __ addi(R3_ARG1, R3_ARG1, 32);\n-        __ addi(R4_ARG2, R4_ARG2, 32);\n-        __ bdnz(l_8);\n+        \/\/ Processor supports VSX, so use it to mass copy.\n+\n+          \/\/ Prefetch src data into L2 cache.\n+          __ dcbt(R3_ARG1, 0);\n+\n+          \/\/ If supported set DSCR pre-fetch to deepest.\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+          __ mtdscr(tmp2);\n+          __ li(tmp1, 16);\n+\n+          \/\/ Backbranch target aligned to 32-byte. It's not aligned 16-byte\n+          \/\/ as loop contains < 8 instructions that fit inside a single\n+          \/\/ i-cache sector.\n+          __ align(32);\n+\n+          __ bind(l_9);\n+          \/\/ Use loop with VSX load\/store instructions to\n+          \/\/ copy 16 elements a time.\n+          __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load from src.\n+          __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst.\n+          __ lxvd2x(tmp_vsr2, R3_ARG1, tmp1);  \/\/ Load from src + 16.\n+          __ stxvd2x(tmp_vsr2, R4_ARG2, tmp1); \/\/ Store to dst + 16.\n+          __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32.\n+          __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32.\n+          __ bdnz(l_9);                        \/\/ Dec CTR and loop if not zero.\n+\n+          \/\/ Restore DSCR pre-fetch value.\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+          __ mtdscr(tmp2);\n+          \n@@ -1528,2 +1556,2 @@\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":60,"deletions":32,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-  \/\/ <= Power7 Little Endian: 4 tables for byte folding\n-  \/\/ <= Power7 Big Endian: 1 table for single byte folding + 4 tables for multi-byte folding\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-    case Interpreter::java_lang_math_sqrt : runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);  break;\n+    case Interpreter::java_lang_math_sqrt : \/* run interpreted *\/  break;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,2 +102,4 @@\n-\n-  MaxVectorSize = 16;\n+  MaxVectorSize = SuperwordUseVSX ? 16 : 8;\n+  if (FLAG_IS_DEFAULT(AlignVector)) {\n+    FLAG_SET_ERGO(AlignVector, false);\n+  }\n@@ -163,3 +165,2 @@\n-               \"ppc64%s%s%s%s\",\n-               (has_lxarxeh() ? \" lxarxeh\" : \"\"),\n-               (has_vshasig() ? \" sha\"     : \"\"),\n+               \"ppc64%s%s%s\",\n+               (\" sha\"),\n@@ -261,8 +262,2 @@\n-  if (has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA)) {\n-      UseSHA = true;\n-    }\n-  } else if (UseSHA) {\n-    if (!FLAG_IS_DEFAULT(UseSHA))\n-      warning(\"SHA instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSHA, false);\n+  if (FLAG_IS_DEFAULT(UseSHA)) {\n+    UseSHA = true;\n@@ -276,7 +271,3 @@\n-  if (UseSHA && has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n-    }\n-  } else if (UseSHA256Intrinsics) {\n-    warning(\"Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);\n+\n+  if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);\n@@ -285,7 +276,2 @@\n-  if (UseSHA && has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n-      FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n-    }\n-  } else if (UseSHA512Intrinsics) {\n-    warning(\"Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -104,3 +104,1 @@\n-  static bool has_fsqrts()  { return (_features & fsqrts_m) != 0; }\n-  static bool has_lxarxeh() { return (_features & lxarxeh_m) !=0; }\n-  static bool has_vshasig() { return (_features & vshasig_m) != 0; }\n+  static bool has_mfdscr()  { return (_features & mfdscr_m) != 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}