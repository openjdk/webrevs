{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -540,2 +540,8 @@\n-            if (cancelled || publisher == null && bodies.isEmpty()) {\n-                return;\n+            synchronized (this) {\n+                \/\/ We are finished when publisher is null and bodies\n+                \/\/ is empty. This means that the data from the last\n+                \/\/ publisher in the list has been consumed.\n+                \/\/ If we are finished or cancelled, do nothing.\n+                if (cancelled || (publisher == null && bodies.isEmpty())) {\n+                    return;\n+                }\n@@ -546,0 +552,2 @@\n+                \/\/ request() should not throw - the scheduler will\n+                \/\/ invoke onError on the subscriber.\n@@ -557,2 +565,1 @@\n-        private boolean cancelSubscription() {\n-            Flow.Subscription subscription = this.subscription;\n+        private boolean cancelSubscription(Flow.Subscription subscription) {\n@@ -560,2 +567,6 @@\n-                this.subscription = null;\n-                this.publisher = null;\n+                synchronized (this) {\n+                    if (this.subscription == subscription) {\n+                        this.subscription = null;\n+                        this.publisher = null;\n+                    }\n+                }\n@@ -564,0 +575,2 @@\n+            \/\/ This method is called when cancel is true, so\n+            \/\/ we should always stop the scheduler here\n@@ -570,0 +583,2 @@\n+                BodyPublisher publisher;\n+                Flow.Subscription subscription = null;\n@@ -572,1 +587,1 @@\n-                        || (publisher == null && !bodies.isEmpty()))) {\n+                        || (this.publisher == null && !bodies.isEmpty()))) {\n@@ -574,2 +589,5 @@\n-                    BodyPublisher publisher = this.publisher;\n-                    Flow.Subscription subscription = this.subscription;\n+                    \/\/ make sure we see a consistent state.\n+                    synchronized (this) {\n+                        publisher = this.publisher;\n+                        subscription = this.subscription;\n+                    }\n@@ -579,1 +597,1 @@\n-                        cancelSubscription();\n+                        cancelSubscription(subscription);\n@@ -583,1 +601,7 @@\n-                        this.publisher = publisher = bodies.poll();\n+                        \/\/ synchronize here to avoid race condition with\n+                        \/\/ request(long) which could otherwise observe a\n+                        \/\/ null publisher and an empty bodies list when\n+                        \/\/ polling the last publisher.\n+                        synchronized (this) {\n+                            this.publisher = publisher = bodies.poll();\n+                        }\n@@ -585,1 +609,0 @@\n-                        subscription = this.subscription;\n@@ -593,4 +616,11 @@\n-                    if (subscription == null) return;\n-                    if (!demand.isFulfilled()) {\n-                        long n = demand.decreaseAndGet(demand.get());\n-                        demanded.increase(n);\n+                    long n = 0;\n+                    \/\/ synchronize to avoid race condition with\n+                    \/\/ publisherDone()\n+                    synchronized (this) {\n+                        if ((subscription = this.subscription) == null) return;\n+                        if (!demand.isFulfilled()) {\n+                            n = demand.decreaseAndGet(demand.get());\n+                            demanded.increase(n);\n+                        }\n+                    }\n+                    if (n > 0 && !cancelled) {\n@@ -605,0 +635,8 @@\n+        \/\/ It is important to synchronize when setting\n+        \/\/ publisher to null to avoid race conditions\n+        \/\/ with request(long)\n+        private synchronized void publisherDone() {\n+            publisher = null;\n+            subscription = null;\n+        }\n+\n@@ -608,1 +646,8 @@\n-            this.subscription = subscription;\n+            \/\/ synchronize for asserting in a consistent state.\n+            synchronized (this) {\n+                \/\/ we shouldn't be able to observe a null publisher\n+                \/\/ when onSubscribe is called, unless - possibly - if\n+                \/\/ there was some error...\n+                assert publisher != null || error.get() != null;\n+                this.subscription = subscription;\n+            }\n@@ -614,2 +659,2 @@\n-            \/\/ make sure to cancel the subscription if we receive\n-            \/\/ an item after the subscription was cancelled or\n+            \/\/ make sure to cancel the downstream subscription if we receive\n+            \/\/ an item after the aggregate subscription was cancelled or\n@@ -618,1 +663,1 @@\n-                cancelSubscription();\n+                cancelSubscription(this.subscription);\n@@ -628,2 +673,1 @@\n-                publisher = null;\n-                subscription = null;\n+                publisherDone();\n@@ -635,2 +679,1 @@\n-        @Override\n-        public void onComplete() {\n+        private synchronized boolean completeAndContinue() {\n@@ -641,2 +684,11 @@\n-                publisher = null;\n-                subscription = null;\n+                publisherDone();\n+                return true; \/\/ continue\n+            } else {\n+                publisherDone();\n+                return false; \/\/ stop\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            if (completeAndContinue()) {\n@@ -645,2 +697,0 @@\n-                publisher = null;\n-                subscription = null;\n@@ -654,0 +704,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":80,"deletions":29,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n@@ -60,0 +58,1 @@\n+import java.util.concurrent.Semaphore;\n@@ -70,1 +69,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -73,3 +71,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n@@ -422,3 +417,5 @@\n-        CompletableFuture<Subscription> subscriptionCF = new CompletableFuture<>();\n-        ConcurrentLinkedDeque<ByteBuffer> items = new ConcurrentLinkedDeque<>();\n-        CompletableFuture<List<ByteBuffer>> resultCF = new CompletableFuture<>();\n+        final CompletableFuture<Subscription> subscriptionCF = new CompletableFuture<>();\n+        final ConcurrentLinkedDeque<ByteBuffer> items = new ConcurrentLinkedDeque<>();\n+        final CompletableFuture<List<ByteBuffer>> resultCF = new CompletableFuture<>();\n+\n+        final Semaphore semaphore = new Semaphore(0);\n@@ -434,0 +431,5 @@\n+            int available = semaphore.availablePermits();\n+            if (available > Integer.MAX_VALUE - 8) {\n+                onError(new IllegalStateException(\"too many buffers in queue: \" + available));\n+            }\n+            semaphore.release();\n@@ -446,0 +448,12 @@\n+        public ByteBuffer take() {\n+            \/\/ it is not guaranteed that the buffer will be added to\n+            \/\/ the queue in the same thread that calls request(1).\n+            try {\n+                semaphore.acquire();\n+            } catch (InterruptedException x) {\n+                Thread.currentThread().interrupt();\n+                throw new CompletionException(x);\n+            }\n+            return items.pop();\n+        }\n+\n@@ -631,1 +645,1 @@\n-        assertTrue(requestSubscriber1.resultCF().isDone());\n+        \/\/ onNext() may not be called in the same thread than request()\n@@ -633,0 +647,1 @@\n+        assertTrue(requestSubscriber1.resultCF().isDone());\n@@ -649,1 +664,0 @@\n-        assertTrue(requestSubscriber2.resultCF().isDone());\n@@ -651,0 +665,1 @@\n+        assertTrue(requestSubscriber2.resultCF().isDone());\n@@ -692,1 +707,1 @@\n-                ByteBuffer buffer = subscriber.items.pop();\n+                ByteBuffer buffer = subscriber.take();\n@@ -792,1 +807,2 @@\n-        System.out.println(\"Request to \" + uri);\n+        System.out.printf(\"Request to %s (sameClient: %s)%n\", uri, sameClient);\n+        System.err.printf(\"Request to %s (sameClient: %s)%n\", uri, sameClient);\n@@ -805,1 +821,2 @@\n-            System.out.println(\"Iteration: \" + i);\n+            System.out.println(uri + \": Iteration: \" + i);\n+            System.err.println(uri + \": Iteration: \" + i);\n","filename":"test\/jdk\/java\/net\/httpclient\/AggregateRequestBodyTest.java","additions":32,"deletions":15,"binary":false,"changes":47,"status":"modified"}]}