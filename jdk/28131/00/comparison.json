{"files":[{"patch":"@@ -3326,91 +3326,0 @@\n-\/\/ this simulates the behaviour of the x86 cmpxchg instruction using a\n-\/\/ load linked\/store conditional pair. we use the acquire\/release\n-\/\/ versions of these instructions so that we flush pending writes as\n-\/\/ per Java semantics.\n-\n-\/\/ n.b the x86 version assumes the old value to be compared against is\n-\/\/ in rax and updates rax with the value located in memory if the\n-\/\/ cmpxchg fails. we supply a register for the old value explicitly\n-\n-\/\/ the aarch64 load linked\/store conditional instructions do not\n-\/\/ accept an offset. so, unlike x86, we must provide a plain register\n-\/\/ to identify the memory word to be compared\/exchanged rather than a\n-\/\/ register+offset Address.\n-\n-void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,\n-                                Label &succeed, Label *fail) {\n-  \/\/ oldv holds comparison value\n-  \/\/ newv holds value to write in exchange\n-  \/\/ addr identifies memory word to compare against\/update\n-  if (UseLSE) {\n-    mov(tmp, oldv);\n-    casal(Assembler::xword, oldv, newv, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::EQ, succeed);\n-    membar(AnyAny);\n-  } else {\n-    Label retry_load, nope;\n-    prfm(Address(addr), PSTL1STRM);\n-    bind(retry_load);\n-    \/\/ flush and load exclusive from the memory location\n-    \/\/ and fail if it is not what we expect\n-    ldaxr(tmp, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::NE, nope);\n-    \/\/ if we store+flush with no intervening write tmp will be zero\n-    stlxr(tmp, newv, addr);\n-    cbzw(tmp, succeed);\n-    \/\/ retry so we only ever return after a load fails to compare\n-    \/\/ ensures we don't return a stale value after a failed write.\n-    b(retry_load);\n-    \/\/ if the memory word differs we return it in oldv and signal a fail\n-    bind(nope);\n-    membar(AnyAny);\n-    mov(oldv, tmp);\n-  }\n-  if (fail)\n-    b(*fail);\n-}\n-\n-void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n-                                        Label &succeed, Label *fail) {\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"assumption\");\n-  cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);\n-}\n-\n-void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,\n-                                Label &succeed, Label *fail) {\n-  \/\/ oldv holds comparison value\n-  \/\/ newv holds value to write in exchange\n-  \/\/ addr identifies memory word to compare against\/update\n-  \/\/ tmp returns 0\/1 for success\/failure\n-  if (UseLSE) {\n-    mov(tmp, oldv);\n-    casal(Assembler::word, oldv, newv, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::EQ, succeed);\n-    membar(AnyAny);\n-  } else {\n-    Label retry_load, nope;\n-    prfm(Address(addr), PSTL1STRM);\n-    bind(retry_load);\n-    \/\/ flush and load exclusive from the memory location\n-    \/\/ and fail if it is not what we expect\n-    ldaxrw(tmp, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::NE, nope);\n-    \/\/ if we store+flush with no intervening write tmp will be zero\n-    stlxrw(tmp, newv, addr);\n-    cbzw(tmp, succeed);\n-    \/\/ retry so we only ever return after a load fails to compare\n-    \/\/ ensures we don't return a stale value after a failed write.\n-    b(retry_load);\n-    \/\/ if the memory word differs we return it in oldv and signal a fail\n-    bind(nope);\n-    membar(AnyAny);\n-    mov(oldv, tmp);\n-  }\n-  if (fail)\n-    b(*fail);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1202,10 +1202,0 @@\n-  \/\/ Various forms of CAS\n-\n-  void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n-                          Label &succeed, Label *fail);\n-  void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,\n-                  Label &succeed, Label *fail);\n-\n-  void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,\n-                  Label &succeed, Label *fail);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}