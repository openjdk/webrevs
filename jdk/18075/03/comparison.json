{"files":[{"patch":"@@ -4094,20 +4094,0 @@\n-operand immI_63()\n-%{\n-  predicate(n->get_int() == 63);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_64()\n-%{\n-  predicate(n->get_int() == 64);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4243,22 +4223,0 @@\n-\/\/ 26 bit signed offset -- for pc-relative branches\n-operand immI26()\n-%{\n-  predicate(((-(1 << 25)) <= n->get_int()) && (n->get_int() < (1 << 25)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ 19 bit signed offset -- for pc-relative loads\n-operand immI19()\n-%{\n-  predicate(((-(1 << 18)) <= n->get_int()) && (n->get_int() < (1 << 18)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4287,21 +4245,0 @@\n-\/\/ 12 bit unsigned offset -- for base plus immediate loads\n-operand immIU12()\n-%{\n-  predicate((0 <= n->get_int()) && (n->get_int() < (1 << 12)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLU12()\n-%{\n-  predicate((0 <= n->get_long()) && (n->get_long() < (1 << 12)));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4572,11 +4509,0 @@\n-\/\/ 64 bit unit increment\n-operand immL_1()\n-%{\n-  predicate(n->get_long() == 1);\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4594,13 +4520,0 @@\n-\/\/ 32 bit offset of pc in thread anchor\n-\n-operand immL_pc_off()\n-%{\n-  predicate(n->get_long() == in_bytes(JavaThread::frame_anchor_offset()) +\n-                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4695,24 +4608,0 @@\n-\/\/ Pointer Immediate Minus One\n-\/\/ this is used when we want to write the current PC to the thread anchor\n-operand immP_M1()\n-%{\n-  predicate(n->get_ptr() == -1);\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Pointer Immediate Minus Two\n-\/\/ this is used when we want to write the current PC to the thread anchor\n-operand immP_M2()\n-%{\n-  predicate(n->get_ptr() == -2);\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4983,22 +4872,0 @@\n-\/\/ Long 64 bit Register R2 only\n-operand iRegL_R2()\n-%{\n-  constraint(ALLOC_IN_RC(r2_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Long 64 bit Register R3 only\n-operand iRegL_R3()\n-%{\n-  constraint(ALLOC_IN_RC(r3_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5016,11 +4883,0 @@\n-\/\/ Pointer 64 bit Register FP only\n-operand iRegP_FP()\n-%{\n-  constraint(ALLOC_IN_RC(fp_reg));\n-  match(RegP);\n-  \/\/ match(iRegP);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5085,27 +4941,0 @@\n-operand iRegN_R0()\n-%{\n-  constraint(ALLOC_IN_RC(r0_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand iRegN_R2()\n-%{\n-  constraint(ALLOC_IN_RC(r2_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand iRegN_R3()\n-%{\n-  constraint(ALLOC_IN_RC(r3_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5262,216 +5091,0 @@\n-operand vRegD_V8()\n-%{\n-  constraint(ALLOC_IN_RC(v8_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V9()\n-%{\n-  constraint(ALLOC_IN_RC(v9_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V10()\n-%{\n-  constraint(ALLOC_IN_RC(v10_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V11()\n-%{\n-  constraint(ALLOC_IN_RC(v11_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V12()\n-%{\n-  constraint(ALLOC_IN_RC(v12_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V13()\n-%{\n-  constraint(ALLOC_IN_RC(v13_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V14()\n-%{\n-  constraint(ALLOC_IN_RC(v14_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V15()\n-%{\n-  constraint(ALLOC_IN_RC(v15_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V16()\n-%{\n-  constraint(ALLOC_IN_RC(v16_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V17()\n-%{\n-  constraint(ALLOC_IN_RC(v17_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V18()\n-%{\n-  constraint(ALLOC_IN_RC(v18_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V19()\n-%{\n-  constraint(ALLOC_IN_RC(v19_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V20()\n-%{\n-  constraint(ALLOC_IN_RC(v20_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V21()\n-%{\n-  constraint(ALLOC_IN_RC(v21_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V22()\n-%{\n-  constraint(ALLOC_IN_RC(v22_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V23()\n-%{\n-  constraint(ALLOC_IN_RC(v23_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V24()\n-%{\n-  constraint(ALLOC_IN_RC(v24_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V25()\n-%{\n-  constraint(ALLOC_IN_RC(v25_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V26()\n-%{\n-  constraint(ALLOC_IN_RC(v26_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V27()\n-%{\n-  constraint(ALLOC_IN_RC(v27_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V28()\n-%{\n-  constraint(ALLOC_IN_RC(v28_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V29()\n-%{\n-  constraint(ALLOC_IN_RC(v29_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V30()\n-%{\n-  constraint(ALLOC_IN_RC(v30_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V31()\n-%{\n-  constraint(ALLOC_IN_RC(v31_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5579,9 +5192,0 @@\n-operand lr_RegP(iRegP reg)\n-%{\n-  constraint(ALLOC_IN_RC(lr_reg)); \/\/ link_reg\n-  match(reg);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5662,14 +5266,0 @@\n-operand indOffI(iRegP reg, immIOffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5746,14 +5336,0 @@\n-operand indOffL(iRegP reg, immLoffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5936,16 +5512,0 @@\n-\n-\/\/ AArch64 opto stubs need to write to the pc slot in the thread anchor\n-operand thread_anchor_pc(thread_RegP reg, immL_pc_off off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":440,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -1740,50 +1740,0 @@\n-\/\/ Integer Immediate: the value 1\n-operand immI_1() %{\n-  predicate(n->get_int() == 1);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 2\n-operand immI_2() %{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 3\n-operand immI_3() %{\n-  predicate(n->get_int() == 3);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 4\n-operand immI_4() %{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 8\n-operand immI_8() %{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -1920,21 +1870,0 @@\n-\n-\/\/ Long Immediate: the value FF\n-operand immL_FF() %{\n-  predicate( n->get_long() == 0xFFL );\n-  match(ConL);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate: the value FFFF\n-operand immL_FFFF() %{\n-  predicate( n->get_long() == 0xFFFFL );\n-  match(ConL);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -1960,30 +1889,0 @@\n-\/\/ Pointer Immediate\n-operand immN()\n-%{\n-  match(ConN);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immNKlass()\n-%{\n-  match(ConNKlass);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Null Pointer Immediate\n-operand immN0()\n-%{\n-  predicate(n->get_narrowcon() == 0);\n-  match(ConN);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":101,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -504,25 +504,0 @@\n-operand immIRotneg() %{\n-  \/\/ if AsmOperand::is_rotated_imm() is true for this constant, it is\n-  \/\/ a immIRot and an optimal instruction combination exists to handle the\n-  \/\/ constant as an immIRot\n-  predicate(!AsmOperand::is_rotated_imm(n->get_int()) && AsmOperand::is_rotated_imm(-n->get_int()));\n-  match(ConI);\n-\n-  op_cost(0);\n-  \/\/ formats are generated automatically for constants and base registers\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Non-negative integer immediate that is encodable using the rotation scheme,\n-\/\/ and that when expanded fits in 31 bits.\n-operand immU31Rot() %{\n-  predicate((0 <= n->get_int()) && AsmOperand::is_rotated_imm(n->get_int()));\n-  match(ConI);\n-\n-  op_cost(0);\n-  \/\/ formats are generated automatically for constants and base registers\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -549,9 +524,9 @@\n-operand immLRot2() %{\n-  predicate(AsmOperand::is_rotated_imm((int)(n->get_long() >> 32)) &&\n-            AsmOperand::is_rotated_imm((int)(n->get_long())));\n-  match(ConL);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n+\/\/operand immLRot2() %{\n+\/\/  predicate(AsmOperand::is_rotated_imm((int)(n->get_long() >> 32)) &&\n+\/\/            AsmOperand::is_rotated_imm((int)(n->get_long())));\n+\/\/  match(ConL);\n+\/\/  op_cost(0);\n+\/\/\n+\/\/  format %{ %}\n+\/\/  interface(CONST_INTER);\n+\/\/%}\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":9,"deletions":34,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4391,21 +4391,0 @@\n-operand rarg2RegL() %{\n-  constraint(ALLOC_IN_RC(rarg2_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rarg3RegL() %{\n-  constraint(ALLOC_IN_RC(rarg3_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rarg4RegL() %{\n-  constraint(ALLOC_IN_RC(rarg4_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2969,13 +2969,0 @@\n-\/\/ 32 bit offset of pc in thread anchor\n-\n-operand immL_pc_off()\n-%{\n-  predicate(n->get_long() == in_bytes(JavaThread::frame_anchor_offset()) +\n-                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -3189,11 +3176,0 @@\n-\/\/ Long 64 bit Register R28 only\n-operand iRegL_R28()\n-%{\n-  constraint(ALLOC_IN_RC(r28_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3697,16 +3673,0 @@\n-\/\/ RISCV opto stubs need to write to the pc slot in the thread anchor\n-operand thread_anchor_pc(javaThread_RegP reg, immL_pc_off off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2581,18 +2581,0 @@\n-\/\/ Integer Immediate: 6-bit\n-operand uimmI6() %{\n-  predicate(Immediate::is_uimm(n->get_int(), 6));\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: 5-bit\n-operand uimmI5() %{\n-  predicate(Immediate::is_uimm(n->get_int(), 5));\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2643,9 +2625,0 @@\n-\/\/ Integer Immediate: the value 255\n-operand immI_255() %{\n-  predicate(n->get_int() == 255);\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2756,9 +2729,0 @@\n-\/\/ Unsigned Long Immediate: 8-bit\n-operand uimmL8() %{\n-  predicate(Immediate::is_uimm8(n->get_long()));\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2769,18 +2733,0 @@\n-\/\/ Long Immediate: the value FF\n-operand immL_FF() %{\n-  predicate(n->get_long() == 0xFFL);\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate: the value FFFF\n-operand immL_FFFF() %{\n-  predicate(n->get_long() == 0xFFFFL);\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2861,9 +2807,0 @@\n-\/\/ Pointer Immediate: 32-bit\n-operand immP32() %{\n-  predicate(Immediate::is_uimm32(n->get_ptr()));\n-  match(ConP);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -3169,14 +3106,0 @@\n-operand lock_ptr_RegP() %{\n-  constraint(ALLOC_IN_RC(z_lock_ptr_reg));\n-  match(RegP);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rscratch2RegP() %{\n-  constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));\n-  match(RegP);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3297,8 +3220,0 @@\n-\/\/ Condition Code Flag Registers for rules with result tuples\n-operand TD_flagsReg() %{\n-  constraint(ALLOC_IN_RC(z_condition_reg));\n-  match(RegFlags);\n-  format %{ \"CR\" %}\n-  interface(REG_TUPLE_DEST_INTER);\n-%}\n-\n@@ -3312,7 +3227,0 @@\n-operand rscratchRegD() %{\n-  constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));\n-  match(RegD);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3326,7 +3234,0 @@\n-operand rscratchRegF() %{\n-  constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));\n-  match(RegF);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3343,20 +3244,0 @@\n-\/\/ Operands to remove register moves in unscaled mode.\n-\/\/ Match read\/write registers with an EncodeP node if neither shift nor add are required.\n-operand iRegP2N(iRegP reg) %{\n-  predicate(CompressedOops::shift() == 0 && _leaf->as_EncodeP()->in(0) == nullptr);\n-  constraint(ALLOC_IN_RC(z_memory_ptr_reg));\n-  match(EncodeP reg);\n-  format %{ \"$reg\" %}\n-  interface(REG_INTER)\n-%}\n-\n-operand iRegN2P(iRegN reg) %{\n-  predicate(CompressedOops::base() == nullptr && CompressedOops::shift() == 0 &&\n-            _leaf->as_DecodeN()->in(0) == nullptr);\n-  constraint(ALLOC_IN_RC(z_memory_ptr_reg));\n-  match(DecodeN reg);\n-  format %{ \"$reg\" %}\n-  interface(REG_INTER)\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":119,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -102,0 +102,12 @@\n+operand no_rax_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_no_rax_reg));\n+  match(RegP);\n+  match(rbx_RegP);\n+  match(rsi_RegP);\n+  match(rdi_RegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3605,58 +3605,0 @@\n-operand kReg_K1()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K2()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K3()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K4()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K5()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K6()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K7()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3740,12 +3682,0 @@\n-operand naxRegI() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegI);\n-  match(eCXRegI);\n-  match(eDXRegI);\n-  match(eSIRegI);\n-  match(eDIRegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3839,25 +3769,0 @@\n-operand naxRegP() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegP);\n-  match(eBXRegP);\n-  match(eDXRegP);\n-  match(eCXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand nabxRegP() %{\n-  constraint(ALLOC_IN_RC(nabx_reg));\n-  match(RegP);\n-  match(eCXRegP);\n-  match(eDXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2129,22 +2129,0 @@\n-\/\/ Constant for long shifts\n-operand immI_32()\n-%{\n-  predicate( n->get_int() == 32 );\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for long shifts\n-operand immI_64()\n-%{\n-  predicate( n->get_int() == 64 );\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2305,22 +2283,0 @@\n-\/\/ Long Immediate: the value 10\n-operand immL10()\n-%{\n-  predicate(n->get_long() == 10);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long immediate from 0 to 127.\n-\/\/ Used for a shorter form of long mul by 10.\n-operand immL_127()\n-%{\n-  predicate(0 <= n->get_long() && n->get_long() < 0x80);\n-  match(ConL);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2461,58 +2417,0 @@\n-operand kReg_K1()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K2()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K3()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K4()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K5()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K6()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K7()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n@@ -2666,12 +2564,0 @@\n-operand no_rax_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_no_rax_reg));\n-  match(RegP);\n-  match(rbx_RegP);\n-  match(rsi_RegP);\n-  match(rdi_RegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -2692,11 +2578,0 @@\n-operand no_rax_rbx_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));\n-  match(RegP);\n-  match(rsi_RegP);\n-  match(rdi_RegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":125,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -723,0 +723,4 @@\n+  if (_disable_warnings) {\n+    return true;\n+  }\n+\n@@ -750,0 +754,1 @@\n+  \/\/ x86_32 combine x86.ad and x86_32.ad, the vec*\/legVec* can not be cleaned from IA32\n@@ -754,1 +759,1 @@\n-#elif defined(AMD64)\n+#elif defined(IA32) || defined(AMD64)\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}