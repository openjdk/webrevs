{"files":[{"patch":"@@ -1740,50 +1740,0 @@\n-\/\/ Integer Immediate: the value 1\n-operand immI_1() %{\n-  predicate(n->get_int() == 1);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 2\n-operand immI_2() %{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 3\n-operand immI_3() %{\n-  predicate(n->get_int() == 3);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 4\n-operand immI_4() %{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: the value 8\n-operand immI_8() %{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -1920,21 +1870,0 @@\n-\n-\/\/ Long Immediate: the value FF\n-operand immL_FF() %{\n-  predicate( n->get_long() == 0xFFL );\n-  match(ConL);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate: the value FFFF\n-operand immL_FFFF() %{\n-  predicate( n->get_long() == 0xFFFFL );\n-  match(ConL);\n-  op_cost(0);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -1960,30 +1889,0 @@\n-\/\/ Pointer Immediate\n-operand immN()\n-%{\n-  match(ConN);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immNKlass()\n-%{\n-  match(ConNKlass);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Null Pointer Immediate\n-operand immN0()\n-%{\n-  predicate(n->get_narrowcon() == 0);\n-  match(ConN);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":101,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -504,25 +504,0 @@\n-operand immIRotneg() %{\n-  \/\/ if AsmOperand::is_rotated_imm() is true for this constant, it is\n-  \/\/ a immIRot and an optimal instruction combination exists to handle the\n-  \/\/ constant as an immIRot\n-  predicate(!AsmOperand::is_rotated_imm(n->get_int()) && AsmOperand::is_rotated_imm(-n->get_int()));\n-  match(ConI);\n-\n-  op_cost(0);\n-  \/\/ formats are generated automatically for constants and base registers\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Non-negative integer immediate that is encodable using the rotation scheme,\n-\/\/ and that when expanded fits in 31 bits.\n-operand immU31Rot() %{\n-  predicate((0 <= n->get_int()) && AsmOperand::is_rotated_imm(n->get_int()));\n-  match(ConI);\n-\n-  op_cost(0);\n-  \/\/ formats are generated automatically for constants and base registers\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4391,21 +4391,0 @@\n-operand rarg2RegL() %{\n-  constraint(ALLOC_IN_RC(rarg2_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rarg3RegL() %{\n-  constraint(ALLOC_IN_RC(rarg3_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rarg4RegL() %{\n-  constraint(ALLOC_IN_RC(rarg4_bits64_reg));\n-  match(iRegLdst);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2969,13 +2969,0 @@\n-\/\/ 32 bit offset of pc in thread anchor\n-\n-operand immL_pc_off()\n-%{\n-  predicate(n->get_long() == in_bytes(JavaThread::frame_anchor_offset()) +\n-                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -3189,11 +3176,0 @@\n-\/\/ Long 64 bit Register R28 only\n-operand iRegL_R28()\n-%{\n-  constraint(ALLOC_IN_RC(r28_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3697,16 +3673,0 @@\n-\/\/ RISCV opto stubs need to write to the pc slot in the thread anchor\n-operand thread_anchor_pc(javaThread_RegP reg, immL_pc_off off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2581,18 +2581,0 @@\n-\/\/ Integer Immediate: 6-bit\n-operand uimmI6() %{\n-  predicate(Immediate::is_uimm(n->get_int(), 6));\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Integer Immediate: 5-bit\n-operand uimmI5() %{\n-  predicate(Immediate::is_uimm(n->get_int(), 5));\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2643,9 +2625,0 @@\n-\/\/ Integer Immediate: the value 255\n-operand immI_255() %{\n-  predicate(n->get_int() == 255);\n-  match(ConI);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2756,9 +2729,0 @@\n-\/\/ Unsigned Long Immediate: 8-bit\n-operand uimmL8() %{\n-  predicate(Immediate::is_uimm8(n->get_long()));\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2769,18 +2733,0 @@\n-\/\/ Long Immediate: the value FF\n-operand immL_FF() %{\n-  predicate(n->get_long() == 0xFFL);\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate: the value FFFF\n-operand immL_FFFF() %{\n-  predicate(n->get_long() == 0xFFFFL);\n-  match(ConL);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2861,9 +2807,0 @@\n-\/\/ Pointer Immediate: 32-bit\n-operand immP32() %{\n-  predicate(Immediate::is_uimm32(n->get_ptr()));\n-  match(ConP);\n-  op_cost(1);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -3169,14 +3106,0 @@\n-operand lock_ptr_RegP() %{\n-  constraint(ALLOC_IN_RC(z_lock_ptr_reg));\n-  match(RegP);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rscratch2RegP() %{\n-  constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));\n-  match(RegP);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3297,8 +3220,0 @@\n-\/\/ Condition Code Flag Registers for rules with result tuples\n-operand TD_flagsReg() %{\n-  constraint(ALLOC_IN_RC(z_condition_reg));\n-  match(RegFlags);\n-  format %{ \"CR\" %}\n-  interface(REG_TUPLE_DEST_INTER);\n-%}\n-\n@@ -3312,7 +3227,0 @@\n-operand rscratchRegD() %{\n-  constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));\n-  match(RegD);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3326,7 +3234,0 @@\n-operand rscratchRegF() %{\n-  constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));\n-  match(RegF);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3343,20 +3244,0 @@\n-\/\/ Operands to remove register moves in unscaled mode.\n-\/\/ Match read\/write registers with an EncodeP node if neither shift nor add are required.\n-operand iRegP2N(iRegP reg) %{\n-  predicate(CompressedOops::shift() == 0 && _leaf->as_EncodeP()->in(0) == nullptr);\n-  constraint(ALLOC_IN_RC(z_memory_ptr_reg));\n-  match(EncodeP reg);\n-  format %{ \"$reg\" %}\n-  interface(REG_INTER)\n-%}\n-\n-operand iRegN2P(iRegN reg) %{\n-  predicate(CompressedOops::base() == nullptr && CompressedOops::shift() == 0 &&\n-            _leaf->as_DecodeN()->in(0) == nullptr);\n-  constraint(ALLOC_IN_RC(z_memory_ptr_reg));\n-  match(DecodeN reg);\n-  format %{ \"$reg\" %}\n-  interface(REG_INTER)\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":119,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -3605,58 +3605,0 @@\n-operand kReg_K1()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K2()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K3()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K4()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K5()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K6()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K7()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3740,12 +3682,0 @@\n-operand naxRegI() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegI);\n-  match(eCXRegI);\n-  match(eDXRegI);\n-  match(eSIRegI);\n-  match(eDIRegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3839,25 +3769,0 @@\n-operand naxRegP() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegP);\n-  match(eBXRegP);\n-  match(eDXRegP);\n-  match(eCXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand nabxRegP() %{\n-  constraint(ALLOC_IN_RC(nabx_reg));\n-  match(RegP);\n-  match(eCXRegP);\n-  match(eDXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -750,0 +750,1 @@\n+  \/\/ x86_32 combine x86.ad and x86_32.ad, the vec*\/legVec* can not be cleaned from IA32\n@@ -754,1 +755,1 @@\n-#elif defined(AMD64)\n+#elif defined(IA32) || defined(AMD64)\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}