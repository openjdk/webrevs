{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import sun.nio.ch.IOStatus;\n+\n@@ -32,0 +34,2 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n@@ -70,0 +74,109 @@\n+    private static UnixException catEx(UnixException x, UnixException y) {\n+        assert x != null || y != null;\n+        UnixException ue = y;\n+        if (x != null) {\n+            ue = x;\n+            if (y != null) {\n+                ue.addSuppressed(y);\n+            }\n+        }\n+        return ue;\n+    }\n+\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code ioctl} system call with the\n+     * {@code FICLONE} request code.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    protected int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        int srcFD = 0;\n+        try {\n+            srcFD = open(src, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(src);\n+            return IOStatus.THROWN;\n+        }\n+\n+        int dstFD = 0;\n+        try {\n+            dstFD = open(dst, O_CREAT | O_WRONLY, 0666);\n+        } catch (UnixException x) {\n+            try {\n+                UnixNativeDispatcher.close(srcFD);\n+            } catch (UnixException y) {\n+                catEx(x, y).rethrowAsIOException(src, dst);\n+                return IOStatus.THROWN;\n+            }\n+            x.rethrowAsIOException(dst);\n+            return IOStatus.THROWN;\n+        }\n+\n+        UnixException ioctlEx = null;\n+        int result;\n+        try {\n+            result = ioctl_ficlone(dstFD, srcFD);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case EINVAL:\n+                    result = IOStatus.UNSUPPORTED;\n+                    break;\n+                case EPERM:\n+                    ioctlEx = x;\n+                    result = IOStatus.THROWN;\n+                    break;\n+                default:\n+                    result = IOStatus.UNSUPPORTED_CASE;\n+                    break;\n+            }\n+        }\n+\n+        UnixException ue = ioctlEx;\n+        UnixPath s = null;\n+        UnixPath d = null;\n+\n+        try {\n+            UnixNativeDispatcher.close(dstFD);\n+        } catch (UnixException x) {\n+            ue = catEx(ue, x);\n+            d = dst;\n+        }\n+\n+        \/\/ delete dst to avoid later exception in Java layer\n+        if (result != 0) {\n+            try {\n+                unlink(dst);\n+            } catch (UnixException x) {\n+                ue = catEx(ue, x);\n+                d = dst;\n+            }\n+        }\n+\n+        try {\n+            UnixNativeDispatcher.close(srcFD);\n+        } catch (UnixException x) {\n+            ue = catEx(ue, x);\n+            s = src;\n+        }\n+\n+        if (ue != null) {\n+            if (ioctlEx != null)\n+                throw new IOException(ioctlEx.errorString(), ioctlEx);\n+            else if (s != null && d != null)\n+                ue.rethrowAsIOException(s, d);\n+            else\n+                ue.rethrowAsIOException(s != null ? s : d);\n+            return IOStatus.THROWN;\n+        }\n+\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":114,"deletions":1,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.misc.Blocker;\n+\n@@ -72,0 +74,14 @@\n+    \/**\n+     * int ioctl(int dest_fd, FICLONE, int src_fd);\n+     *\/\n+    static int ioctl_ficlone(int dst, int src) throws UnixException {\n+        long comp = Blocker.begin();\n+        try {\n+            return ioctl_ficlone0(dst, src);\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+    private static native int ioctl_ficlone0(int dst, int src)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include <linux\/fs.h>\n+#include <sys\/ioctl.h>\n@@ -39,0 +41,4 @@\n+#ifndef FICLONE\n+#define FICLONE      1074041865\n+#endif\n+\n@@ -145,0 +151,14 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_ioctl_1ficlone0(JNIEnv* env, jclass this,\n+    jint dst, jint src)\n+{\n+    int ret = ioctl(dst, FICLONE, src);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -34,0 +35,2 @@\n+import static sun.nio.fs.UnixConstants.*;\n+\n@@ -70,0 +73,32 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using the {@code clonefile} system call.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    @Override\n+    protected int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        int flags = followLinks ? 0 : CLONE_NOFOLLOW;\n+        try {\n+            return BsdNativeDispatcher.clonefile(src, dst, flags);\n+        } catch (UnixException x) {\n+            switch (x.errno()) {\n+                case ENOTSUP: \/\/ cloning not supported by filesystem\n+                    return IOStatus.UNSUPPORTED;\n+                case EXDEV:   \/\/ src and dst on different filesystems\n+                case ENOTDIR: \/\/ problematic path parameter(s)\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                default:\n+                    x.rethrowAsIOException(src, dst);\n+                    return IOStatus.THROWN;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -67,0 +67,23 @@\n+    \/**\n+     * int clonefile(const char * src, const char * dst, int flags);\n+     *\/\n+    static int clonefile(UnixPath src, UnixPath dst, int flags)\n+        throws UnixException {\n+        if (src.getFileSystem() == dst.getFileSystem()) {\n+            try (NativeBuffer srcBuffer = copyToNativeBuffer(src);\n+                NativeBuffer dstBuffer = copyToNativeBuffer(dst)) {\n+                long comp = Blocker.begin();\n+                try {\n+                    return clonefile0(srcBuffer.address(), dstBuffer.address(),\n+                                      flags);\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+            }\n+        }\n+\n+        return -1;\n+    }\n+    private static native int clonefile0(long srcAddress, long dstAddress,\n+                                         int flags);\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+#include <sys\/attr.h>\n+#include <sys\/clonefile.h>\n@@ -228,0 +230,16 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_clonefile0(JNIEnv* env, jclass this,\n+    jlong srcAddress, jlong dstAddress, int flags)\n+{\n+    const char* src = (const char*)jlong_to_ptr(srcAddress);\n+    const char* dst = (const char*)jlong_to_ptr(dstAddress);\n+\n+    int ret = clonefile(src, dst, flags);\n+    if (ret != 0) {\n+        throwUnixException(env, errno);\n+        return ret;\n+    }\n+\n+    return 0;\n+}\n+\n@@ -264,1 +282,2 @@\n-    if (setattrlist(path, &attrList, (void*)buf, count*attrsize, options) != 0) {\n+    if (setattrlist(path, &attrList, (void*)buf,\n+        count*attrsize, options) != 0) {\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <sys\/clonefile.h>\n@@ -136,0 +137,8 @@\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_ENOTSUP = ENOTSUP;\n+#endif\n+\n+#ifdef __linux__\n+    static final int PREFIX_EPERM = EPERM;\n+#endif\n+\n@@ -146,1 +155,0 @@\n-    \/\/ flags used with setattrlist\n@@ -148,0 +156,5 @@\n+    \/\/ flags used with clonefile(2)\n+    static final int PREFIX_CLONE_NOFOLLOW = CLONE_NOFOLLOW;\n+    static final int PREFIX_CLONE_NOOWNERCOPY = CLONE_NOOWNERCOPY;\n+\n+    \/\/ flags used with setattrlist\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -265,0 +265,3 @@\n+    \/\/ whether file cloning is supported on this platform\n+    private static volatile boolean cloneFileNotSupported;\n+\n@@ -276,0 +279,12 @@\n+        boolean copied = false;\n+        if (addressToPollForCancel == 0 && !cloneFileNotSupported) {\n+            int res = source.getFileSystem().clone(source, target,\n+                                                   flags.followLinks);\n+            if (res == 0) {\n+                copied = true;\n+            }\n+            if (res == IOStatus.UNSUPPORTED) {\n+                cloneFileNotSupported = true;\n+            }\n+        }\n+\n@@ -288,0 +303,2 @@\n+                           copied ? \/\/ copied == true => target already exists\n+                           O_WRONLY :\n@@ -299,2 +316,1 @@\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n+                if (!copied && !directCopyNotSupported) {\n@@ -715,4 +731,4 @@\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n@@ -739,0 +755,2 @@\n+    private static native void init();\n+\n@@ -741,0 +759,1 @@\n+        init();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import sun.nio.ch.IOStatus;\n@@ -124,0 +125,22 @@\n+    \/**\n+     * Clones the file whose path name is {@code src} to that whose path\n+     * name is {@code dst} using a platform-specific system call.\n+     *\n+     * @implSpec\n+     * The implementation in this class always returns\n+     * {@code IOStatus.UNSUPPORTED}. This method should be overridden\n+     * on platforms which support file cloning.\n+     *\n+     * @param src the path of the source file\n+     * @param dst the path of the destination file (clone)\n+     * @param followLinks whether to follow links\n+     *\n+     * @return 0 on success, IOStatus.UNSUPPORTED_CASE if the call does not work\n+     *         with the given parameters, or IOStatus.UNSUPPORTED if cloning is\n+     *         not supported on this platform\n+     *\/\n+    protected int clone(UnixPath src, UnixPath dst, boolean followLinks)\n+        throws IOException {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -179,1 +179,21 @@\n-    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, count, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                case EINVAL:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include <dlfcn.h>\n@@ -44,0 +45,6 @@\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -58,0 +65,10 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixCopyFile_init\n+    (JNIEnv* env, jclass this)\n+{\n+#if defined(__linux__)\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n+}\n+\n@@ -144,0 +161,26 @@\n+\n+    if (my_copy_file_range_func != NULL) {\n+        do {\n+            RESTARTABLE(my_copy_file_range_func(src, NULL, dst, NULL, count, 0),\n+                                                bytes_sent);\n+            if (bytes_sent < 0) {\n+                switch (errno) {\n+                    case EINVAL:\n+                    case EXDEV:\n+                        \/\/ ignore and try sendfile()\n+                        break;\n+                    default:\n+                        JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                        return IOS_THROWN;\n+                }\n+            }\n+            if (cancel != NULL && *cancel != 0) {\n+                throwUnixException(env, ECANCELED);\n+                return IOS_THROWN;\n+            }\n+        } while (bytes_sent > 0);\n+\n+        if (bytes_sent == 0)\n+            return 0;\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8264744 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}