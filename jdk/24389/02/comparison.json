{"files":[{"patch":"@@ -28,1 +28,1 @@\n-void ICacheStubGenerator::generate_icache_flush(\n+void ICacheStubGenerator::generate_icache_flush(const char* name,\n@@ -34,1 +34,1 @@\n-void ICache::initialize() {}\n+void ICache::initialize(int phase) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n+void ICacheStubGenerator::generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub) {\n","filename":"src\/hotspot\/cpu\/arm\/icache_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n+void ICacheStubGenerator::generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub) {\n","filename":"src\/hotspot\/cpu\/ppc\/icache_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n+void ICacheStubGenerator::generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub) {\n","filename":"src\/hotspot\/cpu\/riscv\/icache_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n+void ICacheStubGenerator::generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub) {\n","filename":"src\/hotspot\/cpu\/s390\/icache_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2066,0 +2066,5 @@\n+void Assembler::serialize() {\n+  assert(VM_Version::supports_serialize(), \"\");\n+  emit_int24(0x0F, 0x01, 0xE8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1284,0 +1284,3 @@\n+  \/\/ Serialize instruction stream\n+  void serialize();\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,0 +194,9 @@\n+                                                                            \\\n+  product(int, X86ICacheSync, -1, DIAGNOSTIC,                               \\\n+             \"Select the X86 ICache sync mechanism: -1 = auto-select; \"     \\\n+             \"0 = none (dangerous); 1 = CLFLUSH loop; 2 = CLFLUSHOPT loop; \"\\\n+             \"3 = CLWB loop; 4 = single CPUID; 5 = single SERIALIZE. \"      \\\n+             \"Explicitly selected mechanism will fail at startup if \"       \\\n+             \"hardware does not support it.\")                               \\\n+             range(-1, 5)                                                   \\\n+                                                                            \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,2 +30,49 @@\n-void ICacheStubGenerator::generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub) {\n-  StubCodeMark mark(this, \"ICache\", \"flush_icache_stub\");\n+void x86_generate_icache_fence(MacroAssembler* _masm) {\n+  switch (X86ICacheSync) {\n+    case 0:\n+      break;\n+    case 1:\n+      __ mfence();\n+      break;\n+    case 2:\n+    case 3:\n+      __ sfence();\n+      break;\n+    case 4:\n+      __ push(rax);\n+      __ push(rbx);\n+      __ push(rcx);\n+      __ push(rdx);\n+      __ xorptr(rax, rax);\n+      __ cpuid();\n+      __ pop(rdx);\n+      __ pop(rcx);\n+      __ pop(rbx);\n+      __ pop(rax);\n+      break;\n+    case 5:\n+      __ serialize();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void x86_generate_icache_flush_insn(MacroAssembler* _masm, Register addr) {\n+  switch (X86ICacheSync) {\n+    case 1:\n+      __ clflush(Address(addr, 0));\n+      break;\n+    case 2:\n+      __ clflushopt(Address(addr, 0));\n+      break;\n+    case 3:\n+      __ clwb(Address(addr, 0));\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ICacheStubGenerator::generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub) {\n+  StubCodeMark mark(this, \"ICache\", name);\n@@ -34,1 +81,0 @@\n-#ifdef AMD64\n@@ -43,1 +89,1 @@\n-  __ jcc(Assembler::zero, done);\n+  __ jccb(Assembler::zero, done);\n@@ -45,3 +91,1 @@\n-  \/\/ Force ordering wrt cflush.\n-  \/\/ Other fence and sync instructions won't do the job.\n-  __ mfence();\n+  x86_generate_icache_fence(_masm);\n@@ -49,5 +93,6 @@\n-  __ bind(flush_line);\n-  __ clflush(Address(addr, 0));\n-  __ addptr(addr, ICache::line_size);\n-  __ decrementl(lines);\n-  __ jcc(Assembler::notZero, flush_line);\n+  if (1 <= X86ICacheSync && X86ICacheSync <= 3) {\n+    __ bind(flush_line);\n+    x86_generate_icache_flush_insn(_masm, addr);\n+    __ addptr(addr, ICache::line_size);\n+    __ decrementl(lines);\n+    __ jccb(Assembler::notZero, flush_line);\n@@ -55,1 +100,2 @@\n-  __ mfence();\n+    x86_generate_icache_fence(_masm);\n+  }\n@@ -59,4 +105,0 @@\n-#else\n-  const Address magic(rsp, 3*wordSize);\n-  __ lock(); __ addl(Address(rsp, 0), 0);\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/icache_x86.cpp","additions":59,"deletions":17,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1092,0 +1092,24 @@\n+  assert(supports_cpuid(), \"Always present\");\n+  assert(supports_clflush(), \"Always present\");\n+  if (X86ICacheSync == -1) {\n+    \/\/ Auto-detect, choosing the best performant one that still flushes\n+    \/\/ the cache. We could switch to CPUID\/SERIALIZE (\"4\"\/\"5\") going forward.\n+    if (supports_clwb()) {\n+      FLAG_SET_ERGO(X86ICacheSync, 3);\n+    } else if (supports_clflushopt()) {\n+      FLAG_SET_ERGO(X86ICacheSync, 2);\n+    } else {\n+      FLAG_SET_ERGO(X86ICacheSync, 1);\n+    }\n+  } else {\n+    if ((X86ICacheSync == 2) && !supports_clflushopt()) {\n+      vm_exit_during_initialization(\"CPU does not support CLFLUSHOPT, unable to use X86ICacheSync=2\");\n+    }\n+    if ((X86ICacheSync == 3) && !supports_clwb()) {\n+      vm_exit_during_initialization(\"CPU does not support CLWB, unable to use X86ICacheSync=3\");\n+    }\n+    if ((X86ICacheSync == 5) && !supports_serialize()) {\n+      vm_exit_during_initialization(\"CPU does not support SERIALIZE, unable to use X86ICacheSync=5\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-  ICache::flush_icache_stub_t* flush_icache_stub) {\n+    const char* name,\n+    ICache::flush_icache_stub_t* flush_icache_stub) {\n","filename":"src\/hotspot\/cpu\/zero\/icache_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void initialize() {}\n+  static void initialize(int phase) {}\n","filename":"src\/hotspot\/cpu\/zero\/icache_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void initialize();\n+  static void initialize(int phase);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/icache_bsd_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  static void initialize();\n+  static void initialize(int phase);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  static void initialize();\n+  static void initialize(int phase);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/icache_windows_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+typedef AutoModifyRestore<int>  IntFlagSetting;\n","filename":"src\/hotspot\/share\/runtime\/flags\/flagSetting.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"runtime\/flags\/flagSetting.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -33,1 +36,1 @@\n-void AbstractICache::initialize() {\n+void AbstractICache::initialize(int phase) {\n@@ -37,1 +40,13 @@\n-  BufferBlob* b = BufferBlob::create(\"flush_icache_stub\", ICache::stub_size);\n+  const char* stub_name = nullptr;\n+  switch (phase) {\n+    case 1:\n+      stub_name = \"flush_icache_initial_stub\";\n+      break;\n+    case 2:\n+      stub_name = \"flush_icache_final_stub\";\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  BufferBlob* b = BufferBlob::create(stub_name, ICache::stub_size);\n@@ -39,1 +54,1 @@\n-    vm_exit_out_of_memory(ICache::stub_size, OOM_MALLOC_ERROR, \"CodeCache: no space for flush_icache_stub\");\n+    vm_exit_out_of_memory(ICache::stub_size, OOM_MALLOC_ERROR, \"CodeCache: no space for %s\", stub_name);\n@@ -44,1 +59,1 @@\n-  g.generate_icache_flush(&_flush_icache_stub);\n+  g.generate_icache_flush(stub_name, &_flush_icache_stub);\n@@ -109,1 +124,12 @@\n-  ICache::initialize();\n+  \/\/ Initial stub that runs with most basic mechanism, until optimized\n+  \/\/ final stub is generated.\n+#if defined(X86) && !defined(ZERO)\n+  IntFlagSetting fs(X86ICacheSync, 1);\n+#endif\n+  ICache::initialize(1);\n+}\n+\n+void icache_init2() {\n+  \/\/ Final stub that uses the optimized flush mechanism. Happens after\n+  \/\/ CPU feature detection determines which mechanism is usable.\n+  ICache::initialize(2);\n","filename":"src\/hotspot\/share\/runtime\/icache.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  static void initialize();\n+  static void initialize(int phase);\n@@ -120,1 +120,1 @@\n-  void generate_icache_flush(ICache::flush_icache_stub_t* flush_icache_stub);\n+  void generate_icache_flush(const char* name, ICache::flush_icache_stub_t* flush_icache_stub);\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+void icache_init2();\n@@ -128,0 +129,1 @@\n+  icache_init2();                 \/\/ depends on VM_Version for choosing the mechanism\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/icache.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(ICacheTest, flush_perf) {\n+  \/\/ Warmup infra a little.\n+  {\n+    address p = (address)os::malloc(1024, mtTest);\n+    ICache::invalidate_range(p, 1024);\n+    os::free(p);\n+  }\n+\n+  const int ITERS = 1000;\n+\n+  for (int size = 256; size <= 256*1024; size *= 2) {\n+    address p = (address)os::malloc(size, mtTest);\n+    EXPECT_NOT_NULL(p);\n+\n+    jlong total_flush = 0;\n+    jlong total_readback = 0;\n+    for (int t = 0; t < ITERS; t++) {\n+      \/\/ Force writes to mark cache lines modified.\n+      memset(p, 1, size);\n+\n+      jlong time1 = os::javaTimeNanos();\n+\n+      \/\/ Flush the cache under the memory.\n+      ICache::invalidate_range(p, size);\n+\n+      jlong time2 = os::javaTimeNanos();\n+\n+      \/\/ Read memory back.\n+      EXPECT_NULL(memchr(p, 0, size));\n+\n+      jlong time3 = os::javaTimeNanos();\n+\n+      total_flush += time2 - time1;\n+      total_readback += time3 - time2;\n+    }\n+\n+    tty->print_cr(\"%10d bytes flushed in \" JLONG_FORMAT_W(10) \" ns, read back in \" JLONG_FORMAT_W(10) \" ns\",\n+                  size, total_flush \/ ITERS, total_readback \/ ITERS);\n+\n+    os::free(p);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_icache.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}