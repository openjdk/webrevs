{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -43,1 +45,6 @@\n-    Stream<byte[]> classFiles(Runtime.Version version) throws IOException;\n+    Stream<byte[]> classFiles() throws IOException;\n+\n+    default Stream<ClassModel> classModels() throws IOException {\n+        ClassFile classFile = ClassFile.of();\n+        return classFiles().map(classFile::parse);\n+    }\n@@ -58,1 +65,1 @@\n-        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+        public Stream<byte[]> classFiles() throws IOException {\n@@ -78,1 +85,1 @@\n-    record ClassPathJar(Path path) implements ClassFileSource {\n+    record ClassPathJar(Path path, Runtime.Version version) implements ClassFileSource {\n@@ -85,1 +92,1 @@\n-        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+        public Stream<byte[]> classFiles() throws IOException {\n@@ -112,1 +119,1 @@\n-        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+        public Stream<byte[]> classFiles() throws IOException {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassFileSource.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tools.jnativescan;\n-\n-import com.sun.tools.javac.platform.PlatformDescription;\n-import com.sun.tools.javac.platform.PlatformProvider;\n-\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.StandardLocation;\n-import java.io.IOException;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.constant.ClassDesc;\n-import java.lang.module.ModuleDescriptor;\n-import java.util.*;\n-import java.util.function.BiConsumer;\n-import java.util.stream.Stream;\n-\n-abstract class ClassResolver implements AutoCloseable {\n-\n-    static ClassResolver forClassFileSources(List<ClassFileSource> sources, Runtime.Version version) throws IOException {\n-        Map<ClassDesc, Info> classMap = new HashMap<>();\n-        for (ClassFileSource source : sources) {\n-            try (Stream<byte[]> classFiles = source.classFiles(version)) {\n-                classFiles.forEach(bytes -> {\n-                    ClassModel model = ClassFile.of().parse(bytes);\n-                    ClassDesc desc = model.thisClass().asSymbol();\n-                    classMap.put(desc, new Info(source, model));\n-                });\n-            }\n-        }\n-        return new SimpleClassResolver(classMap);\n-    }\n-\n-    static ClassResolver forSystemModules(Runtime.Version version) {\n-        String platformName = String.valueOf(version.feature());\n-        PlatformProvider platformProvider = ServiceLoader.load(PlatformProvider.class).findFirst().orElseThrow();\n-        PlatformDescription platform;\n-        try {\n-            platform = platformProvider.getPlatform(platformName, null);\n-        } catch (PlatformProvider.PlatformNotSupported e) {\n-            throw new JNativeScanFatalError(\"Release: \" + platformName + \" not supported\", e);\n-        }\n-        JavaFileManager fm = platform.getFileManager();\n-        return new SystemModuleClassResolver(fm);\n-    }\n-\n-    record Info(ClassFileSource source, ClassModel model) {}\n-\n-    public abstract void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action);\n-    public abstract Optional<ClassResolver.Info> lookup(ClassDesc desc);\n-\n-    @Override\n-    public abstract void close() throws IOException;\n-\n-    private static class SimpleClassResolver extends ClassResolver {\n-\n-        private final Map<ClassDesc, ClassResolver.Info> classMap;\n-\n-        public SimpleClassResolver(Map<ClassDesc, Info> classMap) {\n-            this.classMap = classMap;\n-        }\n-\n-        public void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action) {\n-            classMap.forEach(action);\n-        }\n-\n-        public Optional<ClassResolver.Info> lookup(ClassDesc desc) {\n-            return Optional.ofNullable(classMap.get(desc));\n-        }\n-\n-        @Override\n-        public void close() {}\n-    }\n-\n-    private static class SystemModuleClassResolver extends ClassResolver {\n-\n-        private final JavaFileManager platformFileManager;\n-        private final Map<String, String> packageToSystemModule;\n-        private final Map<ClassDesc, Info> cache = new HashMap<>();\n-\n-        public SystemModuleClassResolver(JavaFileManager platformFileManager) {\n-            this.platformFileManager = platformFileManager;\n-            this.packageToSystemModule = packageToSystemModule(platformFileManager);\n-        }\n-\n-        private static Map<String, String> packageToSystemModule(JavaFileManager platformFileManager) {\n-            try {\n-                Set<JavaFileManager.Location> locations = platformFileManager.listLocationsForModules(\n-                        StandardLocation.SYSTEM_MODULES).iterator().next();\n-\n-                Map<String, String> result = new HashMap<>();\n-                for (JavaFileManager.Location loc : locations) {\n-                    JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, \"module-info\", JavaFileObject.Kind.CLASS);\n-                    ModuleDescriptor descriptor = ModuleDescriptor.read(jfo.openInputStream());\n-                    for (ModuleDescriptor.Exports export : descriptor.exports()) {\n-                        if (!export.isQualified()) {\n-                            result.put(export.source(), descriptor.name());\n-                        }\n-                    }\n-                }\n-                return result;\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        @Override\n-        public void forEach(BiConsumer<ClassDesc, Info> action) {\n-            throw new UnsupportedOperationException(\"NYI\");\n-        }\n-\n-        @Override\n-        public Optional<Info> lookup(ClassDesc desc) {\n-            return Optional.ofNullable(cache.computeIfAbsent(desc, _ -> {\n-                String qualName = JNativeScanTask.qualName(desc);\n-                String moduleName = packageToSystemModule.get(desc.packageName());\n-                if (moduleName != null) {\n-                    try {\n-                        JavaFileManager.Location loc = platformFileManager.getLocationForModule(StandardLocation.SYSTEM_MODULES, moduleName);\n-                        JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, qualName, JavaFileObject.Kind.CLASS);\n-                        if (jfo == null) {\n-                            throw new JNativeScanFatalError(\"System class can not be found: \" + qualName);\n-                        }\n-                        ClassModel model = ClassFile.of().parse(jfo.openInputStream().readAllBytes());\n-                        return new Info(null, model);\n-                    } catch (IOException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                return null;\n-            }));\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-            platformFileManager.close();\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -33,1 +34,0 @@\n-import java.net.URI;\n@@ -40,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -79,5 +80,20 @@\n-        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n-        try(ClassResolver classesToScan = ClassResolver.forClassFileSources(toScan, version);\n-            ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n-            NativeMethodFinder finder = NativeMethodFinder.create(diagnostics, classesToScan, systemClassResolver);\n-            allRestrictedMethods = finder.findAll();\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods\n+                = new TreeMap<>(Comparator.comparing(ClassFileSource::path));\n+        try(SystemClassResolver systemClassResolver = SystemClassResolver.forRuntimeVersion(version)) {\n+            NativeMethodFinder finder = NativeMethodFinder.create(diagnostics, systemClassResolver);\n+\n+            for (ClassFileSource source : toScan) {\n+                SortedMap<ClassDesc, List<RestrictedUse>> perClass\n+                        = new TreeMap<>(Comparator.comparing(JNativeScanTask::qualName));\n+                try (Stream<ClassModel> stream = source.classModels()) {\n+                    stream.forEach(classModel -> {\n+                        List<RestrictedUse> restrictedUses = finder.find(classModel);\n+                        if (!restrictedUses.isEmpty()) {\n+                            perClass.put(classModel.thisClass().asSymbol(), restrictedUses);\n+                        }\n+                    });\n+                }\n+                if (!perClass.isEmpty()) {\n+                    allRestrictedMethods.put(source, perClass);\n+                }\n+            }\n@@ -118,1 +134,1 @@\n-                    result.add(new ClassFileSource.ClassPathJar(jar));\n+                    result.add(new ClassFileSource.ClassPathJar(jar, version));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -49,2 +48,1 @@\n-    private final ClassResolver classesToScan;\n-    private final ClassResolver systemClassResolver;\n+    private final SystemClassResolver systemClassResolver;\n@@ -52,1 +50,1 @@\n-    private NativeMethodFinder(Diagnostics diagnostics, ClassResolver classesToScan, ClassResolver systemClassResolver) {\n+    private NativeMethodFinder(Diagnostics diagnostics, SystemClassResolver systemClassResolver) {\n@@ -54,1 +52,0 @@\n-        this.classesToScan = classesToScan;\n@@ -58,3 +55,2 @@\n-    public static NativeMethodFinder create(Diagnostics diagnostics, ClassResolver classesToScan,\n-                                            ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n-        return new NativeMethodFinder(diagnostics, classesToScan, systemClassResolver);\n+    public static NativeMethodFinder create(Diagnostics diagnostics, SystemClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n+        return new NativeMethodFinder(diagnostics, systemClassResolver);\n@@ -63,7 +59,2 @@\n-    public SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n-        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> restrictedMethods\n-                = new TreeMap<>(Comparator.comparing(ClassFileSource::path));\n-        classesToScan.forEach((_, info) -> {\n-            ClassModel classModel = info.model();\n-            List<RestrictedUse> perClass = new ArrayList<>();\n-            classModel.methods().forEach(methodModel -> {\n+    public List<RestrictedUse> find(ClassModel model) throws JNativeScanFatalError {\n+        return model.methods().stream().<RestrictedUse>mapMulti((methodModel, sink) -> {\n@@ -71,1 +62,1 @@\n-                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n+                    sink.accept(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n@@ -73,19 +64,1 @@\n-                    SortedSet<MethodRef> perMethod = new TreeSet<>(Comparator.comparing(MethodRef::toString));\n-                    methodModel.code().ifPresent(code -> {\n-                        code.forEach(e -> {\n-                            switch (e) {\n-                                case InvokeInstruction invoke -> {\n-                                    MethodRef ref = MethodRef.ofInvokeInstruction(invoke);\n-                                    try {\n-                                        if (isRestrictedMethod(ref)) {\n-                                            perMethod.add(ref);\n-                                        }\n-                                    } catch (JNativeScanFatalError ex) {\n-                                        diagnostics.error(MethodRef.ofModel(methodModel), ex);\n-                                    }\n-                                }\n-                                default -> {\n-                                }\n-                            }\n-                        });\n-                    });\n+                    SortedSet<MethodRef> perMethod = findRestrictedMethodInvocations(methodModel);\n@@ -93,1 +66,1 @@\n-                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel), perMethod));\n+                        sink.accept(new RestrictedMethodRefs(MethodRef.ofModel(methodModel), perMethod));\n@@ -96,5 +69,16 @@\n-            });\n-            if (!perClass.isEmpty()) {\n-                restrictedMethods.computeIfAbsent(info.source(),\n-                                _ -> new TreeMap<>(Comparator.comparing(JNativeScanTask::qualName)))\n-                        .put(classModel.thisClass().asSymbol(), perClass);\n+            })\n+            .toList();\n+    }\n+\n+    private SortedSet<MethodRef> findRestrictedMethodInvocations(MethodModel methodModel) {\n+        SortedSet<MethodRef> perMethod = new TreeSet<>(Comparator.comparing(MethodRef::toString));\n+        methodModel.code().ifPresent(code -> code.forEach(e -> {\n+            if (e instanceof InvokeInstruction invoke) {\n+                MethodRef ref = MethodRef.ofInvokeInstruction(invoke);\n+                try {\n+                    if (isRestrictedMethod(ref)) {\n+                        perMethod.add(ref);\n+                    }\n+                } catch (JNativeScanFatalError ex) {\n+                    diagnostics.error(MethodRef.ofModel(methodModel), ex);\n+                }\n@@ -102,2 +86,2 @@\n-        });\n-        return restrictedMethods;\n+        }));\n+        return perMethod;\n@@ -112,2 +96,2 @@\n-            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n-            if (!info.isPresent()) {\n+            Optional<ClassModel> modelOpt = systemClassResolver.lookup(methodRef.owner());\n+            if (!modelOpt.isPresent()) {\n@@ -116,1 +100,1 @@\n-            ClassModel classModel = info.get().model();\n+            ClassModel classModel = modelOpt.get();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/NativeMethodFinder.java","additions":31,"deletions":47,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.javac.platform.PlatformDescription;\n+import com.sun.tools.javac.platform.PlatformProvider;\n+\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.*;\n+\n+class SystemClassResolver implements AutoCloseable {\n+\n+    private final JavaFileManager platformFileManager;\n+    private final Map<String, String> packageToSystemModule;\n+    private final Map<ClassDesc, ClassModel> cache = new HashMap<>();\n+\n+    private SystemClassResolver(JavaFileManager platformFileManager) {\n+        this.platformFileManager = platformFileManager;\n+        this.packageToSystemModule = packageToSystemModule(platformFileManager);\n+    }\n+\n+    public static SystemClassResolver forRuntimeVersion(Runtime.Version version) {\n+        String platformName = String.valueOf(version.feature());\n+        PlatformProvider platformProvider = ServiceLoader.load(PlatformProvider.class).findFirst().orElseThrow();\n+        PlatformDescription platform;\n+        try {\n+            platform = platformProvider.getPlatform(platformName, null);\n+        } catch (PlatformProvider.PlatformNotSupported e) {\n+            throw new JNativeScanFatalError(\"Release: \" + platformName + \" not supported\", e);\n+        }\n+        JavaFileManager fm = platform.getFileManager();\n+        return new SystemClassResolver(fm);\n+    }\n+\n+    private static Map<String, String> packageToSystemModule(JavaFileManager platformFileManager) {\n+        try {\n+            Set<JavaFileManager.Location> locations = platformFileManager.listLocationsForModules(\n+                    StandardLocation.SYSTEM_MODULES).iterator().next();\n+\n+            Map<String, String> result = new HashMap<>();\n+            for (JavaFileManager.Location loc : locations) {\n+                JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, \"module-info\", JavaFileObject.Kind.CLASS);\n+                ModuleDescriptor descriptor = ModuleDescriptor.read(jfo.openInputStream());\n+                for (ModuleDescriptor.Exports export : descriptor.exports()) {\n+                    if (!export.isQualified()) {\n+                        result.put(export.source(), descriptor.name());\n+                    }\n+                }\n+            }\n+            return result;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public Optional<ClassModel> lookup(ClassDesc desc) {\n+        return Optional.ofNullable(cache.computeIfAbsent(desc, _ -> {\n+            String qualName = JNativeScanTask.qualName(desc);\n+            String moduleName = packageToSystemModule.get(desc.packageName());\n+            if (moduleName != null) {\n+                try {\n+                    JavaFileManager.Location loc = platformFileManager.getLocationForModule(StandardLocation.SYSTEM_MODULES, moduleName);\n+                    JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, qualName, JavaFileObject.Kind.CLASS);\n+                    if (jfo == null) {\n+                        throw new JNativeScanFatalError(\"System class can not be found: \" + qualName);\n+                    }\n+                    try (InputStream inputStream = jfo.openInputStream()) {\n+                        return ClassFile.of().parse(inputStream.readAllBytes());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }));\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        platformFileManager.close();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/SystemClassResolver.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}