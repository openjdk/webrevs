{"files":[{"patch":"@@ -49,0 +49,62 @@\n+\n+class DllEntry {\n+  public:\n+  static DllEntry* _dll_list;\n+  static DllEntry* _dll_cursor;\n+\n+  const char* _address;\n+  const char* _dll_name;\n+  DllEntry* _next;\n+\n+  void free() {\n+    if (_next != nullptr) {\n+      _next->free();\n+      ::free(_next);\n+      _next = nullptr;\n+    }\n+    ::free((void*)_dll_name);\n+    _dll_name = nullptr;\n+  }\n+\n+  static DllEntry* build(const char* addr, const char* dll_name) {\n+    DllEntry* e = (DllEntry*)::malloc(sizeof(DllEntry));\n+    assert(e != nullptr, \"malloc failure\");\n+    e->_address = addr;\n+    e->_dll_name = ::strdup(dll_name);\n+    e->_next = nullptr;\n+    return e;\n+  }\n+\n+  \/* append to list in sorted order, return first element of list *\/\n+  DllEntry* append(DllEntry* entry) {\n+    DllEntry* first = this;\n+    if (entry->_address < _address) {\n+      entry->_next = this;\n+      first = entry;\n+    } else if (_next == nullptr) {\n+      _next = entry;\n+    } else {\n+      _next = _next->append(entry);\n+    }\n+    return first;\n+  }\n+\n+  static int dll_cb(const char *dll_name, address low, address high, void* param) {\n+    DllEntry* entry = build((const char*)low, dll_name);\n+    if (_dll_list == nullptr) {\n+      _dll_list = entry;\n+    } else {\n+      _dll_list = _dll_list->append(entry);\n+    }\n+    return 0;\n+  };\n+\n+  static void add_all_dlls() {\n+    os::get_loaded_modules_info(dll_cb, nullptr);\n+    _dll_cursor = _dll_list;\n+  }\n+};\n+\n+DllEntry* DllEntry::_dll_list = nullptr;\n+DllEntry* DllEntry::_dll_cursor = nullptr;\n+\n@@ -61,1 +123,1 @@\n-  void process(const proc_regionwithpathinfo& mem_info) {\n+  void reset() {\n@@ -67,0 +129,4 @@\n+  }\n+\n+  void process(const proc_regionwithpathinfo& mem_info) {\n+    reset();\n@@ -119,1 +185,2 @@\n-#define X1(TAG) case VM_MEMORY_ ## TAG: return # TAG;\n+#define X1(TAG, DESCR) X2(TAG, DESCR)\n+\/\/#define X1(TAG) case VM_MEMORY_ ## TAG: return # TAG;\n@@ -125,20 +192,20 @@\n-      X1(MALLOC);\n-      X1(MALLOC_SMALL);\n-      X1(MALLOC_LARGE);\n-      X1(MALLOC_HUGE);\n-      X1(SBRK);\n-      X1(REALLOC);\n-      X1(MALLOC_TINY);\n-      X1(MALLOC_LARGE_REUSABLE);\n-      X1(MALLOC_LARGE_REUSED);\n-      X1(ANALYSIS_TOOL);\n-      X1(MALLOC_NANO);\n-      X1(MALLOC_MEDIUM);\n-      X1(MALLOC_PROB_GUARD);\n-      X1(MACH_MSG);\n-      X1(IOKIT);\n-      X1(STACK);\n-      X1(GUARD);\n-      X1(SHARED_PMAP);\n-      X1(DYLIB);\n-      X1(UNSHARED_PMAP);\n+      X1(MALLOC, malloc);\n+      X1(MALLOC_SMALL, malloc_small);\n+      X1(MALLOC_LARGE, malloc_large);\n+      X1(MALLOC_HUGE, malloc_huge);\n+      X1(SBRK, sbrk);\n+      X1(REALLOC, realloc);\n+      X1(MALLOC_TINY, malloc_tiny);\n+      X1(MALLOC_LARGE_REUSABLE, malloc_large_reusable);\n+      X1(MALLOC_LARGE_REUSED, malloc_lage_reused);\n+      X1(ANALYSIS_TOOL, analysis_tool);\n+      X1(MALLOC_NANO, malloc_nano);\n+      X1(MALLOC_MEDIUM, malloc_medium);\n+      X1(MALLOC_PROB_GUARD, malloc_prob_guard);\n+      X1(MACH_MSG, malloc_msg);\n+      X1(IOKIT, IOKit);\n+      X1(STACK, stack);\n+      X1(GUARD, guard);\n+      X1(SHARED_PMAP, shared_pmap);\n+      X1(DYLIB, dylib);\n+      X1(UNSHARED_PMAP, unshared_pmap);\n@@ -151,9 +218,9 @@\n-      X1(COREDATA_OBJECTIDS);\n-      X1(ATS);\n-      X1(DYLD);\n-      X1(DYLD_MALLOC);\n-      X1(SQLITE);\n-      X1(JAVASCRIPT_CORE);\n-      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR);\n-      X1(JAVASCRIPT_JIT_REGISTER_FILE);\n-      X1(OPENCL);\n+      X1(COREDATA_OBJECTIDS, CodeData_objectids);\n+      X1(ATS, ats);\n+      X1(DYLD, dyld);\n+      X1(DYLD_MALLOC, dyld_malloc);\n+      X1(SQLITE, sqlite);\n+      X1(JAVASCRIPT_CORE, javascript_core);\n+      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR, javascript_jit_executable_allocator);\n+      X1(JAVASCRIPT_JIT_REGISTER_FILE, javascript_jit_register_file);\n+      X1(OPENCL, OpenCL);\n@@ -163,4 +230,4 @@\n-      X1(APPLICATION_SPECIFIC_1);\n-      X1(APPLICATION_SPECIFIC_16);\n-      X1(OS_ALLOC_ONCE);\n-      X1(GENEALOGY);\n+      X1(APPLICATION_SPECIFIC_1, application_specific_1);\n+      X1(APPLICATION_SPECIFIC_16, application_specific_16);\n+      X1(OS_ALLOC_ONCE, os_alloc_once);\n+      X1(GENEALOGY, genealogy);\n@@ -261,1 +328,17 @@\n-  #undef INDENT_BY\n+\/*\n+    st->print(\" bh=%d \", region_info.pri_behavior);\n+    st->print(\"fl=%d \", region_info.pri_flags);\n+    st->print(\"uwc=%d \", region_info.pri_user_wired_count);\n+    st->print(\"ut=%d \", region_info.pri_user_tag);\n+    st->print(\"pr=%d \", region_info.pri_pages_resident);\n+    st->print(\"snp=%d \", region_info.pri_pages_shared_now_private);\n+    st->print(\"inh=%d \", region_info.pri_inheritance);\n+    st->print(\"swo=%d \", region_info.pri_pages_swapped_out);\n+    st->print(\"pd=%d \", region_info.pri_pages_dirtied);\n+    st->print(\"rc=%d \", region_info.pri_ref_count);\n+    st->print(\"sd=%d \", region_info.pri_shadow_depth);\n+    st->print(\"sm=%d \", region_info.pri_share_mode);\n+    st->print(\"ppr=%d \", region_info.pri_private_pages_resident);\n+    st->print(\"spr=%d \", region_info.pri_shared_pages_resident);\n+    st->print(\"dep=%d \", region_info.pri_depth);\n+    \/\/*\/\n@@ -263,0 +346,17 @@\n+\n+    if (mapping_info._file_name.count() == 0) {\n+      for (; DllEntry::_dll_cursor != nullptr; DllEntry::_dll_cursor = DllEntry::_dll_cursor->_next) {\n+        DllEntry* e = DllEntry::_dll_cursor;\n+        if ((uint64_t)(e->_address) < region_info.pri_address) {\n+          continue;\n+        }\n+        if ((uint64_t)(e->_address) >= (region_info.pri_address + region_info.pri_size)) {\n+          break;\n+        }\n+        INDENT_BY(5);\n+        st->print(PTR_FORMAT, (size_t)(e->_address));\n+        INDENT_BY(73);\n+        st->print_cr(\"%s\", e->_dll_name);\n+      }\n+    }\n+#undef INDENT_BY\n@@ -309,0 +409,2 @@\n+  DllEntry::add_all_dlls();\n+\n@@ -325,1 +427,1 @@\n-    if (region_info.prp_prinfo.pri_share_mode != SM_EMPTY) {\n+    if (region_info.prp_prinfo.pri_share_mode != SM_EMPTY || region_info.prp_prinfo.pri_user_tag != 0) {\n@@ -336,0 +438,4 @@\n+\n+  \/* free any held resources *\/\n+  DllEntry::_dll_list->free();\n+  ::free(DllEntry::_dll_list);\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":143,"deletions":37,"binary":false,"changes":180,"status":"modified"}]}