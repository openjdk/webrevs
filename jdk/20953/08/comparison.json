{"files":[{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#if defined(__APPLE__)\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <libproc.h>\n+#include <unistd.h>\n+\n+#include <mach\/vm_inherit.h>\n+#include <mach\/vm_prot.h>\n+#include <mach\/mach_vm.h>\n+\n+\/* maximum number of mapping records returned *\/\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n+\n+class DllEntry {\n+  public:\n+\n+  const char* _address;\n+  const char* _dll_name;\n+  DllEntry* _next;\n+\n+  void free() {\n+    if (_next != nullptr) {\n+      _next->free();\n+      ::free(_next);\n+      _next = nullptr;\n+    }\n+    ::free((void*)_dll_name);\n+    _dll_name = nullptr;\n+  }\n+\n+  static DllEntry* build(const char* addr, const char* dll_name) {\n+    DllEntry* e = (DllEntry*)::malloc(sizeof(DllEntry));\n+    assert(e != nullptr, \"malloc failure\");\n+    assert(dll_name != nullptr, \"null dll name\");\n+    e->_address = addr;\n+    e->_dll_name = ::strdup(dll_name);\n+    e->_next = nullptr;\n+    return e;\n+  }\n+\n+  \/* append to list in sorted order, return first element of list *\/\n+  DllEntry* append(DllEntry* entry) {\n+    DllEntry* first = this;\n+    if (entry->_address < _address) {\n+      entry->_next = this;\n+      first = entry;\n+    } else if (_next == nullptr) {\n+      _next = entry;\n+    } else {\n+      _next = _next->append(entry);\n+    }\n+    return first;\n+  }\n+};\n+\n+class DllList {\n+  DllEntry* _dll_list;\n+  DllEntry* _dll_cursor;\n+\n+  public:\n+\n+  DllList() : _dll_list(nullptr), _dll_cursor(nullptr) {}\n+  ~DllList() {\n+    \/* free any held resources *\/\n+    if (_dll_list != nullptr) {\n+      _dll_list->free();\n+      ::free(_dll_list);\n+    }\n+  }\n+\n+  DllEntry* cursor_rewind() {\n+    _dll_cursor = _dll_list;\n+    return _dll_cursor;\n+  }\n+\n+  DllEntry* cursor_current() {\n+    return _dll_cursor;\n+  }\n+\n+  DllEntry* cursor_next() {\n+    if (_dll_cursor != nullptr) {\n+      _dll_cursor = _dll_cursor->_next;\n+    }\n+    return _dll_cursor;\n+  }\n+\n+  void append(DllEntry* entry) {\n+    if (_dll_list == nullptr) {\n+      _dll_list = entry;\n+    } else {\n+      _dll_list = _dll_list->append(entry);\n+    }\n+  }\n+\n+  static int dll_cb(const char *dll_name, address low, address high, void* param) {\n+    DllList* list = (DllList*)(param);\n+    DllEntry* entry = DllEntry::build((const char*)low, dll_name);\n+    list->append(entry);\n+    return 0;\n+  };\n+\n+  void add_all_dlls() {\n+    os::get_loaded_modules_info(dll_cb, this);\n+    cursor_rewind();\n+  }\n+};\n+\n+DllList dll_list;\n+\n+class MappingInfo {\n+public:\n+  const char* _address;\n+  size_t _size;\n+  stringStream _share_buffer;\n+  stringStream _type_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _file_name;\n+  const char* _tag_text;\n+\n+  MappingInfo() {}\n+\n+  void reset() {\n+    _share_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    _file_name.reset();\n+    _tag_text = \"\";\n+  }\n+\n+  void process(const proc_regionwithpathinfo& mem_info) {\n+    reset();\n+\n+    const proc_regioninfo& rinfo = mem_info.prp_prinfo;\n+\n+    _address = (const char*) rinfo.pri_address;\n+    _size = rinfo.pri_size;\n+\n+    const char* path = mem_info.prp_vip.vip_path;\n+    if (path != nullptr) {\n+      _file_name.print_raw(path);\n+    } else {\n+      char buf[PATH_MAX];\n+      buf[0] = '\\0';\n+      proc_regionfilename(getpid(), (uint64_t) _address, buf, sizeof(buf));\n+      if (buf[0] != 0) {\n+        buf[sizeof(buf) - 1] = '\\0';\n+        _file_name.print_raw(\"-> \");\n+        _file_name.print_raw(buf);\n+      }\n+    }\n+\n+    char prot[4];\n+    rwbits(rinfo.pri_protection, prot);\n+    _protect_buffer.print(\"%s\", prot);\n+\n+    get_share_mode(_share_buffer, rinfo);\n+    _tag_text = tagToStr(rinfo.pri_user_tag);\n+  }\n+\n+  static void get_share_mode(outputStream& out, const proc_regioninfo& rinfo) {\n+    static const char* share_strings[] = {\n+      \"cow\", \"pvt\", \"---\", \"shr\", \"tsh\", \"p\/a\", \"s\/a\", \"lpg\"\n+    };\n+    const bool valid_share_mode = rinfo.pri_share_mode >= SM_COW && rinfo.pri_share_mode <= SM_LARGE_PAGE;\n+    if (valid_share_mode) {\n+      int share_mode = rinfo.pri_share_mode;\n+      out.print_raw(share_strings[share_mode - 1]);\n+    } else {\n+      out.print_cr(\"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+      assert(valid_share_mode, \"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+    }\n+    if (rinfo.pri_flags & PROC_REGION_SHARED) {\n+        out.print_raw(\"-shared\");\n+    }\n+    if (rinfo.pri_flags & PROC_REGION_SUBMAP) {\n+        out.print_raw(\"-submap\");\n+    }\n+    if ((rinfo.pri_flags & (PROC_REGION_SHARED | PROC_REGION_SUBMAP)) != rinfo.pri_flags) {\n+      out.print_cr(\"unhandled pri_flags = 0x%x\", rinfo.pri_flags);\n+      assert(false, \"unhandled pri_flags = 0x%x\", rinfo.pri_flags);\n+    }\n+  }\n+\n+#define X1(TAG, DESCR) X2(TAG, DESCR)\n+\/\/#define X1(TAG) case VM_MEMORY_ ## TAG: return # TAG;\n+#define X2(TAG, DESCRIPTION) case VM_MEMORY_ ## TAG: return # DESCRIPTION;\n+  static const char* tagToStr(uint32_t user_tag) {\n+    switch (user_tag) {\n+      case 0:\n+        return 0;\n+      X1(MALLOC, malloc);\n+      X1(MALLOC_SMALL, malloc_small);\n+      X1(MALLOC_LARGE, malloc_large);\n+      X1(MALLOC_HUGE, malloc_huge);\n+      X1(SBRK, sbrk);\n+      X1(REALLOC, realloc);\n+      X1(MALLOC_TINY, malloc_tiny);\n+      X1(MALLOC_LARGE_REUSABLE, malloc_large_reusable);\n+      X1(MALLOC_LARGE_REUSED, malloc_lage_reused);\n+      X1(ANALYSIS_TOOL, analysis_tool);\n+      X1(MALLOC_NANO, malloc_nano);\n+      X1(MALLOC_MEDIUM, malloc_medium);\n+      X1(MALLOC_PROB_GUARD, malloc_prob_guard);\n+      X1(MACH_MSG, malloc_msg);\n+      X1(IOKIT, IOKit);\n+      X1(STACK, stack);\n+      X1(GUARD, guard);\n+      X1(SHARED_PMAP, shared_pmap);\n+      X1(DYLIB, dylib);\n+      X1(UNSHARED_PMAP, unshared_pmap);\n+      X2(APPKIT, AppKit);\n+      X2(FOUNDATION, Foundation);\n+      X2(COREGRAPHICS, CoreGraphics);\n+      X2(CORESERVICES, CoreServices); \/* is also VM_MEMORY_CARBON *\/\n+      X2(JAVA, Java);\n+      X2(COREDATA, CoreData);\n+      X1(COREDATA_OBJECTIDS, CodeData_objectids);\n+      X1(ATS, ats);\n+      X1(DYLD, dyld);\n+      X1(DYLD_MALLOC, dyld_malloc);\n+      X1(SQLITE, sqlite);\n+      X1(JAVASCRIPT_CORE, javascript_core);\n+      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR, javascript_jit_executable_allocator);\n+      X1(JAVASCRIPT_JIT_REGISTER_FILE, javascript_jit_register_file);\n+      X1(OPENCL, OpenCL);\n+      X2(COREIMAGE, CoreImage);\n+      X2(IMAGEIO, ImageIO);\n+      X2(COREPROFILE, CoreProfile);\n+      X1(APPLICATION_SPECIFIC_1, application_specific_1);\n+      X1(APPLICATION_SPECIFIC_16, application_specific_16);\n+      X1(OS_ALLOC_ONCE, os_alloc_once);\n+      X1(GENEALOGY, genealogy);\n+      default:\n+        static char buffer[30];\n+        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        return buffer;\n+    }\n+  }\n+\n+  static void rwbits(int rw, char bits[4]) {\n+    bits[0] = rw & VM_PROT_READ ? 'r' : '-';\n+    bits[1] = rw & VM_PROT_WRITE ? 'w' : '-';\n+    bits[2] = rw & VM_PROT_EXECUTE ? 'x' : '-';\n+    bits[3] = 0;\n+  }\n+};\n+\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _private;\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _private(0),\n+                       _committed(0), _shared(0), _swapped_out(0) {}\n+\n+  void add_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) {\n+    _num_mappings++;\n+\n+    bool is_private = region_info.pri_share_mode == SM_PRIVATE\n+                   || region_info.pri_share_mode == SM_PRIVATE_ALIASED;\n+    bool is_shared = region_info.pri_share_mode == SM_SHARED\n+                   || region_info.pri_share_mode == SM_SHARED_ALIASED\n+                   || region_info.pri_share_mode == SM_TRUESHARED\n+                   || region_info.pri_share_mode == SM_COW;\n+    _private += is_private ? region_info.pri_size : 0;\n+    _shared += is_shared ? region_info.pri_size : 0;\n+    _swapped_out += region_info.pri_pages_swapped_out;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+\n+    task_vm_info vm_info;\n+    mach_msg_type_number_t num_out = TASK_VM_INFO_COUNT;\n+    kern_return_t err = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&vm_info), &num_out);\n+    if (err == KERN_SUCCESS) {\n+      st->print_cr(\"             vsize: %llu (%llu%s)\", vm_info.virtual_size, PROPERFMTARGS(vm_info.virtual_size));\n+      st->print_cr(\"               rss: %llu (%llu%s)\", vm_info.resident_size, PROPERFMTARGS(vm_info.resident_size));\n+      st->print_cr(\"          peak rss: %llu (%llu%s)\", vm_info.resident_size_peak, PROPERFMTARGS(vm_info.resident_size_peak));\n+      st->print_cr(\"         page size: %d (%ld%s)\", vm_info.page_size, PROPERFMTARGS((size_t)vm_info.page_size));\n+    } else {\n+      st->print_cr(\"error getting vm_info %d\", err);\n+    }\n+    st->print_cr(\"           private: %zu (\" PROPERFMT \")\", _private, PROPERFMTARGS(_private));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out * vm_info.page_size, PROPERFMTARGS(_swapped_out * vm_info.page_size));\n+  }\n+};\n+\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) const {\n+     outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(\"%#014.12llx-%#014.11llx\", (uint64_t)(mapping_info._address), (uint64_t)(mapping_info._address + mapping_info._size));\n+    INDENT_BY(38);\n+    st->print(\"%12ld\", mapping_info._size);\n+    INDENT_BY(51);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n+    INDENT_BY(56);\n+    st->print(\"%s\", mapping_info._share_buffer.base());\n+    st->print(\"%s\", mapping_info._type_buffer.base());\n+    INDENT_BY(61);\n+    st->print(\"%#11llx\", region_info.pri_offset);\n+    INDENT_BY(73);\n+    if (_session.print_nmt_info_for_region((const void*)mapping_info._address, (const void*)(mapping_info._address + mapping_info._size))) {\n+      st->print(\" \");\n+    } else {\n+      const char* tag = mapping_info._tag_text;\n+      if (tag != NULL) {\n+        st->print(\"[%s] \", tag);\n+      }\n+    }\n+    st->print_raw(mapping_info._file_name.base());\n+\/*\n+    st->print(\" bh=%d \", region_info.pri_behavior);\n+    st->print(\"fl=%d \", region_info.pri_flags);\n+    st->print(\"uwc=%d \", region_info.pri_user_wired_count);\n+    st->print(\"ut=%d \", region_info.pri_user_tag);\n+    st->print(\"pr=%d \", region_info.pri_pages_resident);\n+    st->print(\"snp=%d \", region_info.pri_pages_shared_now_private);\n+    st->print(\"inh=%d \", region_info.pri_inheritance);\n+    st->print(\"swo=%d \", region_info.pri_pages_swapped_out);\n+    st->print(\"pd=%d \", region_info.pri_pages_dirtied);\n+    st->print(\"rc=%d \", region_info.pri_ref_count);\n+    st->print(\"sd=%d \", region_info.pri_shadow_depth);\n+    st->print(\"sm=%d \", region_info.pri_share_mode);\n+    st->print(\"ppr=%d \", region_info.pri_private_pages_resident);\n+    st->print(\"spr=%d \", region_info.pri_shared_pages_resident);\n+    st->print(\"dep=%d \", region_info.pri_depth);\n+    \/\/*\/\n+    st->cr();\n+\n+  \/*\n+   * regarding the 'cursor':\n+   * The dll_list is sorted by ascending start address,\n+   * and the macOS region_info is also returned in ascending start address.\n+   * When printing out a region_info, we skip ahead in the dll_list until we find\n+   * dlls within the region, and print them out.  \n+   * Then we leave the cursor pointing to the first dll above the current region.\n+   * We do not print out any dll info for regions with an associated file_name,\n+   * as that would be redundant.\n+   *\/\n+    if (mapping_info._file_name.count() == 0) {\n+      for (; dll_list.cursor_current() != nullptr; dll_list.cursor_next()) {\n+        DllEntry* e = dll_list.cursor_current();\n+        if ((uint64_t)(e->_address) < region_info.pri_address) {\n+          continue;\n+        }\n+        if ((uint64_t)(e->_address) >= (region_info.pri_address + region_info.pri_size)) {\n+          break;\n+        }\n+        INDENT_BY(5);\n+        st->print(\"%#014.12llx\", (uint64_t)(e->_address));\n+        INDENT_BY(73);\n+        st->print_cr(\"%s\", e->_dll_name);\n+      }\n+    }\n+#undef INDENT_BY\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"           rwx: read \/ write \/ execute\");\n+    st->print_cr(\"share:   share mode:\");\n+    st->print_cr(\"           cow: copy on write\");\n+    st->print_cr(\"           pvt: private\");\n+    st->print_cr(\"           shr: shared\");\n+    st->print_cr(\"           tsh: true shared\");\n+    st->print_cr(\"           p\/a: private aliased\");\n+    st->print_cr(\"           s\/a: shared aliased\");\n+    st->print_cr(\"           lpg: large page\");\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x00000001714a0000-0x000000017169c000      2080768 rw-\/rwx  p\/a       0xc000 STACK-28419-C2-CompilerThread0\n+    st->print_cr(\"from               to                        vsize prot share     offset vminfo\/file\");\n+    st->print_cr(\"==================================================================================================\");\n+  }\n+};\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+  outputStream* const st = session.out();\n+  const pid_t pid = getpid();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  dll_list.add_all_dlls();\n+\n+  proc_regionwithpathinfo region_info;\n+  MappingInfo mapping_info;\n+  uint64_t address = 0;\n+  int region_count = 0;\n+  while (true) {\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n+    }\n+    int retval = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, (uint64_t)address, &region_info, sizeof(region_info));\n+    if (retval <= 0) {\n+      break;\n+    } else if (retval < (int)sizeof(region_info)) {\n+      st->print_cr(\"proc_pidinfo() returned %d\", retval);\n+      assert(false, \"proc_pidinfo() returned %d\", retval);\n+    }\n+    if (region_info.prp_prinfo.pri_share_mode != SM_EMPTY || region_info.prp_prinfo.pri_user_tag != 0) {\n+      mapping_info.process(region_info);\n+      printer.print_single_mapping(region_info.prp_prinfo, mapping_info);\n+      summary.add_mapping(region_info.prp_prinfo, mapping_info);\n+    }\n+    assert(region_info.prp_prinfo.pri_size > 0, \"size of region is 0\");\n+    address = region_info.prp_prinfo.pri_address + region_info.prp_prinfo.pri_size;\n+  }\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n+}\n+#endif \/\/ __APPLE__\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -200,0 +200,2 @@\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n@@ -201,1 +203,0 @@\n-    st->print_cr(\"vm info: VM information (requires NMT)\");\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -145,1 +145,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX or WINDOWS or MacOS\n@@ -1177,1 +1177,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -991,1 +991,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux, Windows and MacOS only).\";\n@@ -1009,1 +1009,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux, Windows and MacOS only).\";\n@@ -1020,1 +1020,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX, WINDOWS or MACOS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,25 +36,0 @@\n-    private static final String prot = \"[rwsxp-]+\";\n-\n-    private static final String regexBase = range + space +\n-            someSize + space +\n-            prot + space +\n-            someSize + space +\n-            someSize + space +\n-            pagesize + space;\n-\n-    private static final String regexBase_committed = regexBase + \"com.*\";\n-    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n-\n-    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n-    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n-\n-    private static final String shouldMatchUnconditionally_linux[] = {\n-        \/\/ java launcher\n-        regexBase_committed + \"\/bin\/java\",\n-        \/\/ libjvm\n-        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n-        \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n-        regexBase_committed + \"\\\\[heap\\\\]\",\n-        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n-        regexBase_shared_and_committed + \"hsperfdata_.*\"\n-    };\n@@ -62,10 +37,3 @@\n-    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n-        regexBase_java_heap + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        regexBase_committed + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        regexBase + \"-\" + space + \"META.*\",\n-        \/\/ code cache\n-        regexBase_committed + \"CODE.*\",\n-        \/\/ Main thread stack\n-        regexBase_committed + \"STACK.*main.*\"\n+    interface MapPatterns {\n+        String[] shouldMatchUnconditionally();\n+        String[] shouldMatchIfNMTIsEnabled();\n@@ -74,3 +42,1 @@\n-    \/\/ windows:\n-    private static final String winprot = \"[\\\\-rwxcin]*\";\n-    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+    private final MapPatterns patternProvider;\n@@ -78,1 +44,2 @@\n-    private static final String winbase = range + space + someSize + space + winprot + space;\n+    private static final boolean isWindows = Platform.isWindows();\n+    private static final boolean isMacOS = Platform.isOSX();\n@@ -80,3 +47,3 @@\n-    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n-    private static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n-    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+    protected String[] shouldMatchUnconditionally() {\n+        return patternProvider.shouldMatchUnconditionally();\n+    }\n@@ -84,6 +51,3 @@\n-    private static final String shouldMatchUnconditionally_windows[] = {\n-        \/\/ java launcher\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n-        \/\/ libjvm\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n-    };\n+    protected String[] shouldMatchIfNMTIsEnabled() {\n+        return patternProvider.shouldMatchIfNMTIsEnabled();\n+    }\n@@ -91,11 +55,9 @@\n-    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n-        wincommitted + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        wincommitted + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        winreserved + \"META.*\",\n-        \/\/ code cache\n-        wincommitted + \"CODE.*\",\n-        \/\/ Main thread stack\n-        wincommitted + \"STACK-\\\\d+-main.*\"\n-    };\n+    protected SystemMapTestBase() {\n+        if (Platform.isWindows()) {\n+            patternProvider = new WindowsPatterns();\n+        } else if (Platform.isOSX()) {\n+            patternProvider = new MacOSPatterns();\n+        } else {\n+            patternProvider = new LinuxPatterns();\n+        }\n+    }\n@@ -103,1 +65,48 @@\n-    private static final boolean isWindows = Platform.isWindows();\n+    private static class LinuxPatterns implements MapPatterns {\n+\n+        private static final String prot = \"[rwsxp-]+\";\n+\n+        static final String regexBase = range + space +\n+                                        someSize + space +\n+                                        prot + space +\n+                                        someSize + space +\n+                                        someSize + space +\n+                                        pagesize + space;\n+\n+        static final String regexBase_committed = regexBase + \"com.*\";\n+        static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+        \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+        static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+\n+        static final String shouldMatchUnconditionally_linux[] = {\n+            \/\/ java launcher\n+            regexBase_committed + \"\/bin\/java\",\n+            \/\/ libjvm\n+            regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+            \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n+            regexBase_committed + \"\\\\[heap\\\\]\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            regexBase_shared_and_committed + \"hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_linux[] = {\n+            regexBase_java_heap + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            regexBase_committed + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            regexBase + \"-\" + space + \"META.*\",\n+            \/\/ code cache\n+            regexBase_committed + \"CODE.*\",\n+            \/\/ Main thread stack\n+            regexBase_committed + \"STACK.*main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_linux;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_linux;\n+        }\n+    };\n@@ -105,6 +114,38 @@\n-    protected static String[] shouldMatchUnconditionally() {\n-        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n-    }\n-    protected static String[] shouldMatchIfNMTIsEnabled() {\n-        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n-    }\n+    private static class WindowsPatterns implements MapPatterns {\n+\n+        static final String winprot = \"[\\\\-rwxcin]*\";\n+        static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+        static final String winbase = range + space + someSize + space + winprot + space;\n+\n+        static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+        static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n+        static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+        static final String shouldMatchUnconditionally_windows[] = {\n+            \/\/ java launcher\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+            \/\/ libjvm\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+            wincommitted + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            wincommitted + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            winreserved + \"META.*\",\n+            \/\/ code cache\n+            wincommitted + \"CODE.*\",\n+            \/\/ Main thread stack\n+            wincommitted + \"STACK-\\\\d+-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_windows;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_windows;\n+        }\n+    };\n@@ -112,0 +153,40 @@\n+    private static class MacOSPatterns implements MapPatterns {\n+\n+        \/\/ macOS:\n+        static final String macprot =  \"[\\\\-rwx]*\";\n+\n+        static final String macow = \"cow\";\n+        static final String macprivate = \"pvt\";\n+        static final String macprivate_or_shared = \"(pvt|tsh-shared)\";\n+        static final String macprivatealiased = \"p\/a\";\n+\n+        static final String macOSbase = range + space + someSize + space + macprot + space;\n+\n+        static final String shouldMatchUnconditionally_macOS[] = {\n+            \/\/ java launcher\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/bin\/java\",\n+            \/\/ libjvm\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/lib\/server\/libjvm.dylib\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            macOSbase + macprivate + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_macOS[] = {\n+            \/\/ heap is private with G1GC, shared with ZGC\n+            macOSbase + macprivate_or_shared + space + someNumber + space + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            macOSbase + macprivate + space + someNumber + space + \"META.*\",\n+            \/\/ code cache\n+            macOSbase + macprivate + space + someNumber + space + \"CODE.*\",\n+            \/\/ Main thread stack\n+            macOSbase + macprivatealiased + space + someNumber + space + \"STACK-.*-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_macOS;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_macOS;\n+        }\n+    };\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":147,"deletions":66,"binary":false,"changes":213,"status":"modified"}]}