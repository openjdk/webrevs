{"files":[{"patch":"@@ -46,1 +46,1 @@\n-\/* maximum number of mapping records returned *\/\n+\/\/ maximum number of mapping records returned\n@@ -49,6 +49,5 @@\n-\/* \n- * ::mmap() on MacOS is a layer ontop of Mach system calls, and will allocate in 128MB chunks.\n- * This code will coalesce a series of identical 128GB chunks (maybe followed by one smaller chunk\n- * with identical flags) into one.\n- *\/\n-\n+\/\/ ::mmap() on MacOS is a layer on top of Mach system calls, and will allocate in 128MB chunks.\n+\/\/ This code will coalesce a series of identical 128GB chunks (maybe followed by one smaller chunk\n+\/\/ with identical flags) into one.\n+\/\/ Unfortunately, two or more identically allocated contiguous sections will appear as one, if the\n+\/\/ first section is size 128MB.  vmmap(1) has the same issue.\n@@ -105,1 +104,1 @@\n-    \/* proc_regionfilename() seems to give bad results, so we don't try to use it here. *\/\n+    \/\/ proc_regionfilename() seems to give bad results, so we don't try to use it here.\n@@ -121,1 +120,1 @@\n-    assert(SM_COW == 1 && SM_LARGE_PAGE == 8, \"share_mode contants are out of range\");\n+    assert(SM_COW == 1 && SM_LARGE_PAGE == (sizeof(share_strings)\/sizeof(share_strings[0])), \"share_mode contants are out of range\");  \/\/ the +1 offset is intentional; see below\n@@ -161,1 +160,1 @@\n-      X2(CORESERVICES, CoreServices); \/* is also VM_MEMORY_CARBON *\/\n+      X2(CORESERVICES, CoreServices); \/\/ is also VM_MEMORY_CARBON\n@@ -365,0 +364,4 @@\n+        \/\/ if this region size is not 128GB, it is the last of a set\n+        if (region_info.pri_size != MACOS_PARTIAL_ALLOCATION_SIZE) {\n+\n+        }\n@@ -366,2 +369,2 @@\n-        \/* print previous mapping info *\/\n-        \/* avoid printing the empty info at the start *\/\n+        \/\/ print previous mapping info\n+        \/\/ avoid printing the empty info at the start\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"}]}