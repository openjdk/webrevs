{"files":[{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#if defined(__APPLE__)\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <libproc.h>\n+#include <unistd.h>\n+\n+#include <mach\/vm_inherit.h>\n+#include <mach\/vm_prot.h>\n+#include <mach\/mach_vm.h>\n+\n+\/* maximum number of mapping records returned *\/\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n+class MappingInfo {\n+public:\n+  const char* _address;\n+  size_t _size;\n+  stringStream _share_buffer;\n+  stringStream _type_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _file_name;\n+  const char* _tag_text;\n+\n+  MappingInfo() {}\n+\n+  void process(const proc_regionwithpathinfo& mem_info) {\n+    _share_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    _file_name.reset();\n+    _tag_text = \"\";\n+\n+    const proc_regioninfo& rinfo = mem_info.prp_prinfo;\n+\n+    _address = (const char*) rinfo.pri_address;\n+    _size = rinfo.pri_size;\n+\n+    const char* path = mem_info.prp_vip.vip_path;\n+    if (path != nullptr) {\n+      _file_name.print_raw(path);\n+    } else {\n+      char buf[PATH_MAX];\n+      buf[0] = '\\0';\n+      proc_regionfilename(getpid(), (uint64_t) _address, buf, sizeof(buf));\n+      if (buf[0] != 0) {\n+        buf[sizeof(buf) - 1] = '\\0';\n+        _file_name.print_raw(\"-> \");\n+        _file_name.print_raw(buf);\n+      }\n+    }\n+\n+    char prot[4];\n+    rwbits(rinfo.pri_protection, prot);\n+    _protect_buffer.print(\"%s\", prot);\n+\n+    get_share_mode(_share_buffer, rinfo);\n+    _tag_text = tagToStr(rinfo.pri_user_tag);\n+  }\n+\n+  static void get_share_mode(outputStream& out, const proc_regioninfo& rinfo) {\n+    static const char* share_strings[] = {\n+      \"cow\", \"pvt\", \"---\", \"shr\", \"tsh\", \"p\/a\", \"s\/a\", \"lpg\"\n+    };\n+    const bool valid_share_mode = rinfo.pri_share_mode >= SM_COW && rinfo.pri_share_mode <= SM_LARGE_PAGE;\n+    if (valid_share_mode) {\n+      int share_mode = rinfo.pri_share_mode;\n+      out.print_raw(share_strings[share_mode - 1]);\n+    } else {\n+      out.print_cr(\"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+      assert(valid_share_mode, \"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+    }\n+    if (rinfo.pri_flags & PROC_REGION_SHARED) {\n+        out.print_raw(\"-shared\");\n+    }\n+    if (rinfo.pri_flags & PROC_REGION_SUBMAP) {\n+        out.print_raw(\"-submap\");\n+    }\n+    if ((rinfo.pri_flags & (PROC_REGION_SHARED | PROC_REGION_SUBMAP)) != rinfo.pri_flags) {\n+      out.print_cr(\"unhandled pri_flags = 0x%x\", rinfo.pri_flags);\n+      assert(false, \"unhandled pri_flags = 0x%x\", rinfo.pri_flags);\n+    }\n+  }\n+\n+#define X1(TAG) case VM_MEMORY_ ## TAG: return # TAG;\n+#define X2(TAG, DESCRIPTION) case VM_MEMORY_ ## TAG: return # DESCRIPTION;\n+  static const char* tagToStr(uint32_t user_tag) {\n+    switch (user_tag) {\n+      case 0:\n+        return 0;\n+      X1(MALLOC);\n+      X1(MALLOC_SMALL);\n+      X1(MALLOC_LARGE);\n+      X1(MALLOC_HUGE);\n+      X1(SBRK);\n+      X1(REALLOC);\n+      X1(MALLOC_TINY);\n+      X1(MALLOC_LARGE_REUSABLE);\n+      X1(MALLOC_LARGE_REUSED);\n+      X1(ANALYSIS_TOOL);\n+      X1(MALLOC_NANO);\n+      X1(MALLOC_MEDIUM);\n+      X1(MALLOC_PROB_GUARD);\n+      X1(MACH_MSG);\n+      X1(IOKIT);\n+      X1(STACK);\n+      X1(GUARD);\n+      X1(SHARED_PMAP);\n+      X1(DYLIB);\n+      X1(UNSHARED_PMAP);\n+      X2(APPKIT, AppKit);\n+      X2(FOUNDATION, Foundation);\n+      X2(COREGRAPHICS, CoreGraphics);\n+      X2(CORESERVICES, CoreServices); \/* is also VM_MEMORY_CARBON *\/\n+      X2(JAVA, Java);\n+      X2(COREDATA, CoreData);\n+      X1(COREDATA_OBJECTIDS);\n+      X1(ATS);\n+      X1(DYLD);\n+      X1(DYLD_MALLOC);\n+      X1(SQLITE);\n+      X1(JAVASCRIPT_CORE);\n+      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR);\n+      X1(JAVASCRIPT_JIT_REGISTER_FILE);\n+      X1(OPENCL);\n+      X2(COREIMAGE, CoreImage);\n+      X2(IMAGEIO, ImageIO);\n+      X2(COREPROFILE, CoreProfile);\n+      X1(APPLICATION_SPECIFIC_1);\n+      X1(APPLICATION_SPECIFIC_16);\n+      X1(OS_ALLOC_ONCE);\n+      X1(GENEALOGY);\n+      default:\n+        static char buffer[30];\n+        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        return buffer;\n+    }\n+  }\n+\n+  static void rwbits(int rw, char bits[4]) {\n+    bits[0] = rw & VM_PROT_READ ? 'r' : '-';\n+    bits[1] = rw & VM_PROT_WRITE ? 'w' : '-';\n+    bits[2] = rw & VM_PROT_EXECUTE ? 'x' : '-';\n+    bits[3] = 0;\n+  }\n+};\n+\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _private;\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _private(0),\n+                       _committed(0), _shared(0), _swapped_out(0) {}\n+\n+  void add_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) {\n+    _num_mappings++;\n+\n+    bool is_private = region_info.pri_share_mode == SM_PRIVATE\n+                   || region_info.pri_share_mode == SM_PRIVATE_ALIASED;\n+    bool is_shared = region_info.pri_share_mode == SM_SHARED\n+                   || region_info.pri_share_mode == SM_SHARED_ALIASED\n+                   || region_info.pri_share_mode == SM_TRUESHARED\n+                   || region_info.pri_share_mode == SM_COW;\n+    _private += is_private ? region_info.pri_size : 0;\n+    _shared += is_shared ? region_info.pri_size : 0;\n+    _swapped_out += region_info.pri_pages_swapped_out;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+\n+    task_vm_info vm_info;\n+    mach_msg_type_number_t num_out = TASK_VM_INFO_COUNT;\n+    kern_return_t err_vm = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&vm_info), &num_out);\n+    if (err_vm == KERN_SUCCESS) {\n+      st->print_cr(\"             vsize: %llu (%llu%s)\", vm_info.virtual_size, PROPERFMTARGS(vm_info.virtual_size));\n+      st->print_cr(\"               rss: %llu (%llu%s)\", vm_info.resident_size, PROPERFMTARGS(vm_info.resident_size));\n+      st->print_cr(\"          peak rss: %llu (%llu%s)\", vm_info.resident_size_peak, PROPERFMTARGS(vm_info.resident_size_peak));\n+      st->print_cr(\"         page size: %d (%ld%s)\", vm_info.page_size, PROPERFMTARGS((size_t)vm_info.page_size));\n+    } else {\n+      st->print_cr(\"error getting vm_info %d\", err_vm);\n+    }\n+    st->print_cr(\"           private: %zu (\" PROPERFMT \")\", _private, PROPERFMTARGS(_private));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out * vm_info.page_size, PROPERFMTARGS(_swapped_out * vm_info.page_size));\n+  }\n+};\n+\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) const {\n+     outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, (size_t)mapping_info._address, (size_t)(mapping_info._address + mapping_info._size));\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", mapping_info._size);\n+    INDENT_BY(51);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n+    INDENT_BY(56);\n+    st->print(\"%s\", mapping_info._share_buffer.base());\n+    st->print(\"%s\", mapping_info._type_buffer.base());\n+    INDENT_BY(61);\n+    st->print(\"%#11llx\", region_info.pri_offset);\n+    INDENT_BY(73);\n+    if (_session.print_nmt_info_for_region((const void*)mapping_info._address, (const void*)(mapping_info._address + mapping_info._size))) {\n+      st->print(\" \");\n+    } else {\n+      const char* tag = mapping_info._tag_text;\n+      if (tag != NULL) {\n+        st->print(\"[%s] \", tag);\n+      }\n+    }\n+    st->print_raw(mapping_info._file_name.base());\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"           rwx: read \/ write \/ execute\");\n+    st->print_cr(\"share:   share mode:\");\n+    st->print_cr(\"           cow: copy on write\");\n+    st->print_cr(\"           pvt: private\");\n+    st->print_cr(\"           shr: shared\");\n+    st->print_cr(\"           tsh: true shared\");\n+    st->print_cr(\"           p\/a: private aliased\");\n+    st->print_cr(\"           s\/a: shared aliased\");\n+    st->print_cr(\"           lpg: large page\");\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x00000001714a0000-0x000000017169c000      2080768 rw-\/rwx  p\/a       0xc000 STACK-28419-C2-CompilerThread0\n+    st->print_cr(\"from               to                        vsize prot share     offset vminfo\/file\");\n+    st->print_cr(\"==================================================================================================\");\n+  }\n+};\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+  outputStream* const st = session.out();\n+  const pid_t pid = getpid();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  proc_regionwithpathinfo region_info;\n+  MappingInfo mapping_info;\n+  uint64_t address = 0;\n+  int region_count = 0;\n+  while (true) {\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n+    }\n+    int retval = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, (uint64_t)address, &region_info, sizeof(region_info));\n+    if (retval <= 0) {\n+      break;\n+    } else if (retval < (int)sizeof(region_info)) {\n+      st->print_cr(\"proc_pidinfo() returned %d\", retval);\n+      assert(false, \"proc_pidinfo() returned %d\", retval);\n+    }\n+    if (region_info.prp_prinfo.pri_share_mode != SM_EMPTY) {\n+      mapping_info.process(region_info);\n+      printer.print_single_mapping(region_info.prp_prinfo, mapping_info);\n+      summary.add_mapping(region_info.prp_prinfo, mapping_info);\n+    }\n+    assert(region_info.prp_prinfo.pri_size > 0, \"size of region is 0\");\n+    address = region_info.prp_prinfo.pri_address + region_info.prp_prinfo.pri_size;\n+  }\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n+}\n+#endif \/\/ __APPLE__\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -200,0 +200,2 @@\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n@@ -201,1 +203,0 @@\n-    st->print_cr(\"vm info: VM information (requires NMT)\");\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -145,1 +145,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX or WINDOWS or MacOS\n@@ -1177,1 +1177,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -991,1 +991,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux, Windows and MacOS only).\";\n@@ -1009,1 +1009,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux, Windows and MacOS only).\";\n@@ -1020,1 +1020,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX, WINDOWS or MACOS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,25 +36,0 @@\n-    private static final String prot = \"[rwsxp-]+\";\n-\n-    private static final String regexBase = range + space +\n-            someSize + space +\n-            prot + space +\n-            someSize + space +\n-            someSize + space +\n-            pagesize + space;\n-\n-    private static final String regexBase_committed = regexBase + \"com.*\";\n-    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n-\n-    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n-    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n-\n-    private static final String shouldMatchUnconditionally_linux[] = {\n-        \/\/ java launcher\n-        regexBase_committed + \"\/bin\/java\",\n-        \/\/ libjvm\n-        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n-        \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n-        regexBase_committed + \"\\\\[heap\\\\]\",\n-        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n-        regexBase_shared_and_committed + \"hsperfdata_.*\"\n-    };\n@@ -62,10 +37,3 @@\n-    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n-        regexBase_java_heap + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        regexBase_committed + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        regexBase + \"-\" + space + \"META.*\",\n-        \/\/ code cache\n-        regexBase_committed + \"CODE.*\",\n-        \/\/ Main thread stack\n-        regexBase_committed + \"STACK.*main.*\"\n+    interface MapPatterns {\n+        String[] shouldMatchUnconditionally();\n+        String[] shouldMatchIfNMTIsEnabled();\n@@ -74,3 +42,1 @@\n-    \/\/ windows:\n-    private static final String winprot = \"[\\\\-rwxcin]*\";\n-    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+    private final MapPatterns patternProvider;\n@@ -78,1 +44,2 @@\n-    private static final String winbase = range + space + someSize + space + winprot + space;\n+    private static final boolean isWindows = Platform.isWindows();\n+    private static final boolean isMacOS = Platform.isOSX();\n@@ -80,3 +47,3 @@\n-    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n-    private static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n-    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+    protected String[] shouldMatchUnconditionally() {\n+        return patternProvider.shouldMatchUnconditionally();\n+    }\n@@ -84,6 +51,3 @@\n-    private static final String shouldMatchUnconditionally_windows[] = {\n-        \/\/ java launcher\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n-        \/\/ libjvm\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n-    };\n+    protected String[] shouldMatchIfNMTIsEnabled() {\n+        return patternProvider.shouldMatchIfNMTIsEnabled();\n+    }\n@@ -91,11 +55,9 @@\n-    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n-        wincommitted + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        wincommitted + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        winreserved + \"META.*\",\n-        \/\/ code cache\n-        wincommitted + \"CODE.*\",\n-        \/\/ Main thread stack\n-        wincommitted + \"STACK-\\\\d+-main.*\"\n-    };\n+    protected SystemMapTestBase() {\n+        if (Platform.isWindows()) {\n+            patternProvider = new WindowsPatterns();\n+        } else if (Platform.isOSX()) {\n+            patternProvider = new MacOSPatterns();\n+        } else {\n+            patternProvider = new LinuxPatterns();\n+        }\n+    }\n@@ -103,1 +65,48 @@\n-    private static final boolean isWindows = Platform.isWindows();\n+    private static class LinuxPatterns implements MapPatterns {\n+\n+        private static final String prot = \"[rwsxp-]+\";\n+\n+        static final String regexBase = range + space +\n+                                        someSize + space +\n+                                        prot + space +\n+                                        someSize + space +\n+                                        someSize + space +\n+                                        pagesize + space;\n+\n+        static final String regexBase_committed = regexBase + \"com.*\";\n+        static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+        \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+        static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+\n+        static final String shouldMatchUnconditionally_linux[] = {\n+            \/\/ java launcher\n+            regexBase_committed + \"\/bin\/java\",\n+            \/\/ libjvm\n+            regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+            \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n+            regexBase_committed + \"\\\\[heap\\\\]\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            regexBase_shared_and_committed + \"hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_linux[] = {\n+            regexBase_java_heap + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            regexBase_committed + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            regexBase + \"-\" + space + \"META.*\",\n+            \/\/ code cache\n+            regexBase_committed + \"CODE.*\",\n+            \/\/ Main thread stack\n+            regexBase_committed + \"STACK.*main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_linux;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_linux;\n+        }\n+    };\n@@ -105,6 +114,38 @@\n-    protected static String[] shouldMatchUnconditionally() {\n-        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n-    }\n-    protected static String[] shouldMatchIfNMTIsEnabled() {\n-        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n-    }\n+    private static class WindowsPatterns implements MapPatterns {\n+\n+        static final String winprot = \"[\\\\-rwxcin]*\";\n+        static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+        static final String winbase = range + space + someSize + space + winprot + space;\n+\n+        static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+        static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n+        static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+        static final String shouldMatchUnconditionally_windows[] = {\n+            \/\/ java launcher\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+            \/\/ libjvm\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+            wincommitted + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            wincommitted + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            winreserved + \"META.*\",\n+            \/\/ code cache\n+            wincommitted + \"CODE.*\",\n+            \/\/ Main thread stack\n+            wincommitted + \"STACK-\\\\d+-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_windows;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_windows;\n+        }\n+    };\n@@ -112,0 +153,38 @@\n+    private static class MacOSPatterns implements MapPatterns {\n+\n+        \/\/ macOS:\n+        static final String macprot =  \"[\\\\-rwx]*\";\n+\n+        static final String macow = \"cow\";\n+        static final String macprivate = \"pvt\";\n+        static final String macprivatealiased = \"p\/a\";\n+\n+        static final String macOSbase = range + space + someSize + space + macprot + space;\n+\n+        static final String shouldMatchUnconditionally_macOS[] = {\n+            \/\/ java launcher\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/bin\/java\",\n+            \/\/ libjvm\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/lib\/server\/libjvm.dylib\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            macOSbase + macprivate + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_macOS[] = {\n+            macOSbase + macprivate + space + someNumber + space + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            macOSbase + macprivate + space + someNumber + space + \"META.*\",\n+            \/\/ code cache\n+            macOSbase + macprivate + space + someNumber + space + \"CODE.*\",\n+            \/\/ Main thread stack\n+            macOSbase + macprivatealiased + space + someNumber + space + \"STACK-.*-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_macOS;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_macOS;\n+        }\n+    };\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":145,"deletions":66,"binary":false,"changes":211,"status":"modified"}]}