{"files":[{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#if defined(__APPLE__)\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <libproc.h>\n+#include <unistd.h>\n+\n+#include <mach\/vm_inherit.h>\n+#include <mach\/vm_prot.h>\n+#include <mach\/mach_vm.h>\n+\n+\/* maximum number of mapping records returned *\/\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n+\/* \n+ * ::mmap() on MacOS is a layer ontop of Mach system calls, and will allocate in 128MB chunks.\n+ * This code will coalesce a series of identical 128GB chunks (maybe followed by one smaller chunk\n+ * with identical flags) into one.\n+ *\/\n+\n+static const int MACOS_PARTIAL_ALLOCATION_SIZE = 128 * M;\n+\n+class MappingInfo {\n+  proc_regioninfo _rinfo;\n+public:\n+  const char* _address;\n+  size_t _size;\n+  stringStream _share_buffer;\n+  stringStream _type_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _file_name;\n+  const char* _tag_text;\n+\n+  MappingInfo() {}\n+\n+  void reset() {\n+    _share_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    _file_name.reset();\n+    _tag_text = \"\";\n+  }\n+\n+  bool canCombine(const proc_regionwithpathinfo& mem_info) {\n+    const proc_regioninfo& n = mem_info.prp_prinfo;\n+    bool cc = _rinfo.pri_size == MACOS_PARTIAL_ALLOCATION_SIZE\n+              && n.pri_address == (_rinfo.pri_address + _size)\n+              && n.pri_protection == _rinfo.pri_protection\n+              && n.pri_max_protection == _rinfo.pri_max_protection\n+              && n.pri_user_tag == _rinfo.pri_user_tag\n+              && n.pri_share_mode == _rinfo.pri_share_mode\n+              && n.pri_offset == 0;\n+    return cc;\n+  }\n+\n+  void combineWithFollowing(const proc_regionwithpathinfo& mem_info) {\n+    _size += mem_info.prp_prinfo.pri_size;\n+  }\n+\n+  void process(const proc_regionwithpathinfo& mem_info) {\n+    reset();\n+\n+    _rinfo = mem_info.prp_prinfo;\n+\n+    _address = (const char*) _rinfo.pri_address;\n+    _size = _rinfo.pri_size;\n+\n+    if (mem_info.prp_vip.vip_path[0] != '\\0') {\n+      _file_name.print_raw(mem_info.prp_vip.vip_path);\n+    }\n+    \/* proc_regionfilename() seems to give bad results, so we don't try to use it here. *\/\n+\n+    char prot[4];\n+    char maxprot[4];\n+    rwbits(_rinfo.pri_protection, prot);\n+    rwbits(_rinfo.pri_max_protection, maxprot);\n+    _protect_buffer.print(\"%s\/%s\", prot, maxprot);\n+\n+    get_share_mode(_share_buffer, _rinfo);\n+    _tag_text = tagToStr(_rinfo.pri_user_tag);\n+  }\n+\n+  static void get_share_mode(outputStream& out, const proc_regioninfo& rinfo) {\n+    static const char* share_strings[] = {\n+      \"cow\", \"pvt\", \"---\", \"shr\", \"tsh\", \"p\/a\", \"s\/a\", \"lpg\"\n+    };\n+    assert(SM_COW == 1 && SM_LARGE_PAGE == 8, \"share_mode contants are out of range\");\n+    const bool valid_share_mode = rinfo.pri_share_mode >= SM_COW && rinfo.pri_share_mode <= SM_LARGE_PAGE;\n+    if (valid_share_mode) {\n+      int share_mode = rinfo.pri_share_mode;\n+      out.print_raw(share_strings[share_mode - 1]);\n+    } else {\n+      out.print_cr(\"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+      assert(valid_share_mode, \"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+    }\n+  }\n+\n+#define X1(TAG, DESCR) X2(TAG, DESCR)\n+#define X2(TAG, DESCRIPTION) case VM_MEMORY_ ## TAG: return # DESCRIPTION;\n+  static const char* tagToStr(uint32_t user_tag) {\n+    switch (user_tag) {\n+      case 0:\n+        return 0;\n+      X1(MALLOC, malloc);\n+      X1(MALLOC_SMALL, malloc_small);\n+      X1(MALLOC_LARGE, malloc_large);\n+      X1(MALLOC_HUGE, malloc_huge);\n+      X1(SBRK, sbrk);\n+      X1(REALLOC, realloc);\n+      X1(MALLOC_TINY, malloc_tiny);\n+      X1(MALLOC_LARGE_REUSABLE, malloc_large_reusable);\n+      X1(MALLOC_LARGE_REUSED, malloc_lage_reused);\n+      X1(ANALYSIS_TOOL, analysis_tool);\n+      X1(MALLOC_NANO, malloc_nano);\n+      X1(MALLOC_MEDIUM, malloc_medium);\n+      X1(MALLOC_PROB_GUARD, malloc_prob_guard);\n+      X1(MACH_MSG, malloc_msg);\n+      X1(IOKIT, IOKit);\n+      X1(STACK, stack);\n+      X1(GUARD, guard);\n+      X1(SHARED_PMAP, shared_pmap);\n+      X1(DYLIB, dylib);\n+      X1(UNSHARED_PMAP, unshared_pmap);\n+      X2(APPKIT, AppKit);\n+      X2(FOUNDATION, Foundation);\n+      X2(COREGRAPHICS, CoreGraphics);\n+      X2(CORESERVICES, CoreServices); \/* is also VM_MEMORY_CARBON *\/\n+      X2(JAVA, Java);\n+      X2(COREDATA, CoreData);\n+      X1(COREDATA_OBJECTIDS, CodeData_objectids);\n+      X1(ATS, ats);\n+      X1(DYLD, dyld);\n+      X1(DYLD_MALLOC, dyld_malloc);\n+      X1(SQLITE, sqlite);\n+      X1(JAVASCRIPT_CORE, javascript_core);\n+      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR, javascript_jit_executable_allocator);\n+      X1(JAVASCRIPT_JIT_REGISTER_FILE, javascript_jit_register_file);\n+      X1(OPENCL, OpenCL);\n+      X2(COREIMAGE, CoreImage);\n+      X2(IMAGEIO, ImageIO);\n+      X2(COREPROFILE, CoreProfile);\n+      X1(APPLICATION_SPECIFIC_1, application_specific_1);\n+      X1(APPLICATION_SPECIFIC_16, application_specific_16);\n+      X1(OS_ALLOC_ONCE, os_alloc_once);\n+      X1(GENEALOGY, genealogy);\n+      default:\n+        static char buffer[30];\n+        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        return buffer;\n+    }\n+  }\n+\n+  static void rwbits(int rw, char bits[4]) {\n+    bits[0] = rw & VM_PROT_READ ? 'r' : '-';\n+    bits[1] = rw & VM_PROT_WRITE ? 'w' : '-';\n+    bits[2] = rw & VM_PROT_EXECUTE ? 'x' : '-';\n+    bits[3] = 0;\n+  }\n+};\n+\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _private;\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _reserved;     \/\/ reserved but not committed\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _private(0),\n+                       _committed(0), _shared(0), _swapped_out(0) {}\n+\n+  void add_mapping(const proc_regioninfo& region_info) {\n+    _num_mappings++;\n+\n+    bool is_private = region_info.pri_share_mode == SM_PRIVATE\n+                   || region_info.pri_share_mode == SM_PRIVATE_ALIASED;\n+    bool is_shared = region_info.pri_share_mode == SM_SHARED\n+                   || region_info.pri_share_mode == SM_SHARED_ALIASED\n+                   || region_info.pri_share_mode == SM_TRUESHARED\n+                   || region_info.pri_share_mode == SM_COW;\n+    bool is_committed = region_info.pri_share_mode == SM_EMPTY\n+                   && region_info.pri_max_protection == VM_PROT_ALL\n+                   && ((region_info.pri_protection & VM_PROT_DEFAULT) == VM_PROT_DEFAULT);\n+    bool is_reserved = region_info.pri_share_mode == SM_EMPTY\n+                   && region_info.pri_max_protection == VM_PROT_ALL\n+                   && region_info.pri_protection == VM_PROT_NONE;\n+\n+    _private += is_private ? region_info.pri_size : 0;\n+    _shared += is_shared ? region_info.pri_size : 0;\n+    _swapped_out += region_info.pri_pages_swapped_out;\n+    _committed += is_committed ? region_info.pri_size : 0;\n+    _reserved += is_reserved ? region_info.pri_size : 0;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+\n+    task_vm_info vm_info;\n+    mach_msg_type_number_t num_out = TASK_VM_INFO_COUNT;\n+    kern_return_t err = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&vm_info), &num_out);\n+    if (err == KERN_SUCCESS) {\n+      st->print_cr(\"             vsize: %llu (%llu%s)\", vm_info.virtual_size, PROPERFMTARGS(vm_info.virtual_size));\n+      st->print_cr(\"               rss: %llu (%llu%s)\", vm_info.resident_size, PROPERFMTARGS(vm_info.resident_size));\n+      st->print_cr(\"          peak rss: %llu (%llu%s)\", vm_info.resident_size_peak, PROPERFMTARGS(vm_info.resident_size_peak));\n+      st->print_cr(\"         page size: %d (%ld%s)\", vm_info.page_size, PROPERFMTARGS((size_t)vm_info.page_size));\n+    } else {\n+      st->print_cr(\"error getting vm_info %d\", err);\n+    }\n+    st->print_cr(\"          reserved: %zu (\" PROPERFMT \")\", _reserved, PROPERFMTARGS(_reserved));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"           private: %zu (\" PROPERFMT \")\", _private, PROPERFMTARGS(_private));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out * vm_info.page_size, PROPERFMTARGS(_swapped_out * vm_info.page_size));\n+  }\n+};\n+\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) const {\n+     outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(\"%#014.12llx-%#014.12llx\", (uint64_t)(mapping_info._address), (uint64_t)(mapping_info._address + mapping_info._size));\n+    INDENT_BY(38);\n+    st->print(\"%12ld\", mapping_info._size);\n+    INDENT_BY(51);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n+    INDENT_BY(59);\n+    st->print(\"%s\", mapping_info._share_buffer.base());\n+    st->print(\"%s\", mapping_info._type_buffer.base());\n+    INDENT_BY(64);\n+    st->print(\"%#11llx\", region_info.pri_offset);\n+    INDENT_BY(77);\n+    if (_session.print_nmt_info_for_region((const void*)mapping_info._address, (const void*)(mapping_info._address + mapping_info._size))) {\n+      st->print(\" \");\n+    } else {\n+      const char* tag = mapping_info._tag_text;\n+      if (tag != NULL) {\n+        st->print(\"[%s] \", tag);\n+      }\n+    }\n+\n+    st->print_raw(mapping_info._file_name.base());\n+    st->cr();\n+\n+#undef INDENT_BY\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"           rwx: read \/ write \/ execute\");\n+    st->print_cr(\"share:   share mode:\");\n+    st->print_cr(\"           cow: copy on write\");\n+    st->print_cr(\"           pvt: private\");\n+    st->print_cr(\"           shr: shared\");\n+    st->print_cr(\"           tsh: true shared\");\n+    st->print_cr(\"           p\/a: private aliased\");\n+    st->print_cr(\"           s\/a: shared aliased\");\n+    st->print_cr(\"           lpg: large page\");\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x000102890000-0x000102898000                32768 r--\/r-- cow       0xc000 \/Users\/simont\/dev\/openjdk\/jdk\/build\/macos-aarch64-fastdebug-shenandoah\/images\/jdk\/bin\/java\n+    st->print_cr(\"from               to                        vsize prot    share     offset  vminfo\/file\");\n+    st->print_cr(\"==================================================================================================\");\n+  }\n+};\n+\n+static bool is_interesting(const proc_regionwithpathinfo& info) {\n+   return info.prp_prinfo.pri_share_mode != SM_EMPTY\n+          || info.prp_prinfo.pri_user_tag != 0\n+          || info.prp_vip.vip_path[0] != '\\0'\n+          || info.prp_prinfo.pri_protection != 0\n+          || info.prp_prinfo.pri_max_protection != 0;\n+}\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+  outputStream* const st = session.out();\n+  const pid_t pid = getpid();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  proc_regionwithpathinfo region_info_with_path;\n+  MappingInfo mapping_info;\n+  uint64_t address = 0;\n+  int region_count = 0;\n+  while (true) {\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n+    }\n+    ::bzero(&region_info_with_path, sizeof(region_info_with_path));\n+    int retval = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, (uint64_t)address, &region_info_with_path, sizeof(region_info_with_path));\n+    if (retval <= 0) {\n+      break;\n+    } else if (retval < (int)sizeof(region_info_with_path)) {\n+      st->print_cr(\"proc_pidinfo() returned %d\", retval);\n+      assert(false, \"proc_pidinfo() returned %d\", retval);\n+    }\n+    proc_regioninfo& region_info = region_info_with_path.prp_prinfo;\n+    if (is_interesting(region_info_with_path)) {\n+      if (mapping_info.canCombine(region_info_with_path)) {\n+        mapping_info.combineWithFollowing(region_info_with_path);\n+      } else {\n+        \/* print previous mapping info *\/\n+        \/* avoid printing the empty info at the start *\/\n+        if (mapping_info._size != 0) {\n+          printer.print_single_mapping(region_info, mapping_info);\n+        }\n+        summary.add_mapping(region_info);\n+        mapping_info.process(region_info_with_path);\n+      }\n+    }\n+    assert(region_info.pri_size > 0, \"size of region is 0\");\n+    address = region_info.pri_address + region_info.pri_size;\n+  }\n+  printer.print_single_mapping(region_info_with_path.prp_prinfo, mapping_info);\n+  summary.add_mapping(region_info_with_path.prp_prinfo);\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n+}\n+#endif \/\/ __APPLE__\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -200,0 +200,2 @@\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n@@ -201,1 +203,0 @@\n-    st->print_cr(\"vm info: VM information (requires NMT)\");\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -145,1 +145,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX or WINDOWS or MacOS\n@@ -1177,1 +1177,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -991,1 +991,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux, Windows and MacOS only).\";\n@@ -1009,1 +1009,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux, Windows and MacOS only).\";\n@@ -1020,1 +1020,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX, WINDOWS or MACOS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,25 +36,0 @@\n-    private static final String prot = \"[rwsxp-]+\";\n-\n-    private static final String regexBase = range + space +\n-            someSize + space +\n-            prot + space +\n-            someSize + space +\n-            someSize + space +\n-            pagesize + space;\n-\n-    private static final String regexBase_committed = regexBase + \"com.*\";\n-    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n-\n-    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n-    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n-\n-    private static final String shouldMatchUnconditionally_linux[] = {\n-        \/\/ java launcher\n-        regexBase_committed + \"\/bin\/java\",\n-        \/\/ libjvm\n-        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n-        \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n-        regexBase_committed + \"\\\\[heap\\\\]\",\n-        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n-        regexBase_shared_and_committed + \"hsperfdata_.*\"\n-    };\n@@ -62,10 +37,3 @@\n-    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n-        regexBase_java_heap + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        regexBase_committed + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        regexBase + \"-\" + space + \"META.*\",\n-        \/\/ code cache\n-        regexBase_committed + \"CODE.*\",\n-        \/\/ Main thread stack\n-        regexBase_committed + \"STACK.*main.*\"\n+    interface MapPatterns {\n+        String[] shouldMatchUnconditionally();\n+        String[] shouldMatchIfNMTIsEnabled();\n@@ -74,3 +42,1 @@\n-    \/\/ windows:\n-    private static final String winprot = \"[\\\\-rwxcin]*\";\n-    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+    private final MapPatterns patternProvider;\n@@ -78,1 +44,2 @@\n-    private static final String winbase = range + space + someSize + space + winprot + space;\n+    private static final boolean isWindows = Platform.isWindows();\n+    private static final boolean isMacOS = Platform.isOSX();\n@@ -80,3 +47,3 @@\n-    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n-    private static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n-    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+    protected String[] shouldMatchUnconditionally() {\n+        return patternProvider.shouldMatchUnconditionally();\n+    }\n@@ -84,6 +51,3 @@\n-    private static final String shouldMatchUnconditionally_windows[] = {\n-        \/\/ java launcher\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n-        \/\/ libjvm\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n-    };\n+    protected String[] shouldMatchIfNMTIsEnabled() {\n+        return patternProvider.shouldMatchIfNMTIsEnabled();\n+    }\n@@ -91,11 +55,9 @@\n-    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n-        wincommitted + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        wincommitted + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        winreserved + \"META.*\",\n-        \/\/ code cache\n-        wincommitted + \"CODE.*\",\n-        \/\/ Main thread stack\n-        wincommitted + \"STACK-\\\\d+-main.*\"\n-    };\n+    protected SystemMapTestBase() {\n+        if (Platform.isWindows()) {\n+            patternProvider = new WindowsPatterns();\n+        } else if (Platform.isOSX()) {\n+            patternProvider = new MacOSPatterns();\n+        } else {\n+            patternProvider = new LinuxPatterns();\n+        }\n+    }\n@@ -103,1 +65,48 @@\n-    private static final boolean isWindows = Platform.isWindows();\n+    private static class LinuxPatterns implements MapPatterns {\n+\n+        private static final String prot = \"[rwsxp-]+\";\n+\n+        static final String regexBase = range + space +\n+                                        someSize + space +\n+                                        prot + space +\n+                                        someSize + space +\n+                                        someSize + space +\n+                                        pagesize + space;\n+\n+        static final String regexBase_committed = regexBase + \"com.*\";\n+        static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+        \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+        static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+\n+        static final String shouldMatchUnconditionally_linux[] = {\n+            \/\/ java launcher\n+            regexBase_committed + \"\/bin\/java\",\n+            \/\/ libjvm\n+            regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+            \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n+            regexBase_committed + \"\\\\[heap\\\\]\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            regexBase_shared_and_committed + \"hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_linux[] = {\n+            regexBase_java_heap + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            regexBase_committed + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            regexBase + \"-\" + space + \"META.*\",\n+            \/\/ code cache\n+            regexBase_committed + \"CODE.*\",\n+            \/\/ Main thread stack\n+            regexBase_committed + \"STACK.*main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_linux;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_linux;\n+        }\n+    };\n@@ -105,6 +114,38 @@\n-    protected static String[] shouldMatchUnconditionally() {\n-        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n-    }\n-    protected static String[] shouldMatchIfNMTIsEnabled() {\n-        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n-    }\n+    private static class WindowsPatterns implements MapPatterns {\n+\n+        static final String winprot = \"[\\\\-rwxcin]*\";\n+        static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+        static final String winbase = range + space + someSize + space + winprot + space;\n+\n+        static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+        static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n+        static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+        static final String shouldMatchUnconditionally_windows[] = {\n+            \/\/ java launcher\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+            \/\/ libjvm\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+            wincommitted + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            wincommitted + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            winreserved + \"META.*\",\n+            \/\/ code cache\n+            wincommitted + \"CODE.*\",\n+            \/\/ Main thread stack\n+            wincommitted + \"STACK-\\\\d+-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_windows;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_windows;\n+        }\n+    };\n@@ -112,0 +153,40 @@\n+    private static class MacOSPatterns implements MapPatterns {\n+\n+        \/\/ macOS:\n+        static final String macprot =  \"[\\\\-rwx]*\/[\\\\-rwx]*\";\n+\n+        static final String macow = \"cow\";\n+        static final String macprivate = \"pvt\";\n+        static final String macprivate_or_shared = \"(pvt|tsh-shared)\";\n+        static final String macprivatealiased = \"p\/a\";\n+\n+        static final String macOSbase = range + space + someSize + space + macprot + space;\n+\n+        static final String shouldMatchUnconditionally_macOS[] = {\n+            \/\/ java launcher\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/bin\/java\",\n+            \/\/ libjvm\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/lib\/server\/libjvm.dylib\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            macOSbase + macprivate + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_macOS[] = {\n+            \/\/ heap is private with G1GC, shared with ZGC\n+            macOSbase + macprivate_or_shared + space + someNumber + space + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            macOSbase + macprivate + space + someNumber + space + \"META.*\",\n+            \/\/ code cache\n+            macOSbase + macprivate + space + someNumber + space + \"CODE.*\",\n+            \/\/ Main thread stack\n+            macOSbase + macprivatealiased + space + someNumber + space + \"STACK-.*-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_macOS;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_macOS;\n+        }\n+    };\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":147,"deletions":66,"binary":false,"changes":213,"status":"modified"}]}