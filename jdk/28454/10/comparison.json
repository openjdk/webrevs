{"files":[{"patch":"@@ -1076,0 +1076,22 @@\n+    \/\/ This follows the implementation of encodeASCII\n+    private static int encodedLengthASCII(byte coder, byte[] val) {\n+        if (coder == LATIN1) {\n+            return val.length;\n+        }\n+        int len = val.length >> 1;\n+        int dp = 0;\n+        for (int i = 0; i < len; i++) {\n+            char c = StringUTF16.getChar(val, i);\n+            if (c < 0x80) {\n+                dp++;\n+                continue;\n+            }\n+            if (Character.isHighSurrogate(c) && i + 1 < len &&\n+                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n+                i++;\n+            }\n+            dp++;\n+        }\n+        return dp;\n+    }\n+\n@@ -1136,0 +1158,22 @@\n+    \/\/ This follows the implementation of encode8859_1\n+    private static int encodedLength8859_1(byte coder, byte[] val) {\n+        if (coder == LATIN1) {\n+            return val.length;\n+        }\n+        int len = val.length >> 1;\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = len;\n+        while (sp < sl) {\n+            char c = StringUTF16.getChar(val, sp++);\n+            if (c > 0x80) {\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n+                    sp++;\n+                }\n+            }\n+            dp++;\n+        }\n+        return dp;\n+    }\n+\n@@ -1470,0 +1514,21 @@\n+    \/\/ This follows the implementation of encodeUTF8\n+    private static int encodedLengthUTF8(byte coder, byte[] val) {\n+        if (coder == UTF16) {\n+            return encodedLengthUTF8_UTF16(val, null);\n+        }\n+        int positives = StringCoding.countPositives(val, 0, val.length);\n+        if (positives == val.length) {\n+            return positives;\n+        }\n+        int dp = positives;\n+        for (int i = dp; i < val.length; i++) {\n+            byte c = val[i];\n+            if (c < 0) {\n+                dp += 2;\n+            } else {\n+                dp++;\n+            }\n+        }\n+        return dp;\n+    }\n+\n@@ -1487,5 +1552,2 @@\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, exClass) : sl * 3;\n-        if (allocLen > (long)Integer.MAX_VALUE) {\n-            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n-        }\n-        byte[] dst = new byte[(int) allocLen];\n+        int allocLen = (sl * 3 < 0) ? encodedLengthUTF8_UTF16(val, exClass) : sl * 3;\n+        byte[] dst = new byte[allocLen];\n@@ -1550,1 +1612,1 @@\n-    private static <E extends Exception> long computeSizeUTF8_UTF16(byte[] val, Class<E> exClass) throws E {\n+    private static <E extends Exception> int encodedLengthUTF8_UTF16(byte[] val, Class<E> exClass) throws E {\n@@ -1555,0 +1617,9 @@\n+        while (sp < sl) {\n+            \/\/ ascii fast loop;\n+            char c = StringUTF16.getChar(val, sp);\n+            if (c >= '\\u0080') {\n+                break;\n+            }\n+            dp++;\n+            sp++;\n+        }\n@@ -1583,1 +1654,4 @@\n-        return dp;\n+        if (dp > (long)Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n+        }\n+        return (int) dp;\n@@ -2048,0 +2122,23 @@\n+    \/**\n+     * {@return the length in bytes of the given String encoded with the given {@link Charset}}\n+     *\n+     * <p>The result will be the same value as {@link #getBytes(Charset) getBytes(cs).length}.\n+     *\n+     * @apiNote This method provides equivalent or better performance than {@link #getBytes(Charset)\n+     *          getBytes(cs).length}. It may allocate memory to compute the length for some charsets.\n+     *\n+     * @param cs The {@link Charset} used to the compute the length\n+     * @since 27\n+     *\/\n+    public int getBytesLength(Charset cs) {\n+        Objects.requireNonNull(cs);\n+        if (cs == UTF_8.INSTANCE) {\n+            return encodedLengthUTF8(coder, value);\n+        } else if (cs == ISO_8859_1.INSTANCE) {\n+            return encodedLength8859_1(coder, value);\n+        } else if (cs == US_ASCII.INSTANCE) {\n+            return encodedLengthASCII(coder, value);\n+        }\n+        return getBytes(cs).length;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":104,"deletions":7,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -109,0 +109,4 @@\n+        \/* String.getBytesLength(Charset charset) *\/\n+        if (bs.length != str.getBytesLength(charset))\n+            throw new Exception(charset + \": String.getBytesLength failed\");\n+\n","filename":"test\/jdk\/java\/lang\/String\/Encodings.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -400,0 +400,8 @@\n+    private static void getBytesLength() {\n+        System.out.println(\"getBytesLength(Charset charset)\");\n+        tryCatch(\"  null\", NullPointerException.class, new Runnable() {\n+                public void run() {\n+                    \"foo\".getBytesLength((Charset)null);\n+                }});\n+    }\n+\n@@ -643,0 +651,1 @@\n+        getBytesLength();     \/\/ getBytesLength(Charset)\n","filename":"test\/jdk\/java\/lang\/String\/Exceptions.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -172,0 +172,6 @@\n+        \/\/getBytesLength(cs);\n+        int getBytesLength = str.getBytesLength(cs);\n+        if (baSC.length != getBytesLength) {\n+            throw new RuntimeException(String.format(\"getBytesLength failed (%d != %d) -> %s\",\n+                    baSC.length, getBytesLength, cs.name()));\n+        }\n","filename":"test\/jdk\/sun\/nio\/cs\/TestStringCoding.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@Warmup(time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class StringLoopJmhBenchmark {\n+  @Param({\"10\", \"100\", \"1000\", \"100000\"})\n+  int stringLength;\n+\n+  @Param({\"ASCII\", \"LATIN1\", \"UTF16\"})\n+  String encoding;\n+\n+  String stringData;\n+\n+  @Setup\n+  public void setUp() {\n+    stringData = \"\";\n+\n+    \/\/ Character at the _end_ to affect if we hit\n+    \/\/ - ASCII = compact strings and compatible with UTF-8\n+    \/\/ - LATIN1 = compact strings but not compatible with UTF-8\n+    \/\/ - UTF16 = 2-byte char storage and not compatible with UTF-8\n+    String c;\n+    if (encoding.equals(\"ASCII\")) {\n+      c = \"a\";\n+    } else if (encoding.equals(\"LATIN1\")) {\n+      c = \"\\u00C4\";\n+    } else if (encoding.equals(\"UTF16\")) {\n+      c = \"\\u2603\";\n+    } else {\n+      throw new IllegalArgumentException(\"Unknown encoding: \" + encoding);\n+    }\n+\n+    var stringDataBuilder = new StringBuilder(stringLength + 1);\n+    while (stringDataBuilder.length() < stringLength) {\n+      stringDataBuilder.append((char) (Math.random() * 26) + 'a');\n+    }\n+    stringData = stringDataBuilder.append(c).toString();\n+  }\n+\n+  @Benchmark\n+  public int utf8LenByLoop() {\n+    final String s = stringData;\n+    final int len = s.length();\n+\n+    \/\/ ASCII prefix strings.\n+    int idx = 0;\n+    for (char c; idx < len && (c = s.charAt(idx)) < 0x80; ++idx) {}\n+\n+    \/\/ Entire string was ASCII.\n+    if (idx == len) {\n+      return len;\n+    }\n+\n+    int utf8Len = len;\n+    for (char c; idx < len; ++idx) {\n+      c = s.charAt(idx);\n+      if (c < 0x80) {\n+        utf8Len++;\n+      } else if (c < 0x800) {\n+        utf8Len += 2;\n+      } else {\n+        utf8Len += 3;\n+        if (Character.isSurrogate(c)) {\n+          int cp = Character.codePointAt(s, idx);\n+          if (cp < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            throw new RuntimeException(\"Unpaired surrogate\");\n+          }\n+          idx++;\n+        }\n+      }\n+    }\n+    return utf8Len;\n+  }\n+\n+  @Benchmark\n+  public int getBytes() throws Exception {\n+    return stringData.getBytes(StandardCharsets.UTF_8).length;\n+  }\n+\n+  @Benchmark\n+  public int getBytesLength() throws Exception {\n+    return stringData.getBytesLength(StandardCharsets.UTF_8);\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StringLoopJmhBenchmark.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}