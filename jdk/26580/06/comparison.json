{"files":[{"patch":"@@ -82,0 +82,1 @@\n+        \"NumberElements\/lenientMinusSigns\",\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -847,0 +847,20 @@\n+        \/\/ Lenient parsing\n+        case \"parseLenients\":\n+            if (\"lenient\".equals(attributes.getValue(\"level\"))) {\n+                pushKeyContainer(qName, attributes, attributes.getValue(\"scope\"));\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n+        case \"parseLenient\":\n+            \/\/ Use only the lenient minus sign for now\n+            if (currentContainer instanceof KeyContainer kc &&\n+                kc.getKey().equals(\"number\") &&\n+                attributes.getValue(\"sample\").equals(\"-\")) {\n+                pushStringEntry(qName, attributes, currentNumberingSystem + \"NumberElements\/lenientMinusSigns\");\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n@@ -1153,0 +1173,8 @@\n+        case \"parseLenient\":\n+            if (currentContainer instanceof StringEntry se) {\n+                \/\/ Convert to a simple concatenation of lenient minuses\n+                \/\/ e.g. \"[\\-－﹣ ‐‑ ‒ – −⁻₋ ➖]\" -> \"-－﹣‐‑‒–−⁻₋➖\" for the root locale\n+                put(se.getKey(), se.getValue().replaceAll(\"[\\\\[\\\\]\\\\\\\\ ]\", \"\"));\n+            }\n+            break;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -219,0 +219,4 @@\n+ * @implNote The implementation follows the LDML specification to enable loose\n+ * matching of minus sign patterns when {@link #isStrict()} returns\n+ * {@code false}.\n+ *\n@@ -1696,2 +1700,1 @@\n-            if (text.regionMatches(pos.index, defaultPosPrefix, 0,\n-                    defaultPosPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultPosPrefix)) {\n@@ -1702,2 +1705,1 @@\n-            if (text.regionMatches(pos.index, defaultNegPrefix, 0,\n-                    defaultNegPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultNegPrefix)) {\n@@ -1927,1 +1929,1 @@\n-                return text.regionMatches(position, affix, 0, affix.length());\n+                return decimalFormat.matchAffix(text, position, affix);\n@@ -2029,2 +2031,1 @@\n-            boolean containsPosSuffix = text.regionMatches(position,\n-                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean containsPosSuffix = decimalFormat.matchAffix(text, position, positiveSuffix);\n@@ -2038,2 +2039,1 @@\n-            boolean containsNegSuffix = text.regionMatches(position,\n-                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean containsNegSuffix = decimalFormat.matchAffix(text, position, negativeSuffix);\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -421,0 +421,4 @@\n+ * @implNote The implementation follows the LDML specification to enable loose\n+ * matching of minus sign patterns when {@link #isStrict()} returns\n+ * {@code false}.\n+ *\n@@ -2395,4 +2399,2 @@\n-        gotPositive = text.regionMatches(position, positivePrefix, 0,\n-                positivePrefix.length());\n-        gotNegative = text.regionMatches(position, negativePrefix, 0,\n-                negativePrefix.length());\n+        gotPositive = matchAffix(text, position, positivePrefix);\n+        gotNegative = matchAffix(text, position, negativePrefix);\n@@ -2434,2 +2436,1 @@\n-                boolean containsPosSuffix =\n-                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean containsPosSuffix = matchAffix(text, position, positiveSuffix);\n@@ -2441,2 +2442,1 @@\n-                boolean containsNegSuffix =\n-                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean containsNegSuffix = matchAffix(text, position, negativeSuffix);\n@@ -3511,0 +3511,48 @@\n+    \/**\n+     * {@return true if the text matches the affix}\n+     * In lenient mode, lenient minus signs also match the hyphen-minus\n+     * (U+002D). Package-private access, as this is called from\n+     * CompactNumberFormat.\n+     * @implNote The implementation does not account for lenient minuses\n+     * in non-BMP ranges or normalizations, as these could change the affix\n+     * length.\n+     *\/\n+    boolean matchAffix(String text, int position, String affix) {\n+        var alen = affix.length();\n+        var tlen = text.length();\n+\n+        if (alen == 0) {\n+            \/\/ always match with an empty affix, as affix is optional\n+            return true;\n+        }\n+        if (position >= tlen) {\n+            return false;\n+        }\n+        if (parseStrict) {\n+            return text.regionMatches(position, affix, 0, alen);\n+        }\n+\n+        var lms = symbols.getLenientMinusSigns();\n+        int i = 0;\n+        int limit = Math.min(tlen, position + alen);\n+        for (; position + i < limit; i++) {\n+            char t = text.charAt(position + i);\n+            char a = affix.charAt(i);\n+            int tIndex = lms.indexOf(t);\n+            int aIndex = lms.indexOf(a);\n+            \/\/ Non LMS. Match direct\n+            if (tIndex < 0 && aIndex < 0) {\n+                if (t != a) {\n+                    return false;\n+                }\n+            } else {\n+                \/\/ By here, at least one LMS. Ensure both LMS.\n+                if (tIndex < 0 || aIndex < 0) {\n+                    return false;\n+                }\n+            }\n+        }\n+        \/\/ Return true if entire affix was matched\n+        return i == alen;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":56,"deletions":8,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -718,0 +718,8 @@\n+    \/**\n+     * {@return the lenient minus signs} Multiple lenient minus signs\n+     * are concatenated to form the returned string.\n+     *\/\n+    String getLenientMinusSigns() {\n+        return lenientMinusSigns;\n+    }\n+\n@@ -818,12 +826,1 @@\n-        \/\/ check for region override\n-        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n-            CalendarDataUtility.findRegionOverride(locale) :\n-            locale;\n-\n-        \/\/ get resource bundle data\n-        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n-        \/\/ Avoid potential recursions\n-        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n-            adapter = LocaleProviderAdapter.getResourceBundleBased();\n-        }\n-        Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+        Object[] data = loadNumberData(locale);\n@@ -854,0 +851,3 @@\n+        \/\/ Lenient minus signs\n+        lenientMinusSigns = numberElements.length < 14 ? minusSignText : numberElements[13];\n+\n@@ -859,0 +859,16 @@\n+    private Object[] loadNumberData(Locale locale) {\n+        \/\/ check for region override\n+        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n+            CalendarDataUtility.findRegionOverride(locale) :\n+            locale;\n+\n+        \/\/ get resource bundle data\n+        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n+        \/\/ Avoid potential recursions\n+        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n+            adapter = LocaleProviderAdapter.getResourceBundleBased();\n+        }\n+\n+        return adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+    }\n+\n@@ -995,0 +1011,8 @@\n+\n+        if (loadNumberData(locale) instanceof Object[] d &&\n+            d[0] instanceof String[] numberElements &&\n+            numberElements.length >= 14) {\n+            lenientMinusSigns = numberElements[13];\n+        } else {\n+            lenientMinusSigns = minusSignText;\n+        }\n@@ -1174,0 +1198,3 @@\n+    \/\/ Lenient minus. No need to be set by applications\n+    private transient String lenientMinusSigns;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -195,1 +195,5 @@\n- * {@code 1000} out of the String \"$1,000.00 was paid\".\n+ * {@code 1000} out of the String \"$1,000.00 was paid\". Lenient parsing also\n+ * allows loose matching of characters in the source text. For example, an\n+ * implementation of the {@code NumberFormat} class may allow matching \"−\"\n+ * (U+2212 MINUS SIGN) to the \"-\" (U+002D HYPHEN-MINUS) pattern character\n+ * when used as a negative prefix.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690 8363972\n@@ -465,0 +465,2 @@\n+                \/\/ lenient parsing. Hyphen-minus should match the localized minus sign\n+                {FORMAT_SE_SHORT, \"-8\\u00a0mn\", -8000000L, Long.class},\n@@ -506,2 +508,1 @@\n-            \/\/ Localized minus sign should be used\n-            {FORMAT_SE_SHORT, \"-8\\u00a0mn\", null},};\n+        };\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8363972\n+ * @summary Unit tests for lenient minus parsing\n+ * @modules jdk.localedata\n+ *          java.base\/java.text:+open\n+ * @run junit LenientMinusSignTest\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class LenientMinusSignTest {\n+    private static final Locale FINNISH = Locale.of(\"fi\");\n+    private static final DecimalFormatSymbols DFS =\n+        new DecimalFormatSymbols(Locale.ROOT);\n+    private static final String MINUS_PATTERN = \"\\u002D\";\n+\n+    \/\/ \"parseLenient\" data from CLDR v47. These data are subject to change\n+    private static Stream<String> minus() {\n+        return Stream.of(\n+            MINUS_PATTERN,     \/\/ \"-\" Hyphen-Minus\n+            \"\\uFF0D\",          \/\/ \"－\" Fullwidth Hyphen-Minus\n+            \"\\uFE63\",          \/\/ \"﹣\" Small Hyphen-Minus\n+            \"\\u2010\",          \/\/ \"‐\" Hyphen\n+            \"\\u2011\",          \/\/ \"‑\" Non-Breaking Hyphen\n+            \"\\u2012\",          \/\/ \"‒\" Figure Dash\n+            \"\\u2013\",          \/\/ \"–\" En Dash\n+            \"\\u2212\",          \/\/ \"−\" Minus Sign\n+            \"\\u207B\",          \/\/ \"⁻\" Superscript Minus\n+            \"\\u208B\",          \/\/ \"₋\" Subscript Minus\n+            \"\\u2796\"           \/\/ \"➖\" Heavy Minus Sign\n+        );\n+    }\n+\n+    @Test\n+    void testFinnishMinus() throws ParseException {\n+        \/\/ originally reported in JDK-8189097\n+        \/\/ Should not throw a ParseException\n+        assertEquals(NumberFormat.getInstance(FINNISH).parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    @Test\n+    void testFinnishMinusStrict() {\n+        \/\/ Should throw a ParseException\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        nf.setStrict(true);\n+        assertThrows(ParseException.class, () -> nf.parse(MINUS_PATTERN + \"1,5\"));\n+    }\n+\n+    @Test\n+    void testReadObject() throws IOException, ClassNotFoundException, ParseException {\n+        \/\/ check if deserialized NF works with lenient minus. Using the Finnish example\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        NumberFormat nfDeser;\n+        byte[] serialized;\n+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(bos)) {\n+            out.writeObject(nf);\n+            out.flush();\n+            serialized = bos.toByteArray();\n+        }\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(serialized);\n+             ObjectInputStream in = new ObjectInputStream(bis)) {\n+            nfDeser = (NumberFormat) in.readObject();\n+        }\n+        assertEquals(nfDeser.parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    \/\/ White box test. modifies the private `lenientMinusSigns` field in the DFS\n+    @Test\n+    void testSupplementary() throws IllegalAccessException, NoSuchFieldException, ParseException {\n+        var dfs = new DecimalFormatSymbols(Locale.ROOT);\n+        MethodHandles.privateLookupIn(DecimalFormatSymbols.class, MethodHandles.lookup())\n+            .findVarHandle(DecimalFormatSymbols.class, \"lenientMinusSigns\", String.class)\n+            .set(dfs, \"-🙂\");\n+        \/\/ Direct match. Should succeed\n+        var df = new DecimalFormat(\"#.#;🙂#.#\", dfs);\n+        assertEquals(df.parse(\"🙂1.5\"), -1.5);\n+\n+        \/\/ Fail if the lengths of negative prefixes differ\n+        assertThrows(ParseException.class, () -> df.parse(\"-1.5\"));\n+        var df2= new DecimalFormat(\"#.#;-#.#\", dfs);\n+        assertThrows(ParseException.class, () -> df2.parse(\"🙂1.5\"));\n+    }\n+\n+    @Nested\n+    class DecimalFormatTest {\n+        private static final String PREFIX = \"+#;-#\";\n+        private static final String SUFFIX = \"#+;#-\";\n+        private static final String LONG_PREFIX = \"pos#;-neg#\";\n+        private static final String LONG_SUFFIX = \"#pos;#neg-\";\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_PREFIX, DFS);\n+            assertEquals(MINUS_PATTERN + \"neg1\", df.format(df.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_SUFFIX, DFS);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, df.format(df.parse(\"1neg\" + sign)));\n+        }\n+    }\n+\n+    @Nested\n+    class CompactNumberFormatTest {\n+        private static final String[] PREFIX = {\"+0;-0\"};\n+        private static final String[] SUFFIX = {\"0+;0-\"};\n+        private static final String[] LONG_PREFIX = {\"pos0;-neg0\"};\n+        private static final String[] LONG_SUFFIX = {\"0pos;0neg-\"};\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_PREFIX);\n+            assertEquals(MINUS_PATTERN + \"neg1\", cnf.format(cnf.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_SUFFIX);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, cnf.format(cnf.parse( \"1neg\" + sign)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientMinusSignTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}