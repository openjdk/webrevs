{"files":[{"patch":"@@ -934,1 +934,3 @@\n-        flip_to_old_gc(r);\n+        if (!flip_to_old_gc(r)) {\n+          continue;\n+        }\n@@ -1284,2 +1286,2 @@\n-void ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n-  size_t idx = r->index();\n+bool ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n+  const size_t idx = r->index();\n@@ -1291,5 +1293,2 @@\n-  size_t region_capacity = alloc_capacity(r);\n-  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n-                                               ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n-  _partitions.assert_bounds();\n-  _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+  const size_t region_capacity = alloc_capacity(r);\n+\n@@ -1297,3 +1296,6 @@\n-  if (!transferred) {\n-    log_warning(gc, free)(\"Forcing transfer of %zu to old reserve.\", idx);\n-    gen_heap->generation_sizer()->force_transfer_to_old(1);\n+  if (transferred) {\n+    _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                 ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n+    _partitions.assert_bounds();\n+    _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+    return true;\n@@ -1301,2 +1303,38 @@\n-  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n-  \/\/ to recycle trash before attempting to allocate anything in the region.\n+\n+  if (_heap->young_generation()->free_unaffiliated_regions() == 0 && _heap->old_generation()->free_unaffiliated_regions() > 0) {\n+    \/\/ Old has free unaffiliated regions, but it couldn't use them for allocation (likely because they\n+    \/\/ are trash and weak roots are in process). In this scenario, we aren't really stealing from the\n+    \/\/ mutator (they have nothing to steal), but they do have a usable region in their partition. What\n+    \/\/ we want to do here is swap that region from the mutator partition with one from the old collector\n+    \/\/ partition.\n+    \/\/ 1. Find an unusable trash region in the old collector partition\n+    ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::OldCollector, true);\n+    idx_t unusable_trash = -1;\n+    for (unusable_trash = iterator.current(); iterator.has_next(); unusable_trash = iterator.next()) {\n+      const ShenandoahHeapRegion* region = _heap->get_region(unusable_trash);\n+      if (region->is_trash() && _heap->is_concurrent_weak_root_in_progress()) {\n+        break;\n+      }\n+    }\n+\n+    if (unusable_trash != -1) {\n+      \/\/ 2. Move it to the mutator partition\n+      _partitions.move_from_partition_to_partition(unusable_trash,\n+                                                   ShenandoahFreeSetPartitionId::OldCollector,\n+                                                   ShenandoahFreeSetPartitionId::Mutator, region_capacity);\n+\n+      \/\/ 3. Move this usable region to the old collector partition\n+      _partitions.move_from_partition_to_partition(idx,\n+                                                   ShenandoahFreeSetPartitionId::Mutator,\n+                                                   ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n+\n+      _partitions.assert_bounds();\n+\n+      \/\/ 4. Do not adjust capacities for generations, we just swapped the regions that have already\n+      \/\/ been accounted for.\n+      return true;\n+    }\n+  }\n+\n+  \/\/ We can't take this region young because it has no free unaffiliated regions (transfer failed).\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -328,1 +328,2 @@\n-  void flip_to_old_gc(ShenandoahHeapRegion* r);\n+\n+  bool flip_to_old_gc(ShenandoahHeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}