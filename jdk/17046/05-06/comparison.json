{"files":[{"patch":"@@ -1278,0 +1278,174 @@\n+static const int64_t right_32_bits = right_n_bits(32);\n+static const int64_t right_8_bits = right_n_bits(8);\n+\n+\/**\n+ * Emits code to update CRC-32 with a byte value according to constants in table\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]val       Register containing the byte to fold into the CRC.\n+ * @param [in]table     Register containing the table of crc constants.\n+ *\n+ * uint32_t crc;\n+ * val = crc_table[(val ^ crc) & 0xFF];\n+ * crc = val ^ (crc >> 8);\n+ *\n+ *\/\n+void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n+  assert_different_registers(crc, val, table);\n+\n+  xorr(val, val, crc);\n+  andi(val, val, right_8_bits);\n+  shadd(val, val, table, val, 2);\n+  lwu(val, Address(val));\n+  srli(crc, crc, 8);\n+  xorr(crc, val, crc);\n+}\n+\n+\/**\n+ * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3\n+ *\n+ * @param [in,out]crc   Register containing the crc.\n+ * @param [in]v         Register containing the 32-bit to fold into the CRC.\n+ * @param [in]table0    Register containing table 0 of crc constants.\n+ * @param [in]table1    Register containing table 1 of crc constants.\n+ * @param [in]table2    Register containing table 2 of crc constants.\n+ * @param [in]table3    Register containing table 3 of crc constants.\n+ *\n+ * uint32_t crc;\n+ *   v = crc ^ v\n+ *   crc = table3[v&0xff]^table2[(v>>8)&0xff]^table1[(v>>16)&0xff]^table0[v>>24]\n+ *\n+ *\/\n+void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2,\n+        Register table0, Register table1, Register table2, Register table3, bool upper) {\n+  assert_different_registers(crc, v, tmp1, tmp2, table0, table1, table2, table3);\n+\n+  if (upper)\n+    srli(v, v, 32);\n+  xorr(v, v, crc);\n+\n+  andi(tmp1, v, right_8_bits);\n+  shadd(tmp1, tmp1, table3, tmp2, 2);\n+  lwu(crc, Address(tmp1));\n+\n+  \/\/ In order to access table elements according to initial algorithm\n+  \/\/ the following actions should be performed (with no Zba enabled):\n+  \/\/  tmp1 = v >> 8\n+  \/\/  tmp1 = tmp1 & right_8_bits\n+  \/\/  tmp1 = tmp1 << 2\n+  \/\/  tmp1 += table2\n+  \/\/ Which is the same as:\n+  \/\/  tmp1 = v >> 6\n+  \/\/  tmp1 = tmp1 & (right_8_bits << 2)\n+  \/\/  tmp1 += table2\n+\n+  srli(tmp1, v, 6);\n+  andi(tmp1, tmp1, (right_8_bits << 2));\n+  add(tmp1, tmp1, table2);\n+  lwu(tmp2, Address(tmp1));\n+\n+  srli(tmp1, v, 14);\n+  xorr(crc, crc, tmp2);\n+\n+  andi(tmp1, tmp1, (right_8_bits << 2));\n+  add(tmp1, tmp1, table1);\n+  lwu(tmp2, Address(tmp1));\n+\n+  srli(tmp1, v, 22);\n+  xorr(crc, crc, tmp2);\n+\n+  andi(tmp1, tmp1, (right_8_bits << 2));\n+  add(tmp1, tmp1, table0);\n+  lwu(tmp2, Address(tmp1));\n+  xorr(crc, crc, tmp2);\n+}\n+\n+\/**\n+ * @param crc   register containing existing CRC (32-bit)\n+ * @param buf   register pointing to input byte buffer (byte*)\n+ * @param len   register containing number of bytes\n+ * @param table register that will contain address of CRC table\n+ * @param tmp   scratch registers\n+ *\/\n+void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {\n+  assert_different_registers(crc, buf, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5);\n+  Label L_by16_loop, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n+\n+  const int64_t unroll = 16;\n+  const int64_t unroll_words = unroll*wordSize;\n+  mv(tmp5, right_32_bits);\n+  subw(len, len, unroll_words);\n+  andn(crc, tmp5, crc);\n+\n+  const ExternalAddress table_addr = StubRoutines::crc_table_addr();\n+  la(table0, table_addr);\n+  add(table1, table0, 1*256*sizeof(juint), tmp1);\n+  add(table2, table0, 2*256*sizeof(juint), tmp1);\n+  add(table3, table2, 1*256*sizeof(juint), tmp1);\n+\n+  bge(len, zr, L_unroll_loop_entry);\n+  addiw(len, len, unroll_words-4);\n+  bge(len, zr, L_by4_loop);\n+  addiw(len, len, 4);\n+  bgt(len, zr, L_by1_loop);\n+  j(L_exit);\n+\n+  align(CodeEntryAlignment);\n+  bind(L_unroll_loop_entry);\n+    const Register buf_end = tmp3;\n+    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n+    andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n+    sub(len, len, unroll_words); \/\/ Length after all iterations\n+  bind(L_unroll_loop);\n+    for (int i = 0; i < unroll; i++) {\n+      ld(tmp1, Address(buf, i*wordSize));\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, false);\n+      update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, true);\n+    }\n+\n+    addi(buf, buf, unroll_words);\n+    ble(buf, buf_end, L_unroll_loop);\n+    addiw(len, len, unroll_words-4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    bgt(len, zr, L_by1_loop);\n+    j(L_exit);\n+\n+  bind(L_by4_loop);\n+    lwu(tmp1, Address(buf));\n+    update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, false);\n+    subw(len, len, 4);\n+    addi(buf, buf, 4);\n+    bge(len, zr, L_by4_loop);\n+    addiw(len, len, 4);\n+    ble(len, zr, L_exit);\n+\n+  bind(L_by1_loop);\n+    subw(len, len, 1);\n+    lwu(tmp1, Address(buf));\n+    andi(tmp2, tmp1, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 8);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    subw(len, len, 1);\n+    srli(tmp2, tmp1, 16);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+    ble(len, zr, L_exit);\n+\n+    srli(tmp2, tmp1, 24);\n+    andi(tmp2, tmp2, right_8_bits);\n+    update_byte_crc32(crc, tmp2, table0);\n+\n+  bind(L_exit);\n+    andn(crc, tmp5, crc);\n+}\n+\n@@ -3830,174 +4004,0 @@\n-static const int64_t right_32_bits = right_n_bits(32);\n-static const int64_t right_8_bits = right_n_bits(8);\n-\n-\/**\n- * Emits code to update CRC-32 with a byte value according to constants in table\n- *\n- * @param [in,out]crc   Register containing the crc.\n- * @param [in]val       Register containing the byte to fold into the CRC.\n- * @param [in]table     Register containing the table of crc constants.\n- *\n- * uint32_t crc;\n- * val = crc_table[(val ^ crc) & 0xFF];\n- * crc = val ^ (crc >> 8);\n- *\n- *\/\n-void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {\n-  assert_different_registers(crc, val, table);\n-\n-  xorr(val, val, crc);\n-  andi(val, val, right_8_bits);\n-  shadd(val, val, table, val, 2);\n-  lwu(val, Address(val));\n-  srli(crc, crc, 8);\n-  xorr(crc, val, crc);\n-}\n-\n-\/**\n- * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3\n- *\n- * @param [in,out]crc   Register containing the crc.\n- * @param [in]v         Register containing the 32-bit to fold into the CRC.\n- * @param [in]table0    Register containing table 0 of crc constants.\n- * @param [in]table1    Register containing table 1 of crc constants.\n- * @param [in]table2    Register containing table 2 of crc constants.\n- * @param [in]table3    Register containing table 3 of crc constants.\n- *\n- * uint32_t crc;\n- *   v = crc ^ v\n- *   crc = table3[v&0xff]^table2[(v>>8)&0xff]^table1[(v>>16)&0xff]^table0[v>>24]\n- *\n- *\/\n-void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2,\n-        Register table0, Register table1, Register table2, Register table3, bool upper) {\n-  assert_different_registers(crc, v, tmp1, tmp2, table0, table1, table2, table3);\n-\n-  if (upper)\n-    srli(v, v, 32);\n-  xorr(v, v, crc);\n-\n-  andi(tmp1, v, right_8_bits);\n-  shadd(tmp1, tmp1, table3, tmp2, 2);\n-  lwu(crc, Address(tmp1));\n-\n-  \/\/ In order to access table elements according to initial algorithm\n-  \/\/ the following actions should be performed (with no Zba enabled):\n-  \/\/  tmp1 = v >> 8\n-  \/\/  tmp1 = tmp1 & right_8_bits\n-  \/\/  tmp1 = tmp1 << 2\n-  \/\/  tmp1 += table2\n-  \/\/ Which is the same as:\n-  \/\/  tmp1 = v >> 6\n-  \/\/  tmp1 = tmp1 & (right_8_bits << 2)\n-  \/\/  tmp1 += table2\n-\n-  srli(tmp1, v, 6);\n-  andi(tmp1, tmp1, (right_8_bits << 2));\n-  add(tmp1, tmp1, table2);\n-  lwu(tmp2, Address(tmp1));\n-\n-  srli(tmp1, v, 14);\n-  xorr(crc, crc, tmp2);\n-\n-  andi(tmp1, tmp1, (right_8_bits << 2));\n-  add(tmp1, tmp1, table1);\n-  lwu(tmp2, Address(tmp1));\n-\n-  srli(tmp1, v, 22);\n-  xorr(crc, crc, tmp2);\n-\n-  andi(tmp1, tmp1, (right_8_bits << 2));\n-  add(tmp1, tmp1, table0);\n-  lwu(tmp2, Address(tmp1));\n-  xorr(crc, crc, tmp2);\n-}\n-\n-\/**\n- * @param crc   register containing existing CRC (32-bit)\n- * @param buf   register pointing to input byte buffer (byte*)\n- * @param len   register containing number of bytes\n- * @param table register that will contain address of CRC table\n- * @param tmp   scratch registers\n- *\/\n-void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,\n-        Register table0, Register table1, Register table2, Register table3,\n-        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {\n-  assert_different_registers(crc, buf, table0, table1, table2, table3, tmp1, tmp2, tmp3, tmp4, tmp5);\n-  Label L_by16_loop, L_unroll_loop, L_unroll_loop_entry, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;\n-\n-  const int64_t unroll = 16;\n-  const int64_t unroll_words = unroll*wordSize;\n-  mv(tmp5, right_32_bits);\n-  subw(len, len, unroll_words);\n-  andn(crc, tmp5, crc);\n-\n-  const ExternalAddress table_addr = StubRoutines::crc_table_addr();\n-  la(table0, table_addr);\n-  add(table1, table0, 1*256*sizeof(juint), tmp1);\n-  add(table2, table0, 2*256*sizeof(juint), tmp1);\n-  add(table3, table2, 1*256*sizeof(juint), tmp1);\n-\n-  bge(len, zr, L_unroll_loop_entry);\n-  addiw(len, len, unroll_words-4);\n-  bge(len, zr, L_by4_loop);\n-  addiw(len, len, 4);\n-  bgt(len, zr, L_by1_loop);\n-  j(L_exit);\n-\n-  align(CodeEntryAlignment);\n-  bind(L_unroll_loop_entry);\n-    const Register buf_end = tmp3;\n-    add(buf_end, buf, len); \/\/ buf_end will be used as endpoint for loop below\n-    andi(len, len, unroll_words-1); \/\/ len = (len % unroll_words)\n-    sub(len, len, unroll_words); \/\/ Length after all iterations\n-  bind(L_unroll_loop);\n-    for (int i = 0; i < unroll; i++) {\n-      ld(tmp1, Address(buf, i*wordSize));\n-      update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, false);\n-      update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, true);\n-    }\n-\n-    addi(buf, buf, unroll_words);\n-    ble(buf, buf_end, L_unroll_loop);\n-    addiw(len, len, unroll_words-4);\n-    bge(len, zr, L_by4_loop);\n-    addiw(len, len, 4);\n-    bgt(len, zr, L_by1_loop);\n-    j(L_exit);\n-\n-  bind(L_by4_loop);\n-    lwu(tmp1, Address(buf));\n-    update_word_crc32(crc, tmp1, tmp2, tmp4, table0, table1, table2, table3, false);\n-    subw(len, len, 4);\n-    addi(buf, buf, 4);\n-    bge(len, zr, L_by4_loop);\n-    addiw(len, len, 4);\n-    ble(len, zr, L_exit);\n-\n-  bind(L_by1_loop);\n-    subw(len, len, 1);\n-    lwu(tmp1, Address(buf));\n-    andi(tmp2, tmp1, right_8_bits);\n-    update_byte_crc32(crc, tmp2, table0);\n-    ble(len, zr, L_exit);\n-\n-    subw(len, len, 1);\n-    srli(tmp2, tmp1, 8);\n-    andi(tmp2, tmp2, right_8_bits);\n-    update_byte_crc32(crc, tmp2, table0);\n-    ble(len, zr, L_exit);\n-\n-    subw(len, len, 1);\n-    srli(tmp2, tmp1, 16);\n-    andi(tmp2, tmp2, right_8_bits);\n-    update_byte_crc32(crc, tmp2, table0);\n-    ble(len, zr, L_exit);\n-\n-    srli(tmp2, tmp1, 24);\n-    andi(tmp2, tmp2, right_8_bits);\n-    update_byte_crc32(crc, tmp2, table0);\n-\n-  bind(L_exit);\n-    andn(crc, tmp5, crc);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":174,"deletions":174,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -1227,0 +1227,9 @@\n+  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.\n+  void kernel_crc32(Register crc, Register buf, Register len,\n+        Register table0, Register table1, Register table2, Register table3,\n+        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);\n+  void update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2,\n+        Register table0, Register table1, Register table2, Register table3,\n+        bool upper);\n+  void update_byte_crc32(Register crc, Register val, Register table);\n+\n@@ -1257,9 +1266,0 @@\n-  \/\/ CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.\n-  void kernel_crc32(Register crc, Register buf, Register len,\n-        Register table0, Register table1, Register table2, Register table3,\n-        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);\n-  void update_word_crc32(Register crc, Register v, Register tmp1, Register tmp2,\n-        Register table0, Register table1, Register table2, Register table3,\n-        bool upper);\n-  void update_byte_crc32(Register crc, Register val, Register table);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}