{"files":[{"patch":"@@ -79,0 +79,3 @@\n+    if test \"x$OPENJDK_TARGET_CPU_BITS\" = \"x32\"; then\n+      AC_MSG_ERROR([32-bit Windows builds are not supported])\n+    fi\n","filename":"make\/autoconf\/basic.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,15 +662,0 @@\n-  PLATFORM_CHECK_DEPRECATION\n-])\n-\n-AC_DEFUN([PLATFORM_CHECK_DEPRECATION],\n-[\n-  AC_ARG_ENABLE(deprecated-ports, [AS_HELP_STRING([--enable-deprecated-ports@<:@=yes\/no@:>@],\n-      [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n-  if test \"x$OPENJDK_TARGET_OS\" = xwindows && test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n-    if test \"x$enable_deprecated_ports\" = \"xyes\"; then\n-      AC_MSG_WARN([The Windows 32-bit x86 port is deprecated and may be removed in a future release.])\n-    else\n-      AC_MSG_ERROR(m4_normalize([The Windows 32-bit x86 port is deprecated and may be removed in a future release.\n-        Use --enable-deprecated-ports=yes to suppress this error.]))\n-    fi\n-  fi\n","filename":"make\/autoconf\/platform.m4","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,3 +85,1 @@\n-      if test \"x$TARGET_CPU\" = xx86; then\n-        VCVARSFILES=\"vcvars32.bat vcvarsamd64_x86.bat\"\n-      elif test \"x$TARGET_CPU\" = xx86_64; then\n+      if test \"x$TARGET_CPU\" = xx86_64; then\n@@ -135,3 +133,1 @@\n-        if test \"x$TARGET_CPU\" = xx86; then\n-          VS_ENV_ARGS=\"\/x86\"\n-        elif test \"x$TARGET_CPU\" = xx86_64; then\n+        if test \"x$TARGET_CPU\" = xx86_64; then\n@@ -441,3 +437,1 @@\n-    if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n-      CORRECT_MSVCR_ARCH=386\n-    elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+    if test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -469,3 +463,1 @@\n-  if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n-    vs_target_cpu=x86\n-  elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -525,12 +517,2 @@\n-      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n-        POSSIBLE_MSVC_DLL=`$FIND \"$VCINSTALLDIR\" -name $DLL_NAME \\\n-        | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $GREP -v arm64 | $HEAD --lines 1`\n-        if test \"x$POSSIBLE_MSVC_DLL\" = x; then\n-          # We're grasping at straws now...\n-          POSSIBLE_MSVC_DLL=`$FIND \"$VCINSTALLDIR\" -name $DLL_NAME \\\n-          | $HEAD --lines 1`\n-        fi\n-      else\n-        POSSIBLE_MSVC_DLL=`$FIND \"$VCINSTALLDIR\" -name $DLL_NAME \\\n-        | $GREP x64 | $HEAD --lines 1`\n-      fi\n+      POSSIBLE_MSVC_DLL=`$FIND \"$VCINSTALLDIR\" -name $DLL_NAME \\\n+      | $GREP x64 | $HEAD --lines 1`\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -112,3 +112,1 @@\n-    ifeq ($(call isTargetCpuBits, 64), true)\n-      ADLCFLAGS += -D_WIN64=1\n-    endif\n+    ADLCFLAGS += -D_WIN64=1\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,5 +88,1 @@\n-  LIBAWT_CFLAGS += -EHsc -DUNICODE -D_UNICODE\n-  ifeq ($(call isTargetCpuBits, 64), true)\n-    LIBAWT_CFLAGS += -DMLIB_OS64BIT\n-  endif\n-\n+  LIBAWT_CFLAGS += -EHsc -DUNICODE -D_UNICODE -DMLIB_OS64BIT\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,4 +51,1 @@\n-  # Setup rules to create 32\/64 bit version of jaccessinspector\n-  #\n-  # Parameter 1 File name suffix\n-  # Parameter 2 ACCESSBRIDGE_ARCH_ -D suffix\n+  # Build jaccessinspector\n@@ -56,16 +53,0 @@\n-  define SetupInspector\n-    $$(eval $$(call SetupJdkExecutable, BUILD_JACCESSINSPECTOR$1, \\\n-        NAME := jaccessinspector$1, \\\n-        SRC := jaccessinspector, \\\n-        EXTRA_SRC := \\\n-            bridge \\\n-            common \\\n-            toolscommon, \\\n-        EXTRA_HEADER_DIRS := include\/bridge, \\\n-        CFLAGS := -DACCESSBRIDGE_ARCH_$2 -EHsc, \\\n-        CXXFLAGS := -DACCESSBRIDGE_ARCH_$2 -EHsc, \\\n-        LDFLAGS_windows := -stack:655360, \\\n-        LIBS_windows := advapi32.lib user32.lib, \\\n-        VERSIONINFO_RESOURCE := \\\n-            $(ACCESSIBILITY_SRCDIR)\/jaccessinspector\/jaccessinspectorWindow.rc, \\\n-    ))\n@@ -73,2 +54,16 @@\n-    TARGETS += $$(BUILD_JACCESSINSPECTOR$1)\n-  endef\n+  $(eval $(call SetupJdkExecutable, BUILD_JACCESSINSPECTOR, \\\n+      NAME := jaccessinspector, \\\n+      EXTRA_SRC := \\\n+          bridge \\\n+          common \\\n+          toolscommon, \\\n+      EXTRA_HEADER_DIRS := include\/bridge, \\\n+      CFLAGS := -DACCESSBRIDGE_ARCH_64 -EHsc, \\\n+      CXXFLAGS := -DACCESSBRIDGE_ARCH_64 -EHsc, \\\n+      LDFLAGS_windows := -stack:655360, \\\n+      LIBS_windows := advapi32.lib user32.lib, \\\n+      VERSIONINFO_RESOURCE := \\\n+          $(ACCESSIBILITY_SRCDIR)\/jaccessinspector\/jaccessinspectorWindow.rc, \\\n+  ))\n+\n+  TARGETS += $(BUILD_JACCESSINSPECTOR)\n@@ -77,3 +72,1 @@\n-  # Setup rules to create 32\/64 bit version of jaccesswalker\n-  # Parameter 1 File name suffix\n-  # Parameter 2 ACCESSBRIDGE_ARCH_ -D suffix\n+  # Build jaccesswalker\n@@ -81,16 +74,0 @@\n-  define SetupWalker\n-    $$(eval $$(call SetupJdkExecutable, BUILD_JACCESSWALKER$1, \\\n-        NAME := jaccesswalker$1, \\\n-        SRC := jaccesswalker, \\\n-        EXTRA_SRC := \\\n-            bridge \\\n-            common \\\n-            toolscommon, \\\n-        EXTRA_HEADER_DIRS := include\/bridge, \\\n-        CFLAGS := -DACCESSBRIDGE_ARCH_$2 -EHsc, \\\n-        CXXFLAGS := -DACCESSBRIDGE_ARCH_$2 -EHsc, \\\n-        LDFLAGS_windows := -stack:655360, \\\n-        LIBS_windows := advapi32.lib comctl32.lib gdi32.lib user32.lib, \\\n-        VERSIONINFO_RESOURCE := \\\n-            $(ACCESSIBILITY_SRCDIR)\/jaccesswalker\/jaccesswalkerWindow.rc, \\\n-    ))\n@@ -98,2 +75,14 @@\n-    TARGETS += $$(BUILD_JACCESSWALKER$1)\n-  endef\n+  $(eval $(call SetupJdkExecutable, BUILD_JACCESSWALKER, \\\n+      NAME := jaccesswalker, \\\n+      EXTRA_SRC := \\\n+          bridge \\\n+          common \\\n+          toolscommon, \\\n+      EXTRA_HEADER_DIRS := include\/bridge, \\\n+      CFLAGS := -DACCESSBRIDGE_ARCH_64 -EHsc, \\\n+      CXXFLAGS := -DACCESSBRIDGE_ARCH_64 -EHsc, \\\n+      LDFLAGS_windows := -stack:655360, \\\n+      LIBS_windows := advapi32.lib comctl32.lib gdi32.lib user32.lib, \\\n+      VERSIONINFO_RESOURCE := \\\n+          $(ACCESSIBILITY_SRCDIR)\/jaccesswalker\/jaccesswalkerWindow.rc, \\\n+  ))\n@@ -101,9 +90,1 @@\n-  ifeq ($(call isTargetCpuBits, 32), true)\n-    $(eval $(call SetupInspector,-32,32))\n-    $(eval $(call SetupWalker,-32,32))\n-    $(eval $(call SetupInspector,,LEGACY))\n-    $(eval $(call SetupWalker,,LEGACY))\n-  else\n-    $(eval $(call SetupInspector,,64))\n-    $(eval $(call SetupWalker,,64))\n-  endif\n+  TARGETS += $(BUILD_JACCESSWALKER)\n","filename":"make\/modules\/jdk.accessibility\/Launcher.gmk","additions":33,"deletions":52,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -34,4 +34,1 @@\n-  # Setup rules to create 32\/64 bit version of javaaccessbridge\n-  #\n-  # Parameter 1 Suffix\n-  # Parameter 2 ACCESSBRIDGE_ARCH_ suffix\n+  ## Build libjavaaccessbridge\n@@ -39,19 +36,0 @@\n-  define SetupJavaDLL\n-    $(call SetupJdkLibrary, BUILD_LIBJAVAACCESSBRIDGE$1, \\\n-        NAME := javaaccessbridge$1, \\\n-        SRC := libjavaaccessbridge, \\\n-        EXTRA_SRC := common, \\\n-        OPTIMIZATION := LOW, \\\n-        DISABLED_WARNINGS_microsoft := 4311 4302 4312, \\\n-        CXXFLAGS_FILTER_OUT := -MD, \\\n-        CXXFLAGS := -MT -DACCESSBRIDGE_ARCH_$2, \\\n-        EXTRA_HEADER_DIRS := \\\n-            include\/bridge \\\n-            java.desktop:include, \\\n-        JDK_LIBS := java.desktop:libjawt, \\\n-        LIBS_windows := advapi32.lib comdlg32.lib gdi32.lib kernel32.lib \\\n-            odbc32.lib odbccp32.lib ole32.lib oleaut32.lib shell32.lib \\\n-            user32.lib uuid.lib winspool.lib, \\\n-        VERSIONINFO_RESOURCE := \\\n-            $(ACCESSIBILITY_SRCDIR)\/common\/AccessBridgeStatusWindow.rc, \\\n-    )\n@@ -59,2 +37,19 @@\n-    TARGETS += $$(BUILD_LIBJAVAACCESSBRIDGE$1)\n-  endef\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBJAVAACCESSBRIDGE, \\\n+      NAME := javaaccessbridge, \\\n+      EXTRA_SRC := common, \\\n+      OPTIMIZATION := LOW, \\\n+      DISABLED_WARNINGS_microsoft := 4311 4302 4312, \\\n+      CXXFLAGS_FILTER_OUT := -MD, \\\n+      CXXFLAGS := -MT -DACCESSBRIDGE_ARCH_64, \\\n+      EXTRA_HEADER_DIRS := \\\n+          include\/bridge \\\n+          java.desktop:include, \\\n+      JDK_LIBS := java.desktop:libjawt, \\\n+      LIBS_windows := advapi32.lib comdlg32.lib gdi32.lib kernel32.lib \\\n+          odbc32.lib odbccp32.lib ole32.lib oleaut32.lib shell32.lib \\\n+          user32.lib uuid.lib winspool.lib, \\\n+      VERSIONINFO_RESOURCE := \\\n+          $(ACCESSIBILITY_SRCDIR)\/common\/AccessBridgeStatusWindow.rc, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBJAVAACCESSBRIDGE)\n@@ -63,4 +58,1 @@\n-  # Setup rules to create 32\/64 bit version of windowsaccessbridge\n-  #\n-  # Parameter 1 Suffix\n-  # Parameter 2 ACCESSBRIDGE_ARCH_ suffix\n+  ## Build libwindowsaccessbridge\n@@ -68,33 +60,0 @@\n-  define SetupWinDLL\n-    $(call SetupJdkLibrary, BUILD_LIBWINDOWSACCESSBRIDGE$1, \\\n-        NAME := windowsaccessbridge$1, \\\n-        SRC := libwindowsaccessbridge, \\\n-        EXTRA_SRC := common, \\\n-        OPTIMIZATION := LOW, \\\n-        DISABLED_WARNINGS_microsoft_WinAccessBridge.cpp := 4302 4311, \\\n-        CXXFLAGS := -DACCESSBRIDGE_ARCH_$2, \\\n-        EXTRA_HEADER_DIRS := \\\n-            include\/bridge, \\\n-        LDFLAGS := \\\n-            -def:$(ACCESSIBILITY_SRCDIR)\/libwindowsaccessbridge\/WinAccessBridge.DEF, \\\n-        LIBS_windows := advapi32.lib comdlg32.lib gdi32.lib kernel32.lib \\\n-            odbc32.lib odbccp32.lib ole32.lib oleaut32.lib shell32.lib \\\n-            user32.lib uuid.lib winspool.lib, \\\n-        VERSIONINFO_RESOURCE := \\\n-            $(ACCESSIBILITY_SRCDIR)\/common\/AccessBridgeStatusWindow.rc, \\\n-    )\n-\n-    TARGETS += $$(BUILD_LIBWINDOWSACCESSBRIDGE$1)\n-  endef\n-\n-  ifeq ($(call isTargetCpuBits, 32), true)\n-    ############################################################################\n-    # Build libjabsysinfo\n-    ############################################################################\n-\n-    $(eval $(call SetupJdkLibrary, BUILD_LIBJABSYSINFO, \\\n-        NAME := jabsysinfo, \\\n-        OPTIMIZATION := LOW, \\\n-        VERSIONINFO_RESOURCE := \\\n-            $(ACCESSIBILITY_SRCDIR)\/common\/AccessBridgeStatusWindow.rc, \\\n-    )\n@@ -102,2 +61,17 @@\n-    TARGETS += $(BUILD_LIBJABSYSINFO)\n-  endif\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBWINDOWSACCESSBRIDGE, \\\n+      NAME := windowsaccessbridge-64, \\\n+      SRC := libwindowsaccessbridge, \\\n+      EXTRA_SRC := common, \\\n+      OPTIMIZATION := LOW, \\\n+      DISABLED_WARNINGS_microsoft_WinAccessBridge.cpp := 4302 4311, \\\n+      CXXFLAGS := -DACCESSBRIDGE_ARCH_64, \\\n+      EXTRA_HEADER_DIRS := \\\n+          include\/bridge, \\\n+      LDFLAGS := \\\n+          -def:$(ACCESSIBILITY_SRCDIR)\/libwindowsaccessbridge\/WinAccessBridge.DEF, \\\n+      LIBS_windows := advapi32.lib comdlg32.lib gdi32.lib kernel32.lib \\\n+          odbc32.lib odbccp32.lib ole32.lib oleaut32.lib shell32.lib \\\n+          user32.lib uuid.lib winspool.lib, \\\n+      VERSIONINFO_RESOURCE := \\\n+          $(ACCESSIBILITY_SRCDIR)\/common\/AccessBridgeStatusWindow.rc, \\\n+  ))\n@@ -105,9 +79,1 @@\n-  ifeq ($(call isTargetCpuBits, 32), true)\n-    $(eval $(call SetupJavaDLL,-32,32))\n-    $(eval $(call SetupJavaDLL,,LEGACY))\n-    $(eval $(call SetupWinDLL,-32,32))\n-    $(eval $(call SetupWinDLL,,LEGACY))\n-  else\n-    $(eval $(call SetupJavaDLL,,64))\n-    $(eval $(call SetupWinDLL,-64,64))\n-  endif\n+  TARGETS += $(BUILD_LIBWINDOWSACCESSBRIDGE)\n","filename":"make\/modules\/jdk.accessibility\/Lib.gmk","additions":39,"deletions":73,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -79,20 +79,7 @@\n-  if [ \"$OPENJDK_TARGET_CPU\" = \"x86\" ]; then\n-    DIS_DIFF_FILTER=\"$SED -r \\\n-        -e 's\/^  [0-9A-F]{16}: \/\/' \\\n-        -e 's\/^  [0-9A-F]{8}: \/  <ADDR>: \/' \\\n-        -e 's\/(offset \\?\\?)_C@_.*\/\\1<SYM>\/' \\\n-        -e 's\/[@?][A-Za-z0-9_]{1,25}\/<SYM>\/' \\\n-        -e 's\/([-,+])[0-9A-F]{2,16}\/\\1<HEXSTR>\/g' \\\n-        -e 's\/\\[[0-9A-F]{4,16}h\\]\/[<HEXSTR>]\/' \\\n-        -e 's\/: ([a-z]{2}[a-z ]{2})        [0-9A-F]{2,16}h?$\/: \\1        <HEXSTR>\/' \\\n-        -e 's\/_20[0-9]{2}_[0-1][0-9]_[0-9]{2}\/_<DATE>\/' \\\n-        \"\n-  elif [ \"$OPENJDK_TARGET_CPU\" = \"x86_64\" ]; then\n-    DIS_DIFF_FILTER=\"$SED -r \\\n-        -e 's\/^  [0-9A-F]{16}: \/\/' \\\n-        -e 's\/\\[[0-9A-F]{4,16}h\\]\/[<HEXSTR>]\/' \\\n-        -e 's\/([,+])[0-9A-F]{2,16}h\/\\1<HEXSTR>\/' \\\n-        -e 's\/([a-z]{2}[a-z ]{2})        [0-9A-F]{4,16}$\/\\1        <HEXSTR>\/' \\\n-        -e 's\/\\[\\?\\?_C@_.*\/[<SYM>]\/' \\\n-        \"\n-  fi\n+  DIS_DIFF_FILTER=\"$SED -r \\\n+      -e 's\/^  [0-9A-F]{16}: \/\/' \\\n+      -e 's\/\\[[0-9A-F]{4,16}h\\]\/[<HEXSTR>]\/' \\\n+      -e 's\/([,+])[0-9A-F]{2,16}h\/\\1<HEXSTR>\/' \\\n+      -e 's\/([a-z]{2}[a-z ]{2})        [0-9A-F]{4,16}$\/\\1        <HEXSTR>\/' \\\n+      -e 's\/\\[\\?\\?_C@_.*\/[<SYM>]\/' \\\n+      \"\n@@ -1470,5 +1457,1 @@\n-            if [ \"$OPENJDK_TARGET_CPU\" = \"x86_64\" ]; then\n-                JGSS_WINDOWS_BIN=\"jgss-windows-x64-bin.zip\"\n-            else\n-                JGSS_WINDOWS_BIN=\"jgss-windows-i586-bin.zip\"\n-            fi\n+            JGSS_WINDOWS_BIN=\"jgss-windows-x64-bin.zip\"\n","filename":"make\/scripts\/compare.sh","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -39,11 +39,0 @@\n-#ifdef _WINDOWS\n-GetBooleanField_t JNI_FastGetField::jni_fast_GetBooleanField_fp;\n-GetByteField_t    JNI_FastGetField::jni_fast_GetByteField_fp;\n-GetCharField_t    JNI_FastGetField::jni_fast_GetCharField_fp;\n-GetShortField_t   JNI_FastGetField::jni_fast_GetShortField_fp;\n-GetIntField_t     JNI_FastGetField::jni_fast_GetIntField_fp;\n-GetLongField_t    JNI_FastGetField::jni_fast_GetLongField_fp;\n-GetFloatField_t   JNI_FastGetField::jni_fast_GetFloatField_fp;\n-GetDoubleField_t  JNI_FastGetField::jni_fast_GetDoubleField_fp;\n-#endif\n-\n@@ -122,1 +111,0 @@\n-#ifndef _WINDOWS\n@@ -124,4 +112,0 @@\n-#else\n-  \/\/ __stdcall calling convention\n-  __ ret (3*wordSize);\n-#endif\n@@ -145,1 +129,0 @@\n-#ifndef _WINDOWS\n@@ -147,10 +130,0 @@\n-#else\n-  switch (type) {\n-  case T_BOOLEAN: jni_fast_GetBooleanField_fp = (GetBooleanField_t) fast_entry; break;\n-  case T_BYTE:    jni_fast_GetByteField_fp    = (GetByteField_t)    fast_entry; break;\n-  case T_CHAR:    jni_fast_GetCharField_fp    = (GetCharField_t)    fast_entry; break;\n-  case T_SHORT:   jni_fast_GetShortField_fp   = (GetShortField_t)   fast_entry; break;\n-  case T_INT:     jni_fast_GetIntField_fp     = (GetIntField_t)     fast_entry; break;\n-  }\n-  return os::win32::fast_jni_accessor_wrapper(type);\n-#endif\n@@ -241,1 +214,0 @@\n-#ifndef _WINDOWS\n@@ -243,4 +215,0 @@\n-#else\n-  \/\/ __stdcall calling convention\n-  __ ret (3*wordSize);\n-#endif\n@@ -258,1 +226,0 @@\n-#ifndef _WINDOWS\n@@ -260,4 +227,0 @@\n-#else\n-  jni_fast_GetLongField_fp = (GetLongField_t) fast_entry;\n-  return os::win32::fast_jni_accessor_wrapper(T_LONG);\n-#endif\n@@ -333,1 +296,0 @@\n-#ifndef _WINDOWS\n@@ -335,4 +297,0 @@\n-#else\n-  \/\/ __stdcall calling convention\n-  __ ret (3*wordSize);\n-#endif\n@@ -357,1 +315,0 @@\n-#ifndef _WINDOWS\n@@ -359,7 +316,0 @@\n-#else\n-  switch (type) {\n-  case T_FLOAT:  jni_fast_GetFloatField_fp  = (GetFloatField_t)  fast_entry; break;\n-  case T_DOUBLE: jni_fast_GetDoubleField_fp = (GetDoubleField_t) fast_entry; break;\n-  }\n-  return os::win32::fast_jni_accessor_wrapper(type);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1427,8 +1427,0 @@\n-  \/\/\n-  \/\/ ****************************************************************************\n-  \/\/ WARNING - on Windows Java Natives use pascal calling convention and pop the\n-  \/\/ arguments off of the stack after the jni call. Before the call we can use\n-  \/\/ instructions that are SP relative. After the jni call we switch to FP\n-  \/\/ relative instructions instead of re-adjusting the stack on windows.\n-  \/\/ ****************************************************************************\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -699,8 +699,0 @@\n-void os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n-  \/\/ no prefix required\n-}\n-\n-void os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n-  \/\/ no suffix required\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  #define __CPU__ i486\n+  #define __CPU__ unknown\n@@ -285,5 +285,0 @@\n-#ifndef _WIN64\n-\/\/ previous UnhandledExceptionFilter, if there is one\n-static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = nullptr;\n-#endif\n-\n@@ -402,5 +397,0 @@\n-#ifndef _WIN64\n-  \/\/ set our UnhandledExceptionFilter and save any previous one\n-  prev_uef_handler = SetUnhandledExceptionFilter(Uncaught_Exception_Handler);\n-#endif\n-\n@@ -1552,1 +1542,1 @@\n-#ifdef _WIN64\n+\n@@ -1574,1 +1564,0 @@\n-#endif\n@@ -1752,1 +1741,0 @@\n-    {IMAGE_FILE_MACHINE_I386,      (char*)\"IA 32\"},\n@@ -1760,2 +1748,0 @@\n-#elif (defined _M_IX86)\n-  static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;\n@@ -1764,1 +1750,1 @@\n-         is defined :_M_AMD64 or _M_IX86 or _M_ARM64\n+         is defined :_M_AMD64 or _M_ARM64\n@@ -2104,7 +2090,0 @@\n-\n-    \/\/ on 32bit Total\/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)\n-#if defined(_M_IX86)\n-    st->print(\", user-mode portion of virtual address-space \" INT64_FORMAT \"M \",\n-             (int64_t) ms.ullTotalVirtual >> 20);\n-    st->print(\"(\" INT64_FORMAT \"M free)\", (int64_t) ms.ullAvailVirtual >> 20);\n-#endif\n@@ -2231,13 +2210,0 @@\n-void os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n-#ifndef _WIN64\n-  st->print(\"_\");\n-#endif\n-}\n-\n-\n-void os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n-#ifndef _WIN64\n-  st->print(\"@%d\", args_size  * sizeof(int));\n-#endif\n-}\n-\n@@ -2468,2 +2434,0 @@\n-#elif defined(_M_IX86)\n-  #define PC_NAME Eip\n@@ -2592,11 +2556,0 @@\n-#else\n-  PCONTEXT ctx = exceptionInfo->ContextRecord;\n-  address pc = (address)ctx->Eip;\n-  guarantee(pc[0] == 0xF7, \"not an idiv opcode(0xF7), the actual value = 0x%x\", pc[1]);\n-  guarantee((pc[1] & ~0x7) == 0xF8, \"cannot handle non-register operands, the actual value = 0x%x\", pc[1]);\n-  guarantee(ctx->Eax == min_jint, \"unexpected idiv exception, the actual value = %d while the expected is %d\", ctx->Eax, min_jint);\n-  \/\/ set correct result values and continue after idiv instruction\n-  ctx->Eip = (DWORD)pc + 2;        \/\/ idiv reg, reg  is 2 bytes\n-  ctx->Eax = (DWORD)min_jint;      \/\/ result\n-  ctx->Edx = (DWORD)0;             \/\/ remainder\n-  \/\/ Continue the execution\n@@ -2607,1 +2560,1 @@\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2622,10 +2575,0 @@\n-#ifndef  _WIN64\n-    jint fp_control_word = (* (jint*) StubRoutines::x86::addr_fpu_cntrl_wrd_std());\n-    if (fp_control_word != ctx->FloatSave.ControlWord) {\n-      \/\/ Restore FPCW and mask out FLT exceptions\n-      ctx->FloatSave.ControlWord = fp_control_word | 0xffffffc0;\n-      \/\/ Mask out pending FLT exceptions\n-      ctx->FloatSave.StatusWord &=  0xffffff00;\n-      return true;\n-    }\n-#else \/\/ !_WIN64\n@@ -2642,1 +2585,0 @@\n-#endif \/\/ !_WIN64\n@@ -2650,17 +2592,0 @@\n-#ifndef _WIN64\n-static LONG WINAPI Uncaught_Exception_Handler(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  if (handle_FLT_exception(exceptionInfo)) {\n-    return EXCEPTION_CONTINUE_EXECUTION;\n-  }\n-\n-  \/\/ we only override this on 32 bits, so only check it there\n-  if (prev_uef_handler != nullptr) {\n-    \/\/ We didn't handle this exception so pass it to the previous\n-    \/\/ UnhandledExceptionFilter.\n-    return (prev_uef_handler)(exceptionInfo);\n-  }\n-\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-#endif\n-\n@@ -2686,1 +2611,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+  #error unknown architecture\n@@ -2690,81 +2615,1 @@\n-#ifndef _WIN64\n-  \/\/ Execution protection violation - win32 running on AMD64 only\n-  \/\/ Handled first to avoid misdiagnosis as a \"normal\" access violation;\n-  \/\/ This is safe to do because we have a new\/unique ExceptionInformation\n-  \/\/ code for this condition.\n-  if (exception_code == EXCEPTION_ACCESS_VIOLATION) {\n-    int exception_subcode = (int) exception_record->ExceptionInformation[0];\n-    address addr = (address) exception_record->ExceptionInformation[1];\n-\n-    if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {\n-      size_t page_size = os::vm_page_size();\n-\n-      \/\/ Make sure the pc and the faulting address are sane.\n-      \/\/\n-      \/\/ If an instruction spans a page boundary, and the page containing\n-      \/\/ the beginning of the instruction is executable but the following\n-      \/\/ page is not, the pc and the faulting address might be slightly\n-      \/\/ different - we still want to unguard the 2nd page in this case.\n-      \/\/\n-      \/\/ 15 bytes seems to be a (very) safe value for max instruction size.\n-      bool pc_is_near_addr =\n-        (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n-      bool instr_spans_page_boundary =\n-        (align_down((intptr_t) pc ^ (intptr_t) addr,\n-                         (intptr_t) page_size) > 0);\n-\n-      if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n-        static volatile address last_addr =\n-          (address) os::non_memory_address_word();\n-\n-        \/\/ In conservative mode, don't unguard unless the address is in the VM\n-        if (UnguardOnExecutionViolation > 0 && addr != last_addr &&\n-            (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n-\n-          \/\/ Set memory to RWX and retry\n-          address page_start = align_down(addr, page_size);\n-          bool res = os::protect_memory((char*) page_start, page_size,\n-                                        os::MEM_PROT_RWX);\n-\n-          log_debug(os)(\"Execution protection violation \"\n-                        \"at \" INTPTR_FORMAT\n-                        \", unguarding \" INTPTR_FORMAT \": %s\", p2i(addr),\n-                        p2i(page_start), (res ? \"success\" : os::strerror(errno)));\n-\n-          \/\/ Set last_addr so if we fault again at the same address, we don't\n-          \/\/ end up in an endless loop.\n-          \/\/\n-          \/\/ There are two potential complications here.  Two threads trapping\n-          \/\/ at the same address at the same time could cause one of the\n-          \/\/ threads to think it already unguarded, and abort the VM.  Likely\n-          \/\/ very rare.\n-          \/\/\n-          \/\/ The other race involves two threads alternately trapping at\n-          \/\/ different addresses and failing to unguard the page, resulting in\n-          \/\/ an endless loop.  This condition is probably even more unlikely\n-          \/\/ than the first.\n-          \/\/\n-          \/\/ Although both cases could be avoided by using locks or thread\n-          \/\/ local last_addr, these solutions are unnecessary complication:\n-          \/\/ this handler is a best-effort safety net, not a complete solution.\n-          \/\/ It is disabled by default and should only be used as a workaround\n-          \/\/ in case we missed any no-execute-unsafe VM code.\n-\n-          last_addr = addr;\n-\n-          return EXCEPTION_CONTINUE_EXECUTION;\n-        }\n-      }\n-\n-      \/\/ Last unguard failed or not unguarding\n-      tty->print_raw_cr(\"Execution protection violation\");\n-#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n-      report_error(t, exception_code, addr, exception_record,\n-                   exceptionInfo->ContextRecord);\n-#endif\n-      return EXCEPTION_CONTINUE_SEARCH;\n-    }\n-  }\n-#endif \/\/ _WIN64\n-\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2845,1 +2690,0 @@\n-#ifdef _WIN64\n@@ -2854,1 +2698,0 @@\n-#endif\n@@ -2865,1 +2708,0 @@\n-#ifdef _WIN64\n@@ -2873,1 +2715,0 @@\n-#endif\n@@ -2926,1 +2767,1 @@\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2970,1 +2811,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+  #error unknown architecture\n@@ -3012,57 +2853,0 @@\n-#ifndef _WIN64\n-\/\/ Special care for fast JNI accessors.\n-\/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in and\n-\/\/ the heap gets shrunk before the field access.\n-\/\/ Need to install our own structured exception handler since native code may\n-\/\/ install its own.\n-LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n-  if (exception_code == EXCEPTION_ACCESS_VIOLATION) {\n-    address pc = (address) exceptionInfo->ContextRecord->Eip;\n-    address addr = JNI_FastGetField::find_slowcase_pc(pc);\n-    if (addr != (address)-1) {\n-      return Handle_Exception(exceptionInfo, addr);\n-    }\n-  }\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-\n-#define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \\\n-  Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \\\n-                                                     jobject obj,           \\\n-                                                     jfieldID fieldID) {    \\\n-    __try {                                                                 \\\n-      return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \\\n-                                                                 obj,       \\\n-                                                                 fieldID);  \\\n-    } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \\\n-                                              _exception_info())) {         \\\n-    }                                                                       \\\n-    return 0;                                                               \\\n-  }\n-\n-DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)\n-DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)\n-DEFINE_FAST_GETFIELD(jchar,    char,   Char)\n-DEFINE_FAST_GETFIELD(jshort,   short,  Short)\n-DEFINE_FAST_GETFIELD(jint,     int,    Int)\n-DEFINE_FAST_GETFIELD(jlong,    long,   Long)\n-DEFINE_FAST_GETFIELD(jfloat,   float,  Float)\n-DEFINE_FAST_GETFIELD(jdouble,  double, Double)\n-\n-address os::win32::fast_jni_accessor_wrapper(BasicType type) {\n-  switch (type) {\n-  case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;\n-  case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;\n-  case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;\n-  case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;\n-  case T_INT:     return (address)jni_fast_GetIntField_wrapper;\n-  case T_LONG:    return (address)jni_fast_GetLongField_wrapper;\n-  case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;\n-  case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;\n-  default:        ShouldNotReachHere();\n-  }\n-  return (address)-1;\n-}\n-#endif\n-\n@@ -3344,6 +3128,1 @@\n-#if defined(IA32)\n-  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n-    WARN(\"JVM cannot use large pages bigger than 4mb.\");\n-    return 0;\n-  }\n-#elif defined(AMD64)\n+#if defined(AMD64)\n@@ -3433,1 +3212,0 @@\n-#ifdef _LP64\n@@ -3436,4 +3214,0 @@\n-#else\n-  HANDLE fileMapping = CreateFileMapping(fh, nullptr, PAGE_READWRITE,\n-    0, (DWORD)size, nullptr);\n-#endif\n@@ -4621,26 +4395,0 @@\n-#ifndef PRODUCT\n-#ifndef _WIN64\n-\/\/ Helpers to check whether NX protection is enabled\n-int nx_exception_filter(_EXCEPTION_POINTERS *pex) {\n-  if (pex->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION &&\n-      pex->ExceptionRecord->NumberParameters > 0 &&\n-      pex->ExceptionRecord->ExceptionInformation[0] ==\n-      EXCEPTION_INFO_EXEC_VIOLATION) {\n-    return EXCEPTION_EXECUTE_HANDLER;\n-  }\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-\n-void nx_check_protection() {\n-  \/\/ If NX is enabled we'll get an exception calling into code on the stack\n-  char code[] = { (char)0xC3 }; \/\/ ret\n-  void *code_ptr = (void *)code;\n-  __try {\n-    __asm call code_ptr\n-  } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {\n-    tty->print_raw_cr(\"NX protection detected.\");\n-  }\n-}\n-#endif \/\/ _WIN64\n-#endif \/\/ PRODUCT\n-\n@@ -4684,1 +4432,0 @@\n-#ifdef _LP64\n@@ -4686,3 +4433,0 @@\n-#else\n-size_t os::_vm_internal_thread_min_stack_allowed = (48 DEBUG_ONLY(+ 4)) * K;\n-#endif \/\/ _LP64\n@@ -4716,10 +4460,0 @@\n-  \/\/ for debugging float code generation bugs\n-#if defined(ASSERT) && !defined(_WIN64)\n-  static long fp_control_word = 0;\n-  __asm { fstcw fp_control_word }\n-  \/\/ see Intel PPro Manual, Vol. 2, p 7-16\n-  const long invalid   = 0x01;\n-  fp_control_word |= invalid;\n-  __asm { fldcw fp_control_word }\n-#endif\n-\n@@ -4749,5 +4483,0 @@\n-#ifndef _WIN64\n-  \/\/ Print something if NX is enabled (win32 on AMD64)\n-  NOT_PRODUCT(if (PrintMiscellaneous && Verbose) nx_check_protection());\n-#endif\n-\n@@ -6009,7 +5738,0 @@\n-\/\/ WINDOWS CONTEXT Flags for THREAD_SAMPLING\n-#if defined(IA32)\n-  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)\n-#elif defined(AMD64) || defined(_M_ARM64)\n-  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)\n-#endif\n-\n@@ -6060,1 +5782,1 @@\n-    ctxt.ContextFlags = sampling_context_flags;\n+    ctxt.ContextFlags = (CONTEXT_FULL | CONTEXT_FLOATING_POINT);\n@@ -6290,1 +6012,1 @@\n-  static const int num_words = LP64_ONLY(3) NOT_LP64(6);\n+  static const int num_words = 3;\n@@ -6333,2 +6055,1 @@\n-      st->print_raw(NOT_LP64 (\"                 \")\n-                    LP64_ONLY(\"                         \"));\n+      st->print_raw(\"                         \");\n@@ -6434,1 +6155,1 @@\n-      static const address end_virt = (address)(LP64_ONLY(0x7ffffffffffULL) NOT_LP64(3*G));\n+      static const address end_virt = (address)(0x7ffffffffffULL);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":13,"deletions":292,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -149,5 +149,0 @@\n-#ifndef _WIN64\n-  \/\/ A wrapper to install a structured exception handler for fast JNI accessors.\n-  static address fast_jni_accessor_wrapper(BasicType);\n-#endif\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#ifdef _WIN64\n@@ -161,2 +160,0 @@\n-\n-#endif\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,75 +114,0 @@\n-#ifndef AMD64\n-\n-#pragma warning(disable: 4035) \/\/ Disables warnings reporting missing return statement\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile T dest;\n-  volatile T* pdest = &dest;\n-  __asm {\n-    mov eax, src\n-    fild     qword ptr [eax]\n-    mov eax, pdest\n-    fistp    qword ptr [eax]\n-  }\n-  return dest;\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile T* src = &store_value;\n-  __asm {\n-    mov eax, src\n-    fild     qword ptr [eax]\n-    mov eax, dest\n-    fistp    qword ptr [eax]\n-  }\n-}\n-\n-#pragma warning(default: 4035) \/\/ Enables warnings reporting missing return statement\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<1, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm {\n-      mov edx, p;\n-      mov al, v;\n-      xchg al, byte ptr [edx];\n-    }\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<2, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm {\n-      mov edx, p;\n-      mov ax, v;\n-      xchg ax, word ptr [edx];\n-    }\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<4, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm {\n-      mov edx, p;\n-      mov eax, v;\n-      xchg eax, dword ptr [edx];\n-    }\n-  }\n-};\n-#endif \/\/ AMD64\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/atomic_windows_x86.hpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#ifdef AMD64\n@@ -58,27 +57,0 @@\n-#else\n-  \/\/ Guarantee use of fild\/fistp or xmm regs via some asm code, because compilers won't.\n-  __asm {\n-    mov    eax, from;\n-    mov    edx, to;\n-    mov    ecx, count;\n-    cmp    eax, edx;\n-    jbe    downtest;\n-    jmp    uptest;\n-  up:\n-    fild   qword ptr [eax];\n-    fistp  qword ptr [edx];\n-    add    eax, 8;\n-    add    edx, 8;\n-  uptest:\n-    sub    ecx, 1;\n-    jge    up;\n-    jmp    done;\n-  down:\n-    fild   qword ptr [eax][ecx*8];\n-    fistp  qword ptr [edx][ecx*8];\n-  downtest:\n-    sub    ecx, 1;\n-    jge    down;\n-  done:;\n-  }\n-#endif \/\/ AMD64\n@@ -92,1 +64,0 @@\n-#ifdef AMD64\n@@ -94,3 +65,0 @@\n-#else\n-  pd_conjoint_bytes(from, to, count);\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/copy_windows_x86.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#ifdef AMD64\n@@ -53,5 +52,0 @@\n-#else\n-  __asm {\n-    lock add dword ptr [esp], 0;\n-  }\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/orderAccess_windows_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-#ifdef AMD64\n@@ -63,5 +62,0 @@\n-#else\n-#define REG_SP Esp\n-#define REG_FP Ebp\n-#define REG_PC Eip\n-#endif \/\/ AMD64\n@@ -75,38 +69,0 @@\n-\n-#ifndef AMD64\n-    \/\/ We store the current thread in this wrapperthread location\n-    \/\/ and determine how far away this address is from the structured\n-    \/\/ exception pointer that FS:[0] points to.  This get_thread\n-    \/\/ code can then get the thread pointer via FS.\n-    \/\/\n-    \/\/ Warning:  This routine must NEVER be inlined since we'd end up with\n-    \/\/           multiple offsets.\n-    \/\/\n-    volatile Thread* wrapperthread = thread;\n-\n-    if (os::win32::get_thread_ptr_offset() == 0) {\n-      int thread_ptr_offset;\n-      __asm {\n-        lea eax, dword ptr wrapperthread;\n-        sub eax, dword ptr FS:[0H];\n-        mov thread_ptr_offset, eax\n-      };\n-      os::win32::set_thread_ptr_offset(thread_ptr_offset);\n-    }\n-#ifdef ASSERT\n-    \/\/ Verify that the offset hasn't changed since we initially captured\n-    \/\/ it. This might happen if we accidentally ended up with an\n-    \/\/ inlined version of this routine.\n-    else {\n-      int test_thread_ptr_offset;\n-      __asm {\n-        lea eax, dword ptr wrapperthread;\n-        sub eax, dword ptr FS:[0H];\n-        mov test_thread_ptr_offset, eax\n-      };\n-      assert(test_thread_ptr_offset == os::win32::get_thread_ptr_offset(),\n-             \"thread pointer offset from SEH changed\");\n-    }\n-#endif \/\/ ASSERT\n-#endif \/\/ !AMD64\n-\n@@ -119,2 +75,0 @@\n-#ifdef AMD64\n-\n@@ -160,1 +114,0 @@\n-#endif \/\/ AMD64\n@@ -170,2 +123,0 @@\n-#ifdef AMD64\n-\n@@ -209,1 +160,0 @@\n-#endif \/\/ AMD64\n@@ -337,14 +287,0 @@\n-#ifndef AMD64\n-\/\/ Ignore \"C4172: returning address of local variable or temporary\" on 32bit\n-PRAGMA_DIAG_PUSH\n-PRAGMA_DISABLE_MSVC_WARNING(4172)\n-\/\/ Returns an estimate of the current stack pointer. Result must be guaranteed\n-\/\/ to point into the calling threads stack, and be no lower than the current\n-\/\/ stack pointer.\n-address os::current_stack_pointer() {\n-  int dummy;\n-  address sp = (address)&dummy;\n-  return sp;\n-}\n-PRAGMA_DIAG_POP\n-#else\n@@ -359,1 +295,0 @@\n-#endif\n@@ -417,1 +352,0 @@\n-#ifdef AMD64\n@@ -440,14 +374,0 @@\n-#else\n-  st->print(  \"EAX=\" INTPTR_FORMAT, uc->Eax);\n-  st->print(\", EBX=\" INTPTR_FORMAT, uc->Ebx);\n-  st->print(\", ECX=\" INTPTR_FORMAT, uc->Ecx);\n-  st->print(\", EDX=\" INTPTR_FORMAT, uc->Edx);\n-  st->cr();\n-  st->print(  \"ESP=\" INTPTR_FORMAT, uc->Esp);\n-  st->print(\", EBP=\" INTPTR_FORMAT, uc->Ebp);\n-  st->print(\", ESI=\" INTPTR_FORMAT, uc->Esi);\n-  st->print(\", EDI=\" INTPTR_FORMAT, uc->Edi);\n-  st->cr();\n-  st->print(  \"EIP=\" INTPTR_FORMAT, uc->Eip);\n-  st->print(\", EFLAGS=\" INTPTR_FORMAT, uc->EFlags);\n-#endif \/\/ AMD64\n@@ -476,1 +396,1 @@\n-  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  const int register_count = 16;\n@@ -489,1 +409,0 @@\n-#ifdef AMD64\n@@ -506,10 +425,0 @@\n-#else\n-    CASE_PRINT_REG(0, \"EAX=\", Eax); break;\n-    CASE_PRINT_REG(1, \"EBX=\", Ebx); break;\n-    CASE_PRINT_REG(2, \"ECX=\", Ecx); break;\n-    CASE_PRINT_REG(3, \"EDX=\", Edx); break;\n-    CASE_PRINT_REG(4, \"ESP=\", Esp); break;\n-    CASE_PRINT_REG(5, \"EBP=\", Ebp); break;\n-    CASE_PRINT_REG(6, \"ESI=\", Esi); break;\n-    CASE_PRINT_REG(7, \"EDI=\", Edi); break;\n-#endif \/\/ AMD64\n@@ -523,1 +432,0 @@\n-#ifdef AMD64\n@@ -525,9 +433,0 @@\n-#else\n-   \/\/ pause == rep:nop\n-   \/\/ On systems that don't support pause a rep:nop\n-   \/\/ is executed as a nop.  The rep: prefix is ignored.\n-   _asm {\n-      pause ;\n-   };\n-   return 1 ;\n-#endif \/\/ AMD64\n@@ -555,4 +454,0 @@\n-#ifndef AMD64\n-  int fpu_cntrl_word = StubRoutines::x86::fpu_cntrl_wrd_std();\n-  __asm fldcw fpu_cntrl_word;\n-#endif \/\/ !AMD64\n@@ -563,1 +458,0 @@\n-#ifdef AMD64\n@@ -569,1 +463,0 @@\n-#endif\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":1,"deletions":108,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#ifdef AMD64\n@@ -37,1 +36,0 @@\n-#endif\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-\n-#ifdef AMD64\n@@ -57,2 +55,0 @@\n-#endif \/\/ AMD64\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/unwind_windows_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-#ifdef _WIN64\n@@ -52,3 +51,0 @@\n-#else\n-typedef int intptr_t;\n-#endif\n@@ -59,1 +55,0 @@\n-#ifdef _WIN64\n@@ -61,3 +56,0 @@\n-#else\n-typedef unsigned int uintptr_t;\n-#endif\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -494,1 +494,0 @@\n-#if !defined(_WIN32) || defined(_WIN64)\n@@ -498,1 +497,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -415,6 +415,0 @@\n-#if defined(_WIN32) && !defined(_WIN64)\n-    if (_to_java_string_fn == nullptr) {\n-      \/\/ On 32 bit Windows, also try __stdcall decorated name\n-      _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, \"_JNU_NewStringPlatform@8\"));\n-    }\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2574,1 +2574,0 @@\n-      os::print_jni_name_prefix_on(&st, args_size);\n@@ -2576,1 +2575,0 @@\n-      os::print_jni_name_suffix_on(&st, args_size);\n@@ -2585,1 +2583,0 @@\n-        os::print_jni_name_prefix_on(&st, args_size);\n@@ -2588,1 +2585,0 @@\n-        os::print_jni_name_suffix_on(&st, args_size);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,11 +74,0 @@\n-#if defined(_WINDOWS) && !defined(_WIN64)\n-  static GetBooleanField_t jni_fast_GetBooleanField_fp;\n-  static GetByteField_t    jni_fast_GetByteField_fp;\n-  static GetCharField_t    jni_fast_GetCharField_fp;\n-  static GetShortField_t   jni_fast_GetShortField_fp;\n-  static GetIntField_t     jni_fast_GetIntField_fp;\n-  static GetLongField_t    jni_fast_GetLongField_fp;\n-  static GetFloatField_t   jni_fast_GetFloatField_fp;\n-  static GetDoubleField_t  jni_fast_GetDoubleField_fp;\n-#endif\n-\n","filename":"src\/hotspot\/share\/prims\/jniFastGetField.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-#if defined(_LP64) || defined(_WIN64)\n+#if defined(_LP64)\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-address NativeLookup::lookup_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, bool os_style, TRAPS) {\n+address NativeLookup::lookup_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, TRAPS) {\n@@ -255,1 +255,1 @@\n-  const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);\n+  const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size);\n@@ -309,1 +309,1 @@\n-const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style) {\n+const char* NativeLookup::compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size) {\n@@ -311,4 +311,0 @@\n-  if (os_style) {\n-    os::print_jni_name_prefix_on(&st, args_size);\n-  }\n-\n@@ -317,3 +313,0 @@\n-  if (os_style) {\n-    os::print_jni_name_suffix_on(&st, args_size);\n-  }\n@@ -342,1 +335,1 @@\n-  entry = lookup_style(method, pure_name, \"\",        args_size, true,  CHECK_NULL);\n+  entry = lookup_style(method, pure_name, \"\",        args_size, CHECK_NULL);\n@@ -354,1 +347,1 @@\n-  entry = lookup_style(method, pure_name, long_name, args_size, true,  CHECK_NULL);\n+  entry = lookup_style(method, pure_name, long_name, args_size, CHECK_NULL);\n@@ -358,1 +351,1 @@\n-  entry = lookup_style(method, pure_name, \"\",        args_size, false, CHECK_NULL);\n+  entry = lookup_style(method, pure_name, \"\",        args_size, CHECK_NULL);\n@@ -361,3 +354,0 @@\n-  \/\/ 4) Try JNI long style without os prefix\/suffix\n-  entry = lookup_style(method, pure_name, long_name, args_size, false, CHECK_NULL);\n-\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static address lookup_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, bool os_style, TRAPS);\n+  static address lookup_style(const methodHandle& method, char* pure_name, const char* long_name, int args_size, TRAPS);\n@@ -42,1 +42,1 @@\n-  static const char* compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size, bool os_style);\n+  static const char* compute_complete_jni_name(const char* pure_name, const char* long_name, int args_size);\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -885,4 +885,0 @@\n-  \/\/ JNI names\n-  static void     print_jni_name_prefix_on(outputStream* st, int args_size);\n-  static void     print_jni_name_suffix_on(outputStream* st, int args_size);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,5 @@\n+\/\/ Only 64-bit Windows is supported\n+#ifndef _LP64\n+#error unsupported platform\n+#endif\n+\n@@ -64,1 +69,0 @@\n-#ifdef _LP64\n@@ -70,5 +74,0 @@\n-#else\n-#ifndef NULL\n-#define NULL 0\n-#endif\n-#endif\n@@ -82,1 +81,0 @@\n-#ifdef _WIN64\n@@ -84,3 +82,0 @@\n-#else\n-typedef int32_t ssize_t;\n-#endif\n@@ -123,1 +118,0 @@\n-#ifdef _LP64\n@@ -126,4 +120,0 @@\n-#else\n-#define SSIZE_MIN INT_MIN\n-#define SSIZE_MAX INT_MAX\n-#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,5 +31,0 @@\n-#ifndef _WIN64\n-typedef int intptr_t;\n-typedef unsigned int uintptr_t;\n-typedef unsigned long DWORD_PTR, *PDWORD_PTR;\n-#endif\n","filename":"src\/java.base\/windows\/native\/libjava\/gdefs_md.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -555,2 +555,0 @@\n-#elif defined(_X86_)\n-        sprops.os_arch = \"x86\";\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-#ifdef _WIN64\n@@ -69,6 +68,0 @@\n-#else\n-\/* Double casting to avoid warning messages looking for casting of *\/\n-\/* smaller sizes into pointers *\/\n-#define jlong_to_ptr(a) ((void*)(int)(a))\n-#define ptr_to_jlong(a) ((jlong)(int)(a))\n-#endif\n","filename":"src\/java.base\/windows\/native\/libjava\/jlong_md.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-#ifdef _WIN64\n@@ -74,1 +73,0 @@\n-#endif\n@@ -124,1 +122,0 @@\n-#ifdef _WIN64\n@@ -145,3 +142,0 @@\n-#else\n-    (*env)->SetIntArrayRegion(env, returnReadFds, 0,\n-                              readfds->fd_count + 1, (jint *)readfds);\n@@ -149,5 +143,0 @@\n-    (*env)->SetIntArrayRegion(env, returnWriteFds, 0,\n-                              writefds->fd_count + 1, (jint *)writefds);\n-    (*env)->SetIntArrayRegion(env, returnExceptFds, 0,\n-                              exceptfds->fd_count + 1, (jint *)exceptfds);\n-#endif\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/WindowsSelectorImpl.c","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-#ifdef _WIN64\n-\n@@ -57,9 +55,0 @@\n-#else\n-\n-struct iovec {\n-    jint  iov_base;\n-    jint  iov_len;\n-};\n-\n-#endif\n-\n@@ -72,1 +61,0 @@\n-\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/nio_util.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -160,5 +160,1 @@\n-#if defined (_WIN64)\n-    #define IS_WIN64 TRUE\n-#else\n-    #define IS_WIN64 FALSE\n-#endif\n+#define IS_WIN64 TRUE\n@@ -198,29 +194,0 @@\n-\/*\n- * Itanium symbols needed for 64-bit compilation.\n- * These are defined in winuser.h in the August 2001 MSDN update.\n- *\/\n-#ifndef GCLP_HBRBACKGROUND\n-    #ifdef _WIN64\n-        #error Macros for GetClassLongPtr, etc. are for 32-bit windows only\n-    #endif \/* !_WIN64 *\/\n-    #define GetClassLongPtr GetClassLong\n-    #define SetClassLongPtr SetClassLong\n-    #define GCLP_HBRBACKGROUND GCL_HBRBACKGROUND\n-    #define GCLP_HCURSOR GCL_HCURSOR\n-    #define GCLP_HICON GCL_HICON\n-    #define GCLP_HICONSM GCL_HICONSM\n-    #define GCLP_HMODULE GCL_HMODULE\n-    #define GCLP_MENUNAME GCL_MENUNAME\n-    #define GCLP_WNDPROC GCL_WNDPROC\n-    #define GetWindowLongPtr GetWindowLong\n-    #define SetWindowLongPtr SetWindowLong\n-    #define GWLP_WNDPROC GWL_WNDPROC\n-    #define GWLP_HINSTANCE GWL_HINSTANCE\n-    #define GWLP_HWNDPARENT GWL_HWNDPARENT\n-    #define GWLP_ID GWL_ID\n-    #define GWLP_USERDATA GWL_USERDATA\n-    #define DWLP_DLGPROC DWL_DLGPROC\n-    #define DWLP_MSGRESULT DWL_MSGRESULT\n-    #define DWLP_USER DWL_USER\n-#endif \/* !GCLP_HBRBACKGROUND *\/\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt.h","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -163,5 +163,1 @@\n-        # if defined(_M_IX86)\n-            _asm { int 3 };\n-        # else\n-            DebugBreak();\n-        # endif\n+        DebugBreak();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <exception>\n-#include <stdexcept>\n-#include <jni.h>\n-#include <windows.h>\n-#include <WinDef.h>\n-\n-extern \"C\" {\n-\n-BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved) {\n-    return TRUE;\n-}\n-\n-\/\/ Determine bitness of Win OS\n-JNIEXPORT jboolean JNICALL\n-Java_com_sun_java_accessibility_internal_AccessBridge_isSysWow(JNIEnv *env, jobject callingObj) {\n-    BOOL bIsWow64 = FALSE;\n-    typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);\n-\n-    LPFN_ISWOW64PROCESS fnIsWow64Process =\n-        (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT(\"kernel32\")), \"IsWow64Process\");\n-\n-    if (fnIsWow64Process != NULL) {\n-        if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64)) {\n-            throw std::runtime_error(\"fnIsWow64Process() failed\");\n-        }\n-    }\n-\n-    return bIsWow64 ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-}\n","filename":"src\/jdk.accessibility\/windows\/native\/libjabsysinfo\/AccessBridgeSysInfo.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -245,7 +245,2 @@\n-            #ifdef _WIN64\n-              JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachNotSupportedException\",\n-                  \"Unable to attach to 32-bit process running under WOW64\");\n-            #else\n-              JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachNotSupportedException\",\n-                  \"Unable to attach to 64-bit process\");\n-            #endif\n+            JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachNotSupportedException\",\n+                \"Unable to attach to 32-bit process running under WOW64\");\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.jvm.hotspot.debugger.x86.*;\n@@ -33,1 +32,0 @@\n-import sun.jvm.hotspot.debugger.windows.x86.*;\n@@ -72,8 +70,1 @@\n-    if (dbg.getCPU().equals(\"x86\")) {\n-      X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-      Address ebp = context.getRegisterAsAddress(X86ThreadContext.EBP);\n-      if (ebp == null) return null;\n-      Address pc  = context.getRegisterAsAddress(X86ThreadContext.EIP);\n-      if (pc == null) return null;\n-      return new WindowsX86CFrame(dbg, ebp, pc);\n-    } else if (dbg.getCPU().equals(\"amd64\")) {\n+    if (dbg.getCPU().equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgCDebugger.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.debugger.x86.*;\n@@ -36,1 +35,0 @@\n-import sun.jvm.hotspot.debugger.windbg.x86.*;\n@@ -103,3 +101,1 @@\n-    if (cpu.equals(\"x86\")) {\n-       threadFactory = new WindbgX86ThreadFactory(this);\n-    } else if (cpu.equals(\"amd64\")) {\n+    if (cpu.equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.windbg.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.windbg.*;\n-\n-class WindbgX86Thread implements ThreadProxy {\n-  private WindbgDebugger debugger;\n-  private long           sysId;\n-  private boolean        gotID;\n-  private long           id;\n-\n-  \/\/ The address argument must be the address of OSThread::_thread_id\n-  WindbgX86Thread(WindbgDebugger debugger, Address addr) {\n-    this.debugger = debugger;\n-    this.sysId    = addr.getCIntegerAt(0, 4, true);\n-    gotID         = false;\n-  }\n-\n-  WindbgX86Thread(WindbgDebugger debugger, long sysId) {\n-    this.debugger = debugger;\n-    this.sysId    = sysId;\n-    gotID         = false;\n-  }\n-\n-  public ThreadContext getContext() throws IllegalThreadStateException {\n-    long[] data = debugger.getThreadIntegerRegisterSet(getThreadID());\n-    WindbgX86ThreadContext context = new WindbgX86ThreadContext(debugger);\n-    for (int i = 0; i < data.length; i++) {\n-      context.setRegister(i, data[i]);\n-    }\n-    return context;\n-  }\n-\n-  public boolean canSetContext() throws DebuggerException {\n-    return false;\n-  }\n-\n-  public void setContext(ThreadContext thrCtx)\n-    throws IllegalThreadStateException, DebuggerException {\n-    throw new DebuggerException(\"Unimplemented\");\n-  }\n-\n-  public boolean equals(Object obj) {\n-    if (!(obj instanceof WindbgX86Thread other)) {\n-      return false;\n-    }\n-\n-    return (other.getThreadID() == getThreadID());\n-  }\n-\n-  public int hashCode() {\n-    return Long.hashCode(getThreadID());\n-  }\n-\n-  public String toString() {\n-    return Long.toString(getThreadID());\n-  }\n-\n-  \/** Retrieves the thread ID of this thread by examining the Thread\n-      Information Block. *\/\n-  private long getThreadID() {\n-    if (!gotID) {\n-       id = debugger.getThreadIdFromSysId(sysId);\n-    }\n-\n-    return id;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/x86\/WindbgX86Thread.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.windbg.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.windbg.*;\n-\n-class WindbgX86ThreadContext extends X86ThreadContext {\n-  private WindbgDebugger debugger;\n-\n-  public WindbgX86ThreadContext(WindbgDebugger debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/x86\/WindbgX86ThreadContext.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.windbg.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.windbg.*;\n-\n-public class WindbgX86ThreadFactory implements WindbgThreadFactory {\n-  private WindbgDebugger debugger;\n-\n-  public WindbgX86ThreadFactory(WindbgDebugger debugger) {\n-    this.debugger = debugger;\n-  }\n-\n-  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {\n-    return new WindbgX86Thread(debugger, threadIdentifierAddr);\n-  }\n-\n-  public ThreadProxy createThreadWrapper(long id) {\n-    return new WindbgX86Thread(debugger, id);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/x86\/WindbgX86ThreadFactory.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.windows.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-import sun.jvm.hotspot.debugger.cdbg.basic.*;\n-import sun.jvm.hotspot.debugger.windbg.*;\n-\n-public class WindowsX86CFrame extends BasicCFrame {\n-  private Address ebp;\n-  private Address pc;\n-\n-  private static final int ADDRESS_SIZE = 4;\n-\n-  \/** Constructor for topmost frame *\/\n-  public WindowsX86CFrame(WindbgDebugger dbg, Address ebp, Address pc) {\n-    super(dbg.getCDebugger());\n-    this.ebp = ebp;\n-    this.pc  = pc;\n-    this.dbg = dbg;\n-  }\n-\n-  public CFrame sender(ThreadProxy thread) {\n-    X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-    \/*\n-     * Native code fills in the stack pointer register value using index\n-     * X86ThreadContext.SP.\n-     * See file sawindbg.cpp macro REG_INDEX(x).\n-     *\n-     * Be sure to use SP, or UESP which is aliased to SP in Java code,\n-     * for the frame pointer validity check.\n-     *\/\n-    Address esp = context.getRegisterAsAddress(X86ThreadContext.SP);\n-\n-    if ( (ebp == null) || ebp.lessThan(esp) ) {\n-      return null;\n-    }\n-\n-    \/\/ Check alignment of ebp\n-    if ( dbg.getAddressValue(ebp) % ADDRESS_SIZE != 0) {\n-        return null;\n-    }\n-\n-    Address nextEBP = ebp.getAddressAt( 0 * ADDRESS_SIZE);\n-    if (nextEBP == null || nextEBP.lessThanOrEqual(ebp)) {\n-      return null;\n-    }\n-    Address nextPC  = ebp.getAddressAt( 1 * ADDRESS_SIZE);\n-    if (nextPC == null) {\n-      return null;\n-    }\n-    return new WindowsX86CFrame(dbg, nextEBP, nextPC);\n-  }\n-\n-  public Address pc() {\n-    return pc;\n-  }\n-\n-  public Address localVariableBase() {\n-    return ebp;\n-  }\n-\n-  private WindbgDebugger dbg;\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windows\/x86\/WindowsX86CFrame.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.jvm.hotspot.runtime.win32_x86.Win32X86JavaThreadPDAccess;\n@@ -101,3 +100,1 @@\n-            if (cpu.equals(\"x86\")) {\n-                access =  new Win32X86JavaThreadPDAccess();\n-            } else if (cpu.equals(\"amd64\")) {\n+            if (cpu.equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.win32_x86;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.runtime.x86.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** This class is only public to allow using the VMObjectFactory to\n-    instantiate these.\n-*\/\n-\n-public class Win32X86JavaThreadPDAccess implements JavaThreadPDAccess {\n-  private static AddressField  lastJavaFPField;\n-  private static AddressField  osThreadField;\n-\n-  \/\/ Field from OSThread\n-  private static Field         threadIdField;\n-\n-  \/\/ This is currently unneeded but is being kept in case we change\n-  \/\/ the currentFrameGuess algorithm\n-  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"JavaThread\");\n-    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n-    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n-    osThreadField           = type.getAddressField(\"_osthread\");\n-\n-    type = db.lookupType(\"OSThread\");\n-    threadIdField = type.getField(\"_thread_id\");\n-  }\n-\n-  public Address getLastJavaFP(Address addr) {\n-    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n-  }\n-\n-  public Address getLastJavaPC(Address addr) {\n-    return null;\n-  }\n-\n-  public Address getBaseOfStackPointer(Address addr) {\n-    return null;\n-  }\n-\n-  public Frame getLastFramePD(JavaThread thread, Address addr) {\n-    Address fp = thread.getLastJavaFP();\n-    if (fp == null) {\n-      return null; \/\/ no information\n-    }\n-    Address pc =  thread.getLastJavaPC();\n-    if ( pc != null ) {\n-      return new X86Frame(thread.getLastJavaSP(), fp, pc);\n-    } else {\n-      return new X86Frame(thread.getLastJavaSP(), fp);\n-    }\n-  }\n-\n-  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n-    return new X86RegisterMap(thread, updateMap);\n-  }\n-\n-  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    X86CurrentFrameGuess guesser = new X86CurrentFrameGuess(context, thread);\n-    if (!guesser.run(GUESS_SCAN_RANGE)) {\n-      return null;\n-    }\n-    if (guesser.getPC() == null) {\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n-    } else {\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n-    }\n-  }\n-\n-  public void printThreadIDOn(Address addr, PrintStream tty) {\n-    tty.print(getThreadProxy(addr));\n-  }\n-\n-  public void printInfoOn(Address threadAddr, PrintStream tty) {\n-  }\n-\n-  public Address getLastSP(Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    return context.getRegisterAsAddress(X86ThreadContext.ESP);\n-  }\n-\n-  public ThreadProxy getThreadProxy(Address addr) {\n-    \/\/ Addr is the address of the JavaThread.\n-    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n-    \/\/ separate \"OSThread\" class in this package)\n-    Address osThreadAddr = osThreadField.getValue(addr);\n-    \/\/ Get the address of the thread_id within the OSThread\n-    Address threadIdAddr =\n-      osThreadAddr.addOffsetTo(threadIdField.getOffset());\n-    JVMDebugger debugger = VM.getVM().getDebugger();\n-    return debugger.getThreadForIdentifierAddress(threadIdAddr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/win32_x86\/Win32X86JavaThreadPDAccess.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -33,4 +33,1 @@\n-#ifdef _M_IX86\n-  #include \"sun_jvm_hotspot_debugger_x86_X86ThreadContext.h\"\n-  #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG\n-#elif _M_AMD64\n+#ifdef _M_AMD64\n@@ -563,33 +560,1 @@\n-#ifdef _M_IX86\n-    #define REG_INDEX(x) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##x\n-\n-    context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;\n-    ptrIDebugAdvanced->GetThreadContext(&context, sizeof(CONTEXT));\n-\n-    ptrRegs[REG_INDEX(GS)]  = context.SegGs;\n-    ptrRegs[REG_INDEX(FS)]  = context.SegFs;\n-    ptrRegs[REG_INDEX(ES)]  = context.SegEs;\n-    ptrRegs[REG_INDEX(DS)]  = context.SegDs;\n-\n-    ptrRegs[REG_INDEX(EDI)] = context.Edi;\n-    ptrRegs[REG_INDEX(ESI)] = context.Esi;\n-    ptrRegs[REG_INDEX(EBX)] = context.Ebx;\n-    ptrRegs[REG_INDEX(EDX)] = context.Edx;\n-    ptrRegs[REG_INDEX(ECX)] = context.Ecx;\n-    ptrRegs[REG_INDEX(EAX)] = context.Eax;\n-\n-    ptrRegs[REG_INDEX(FP)] = context.Ebp;\n-    ptrRegs[REG_INDEX(PC)] = context.Eip;\n-    ptrRegs[REG_INDEX(CS)]  = context.SegCs;\n-    ptrRegs[REG_INDEX(EFL)] = context.EFlags;\n-    ptrRegs[REG_INDEX(SP)] = context.Esp;\n-    ptrRegs[REG_INDEX(SS)]  = context.SegSs;\n-\n-    ptrRegs[REG_INDEX(DR0)] = context.Dr0;\n-    ptrRegs[REG_INDEX(DR1)] = context.Dr1;\n-    ptrRegs[REG_INDEX(DR2)] = context.Dr2;\n-    ptrRegs[REG_INDEX(DR3)] = context.Dr3;\n-    ptrRegs[REG_INDEX(DR6)] = context.Dr6;\n-    ptrRegs[REG_INDEX(DR7)] = context.Dr7;\n-\n-#elif _M_AMD64\n+#ifdef _M_AMD64\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":2,"deletions":37,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -108,7 +108,0 @@\n-#if defined(_WIN32) && !defined(_WIN64)\n-    onLoad = (jdwpTransport_OnLoad_t)\n-                 dbgsysFindLibraryEntry(handle, \"_jdwpTransport_OnLoad@16\");\n-    if (onLoad != NULL) {\n-        return onLoad;\n-    }\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,6 +37,0 @@\n-#if defined(_WIN32) && !defined(_WIN64)\n-#define LAUNCH_FUNC \"_JLI_Launch@56\"\n-#else\n-#define LAUNCH_FUNC \"JLI_Launch\"\n-#endif\n-\n@@ -209,1 +203,1 @@\n-    DllFunction<void*> func(Dll(jvmPath), LAUNCH_FUNC);\n+    DllFunction<void*> func(Dll(jvmPath), \"JLI_Launch\");\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncher.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -292,5 +292,1 @@\n-#ifdef _WIN64\n-    #define JP_CA_MANGLED_NAME(name) #name\n-#else\n-    #define JP_CA_MANGLED_NAME(name) \"_\" #name \"@4\"\n-#endif\n+#define JP_CA_MANGLED_NAME(name) #name\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiCA.h","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}