{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import sun.security.util.AlgorithmDecomposer;\n@@ -137,2 +138,2 @@\n-                    public boolean getIsAllowed(Service svc) {\n-                        return svc.getIsAllowed();\n+                    public boolean isAllowed(Service svc) {\n+                        return svc.isAllowed();\n@@ -1021,1 +1022,1 @@\n-                            svc.getIsAllowed() == allowed && isValid(svc)) {\n+                            svc.isAllowed() == allowed && isValid(svc)) {\n@@ -1030,2 +1031,2 @@\n-                return svc != null && isValid(svc) && svc.getIsAllowed() ?\n-                        svc : null;\n+                return svc != null && isValid(svc) &&\n+                        svc.isAllowed() ? svc : null;\n@@ -1098,1 +1099,1 @@\n-                    svc.computeIsAllowed();\n+                    svc.computeSvcAllowed();\n@@ -1296,1 +1297,1 @@\n-                notifyChanges(mi.svc.getIsAllowed());\n+                notifyChanges(mi.svc.isAllowed());\n@@ -1342,1 +1343,1 @@\n-                        newSvc.computeIsAllowed();\n+                        newSvc.computeSvcAllowed();\n@@ -1411,1 +1412,4 @@\n-                    newSvc.computeIsAllowed();\n+                    newSvc.computeSvcAllowed();\n+                    if (newSvc.cipherTransformsAllowed != null) {\n+                        newSvc.cipherTransformsAllowed.clear();\n+                    }\n@@ -1515,1 +1519,4 @@\n-                        newSvc.computeIsAllowed();\n+                        newSvc.computeSvcAllowed();\n+                        if (newSvc.cipherTransformsAllowed != null) {\n+                            newSvc.cipherTransformsAllowed.clear();\n+                        }\n@@ -1630,1 +1637,1 @@\n-                        oldMi.svc.getIsAllowed() != newSvc.getIsAllowed()) {\n+                        oldMi.svc.isAllowed() != newSvc.isAllowed()) {\n@@ -1634,1 +1641,1 @@\n-                    notifyChanges(oldMi.svc.getIsAllowed());\n+                    notifyChanges(oldMi.svc.isAllowed());\n@@ -1638,1 +1645,1 @@\n-                notifyChanges(newSvc.getIsAllowed());\n+                notifyChanges(newSvc.isAllowed());\n@@ -2270,1 +2277,1 @@\n-            if (svc != null && svc.getIsAllowed()) {\n+            if (svc != null && svc.isAllowed()) {\n@@ -2474,2 +2481,2 @@\n-        \/\/ Cached Providers filter state for this service. Value is null when\n-        \/\/ not decided.\n+        \/\/ Cache with the Providers filter decision for this service. Value is\n+        \/\/ null when not decided.\n@@ -2478,0 +2485,6 @@\n+        \/\/ Cache with transformation - filter decision entries. Transformations\n+        \/\/ in this cache are based on this service algorithm or aliases, but\n+        \/\/ are not necessarily supported (further evaluation is needed). For\n+        \/\/ Cipher service types only (lazily initialized), null otherwise.\n+        private Map<String, Boolean> cipherTransformsAllowed;\n+\n@@ -2548,0 +2561,4 @@\n+            if (svc.cipherTransformsAllowed != null) {\n+                cipherTransformsAllowed = new ConcurrentHashMap<>(\n+                        svc.cipherTransformsAllowed);\n+            }\n@@ -2619,1 +2636,1 @@\n-                Map<String,String> attributes) {\n+                Map<String, String> attributes) {\n@@ -2640,1 +2657,1 @@\n-                for (Map.Entry<String,String> entry : attributes.entrySet()) {\n+                for (Map.Entry<String, String> entry : attributes.entrySet()) {\n@@ -2681,1 +2698,31 @@\n-        private boolean getIsAllowed() {\n+        private boolean isAllowed() {\n+            ProvidersFilter.CipherContext cipherContext =\n+                    ProvidersFilter.CipherTransformation.getContext();\n+            if (cipherContext != null) {\n+                \/\/ The Cipher class is trying to create a CipherSpi instance\n+                \/\/ from a service. E.g. Cipher.getInstance(\"transformation\").\n+                \/\/ The service algorithm and aliases do not match the\n+                \/\/ transformation exactly. However, there could still be support\n+                \/\/ for it. Evaluate the transformation according to the filter\n+                \/\/ and see if the service remains on track for further\n+                \/\/ assessment (e.g. Cipher.Transform::supports).\n+                if ((cipherTransformsAllowed != null ||\n+                        type.equals(\"Cipher\")) &&\n+                        isTransformationForSvc(cipherContext.svcSearchKey())) {\n+                    return isTransformationAllowed(\n+                            cipherContext.transformation());\n+                } else {\n+                    \/\/ Unlikely. May happen if a provider overrides\n+                    \/\/ Provider::getService or Provider.Service::newInstance\n+                    \/\/ and, during a Cipher service lookup, triggers a\n+                    \/\/ Provider.Service::isAllowed call for a service not\n+                    \/\/ related to the Cipher transformation.\n+                    if (debug != null) {\n+                        debug.println(\"Filter evaluation of a service not \" +\n+                                \"related to a Cipher transformation (\" +\n+                                cipherContext.transformation() + \"). Service \" +\n+                                \"search key: \" + cipherContext.svcSearchKey() +\n+                                \". Service: \" + this);\n+                    }\n+                }\n+            }\n@@ -2683,1 +2730,67 @@\n-                computeIsAllowed();\n+                computeSvcAllowed();\n+            }\n+            return isAllowed;\n+        }\n+\n+        \/*\n+         * Returns whether a key matches any of the algorithm or aliases\n+         * (case insensitive).\n+         *\/\n+        private boolean isTransformationForSvc(String svcSearchKey) {\n+            if (svcSearchKey.equalsIgnoreCase(algorithm)) {\n+                return true;\n+            }\n+            for (String alias : getAliases()) {\n+                if (svcSearchKey.equalsIgnoreCase(alias)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/*\n+         * Returns whether a transformation potentially supported by this\n+         * service is allowed by the Providers filter. Service algorithm and\n+         * aliases are used to build transformation aliases.\n+         *\/\n+        private boolean isTransformationAllowed(String transformation) {\n+            Boolean isTransformAllowed;\n+            if (cipherTransformsAllowed == null) {\n+                cipherTransformsAllowed = new ConcurrentHashMap<>();\n+                isTransformAllowed = null;\n+            } else {\n+                isTransformAllowed =\n+                        cipherTransformsAllowed.get(transformation);\n+            }\n+            if (isTransformAllowed == null) {\n+                String[] transformParts = AlgorithmDecomposer\n+                        .getTransformationTokens(transformation);\n+                \/\/ transformParts has three non-empty components because\n+                \/\/ transformation 1) was analyzed by\n+                \/\/ Cipher::tokenizeTransformation before and 2) if it\n+                \/\/ had have a single component, it would have been\n+                \/\/ equal to the service algorithm or alias and not set by\n+                \/\/ ProvidersFilter.CipherTransformation to reach this point.\n+                assert transformParts.length == 3 :\n+                        \"Unexpected transformation.\";\n+                List<String> allAlgos =\n+                        new ArrayList<>(getAliases().size() + 1);\n+                allAlgos.add(algorithm);\n+                allAlgos.addAll(getAliases());\n+                List<String> tAliases = new ArrayList<>(allAlgos.size() - 1);\n+                for (String algo : allAlgos) {\n+                    \/\/ If a service algorithm or alias has multiple components,\n+                    \/\/ use the first one for the transformation alias. The\n+                    \/\/ second and third one (if any) are assumed to be the mode\n+                    \/\/ and padding respectively, and taken from the\n+                    \/\/ transformation.\n+                    algo = AlgorithmDecomposer.getTransformationTokens(algo)[0];\n+                    String transformAlgo = algo + \"\/\" + transformParts[1] +\n+                            \"\/\" + transformParts[2];\n+                    if (!transformAlgo.equalsIgnoreCase(transformation)) {\n+                        tAliases.add(transformAlgo);\n+                    }\n+                }\n+                isTransformAllowed = ProvidersFilter.computeSvcAllowed(\n+                        provider.getName(), type, transformation, tAliases);\n+                cipherTransformsAllowed.put(transformation, isTransformAllowed);\n@@ -2685,1 +2798,1 @@\n-            return isAllowed == Boolean.TRUE;\n+            return isTransformAllowed;\n@@ -2691,1 +2804,1 @@\n-         * from Service::getIsAllowed to handle uncommon cases.\n+         * from Service::isAllowed to handle uncommon cases.\n@@ -2693,2 +2806,3 @@\n-        private void computeIsAllowed() {\n-            isAllowed = ProvidersFilter.computeIsAllowed(this);\n+        private void computeSvcAllowed() {\n+            isAllowed = ProvidersFilter.computeSvcAllowed(\n+                    provider.getName(), type, algorithm, getAliases());\n@@ -2791,1 +2905,1 @@\n-                        !getIsAllowed()) {\n+                        !isAllowed()) {\n@@ -2793,1 +2907,1 @@\n-                            (!getIsAllowed() ? \"allowed\" : \"registered with \" +\n+                            (!isAllowed() ? \"allowed\" : \"registered with \" +\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":140,"deletions":26,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import sun.security.util.AlgorithmDecomposer;\n@@ -311,2 +312,6 @@\n-    private static final String SHA512TRUNCATED = \"SHA512\/2\";\n-\n+    \/**\n+     * Split a Cipher transformation of the form algorithm\/mode\/padding or\n+     * algorithm into its components. Checks that only one or three components\n+     * are returned and that the first component is non-empty, or throws\n+     * NoSuchAlgorithmException otherwise.\n+     *\/\n@@ -315,2 +320,6 @@\n-        if (transformation == null) {\n-            throw new NoSuchAlgorithmException(\"No transformation given\");\n+        String[] transformationTokens =\n+                AlgorithmDecomposer.getTransformationTokens(transformation);\n+        if (transformationTokens.length != 1 &&\n+                transformationTokens.length != 3) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation \" +\n+                    \"format: \" + transformation);\n@@ -318,30 +327,3 @@\n-        \/*\n-         * array containing the components of a cipher transformation:\n-         *\n-         * index 0: algorithm component (e.g., AES)\n-         * index 1: feedback component (e.g., CFB)\n-         * index 2: padding component (e.g., PKCS5Padding)\n-         *\/\n-        String[] parts = { \"\", \"\", \"\" };\n-\n-        \/\/ check if the transformation contains algorithms with \"\/\" in their\n-        \/\/ name which can cause the parsing logic to go wrong\n-        int sha512Idx = transformation.toUpperCase(Locale.ENGLISH)\n-                .indexOf(SHA512TRUNCATED);\n-        int startIdx = (sha512Idx == -1 ? 0 :\n-                sha512Idx + SHA512TRUNCATED.length());\n-        int endIdx = transformation.indexOf('\/', startIdx);\n-        if (endIdx == -1) {\n-            \/\/ algorithm\n-            parts[0] = transformation.trim();\n-        } else {\n-            \/\/ algorithm\/mode\/padding\n-            parts[0] = transformation.substring(0, endIdx).trim();\n-            startIdx = endIdx+1;\n-            endIdx = transformation.indexOf('\/', startIdx);\n-            if (endIdx == -1) {\n-                throw new NoSuchAlgorithmException(\"Invalid transformation\"\n-                            + \" format:\" + transformation);\n-            }\n-            parts[1] = transformation.substring(startIdx, endIdx).trim();\n-            parts[2] = transformation.substring(endIdx+1).trim();\n+        if (transformationTokens[0].isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation (\" +\n+                    \"algorithm not specified): \" + transformation);\n@@ -349,6 +331,1 @@\n-        if (parts[0].isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n-                                   + transformation);\n-        }\n-        return parts;\n+        return transformationTokens;\n@@ -449,1 +426,0 @@\n-\n@@ -451,2 +427,2 @@\n-        String mode = parts[1];\n-        String pad = parts[2];\n+        String mode = parts.length == 3 ? parts[1] : \"\";\n+        String pad = parts.length == 3 ? parts[2] : \"\";\n@@ -454,1 +430,1 @@\n-        if ((mode.length() == 0) && (pad.length() == 0)) {\n+        if (mode.isEmpty() && pad.isEmpty()) {\n@@ -481,0 +457,24 @@\n+    private static Service tryGetService(Provider p, String canonicalTransform,\n+            String svcSearchKey) {\n+        ProvidersFilter.CipherTransformation ct =\n+                new ProvidersFilter.CipherTransformation(\n+                        canonicalTransform, svcSearchKey);\n+        try (ct) {\n+            Service s = p.getService(\"Cipher\", svcSearchKey);\n+            if (s == null || !ProvidersFilter.isAllowed(s)) {\n+                return null;\n+            }\n+            return s;\n+        }\n+    }\n+\n+    private static Object newInstance(Service s, String canonicalTransform,\n+            String svcSearchKey) throws NoSuchAlgorithmException {\n+        ProvidersFilter.CipherTransformation ct =\n+                new ProvidersFilter.CipherTransformation(\n+                        canonicalTransform, svcSearchKey);\n+        try (ct) {\n+            return s.newInstance(null);\n+        }\n+    }\n+\n@@ -538,0 +538,1 @@\n+        String canonicalTransform = transforms.getFirst().transform;\n@@ -542,1 +543,2 @@\n-        List<Service> services = GetInstance.getServices(cipherServices);\n+        List<Service> services =\n+                GetInstance.getCipherServices(cipherServices);\n@@ -549,1 +551,1 @@\n-            if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -566,1 +568,2 @@\n-                CipherSpi spi = (CipherSpi)s.newInstance(null);\n+                CipherSpi spi = (CipherSpi)newInstance(s, canonicalTransform,\n+                        tr.transform);\n@@ -711,0 +714,1 @@\n+        String canonicalTransform = transforms.getFirst().transform;\n@@ -714,2 +718,3 @@\n-            Service s = provider.getService(\"Cipher\", tr.transform);\n-            if (s == null || !ProvidersFilter.isAllowed(s)) {\n+            Service s = tryGetService(provider, canonicalTransform,\n+                    tr.transform);\n+            if (s == null) {\n@@ -718,1 +723,1 @@\n-            if (providerChecked == false) {\n+            if (!providerChecked) {\n@@ -721,2 +726,2 @@\n-                \/\/ and a SecurityException if the\n-                \/\/ provider does not support the algorithm.\n+                \/\/ and a SecurityException if the provider does not support\n+                \/\/ the algorithm.\n@@ -726,1 +731,1 @@\n-                        + provider.getName();\n+                            + provider.getName();\n@@ -739,1 +744,2 @@\n-                CipherSpi spi = (CipherSpi)s.newInstance(null);\n+                CipherSpi spi = (CipherSpi)newInstance(s, canonicalTransform,\n+                        tr.transform);\n@@ -749,1 +755,0 @@\n-\n@@ -806,0 +811,1 @@\n+            String canonicalTransform = transforms.getFirst().transform;\n@@ -819,1 +825,1 @@\n-                if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -832,1 +838,2 @@\n-                        Object obj = s.newInstance(null);\n+                        Object obj = newInstance(s, canonicalTransform,\n+                                tr.transform);\n@@ -900,0 +907,1 @@\n+            String canonicalTransform = transforms.getFirst().transform;\n@@ -914,1 +922,1 @@\n-                if (s.supportsParameter(key) == false) {\n+                if (!s.supportsParameter(key)) {\n@@ -917,1 +925,1 @@\n-                if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -930,1 +938,2 @@\n-                        thisSpi = (CipherSpi)s.newInstance(null);\n+                        thisSpi = (CipherSpi)newInstance(s, canonicalTransform,\n+                                tr.transform);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":69,"deletions":60,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    boolean getIsAllowed(Provider.Service svc);\n+    boolean isAllowed(Provider.Service svc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecurityProviderAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,0 +138,5 @@\n+    public static List<Service> getCipherServices(List<ServiceId> ids) {\n+        ProviderList list = Providers.getProviderList();\n+        return list.getCipherServices(ids);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/GetInstance.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -424,0 +424,4 @@\n+    public List<Service> getCipherServices(List<ServiceId> ids) {\n+        return new CipherServiceList(ids);\n+    }\n+\n@@ -429,1 +433,2 @@\n-    private final class ServiceList extends AbstractList<Service> {\n+    private sealed class ServiceList extends AbstractList<Service>\n+            permits CipherServiceList {\n@@ -521,2 +526,2 @@\n-                    Service s = p.getService(type, algorithm);\n-                    if (s != null && ProvidersFilter.isAllowed(s)) {\n+                    Service s = tryGetService(p, type, algorithm);\n+                    if (s != null) {\n@@ -528,2 +533,2 @@\n-                        Service s = p.getService(id.type, id.algorithm);\n-                        if (s != null && ProvidersFilter.isAllowed(s)) {\n+                        Service s = tryGetService(p, id.type, id.algorithm);\n+                        if (s != null) {\n@@ -537,0 +542,8 @@\n+        Service tryGetService(Provider p, String type, String algorithm) {\n+            Service s = p.getService(type, algorithm);\n+            if (s == null || !ProvidersFilter.isAllowed(s)) {\n+                return null;\n+            }\n+            return s;\n+        }\n+\n@@ -589,0 +602,19 @@\n+    private final class CipherServiceList extends ServiceList {\n+        private final String canonicalTransform;\n+\n+        CipherServiceList(List<ServiceId> ids) {\n+            super(ids);\n+            canonicalTransform = ids.getFirst().algorithm;\n+        }\n+\n+        @Override\n+        Service tryGetService(Provider p, String type, String algorithm) {\n+            ProvidersFilter.CipherTransformation ct =\n+                    new ProvidersFilter.CipherTransformation(\n+                            canonicalTransform, algorithm);\n+            try (ct) {\n+                return super.tryGetService(p, type, algorithm);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.Closeable;\n@@ -34,0 +35,1 @@\n+import java.util.Locale;\n@@ -74,0 +76,4 @@\n+        boolean isAllow() {\n+            return result == ProvidersFilter.FilterDecision.Result.ALLOW;\n+        }\n+\n@@ -688,2 +694,2 @@\n-        \/\/ Provider.Service::getIsAllowed).\n-        return jspa.getIsAllowed(svc);\n+        \/\/ Provider.Service::isAllowed).\n+        return jspa.isAllowed(svc);\n@@ -693,1 +699,2 @@\n-     * This method is called from Provider.Service::computeIsAllowed only.\n+     * This method is called from Provider.Service::computeSvcAllowed and\n+     * Provider.Service::isTransformationAllowed.\n@@ -695,1 +702,2 @@\n-    public static boolean computeIsAllowed(Provider.Service svc) {\n+    public static boolean computeSvcAllowed(String providerName,\n+            String svcType, String algo, List<String> aliases) {\n@@ -699,3 +707,0 @@\n-        String providerName = svc.getProvider().getName();\n-        String svcType = svc.getType();\n-        String algo = svc.getAlgorithm();\n@@ -703,1 +708,0 @@\n-        List<String> aliases = jspa.getAliases(svc);\n@@ -723,1 +727,1 @@\n-        return d.result == FilterDecision.Result.ALLOW;\n+        return d.isAllow();\n@@ -730,0 +734,67 @@\n+\n+    \/*\n+     * CipherContext is an auxiliary class to bundle information required by\n+     * CipherTransformation. The field \"transformation\" is the ongoing Cipher\n+     * transformation for which a service is being looked up. The field\n+     * \"svcSearchKey\" is the key (algorithm or alias) used to look up a\n+     * service that might support the transformation.\n+     *\/\n+    public record CipherContext(String transformation, String svcSearchKey) {}\n+\n+    \/*\n+     * CipherTransformation is used from the Cipher::tryGetService,\n+     * Cipher::newInstance and ProviderList.CipherServiceList::tryGetService\n+     * methods for a thread to indicate that a service will be looked up for a\n+     * Cipher transformation. In these cases, the service evaluation against\n+     * the Providers Filter is based on the transformation and not the service\n+     * algorithm or aliases. Thus, a Filter value such as\n+     * \"*.Cipher.AES\/ECB\/PKCS5Padding; !*\" would allow\n+     * Cipher.getInstance(\"AES\/ECB\/PKCS5Padding\") but block\n+     * Cipher.getInstance(\"AES\") even when the supporting service is the same.\n+     *\/\n+    public static final class CipherTransformation implements Closeable {\n+        private static final ThreadLocal<CipherContext> cipherTransformContext =\n+                new ThreadLocal<>();\n+        private CipherContext prevContext;\n+\n+        public CipherTransformation(String transformation,\n+                String svcSearchKey) {\n+            if (filter == null) {\n+                return;\n+            }\n+            prevContext = cipherTransformContext.get();\n+            if (!transformation.equalsIgnoreCase(svcSearchKey)) {\n+                cipherTransformContext.set(new CipherContext(\n+                        transformation.toUpperCase(Locale.ENGLISH),\n+                        svcSearchKey));\n+            } else {\n+                \/\/ The transformation matches the service algorithm or alias.\n+                \/\/ Set the context to null to indicate that a regular service\n+                \/\/ evaluation (not based on the transformation) should be done.\n+                cipherTransformContext.set(null);\n+            }\n+        }\n+\n+        \/*\n+         * This method is called from Provider.Service::isAllowed for a thread\n+         * to get the CipherContext related to a service lookup. Returns\n+         * null if 1) there is not an ongoing service lookup based on a Cipher\n+         * transformation or 2) the transformation matches the service\n+         * algorithm or any of its aliases. A regular service evaluation (not\n+         * based on the transformation) should be done if null is returned.\n+         *\/\n+        public static CipherContext getContext() {\n+            if (filter == null) {\n+                return null;\n+            }\n+            return cipherTransformContext.get();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (filter == null) {\n+                return;\n+            }\n+            cipherTransformContext.set(prevContext);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProvidersFilter.java","additions":80,"deletions":9,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,43 @@\n+\n+    private static final String SHA512TRUNCATED = \"SHA512\/2\";\n+\n+    \/**\n+     * Split a Cipher transformation of the form algorithm\/mode\/padding,\n+     * algorithm\/mode or algorithm into its components.\n+     *\n+     * Array components of a Cipher transformation:\n+     *\n+     * index 0: algorithm component (e.g. AES)\n+     * index 1: feedback component (e.g. CFB)\n+     * index 2: padding component (e.g. PKCS5Padding)\n+     *\/\n+    public static String[] getTransformationTokens(String transformation) {\n+        \/\/ check if the transformation contains algorithms with \"\/\" in their\n+        \/\/ name which can cause the parsing logic to go wrong\n+        int sha512Idx = transformation.toUpperCase(Locale.ENGLISH)\n+                .indexOf(SHA512TRUNCATED);\n+        int startIdx = (sha512Idx == -1 ? 0 :\n+                sha512Idx + SHA512TRUNCATED.length());\n+        int endIdx = transformation.indexOf('\/', startIdx);\n+        if (endIdx == -1) {\n+            \/\/ algorithm\n+            return new String[] { transformation.trim() };\n+        } else {\n+            String algorithm;\n+            String mode;\n+            String padding;\n+            algorithm = transformation.substring(0, endIdx).trim();\n+            startIdx = endIdx + 1;\n+            endIdx = transformation.indexOf('\/', startIdx);\n+            if (endIdx == -1) {\n+                \/\/ algorithm\/mode\n+                mode = transformation.substring(startIdx).trim();\n+                return new String[] { algorithm, mode };\n+            } else {\n+                \/\/ algorithm\/mode\/padding\n+                mode = transformation.substring(startIdx, endIdx).trim();\n+                padding = transformation.substring(endIdx + 1).trim();\n+                return new String[] { algorithm, mode, padding };\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AlgorithmDecomposer.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1520,23 +1520,17 @@\n-# Security Providers Filter\n-#\n-# This filter can be used to select which security services (combination of a\n-# provider, service type and algorithm) are allowed in the Java security APIs.\n-# Services that belong either to statically enabled security providers\n-# (security.provider.<n> security property) or dynamically added ones\n-# (Security::addProvider API) are subject to the restrictions of this filter.\n-# A service is evaluated against this filter when a provider registers it\n-# (java.security.Provider::put or java.security.Provider::putService APIs) or returns\n-# an unregistered instance (after overriding java.security.Provider::getService\n-# or java.security.Provider::getServices APIs).\n-#\n-# Filtering out a cryptographic algorithm will block its use in TLS connections,\n-# JAR signing, certificates paths validation and in any other Java Cryptography\n-# Architecture API. The effect of blocking an algorithm applies on top of security\n-# properties that concern specific uses of it, such as jdk.tls.disabledAlgorithms,\n-# jdk.jar.disabledAlgorithms or jdk.certpath.disabledAlgorithms. However, an\n-# algorithm allowed by a filter is still subject to the aforementioned properties.\n-#\n-# If the system property jdk.security.providers.filter is specified, it supersedes\n-# the security property value defined here. If any of these properties is set at\n-# run time, the filter could be initialized already and the new value may not take\n-# effect until the JVM is relaunched. When a filter is not specified or is the empty\n+# Security Providers Filter (JEP TBD)\n+#\n+# This filter can be used to configure which services, implemented by installed\n+# security providers, are available for use in the JCA getInstance APIs (Cipher,\n+# Signature, Mac, KeyFactory, etc). Services filtering is independent of other\n+# mechanisms such as jdk.tls.disabledAlgorithms, jdk.jar.disabledAlgorithms and\n+# jdk.certpath.disabledAlgorithms.\n+#\n+# The scope of this filter includes services implemented by statically installed\n+# security providers (security.provider.<n> security properties) and dynamically\n+# installed ones (java.security.Security::addProvider API). No distinctions are\n+# made between OpenJDK and third-party security providers.\n+#\n+# If the system property jdk.security.providers.filter is set, it supersedes\n+# the security one defined here. If any of these properties is set at run time,\n+# the filter could be initialized already and the new value will not take effect\n+# until the JVM is relaunched. When a filter is not set or is set to the empty\n@@ -1545,1 +1539,11 @@\n-# A filter value has the following structure:\n+# A service is typically evaluated against the filter at provider registration\n+# time (java.security.Provider ::put or ::putService APIs). In special cases, when\n+# a provider overrides java.security.Provider ::getService or ::getServices APIs to\n+# return unregistered services, filter evaluation is deferred until its first use.\n+# Services are identifiable as a combination of a security provider, a service type\n+# and an algorithm name. Optionally, an algorithm alias can be used to replace the\n+# algorithm name. A filter is made of a sequence of patterns that identify a service\n+# according to a matching criteria (as we shall see later) and indicate an action:\n+# allow or deny the service under evaluation.\n+#\n+# The filter syntax is as follows:\n@@ -1549,2 +1553,2 @@\n-# Each pattern in the sequence can be optionally prefixed by a '!' character (i.e.\n-# \" ! pattern-1 \"). Whitespaces between patterns, pattern prefixes ('!') and pattern\n+# Each pattern in the sequence can be optionally prefixed by a '!' character (e.g.\n+# \" ! pattern-1 \"). White spaces between patterns, pattern prefixes ('!') and pattern\n@@ -1553,4 +1557,4 @@\n-# authorization decision is made: if the pattern is prefixed by a '!', the decision\n-# is to deny it; otherwise, the decision is to allow it. If none of the patterns\n-# match, the default decision is to deny it. Once a decision is made, the remaining\n-# patterns are not evaluated.\n+# authorization decision is made: if the pattern is prefixed by a '!' character, the\n+# decision is to deny it; otherwise, the decision is to allow it. If none of the\n+# patterns match, the default decision is to deny the service. Once a decision is\n+# made, remaining patterns are not considered.\n@@ -1558,1 +1562,1 @@\n-# A pattern has one the following forms:\n+# Each pattern's syntax has one of the following forms:\n@@ -1562,4 +1566,6 @@\n-# 3) security-provider.service-type.algorithm\n-# 4) security-provider.service-type.algorithm-alias\n-#\n-# In form #1, a service provider name equal to \"security-provider\" is enough for a\n+# 3.a) security-provider.service-type.algorithm-name\n+# 3.b) security-provider.service-type.algorithm-alias\n+# 3.c) security-provider.Cipher.transformation\n+# 3.d) security-provider.Cipher.transformation-alias\n+\n+# In form #1, a security provider name equal to security-provider is enough for a\n@@ -1567,28 +1573,41 @@\n-# \"service-type\". In form #3, the service algorithm must also be equal to \"algorithm\".\n-# In form #4, it is enough that one of the service aliases matches \"algorithm-alias\",\n-# in addition to the requirements for form #2. In all cases, pattern and service\n-# names must have valid characters and cannot be empty.\n-#\n-# Characters '\\n' and '\\0' are not valid in a pattern. The following characters,\n-# when part of a pattern provider, service type, algorithm or alias, must be escaped\n-# by prepending a '\\' character: '!', '*', ' ' (whitespace), '.', ';', '\\', ':' and\n-# ','. Escaping any other character has no effect other than discarding the '\\'\n-# escape character. These escaping rules apply to the filter value as read in\n-# java.lang.System::getProperty or java.security.Security::getProperty: additional\n-# escaping might be needed depending on how the property is passed. For example,\n-# security properties require '\\' characters to be escaped. Thus, to match a service\n-# provider whose name is \"\\\", a pattern must be \"\\\\\\\\\" if passed as a security property.\n-#\n-# In addition to characters escaping, pattern names can contain '*' wildcards to\n-# imply zero or more repetitions of any character. Wildcards behave in a greedy mode,\n-# trying to consume as many characters as possible and backing off if necessary.\n-# Pattern matching is always case insensitive.\n-#\n-# When a service has aliases, the algorithm and each alias are independently evaluated\n-# against the filter. From the set of authorization decisions obtained, the one made\n-# by the left-most pattern has the highest priority and is finally effective.\n-#\n-# For troubleshooting, enable filter debugging output with the system property\n-# java.security.debug=jca and look for messages prefixed by \"ProvidersFilter\". To\n-# verify the list of services allowed for each installed security provider, run the\n-# JVM with the argument -XshowSettings:security:providers.\n+# service-type. In form #3.a, the service algorithm must also be equal to\n+# algorithm-name. In form #3.b, it is enough that one of the service aliases matches\n+# algorithm-alias, in addition to the requirements for form #2. Form #3.c is similar\n+# to form #3.a but applies to cipher transformations with multiple components\n+# (algorithm\/mode\/padding). Form #3.d is equivalent to #3.c but looks for a\n+# transformation alias match (algorithm-alias\/mode\/padding). In all cases, pattern and\n+# service names must have valid characters and cannot be empty. Pattern matching is\n+# always case insensitive.\n+#\n+# Characters '\\n' and '\\0' are not valid in a pattern. The character '.' is used as a\n+# separator between different levels: security provider, service type, algorithm name or\n+# algorithm alias. The following characters, when part of one of the listed levels, must\n+# be escaped by prepending a '\\' character: '!', '*', ' ' (white space), '.', ';', '\\',\n+# ':' and ','. Escaping any other character has no effect other than silently discarding\n+# the '\\' character.\n+#\n+# The aforementioned escaping rules apply to the filter value as read in the\n+# java.security.Security::getProperty and java.lang.System::getProperty APIs:\n+# additional escaping might be needed depending on how the filter value is passed. For\n+# example, security properties require '\\' characters to be escaped. Thus, to match a\n+# provider whose name is abc\\123, a pattern must be escaped as abc\\\\\\\\123 if passed as a\n+# security property.\n+#\n+# In addition to characters escaping, pattern names can contain '*' wildcards to imply\n+# zero or more repetitions of any character. Wildcards behave in greedy mode, trying to\n+# consume as many characters as possible and backing off if necessary.\n+#\n+# When a service has aliases, its algorithm name and each of the aliases are independently\n+# evaluated against the filter. Notice that the security provider and service type for each\n+# of these evaluations are the same. From the set of authorization decisions obtained —which\n+# can potentially be contradictory—, the one made by the left-most pattern in the filter has\n+# the highest priority and is finally effective. This strategy would be equivalent to\n+# modifying the evaluation of a service against each pattern so that each alias is tried\n+# (besides the algorithm name) and stopping if a decision is made for one of them.\n+#\n+# For troubleshooting, it is possible to enable filter debugging logs with the system\n+# property java.security.debug=jca and look for messages prefixed by ProvidersFilter. To list\n+# services allowed and not allowed by a filter for each installed security provider, run java\n+# with the argument -XshowSettings:security:providers. When a filter value is syntactically\n+# invalid, the exception message thrown points to the exact location in the pattern that could\n+# not be parsed.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":82,"deletions":63,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javax.crypto.Mac;\n@@ -40,0 +41,1 @@\n+import sun.security.util.KnownOIDs;\n@@ -50,0 +52,1 @@\n+ *          java.base\/sun.security.util\n@@ -105,0 +108,2 @@\n+        cryptoCheckers.put(\"Mac\", (ServiceData d) -> cryptoCheck(\n+                () -> Mac.getInstance(d.svcAlgo, d.provider)));\n@@ -561,0 +566,10 @@\n+    private static Provider getProviderByName(String providerName) {\n+        Provider[] providers = Security.getProviders();\n+        for (Provider p : providers) {\n+            if (p.getName().equals(providerName)) {\n+                return p;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -564,0 +579,1 @@\n+            Provider p = getProviderByName(svcData.provider);\n@@ -572,0 +588,10 @@\n+                if (availableInCryptoCheckers &&\n+                        svcData.svcType.equalsIgnoreCase(\"Cipher\")) {\n+                    Provider.Service svc = p.getService(svcData.svcType, algo);\n+                    if (svc == null) {\n+                        \/\/ The Security::getProviders API does not support\n+                        \/\/ transformations except when the service is explicitly\n+                        \/\/ registered for it.\n+                        continue;\n+                    }\n+                }\n@@ -620,3 +646,4 @@\n-        t.setFilter(\"  SunJCE.Cipher.AES  ;  !  *.*.*WeaK*;\" +\n-                \"MyProvider.*.myStrongAlgorithm*; !NonExistentProvider  \");\n-        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\");\n+        t.setFilter(\"  SunJCE.Mac.HmacSHA512; SUN.MessageDigest.SHA-512  ;\" +\n+                \"  !  *.*.*WeaK*;MyProvider.*.myStrongAlgorithm*; \" +\n+                \"!NonExistentProvider  \");\n+        t.addExpectedService(\"SunJCE\", \"Mac\", \"HmacSHA512\");\n@@ -641,0 +668,23 @@\n+    private static void testCipherFiltering(TestExecutor t) throws Throwable {\n+        t.setFilter(\"!*.Cipher.AES; *.Cipher.AES\/CBC\/PKCS5Padding; \" +\n+                \"*.Cipher.\" + KnownOIDs.AES.value().replace(\".\", \"\\\\.\") +\n+                \"\/OFB\/NoPadding; *.Cipher.AES_128\/CBC\/*; \" +\n+                \"*.Cipher.PBEWithHmacSHA512\/256AndAES_128\/CBC\/PKCS5Padding;\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\/CBC\/PKCS5Padding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\/OFB\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES_128\/CBC\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES.value() + \"\/CBC\/PKCS5Padding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES.value() + \"\/OFB\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES_128$CBC$NoPadding.value());\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/PKCS5Padding\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", \"AES\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", KnownOIDs.AES.value());\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", \"AES\/CBC\/NoPadding\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\",\n+                \"PBEWithHmacSHA512\/256AndAES_128\");\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/provider\/ProvidersFilterTest.java","additions":53,"deletions":3,"binary":false,"changes":56,"status":"modified"}]}