{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -1797,1 +1798,2 @@\n-                    if (s.getType().equals(\"KeyStore\")) {\n+                    if (ProvidersFilter.isAllowed(s) &&\n+                            s.getType().equals(\"KeyStore\")) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.event.SecurityProviderServiceEvent;\n-\n@@ -35,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -40,0 +39,5 @@\n+import jdk.internal.access.JavaSecurityProviderAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.event.SecurityProviderServiceEvent;\n+import sun.security.jca.ProvidersFilter;\n+\n@@ -119,0 +123,20 @@\n+    static {\n+        SharedSecrets.setJavaSecurityProviderAccess(\n+                new JavaSecurityProviderAccess() {\n+                    @Override\n+                    public Set<Service> getServicesNotAllowed(Provider p) {\n+                        return p.getServicesNotAllowed();\n+                    }\n+\n+                    @Override\n+                    public List<String> getAliases(Service svc) {\n+                        return svc.getAliases();\n+                    }\n+\n+                    @Override\n+                    public boolean getIsAllowed(Service svc) {\n+                        return svc.getIsAllowed();\n+                    }\n+                });\n+    }\n+\n@@ -195,2 +219,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -235,2 +258,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -767,1 +789,1 @@\n-    public Object get(Object key) {\n+    public synchronized Object get(Object key) {\n@@ -792,1 +814,1 @@\n-    public Enumeration<Object> keys() {\n+    public synchronized Enumeration<Object> keys() {\n@@ -799,1 +821,1 @@\n-    public Enumeration<Object> elements() {\n+    public synchronized Enumeration<Object> elements() {\n@@ -825,9 +847,0 @@\n-    \/\/ legacyMap changed since last call to getServices()\n-    private transient volatile boolean legacyChanged;\n-    \/\/ serviceMap changed since last call to getServices()\n-    private transient volatile boolean servicesChanged;\n-\n-    \/\/ Map<ServiceKey,Service>\n-    \/\/ used for services added via putService(), initialized on demand\n-    private transient Map<ServiceKey,Service> serviceMap;\n-\n@@ -840,1 +853,7 @@\n-    private transient Set<String> prngAlgos;\n+    private transient Set<ServiceKey> prngAlgos;\n+\n+    \/\/ Map of services registered by this provider. This map may be republished\n+    \/\/ (assigned to a new one instead of modified in place) when a series of\n+    \/\/ changes with the Legacy API must be seen by readers as an atomic\n+    \/\/ operation. See Providers::putAll.\n+    private transient volatile ServicesMap servicesMap;\n@@ -842,3 +861,179 @@\n-    \/\/ Map<ServiceKey,Service>\n-    \/\/ used for services added via legacy methods, init on demand\n-    private transient Map<ServiceKey,Service> legacyMap;\n+    \/*\n+     * This class defines a structure to store and obtain services registered by\n+     * this provider, according to the Current (preferred) and Legacy APIs.\n+     * Synchronization is required for write accesses, while reads are\n+     * lock-free. When a service is added to this structure, it goes through\n+     * the Providers filter and, if allowed, is available for use.\n+     *\/\n+    private final class ServicesMap {\n+        \/*\n+         * Enum to inform the result of an operation on the services map.\n+         *\/\n+        enum SvcOpResult {\n+            SUCCESS,\n+            ERROR\n+        }\n+\n+        \/*\n+         * Interface to add and remove services to the map according to the\n+         * Current API. These functions update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Legacy API may be overwritten with this API.\n+         *\n+         * This interface guarantees atomicity from a service reader point\n+         * of view. In other words, a reader that gets a service will see all\n+         * its attributes and aliases as they were at time of registration.\n+         * Also, a Providers filter decision is made for services added to\n+         * this map and will not change.\n+         *\/\n+        interface Current {\n+            SvcOpResult putService(Service svc);\n+            SvcOpResult removeService(Service svc);\n+        }\n+\n+        \/*\n+         * Interface to add, modify and remove services on the map according to\n+         * the Legacy API. These functions update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Current API cannot be overwritten with\n+         * this API.\n+         *\n+         * Notice that this interface does not guarantee atomicity in a\n+         * sequence of operations from a service reader point of view. As\n+         * an example, a service reader may get a service missing an attribute\n+         * if looked up between a writer's putClassName() and putAttribute()\n+         * calls. Conversely, the Providers filter decision for a service may\n+         * vary as aliases are added or removed. For atomic changes with the\n+         * Legacy API see Provider::putAll.\n+         *\/\n+        interface Legacy {\n+            SvcOpResult putClassName(ServiceKey key, String className,\n+                    String propKey);\n+            SvcOpResult putAlias(ServiceKey key, ServiceKey aliasKey,\n+                    String propKey);\n+            SvcOpResult putAttribute(ServiceKey key, String attrName,\n+                    String attrValue, String propKey);\n+            SvcOpResult remove(ServiceKey key, String className);\n+            SvcOpResult removeAlias(ServiceKey key, ServiceKey aliasKey);\n+            SvcOpResult removeAttribute(ServiceKey key, String attrName,\n+                    String attrValue);\n+        }\n+\n+        \/*\n+         * This class is the internal implementation of the services map.\n+         * Services can be added or removed either through the Current or the\n+         * Legacy API.\n+         *\/\n+        private final class ServicesMapImpl implements Current, Legacy {\n+            \/*\n+             * Record to aggregate information about the lookup of a service on\n+             * the internal map. See ServicesMapImpl::find for a description of\n+             * possible values.\n+             *\/\n+            private record MappingInfo(Service svc, ServiceKey algKey,\n+                    Boolean isLegacy) {}\n+\n+            \/\/ The internal services map, containing services registered with\n+            \/\/ the Current and the Legacy APIs. Concurrent read and write access\n+            \/\/ to this map is expected. Both algorithm and alias service keys\n+            \/\/ are added to this map.\n+            private final Map<ServiceKey, Service> services;\n+\n+            \/\/ Auxiliary set to determine if a service on the services map\n+            \/\/ was added with the Legacy API. The absence of a service key\n+            \/\/ on this set is an indication that the service was either not\n+            \/\/ added or added with the Current API. Only algorithm service keys\n+            \/\/ are added to this set.\n+            private final Set<ServiceKey> legacySvcKeys;\n+\n+            \/\/ Auxiliary map to keep track of the Properties map entries that\n+            \/\/ originated entries on the internal map. This information is used\n+            \/\/ to avoid inconsistencies. Both algorithm and alias service keys\n+            \/\/ are added to this map.\n+            private final Map<ServiceKey, String> serviceProps;\n+\n+            \/\/ Auxiliary map to keep track of the Properties map entries that\n+            \/\/ originated service attributes on the internal map. This\n+            \/\/ information is used to avoid inconsistencies. Only algorithm\n+            \/\/ service keys are added to this map.\n+            private final Map<ServiceKey, Map<UString, String>>\n+                    serviceAttrProps;\n+\n+            ServicesMapImpl() {\n+                services = new ConcurrentHashMap<>();\n+                legacySvcKeys = new HashSet<>();\n+                serviceProps = new HashMap<>();\n+                serviceAttrProps = new HashMap<>();\n+            }\n+\n+            \/*\n+             * Constructor to create a thin working copy such that readers of\n+             * the original map do not notice new changes. Used for atomic\n+             * changes with the Legacy API. See Providers::putAll.\n+             *\/\n+            ServicesMapImpl(ServicesMapImpl original) {\n+                services = new ConcurrentHashMap<>(original.services);\n+                legacySvcKeys = original.legacySvcKeys;\n+                serviceProps = original.serviceProps;\n+                serviceAttrProps = original.serviceAttrProps;\n+            }\n+\n+            \/*\n+             * Finds information about a service on the internal map. The key\n+             * for the lookup can be either algorithm or alias based. If the\n+             * service is found, svc refers to it, algKey to the algorithm\n+             * service key and isLegacy informs if the service was stored with\n+             * the Current or the Legacy API. Otherwise, svc is null, algKey\n+             * refers to the key used for the lookup and isLegacy is null.\n+             *\/\n+            private MappingInfo find(ServiceKey key) {\n+                Service svc = services.get(key);\n+                ServiceKey algKey = svc != null ? svc.algKey : key;\n+                Boolean isLegacy = svc != null ?\n+                        legacySvcKeys.contains(algKey) : null;\n+                return new MappingInfo(svc, algKey, isLegacy);\n+            }\n+\n+            \/*\n+             * Returns a set of services with services stored on the internal\n+             * map that are either allowed or not allowed according to the\n+             * Providers filter. This method can be invoked concurrently with\n+             * write accesses on the map and is lock-free.\n+             *\/\n+            Set<Service> getServices(boolean allowed) {\n+                Set<Service> set = new LinkedHashSet<>();\n+                for (Map.Entry<ServiceKey, Service> e : services.entrySet()) {\n+                    Service svc = e.getValue();\n+                    \/\/\n+                    \/\/ Skip alias based entries and filter out invalid services.\n+                    \/\/\n+                    \/\/ Note: Multiple versions of the same service (reflecting\n+                    \/\/ different points in time) can be generated by concurrent\n+                    \/\/ writes with the Legacy API and, as a result of the\n+                    \/\/ copy-on-write strategy, seen under different service\n+                    \/\/ keys here. Each version has a unique object identity\n+                    \/\/ and, thus, would be distinguishable for a Set<Service>\n+                    \/\/ set. To avoid duplicates, we skip alias keys and use\n+                    \/\/ the version of the service pointed by the algorithm key.\n+                    if (e.getKey().equals(svc.algKey) &&\n+                            svc.getIsAllowed() == allowed && isValid(svc)) {\n+                        set.add(svc);\n+                    }\n+                }\n+                return set;\n+            }\n+\n+            Service getAllowed(ServiceKey key) {\n+                Service svc = services.get(key);\n+                return svc != null && isValid(svc) && svc.getIsAllowed() ?\n+                        svc : null;\n+            }\n+\n+            void clear() {\n+                services.clear();\n+                legacySvcKeys.clear();\n+                serviceProps.clear();\n+                serviceAttrProps.clear();\n+            }\n@@ -846,3 +1041,726 @@\n-    \/\/ Set<Service>\n-    \/\/ Unmodifiable set of all services. Initialized on demand.\n-    private transient volatile Set<Service> serviceSet;\n+            \/*\n+             * Signals that there were changes on the services map and either\n+             * the cached set of allowed or not allowed services need to be\n+             * recomputed before use.\n+             *\/\n+            private void notifyChanges(boolean allowedChange) {\n+                if (allowedChange) {\n+                    allowedSet.set(null);\n+                } else {\n+                    notAllowedSet.set(null);\n+                }\n+            }\n+\n+            \/*\n+             * A service is invalid if it was added with the Legacy API through\n+             * an alias and does not have class information yet. We keep these\n+             * services on the internal map but filter them out for readers, so\n+             * they don't cause a NullPointerException when trying to create a\n+             * new instance.\n+             *\/\n+            private boolean isValid(Service svc) {\n+                return svc.className != null;\n+            }\n+\n+            \/*\n+             * Current API methods to add and remove services.\n+             *\/\n+\n+            @Override\n+            public SvcOpResult putService(Service svc) {\n+                \/\/ At this point, the caller's check for putProviderProperty\n+                \/\/ permission succeeded, so it is safe to generate keys for the\n+                \/\/ service that will be on the map.\n+                svc.generateServiceKeys();\n+\n+                \/\/ Define a set of algorithm and alias keys that, if already\n+                \/\/ on the services map, will be kept at all times until\n+                \/\/ overwritten. This prevents concurrent readers from seeing\n+                \/\/ 'holes' on the map while doing updates.\n+                Set<ServiceKey> keysToBeKept =\n+                        new HashSet<>(svc.aliasKeys.size() + 1);\n+                keysToBeKept.add(svc.algKey);\n+                keysToBeKept.addAll(svc.aliasKeys.keySet());\n+\n+                \/\/ The new service algorithm key may be in use already.\n+                resolveKeyConflict(svc.algKey, keysToBeKept);\n+\n+                \/\/ Services added to the services map must go through the\n+                \/\/ Providers filter first so readers do not have any performance\n+                \/\/ penalty.\n+                \/\/\n+                \/\/ Note: if isAllowed is set to a non-null value, aliases have\n+                \/\/ not changed since the last computation, so the computed value\n+                \/\/ remains valid. This is because services added with the\n+                \/\/ Current API are immutable, and services added with the Legacy\n+                \/\/ API are copied before modified.\n+                if (svc.isAllowed == null) {\n+                    svc.computeIsAllowed();\n+                }\n+\n+                \/\/ The service will be registered to its provider's ServicesMap.\n+                svc.registered = true;\n+\n+                \/\/ Register the new service under its algorithm service key.\n+                \/\/ At this point, readers  will have access to it.\n+                services.put(svc.algKey, svc);\n+\n+                \/\/ Add an entry to the Properties map to reflect the new service\n+                \/\/ under its algorithm key, and keep track of this information\n+                \/\/ for further changes in the future (i.e. removal of the\n+                \/\/ service).\n+                String propKey = svc.getType() + \".\" + svc.getAlgorithm();\n+                serviceProps.put(svc.algKey, propKey);\n+                Provider.super.put(propKey, svc.getClassName());\n+\n+                \/\/ Register the new service under its aliases.\n+                for (Map.Entry<ServiceKey, String> e :\n+                        svc.aliasKeys.entrySet()) {\n+                    ServiceKey aliasKey = e.getKey();\n+\n+                    \/\/ The new service alias may be in use already.\n+                    resolveKeyConflict(aliasKey, keysToBeKept);\n+\n+                    \/\/ Register the new service under its alias service key. At\n+                    \/\/ this point, readers will have access through this alias.\n+                    services.put(aliasKey, svc);\n+\n+                    \/\/ Add an entry to the Properties map to reflect the new\n+                    \/\/ service under its alias service key, and keep track\n+                    \/\/ of this information for further changes in the future\n+                    \/\/ (i.e. removal of the service).\n+                    propKey = ALIAS_PREFIX + svc.getType() + \".\" + e.getValue();\n+                    serviceProps.put(aliasKey, propKey);\n+                    Provider.super.put(propKey, svc.getAlgorithm());\n+                }\n+\n+                if (!svc.attributes.isEmpty()) {\n+                    \/\/ Register the new service attributes on the Properties map\n+                    \/\/ and keep track of them for further changes in the future\n+                    \/\/ (i.e. removal of the service).\n+                    Map<UString, String> newAttrProps =\n+                            new HashMap<>(svc.attributes.size());\n+                    for (Map.Entry<UString, String> attr :\n+                            svc.attributes.entrySet()) {\n+                        propKey = svc.getType() + \".\" + svc.getAlgorithm() +\n+                                \" \" + attr.getKey().string;\n+                        newAttrProps.put(attr.getKey(), propKey);\n+                        Provider.super.put(propKey, attr.getValue());\n+                    }\n+                    serviceAttrProps.put(svc.algKey, newAttrProps);\n+                }\n+\n+                Provider.this.checkAndUpdateSecureRandom(svc.algKey, true);\n+\n+                return SvcOpResult.SUCCESS;\n+            }\n+\n+            \/*\n+             * Handle cases in which a service key (algorithm or alias based)\n+             * is in use already. This might require modifications to a service,\n+             * the Properties map or auxiliary structures. This method must be\n+             * called from the Current API only.\n+             *\/\n+            private void resolveKeyConflict(ServiceKey key,\n+                    Set<ServiceKey> keysToBeKept) {\n+                assert keysToBeKept.contains(key) : \"Inconsistent \" +\n+                        \"keysToBeKept set.\";\n+                MappingInfo miByKey = find(key);\n+                if (miByKey.svc != null) {\n+                    \/\/ The service key (algorithm or alias) is in use already.\n+                    SvcOpResult opResult = SvcOpResult.SUCCESS;\n+                    if (miByKey.algKey.equals(key)) {\n+                        \/\/ It is used as an algorithm. Remove the service.\n+                        opResult = removeCommon(miByKey, false, keysToBeKept);\n+                    } else {\n+                        \/\/ It is used as an alias.\n+                        if (miByKey.isLegacy) {\n+                            \/\/ The service was added with the Legacy API.\n+                            \/\/ Remove the alias only.\n+                            opResult = removeAlias(miByKey.algKey, key,\n+                                    keysToBeKept);\n+                        } else {\n+                            \/\/ The service was added with the Current API.\n+                            \/\/ Overwrite the alias entry on the services map\n+                            \/\/ without modifying the service that is currently\n+                            \/\/ using it.\n+\n+                            \/\/ Remove any Properties map key entry because, if\n+                            \/\/ no longer used as an alias, the entry would not\n+                            \/\/ be overwritten. Note: The serviceProps key entry\n+                            \/\/ will be overwritten later.\n+                            String oldPropKey = serviceProps.remove(key);\n+                            assert oldPropKey != null :\n+                                    \"Invalid alias property.\";\n+                            Provider.super.remove(oldPropKey);\n+                        }\n+                    }\n+                    assert opResult == SvcOpResult.SUCCESS : \"Unexpected\" +\n+                            \" error removing an existing service or alias.\";\n+                }\n+            }\n+\n+            @Override\n+            public SvcOpResult removeService(Service svc) {\n+                if (svc.algKey != null) {\n+                    MappingInfo mi = find(svc.algKey);\n+                    if (mi.svc != null) {\n+                        SvcOpResult opResult = removeCommon(mi, false,\n+                                Collections.emptySet());\n+                        assert opResult == SvcOpResult.SUCCESS : \"Unexpected\" +\n+                                \" error removing an existing service.\";\n+                        return opResult;\n+                    }\n+                }\n+                return SvcOpResult.SUCCESS;\n+            }\n+\n+            \/*\n+             * Common (Current and Legacy) API methods to add and remove\n+             * services.\n+             *\/\n+\n+            \/*\n+             * This method is invoked both when removing and overwriting a\n+             * service. The keysToBeKept set is used when overwriting to\n+             * prevent readers from seeing a 'hole' on the services map\n+             * between removing and adding entries.\n+             *\/\n+            private SvcOpResult removeCommon(MappingInfo mi,\n+                    boolean legacyApiCall, Set<ServiceKey> keysToBeKept) {\n+                assert mi.svc != null : \"Invalid service for removal.\";\n+                if (!mi.isLegacy && legacyApiCall) {\n+                    \/\/ Services added with the Current API cannot be\n+                    \/\/ removed with the Legacy API.\n+                    return SvcOpResult.ERROR;\n+                }\n+\n+                if (mi.isLegacy) {\n+                    legacySvcKeys.remove(mi.algKey);\n+                }\n+\n+                if (!keysToBeKept.contains(mi.algKey)) {\n+                    services.remove(mi.algKey);\n+                }\n+\n+                \/\/ Update the Properties map to reflect the algorithm removal.\n+                \/\/ Note: oldPropKey may be null for services added through\n+                \/\/ aliases or attributes (Legacy API) that still don't have a\n+                \/\/ class name (invalid).\n+                String oldPropKey = serviceProps.remove(mi.algKey);\n+                if (oldPropKey != null) {\n+                    Provider.super.remove(oldPropKey);\n+                }\n+\n+                \/\/ Remove registered service aliases.\n+                for (ServiceKey aliasKey : mi.svc.aliasKeys.keySet()) {\n+                    if (!mi.isLegacy) {\n+                        \/\/ Services added with the Current API can have aliases\n+                        \/\/ overwritten by other services added with the same\n+                        \/\/ API. Do nothing in these cases: the alias on the\n+                        \/\/ services map does not belong to the removed service\n+                        \/\/ anymore.\n+                        MappingInfo miByAlias = find(aliasKey);\n+                        if (miByAlias.svc != mi.svc) {\n+                            continue;\n+                        }\n+                    }\n+                    if (!keysToBeKept.contains(aliasKey)) {\n+                        services.remove(aliasKey);\n+                    }\n+\n+                    \/\/ Update the Properties map to reflect the alias removal.\n+                    \/\/ Note: oldPropKey cannot be null because aliases always\n+                    \/\/ have a corresponding Properties map entry.\n+                    oldPropKey = serviceProps.remove(aliasKey);\n+                    assert oldPropKey != null : \"Unexpected null \" +\n+                            \"Property value for an alias.\";\n+                    Provider.super.remove(oldPropKey);\n+                }\n+\n+                \/\/ Remove registered service attributes.\n+                Map<UString, String> oldAttrProps =\n+                        serviceAttrProps.remove(mi.algKey);\n+                if (oldAttrProps != null) {\n+                    for (String oldAttrPropKey : oldAttrProps.values()) {\n+                        \/\/ Update the Properties map to reflect the attribute\n+                        \/\/ removal. Note: oldAttrPropKey cannot be null because\n+                        \/\/ attributes always have a corresponding Properties map\n+                        \/\/ entry.\n+                        assert oldAttrPropKey != null : \"Unexpected null \" +\n+                                \"Property value for an attribute.\";\n+                        Provider.super.remove(oldAttrPropKey);\n+                    }\n+                }\n+\n+                notifyChanges(mi.svc.getIsAllowed());\n+\n+                Provider.this.checkAndUpdateSecureRandom(mi.svc.algKey, false);\n+\n+                return SvcOpResult.SUCCESS;\n+            }\n+\n+            \/*\n+             * Legacy API methods to add, modify and remove services.\n+             *\/\n+\n+            @Override\n+            public SvcOpResult putClassName(ServiceKey key, String className,\n+                    String propKey) {\n+                assert key != null && className != null && propKey != null :\n+                        \"Service information missing.\";\n+                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                    String canonicalPropKey = propKey;\n+                    if (oldMi.svc != null) {\n+                        \/\/ The service exists. Get its Properties map entry.\n+                        \/\/ Note: Services added through an alias or an attribute\n+                        \/\/ may don't have one.\n+                        String oldPropKey = serviceProps.get(oldMi.algKey);\n+                        if (oldMi.algKey.equals(key)) {\n+                            \/\/ The service was found by an algorithm.\n+                            if (oldPropKey != null) {\n+                                \/\/ Remove any previous Properties map entry\n+                                \/\/ before adding a new one, so we handle\n+                                \/\/ differences in casing.\n+                                Provider.super.remove(oldPropKey);\n+                            }\n+                        } else {\n+                            \/\/ The service was found by an alias. Use an\n+                            \/\/ algorithm entry on the Properties map. Create a\n+                            \/\/ new one if it does not exist.\n+                            canonicalPropKey = oldPropKey != null ?\n+                                    oldPropKey : newSvc.getType() + \".\" +\n+                                    newSvc.getAlgorithm();\n+                        }\n+                    } else {\n+                        \/\/ The service is new. Services added to the services\n+                        \/\/ map must go through the Providers filter first so\n+                        \/\/ readers don't have any performance penalties. Note:\n+                        \/\/ if the service exists already, this is not necessary\n+                        \/\/ because a change in the class name does not affect\n+                        \/\/ the previous filter decision.\n+                        newSvc.computeIsAllowed();\n+                    }\n+\n+                    newSvc.className = className;\n+\n+                    \/\/ Keep track of the Properties map entry for further\n+                    \/\/ changes in the future (i.e. removal of the service).\n+                    serviceProps.put(oldMi.algKey, canonicalPropKey);\n+                    Provider.super.put(canonicalPropKey, className);\n+\n+                    Provider.this.checkAndUpdateSecureRandom(\n+                            newSvc.algKey, true);\n+\n+                    return SvcOpResult.SUCCESS;\n+                });\n+            }\n+\n+            @Override\n+            public SvcOpResult putAlias(ServiceKey key, ServiceKey aliasKey,\n+                    String propKey) {\n+                assert key != null && aliasKey != null && propKey != null :\n+                        \"Alias information missing.\";\n+                assert key.type.equals(aliasKey.type) :\n+                        \"Inconsistent service key types.\";\n+                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                    MappingInfo miByAlias = find(aliasKey);\n+                    if (miByAlias.svc != null) {\n+                        \/\/ The alias is associated to a service on the map.\n+                        if (miByAlias.algKey.equals(aliasKey)) {\n+                            \/\/ The alias is an algorithm. Never overwrite\n+                            \/\/ algorithms with aliases from the Legacy API.\n+                            return SvcOpResult.ERROR;\n+                        } else if (!miByAlias.isLegacy) {\n+                            \/\/ Do not remove the alias of services added with\n+                            \/\/ the Current API.\n+                            return SvcOpResult.ERROR;\n+                        } else if (miByAlias.svc == oldMi.svc) {\n+                            \/\/ The service has the alias that we are adding.\n+                            \/\/ This is possible if, for example, the alias\n+                            \/\/ casing is changing.\n+                            \/\/\n+                            \/\/ Update the Properties map to remove the alias\n+                            \/\/ with the old casing. Note: oldPropKey cannot be\n+                            \/\/ null because aliases always have a corresponding\n+                            \/\/ Properties map entry.\n+                            String oldPropKey = serviceProps.remove(aliasKey);\n+                            assert oldPropKey != null : \"Unexpected null \" +\n+                                    \"Property value for an alias.\";\n+                            Provider.super.remove(oldPropKey);\n+                        } else {\n+                            \/\/ The alias belongs to a different service.\n+                            \/\/ Remove it first.\n+                            SvcOpResult opResult = removeAlias(miByAlias.algKey,\n+                                    aliasKey, Set.of(aliasKey));\n+                            assert opResult == SvcOpResult.SUCCESS :\n+                                    \"Unexpected error removing an alias.\";\n+                        }\n+                    } else {\n+                        \/\/ The alias was not found on the map.\n+                        if (aliasKey.equals(key)) {\n+                            \/\/ The alias would be equal to the algorithm for\n+                            \/\/ the new service.\n+                            return SvcOpResult.ERROR;\n+                        }\n+                    }\n+\n+                    newSvc.addAliasKey(aliasKey);\n+\n+                    \/\/ The new alias can modify the Providers filter decision.\n+                    newSvc.computeIsAllowed();\n+\n+                    \/\/ Keep track of the Properties map entry for further\n+                    \/\/ changes in the future (i.e. removal of the service).\n+                    serviceProps.put(aliasKey, propKey);\n+                    \/\/ If the service to which we will add an alias was found by\n+                    \/\/ an alias, use its algorithm for the Properties map entry.\n+                    String canonicalAlgorithm = oldMi.algKey.equals(key) ?\n+                            key.originalAlgorithm : newSvc.getAlgorithm();\n+                    Provider.super.put(propKey, canonicalAlgorithm);\n+\n+                    return SvcOpResult.SUCCESS;\n+                });\n+            }\n+\n+            @Override\n+            public SvcOpResult putAttribute(ServiceKey key, String attrName,\n+                    String attrValue, String propKey) {\n+                assert key != null && attrName != null && attrValue != null &&\n+                        propKey != null : \"Attribute information missing.\";\n+                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                    String canonicalPropKey = propKey;\n+                    UString attrNameKey = new UString(attrName);\n+                    Map<UString, String> attrProps =\n+                            serviceAttrProps.computeIfAbsent(\n+                                    oldMi.algKey, k -> new HashMap<>());\n+                    assert oldMi.svc != null || attrProps.isEmpty() :\n+                            \"Inconsistent service attributes data.\";\n+                    \/\/ Try to get the attribute's Properties map entry. Note:\n+                    \/\/ oldPropKey can be null if the service was not found or\n+                    \/\/ does not have the attribute.\n+                    String oldPropKey = attrProps.get(attrNameKey);\n+                    if (oldMi.algKey.equals(key)) {\n+                        \/\/ The service was found by an algorithm.\n+                        if (oldPropKey != null) {\n+                            \/\/ Remove any previous Properties map entry before\n+                            \/\/ adding a new one, so we handle differences in\n+                            \/\/ casing.\n+                            Provider.super.remove(oldPropKey);\n+                        }\n+                    } else {\n+                        \/\/ The service was found by an alias. Use an algorithm\n+                        \/\/ based entry on the Properties map. Create a new one\n+                        \/\/ if it does not exist.\n+                        canonicalPropKey = oldPropKey != null ? oldPropKey :\n+                                newSvc.getType() + \".\" + newSvc.getAlgorithm() +\n+                                \" \" + attrName;\n+                    }\n+\n+                    newSvc.addAttribute(attrName, attrValue);\n+\n+                    \/\/ Keep track of the Properties map entry for further\n+                    \/\/ changes in the future (i.e. removal of the service).\n+                    attrProps.put(attrNameKey, canonicalPropKey);\n+                    Provider.super.put(canonicalPropKey, attrValue);\n+\n+                    return SvcOpResult.SUCCESS;\n+                });\n+            }\n+\n+            @Override\n+            public SvcOpResult remove(ServiceKey key, String className) {\n+                assert key != null && className != null :\n+                        \"Service information missing.\";\n+                MappingInfo mi = find(key);\n+                if (mi.svc != null) {\n+                    assert className.equals(mi.svc.getClassName()) :\n+                            \"Unexpected class name.\";\n+                    return removeCommon(mi, true, Collections.emptySet());\n+                }\n+                assert false : \"Should not reach.\";\n+                return SvcOpResult.ERROR;\n+            }\n+\n+            @Override\n+            public SvcOpResult removeAlias(ServiceKey key,\n+                    ServiceKey aliasKey) {\n+                return removeAlias(key, aliasKey, Collections.emptySet());\n+            }\n+\n+            \/*\n+             * This method is invoked both when removing and overwriting a\n+             * service alias. The keysToBeKept set is used when overwriting to\n+             * prevent readers from seeing a 'hole' on the services map between\n+             * removing and adding entries.\n+             *\/\n+            private SvcOpResult removeAlias(ServiceKey key, ServiceKey aliasKey,\n+                    Set<ServiceKey> keysToBeKept) {\n+                assert key != null && aliasKey != null && keysToBeKept != null :\n+                        \"Alias information missing.\";\n+                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                    MappingInfo miByAlias = find(aliasKey);\n+                    if (oldMi.svc != null && miByAlias.svc == oldMi.svc &&\n+                            !miByAlias.algKey.equals(aliasKey)) {\n+                        \/\/ The alias is a real alias and is associated to the\n+                        \/\/ service on the map.\n+                        if (!keysToBeKept.contains(aliasKey)) {\n+                            services.remove(aliasKey);\n+                        }\n+\n+                        newSvc.removeAliasKey(aliasKey);\n+\n+                        \/\/ The removed alias can modify the Providers filter\n+                        \/\/ decision.\n+                        newSvc.computeIsAllowed();\n+\n+                        \/\/ Update the Properties map to reflect the alias\n+                        \/\/ removal. Note: oldPropKey cannot be null because\n+                        \/\/ aliases always have a corresponding Properties map\n+                        \/\/ entry.\n+                        String oldPropKey = serviceProps.remove(aliasKey);\n+                        assert oldPropKey != null : \"Invalid alias property.\";\n+                        Provider.super.remove(oldPropKey);\n+\n+                        return SvcOpResult.SUCCESS;\n+                    }\n+                    assert false : \"Should not reach.\";\n+                    return SvcOpResult.ERROR;\n+                });\n+            }\n+\n+            @Override\n+            public SvcOpResult removeAttribute(ServiceKey key,\n+                    String attrName, String attrValue) {\n+                assert key != null && attrName != null && attrValue != null :\n+                        \"Attribute information missing.\";\n+                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                    Map<UString, String> oldAttrProps =\n+                            serviceAttrProps.get(oldMi.algKey);\n+                    if (oldAttrProps != null) {\n+                        \/\/ The service was found and has attributes.\n+                        assert oldMi.svc != null : \"Inconsistent service \" +\n+                                \"attributes data.\";\n+\n+                        newSvc.removeAttribute(attrName, attrValue);\n+                        assert newSvc.getAttribute(attrName) == null :\n+                                \"Attribute was not removed from the service.\";\n+\n+                        \/\/ Update the Properties map to reflect the attribute\n+                        \/\/ removal. Note: oldPropKey cannot be null because\n+                        \/\/ attributes always have a corresponding Properties\n+                        \/\/ map entry.\n+                        String oldPropKey = oldAttrProps.remove(\n+                                new UString(attrName));\n+                        assert oldPropKey != null :\n+                                \"Invalid attribute property.\";\n+                        Provider.super.remove(oldPropKey);\n+\n+                        if (oldAttrProps.isEmpty()) {\n+                            \/\/ If the removed attribute was the last one,\n+                            \/\/ remove the map.\n+                            serviceAttrProps.remove(oldMi.algKey);\n+                        }\n+\n+                        return SvcOpResult.SUCCESS;\n+                    }\n+                    assert false : \"Should not reach.\";\n+                    return SvcOpResult.ERROR;\n+                });\n+            }\n+\n+            @FunctionalInterface\n+            private interface ServiceUpdateCallback {\n+                SvcOpResult apply(MappingInfo oldMi, Service newSvc);\n+            }\n+\n+            \/*\n+             * This method tries to find a service on the map (based on an\n+             * algorithm or alias) and pass a copy of it to an update callback\n+             * (copy-on-write). If the service found was added with the Current\n+             * API, no update should be done. If a service was not found, a new\n+             * instance may be created.\n+             *\n+             * The updated version of the service is put on the services map.\n+             * Algorithm and alias based entries pointing to the old version\n+             * of the service are overwritten.\n+             *\/\n+            private SvcOpResult updateSvc(ServiceKey key,\n+                    ServiceUpdateCallback updateCb) {\n+                Service newSvc;\n+                MappingInfo oldMi = find(key);\n+                if (oldMi.svc != null) {\n+                    \/\/ Service exits.\n+                    if (!oldMi.isLegacy) {\n+                        \/\/ Don't update services added with the Current API.\n+                        return SvcOpResult.ERROR;\n+                    }\n+                    \/\/ Create a copy of the service for a copy-on-write update.\n+                    newSvc = new Service(oldMi.svc);\n+                } else {\n+                    \/\/ Service does not exist.\n+                    newSvc = new Service(Provider.this, key);\n+                }\n+                SvcOpResult opResult = updateCb.apply(oldMi, newSvc);\n+                if (opResult == SvcOpResult.ERROR) {\n+                    \/\/ Something went wrong and the update should not be done.\n+                    return opResult;\n+                }\n+\n+                \/\/ The service (or its updated version) will be registered to\n+                \/\/ its provider's ServicesMap.\n+                newSvc.registered = true;\n+\n+                \/\/ Register the updated version of the service under its\n+                \/\/ algorithm and aliases on the map. This may overwrite entries\n+                \/\/ or add new ones. The previous callback should have handled\n+                \/\/ the removal of an alias.\n+                for (ServiceKey aliasKey : newSvc.aliasKeys.keySet()) {\n+                    services.put(aliasKey, newSvc);\n+                }\n+\n+                assert oldMi.algKey.type.equals(newSvc.getType()) &&\n+                        oldMi.algKey.originalAlgorithm.equals(\n+                                newSvc.getAlgorithm()) : \"Invalid key.\";\n+                services.put(oldMi.algKey, newSvc);\n+\n+                legacySvcKeys.add(oldMi.algKey);\n+\n+                if (oldMi.svc != null &&\n+                        oldMi.svc.getIsAllowed() != newSvc.getIsAllowed()) {\n+                    \/\/ The updated service transitioned between allowed and not\n+                    \/\/ allowed Providers filter states. Notify according to the\n+                    \/\/ previous state.\n+                    notifyChanges(oldMi.svc.getIsAllowed());\n+                }\n+                \/\/ Notify a change according to the current Providers filter\n+                \/\/ state.\n+                notifyChanges(newSvc.getIsAllowed());\n+\n+                return opResult;\n+            }\n+        }\n+\n+        \/\/ Placeholder for a thread to mark that allowedSet or notAllowedSet\n+        \/\/ values are being computed after a services update. Only one thread\n+        \/\/ at a time can effectively assign this value.\n+        private static final Set<Service> SERVICE_SET_IN_PROGRESS = Set.of();\n+\n+        \/\/ Unmodifiable set of all services allowed by the Providers filter (see\n+        \/\/ sun.security.jca.ProvidersFilter). Possible values for this field\n+        \/\/ are: 1) null (indicates that the set has to be recomputed after a\n+        \/\/ service update), 2) SERVICE_SET_IN_PROGRESS (indicates that a thread\n+        \/\/ is recomputing its value), and 3) an actual set of services.\n+        private final AtomicReference<Set<Service>> allowedSet;\n+\n+        \/\/ Unmodifiable set of all services not allowed by the Providers filter\n+        \/\/ (see sun.security.jca.ProvidersFilter). For informational purposes\n+        \/\/ only (see the -XshowSettings:security:providers JVM argument): do not\n+        \/\/ use services in this set. See allowedSet for possible values.\n+        private final AtomicReference<Set<Service>> notAllowedSet;\n+\n+        \/\/ Implementation of ServicesMap that handles the Current and Legacy\n+        \/\/ APIs.\n+        private final ServicesMapImpl impl;\n+\n+        ServicesMap() {\n+            impl = new ServicesMapImpl();\n+            allowedSet = new AtomicReference<>();\n+            notAllowedSet = new AtomicReference<>();\n+        }\n+\n+        \/*\n+         * Constructor to create a thin working copy such that readers of the\n+         * original map do not notice any new changes. Used for atomic\n+         * changes with the Legacy API. See Providers::putAll.\n+         *\/\n+        ServicesMap(ServicesMap original) {\n+            impl = new ServicesMapImpl(original.impl);\n+            allowedSet = new AtomicReference<>(original.allowedSet.get());\n+            notAllowedSet = new AtomicReference<>(original.notAllowedSet.get());\n+        }\n+\n+        \/*\n+         * Returns a Current API view of the services map.\n+         *\/\n+        Current asCurrent() {\n+            return impl;\n+        }\n+\n+        \/*\n+         * Returns a Legacy API view of the services map.\n+         *\/\n+        Legacy asLegacy() {\n+            return impl;\n+        }\n+\n+        \/*\n+         * Returns a set containing allowed or not allowed services. Recomputes\n+         * allowedSet and notAllowedSet if needed, after a service update. This\n+         * method is thread-safe and lock-free.\n+         *\/\n+        private Set<Service> getServicesSet(boolean allowedServices) {\n+            AtomicReference<Set<Service>> svcSet = allowedServices ?\n+                    allowedSet : notAllowedSet;\n+            Set<Service> serviceSetLocal = svcSet.compareAndExchange(\n+                    null, SERVICE_SET_IN_PROGRESS);\n+            if (serviceSetLocal == null ||\n+                    serviceSetLocal == SERVICE_SET_IN_PROGRESS) {\n+                \/\/ A cached set is not available. Instead of locking, compute\n+                \/\/ the set to be returned and, eventually, make it available\n+                \/\/ for others to use.\n+                Set<Service> newSet = Collections.unmodifiableSet(\n+                        impl.getServices(allowedServices));\n+                if (serviceSetLocal == null) {\n+                    \/\/ We won the race to make the computed set available for\n+                    \/\/ others to use. However, only make it available if it\n+                    \/\/ is still current (in other words, there were no further\n+                    \/\/ changes). If it is not current, the next reader will\n+                    \/\/ do the job.\n+                    svcSet.compareAndExchange(SERVICE_SET_IN_PROGRESS, newSet);\n+                }\n+                serviceSetLocal = newSet;\n+            }\n+            return serviceSetLocal;\n+        }\n+\n+        \/*\n+         * Returns an unmodifiable set of services allowed by the Providers\n+         * filter. Both services added with the Current and Legacy APIs are\n+         * included. If no services are found, the returned set is empty.\n+         * Thread-safe and lock-free.\n+         *\/\n+        Set<Service> getServicesAllowed() {\n+            return getServicesSet(true);\n+        }\n+\n+        \/*\n+         * Returns an unmodifiable set of services not allowed by the Providers\n+         * filter. Both services added with the Current and Legacy APIs are\n+         * included. If no services are found, the returned set is empty.\n+         * Thread-safe and lock-free. For informational purposes only: do not\n+         * use services returned in this set.\n+         *\/\n+        Set<Service> getServicesNotAllowed() {\n+            return getServicesSet(false);\n+        }\n+\n+        \/*\n+         * Returns a service allowed by the Providers filter or null if not\n+         * found. Both services added with the Current and Legacy APIs are\n+         * considered in the search. Thread-safe and lock-free.\n+         *\/\n+        Service getService(ServiceKey key) {\n+            return impl.getAllowed(key);\n+        }\n+\n+        \/*\n+         * Clears the internal ServicesMap state. The caller must synchronize\n+         * changes with the Properties map.\n+         *\/\n+        void clear() {\n+            impl.clear();\n+            allowedSet.set(null);\n+            notAllowedSet.set(null);\n+        }\n+    }\n@@ -861,0 +1779,13 @@\n+    \/*\n+     * Creates a copy of the Properties map that is useful to iterate when\n+     * applying changes to the original one. Notice that we are calling\n+     * super.entrySet() purposefully to avoid landing into a subclass override.\n+     *\/\n+    private Properties copyProperties() {\n+        Properties copy = new Properties(super.size());\n+        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n+            copy.put(entry.getKey(), entry.getValue());\n+        }\n+        return copy;\n+    }\n+\n@@ -876,5 +1807,1 @@\n-        Map<Object,Object> copy = new HashMap<>();\n-        for (Map.Entry<Object,Object> entry : super.entrySet()) {\n-            copy.put(entry.getKey(), entry.getValue());\n-        }\n-\n+        Properties copy = copyProperties();\n@@ -890,2 +1817,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -898,8 +1824,36 @@\n-    \/\/ returns false if no update necessary, i.e. key isn't String or\n-    \/\/ is String, but it's provider-related (name\/version\/info\/className)\n-    private static boolean checkLegacy(Object key) {\n-        if (key instanceof String && ((String)key).startsWith(\"Provider.\")) {\n-            \/\/ ignore provider related updates\n-            return false;\n-        } else {\n-            return true;\n+    \/*\n+     * Enum to determine if changes to the Properties map must be applied by the\n+     * caller (UPDATE) or skipped (SKIP).\n+     *\n+     * If a change does not concern a ServicesMap, UPDATE is returned. An\n+     * example of this is when adding, modifying or removing an entry that is\n+     * not a service, alias or attribute.\n+     *\n+     * If the change concerns a ServicesMap, SKIP is returned. The change may\n+     * have been applied internally or ignored due to an error. In the former\n+     * case, Properties map entries are synchronized. In the latter, Properties\n+     * map entries are not modified.\n+     *\/\n+    private enum PropertiesMapAction {\n+        UPDATE,\n+        SKIP\n+    }\n+\n+    private PropertiesMapAction doLegacyOp(ServicesMap servicesMap, Object key,\n+            Object value, Object oldValue, OPType opType) {\n+        if (key instanceof String ks) {\n+            if (ks.startsWith(\"Provider.\")) {\n+                \/\/ Ignore provider related updates.\n+                return PropertiesMapAction.SKIP;\n+            }\n+            if (value instanceof String vs) {\n+                return parseLegacy(servicesMap, ks, vs, opType);\n+            } else if (value != null && oldValue instanceof String oldValueS &&\n+                    opType == OPType.ADD) {\n+                \/\/ An entry in the Properties map potentially concerning the\n+                \/\/ ServicesMap is about to be replaced by one that does not.\n+                \/\/ From the ServicesMap point of view, this could be equivalent\n+                \/\/ to a removal. In any case, let the caller proceed with the\n+                \/\/ Properties map update.\n+                parseLegacy(servicesMap, ks, oldValueS, OPType.REMOVE);\n+            }\n@@ -907,0 +1861,2 @@\n+        \/\/ The change does not concern a ServicesMap.\n+        return PropertiesMapAction.UPDATE;\n@@ -915,0 +1871,3 @@\n+        \/\/ For service readers to see this change as atomic, add the elements in\n+        \/\/ a local thin copy of the ServicesMap and then publish it.\n+        ServicesMap servicesMapCopy = new ServicesMap(servicesMap);\n@@ -916,1 +1875,1 @@\n-            implPut(e.getKey(), e.getValue());\n+            implPut(servicesMapCopy, e.getKey(), e.getValue());\n@@ -918,0 +1877,1 @@\n+        servicesMap = servicesMapCopy;\n@@ -920,2 +1880,6 @@\n-    private Object implRemove(Object key) {\n-        if (!checkLegacy(key)) return null;\n+    private void implClear() {\n+        servicesMap.clear();\n+        prngAlgos.clear();\n+        super.clear();\n+        putId();\n+    }\n@@ -923,5 +1887,4 @@\n-        Object o = super.remove(key);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.REMOVE);\n-        }\n-        return o;\n+    private Object implRemove(Object key) {\n+        Object oldValue = super.get(key);\n+        return doLegacyOp(servicesMap, key, oldValue, null, OPType.REMOVE) ==\n+                PropertiesMapAction.UPDATE ? super.remove(key) : oldValue;\n@@ -931,5 +1894,3 @@\n-        if (!checkLegacy(key)) return false;\n-\n-        boolean result = super.remove(key, value);\n-        if (result && key instanceof String sk && value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.REMOVE);\n+        if (Objects.equals(super.get(key), value) && value != null) {\n+            implRemove(key);\n+            return !super.contains(key);\n@@ -937,1 +1898,1 @@\n-        return result;\n+        return false;\n@@ -941,9 +1902,6 @@\n-        if (!checkLegacy(key)) return false;\n-\n-        boolean result = super.replace(key, oldValue, newValue);\n-        if (result && key instanceof String sk) {\n-            if (newValue instanceof String sv) {\n-                parseLegacy(sk, sv, OPType.ADD);\n-            } else if (oldValue instanceof String sv) {\n-                parseLegacy(sk, sv, OPType.REMOVE);\n-            }\n+        Objects.requireNonNull(oldValue);\n+        Objects.requireNonNull(newValue);\n+        if (super.containsKey(key) &&\n+                Objects.equals(super.get(key), oldValue)) {\n+            implPut(key, newValue);\n+            return super.get(key) == newValue;\n@@ -951,1 +1909,1 @@\n-        return result;\n+        return false;\n@@ -955,11 +1913,3 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.replace(key, value);\n-        if (key instanceof String sk) {\n-            if (o instanceof String so) {\n-                if (value instanceof String sv) {\n-                    parseLegacy(sk, sv, OPType.ADD);\n-                } else {\n-                    parseLegacy(sk, so, OPType.REMOVE);\n-                }\n-            }\n+        Objects.requireNonNull(value);\n+        if (super.containsKey(key)) {\n+            return implPut(key, value);\n@@ -967,1 +1917,1 @@\n-        return o;\n+        return null;\n@@ -973,15 +1923,3 @@\n-\n-        super.replaceAll(function);\n-        \/\/ clear out all existing mappings and start fresh\n-        legacyMap.clear();\n-        legacyChanged = true;\n-        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-            if ((key instanceof String sk) && (value instanceof String sv)) {\n-                if (!checkLegacy(sk)) {\n-                    continue;\n-                }\n-                parseLegacy(sk, sv, OPType.ADD);\n-            }\n-        }\n+        Properties propertiesCopy = copyProperties();\n+        propertiesCopy.replaceAll(function);\n+        putAll(propertiesCopy);\n@@ -994,9 +1932,8 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.merge(key, value, remappingFunction);\n-        if (key instanceof String sk) {\n-            if (o == null) {\n-                parseLegacy(sk, null, OPType.REMOVE);\n-            } else if (o instanceof String so) {\n-                parseLegacy(sk, so, OPType.ADD);\n-            }\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        Object newValue = (oldValue == null) ? value :\n+                remappingFunction.apply(oldValue, value);\n+        if (newValue == null) {\n+            implRemove(key);\n+        } else {\n+            implPut(key, newValue);\n@@ -1004,1 +1941,1 @@\n-        return o;\n+        return super.get(key);\n@@ -1010,10 +1947,8 @@\n-\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.compute(key, remappingFunction);\n-        if (key instanceof String sk) {\n-            if (o == null) {\n-                parseLegacy(sk, null, OPType.REMOVE);\n-            } else if (o instanceof String so) {\n-                parseLegacy(sk, so, OPType.ADD);\n-            }\n+        Object oldValue = super.get(key);\n+        Object newValue = remappingFunction.apply(key, oldValue);\n+        if (newValue != null) {\n+            implPut(key, newValue);\n+        } else if (oldValue != null) {\n+            \/\/ The Properties map cannot contain null values, so checking\n+            \/\/ super.containsKey(key) would be superfluous.\n+            implRemove(key);\n@@ -1021,1 +1956,1 @@\n-        return o;\n+        return super.get(key);\n@@ -1027,5 +1962,7 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.computeIfAbsent(key, mappingFunction);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.ADD);\n+        Object oldValue = super.get(key);\n+        if (oldValue == null) {\n+            Object newValue = mappingFunction.apply(key);\n+            if (newValue != null) {\n+                implPut(key, newValue);\n+                return super.get(key);\n+            }\n@@ -1033,1 +1970,1 @@\n-        return o;\n+        return oldValue;\n@@ -1039,15 +1976,9 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.computeIfPresent(key, remappingFunction);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.ADD);\n-        }\n-        return o;\n-    }\n-\n-    private Object implPut(Object key, Object value) {\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.put(key, value);\n-        if (key instanceof String sk && value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.ADD);\n+        Object oldValue = super.get(key);\n+        if (oldValue != null) {\n+            Object newValue = remappingFunction.apply(key, oldValue);\n+            if (newValue != null) {\n+                implPut(key, newValue);\n+            } else {\n+                implRemove(key);\n+            }\n+            return super.get(key);\n@@ -1055,1 +1986,1 @@\n-        return o;\n+        return null;\n@@ -1059,1 +1990,4 @@\n-        if (!checkLegacy(key)) return null;\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        return oldValue == null ? implPut(key, value) : oldValue;\n+    }\n@@ -1061,6 +1995,2 @@\n-        Object o = super.putIfAbsent(key, value);\n-        if (o == null && key instanceof String sk &&\n-                value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.ADD);\n-        }\n-        return o;\n+    private Object implPut(Object key, Object value) {\n+        return implPut(servicesMap, key, value);\n@@ -1069,9 +1999,5 @@\n-    private void implClear() {\n-        legacyMap.clear();\n-        serviceMap.clear();\n-        legacyChanged = false;\n-        servicesChanged = false;\n-        serviceSet = null;\n-        prngAlgos.clear();\n-        super.clear();\n-        putId();\n+    private Object implPut(ServicesMap servicesMap, Object key, Object value) {\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        return doLegacyOp(servicesMap, key, value, oldValue, OPType.ADD) ==\n+                PropertiesMapAction.UPDATE ? super.put(key, value) : oldValue;\n@@ -1081,1 +2007,1 @@\n-    private static class ServiceKey {\n+    private static final class ServiceKey {\n@@ -1135,1 +2061,7 @@\n-    private void parseLegacy(String name, String value, OPType opType) {\n+    \/*\n+     * Parse a String entry change on the Properties map and, if concerns to the\n+     * ServicesMap, apply its corresponding operation through the Legacy API.\n+     * Returns whether the change on the Properties map should proceed or not.\n+     *\/\n+    private PropertiesMapAction parseLegacy(ServicesMap servicesMap,\n+            String propKey, String propValue, OPType opType) {\n@@ -1137,1 +2069,1 @@\n-        if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {\n+        if (propKey.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {\n@@ -1140,1 +2072,1 @@\n-            String aliasKeyStr = name.substring(ALIAS_LENGTH);\n+            String aliasKeyStr = propKey.substring(ALIAS_LENGTH);\n@@ -1143,1 +2075,1 @@\n-                return;\n+                return PropertiesMapAction.UPDATE;\n@@ -1145,2 +2077,2 @@\n-            legacyChanged = true;\n-            Objects.requireNonNull(value, \"alias value should map to an alg\");\n+            Objects.requireNonNull(propValue,\n+                    \"alias value should map to an alg\");\n@@ -1149,2 +2081,1 @@\n-            ServiceKey stdKey = new ServiceKey(type, value, true);\n-            Service stdService = legacyMap.get(stdKey);\n+            ServiceKey svcKey = new ServiceKey(type, propValue, true);\n@@ -1153,22 +2084,4 @@\n-                case ADD:\n-                    \/\/ clean up old alias if present\n-                    Service prevAliasService = legacyMap.get(aliasKey);\n-                    if (prevAliasService != null) {\n-                        prevAliasService.removeAlias(aliasAlg);\n-                    }\n-                    if (stdService == null) {\n-                        \/\/ add standard mapping in order to add alias\n-                        stdService = new Service(this, type, value);\n-                        legacyMap.put(stdKey, stdService);\n-                    }\n-                    stdService.addAlias(aliasAlg);\n-                    legacyMap.put(aliasKey, stdService);\n-                    break;\n-                case REMOVE:\n-                    if (stdService != null) {\n-                        stdService.removeAlias(aliasAlg);\n-                    }\n-                    legacyMap.remove(aliasKey);\n-                    break;\n-                default:\n-                    throw new AssertionError();\n+                case ADD -> servicesMap.asLegacy()\n+                        .putAlias(svcKey, aliasKey, propKey);\n+                case REMOVE -> servicesMap.asLegacy()\n+                        .removeAlias(svcKey, aliasKey);\n@@ -1177,1 +2090,1 @@\n-            String[] typeAndAlg = getTypeAndAlgorithm(name);\n+            String[] typeAndAlg = getTypeAndAlgorithm(propKey);\n@@ -1179,1 +2092,1 @@\n-                return;\n+                return PropertiesMapAction.UPDATE;\n@@ -1181,1 +2094,0 @@\n-            legacyChanged = true;\n@@ -1187,3 +2099,2 @@\n-                String stdAlg = typeAndAlg[1].intern();\n-                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n-                Service stdService = legacyMap.get(stdKey);\n+                String algo = typeAndAlg[1].intern();\n+                ServiceKey svcKey = new ServiceKey(type, algo, true);\n@@ -1191,26 +2102,4 @@\n-                    case ADD:\n-                        Objects.requireNonNull(value,\n-                                \"className can't be null\");\n-                        if (stdService == null) {\n-                            stdService = new Service(this, type, stdAlg);\n-                            legacyMap.put(stdKey, stdService);\n-                        }\n-                        stdService.className = value;\n-                        break;\n-                    case REMOVE:\n-                        \/\/ only remove if value also matches when non-null\n-                        if (stdService != null) {\n-                            if (value == null) {\n-                                legacyMap.remove(stdKey);\n-                            } else if (stdService.className.equals(value)) {\n-                                legacyMap.remove(stdKey, stdService);\n-                            }\n-                            \/\/ remove all corresponding alias mappings\n-                            for (String alias : stdService.getAliases()) {\n-                                legacyMap.remove(new ServiceKey(type, alias,\n-                                        true), stdService);\n-                            }\n-                        }\n-                        break;\n-                    default:\n-                        throw new AssertionError();\n+                    case ADD -> servicesMap.asLegacy()\n+                            .putClassName(svcKey, propValue, propKey);\n+                    case REMOVE -> servicesMap.asLegacy()\n+                            .remove(svcKey, propValue);\n@@ -1218,2 +2107,0 @@\n-                checkAndUpdateSecureRandom(type, stdAlg,\n-                        (opType != OPType.REMOVE));\n@@ -1224,1 +2111,1 @@\n-                String stdAlg = attrString.substring(0, i).intern();\n+                String algo = attrString.substring(0, i).intern();\n@@ -1231,2 +2118,1 @@\n-                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n-                Service stdService = legacyMap.get(stdKey);\n+                ServiceKey svcKey = new ServiceKey(type, algo, true);\n@@ -1234,17 +2120,4 @@\n-                    case ADD:\n-                        Objects.requireNonNull(value,\n-                                \"attribute value should not be null\");\n-\n-                        if (stdService == null) {\n-                            stdService = new Service(this, type, stdAlg);\n-                            legacyMap.put(stdKey, stdService);\n-                        }\n-                        stdService.addAttribute(attrName, value);\n-                        break;\n-                    case REMOVE:\n-                        if (stdService != null) {\n-                            stdService.removeAttribute(attrName, value);\n-                        }\n-                        break;\n-                default:\n-                    throw new AssertionError();\n+                    case ADD -> servicesMap.asLegacy()\n+                            .putAttribute(svcKey, attrName, propValue, propKey);\n+                    case REMOVE -> servicesMap.asLegacy()\n+                            .removeAttribute(svcKey, attrName, propValue);\n@@ -1254,0 +2127,1 @@\n+        return PropertiesMapAction.SKIP;\n@@ -1259,4 +2133,1 @@\n-     * implementation exists, this method returns {@code null}. If there are two\n-     * matching services, one added to this provider using\n-     * {@link #putService putService()} and one added via {@link #put put()},\n-     * the service added via {@link #putService putService()} is returned.\n+     * implementation exists, this method returns {@code null}.\n@@ -1285,7 +2156,1 @@\n-        Service s = serviceMap.get(key);\n-        if (s == null) {\n-            s = legacyMap.get(key);\n-            if (s != null && !s.isValid()) {\n-                legacyMap.remove(key, s);\n-            }\n-        }\n+        Service s = servicesMap.getService(key);\n@@ -1324,19 +2189,14 @@\n-        if (serviceSet == null || legacyChanged || servicesChanged) {\n-            Set<Service> set = new LinkedHashSet<>();\n-            if (!serviceMap.isEmpty()) {\n-                set.addAll(serviceMap.values());\n-            }\n-            if (!legacyMap.isEmpty()) {\n-                legacyMap.entrySet().forEach(entry -> {\n-                    if (!entry.getValue().isValid()) {\n-                        legacyMap.remove(entry.getKey(), entry.getValue());\n-                    } else {\n-                        set.add(entry.getValue());\n-                    }\n-                });\n-            }\n-            serviceSet = Collections.unmodifiableSet(set);\n-            servicesChanged = false;\n-            legacyChanged = false;\n-        }\n-        return serviceSet;\n+        return servicesMap.getServicesAllowed();\n+    }\n+\n+    \/*\n+     * This method returns an unmodifiable set of services that are supported\n+     * by this provider but not allowed by the Providers filter (see\n+     * sun.security.jca.ProvidersFilter). These services must not be used for\n+     * anything other than informational purposes (see\n+     * sun.launcher.SecuritySettings and the -XshowSettings:security:providers\n+     * JVM argument).\n+     *\/\n+    private Set<Service> getServicesNotAllowed() {\n+        checkInitialized();\n+        return servicesMap.getServicesNotAllowed();\n@@ -1347,5 +2207,4 @@\n-     * name exists, and it was added using {@link #putService putService()},\n-     * it is replaced by the new service.\n-     * This method also places information about this service\n-     * in the provider's Hashtable values in the format described in the\n-     * {@extLink security_guide_jca\n+     * name exists, and it was added using {@link #putService putService()} or\n+     * {@link #put put()}, it is replaced by the new service. This method also\n+     * places information about this service in the provider's Hashtable\n+     * values in the format described in the {@extLink security_guide_jca\n@@ -1374,1 +2233,1 @@\n-    protected void putService(Service s) {\n+    protected synchronized void putService(Service s) {\n@@ -1386,13 +2245,1 @@\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        ServiceKey key = new ServiceKey(type, algorithm, true);\n-        implRemoveService(serviceMap.get(key));\n-        serviceMap.put(key, s);\n-        for (String alias : s.getAliases()) {\n-            serviceMap.put(new ServiceKey(type, alias, true), s);\n-        }\n-        servicesChanged = true;\n-        synchronized (this) {\n-            putPropertyStrings(s);\n-            checkAndUpdateSecureRandom(type, algorithm, true);\n-        }\n+        servicesMap.asCurrent().putService(s);\n@@ -1401,3 +2248,2 @@\n-    private void checkAndUpdateSecureRandom(String type, String algo,\n-            boolean doAdd) {\n-        if (type.equalsIgnoreCase(\"SecureRandom\")) {\n+    private void checkAndUpdateSecureRandom(ServiceKey algKey, boolean doAdd) {\n+        if (algKey.type.equalsIgnoreCase(\"SecureRandom\")) {\n@@ -1405,1 +2251,1 @@\n-                prngAlgos.add(algo);\n+                prngAlgos.add(algKey);\n@@ -1407,1 +2253,1 @@\n-                prngAlgos.remove(algo);\n+                prngAlgos.remove(algKey);\n@@ -1410,2 +2256,1 @@\n-                debug.println((doAdd? \"Add\":\"Remove\") +\n-                        \" SecureRandom algo \" + algo);\n+                debug.println((doAdd ? \"Add\" : \"Remove\") + \" \" + algKey);\n@@ -1420,3 +2265,1 @@\n-\n-        if (!prngAlgos.isEmpty()) {\n-            String algo = prngAlgos.iterator().next();\n+        for (ServiceKey algKey : prngAlgos) {\n@@ -1426,1 +2269,4 @@\n-            return getService(\"SecureRandom\", algo);\n+            Service svc = getService(\"SecureRandom\", algKey.originalAlgorithm);\n+            if (svc != null && svc.getIsAllowed()) {\n+                return svc;\n+            }\n@@ -1428,1 +2274,0 @@\n-\n@@ -1433,38 +2278,2 @@\n-     * Put the string properties for this Service in this Provider's\n-     * Hashtable.\n-     *\/\n-    private void putPropertyStrings(Service s) {\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        \/\/ use super() to avoid permission check and other processing\n-        super.put(type + \".\" + algorithm, s.getClassName());\n-        for (String alias : s.getAliases()) {\n-            super.put(ALIAS_PREFIX + type + \".\" + alias, algorithm);\n-        }\n-        for (Map.Entry<UString,String> entry : s.attributes.entrySet()) {\n-            String key = type + \".\" + algorithm + \" \" + entry.getKey();\n-            super.put(key, entry.getValue());\n-        }\n-    }\n-\n-    \/**\n-     * Remove the string properties for this Service from this Provider's\n-     * Hashtable.\n-     *\/\n-    private void removePropertyStrings(Service s) {\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        \/\/ use super() to avoid permission check and other processing\n-        super.remove(type + \".\" + algorithm);\n-        for (String alias : s.getAliases()) {\n-            super.remove(ALIAS_PREFIX + type + \".\" + alias);\n-        }\n-        for (Map.Entry<UString,String> entry : s.attributes.entrySet()) {\n-            String key = type + \".\" + algorithm + \" \" + entry.getKey();\n-            super.remove(key);\n-        }\n-    }\n-\n-    \/**\n-     * Remove a service previously added using\n-     * {@link #putService putService()}. The specified service is removed from\n+     * Remove a service previously added using {@link #putService putService()}\n+     * or {@link #put put()}. The specified service is removed from\n@@ -1496,1 +2305,1 @@\n-    protected void removeService(Service s) {\n+    protected synchronized void removeService(Service s) {\n@@ -1504,22 +2313,1 @@\n-        implRemoveService(s);\n-    }\n-\n-    private void implRemoveService(Service s) {\n-        if ((s == null) || serviceMap.isEmpty()) {\n-            return;\n-        }\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        ServiceKey key = new ServiceKey(type, algorithm, false);\n-        Service oldService = serviceMap.get(key);\n-        if (s != oldService) {\n-            return;\n-        }\n-        servicesChanged = true;\n-        serviceMap.remove(key);\n-        for (String alias : s.getAliases()) {\n-            serviceMap.remove(new ServiceKey(type, alias, false));\n-        }\n-\n-        removePropertyStrings(s);\n-        checkAndUpdateSecureRandom(type, algorithm, false);\n+        servicesMap.asCurrent().removeService(s);\n@@ -1671,1 +2459,1 @@\n-        private Map<UString,String> attributes;\n+        private Map<UString, String> attributes;\n@@ -1674,0 +2462,16 @@\n+        \/\/ For services added to a ServicesMap, their algorithm service key.\n+        \/\/ This value derives from the algorithm field. For services (still)\n+        \/\/ not added to a ServicesMap, value is null.\n+        private ServiceKey algKey;\n+\n+        \/\/ For services added to a ServicesMap, this is a map from alias service\n+        \/\/ keys to alias string values. Empty map if no aliases. While map\n+        \/\/ entries derive from the aliases field, keys are not repeated\n+        \/\/ (case-insensitive comparison) and not equal to the algorithm. For\n+        \/\/ services (still) not added to a ServicesMap, value is an empty map.\n+        private Map<ServiceKey, String> aliasKeys;\n+\n+        \/\/ Cached Providers filter state for this service. Value is null when\n+        \/\/ not decided.\n+        private Boolean isAllowed;\n+\n@@ -1702,4 +2506,6 @@\n-        \/\/ this constructor and these methods are used for parsing\n-        \/\/ the legacy string properties.\n-\n-        private Service(Provider provider, String type, String algorithm) {\n+        \/*\n+         * Constructor used from the ServicesMap Legacy API.\n+         *\/\n+        private Service(Provider provider, ServiceKey algKey) {\n+            assert algKey.algorithm.intern() == algKey.algorithm :\n+                    \"Algorithm should be interned.\";\n@@ -1707,2 +2513,3 @@\n-            this.type = type;\n-            this.algorithm = algorithm;\n+            this.algKey = algKey;\n+            algorithm = algKey.originalAlgorithm;\n+            type = algKey.type;\n@@ -1711,0 +2518,1 @@\n+            aliasKeys = Collections.emptyMap();\n@@ -1714,2 +2522,35 @@\n-        private boolean isValid() {\n-            return (type != null) && (algorithm != null) && (className != null);\n+        \/*\n+         * Copy constructor used from the ServicesMap Legacy API for the\n+         * copy-on-write strategy. This constructor is invoked after every\n+         * update to a service on the ServicesMap.\n+         *\/\n+        private Service(Service svc) {\n+            provider = svc.provider;\n+            type = svc.type;\n+            algorithm = svc.algorithm;\n+            algKey = svc.algKey;\n+            className = svc.className;\n+            engineDescription = svc.engineDescription;\n+            if ((Object)svc.aliases == Collections.emptyList()) {\n+                aliases = Collections.emptyList();\n+                aliasKeys = Collections.emptyMap();\n+            } else {\n+                aliases = new ArrayList<>(svc.aliases);\n+                aliasKeys = new HashMap<>(svc.aliasKeys);\n+            }\n+            if ((Object)svc.attributes == Collections.emptyMap()) {\n+                attributes = Collections.emptyMap();\n+            } else {\n+                attributes = new HashMap<>(svc.attributes);\n+            }\n+            isAllowed = svc.isAllowed;\n+            registered = false;\n+\n+            \/\/ Do not copy cached fields because the updated service may have a\n+            \/\/ different class name or attributes and these values have to be\n+            \/\/ regenerated.\n+            classCache = null;\n+            constructorCache = null;\n+            hasKeyAttributes = null;\n+            supportedFormats = null;\n+            supportedClasses = null;\n@@ -1718,2 +2559,11 @@\n-        private void addAlias(String alias) {\n-            if (aliases.isEmpty()) {\n+        \/*\n+         * Methods used from the ServicesMap Legacy API to update a service.\n+         *\/\n+\n+        private void addAliasKey(ServiceKey aliasKey) {\n+            assert !aliasKey.equals(algKey) : \"Alias key cannot be equal to \" +\n+                    \"the algorithm.\";\n+            assert aliasKey.type.equals(type) : \"Invalid alias key type.\";\n+            assert aliasKey.algorithm.intern() == aliasKey.algorithm :\n+                    \"Alias should be interned.\";\n+            if ((Object)aliases == Collections.emptyList()) {\n@@ -1721,0 +2571,5 @@\n+                aliasKeys = new HashMap<>(2);\n+            } else if (aliasKeys.containsKey(aliasKey)) {\n+                \/\/ When overwriting aliases, remove first to handle differences\n+                \/\/ in alias string casing.\n+                removeAliasKey(aliasKey);\n@@ -1722,1 +2577,2 @@\n-            aliases.add(alias);\n+            aliases.add(aliasKey.originalAlgorithm);\n+            aliasKeys.put(aliasKey, aliasKey.originalAlgorithm);\n@@ -1725,5 +2581,5 @@\n-        private void removeAlias(String alias) {\n-            if (aliases.isEmpty()) {\n-                return;\n-            }\n-            aliases.remove(alias);\n+        private void removeAliasKey(ServiceKey aliasKey) {\n+            assert aliasKeys.containsKey(aliasKey) &&\n+                    aliases.contains(aliasKeys.get(aliasKey)) :\n+                    \"Removing nonexistent alias.\";\n+            aliases.remove(aliasKeys.remove(aliasKey));\n@@ -1732,2 +2588,2 @@\n-        void addAttribute(String type, String value) {\n-            if (attributes.isEmpty()) {\n+        private void addAttribute(String attrName, String attrValue) {\n+            if ((Object)attributes == Collections.emptyMap()) {\n@@ -1736,1 +2592,1 @@\n-            attributes.put(new UString(type), value);\n+            attributes.put(new UString(attrName), attrValue);\n@@ -1739,9 +2595,5 @@\n-        void removeAttribute(String type, String value) {\n-            if (attributes.isEmpty()) {\n-                return;\n-            }\n-            if (value == null) {\n-                attributes.remove(new UString(type));\n-            } else {\n-                attributes.remove(new UString(type), value);\n-            }\n+        private void removeAttribute(String attrName, String attrValue) {\n+            UString attrKey = new UString(attrName);\n+            assert attributes.get(attrKey) == attrValue :\n+                    \"Attribute value expected to exist with the same identity.\";\n+            attributes.remove(attrKey, attrValue);\n@@ -1776,0 +2628,1 @@\n+            algKey = null;\n@@ -1782,0 +2635,1 @@\n+            aliasKeys = Collections.emptyMap();\n@@ -1787,1 +2641,2 @@\n-                    this.attributes.put(new UString(entry.getKey()), entry.getValue());\n+                    this.attributes.put(new UString(entry.getKey()),\n+                            entry.getValue());\n@@ -1792,0 +2647,50 @@\n+        \/*\n+         * When a Service is added to a ServicesMap with the Current API,\n+         * service and alias keys must be generated. Currently used by\n+         * ServicesMapImpl::putService. Legacy API methods do not need to call:\n+         * they generated the algorithm key at construction time and alias\n+         * keys with Service::addAliasKey. This method assumes that a\n+         * putProviderProperty permission was checked before, as unprivileged\n+         * callers should not intern Strings.\n+         *\/\n+        private void generateServiceKeys() {\n+            if (algKey == null) {\n+                assert (Object)aliasKeys == Collections.emptyMap() :\n+                        \"aliasKeys expected to be the empty map.\";\n+                algKey = new ServiceKey(type, algorithm, true);\n+                aliasKeys = new HashMap<>(aliases.size());\n+                for (String alias : aliases) {\n+                    ServiceKey aliasKey = new ServiceKey(type, alias, true);\n+                    if (!aliasKey.equals(algKey)) {\n+                        aliasKeys.put(aliasKey, alias);\n+                    }\n+                }\n+                aliasKeys = Collections.unmodifiableMap(aliasKeys);\n+            }\n+        }\n+\n+        \/*\n+         * Returns whether the service is allowed or not according to the\n+         * Providers filter. This decision is usually made when a service\n+         * instance is added to a ServicesMap, and then cached. However, some\n+         * Providers may override Provider::getService or Provider::getServices\n+         * and return Service instances that did not go through the filter\n+         * before. In any case, if the service did not go through the filter,\n+         * evaluate it now and save the result.\n+         *\/\n+        private boolean getIsAllowed() {\n+            if (isAllowed == null) {\n+                computeIsAllowed();\n+            }\n+            return isAllowed == Boolean.TRUE;\n+        }\n+\n+        \/*\n+         * Pass the service through the Providers filter and save the result.\n+         * Called from ServicesMap before adding a Service to the map, and\n+         * from Service::getIsAllowed to handle uncommon cases.\n+         *\/\n+        private void computeIsAllowed() {\n+            isAllowed = ProvidersFilter.computeIsAllowed(this);\n+        }\n+\n@@ -1829,1 +2734,4 @@\n-        \/\/ internal only\n+        \/*\n+         * Method accessed from sun.security.jca.ProvidersFilter and\n+         * sun.launcher.SecuritySettings.\n+         *\/\n@@ -1831,1 +2739,1 @@\n-            return aliases;\n+            return Collections.unmodifiableList(aliases);\n@@ -1881,4 +2789,6 @@\n-                if (provider.getService(type, algorithm) != this) {\n-                    throw new NoSuchAlgorithmException\n-                        (\"Service not registered with Provider \"\n-                        + provider.getName() + \": \" + this);\n+                \/\/ Services never added to a ServicesMap need to be checked.\n+                if (provider.getService(type, algorithm) != this ||\n+                        !getIsAllowed()) {\n+                    throw new NoSuchAlgorithmException(\"Service not \" +\n+                            (!getIsAllowed() ? \"allowed\" : \"registered with \" +\n+                            \"Provider \" + provider.getName()) + \": \" + this);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":1303,"deletions":393,"binary":false,"changes":1696,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -280,1 +281,7 @@\n-                break;\n+                if (prngService != null) {\n+                    if (ProvidersFilter.isAllowed(prngService)) {\n+                        break;\n+                    } else {\n+                        prngService = null;\n+                    }\n+                }\n@@ -293,1 +300,0 @@\n-            this.secureRandomSpi = new sun.security.provider.SecureRandom();\n@@ -295,0 +301,6 @@\n+            try {\n+                this.secureRandomSpi = SecureRandom.getInstance(prngAlgorithm,\n+                        this.provider).secureRandomSpi;\n+            } catch (NoSuchAlgorithmException nsae) {\n+                throw new RuntimeException(\"Default PRNG not found\", nsae);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-     * Returns the property (if any) mapping the key for the given provider.\n+     * Returns a service allowed by the Providers filter given a service type,\n+     * algorithm and provider. Search is case-insensitive.\n@@ -242,10 +243,9 @@\n-    private static String getProviderProperty(String key, Provider provider) {\n-        String prop = provider.getProperty(key);\n-        if (prop == null) {\n-            \/\/ Is there a match if we do a case-insensitive property name\n-            \/\/ comparison? Let's try ...\n-            for (Enumeration<Object> e = provider.keys();\n-                                e.hasMoreElements(); ) {\n-                String matchKey = (String)e.nextElement();\n-                if (key.equalsIgnoreCase(matchKey)) {\n-                    prop = provider.getProperty(matchKey);\n+    private static Provider.Service findService(String type, String algo,\n+            Provider provider) {\n+        \/\/ Try the fast path (when \"type\" has the exact case).\n+        Provider.Service foundSvc = provider.getService(type, algo);\n+        if (foundSvc == null) {\n+            \/\/ Try the slow path (when \"type\" does not have the exact case).\n+            for (Provider.Service svc : provider.getServices()) {\n+                if (svc.getType().equalsIgnoreCase(type)) {\n+                    foundSvc = provider.getService(svc.getType(), algo);\n@@ -256,1 +256,4 @@\n-        return prop;\n+        if (foundSvc != null && ProvidersFilter.isAllowed(foundSvc)) {\n+            return foundSvc;\n+        }\n+        return null;\n@@ -880,24 +883,3 @@\n-            \/\/ Constructed key have ONLY 1 space between algName and attrName\n-            String key = serviceName + '.' + algName +\n-                    (attrName != null ? (' ' + attrName) : \"\");\n-\n-            \/\/ Check whether the provider has a property\n-            \/\/ whose key is the same as the given key.\n-            String propValue = getProviderProperty(key, prov);\n-\n-            if (propValue == null) {\n-                \/\/ Check whether we have an alias instead\n-                \/\/ of a standard name in the key.\n-                String standardName = getProviderProperty(\"Alg.Alias.\" +\n-                        serviceName + \".\" + algName, prov);\n-                if (standardName != null) {\n-                    key = serviceName + \".\" + standardName +\n-                            (attrName != null ? ' ' + attrName : \"\");\n-                    propValue = getProviderProperty(key, prov);\n-                }\n-\n-                if (propValue == null) {\n-                    \/\/ The provider doesn't have the given\n-                    \/\/ key in its property list.\n-                    return false;\n-                }\n+            Provider.Service svc = findService(serviceName, algName, prov);\n+            if (svc == null) {\n+                return false;\n@@ -913,0 +895,5 @@\n+            String foundAttrValue = svc.getAttribute(attrName);\n+            if (foundAttrValue == null) {\n+                return false;\n+            }\n+\n@@ -923,1 +910,1 @@\n-                int maxSize = Integer.parseInt(propValue);\n+                int maxSize = Integer.parseInt(foundAttrValue);\n@@ -930,1 +917,1 @@\n-                propValue = propValue.toUpperCase(Locale.ENGLISH);\n+                foundAttrValue = foundAttrValue.toUpperCase(Locale.ENGLISH);\n@@ -933,1 +920,1 @@\n-                String[] propComponents = propValue.split(\"\\\\|\");\n+                String[] propComponents = foundAttrValue.split(\"\\\\|\");\n@@ -940,1 +927,1 @@\n-                return attrValue.equalsIgnoreCase(propValue);\n+                return attrValue.equalsIgnoreCase(foundAttrValue);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -459,1 +459,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -715,1 +715,1 @@\n-            if (s == null) {\n+            if (s == null || !ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.security.Provider;\n+import java.util.List;\n+import java.util.Set;\n+\n+public interface JavaSecurityProviderAccess {\n+    Set<Provider.Service> getServicesNotAllowed(Provider p);\n+    List<String> getAliases(Provider.Service svc);\n+    boolean getIsAllowed(Provider.Service svc);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecurityProviderAccess.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.security.Provider;\n@@ -88,0 +89,1 @@\n+    private static JavaSecurityProviderAccess javaSecurityProviderAccess;\n@@ -362,0 +364,14 @@\n+    public static void setJavaSecurityProviderAccess(\n+            JavaSecurityProviderAccess jspa) {\n+        javaSecurityProviderAccess = jspa;\n+    }\n+\n+    public static JavaSecurityProviderAccess getJavaSecurityProviderAccess() {\n+        var access = javaSecurityProviderAccess;\n+        if (access == null) {\n+            ensureClassInitialized(Provider.class);\n+            access = javaSecurityProviderAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+        java.security.sasl,\n@@ -332,0 +333,1 @@\n+        java.xml.crypto,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.Collections;\n@@ -143,0 +142,24 @@\n+    private static void printSecurityProviderServices(\n+            Set<Provider.Service> services) {\n+        if (!services.isEmpty()) {\n+            services.stream().sorted(\n+                    Comparator.comparing(Provider.Service::getType)\n+                            .thenComparing(Provider.Service::getAlgorithm))\n+                    .forEach(ps -> {\n+                        ostream.println(THREEINDENT +\n+                                ps.getType() + \".\" + ps.getAlgorithm());\n+                        List<String> aliases = SharedSecrets\n+                                .getJavaSecurityProviderAccess().getAliases(ps);\n+\n+                        if (!aliases.isEmpty()) {\n+                            ostream.println(wrappedString(\n+                                    aliases.stream().sorted()\n+                                            .collect(Collectors.joining(\", \", INDENT + \" aliases: [\", \"]\")),\n+                                    80, \" \" + TWOINDENT, INDENT + THREEINDENT));\n+                        }\n+                    });\n+        } else {\n+            ostream.println(THREEINDENT + \"<none>\");\n+        }\n+    }\n+\n@@ -152,33 +175,8 @@\n-                ostream.println(wrappedString(PROV_INFO_STRING + p.getInfo(), 80,\n-                        TWOINDENT, THREEINDENT));\n-                ostream.println(TWOINDENT + \"Provider services: (type : algorithm)\");\n-                Set<Provider.Service> services = p.getServices();\n-                Set<String> keys = Collections.list(p.keys())\n-                        .stream()\n-                        .map(String.class::cast)\n-                        .filter(s -> s.startsWith(\"Alg.Alias.\"))\n-                        .collect(Collectors.toSet());\n-                if (!services.isEmpty()) {\n-                    services.stream()\n-                            .sorted(Comparator.comparing(Provider.Service::getType)\n-                                    .thenComparing(Provider.Service::getAlgorithm))\n-                            .forEach(ps -> {\n-                                ostream.println(THREEINDENT +\n-                                        ps.getType() + \".\" + ps.getAlgorithm());\n-                                List<String> aliases = keys\n-                                        .stream()\n-                                        .filter(s -> s.startsWith(\"Alg.Alias.\" + ps.getType()))\n-                                        .filter(s -> p.getProperty(s).equals(ps.getAlgorithm()))\n-                                        .map(s -> s.substring((\"Alg.Alias.\" + ps.getType() + \".\").length()))\n-                                        .toList();\n-\n-                                if (!aliases.isEmpty()) {\n-                                    ostream.println(wrappedString(\n-                                            aliases.stream()\n-                                                    .collect(Collectors.joining(\", \", INDENT + \" aliases: [\", \"]\")),\n-                                            80, \" \" + TWOINDENT, INDENT + THREEINDENT));\n-                                }\n-                            });\n-                } else {\n-                    ostream.println(THREEINDENT + \"<none>\");\n-                }\n+                ostream.println(wrappedString(PROV_INFO_STRING + p.getInfo(),\n+                        80, TWOINDENT, THREEINDENT));\n+                ostream.println(TWOINDENT + \"Provider services allowed: (type : algorithm)\");\n+                printSecurityProviderServices(p.getServices());\n+                ostream.println(TWOINDENT + \"Provider services NOT allowed: (type : algorithm)\");\n+                printSecurityProviderServices(\n+                        SharedSecrets.getJavaSecurityProviderAccess()\n+                                .getServicesNotAllowed(p));\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/SecuritySettings.java","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.action;\n-\n-import java.util.Map;\n-\n-import java.security.Provider;\n-import java.security.PrivilegedAction;\n-\n-\/**\n- * A convenience PrivilegedAction class for setting the properties of\n- * a provider. See the SunRsaSign provider for a usage example.\n- *\n- * @see sun.security.rsa.SunRsaSign\n- * @author  Andreas Sterbenz\n- * @since   1.5\n- *\/\n-public class PutAllAction implements PrivilegedAction<Void> {\n-\n-    private final Provider provider;\n-    private final Map<?, ?> map;\n-\n-    public PutAllAction(Provider provider, Map<?, ?> map) {\n-        this.provider = provider;\n-        this.map = map;\n-    }\n-\n-    public Void run() {\n-        provider.putAll(map);\n-        return null;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/PutAllAction.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        if (s == null) {\n+        if (s == null || !ProvidersFilter.isAllowed(s)) {\n@@ -99,1 +99,1 @@\n-        if (s == null) {\n+        if (s == null || !ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/GetInstance.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,1 +377,1 @@\n-                if (s != null) {\n+                if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -386,1 +386,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -522,1 +522,1 @@\n-                    if (s != null) {\n+                    if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -529,1 +529,1 @@\n-                        if (s != null) {\n+                        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,729 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.jca;\n+\n+import java.nio.CharBuffer;\n+import java.security.Provider;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.access.JavaSecurityProviderAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.Debug;\n+import sun.security.util.SecurityProperties;\n+\n+public final class ProvidersFilter {\n+\n+    private static final String FILTER_PROP = \"jdk.security.providers.filter\";\n+\n+    private static final Debug debug = Debug.getInstance(\"jca\",\n+            \"ProvidersFilter\");\n+\n+    private static final JavaSecurityProviderAccess jspa = SharedSecrets\n+            .getJavaSecurityProviderAccess();\n+\n+    private static final class FilterDecision {\n+        private enum Result {\n+            DENY,\n+            ALLOW,\n+            UNDECIDED\n+        }\n+        private static final int UNDEFINED_PRIORITY = -1;\n+        private static final FilterDecision UNDECIDED = new FilterDecision();\n+        private final Result result;\n+        private final int priority;\n+\n+        private FilterDecision() {\n+            this.result = Result.UNDECIDED;\n+            this.priority = UNDEFINED_PRIORITY;\n+        }\n+\n+        FilterDecision(Result result, int priority) {\n+            assert result != Result.UNDECIDED : \"Invalid result.\";\n+            assert priority >= 0 : \"Invalid priority\";\n+            this.result = result;\n+            this.priority = priority;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return result + (priority != UNDEFINED_PRIORITY ? \" - priority: \" +\n+                    priority : \"\");\n+        }\n+\n+        void debugDisplay() {\n+            if (debug == null) {\n+                return;\n+            }\n+            debug.println(\" * Decision: \" + this);\n+        }\n+    }\n+\n+    private record FilterQuery(String provider, String svcType,\n+            String svcAlgo) {\n+        private FilterQuery {\n+            assert provider != null && svcType != null && svcAlgo != null :\n+                    \"Invalid FilterQuery.\";\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Service filter query (Provider: \" + provider +\n+                    \", Service type: \" + svcType + \", Algorithm: \" +\n+                    svcAlgo + \")\";\n+        }\n+    }\n+\n+    private static final class Filter {\n+        private sealed interface Rule permits PatternRule, DefaultRule {\n+            FilterDecision apply(FilterQuery q);\n+        }\n+\n+        private record PatternRuleComponent(Type type, String value,\n+                Pattern regexp) {\n+            enum Type {\n+                PROVIDER(\"Provider\"),\n+                SVC_TYPE(\"Service type\"),\n+                SVC_ALGO(\"Algorithm\");\n+\n+                private final String type;\n+\n+                Type(String type) {\n+                    this.type = type;\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return type;\n+                }\n+            }\n+\n+            private static final Pattern ALL_PATTERN = Pattern.compile(\".*\");\n+\n+            static final PatternRuleComponent ANY_SVC_TYPE =\n+                    new PatternRuleComponent(Type.SVC_TYPE, \"*\", ALL_PATTERN);\n+\n+            static final PatternRuleComponent ANY_SVC_ALGO =\n+                    new PatternRuleComponent(Type.SVC_ALGO, \"*\", ALL_PATTERN);\n+\n+            PatternRuleComponent {\n+                assert value != null && !value.isEmpty() && regexp != null :\n+                        \"Invalid PatternRuleComponent instance.\";\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return value;\n+            }\n+\n+            void debugDisplay() {\n+                if (debug == null) {\n+                    return;\n+                }\n+                debug.println(\" * \" + type + \": \" + value + \" (regexp: \" +\n+                        regexp + \")\");\n+            }\n+        }\n+\n+        private static final class PatternRule implements Rule {\n+            private FilterDecision decision;\n+            private PatternRuleComponent provider;\n+            private PatternRuleComponent svcType;\n+            private PatternRuleComponent svcAlgo;\n+\n+            @Override\n+            public FilterDecision apply(FilterQuery q) {\n+                assert assertIsValid();\n+                if (provider.regexp.matcher(q.provider).matches() &&\n+                        svcType.regexp.matcher(q.svcType).matches() &&\n+                        svcAlgo.regexp.matcher(q.svcAlgo).matches()) {\n+                    return decision;\n+                }\n+                return FilterDecision.UNDECIDED;\n+            }\n+\n+            private boolean assertIsValid() {\n+                assert decision.result != FilterDecision.Result.UNDECIDED :\n+                        \"Invalid decision result.\";\n+                assert decision.priority != FilterDecision.UNDEFINED_PRIORITY :\n+                        \"Invalid decision priority.\";\n+                assert provider != null : \"Invalid provider.\";\n+                assert svcType != null : \"Invalid service type.\";\n+                assert svcAlgo != null : \"Invalid algorithm.\";\n+                return true;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return (decision.result == FilterDecision.Result.DENY ? \"!\" :\n+                        \"\") + provider + \".\" + svcType + \".\" + svcAlgo;\n+            }\n+\n+            void debugDisplay() {\n+                if (debug == null) {\n+                    return;\n+                }\n+                provider.debugDisplay();\n+                svcType.debugDisplay();\n+                svcAlgo.debugDisplay();\n+                decision.debugDisplay();\n+            }\n+        }\n+\n+        private static final class DefaultRule implements Rule {\n+            private final FilterDecision d;\n+\n+            DefaultRule(int priority) {\n+                d = new FilterDecision(FilterDecision.Result.DENY, priority);\n+            }\n+\n+            @Override\n+            public FilterDecision apply(FilterQuery q) {\n+                return d;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"!* (DEFAULT)\";\n+            }\n+        }\n+\n+        private static final class ParserException extends Exception {\n+            @java.io.Serial\n+            private static final long serialVersionUID = -6981287318167654426L;\n+\n+            private static final String LN = System.lineSeparator();\n+\n+            private static final String HEADER_STR = \" * Filter string: \";\n+\n+            private static final String MORE_STR = \"(...)\";\n+\n+            private static final int MORE_TOTAL = MORE_STR.length() + 1;\n+\n+            private static final int MAX_MARK = 7;\n+\n+            private static final int MAX_LINE = 80;\n+\n+            static {\n+                assert MAX_LINE >= HEADER_STR.length() + (MORE_TOTAL * 2) + 1\n+                        : \"Not enough line space.\";\n+            }\n+\n+            private static String addStateInfo(String message, Parser parser) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(message);\n+                sb.append(LN);\n+                sb.append(\" * State: \");\n+                sb.append(parser.state);\n+                sb.append(LN);\n+                renderFilterStr(parser.filterBuff.asReadOnlyBuffer(), sb);\n+                return sb.toString();\n+            }\n+\n+            private static void renderFilterStr(CharBuffer filterBuff,\n+                    StringBuilder sb) {\n+                int filterBuffLen = filterBuff.limit();\n+                int cursor = filterBuff.position() - 1;\n+                int preCutMark, postCutMark;\n+                int lineAvailable = MAX_LINE - HEADER_STR.length() - 1;\n+                int preAvailable = lineAvailable \/ 2;\n+                int postAvailable = (lineAvailable + 1) \/ 2;\n+                boolean preMore = false, postMore = false;\n+                int preCursor, preSpaceCount, preDashCount, postDashCount;\n+\n+                \/\/ Calculate the filter line\n+                if (preAvailable < cursor) {\n+                    preMore = true;\n+                    preAvailable -= MORE_TOTAL;\n+                }\n+                if (postAvailable + cursor + 1 < filterBuffLen) {\n+                    postMore = true;\n+                    postAvailable -= MORE_TOTAL;\n+                }\n+                preCutMark = Math.max(0, cursor - preAvailable);\n+                preAvailable -= cursor - preCutMark;\n+                postCutMark = Math.min(filterBuffLen, cursor + 1 +\n+                        postAvailable);\n+                postAvailable -= postCutMark - (cursor + 1);\n+                if (postAvailable > 0 && preMore) {\n+                    if (preCutMark - (postAvailable + MORE_TOTAL) <= 0) {\n+                        postAvailable += MORE_TOTAL;\n+                        preMore = false;\n+                    }\n+                    preCutMark = Math.max(0, preCutMark - postAvailable);\n+                }\n+                if (preAvailable > 0 && postMore) {\n+                    if (postCutMark + preAvailable + MORE_TOTAL >=\n+                            filterBuffLen) {\n+                        preAvailable += MORE_TOTAL;\n+                        postMore = false;\n+                    }\n+                    postCutMark = Math.min(filterBuffLen, postCutMark +\n+                            preAvailable);\n+                }\n+\n+                \/\/ Calculate the underlining line\n+                preCursor = HEADER_STR.length() + (preMore ? MORE_TOTAL : 0) +\n+                        cursor - preCutMark;\n+                preSpaceCount = Math.max(0, preCursor - MAX_MARK\/2);\n+                preDashCount = Math.min(preCursor, MAX_MARK\/2);\n+                postDashCount = Math.min(MAX_LINE - 1 - preSpaceCount -\n+                        preDashCount, MAX_MARK\/2);\n+\n+                \/\/ Render the filter line\n+                sb.append(HEADER_STR);\n+                if (preMore) {\n+                    sb.append(MORE_STR);\n+                    sb.append(' ');\n+                }\n+                filterBuff.position(0);\n+                sb.append(filterBuff, preCutMark, postCutMark);\n+                if (postMore) {\n+                    sb.append(' ');\n+                    sb.append(MORE_STR);\n+                }\n+                sb.append(LN);\n+\n+                \/\/ Render the underlining line\n+                sb.append(\" \".repeat(preSpaceCount));\n+                sb.append(\"-\".repeat(preDashCount));\n+                sb.append(\"^\");\n+                sb.append(\"-\".repeat(postDashCount));\n+                sb.append(LN);\n+            }\n+\n+            ParserException(String message, Parser parser) {\n+                super(addStateInfo(message, parser));\n+            }\n+        }\n+\n+        private static final class Parser {\n+            private enum ParsingState {\n+                PRE_PATTERN,\n+                PRE_PATTERN_DENY,\n+                PATTERN,\n+                POST_PATTERN\n+            }\n+\n+            private enum Transition {\n+                WHITESPACE_CHAR,\n+                DENY_CHAR,\n+                REGULAR_CHAR,\n+                PATTERN_LEVEL_CHAR,\n+                PATTERN_END_CHAR\n+            }\n+\n+            static List<Rule> parse(String filterStr) throws ParserException {\n+                return new Parser(filterStr).getRules();\n+            }\n+\n+            private final CharBuffer filterBuff;\n+            private final List<Rule> rules;\n+            private PatternRule rule;\n+            private ParsingState state;\n+            private final StringBuffer buff;\n+            private final StringBuffer buffR;\n+            private boolean escape;\n+            private boolean quote;\n+\n+            private Parser(String filterStr) throws ParserException {\n+                filterBuff = CharBuffer.wrap(filterStr);\n+                rules = new ArrayList<>();\n+                rule = new PatternRule();\n+                state = ParsingState.PRE_PATTERN;\n+                buff = new StringBuffer();\n+                buffR = new StringBuffer();\n+                escape = false;\n+                quote = false;\n+                parse();\n+            }\n+\n+            private List<Rule> getRules() {\n+                return rules;\n+            }\n+\n+            private PatternRuleComponent getComponent(\n+                    PatternRuleComponent.Type type) throws ParserException {\n+                if (buff.isEmpty()) {\n+                    throw new ParserException(\"Missing \" +\n+                            type.toString().toLowerCase() + \" in \" +\n+                            \"pattern rule.\", this);\n+                }\n+                if (quote) {\n+                    buffR.append(\"\\\\E\");\n+                    quote = false;\n+                }\n+                return new PatternRuleComponent(type, buff.toString(),\n+                        Pattern.compile(buffR.toString(),\n+                                Pattern.CASE_INSENSITIVE));\n+            }\n+\n+            private void flushBuffers() throws ParserException {\n+                if (rule.provider == null) {\n+                    rule.provider = getComponent(\n+                            PatternRuleComponent.Type.PROVIDER);\n+                } else if (rule.svcType == null) {\n+                    rule.svcType = getComponent(\n+                            PatternRuleComponent.Type.SVC_TYPE);\n+                } else if (rule.svcAlgo == null) {\n+                    rule.svcAlgo = getComponent(\n+                            PatternRuleComponent.Type.SVC_ALGO);\n+                } else {\n+                    assert false : \"Should not reach.\";\n+                }\n+                buff.setLength(0);\n+                buffR.setLength(0);\n+            }\n+\n+            private void endPattern() throws ParserException {\n+                if (escape) {\n+                    throw new ParserException(\"Invalid escaping.\", this);\n+                }\n+                flushBuffers();\n+                if (rule.svcType == null) {\n+                    rule.svcType = PatternRuleComponent.ANY_SVC_TYPE;\n+                }\n+                if (rule.svcAlgo == null) {\n+                    rule.svcAlgo = PatternRuleComponent.ANY_SVC_ALGO;\n+                }\n+                if (debug != null) {\n+                    debug.println(\"--------------------\");\n+                    debug.println(\"Rule parsed: \" + rule);\n+                    rule.debugDisplay();\n+                }\n+                rules.add(rule);\n+                rule = new PatternRule();\n+            }\n+\n+            \/*\n+             * Transition to the next state if there is a valid reason. If the\n+             * reason is not valid, throw an exception. If there are no reasons\n+             * to transition, stay in the same state.\n+             *\/\n+            private void nextState(Transition transition)\n+                    throws ParserException {\n+                if (state == ParsingState.PRE_PATTERN) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in PRE_PATTERN state and ignore whitespaces\n+                        \/\/ at the beginning of a pattern:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm;\"\n+                        \/\/  ^^^^\n+                        \/\/\n+                        \/\/ or\n+                        \/\/\n+                        \/\/ \"    !    Provider.ServiceType.Algorithm;\"\n+                        \/\/  ^^^^\n+                    } else if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Transition to PATTERN state:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;\"\n+                        \/\/     ^^^^\n+                        state = ParsingState.PATTERN;\n+                        rule.decision = new FilterDecision(\n+                                FilterDecision.Result.ALLOW, rules.size());\n+                    } else if (transition == Transition.DENY_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN_DENY state:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/      ^^^^\n+                        state = ParsingState.PRE_PATTERN_DENY;\n+                        rule.decision = new FilterDecision(\n+                                FilterDecision.Result.DENY, rules.size());\n+                    } else {\n+                        throw new ParserException(\"A pattern must start with \" +\n+                                \"a '!' or a security provider name.\", this);\n+                    }\n+                } else if (state == ParsingState.PRE_PATTERN_DENY) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in PRE_PATTERN_DENY state and ignore whitespaces\n+                        \/\/ before the provider:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/      ^^^^\n+                    } else if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Transition to PATTERN state:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/          ^^^^\n+                        state = ParsingState.PATTERN;\n+                    } else {\n+                        throw new ParserException(\"A pattern must have a \" +\n+                                \"security provider name after '!'.\", this);\n+                    }\n+                } else if (state == ParsingState.PATTERN) {\n+                    if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Stay in PATTERN while the provider, service type\n+                        \/\/ and algorithm names fill up:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;\"\n+                        \/\/     ^^^^\n+                    } else if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Transition to POST_PATTERN state, after recording\n+                        \/\/ the parsed rule:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm    ;\"\n+                        \/\/                                   ^^^^\n+                        endPattern();\n+                        state = ParsingState.POST_PATTERN;\n+                    } else if (transition == Transition.PATTERN_END_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN state, after recording\n+                        \/\/ the parsed rule:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;    Provider...\"\n+                        \/\/                                  ^^^\n+                        endPattern();\n+                        state = ParsingState.PRE_PATTERN;\n+                    } else if (transition == Transition.PATTERN_LEVEL_CHAR) {\n+                        \/\/ Stay in PATTERN state while recording characters\n+                        \/\/ for the next level (service type or algorithm):\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm;\"\n+                        \/\/               ^^^^\n+                        if (rule.svcType != null) {\n+                            throw new ParserException(\"Too many levels. Dots \" +\n+                                    \"that are part of a provider name, \" +\n+                                    \"service type or algorithm must be \" +\n+                                    \"escaped.\", this);\n+                        }\n+                        flushBuffers();\n+                    } else {\n+                        throw new ParserException(\"Invalid name in pattern.\",\n+                                this);\n+                    }\n+                } else if (state == ParsingState.POST_PATTERN) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in POST_PATTERN state and ignore whitespaces\n+                        \/\/ until the end of the pattern:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm    ;    Provider\"\n+                        \/\/                                    ^^^^\n+                    } else if (transition == Transition.PATTERN_END_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN state:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm    ;    Provider\"\n+                        \/\/                                       ^^^\n+                        state = ParsingState.PRE_PATTERN;\n+                    } else {\n+                        throw new ParserException(\"Only whitespace characters\" +\n+                                \" are valid after a pattern. Whitespaces that\" +\n+                                \" are part of a provider name, service type \" +\n+                                \"or algorithm must be escaped.\", this);\n+                    }\n+                } else {\n+                    \/\/ Should not reach.\n+                    throw new RuntimeException(\"Unexpected Providers filter \" +\n+                            \"parser state.\");\n+                }\n+            }\n+\n+            private void appendChar(char c) {\n+                if (c == '*' && !escape) {\n+                    \/\/ Character is a wildcard.\n+                    if (quote) {\n+                        buffR.append(\"\\\\E\");\n+                        quote = false;\n+                    }\n+                    buffR.append(\".*\");\n+                } else {\n+                    \/\/ Character is not a wildcard.\n+                    if (escape) {\n+                        buff.append(\"\\\\\");\n+                    }\n+                    if (!quote) {\n+                        buffR.append(\"\\\\Q\");\n+                        quote = true;\n+                    }\n+                    buffR.append(c);\n+                    if (c == '\\\\') {\n+                        \/\/ A '\\' could be problematic because if an 'E' comes\n+                        \/\/ next the sequence \"\\E\" would interfere with regexp\n+                        \/\/ quoting. Split these sequences into separated\n+                        \/\/ quoting units. I.e: \"...\\\\E\\QE...\".\n+                        buffR.append(\"\\\\E\\\\Q\");\n+                    }\n+                }\n+                buff.append(c);\n+            }\n+\n+            private void parse() throws ParserException {\n+                if (debug != null) {\n+                    debug.println(\"Parsing: \" + filterBuff);\n+                }\n+                assert filterBuff.hasRemaining() : \"Cannot parse an empty \" +\n+                        \"filter.\";\n+                while (filterBuff.hasRemaining()) {\n+                    char c = filterBuff.get();\n+                    if (c == '\\n' || c == '\\0') {\n+                        throw new ParserException(\"Invalid filter character: \" +\n+                                \"'\" + c + \"'\", this);\n+                    } else if (escape) {\n+                        appendChar(c);\n+                        escape = false;\n+                    } else if (c == '\\\\') {\n+                        nextState(Transition.REGULAR_CHAR);\n+                        escape = true;\n+                    } else if (c == '.') {\n+                        nextState(Transition.PATTERN_LEVEL_CHAR);\n+                    } else if (c == ';') {\n+                        nextState(Transition.PATTERN_END_CHAR);\n+                    } else if (Character.isWhitespace(c)) {\n+                        nextState(Transition.WHITESPACE_CHAR);\n+                    } else if (c == '!') {\n+                        nextState(Transition.DENY_CHAR);\n+                    } else if (c == ':' || c == ',') {\n+                        throw new ParserException(\"Reserved character '\" + c +\n+                                \"' must be escaped.\", this);\n+                    } else {\n+                        nextState(Transition.REGULAR_CHAR);\n+                        appendChar(c);\n+                    }\n+                }\n+                if (state != ParsingState.PRE_PATTERN || rules.size() == 0) {\n+                    nextState(Transition.PATTERN_END_CHAR);\n+                }\n+                assert state == ParsingState.PRE_PATTERN : \"Parser state \" +\n+                        \"must finish in PRE_PATTERN.\";\n+            }\n+        }\n+\n+        private final List<Rule> rules;\n+\n+        Filter(String filterStr) throws IllegalArgumentException {\n+            try {\n+                rules = Parser.parse(filterStr);\n+            } catch (ParserException e) {\n+                throw new IllegalArgumentException(\"Invalid Providers filter:\" +\n+                        \" \" + filterStr, e);\n+            }\n+            rules.add(new DefaultRule(rules.size()));\n+        }\n+\n+        FilterDecision apply(FilterQuery q) {\n+            for (Rule r : rules) {\n+                FilterDecision d = r.apply(q);\n+                if (d != FilterDecision.UNDECIDED) {\n+                    if (debug != null) {\n+                        debug.println(\"--------------------\");\n+                        debug.println(q.toString());\n+                        debug.println(\" * Decision: \" + d);\n+                        debug.println(\" * Made by: \" + r);\n+                    }\n+                    return d;\n+                }\n+            }\n+            \/\/ Should never reach this point: there is always a DefaultRule\n+            \/\/ capable of deciding.\n+            throw new RuntimeException(\"Unexpected Providers filter failure: \" +\n+                    \"decision not made.\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Filter: \");\n+            Iterator<Rule> ri = rules.iterator();\n+            while (ri.hasNext()) {\n+                sb.append(ri.next());\n+                if (ri.hasNext()) {\n+                    sb.append(\"; \");\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final Filter filter;\n+\n+    static {\n+        Filter tmpFilter = null;\n+        String fStr = SecurityProperties.privilegedGetOverridable(FILTER_PROP);\n+        if (fStr != null && !fStr.isEmpty()) {\n+            tmpFilter = new Filter(fStr);\n+        }\n+        filter = tmpFilter;\n+        if (debug != null) {\n+            debug.println(filter != null ? filter.toString() : \"No filter\");\n+        }\n+    }\n+\n+    \/*\n+     * This method has to be called every time that a Provider.Service instance\n+     * is obtained with Provider::getService or Provider::getServices.\n+     *\/\n+    public static boolean isAllowed(Provider.Service svc) {\n+        if (filter == null) {\n+            return true;\n+        }\n+        \/\/ For services added to the Provider's ServicesMap (most cases), this\n+        \/\/ call is expected to be fast: a Provider.Service field read only. It\n+        \/\/ might take longer on the first time for uncommon services (see\n+        \/\/ Provider.Service::getIsAllowed).\n+        return jspa.getIsAllowed(svc);\n+    }\n+\n+    \/*\n+     * This method is called from Provider.Service::computeIsAllowed only.\n+     *\/\n+    public static boolean computeIsAllowed(Provider.Service svc) {\n+        if (filter == null) {\n+            return true;\n+        }\n+        String providerName = svc.getProvider().getName();\n+        String svcType = svc.getType();\n+        String algo = svc.getAlgorithm();\n+        FilterDecision d = isAllowed(providerName, svcType, algo);\n+        List<String> aliases = jspa.getAliases(svc);\n+        if (debug != null && aliases.size() > 0) {\n+            debug.println(\"--------------------\");\n+            debug.println(\"The queried service has aliases. Checking them \" +\n+                    \"for a final decision...\");\n+        }\n+        for (String algAlias : aliases) {\n+            FilterDecision da = isAllowed(providerName, svcType, algAlias);\n+            if (da.priority < d.priority) {\n+                d = da;\n+                if (debug != null) {\n+                    algo = algAlias;\n+                }\n+            }\n+        }\n+        if (debug != null && aliases.size() > 0) {\n+            debug.println(\"--------------------\");\n+            debug.println(\"Final decision based on \" + algo + \" algorithm\" +\n+                    \": \" + d);\n+        }\n+        return d.result == FilterDecision.Result.ALLOW;\n+    }\n+\n+    private static FilterDecision isAllowed(String provider, String svcType,\n+            String svcAlgo) {\n+        return filter.apply(new FilterQuery(provider, svcType, svcAlgo));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProvidersFilter.java","additions":729,"deletions":0,"binary":false,"changes":729,"status":"added"},{"patch":"@@ -1518,0 +1518,84 @@\n+\n+#\n+# Security Providers Filter\n+#\n+# This filter can be used to select which security services (combination of a\n+# provider, service type and algorithm) are allowed in the Java security APIs.\n+# Services that belong either to statically enabled security providers\n+# (security.provider.<n> security property) or dynamically added ones\n+# (Security::addProvider API) are subject to the restrictions of this filter.\n+# A service is evaluated against this filter when a provider registers it\n+# (java.security.Provider::put or java.security.Provider::putService APIs) or returns\n+# an unregistered instance (after overriding java.security.Provider::getService\n+# or java.security.Provider::getServices APIs).\n+#\n+# Filtering out a cryptographic algorithm will block its use in TLS connections,\n+# JAR signing, certificates paths validation and in any other Java Cryptography\n+# Architecture API. The effect of blocking an algorithm applies on top of security\n+# properties that concern specific uses of it, such as jdk.tls.disabledAlgorithms,\n+# jdk.jar.disabledAlgorithms or jdk.certpath.disabledAlgorithms. However, an\n+# algorithm allowed by a filter is still subject to the aforementioned properties.\n+#\n+# If the system property jdk.security.providers.filter is specified, it supersedes\n+# the security property value defined here. If any of these properties is set at\n+# run time, the filter could be initialized already and the new value may not take\n+# effect until the JVM is relaunched. When a filter is not specified or is the empty\n+# string, filtering is disabled: all services are allowed.\n+#\n+# A filter value has the following structure:\n+#\n+# pattern-1; pattern-2; ...; pattern-n\n+#\n+# Each pattern in the sequence can be optionally prefixed by a '!' character (i.e.\n+# \" ! pattern-1 \"). Whitespaces between patterns, pattern prefixes ('!') and pattern\n+# separators (';') are not significant. A service is evaluated against the filter\n+# from left to right. If a service matches one of the patterns in the sequence, an\n+# authorization decision is made: if the pattern is prefixed by a '!', the decision\n+# is to deny it; otherwise, the decision is to allow it. If none of the patterns\n+# match, the default decision is to deny it. Once a decision is made, the remaining\n+# patterns are not evaluated.\n+#\n+# A pattern has one the following forms:\n+#\n+# 1) security-provider\n+# 2) security-provider.service-type\n+# 3) security-provider.service-type.algorithm\n+# 4) security-provider.service-type.algorithm-alias\n+#\n+# In form #1, a service provider name equal to \"security-provider\" is enough for a\n+# match to be successful. In form #2, the service type must also be equal to\n+# \"service-type\". In form #3, the service algorithm must also be equal to \"algorithm\".\n+# In form #4, it is enough that one of the service aliases matches \"algorithm-alias\",\n+# in addition to the requirements for form #2. In all cases, pattern and service\n+# names must have valid characters and cannot be empty.\n+#\n+# Characters '\\n' and '\\0' are not valid in a pattern. The following characters,\n+# when part of a pattern provider, service type, algorithm or alias, must be escaped\n+# by prepending a '\\' character: '!', '*', ' ' (whitespace), '.', ';', '\\', ':' and\n+# ','. Escaping any other character has no effect other than discarding the '\\'\n+# escape character. These escaping rules apply to the filter value as read in\n+# java.lang.System::getProperty or java.security.Security::getProperty: additional\n+# escaping might be needed depending on how the property is passed. For example,\n+# security properties require '\\' characters to be escaped. Thus, to match a service\n+# provider whose name is \"\\\", a pattern must be \"\\\\\\\\\" if passed as a security property.\n+#\n+# In addition to characters escaping, pattern names can contain '*' wildcards to\n+# imply zero or more repetitions of any character. Wildcards behave in a greedy mode,\n+# trying to consume as many characters as possible and backing off if necessary.\n+# Pattern matching is always case insensitive.\n+#\n+# When a service has aliases, the algorithm and each alias are independently evaluated\n+# against the filter. From the set of authorization decisions obtained, the one made\n+# by the left-most pattern has the highest priority and is finally effective.\n+#\n+# For troubleshooting, enable filter debugging output with the system property\n+# java.security.debug=jca and look for messages prefixed by \"ProvidersFilter\". To\n+# verify the list of services allowed for each installed security provider, run the\n+# JVM with the argument -XshowSettings:security:providers.\n+#\n+# Example\n+#\n+# Enable all services except those involving the algorithms MD2 or MD5:\n+# jdk.security.providers.filter=!*.*.*MD2*; !*.*.*MD5*; *\n+#\n+#jdk.security.providers.filter=\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -46,0 +46,5 @@\n+grant codeBase \"jrt:\/java.security.sasl\" {\n+    permission java.lang.RuntimePermission\n+                   \"accessClassInPackage.sun.security.jca\";\n+};\n+\n@@ -89,0 +94,2 @@\n+    permission java.lang.RuntimePermission\n+                   \"accessClassInPackage.sun.security.jca\";\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.HashMap;\n@@ -38,1 +37,0 @@\n-import sun.security.action.PutAllAction;\n@@ -72,1 +70,1 @@\n-    private static final HashMap<String, String> MECH_MAP =\n+    private static final Oid[] MECH_OIDS =\n@@ -75,1 +73,1 @@\n-                    public HashMap<String, String> run() {\n+                    public Oid[] run() {\n@@ -118,4 +116,3 @@\n-                                HashMap<String,String> map = new HashMap<>();\n-                                for (int i = 0; i < mechs.length; i++) {\n-                                    if (DEBUG) {\n-                                        debug(\"Native MF for \" + mechs[i]);\n+                                if (DEBUG) {\n+                                    for (Oid mech : mechs) {\n+                                        debug(\"Native MF for \" + mech);\n@@ -123,2 +120,0 @@\n-                                    map.put(\"GssApiMechanism.\" + mechs[i],\n-                                            MF_CLASS);\n@@ -126,1 +121,1 @@\n-                                return map;\n+                                return mechs;\n@@ -141,2 +136,9 @@\n-        if (MECH_MAP != null) {\n-            AccessController.doPrivileged(new PutAllAction(this, MECH_MAP));\n+        if (MECH_OIDS != null) {\n+            final Provider p = this;\n+            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+                for (Oid mech : MECH_OIDS) {\n+                    putService(new Service(p, \"GssApiMechanism\",\n+                            mech.toString(), MF_CLASS, null, null));\n+                }\n+                return null;\n+            });\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import sun.security.jca.ProvidersFilter;\n+\n@@ -427,1 +429,2 @@\n-                    if (service == null) {\n+                    if (service == null ||\n+                            !ProvidersFilter.isAllowed(service)) {\n@@ -575,1 +578,1 @@\n-                if (service == null) {\n+                if (service == null || !ProvidersFilter.isAllowed(service)) {\n@@ -650,1 +653,2 @@\n-                if (s.getType().equals(serviceName)) {\n+                if (ProvidersFilter.isAllowed(s) &&\n+                        s.getType().equals(serviceName)) {\n","filename":"src\/java.security.sasl\/share\/classes\/javax\/security\/sasl\/Sasl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -178,1 +179,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -239,1 +240,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -309,1 +310,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/TransformService.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -204,1 +205,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -254,1 +255,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -316,1 +317,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/XMLSignatureFactory.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -159,1 +160,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -209,1 +210,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -269,1 +270,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,1109 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8315487\n+ * @run main\/othervm\/timeout=60 -enablesystemassertions ServicesConsistency\n+ *\/\n+\n+public final class ServicesConsistency {\n+\n+    private static final String separatorThin = \"----------------------------\";\n+\n+    private static final String separatorThick = \"============================\";\n+\n+    private static final String aliasPrefix = \"Alg.Alias.\";\n+    private static final String sT = \"M\";\n+    private static final String algL = \"alg\";\n+    private static final String alg2L = algL + \"2\";\n+    private static final String alg2U = alg2L.toUpperCase();\n+    private static final String algPropKeyL = sT + \".\" + algL;\n+    private static final String alg2PropKeyL = sT + \".\" + alg2L;\n+    private static final String algU = algL.toUpperCase();\n+    private static final String algPropKeyU = sT + \".\" + algU;\n+    private static final String aliasL = \"alias\";\n+    private static final String aliasPropKeyL = aliasPrefix + sT + \".\" + aliasL;\n+    private static final String aliasU = aliasL.toUpperCase();\n+    private static final String aliasPropKeyU = aliasPrefix + sT + \".\" + aliasU;\n+    private static final String attrL = \"attr1\";\n+    private static final String attrU = attrL.toUpperCase();\n+    private static final String attrLAlgPropKeyL = algPropKeyL + \" \" + attrL;\n+    private static final String attrLAlgPropKeyU = algPropKeyU + \" \" + attrL;\n+    private static final String attrUAlgPropKeyL = algPropKeyL + \" \" + attrU;\n+    private static final String attrUAlgPropKeyU = algPropKeyU + \" \" + attrU;\n+    private static final String class1 = \"class1\";\n+    private static final String class2 = \"class2\";\n+    private static final String currentClass = \"currentClass\";\n+    private static final String currentClass2 = currentClass + \"2\";\n+    private static final String legacyClass = \"legacyClass\";\n+    private static final String attrValue = \"attrValue\";\n+    private static final String attrValue2 = attrValue + \"2\";\n+    private static Provider.Service s, s2;\n+\n+    private static int testsFailed = 0;\n+    private static int testsTotal = 0;\n+\n+    private static final TestProvider p;\n+\n+    static {\n+        TestProvider tmp = new TestProvider();\n+        for (Provider p : Security.getProviders()) {\n+            Security.removeProvider(p.getName());\n+        }\n+        Security.addProvider(tmp);\n+        p = tmp;\n+    }\n+\n+    private static final class TestProvider extends Provider {\n+        @Serial\n+        private static final long serialVersionUID = -6399263285569001970L;\n+\n+        static TestProvider serializationCopy() throws Throwable {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            oos.writeObject(p);\n+            ObjectInputStream ois = new ObjectInputStream(\n+                    new ByteArrayInputStream(baos.toByteArray()));\n+            return (TestProvider) ois.readObject();\n+        }\n+\n+        TestProvider() {\n+            super(\"TestProvider\", \"1.0\", \"TestProvider info\");\n+        }\n+\n+        void putService(String type, String algorithm, String className,\n+                List<String> aliases, Map<String, String> attributes) {\n+            System.out.println(\"Provider.putService(new Service(TestProvider,\" +\n+                    \" \" + type + \", \" + algorithm + \", \" + className + \", \" +\n+                    aliases + \", \" + attributes + \"))\");\n+            super.putService(new Service(this, type, algorithm, className,\n+                    aliases, attributes));\n+        }\n+\n+        @Override\n+        public void removeService(Provider.Service s) {\n+            System.out.println(\"Provider.removeService(\" + s + \")\");\n+            super.removeService(s);\n+        }\n+\n+        @Override\n+        public Object put(Object k, Object v) {\n+            return put(k, v, true);\n+        }\n+\n+        Object put(Object k, Object v, boolean print) {\n+            if (print) {\n+                System.out.println(\"Provider.put(\" + k + \", \" + v + \")\");\n+            }\n+            return super.put(k, v);\n+        }\n+\n+        void showProperties() {\n+            System.out.println();\n+            System.out.println(\"Properties map:\");\n+            System.out.println(separatorThin);\n+            for (Map.Entry<Object, Object> e : entrySet()) {\n+                Object k = e.getKey();\n+                Object v = e.getValue();\n+                if (k instanceof String ks) {\n+                    if (ks.startsWith(\"Provider.\")) {\n+                        continue;\n+                    }\n+                }\n+                System.out.println(k + \": \" + v);\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+    public static class TestSpi {\n+    }\n+\n+    public static class TestSpi2 {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        for (Method m : ServicesConsistency.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                try {\n+                    printTestHeader(m.getName());\n+                    testsTotal += 1;\n+                    m.invoke(null);\n+                } catch (Throwable t) {\n+                    testsFailed += 1;\n+                    t.printStackTrace();\n+                } finally {\n+                    p.clear();\n+                }\n+            }\n+        }\n+\n+        if (testsFailed > 0) {\n+            throw new Exception(\"TESTS FAILED: \" + testsFailed + \"\/\" +\n+                    testsTotal);\n+        } else {\n+            System.out.println(\"TESTS PASSED: \" + testsTotal + \"\/\" +\n+                    testsTotal);\n+        }\n+    }\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println(separatorThin);\n+        System.out.println(testName);\n+        System.out.println(separatorThin);\n+        System.out.println();\n+    }\n+\n+    private static void printThickHeader(String title) {\n+        System.out.println(title);\n+        System.out.println(separatorThick);\n+        System.out.println();\n+    }\n+\n+    private static void assertThat(boolean condition, String errorMsg)\n+            throws Exception {\n+        if (!condition) {\n+            throw new Exception(errorMsg);\n+        }\n+    }\n+\n+    private static void propValueAssertion(String propKey, String expectedValue,\n+            String valueDesc, TestProvider p) throws Exception {\n+        Object value = p.get(propKey);\n+        assertThat(expectedValue.equals(value), \"A wrong \" + valueDesc +\n+                \" is assigned to the '\" + propKey + \"' provider property: \" +\n+                \"expecting '\" + expectedValue + \"' but was '\" + value + \"'.\");\n+    }\n+\n+    private static void assertClassnamePropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        assertClassnamePropValue(propKey, expectedValue, p);\n+    }\n+\n+    private static void assertClassnamePropValue(String propKey,\n+            String expectedValue, TestProvider p) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"class name\", p);\n+    }\n+\n+    private static void assertAliasPropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"algorithm\", p);\n+    }\n+\n+    private static void assertAttributePropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"attribute value\", p);\n+    }\n+\n+    private static void assertPropRemoved(String propKey) throws Exception {\n+        assertThat(p.get(propKey) == null, \"Property '\" + propKey + \"' \" +\n+                \"expected to be removed but was not. Current value is '\" +\n+                p.get(propKey) + \"'.\");\n+    }\n+\n+    private static String getServiceDesc(Provider.Service svc) {\n+        return svc == null ? \"null service\" : \"service with type '\" +\n+                svc.getType() + \"' and algorithm '\" + svc.getAlgorithm() + \"'\";\n+    }\n+\n+    private static void serviceAssertionCommon(Provider.Service svc,\n+            boolean isEqual, Provider.Service svc2, String errorMsg)\n+            throws Exception {\n+        String svc2Desc = getServiceDesc(svc2);\n+        if (isEqual) {\n+            assertThat(svc == svc2, errorMsg + \" is not equal to a \" +\n+                    svc2Desc + \", and was expected to be equal.\");\n+        } else {\n+            assertThat(svc != svc2, errorMsg + \" is equal to a \" + svc2Desc +\n+                    \", and was not expected to be equal.\");\n+        }\n+    }\n+\n+    private static void lookupServiceAssertion(String type, String algorithm,\n+            boolean isEqual, Provider.Service svc2) throws Exception {\n+        serviceAssertionCommon(p.getService(type, algorithm), isEqual, svc2,\n+                \"A service looked up by type '\" + type + \"' and algorithm '\" +\n+                        algorithm + \"'\");\n+    }\n+\n+    private static void assertServiceEqual(String type, String algorithm,\n+            Provider.Service svc2) throws Exception {\n+        lookupServiceAssertion(type, algorithm, true, svc2);\n+    }\n+\n+    private static void assertServiceNotEqual(String type, String algorithm,\n+            Provider.Service svc2) throws Exception {\n+        lookupServiceAssertion(type, algorithm, false, svc2);\n+    }\n+\n+    private static void serviceAssertion(Provider.Service svc, boolean isEqual,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertionCommon(svc, isEqual, svc2, \"A \" + getServiceDesc(svc));\n+    }\n+\n+    private static void assertServiceEqual(Provider.Service svc,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertion(svc, true, svc2);\n+    }\n+\n+    private static void assertServiceNotEqual(Provider.Service svc,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertion(svc, false, svc2);\n+    }\n+\n+    private static void assertClassname(Provider.Service svc,\n+            String expectedClassName) throws Exception {\n+        assertServiceNotEqual(svc, null);\n+        String svcClassName = svc.getClassName();\n+        assertThat(expectedClassName.equals(svcClassName), \"A \" +\n+                getServiceDesc(svc) + \" was expected to have a class name \" +\n+                \"equal to '\" + expectedClassName + \"' but is equal to '\" +\n+                svcClassName + \"'.\");\n+    }\n+\n+    private static void assertAttribute(Provider.Service svc, String attrName,\n+            String expectedAttrValue) throws Exception {\n+        assertServiceNotEqual(svc, null);\n+        String attrValue = svc.getAttribute(attrName);\n+        assertThat(Objects.equals(expectedAttrValue, attrValue), \"A \" +\n+                getServiceDesc(svc) + \" was expected to have a '\" + attrName +\n+                        \"' attribute equal to '\" + expectedAttrValue + \"' but\" +\n+                        \" is equal to '\" + attrValue + \"'.\");\n+    }\n+\n+    private static void assertNotAttribute(Provider.Service svc,\n+            String attrName) throws Exception {\n+        assertAttribute(svc, attrName, null);\n+    }\n+\n+    private static void testBasicLegacyAPIOps() throws Throwable {\n+        String attrLAliasPropKeyL = sT + \".\" + aliasL + \" \" + attrU;\n+\n+        printThickHeader(\"Put an algorithm with two different cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(algPropKeyU, class2);\n+        p.showProperties();\n+        assertPropRemoved(algPropKeyL);\n+        assertClassnamePropValue(algPropKeyU, class2);\n+        assertClassname(p.getService(sT, algL), class2);\n+        assertClassname(p.getService(sT, algU), class2);\n+        p.clear();\n+\n+        printThickHeader(\"Assign an alias with two different cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(aliasPropKeyU, algL);\n+        s = p.getService(sT, algL);\n+        p.showProperties();\n+        assertPropRemoved(aliasPropKeyL);\n+        assertAliasPropValue(aliasPropKeyU, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertServiceEqual(sT, aliasU, s);\n+        assertClassname(s, class1);\n+        p.clear();\n+\n+        printThickHeader(\"Put an attribute with different algorithm cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrLAlgPropKeyU, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyU, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue2);\n+        assertAttribute(p.getService(sT, algU), attrU, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Put an attribute with different attr name case:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrUAlgPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAttributePropValue(attrUAlgPropKeyL, attrValue2);\n+        assertAttribute(p.getService(sT, algU), attrL, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrU, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Replace attribute by alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrLAliasPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAliasPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.showProperties();\n+        p.remove(algPropKeyU);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassname(p.getService(sT, algL), class1);\n+        assertClassname(p.getService(sT, aliasL), class1);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(algPropKeyL);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.remove(aliasPropKeyU);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertServiceNotEqual(sT, aliasL, null);\n+        p.remove(aliasPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertClassname(p.getService(sT, algL), class1);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service attribute:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.remove(attrUAlgPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(attrLAlgPropKeyU);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(attrLAlgPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertNotAttribute(p.getService(sT, algL), attrL);\n+    }\n+\n+    private static void testSerializationConsistencyBetweenAPIs()\n+            throws Throwable {\n+        printThickHeader(\"Before serialization:\");\n+        p.putService(sT, algL, currentClass, null, null);\n+        p.put(algPropKeyL, legacyClass);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertClassname(p.getService(sT, algL), currentClass);\n+\n+        TestProvider serialP = TestProvider.serializationCopy();\n+\n+        printThickHeader(\"After serialization:\");\n+        serialP.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass, serialP);\n+        assertClassname(serialP.getService(sT, algL), currentClass);\n+    }\n+\n+    private static void testComputeDoesNotThrowNPE() throws Throwable {\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.compute(aliasPropKeyL, (key, oldV) -> null);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testMergeDoesNotThrowNPE() throws Throwable {\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.merge(aliasPropKeyL, algL, (oldV, newV) -> null);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testLegacyAPIServicesOverride() throws Throwable {\n+        legacyAPIServicesOverride(false);\n+    }\n+\n+    private static void testLegacyAPIServicesOverrideDifferentCase()\n+            throws Throwable {\n+        legacyAPIServicesOverride(true);\n+    }\n+\n+    private static void legacyAPIServicesOverride(boolean differentCase)\n+            throws Throwable {\n+        String aliasAsAlgPropKey = sT + \".\" + (differentCase ? aliasU : aliasL);\n+        String algAsAliasPropKey = aliasPrefix + sT + \".\" +\n+                (differentCase ? algU : algL);\n+\n+        printThickHeader(\"A Legacy API service algorithm can override a \" +\n+                \"Legacy API service algorithm:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, class1);\n+        assertAttribute(s, attrL, attrValue);\n+        p.put(differentCase ? algPropKeyU : algPropKeyL, class2);\n+        p.showProperties();\n+        s2 = p.getService(sT, algL);\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                class2);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAliasPropValue(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algU, s2);\n+        assertClassname(s2, class2);\n+        assertClassname(p.getService(sT, aliasL), class2);\n+        assertAttribute(s2, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service algorithm is a Legacy API \" +\n+                \"service alias already. Modify the existing service through \" +\n+                \"its alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(aliasAsAlgPropKey, class2);\n+        p.showProperties();\n+        s = p.getService(sT, algL);\n+        assertClassnamePropValue(algPropKeyL, class2);\n+        assertPropRemoved(aliasAsAlgPropKey);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassname(p.getService(sT, aliasL), class2);\n+        assertClassname(p.getService(sT, aliasU), class2);\n+        assertClassname(s, class2);\n+        assertAttribute(s, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service alias can override a Legacy \" +\n+                \"API service alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(alg2PropKeyL, class2);\n+        p.put(differentCase ? aliasPropKeyU : aliasPropKeyL, alg2L);\n+        p.showProperties();\n+        s2 = p.getService(sT, alg2L);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+        assertClassname(p.getService(sT, algL), class1);\n+        assertClassname(s2, class2);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot be \" +\n+                \"overwritten by a Legacy API service alias:\");\n+        p.put(algPropKeyL, class1);\n+        s = p.getService(sT, algL);\n+        p.put(alg2PropKeyL, class2);\n+        p.put(algAsAliasPropKey, alg2L);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertPropRemoved(algAsAliasPropKey);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertClassnamePropValue(alg2PropKeyL, class2);\n+        assertServiceEqual(sT, algL, s);\n+        assertServiceEqual(sT, algU, s);\n+        assertClassname(s, class1);\n+        assertClassname(s2, class2);\n+        p.clear();\n+\n+        \/\/ Add a Current API service to test invalid overrides\n+        p.putService(sT, algL, currentClass, List.of(aliasL),\n+                Map.of(attrL, attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceNotEqual(s, null);\n+        assertServiceEqual(sT, aliasL, s);\n+        System.out.println();\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot overwrite a \" +\n+                \"Current API service algorithm:\");\n+        p.put(differentCase ? algPropKeyU : algPropKeyL, legacyClass);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyU);\n+        }\n+        assertClassname(p.getService(sT, algL), currentClass);\n+        assertClassname(p.getService(sT, algU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service alias cannot overwrite a \" +\n+                \"Current API service alias:\");\n+        p.put(differentCase ? aliasPropKeyU : aliasPropKeyL, alg2L);\n+        p.showProperties();\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyU);\n+        }\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(p.getService(sT, aliasL), currentClass);\n+        assertClassname(p.getService(sT, aliasU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service cannot overwrite a Current API\" +\n+                \" service attribute:\");\n+        p.put(differentCase ? attrUAlgPropKeyU : attrLAlgPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        if (differentCase) {\n+            assertPropRemoved(attrUAlgPropKeyU);\n+        }\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+\n+        printThickHeader(\"A Legacy API service alias cannot overwrite a \" +\n+                \"Current API service algorithm:\");\n+        p.put(algAsAliasPropKey, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertPropRemoved(algAsAliasPropKey);\n+        assertClassname(p.getService(sT, algL), currentClass);\n+        assertClassname(p.getService(sT, algU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot overwrite a \" +\n+                \"Current API service alias:\");\n+        p.put(aliasAsAlgPropKey, legacyClass);\n+        p.showProperties();\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertPropRemoved(aliasAsAlgPropKey);\n+        assertClassname(p.getService(sT, aliasL), currentClass);\n+        assertClassname(p.getService(sT, aliasU), currentClass);\n+\n+        assertServiceEqual(p.getService(sT, algL), s);\n+        assertServiceEqual(p.getService(sT, aliasL), s);\n+    }\n+\n+    private static void testLegacyAPIAliasCannotBeAlgorithm() throws Throwable {\n+        p.put(aliasPropKeyL, aliasL);\n+        p.showProperties();\n+        assertPropRemoved(aliasPropKeyL);\n+        p.clear();\n+\n+        p.put(sT + \".\" + aliasU, class1);\n+        p.put(aliasPropKeyL, aliasU);\n+        p.showProperties();\n+        assertClassnamePropValue(sT + \".\" + aliasU, class1);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testCurrentAPIServicesOverride() throws Throwable {\n+        currentAPIServicesOverride(false);\n+    }\n+\n+    private static void testCurrentAPIServicesOverrideDifferentCase()\n+            throws Throwable {\n+        currentAPIServicesOverride(true);\n+    }\n+\n+    private static void currentAPIServicesOverride(boolean differentCase)\n+            throws Throwable {\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service algorithm with its algorithm:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(aliasPropKeyL, algL);\n+        s = p.getService(sT, algL);\n+        p.putService(sT, differentCase ? algU : algL, currentClass, List.of(),\n+                null);\n+        s2 = p.getService(sT, differentCase ? algU : algL);\n+        p.showProperties();\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                currentClass);\n+        assertClassname(s, legacyClass);\n+        assertClassname(s2, currentClass);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertNotAttribute(s2, attrL);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service alias with its algorithm:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, differentCase ? aliasU : aliasL, currentClass,\n+                List.of(), null);\n+        s2 = p.getService(sT, differentCase ? aliasU : aliasL);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, legacyClass);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? aliasU : aliasL),\n+                currentClass);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassname(p.getService(sT, algL), legacyClass);\n+        assertClassname(s2, currentClass);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service algorithm with its alias:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, alg2L, currentClass,\n+                List.of(differentCase ? algU : algL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(alg2PropKeyL, currentClass);\n+        assertAliasPropValue(aliasPrefix + sT + \".\" + (differentCase ? algU :\n+                algL), alg2L);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertServiceNotEqual(s, s2);\n+        assertServiceEqual(sT, algL, s2);\n+        assertClassname(s2, currentClass);\n+        assertNotAttribute(s2, attrL);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API alias\" +\n+                \" with its alias:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, alg2L, currentClass, List.of(differentCase ?\n+                aliasU : aliasL), null);\n+        s2 = p.getService(sT, alg2L);\n+        s = p.getService(sT, algL);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, legacyClass);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(alg2PropKeyL, currentClass);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertClassname(s, legacyClass);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertClassname(s2, currentClass);\n+        assertNotAttribute(s2, attrL);\n+        assertAttribute(s, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service algorithm with its algorithm:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, currentClass);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, differentCase ? algU : algL, currentClass2, List.of(),\n+                null);\n+        s2 = p.getService(sT, differentCase ? algU : algL);\n+        p.showProperties();\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                currentClass2);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassname(s2, currentClass2);\n+        assertNotAttribute(s2, attrL);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service alias with its algorithm:\");\n+        p.putService(sT, algL, currentClass, List.of(alg2L), Map.of(attrL,\n+                attrValue));\n+        assertServiceEqual(sT, alg2L, p.getService(sT, algL));\n+        p.putService(sT, differentCase ? alg2U : alg2L, currentClass2,\n+                List.of(), null);\n+        s = p.getService(sT, algL);\n+        s2 = p.getService(sT, differentCase ? alg2U : alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? alg2U : alg2L),\n+                currentClass2);\n+        assertPropRemoved(aliasPrefix + alg2PropKeyL);\n+        assertClassname(s, currentClass);\n+        assertClassname(s2, currentClass2);\n+        assertAttribute(s, attrL, attrValue);\n+        assertNotAttribute(s2, attrL);\n+        p.removeService(s);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? alg2U : alg2L),\n+                currentClass2);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(s2, p.getService(sT, differentCase ? alg2U : alg2L));\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service algorithm with its alias:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, alg2L, currentClass2, List.of(differentCase ?\n+                algU : algL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(alg2PropKeyL, currentClass2);\n+        assertAliasPropValue(aliasPrefix + sT + \".\" + (differentCase ?\n+                algU : algL), alg2L);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, algL, s2);\n+        assertServiceEqual(sT, algU, s2);\n+        assertClassname(s2, currentClass2);\n+        assertNotAttribute(s2, attrL);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service alias with its alias:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, alg2L, currentClass2, List.of(differentCase ?\n+                aliasU : aliasL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertClassnamePropValue(alg2PropKeyL, currentClass2);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algL, s);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+        p.removeService(s);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+    }\n+\n+    private static void testInvalidServiceNotReturned() throws Throwable {\n+        p.put(aliasPropKeyL, algL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+    }\n+\n+    private static void testInvalidCachedHasKeyAttributes() throws Throwable {\n+        invalidCachedSupportedKeyFormats(true);\n+    }\n+\n+    private static void testInvalidCachedSupportedKeyFormats()\n+            throws Throwable {\n+        invalidCachedSupportedKeyFormats(false);\n+    }\n+\n+    private static void invalidCachedSupportedKeyFormats(\n+            boolean targetingHasAttributes) throws Throwable {\n+        String sT = \"Cipher\";\n+        String algPropKeyL = sT + \".\" + algL;\n+        String attrPropKey = algPropKeyL + \" SupportedKeyFormats\";\n+        String format1 = \"format1\";\n+        String format2 = \"format2\";\n+        boolean supportsKeyFormat, supportsKeyFormat2;\n+        Key key = new Key() {\n+            @Serial\n+            private static final long serialVersionUID = 5040566397999588441L;\n+            @Override\n+            public String getAlgorithm() {\n+                return null;\n+            }\n+            @Override\n+            public String getFormat() {\n+                return format2;\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                return new byte[0];\n+            }\n+        };\n+\n+        p.put(algPropKeyL, TestSpi.class.getName());\n+        if (!targetingHasAttributes) {\n+            p.put(attrPropKey, format2);\n+        }\n+        supportsKeyFormat = p.getService(sT, algL).supportsParameter(key);\n+        p.put(attrPropKey, format1);\n+        supportsKeyFormat2 = p.getService(sT, algL).supportsParameter(key);\n+        p.showProperties();\n+\n+        assertClassnamePropValue(algPropKeyL, TestSpi.class.getName());\n+        assertAttributePropValue(attrPropKey, format1);\n+        assertThat(supportsKeyFormat && !supportsKeyFormat2,\n+                \"supportsKeyFormat expected to be 'true' (was '\" +\n+                supportsKeyFormat + \"'), and supportsKeyFormat2 expected to \" +\n+                \"be 'false' (was '\" + supportsKeyFormat2 + \"').\");\n+    }\n+\n+    private static void testInvalidCachedClass() throws Throwable {\n+        Object testSpi, testSpi2;\n+        p.put(algPropKeyL, TestSpi.class.getName());\n+        s = p.getService(sT, algL);\n+        testSpi = s.newInstance(null);\n+        assertClassname(s, TestSpi.class.getName());\n+        p.put(algPropKeyL, TestSpi2.class.getName());\n+        s2 = p.getService(sT, algL);\n+        testSpi2 = s2.newInstance(null);\n+        assertClassname(s2, TestSpi2.class.getName());\n+        p.showProperties();\n+\n+        assertClassnamePropValue(algPropKeyL, TestSpi2.class.getName());\n+        assertThat(testSpi.getClass() == TestSpi.class && testSpi2.getClass()\n+                == TestSpi2.class, \"testSpi expected to be an instance of '\" +\n+                TestSpi.class.getSimpleName() + \"' (was an instance of '\" +\n+                testSpi.getClass().getSimpleName() + \"'), and testSpi2 \" +\n+                \"expected to be an instance of '\" +\n+                TestSpi2.class.getSimpleName() + \"' (was an instance of '\" +\n+                testSpi2.getClass().getSimpleName() + \"').\");\n+    }\n+\n+    private static void testLegacyAPIAddIsRemove() throws Throwable {\n+        Object obj = new Object();\n+        p.put(algPropKeyL, class1);\n+        p.put(algPropKeyU, obj);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertServiceNotEqual(sT, algL, null);\n+        p.showProperties();\n+        p.put(algPropKeyL, obj);\n+        p.showProperties();\n+        assertThat(p.get(algPropKeyL) == obj, \"Entry value \" +\n+                \"expected to be the Object instance added.\");\n+        assertThat(p.get(algPropKeyU) == obj, \"Entry value \" +\n+                \"expected to be the Object instance added.\");\n+        assertServiceEqual(sT, algL, null);\n+    }\n+\n+    private static void testReplaceAllIsAtomic() throws Throwable {\n+        concurrentReadWrite((Map<String, String> aliases) -> {\n+                    p.put(alg2PropKeyL, class2);\n+                    p.putAll(aliases);\n+                },\n+                (Map<String, String> aliases) ->\n+                    p.replaceAll((k, v) -> {\n+                        if (((String)k).startsWith(aliasPrefix) &&\n+                                algL.equals(v)) {\n+                            return alg2L;\n+                        }\n+                        return v;\n+                    }),\n+                (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            Provider.Service s2 = p.getService(sT, lastAlias);\n+            if (s1 != null && s1.getClassName().equals(class2)) {\n+                if (s2 == null) {\n+                    throw new Exception(\"First service found, \" +\n+                            \"last service not found.\");\n+                }\n+                return true;\n+            }\n+            return false;\n+        }, \"Provider::replaceAll is not atomic.\");\n+    }\n+\n+    private static void testPutAllIsAtomic() throws Throwable {\n+        concurrentReadWrite(null, p::putAll,\n+                (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            Provider.Service s2 = p.getService(sT, lastAlias);\n+            if (s1 != null) {\n+                if (s2 == null) {\n+                    throw new Exception(\"First service found, \" +\n+                            \"last service not found.\");\n+                }\n+                return true;\n+            }\n+            return false;\n+        }, \"Provider::putAll is not atomic.\");\n+    }\n+\n+    private static void testConcurrentServiceModification() throws Throwable {\n+        concurrentReadWrite(null, (Map<String, String> aliases) -> {\n+            for (Map.Entry<String, String> aliasEntry : aliases.entrySet()) {\n+                p.put(aliasEntry.getKey(), aliasEntry.getValue(), false);\n+            }\n+        }, (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            if (s1 != null) {\n+                s1.toString();\n+            }\n+            return p.getService(sT, lastAlias) != null;\n+        }, \"Concurrent modification of a service compromised integrity.\");\n+    }\n+\n+    @FunctionalInterface\n+    private interface ConcurrentWriteCallback {\n+        void apply(Map<String, String> aliases);\n+    }\n+\n+    @FunctionalInterface\n+    private interface ConcurrentReadCallback {\n+        boolean apply(String sT, String firstAlias, String lastAlias)\n+                throws Throwable;\n+    }\n+\n+    private static void concurrentReadWrite(ConcurrentWriteCallback preWriteCB,\n+            ConcurrentWriteCallback writerCB, ConcurrentReadCallback readerCB,\n+            String errorMsg) throws Throwable {\n+        int lastAlias = 500;\n+        int numberOfExperiments = 10;\n+        String firstAliasL = aliasL + 0;\n+        String lastAliasL = aliasL + lastAlias;\n+        Map<String, String> aliasesMap = new LinkedHashMap<>(lastAlias + 1);\n+        for (int i = 0; i <= lastAlias; i++) {\n+            aliasesMap.put(aliasPropKeyL + i, algL);\n+        }\n+        AtomicReference<Throwable> exceptionRef = new AtomicReference<>(null);\n+        Runnable writerR = () -> writerCB.apply(aliasesMap);\n+        Runnable readerR = () -> {\n+            try {\n+                while (!readerCB.apply(sT, firstAliasL, lastAliasL));\n+            } catch (Throwable t) {\n+                exceptionRef.set(t);\n+            }\n+        };\n+        for (int i = 0; i < numberOfExperiments; i++) {\n+            p.clear();\n+            p.put(algPropKeyL, class1);\n+            Thread writerT = new Thread(writerR);\n+            Thread readerT = new Thread(readerR);\n+            if (preWriteCB != null) {\n+                preWriteCB.apply(aliasesMap);\n+            }\n+            readerT.start();\n+            writerT.start();\n+            writerT.join();\n+            readerT.join();\n+            if (exceptionRef.get() != null) {\n+                throw new Exception(errorMsg, exceptionRef.get());\n+            }\n+        }\n+    }\n+\n+    private static void testInvalidGetServiceRemoval() throws Throwable {\n+        invalidServiceRemoval(true);\n+    }\n+\n+    private static void testInvalidGetServicesRemoval() throws Throwable {\n+        invalidServiceRemoval(false);\n+    }\n+\n+    private static void invalidServiceRemoval(boolean getService)\n+            throws Throwable {\n+        p.put(aliasPropKeyL, algL);\n+        if (getService) {\n+            p.getService(sT, aliasL);\n+        } else {\n+            p.getServices();\n+        }\n+        p.put(algPropKeyL, class1);\n+        p.showProperties();\n+\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        s = p.getService(sT, aliasL);\n+        assertClassname(s, class1);\n+        assertServiceEqual(sT, algL, s);\n+    }\n+\n+    private static void testSerializationClassnameConsistency()\n+            throws Throwable {\n+        printThickHeader(\"Before serialization:\");\n+        p.put(algPropKeyU, class1);\n+        p.put(algPropKeyL, class2);\n+        s = p.getService(sT, algL);\n+        s2 = p.getService(sT, algU);\n+        p.showProperties();\n+        assertClassname(s, class2);\n+        assertClassname(s2, class2);\n+\n+        TestProvider serialP = TestProvider.serializationCopy();\n+\n+        printThickHeader(\"After serialization:\");\n+        serialP.showProperties();\n+        s = serialP.getService(sT, algL);\n+        s2 = serialP.getService(sT, algU);\n+        p.showProperties();\n+        assertClassname(s, class2);\n+        assertClassname(s2, class2);\n+    }\n+\n+    private static void testCreateServiceByAlias() throws Throwable {\n+        printThickHeader(\"Create service by alias and set classname by alias:\");\n+        p.put(aliasPropKeyL, algL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.put(sT + \".\" + aliasL, class1);\n+        p.showProperties();\n+        assertPropRemoved(sT + \".\" + aliasL);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, class1);\n+    }\n+\n+    private static void testCreateServiceByAttr() throws Throwable {\n+        printThickHeader(\"Create a service by attribute:\");\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algL, null);\n+        p.put(algPropKeyL, class1);\n+        p.showProperties();\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Provider\/ServicesConsistency.java","additions":1109,"deletions":0,"binary":false,"changes":1109,"status":"added"},{"patch":"@@ -0,0 +1,827 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import java.util.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+\n+import sun.security.jca.GetInstance;\n+\n+import jdk.test.lib.process.Proc;\n+import jdk.test.lib.util.FileUtils;\n+\n+\/*\n+ * @test\n+ * @bug 8315487\n+ * @summary\n+ *   Tests the sun.security.jca.ProvidersFilter.\n+ * @modules java.base\/sun.security.jca\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=600 -enablesystemassertions ProvidersFilterTest\n+ *\/\n+\n+public final class ProvidersFilterTest {\n+    private static final boolean DEBUG = false;\n+\n+    private static final String SEC_FILTER_PROP =\n+            \"jdk.security.providers.filter\";\n+\n+    private static final String FILTER_EXCEPTION_HDR = \" * Filter string: \";\n+\n+    private static final String FILTER_EXCEPTION_MORE = \"(...)\";\n+\n+    private static final int FILTER_EXCEPTION_MAX_LINE = 80;\n+\n+    private static Path workspace;\n+\n+    private static final String TEST_SERVICE_TYPE = \"TestServiceType\";\n+\n+    \/*\n+     * Class used as a service SPI for services added by security providers\n+     * installed dynamically.\n+     *\/\n+    public static final class TestServiceSpi {\n+    }\n+\n+    @FunctionalInterface\n+    private interface CryptoChecker {\n+        boolean check(ServiceData svcData);\n+    }\n+\n+    @FunctionalInterface\n+    private interface CryptoOp {\n+        void doOp() throws Throwable;\n+    }\n+\n+    private static boolean cryptoCheck(CryptoOp cryptoOp) {\n+        try {\n+            cryptoOp.doOp();\n+            return true;\n+        } catch (Throwable t) {\n+            if (DEBUG) {\n+                t.printStackTrace();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static final Map<String, CryptoChecker> cryptoCheckers =\n+            new HashMap<>();\n+\n+    static {\n+        cryptoCheckers.put(\"Cipher\", (ServiceData d) -> cryptoCheck(\n+                () -> Cipher.getInstance(d.svcAlgo, d.provider)));\n+        cryptoCheckers.put(\"Signature\", (ServiceData d) -> cryptoCheck(\n+                () -> Signature.getInstance(d.svcAlgo, d.provider)));\n+        cryptoCheckers.put(\"KeyGenerator\", (ServiceData d) -> cryptoCheck(\n+                () -> KeyGenerator.getInstance(d.svcAlgo, d.provider)));\n+        cryptoCheckers.put(TEST_SERVICE_TYPE,\n+                (ServiceData d) -> cryptoCheck(() -> GetInstance.getInstance(\n+                        TEST_SERVICE_TYPE, TestServiceSpi.class, d.svcAlgo,\n+                        d.provider)));\n+    }\n+\n+    private static sealed class ServiceData implements Serializable\n+            permits DynamicServiceData {\n+        @Serial\n+        private static final long serialVersionUID = -351065619007499507L;\n+        protected final String provider;\n+        private final String svcType;\n+        protected final String svcAlgo;\n+\n+        private ServiceData(String provider, String svcType, String svcAlgo) {\n+            this.provider = provider;\n+            this.svcType = svcType;\n+            this.svcAlgo = svcAlgo;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return provider + \" \/ \" + svcType + \" \/ \" + svcAlgo;\n+        }\n+    }\n+\n+    private static final class DynamicServiceData extends ServiceData {\n+        @Serial\n+        private static final long serialVersionUID = 6156428473910912042L;\n+        final List<String> aliases;\n+        final Boolean legacy;\n+\n+        DynamicServiceData(String provider, String svcType,\n+                String svcAlgo, List<String> aliases, Boolean legacy) {\n+            super(provider, svcType, svcAlgo);\n+            if (aliases != null) {\n+                this.aliases = aliases;\n+            } else {\n+                this.aliases = List.of();\n+            }\n+            this.legacy = legacy;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return super.toString() + (aliases != null ?\n+                    \" \/ aliases: \" + aliases : \"\") + \" \/ legacy: \" + (legacy ==\n+                    null ? \"unregistered\" : legacy);\n+        }\n+    }\n+\n+    private record ExpectedExceptionData(String exceptionClass,\n+            String filterLine, String underliningLine) implements Serializable {\n+    }\n+\n+    private static final class TestExecutor {\n+        enum FilterPropertyType {\n+            SYSTEM, SECURITY\n+        }\n+\n+        @FunctionalInterface\n+        private interface AssertionDataLoader {\n+            void apply(TestExecutor testExecutor, String provider,\n+                    String svcType, String svcAlgo) throws Throwable;\n+        }\n+\n+        private final List<DynamicServiceData> dynamicServices =\n+                new ArrayList<>();\n+        private final List<ServiceData> expected = new ArrayList<>();\n+        private final List<ServiceData> notExpected = new ArrayList<>();\n+        private ExpectedExceptionData expectedException = null;\n+        private String filterStr;\n+        private FilterPropertyType propertyType;\n+\n+        void setFilter(String filterStr) {\n+            setFilter(filterStr, FilterPropertyType.SECURITY);\n+        }\n+\n+        void setFilter(String filterStr, FilterPropertyType propertyType) {\n+            if (propertyType == FilterPropertyType.SECURITY) {\n+                StringBuilder sb = new StringBuilder(filterStr.length());\n+                CharBuffer cb = CharBuffer.wrap(filterStr);\n+                while (cb.hasRemaining()) {\n+                    char c = cb.get();\n+                    if (c == '\\\\') {\n+                        sb.append('\\\\');\n+                    }\n+                    if (Character.UnicodeBlock.of(c) ==\n+                            Character.UnicodeBlock.BASIC_LATIN) {\n+                        sb.append(c);\n+                    } else {\n+                        sb.append(\"\\\\u%04x\".formatted((int) c));\n+                    }\n+                }\n+                this.filterStr = sb.toString();\n+            } else {\n+                this.filterStr = filterStr;\n+            }\n+            this.propertyType = propertyType;\n+            if (DEBUG) {\n+                System.out.println(\"Filter: \" + filterStr);\n+            }\n+        }\n+\n+        private void addDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy,\n+                AssertionDataLoader assertionDataLoader) throws Throwable {\n+            DynamicServiceData svcData = new DynamicServiceData(provider,\n+                    TEST_SERVICE_TYPE, svcAlgo, aliases, legacy);\n+            dynamicServices.add(svcData);\n+            \/\/ Sanity check: install the dynamic security provider without a\n+            \/\/ filter.\n+            DynamicProvider dynamicProvider = DynamicProvider.install(svcData);\n+            dynamicProvider.putAlgo(svcData);\n+            assertionDataLoader.apply(this, provider, TEST_SERVICE_TYPE,\n+                    svcAlgo);\n+        }\n+\n+        void addExpectedDynamicService(String provider, String svcAlgo)\n+                throws Throwable {\n+            addExpectedDynamicService(provider, svcAlgo, null, false);\n+        }\n+\n+        void addExpectedDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy) throws Throwable {\n+            addDynamicService(provider, svcAlgo, aliases, legacy,\n+                    TestExecutor::addExpectedService);\n+        }\n+\n+        void addExpectedService(String provider, String svcType,\n+                String svcAlgo) throws Throwable {\n+            expected.add(checkSvcAvailable(new ServiceData(provider,\n+                    svcType, svcAlgo)));\n+        }\n+\n+        void addNotExpectedDynamicService(String provider, String svcAlgo)\n+                throws Throwable {\n+            addNotExpectedDynamicService(provider, svcAlgo, null, false);\n+        }\n+\n+        void addNotExpectedDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy) throws Throwable {\n+            addDynamicService(provider, svcAlgo, aliases, legacy,\n+                    TestExecutor::addNotExpectedService);\n+        }\n+\n+        void addNotExpectedService(String provider, String svcType,\n+                String svcAlgo) throws Throwable {\n+            notExpected.add(checkSvcAvailable(new ServiceData(provider,\n+                    svcType, svcAlgo)));\n+        }\n+\n+        \/*\n+         * Sanity check: services must be available without a filter.\n+         *\/\n+        private ServiceData checkSvcAvailable(ServiceData svcData)\n+                throws Throwable {\n+            if (!cryptoCheckers.get(svcData.svcType).check(svcData)) {\n+                throw new Exception(\"The service \" + svcData + \" is not\" +\n+                        \" available without a filter.\");\n+            }\n+            return svcData;\n+        }\n+\n+        void addExpectedFilterException(String filterLine,\n+                int underliningSpaces) {\n+            String underliningLine = \" \".repeat(underliningSpaces) +\n+                    \"---^---\";\n+            underliningLine = underliningLine.substring(0, Math.min(\n+                    underliningLine.length(), FILTER_EXCEPTION_MAX_LINE));\n+            expectedException = new ExpectedExceptionData(\"sun.security.jca\" +\n+                    \".ProvidersFilter$Filter$ParserException\",\n+                    FILTER_EXCEPTION_HDR + filterLine, underliningLine);\n+        }\n+\n+        void execute() throws Throwable {\n+            String testClassName = getClass().getEnclosingClass().getName();\n+            Path dynamicServicesPath = getSvcDataFile(dynamicServices,\n+                    \"Dynamically installed services\");\n+            Path expectedPath = getSvcDataFile(expected, \"Expected\");\n+            Path notExpectedPath = getSvcDataFile(notExpected, \"Not expected\");\n+            Path expectedExceptionPath = serializeObject(expectedException);\n+            if (DEBUG) {\n+                System.out.println(\"=========================================\");\n+            }\n+            Proc p = Proc.create(testClassName).args(\n+                    dynamicServicesPath.toString(), expectedPath.toString(),\n+                    notExpectedPath.toString(), (expectedExceptionPath == null ?\n+                            \"\" : expectedExceptionPath.toString()));\n+            p.env(\"JDK_JAVA_OPTIONS\", \"-enablesystemassertions\");\n+            if (propertyType == FilterPropertyType.SECURITY) {\n+                p.secprop(SEC_FILTER_PROP, filterStr);\n+            } else {\n+                p.prop(SEC_FILTER_PROP, filterStr);\n+            }\n+            if (DEBUG) {\n+                p.inheritIO();\n+                p.prop(\"java.security.debug\", \"jca\");\n+                p.debug(testClassName);\n+\n+                \/\/ Need the launched process to connect to a debugger?\n+                \/\/System.setProperty(\"test.vm.opts\", \"-Xdebug -Xrunjdwp:\" +\n+                \/\/        \"transport=dt_socket,address=localhost:8000,\" +\n+                \/\/        \"suspend=y\");\n+            } else {\n+                p.nodump();\n+            }\n+            p.start().waitFor(0);\n+            for (ServiceData svcData : dynamicServices) {\n+                Security.removeProvider(svcData.provider);\n+            }\n+        }\n+    }\n+\n+    private static Path getSvcDataFile(Object svcData, String title)\n+            throws Throwable {\n+        assert svcData != null : \"Service data cannot be null.\";\n+        Path svcDataFilePath = serializeObject(svcData);\n+        showFileContent(svcDataFilePath, title);\n+        return svcDataFilePath;\n+    }\n+\n+    private static List<ServiceData> getSvcData(Path svcDataPath)\n+            throws Throwable {\n+        return (List<ServiceData>) deserializeObject(svcDataPath);\n+    }\n+\n+    private static Path serializeObject(Object obj) throws Throwable {\n+        if (obj == null) {\n+            return null;\n+        }\n+        Path objFilePath = Files.createTempFile(workspace, null, null);\n+        try (FileOutputStream fos =\n+                     new FileOutputStream(objFilePath.toFile())) {\n+            ObjectOutputStream oos = new ObjectOutputStream(fos);\n+            oos.writeObject(obj);\n+            oos.flush();\n+        }\n+        return objFilePath;\n+    }\n+\n+    private static Object deserializeObject(Path filePath)\n+            throws Throwable {\n+        try (FileInputStream fos = new FileInputStream(filePath.toFile())) {\n+            ObjectInputStream ois = new ObjectInputStream(fos);\n+            return ois.readObject();\n+        }\n+    }\n+\n+    private static void showFileContent(Path filePath, String title)\n+            throws Throwable {\n+        if (DEBUG) {\n+            System.out.println(\"-----------------------------------------\");\n+            System.out.println(title + \" assertion data (\" + filePath + \"):\");\n+            for (ServiceData svcData : getSvcData(filePath)) {\n+                System.out.println(svcData);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length == 4) {\n+            \/\/ Executed by a child process.\n+            mainChild(args[0], args[1], args[2], args[3]);\n+        } else if (args.length == 0) {\n+            \/\/ Executed by the parent process.\n+            try {\n+                workspace = Files.createTempDirectory(null);\n+                mainLauncher();\n+            } finally {\n+                FileUtils.deleteFileTreeWithRetry(workspace);\n+            }\n+            System.out.println(\"TEST PASS - OK\");\n+        } else {\n+            throw new Exception(\"Unexpected number of arguments.\");\n+        }\n+    }\n+\n+    private interface SvcDataConsumer {\n+        void consume(ServiceData data, boolean available) throws Throwable;\n+    }\n+\n+    private static void mainChild(String dynamicServicesPath,\n+            String expectedPropsPath, String notExpectedPropsPath,\n+            String expectedExceptionPath) throws Throwable {\n+        if (!expectedExceptionPath.isEmpty()) {\n+            ExpectedExceptionData expectedException = (ExpectedExceptionData)\n+                    deserializeObject(Paths.get(expectedExceptionPath));\n+            try {\n+                \/\/ Force the filter to be loaded.\n+                Security.getProviders();\n+            } catch (Throwable t) {\n+                if (DEBUG) {\n+                    System.out.println(\"Filter line expected: \" +\n+                            expectedException.filterLine);\n+                    System.out.println(\"Filter underlining line expected: \" +\n+                            expectedException.underliningLine);\n+                    t.printStackTrace();\n+                }\n+                Throwable ultimateCause = t.getCause();\n+                while (ultimateCause.getCause() != null) {\n+                    ultimateCause = ultimateCause.getCause();\n+                }\n+                if (ultimateCause.getClass().getName()\n+                        .equals(expectedException.exceptionClass)) {\n+                    String[] lines = ultimateCause.getMessage().split(\"\\\\R\");\n+                    for (int i = 0; i < lines.length; i++) {\n+                        if (lines[i].startsWith(FILTER_EXCEPTION_HDR)) {\n+                            if (lines[i].equals(expectedException.filterLine) &&\n+                                i < lines.length - 1 && lines[i + 1].equals(\n+                                        expectedException.underliningLine)) {\n+                                return;\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            throw new Exception(\"Expected filter exception could not be \" +\n+                    \"verified.\");\n+        }\n+        installDynamicServices(dynamicServicesPath);\n+        if (DEBUG) {\n+            System.out.println(\"Security Providers installed:\");\n+            for (Provider provider : Security.getProviders()) {\n+                System.out.println(\"Provider: \" + provider);\n+            }\n+        }\n+        perSvcDataDo(expectedPropsPath,\n+                (ServiceData data, boolean available) -> {\n+            if (!available) {\n+                throw new Exception(\"The service '\" + data + \"' is not \" +\n+                        \"available when it was expected.\");\n+            }\n+        });\n+        perSvcDataDo(notExpectedPropsPath,\n+                (ServiceData data, boolean available) -> {\n+            if (available) {\n+                throw new Exception(\"The service '\" + data + \"' is \" +\n+                        \"available when it was not expected.\");\n+            }\n+        });\n+    }\n+\n+    private static abstract sealed class DynamicProvider extends Provider\n+            permits DynamicProviderCurrent, DynamicProviderLegacy,\n+            DynamicProviderUnregistered {\n+        @Serial\n+        private static final long serialVersionUID = 6088341396620902983L;\n+\n+        static DynamicProvider install(DynamicServiceData svcData)\n+                throws Throwable {\n+            DynamicProvider dynamicProvider;\n+            if (Security.getProvider(svcData.provider)\n+                    instanceof DynamicProvider dP) {\n+                dynamicProvider = dP;\n+            } else {\n+                if (svcData.legacy == null) {\n+                    dynamicProvider = new DynamicProviderUnregistered(svcData);\n+                } else if (svcData.legacy) {\n+                    dynamicProvider = new DynamicProviderLegacy(svcData);\n+                } else {\n+                    dynamicProvider = new DynamicProviderCurrent(svcData);\n+                }\n+                if (Security.addProvider(dynamicProvider) == -1) {\n+                    throw new Exception(\"Could not install dynamic provider.\");\n+                }\n+            }\n+            return dynamicProvider;\n+        }\n+\n+        DynamicProvider(ServiceData svcData) {\n+            super(svcData.provider, \"\", svcData.toString());\n+        }\n+        abstract void putAlgo(DynamicServiceData svcData);\n+    }\n+\n+    private static final class DynamicProviderCurrent extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 7754296009615868997L;\n+\n+        DynamicProviderCurrent(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            putService(new Service(this, TEST_SERVICE_TYPE, svcData.svcAlgo,\n+                    TestServiceSpi.class.getName(), svcData.aliases, null));\n+        }\n+    }\n+\n+    private static final class DynamicProviderLegacy extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 1859892951118353404L;\n+\n+        DynamicProviderLegacy(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            put(TEST_SERVICE_TYPE + \".\" + svcData.svcAlgo,\n+                    TestServiceSpi.class.getName());\n+            for (String alias : svcData.aliases) {\n+                put(\"Alg.Alias.\" + TEST_SERVICE_TYPE + \".\" + alias,\n+                        svcData.svcAlgo);\n+            }\n+        }\n+    }\n+\n+    private static final class DynamicProviderUnregistered\n+            extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 4421847184357342760L;\n+        private final Map<String, Service> services = new HashMap<>();\n+\n+        DynamicProviderUnregistered(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            Provider.Service s = new Service(this, TEST_SERVICE_TYPE,\n+                    svcData.svcAlgo, TestServiceSpi.class.getName(),\n+                    svcData.aliases, null);\n+            services.put(s.getType() + \".\" + s.getAlgorithm(), s);\n+            for (String alias : svcData.aliases) {\n+                services.put(s.getType() + \".\" + alias, s);\n+            }\n+        }\n+\n+        @Override\n+        public Provider.Service getService(String type, String algorithm) {\n+            return services.get(type + \".\" + algorithm);\n+        }\n+\n+        @Override\n+        public Set<Provider.Service> getServices() {\n+            return new HashSet<>(services.values());\n+        }\n+    }\n+\n+    private static void installDynamicServices(String svcDataPath)\n+            throws Throwable {\n+        for (ServiceData svcDataObj : getSvcData(Paths.get(svcDataPath))) {\n+            DynamicServiceData svcData = (DynamicServiceData)svcDataObj;\n+            DynamicProvider dynamicProvider = DynamicProvider.install(svcData);\n+            dynamicProvider.putAlgo(svcData);\n+        }\n+    }\n+\n+    private static void perSvcDataDo(String svcDataPath,\n+            SvcDataConsumer svcDataDo) throws Throwable {\n+        for (ServiceData svcData : getSvcData(Paths.get(svcDataPath))) {\n+            CryptoChecker checker = cryptoCheckers.get(svcData.svcType);\n+            boolean availableInCryptoCheckers = checker.check(svcData);\n+            List<String> allAlgos = new ArrayList<>(List.of(svcData.svcAlgo));\n+            if (svcData instanceof DynamicServiceData dynamicSvcData) {\n+                allAlgos.addAll(dynamicSvcData.aliases);\n+            }\n+            for (String algo : allAlgos) {\n+                String filter = svcData.svcType + \".\" + algo;\n+                boolean availableInFiltered = findSvcInFilteredProviders(\n+                        svcData.provider, filter);\n+                if (availableInCryptoCheckers != availableInFiltered) {\n+                    throw new Exception(\"Inconsistent Security.getProviders(\" +\n+                            \"\\\"\" + filter + \"\\\") filtering result.\");\n+                }\n+            }\n+            svcDataDo.consume(svcData, availableInCryptoCheckers);\n+        }\n+    }\n+\n+    private static boolean findSvcInFilteredProviders(String provider,\n+            String filter) {\n+        Provider[] filteredProviders = Security.getProviders(filter);\n+        if (filteredProviders != null) {\n+            for (Provider p : filteredProviders) {\n+                if (p.getName().equals(provider)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void mainLauncher() throws Throwable {\n+        for (Method m : ProvidersFilterTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                printTestHeader(m.getName());\n+                TestExecutor t = new TestExecutor();\n+                m.invoke(null, t);\n+                t.execute();\n+            }\n+        }\n+    }\n+\n+    private static void printTestHeader(String testName) {\n+        if (DEBUG) {\n+            System.out.println(\"=========================================\");\n+            System.out.println(testName);\n+            System.out.println(\"-----------------------------------------\");\n+        }\n+    }\n+\n+    \/*\n+     * Valid filters\n+     *\/\n+\n+    private static void testBasicFiltering(TestExecutor t) throws Throwable {\n+        t.setFilter(\"  SunJCE.Cipher.AES  ;  !  *.*.*WeaK*;\" +\n+                \"MyProvider.*.myStrongAlgorithm*; !NonExistentProvider  \");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\");\n+        t.addExpectedDynamicService(\"MyProvider\", \"MyStrongAlgorithm\");\n+        t.addExpectedDynamicService(\"MyProvider\", \"MyStrongAlgorithm2\");\n+        t.addNotExpectedService(\"SunJCE\", \"KeyGenerator\", \"HmacSHA3-512\");\n+        t.addNotExpectedDynamicService(\"MyProvider\", \"MyWeakAlgorithm\");\n+    }\n+\n+    private static void testBasicFilteringUnregistered(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider.*.strong; !R1_MyProvider;\" +\n+                \"!R2_MyProvider.*.weak; R2_MyProvider\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"strong\", List.of(), null);\n+        t.addExpectedDynamicService(\"R2_MyProvider\", \"Algo\", List.of(), null);\n+        t.addNotExpectedDynamicService(\"R1_MyProvider\", \"Algo\", List.of(),\n+                null);\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"weak\", List.of(),\n+                null);\n+    }\n+\n+    private static void testCharsEscaping(TestExecutor t) throws Throwable {\n+        t.setFilter(\"R1_\\\\M\\\\!\\\\ \\\\.Pr\\\\*\\\\\\\\\/\\\\;der \\t; \" +\n+                \"R2_My\\\\\\\\E\\\\.\\\\\\\\QProvider;\" +\n+                \"\\\\!R3_M\\\\:Pr\\\\\\tvi\\\\,de\\u2014r.*;\");\n+        t.addExpectedDynamicService(\"R1_M! .Pr*\\\\\/;der\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_My\\\\E.\\\\QProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"!R3_M:Pr\\tvi,de\\u2014r\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_\\\\M! .Pr*\\\\\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pro\\\\\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\\\\\/\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\\\\\/\\\\\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R2_MyXProvider\", \"Algo\");\n+    }\n+\n+    private static void testWildcardGreediness(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider*; R2_MyProviderA**B**C; \" +\n+                \"R3_MyProvider*ABC\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"R1_MyProviderX\", \"Algo\");\n+        t.addExpectedDynamicService(\"R1_MyProviderXX\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABCDC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABCCCC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R3_MyProviderABC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R3_MyProviderABCABC\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R2_MyProviderA\", \"Algo\");\n+    }\n+\n+    private static void testLeftPrecedence(TestExecutor t) throws Throwable {\n+        t.setFilter(\"R1_MyProvider; !R1_MyProvider; !R2_MyProvider; \" +\n+                \"R2_MyProvider; !R3_*; R3_MyProvider; !R4_*.*.AES; \" +\n+                \"R4_*.*.RSA\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"R4_MyProvider\", \"RSA\");\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R3_MyProvider\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"AES\");\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"*\");\n+    }\n+\n+    private static void aliasesCommon(TestExecutor t, Boolean legacy)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider.*.Alias; !R1_MyProvider.*.Algo; \" +\n+                \"!R2_MyProvider.*.Alias; R2_MyProvider.*.Algo;\" +\n+                \"R3_MyProvider.*.Algo; !R3_MyProvider.*.Alias;\" +\n+                \"!R4_MyProvider.*.Algo; R4_MyProvider.*.Alias;\" +\n+                \"R5_MyProvider.*.ALIAS1; !R5_MyProvider.*.ALIAS2\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\", List.of(\"Alias\"),\n+                legacy);\n+        t.addExpectedDynamicService(\"R3_MyProvider\", \"Algo\", List.of(\"Alias\"),\n+                legacy);\n+        t.addExpectedDynamicService(\"R5_MyProvider\", \"Algo\", List.of(\"Alias1\",\n+                \"Alias2\"), legacy);\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"Algo\",\n+                List.of(\"Alias\"), legacy);\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"Algo\",\n+                List.of(\"Alias\"), legacy);\n+    }\n+\n+    private static void testAliases(TestExecutor t) throws Throwable {\n+        aliasesCommon(t, false);\n+    }\n+\n+    private static void testAliasesLegacy(TestExecutor t) throws Throwable {\n+        aliasesCommon(t, true);\n+    }\n+\n+    private static void testAliasesUnregistered(TestExecutor t)\n+            throws Throwable {\n+        aliasesCommon(t, null);\n+    }\n+\n+    \/*\n+     * Invalid filters (must throw an exception)\n+     *\/\n+\n+    private static void testWhitespacesOnlyInFilter(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"\\t\\t\\t\", TestExecutor.FilterPropertyType.SYSTEM);\n+        t.addExpectedFilterException(\"\\t\\t\\t\", 17);\n+    }\n+\n+    private static void testWhitespacesOnlyInRule(TestExecutor t) {\n+        t.setFilter(\"*;    ;\");\n+        t.addExpectedFilterException(\"*;    ;\", 21);\n+    }\n+\n+    private static void testDenyOnly(TestExecutor t) {\n+        t.setFilter(\"!\");\n+        t.addExpectedFilterException(\"!\", 15);\n+    }\n+\n+    private static void testTooManyLevels(TestExecutor t) {\n+        t.setFilter(\"*.*.*.*\");\n+        t.addExpectedFilterException(\"*.*.*.*\", 20);\n+    }\n+\n+    private static void testMissingSecurityProvider(TestExecutor t) {\n+        t.setFilter(\".*.*\");\n+        t.addExpectedFilterException(\".*.*\", 15);\n+    }\n+\n+    private static void testDenyMissingSecurityProvider(TestExecutor t) {\n+        t.setFilter(\"!.*\");\n+        t.addExpectedFilterException(\"!.*\", 16);\n+    }\n+\n+    private static void testMissingServiceType(TestExecutor t) {\n+        t.setFilter(\"*.\");\n+        t.addExpectedFilterException(\"*.\", 16);\n+    }\n+\n+    private static void testMissingServiceType2(TestExecutor t) {\n+        t.setFilter(\"*..*\");\n+        t.addExpectedFilterException(\"*..*\", 17);\n+    }\n+\n+    private static void testMissingAlgorithm(TestExecutor t) {\n+        t.setFilter(\"*.*.\");\n+        t.addExpectedFilterException(\"*.*.\", 18);\n+    }\n+\n+    private static void testUnescapedSpaceInProvider(TestExecutor t) {\n+        t.setFilter(\"My Provider\");\n+        t.addExpectedFilterException(\"My Provider\", 18);\n+    }\n+\n+    private static void testUnescapedSpaceInServiceType(TestExecutor t) {\n+        t.setFilter(\"MyProvider. MyService\");\n+        t.addExpectedFilterException(\"MyProvider. MyService\", 26);\n+    }\n+\n+    private static void testUnescapedExclamationMark(TestExecutor t) {\n+        t.setFilter(\"My!Provider\");\n+        t.addExpectedFilterException(\"My!Provider\", 17);\n+    }\n+\n+    private static void testUnescapedColonInProvider(TestExecutor t) {\n+        t.setFilter(\"My:Provider\");\n+        t.addExpectedFilterException(\"My:Provider\", 17);\n+    }\n+\n+    private static void testUnescapedCommaInProvider(TestExecutor t) {\n+        t.setFilter(\"My,Provider\");\n+        t.addExpectedFilterException(\"My,Provider\", 17);\n+    }\n+\n+    private static void testFilterEndsInEscape(TestExecutor t) {\n+        t.setFilter(\"\\\\\");\n+        t.addExpectedFilterException(\"\\\\\", 15);\n+    }\n+\n+    private static void testProviderEndsInEscape(TestExecutor t) {\n+        t.setFilter(\"MyProvider\\\\\");\n+        t.addExpectedFilterException(\"MyProvider\\\\\", 25);\n+    }\n+\n+    private static void testParserExceptionLineMoreRight(TestExecutor t) {\n+        t.setFilter(\".\" + \";\".repeat(FILTER_EXCEPTION_MAX_LINE + 10));\n+        t.addExpectedFilterException(\".\" + \";\".repeat(\n+                FILTER_EXCEPTION_MAX_LINE - FILTER_EXCEPTION_HDR.length() - 1\n+                        - FILTER_EXCEPTION_MORE.length() - 1) + \" \" +\n+                FILTER_EXCEPTION_MORE, 15);\n+    }\n+\n+    private static void testParserExceptionLineMoreLeft(TestExecutor t) {\n+        t.setFilter(\"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10) + \"!\");\n+        t.addExpectedFilterException(FILTER_EXCEPTION_MORE + \" \" + \"*\".repeat(\n+                FILTER_EXCEPTION_MAX_LINE - FILTER_EXCEPTION_HDR.length() - 1\n+                        - FILTER_EXCEPTION_MORE.length() - 1) + \"!\", 76);\n+    }\n+\n+    private static void testParserExceptionLineMoreBoth(TestExecutor t) {\n+        t.setFilter(\"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10) + \"!\" +\n+                \"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10));\n+        float halfWildcards = (FILTER_EXCEPTION_MAX_LINE -\n+                FILTER_EXCEPTION_HDR.length() - (FILTER_EXCEPTION_MORE.length()\n+                + 1) * 2 - 1) \/ 2.0f;\n+        int preWildcards = (int) halfWildcards;\n+        int postWildcards = (int) (halfWildcards + 0.5f);\n+        t.addExpectedFilterException(FILTER_EXCEPTION_MORE + \" \" + \"*\".repeat(\n+                preWildcards) + \"!\" + \"*\".repeat(postWildcards) + \" \" +\n+                FILTER_EXCEPTION_MORE, 45);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/ProvidersFilterTest.java","additions":827,"deletions":0,"binary":false,"changes":827,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.Iterator;\n@@ -28,1 +29,1 @@\n- * @bug 6994753 7123582 8305950 8281658 8310201 8311653\n+ * @bug 6994753 7123582 8305950 8281658 8310201 8311653 8315487\n@@ -67,0 +68,22 @@\n+    static void checkServicesAllowed(TestResult tr, boolean servicesAllowed) {\n+        String noneSvcHdr = \"Provider services \" + (servicesAllowed ?\n+                \"NOT \" : \"\") + \"allowed: (type : algorithm)\";\n+        String errorMsg = \"Expected header '\" + noneSvcHdr + \"' not found\";\n+        Iterator<String> oi = tr.testOutput.iterator();\n+        while (oi.hasNext()) {\n+            if (oi.next().contains(noneSvcHdr)) {\n+                if (oi.next().contains(\"<none>\")) {\n+                    errorMsg = null;\n+                } else {\n+                    errorMsg = \"Unexpected services listed under '\" +\n+                            noneSvcHdr + \"'\";\n+                    break;\n+                }\n+            }\n+        }\n+        if (errorMsg != null) {\n+            System.out.println(tr);\n+            throw new RuntimeException(errorMsg);\n+        }\n+    }\n+\n@@ -214,2 +237,5 @@\n-    static void runTestOptionSecurityProv() throws IOException {\n-        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:providers\");\n+    static void runTestOptionSecurityProv(boolean servicesAllowed)\n+            throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:providers\",\n+                \"-Djdk.security.providers.filter=\" + (servicesAllowed ? \"\" :\n+                        \"!*\"));\n@@ -224,0 +250,7 @@\n+        \/\/ test services filter information\n+        checkServicesAllowed(tr, servicesAllowed);\n+    }\n+\n+    static void runTestOptionSecurityProv() throws IOException {\n+        runTestOptionSecurityProv(true);\n+        runTestOptionSecurityProv(false);\n","filename":"test\/jdk\/tools\/launcher\/Settings.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"}]}