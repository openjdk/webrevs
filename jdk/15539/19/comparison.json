{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -1793,1 +1794,2 @@\n-                    if (s.getType().equals(\"KeyStore\")) {\n+                    if (ProvidersFilter.isAllowed(s) &&\n+                            s.getType().equals(\"KeyStore\")) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.event.SecurityProviderServiceEvent;\n-\n@@ -44,0 +42,6 @@\n+import jdk.internal.access.JavaSecurityProviderAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.event.SecurityProviderServiceEvent;\n+import sun.security.jca.ProvidersFilter;\n+import sun.security.util.AlgorithmDecomposer;\n+\n@@ -123,0 +127,20 @@\n+    static {\n+        SharedSecrets.setJavaSecurityProviderAccess(\n+                new JavaSecurityProviderAccess() {\n+                    @Override\n+                    public Set<Service> getServicesNotAllowed(Provider p) {\n+                        return p.getServicesNotAllowed();\n+                    }\n+\n+                    @Override\n+                    public List<String> getAliases(Service svc) {\n+                        return svc.getAliases();\n+                    }\n+\n+                    @Override\n+                    public boolean isAllowed(Service svc) {\n+                        return svc.isAllowed();\n+                    }\n+                });\n+    }\n+\n@@ -704,1 +728,2 @@\n-     * lock-free.\n+     * lock-free. When a service is added to this structure, it goes through\n+     * the Providers filter and, if allowed, is available for use.\n@@ -715,3 +740,3 @@\n-        \/\/ Placeholder for a thread to mark that serviceSet values are being\n-        \/\/ computed after a services update. Only one thread at a time can\n-        \/\/ effectively assign this value.\n+        \/\/ Placeholder for a thread to mark that allowedSet or notAllowedSet\n+        \/\/ values are being computed after a services update. Only one thread\n+        \/\/ at a time can effectively assign this value.\n@@ -720,1 +745,2 @@\n-        \/\/ Unmodifiable set of all services. Possible values for this field\n+        \/\/ Unmodifiable set of all services allowed by the Providers filter (see\n+        \/\/ sun.security.jca.ProvidersFilter). Possible values for this field\n@@ -724,1 +750,7 @@\n-        private final AtomicReference<Set<Service>> serviceSet;\n+        private final AtomicReference<Set<Service>> allowedSet;\n+\n+        \/\/ Unmodifiable set of all services not allowed by the Providers filter\n+        \/\/ (see sun.security.jca.ProvidersFilter). For informational purposes\n+        \/\/ only (see the -XshowSettings:security:providers JVM argument): do not\n+        \/\/ use services in this set. See allowedSet for possible values.\n+        private final AtomicReference<Set<Service>> notAllowedSet;\n@@ -751,1 +783,2 @@\n-            serviceSet = new AtomicReference<>();\n+            allowedSet = new AtomicReference<>();\n+            notAllowedSet = new AtomicReference<>();\n@@ -764,1 +797,2 @@\n-            serviceSet = new AtomicReference<>(original.serviceSet.get());\n+            allowedSet = new AtomicReference<>(original.allowedSet.get());\n+            notAllowedSet = new AtomicReference<>(original.notAllowedSet.get());\n@@ -772,5 +806,5 @@\n-         * Returns an unmodifiable set of available services. Recomputes\n-         * serviceSet if needed, after a service update. Both services added\n-         * with the Current and Legacy APIs are included. If no services are\n-         * found, the returned set is empty. This method is thread-safe and\n-         * lock-free.\n+         * Returns an unmodifiable set containing allowed or not allowed\n+         * services. Recomputes allowedSet and notAllowedSet if needed, after a\n+         * service update. Both services added with the Current and Legacy APIs\n+         * are included. If no services are found, the returned set is empty.\n+         * This method is thread-safe and lock-free.\n@@ -778,2 +812,4 @@\n-        Set<Service> getServices() {\n-            Set<Service> serviceSetLocal = serviceSet.compareAndExchange(\n+        Set<Service> getServicesSet(boolean allowedServices) {\n+            AtomicReference<Set<Service>> svcSet = allowedServices ?\n+                    allowedSet : notAllowedSet;\n+            Set<Service> serviceSetLocal = svcSet.compareAndExchange(\n@@ -786,1 +822,1 @@\n-                Set<Service> newSet = computeServicesSet();\n+                Set<Service> newSet = computeServicesSet(allowedServices);\n@@ -793,2 +829,1 @@\n-                    serviceSet.compareAndExchange(\n-                            SERVICE_SET_IN_PROGRESS, newSet);\n+                    svcSet.compareAndExchange(SERVICE_SET_IN_PROGRESS, newSet);\n@@ -801,1 +836,1 @@\n-        private Set<Service> computeServicesSet() {\n+        private Set<Service> computeServicesSet(boolean allowed) {\n@@ -815,1 +850,2 @@\n-                if (e.getKey().equals(svc.algKey) && isValid(svc)) {\n+                if (e.getKey().equals(svc.algKey) &&\n+                        svc.isAllowed() == allowed && isValid(svc)) {\n@@ -823,3 +859,3 @@\n-         * Returns an available service. Both services added with the Current\n-         * and Legacy APIs are considered in the search. Thread-safe and\n-         * lock-free.\n+         * Returns an available and allowed service. Both services added with\n+         * the Current and Legacy APIs are considered in the search. Thread-safe\n+         * and lock-free.\n@@ -827,1 +863,1 @@\n-        Service getService(ServiceKey key) {\n+        Service getAllowed(ServiceKey key) {\n@@ -829,1 +865,1 @@\n-            return svc != null && isValid(svc) ? svc : null;\n+            return svc != null && isValid(svc) && svc.isAllowed() ? svc : null;\n@@ -837,1 +873,2 @@\n-            serviceSet.set(null);\n+            allowedSet.set(null);\n+            notAllowedSet.set(null);\n@@ -861,2 +898,3 @@\n-         * Signals that there were changes on the services map and the cached\n-         * set of services need to be recomputed before use.\n+         * Signals that there were changes on the services map and either the\n+         * cached set of allowed or not allowed services need to be recomputed\n+         * before use.\n@@ -864,2 +902,6 @@\n-        private void notifyChanges() {\n-            serviceSet.set(null);\n+        private void notifyChanges(boolean allowedChange) {\n+            if (allowedChange) {\n+                allowedSet.set(null);\n+            } else {\n+                notAllowedSet.set(null);\n+            }\n@@ -888,1 +930,3 @@\n-         * attributes and aliases as they were at time of registration.\n+         * attributes and aliases as they were at time of registration. Also, a\n+         * Providers filter decision is made for services added to this map and\n+         * will not change.\n@@ -906,0 +950,12 @@\n+            \/\/ Services added to the services map must go through the Providers\n+            \/\/ filter first so readers do not have any performance penalty.\n+            \/\/\n+            \/\/ Note: if isAllowed is set to a non-null value, aliases have not\n+            \/\/ changed since the last computation, so the computed value remains\n+            \/\/ valid. This is because services added with the Current API are\n+            \/\/ immutable, and services added with the Legacy API are copied\n+            \/\/ before modified.\n+            if (svc.isAllowed == null) {\n+                svc.computeSvcAllowed();\n+            }\n+\n@@ -1094,1 +1150,1 @@\n-            notifyChanges();\n+            notifyChanges(mi.svc.isAllowed());\n@@ -1113,2 +1169,3 @@\n-         * ServicesMap::putAttributeLegacy calls. For atomic changes with the\n-         * Legacy API see Provider::putAll.\n+         * ServicesMap::putAttributeLegacy calls. Conversely, the Providers\n+         * filter decision for a service may vary as aliases are added or\n+         * removed. For atomic changes with the Legacy API see Provider::putAll.\n@@ -1143,0 +1200,8 @@\n+                } else {\n+                    \/\/ The service is new. Services added to the services map\n+                    \/\/ must go through the Providers filter first so readers\n+                    \/\/ don't have any performance penalties. Note: if the\n+                    \/\/ service exists already, this is not necessary because a\n+                    \/\/ change in the class name does not affect the previous\n+                    \/\/ filter decision.\n+                    newSvc.computeSvcAllowed();\n@@ -1208,0 +1273,6 @@\n+                \/\/ The new alias can modify the Providers filter decision.\n+                newSvc.computeSvcAllowed();\n+                if (newSvc.cipherTransformsAllowed != null) {\n+                    newSvc.cipherTransformsAllowed.clear();\n+                }\n+\n@@ -1303,0 +1374,7 @@\n+                    \/\/ The removed alias can modify the Providers filter\n+                    \/\/ decision.\n+                    newSvc.computeSvcAllowed();\n+                    if (newSvc.cipherTransformsAllowed != null) {\n+                        newSvc.cipherTransformsAllowed.clear();\n+                    }\n+\n@@ -1411,2 +1489,9 @@\n-            \/\/ Notify a change.\n-            notifyChanges();\n+            if (oldMi.svc != null &&\n+                    oldMi.svc.isAllowed() != newSvc.isAllowed()) {\n+                \/\/ The updated service transitioned between allowed and not\n+                \/\/ allowed Providers filter states. Notify according to the\n+                \/\/ previous state.\n+                notifyChanges(oldMi.svc.isAllowed());\n+            }\n+            \/\/ Notify a change according to the current Providers filter state.\n+            notifyChanges(newSvc.isAllowed());\n@@ -1802,1 +1887,1 @@\n-        Service s = servicesMap.getService(key);\n+        Service s = servicesMap.getAllowed(key);\n@@ -1835,1 +1920,14 @@\n-        return servicesMap.getServices();\n+        return servicesMap.getServicesSet(true);\n+    }\n+\n+    \/*\n+     * This method returns an unmodifiable set of services that are supported\n+     * by this provider but not allowed by the Providers filter (see\n+     * sun.security.jca.ProvidersFilter). These services must not be used for\n+     * anything other than informational purposes (see\n+     * sun.launcher.SecuritySettings and the -XshowSettings:security:providers\n+     * JVM argument).\n+     *\/\n+    private Set<Service> getServicesNotAllowed() {\n+        checkInitialized();\n+        return servicesMap.getServicesSet(false);\n@@ -1884,3 +1982,1 @@\n-\n-        if (!prngAlgos.isEmpty()) {\n-            String algo = prngAlgos.iterator().next().originalAlgorithm;\n+        for (ServiceKey algKey : prngAlgos) {\n@@ -1890,1 +1986,4 @@\n-            return getService(\"SecureRandom\", algo);\n+            Service svc = getService(\"SecureRandom\", algKey.originalAlgorithm);\n+            if (svc != null && svc.isAllowed()) {\n+                return svc;\n+            }\n@@ -1892,1 +1991,0 @@\n-\n@@ -2081,0 +2179,10 @@\n+        \/\/ Cache with the Providers filter decision for this service. Value is\n+        \/\/ null when not decided.\n+        private Boolean isAllowed;\n+\n+        \/\/ Cache with transformation - filter decision entries. Transformations\n+        \/\/ in this cache are based on this service algorithm or aliases, but are\n+        \/\/ not necessarily supported (further evaluation is needed). For Cipher\n+        \/\/ service types only (lazily initialized), null otherwise.\n+        private Map<String, Boolean> cipherTransformsAllowed;\n+\n@@ -2149,0 +2257,1 @@\n+            isAllowed = svc.isAllowed;\n@@ -2150,0 +2259,4 @@\n+            if (svc.cipherTransformsAllowed != null) {\n+                cipherTransformsAllowed = new ConcurrentHashMap<>(\n+                        svc.cipherTransformsAllowed);\n+            }\n@@ -2272,0 +2385,122 @@\n+        \/*\n+         * Returns whether the service is allowed or not according to the\n+         * Providers filter. This decision is usually made when a service\n+         * instance is added to a ServicesMap, and then cached. However, some\n+         * Providers may override Provider::getService or Provider::getServices\n+         * and return Service instances that did not go through the filter\n+         * before. In any case, if the service did not go through the filter,\n+         * evaluate it now and save the result.\n+         *\/\n+        private boolean isAllowed() {\n+            ProvidersFilter.CipherContext cipherContext =\n+                    ProvidersFilter.CipherTransformation.getContext();\n+            if (cipherContext != null) {\n+                \/\/ The Cipher class is trying to create a CipherSpi instance\n+                \/\/ from a service. E.g. Cipher.getInstance(\"transformation\").\n+                \/\/ The service algorithm and aliases do not match the\n+                \/\/ transformation exactly. However, there could still be support\n+                \/\/ for it. Evaluate the transformation according to the filter\n+                \/\/ and see if the service remains on track for further\n+                \/\/ assessment (e.g. Cipher.Transform::supports).\n+                if ((cipherTransformsAllowed != null ||\n+                        type.equals(\"Cipher\")) &&\n+                        isTransformationForSvc(cipherContext.svcSearchKey())) {\n+                    return isTransformationAllowed(\n+                            cipherContext.transformation());\n+                } else {\n+                    \/\/ Unlikely. May happen if a provider overrides\n+                    \/\/ Provider::getService or Provider.Service::newInstance\n+                    \/\/ and, during a Cipher service lookup, triggers a\n+                    \/\/ Provider.Service::isAllowed call for a service not\n+                    \/\/ related to the Cipher transformation.\n+                    if (debug != null) {\n+                        debug.println(\"Filter evaluation of a service not \" +\n+                                \"related to a Cipher transformation (\" +\n+                                cipherContext.transformation() + \"). Service \" +\n+                                \"search key: \" + cipherContext.svcSearchKey() +\n+                                \". Service: \" + this);\n+                    }\n+                }\n+            }\n+            if (isAllowed == null) {\n+                computeSvcAllowed();\n+            }\n+            return isAllowed;\n+        }\n+\n+        \/*\n+         * Returns whether a key matches any of the algorithm or aliases\n+         * (case insensitive).\n+         *\/\n+        private boolean isTransformationForSvc(String svcSearchKey) {\n+            if (svcSearchKey.equalsIgnoreCase(algorithm)) {\n+                return true;\n+            }\n+            for (String alias : getAliases()) {\n+                if (svcSearchKey.equalsIgnoreCase(alias)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/*\n+         * Returns whether a transformation potentially supported by this\n+         * service is allowed by the Providers filter. Service algorithm and\n+         * aliases are used to build transformation aliases.\n+         *\/\n+        private boolean isTransformationAllowed(String transformation) {\n+            Boolean isTransformAllowed;\n+            if (cipherTransformsAllowed == null) {\n+                cipherTransformsAllowed = new ConcurrentHashMap<>();\n+                isTransformAllowed = null;\n+            } else {\n+                isTransformAllowed =\n+                        cipherTransformsAllowed.get(transformation);\n+            }\n+            if (isTransformAllowed == null) {\n+                String[] transformParts = AlgorithmDecomposer\n+                        .getTransformationTokens(transformation);\n+                \/\/ transformParts has three non-empty components because\n+                \/\/ transformation 1) was analyzed by\n+                \/\/ Cipher::tokenizeTransformation before and 2) if it\n+                \/\/ had have a single component, it would have been\n+                \/\/ equal to the service algorithm or alias and not set by\n+                \/\/ ProvidersFilter.CipherTransformation to reach this point.\n+                assert transformParts.length == 3 :\n+                        \"Unexpected transformation.\";\n+                List<String> allAlgos =\n+                        new ArrayList<>(getAliases().size() + 1);\n+                allAlgos.add(algorithm);\n+                allAlgos.addAll(getAliases());\n+                List<String> tAliases = new ArrayList<>(allAlgos.size() - 1);\n+                for (String algo : allAlgos) {\n+                    \/\/ If a service algorithm or alias has multiple components,\n+                    \/\/ use the first one for the transformation alias. The\n+                    \/\/ second and third one (if any) are assumed to be the mode\n+                    \/\/ and padding respectively, and taken from the\n+                    \/\/ transformation.\n+                    algo = AlgorithmDecomposer.getTransformationTokens(algo)[0];\n+                    String transformAlgo = algo + \"\/\" + transformParts[1] +\n+                            \"\/\" + transformParts[2];\n+                    if (!transformAlgo.equalsIgnoreCase(transformation)) {\n+                        tAliases.add(transformAlgo);\n+                    }\n+                }\n+                isTransformAllowed = ProvidersFilter.computeSvcAllowed(\n+                        provider.getName(), type, transformation, tAliases);\n+                cipherTransformsAllowed.put(transformation, isTransformAllowed);\n+            }\n+            return isTransformAllowed;\n+        }\n+\n+        \/*\n+         * Pass the service through the Providers filter and save the result.\n+         * Called from ServicesMap before adding a Service to the map, and\n+         * from Service::isAllowed to handle uncommon cases.\n+         *\/\n+        private void computeSvcAllowed() {\n+            isAllowed = ProvidersFilter.computeSvcAllowed(\n+                    provider.getName(), type, algorithm, getAliases());\n+        }\n+\n@@ -2309,0 +2544,8 @@\n+        \/*\n+         * Method accessed from sun.security.jca.ProvidersFilter and\n+         * sun.launcher.SecuritySettings.\n+         *\/\n+        private List<String> getAliases() {\n+            return Collections.unmodifiableList(aliases);\n+        }\n+\n@@ -2356,4 +2599,6 @@\n-                if (provider.getService(type, algorithm) != this) {\n-                    throw new NoSuchAlgorithmException\n-                        (\"Service not registered with Provider \"\n-                        + provider.getName() + \": \" + this);\n+                \/\/ Services never added to a ServicesMap need to be checked.\n+                if (provider.getService(type, algorithm) != this ||\n+                        !isAllowed()) {\n+                    throw new NoSuchAlgorithmException(\"Service not \" +\n+                            (!isAllowed() ? \"allowed\" : \"registered with \" +\n+                            \"Provider \" + provider.getName()) + \": \" + this);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":294,"deletions":49,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -282,1 +283,7 @@\n-                break;\n+                if (prngService != null) {\n+                    if (ProvidersFilter.isAllowed(prngService)) {\n+                        break;\n+                    } else {\n+                        prngService = null;\n+                    }\n+                }\n@@ -295,1 +302,0 @@\n-            this.secureRandomSpi = new sun.security.provider.SecureRandom();\n@@ -297,0 +303,6 @@\n+            try {\n+                this.secureRandomSpi = SecureRandom.getInstance(prngAlgorithm,\n+                        this.provider).secureRandomSpi;\n+            } catch (NoSuchAlgorithmException nsae) {\n+                throw new RuntimeException(\"Default PRNG not found\", nsae);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -383,1 +384,2 @@\n-     * Returns the property (if any) mapping the key for the given provider.\n+     * Returns a service allowed by the Providers filter given a service type,\n+     * algorithm and provider. Search is case-insensitive.\n@@ -385,10 +387,9 @@\n-    private static String getProviderProperty(String key, Provider provider) {\n-        String prop = provider.getProperty(key);\n-        if (prop == null) {\n-            \/\/ Is there a match if we do a case-insensitive property name\n-            \/\/ comparison? Let's try ...\n-            for (Enumeration<Object> e = provider.keys();\n-                                e.hasMoreElements(); ) {\n-                String matchKey = (String)e.nextElement();\n-                if (key.equalsIgnoreCase(matchKey)) {\n-                    prop = provider.getProperty(matchKey);\n+    private static Provider.Service findService(String type, String algo,\n+            Provider provider) {\n+        \/\/ Try the fast path (when \"type\" has the exact case).\n+        Provider.Service foundSvc = provider.getService(type, algo);\n+        if (foundSvc == null) {\n+            \/\/ Try the slow path (when \"type\" does not have the exact case).\n+            for (Provider.Service svc : provider.getServices()) {\n+                if (svc.getType().equalsIgnoreCase(type)) {\n+                    foundSvc = provider.getService(svc.getType(), algo);\n@@ -399,1 +400,4 @@\n-        return prop;\n+        if (foundSvc != null && ProvidersFilter.isAllowed(foundSvc)) {\n+            return foundSvc;\n+        }\n+        return null;\n@@ -915,24 +919,3 @@\n-            \/\/ Constructed key have ONLY 1 space between algName and attrName\n-            String key = serviceName + '.' + algName +\n-                    (attrName != null ? (' ' + attrName) : \"\");\n-\n-            \/\/ Check whether the provider has a property\n-            \/\/ whose key is the same as the given key.\n-            String propValue = getProviderProperty(key, prov);\n-\n-            if (propValue == null) {\n-                \/\/ Check whether we have an alias instead\n-                \/\/ of a standard name in the key.\n-                String standardName = getProviderProperty(\"Alg.Alias.\" +\n-                        serviceName + \".\" + algName, prov);\n-                if (standardName != null) {\n-                    key = serviceName + \".\" + standardName +\n-                            (attrName != null ? ' ' + attrName : \"\");\n-                    propValue = getProviderProperty(key, prov);\n-                }\n-\n-                if (propValue == null) {\n-                    \/\/ The provider doesn't have the given\n-                    \/\/ key in its property list.\n-                    return false;\n-                }\n+            Provider.Service svc = findService(serviceName, algName, prov);\n+            if (svc == null) {\n+                return false;\n@@ -948,0 +931,5 @@\n+            String foundAttrValue = svc.getAttribute(attrName);\n+            if (foundAttrValue == null) {\n+                return false;\n+            }\n+\n@@ -958,1 +946,1 @@\n-                int maxSize = Integer.parseInt(propValue);\n+                int maxSize = Integer.parseInt(foundAttrValue);\n@@ -965,1 +953,1 @@\n-                propValue = propValue.toUpperCase(Locale.ENGLISH);\n+                foundAttrValue = foundAttrValue.toUpperCase(Locale.ENGLISH);\n@@ -968,1 +956,1 @@\n-                String[] propComponents = propValue.split(\"\\\\|\");\n+                String[] propComponents = foundAttrValue.split(\"\\\\|\");\n@@ -975,1 +963,1 @@\n-                return attrValue.equalsIgnoreCase(propValue);\n+                return attrValue.equalsIgnoreCase(foundAttrValue);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":29,"deletions":41,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import sun.security.util.AlgorithmDecomposer;\n@@ -317,2 +318,6 @@\n-    private static final String SHA512TRUNCATED = \"SHA512\/2\";\n-\n+    \/**\n+     * Split a Cipher transformation of the form algorithm\/mode\/padding or\n+     * algorithm into its components. Checks that only one or three components\n+     * are returned and that the first component is non-empty, or throws\n+     * NoSuchAlgorithmException otherwise.\n+     *\/\n@@ -321,33 +326,6 @@\n-        if (transformation == null) {\n-            throw new NoSuchAlgorithmException(\"No transformation given\");\n-        }\n-        \/*\n-         * array containing the components of a cipher transformation:\n-         *\n-         * index 0: algorithm component (e.g., AES)\n-         * index 1: feedback component (e.g., CFB)\n-         * index 2: padding component (e.g., PKCS5Padding)\n-         *\/\n-        String[] parts = { \"\", \"\", \"\" };\n-\n-        \/\/ check if the transformation contains algorithms with \"\/\" in their\n-        \/\/ name which can cause the parsing logic to go wrong\n-        int sha512Idx = transformation.toUpperCase(Locale.ENGLISH)\n-                .indexOf(SHA512TRUNCATED);\n-        int startIdx = (sha512Idx == -1 ? 0 :\n-                sha512Idx + SHA512TRUNCATED.length());\n-        int endIdx = transformation.indexOf('\/', startIdx);\n-        if (endIdx == -1) {\n-            \/\/ algorithm\n-            parts[0] = transformation.trim();\n-        } else {\n-            \/\/ algorithm\/mode\/padding\n-            parts[0] = transformation.substring(0, endIdx).trim();\n-            startIdx = endIdx+1;\n-            endIdx = transformation.indexOf('\/', startIdx);\n-            if (endIdx == -1) {\n-                throw new NoSuchAlgorithmException(\"Invalid transformation\"\n-                            + \" format:\" + transformation);\n-            }\n-            parts[1] = transformation.substring(startIdx, endIdx).trim();\n-            parts[2] = transformation.substring(endIdx+1).trim();\n+        String[] transformationTokens =\n+                AlgorithmDecomposer.getTransformationTokens(transformation);\n+        if (transformationTokens.length != 1 &&\n+                transformationTokens.length != 3) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation \" +\n+                    \"format: \" + transformation);\n@@ -355,4 +333,3 @@\n-        if (parts[0].isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n-                                   + transformation);\n+        if (transformationTokens[0].isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation (\" +\n+                    \"algorithm not specified): \" + transformation);\n@@ -360,1 +337,1 @@\n-        return parts;\n+        return transformationTokens;\n@@ -455,1 +432,0 @@\n-\n@@ -457,2 +433,2 @@\n-        String mode = parts[1];\n-        String pad = parts[2];\n+        String mode = parts.length == 3 ? parts[1] : \"\";\n+        String pad = parts.length == 3 ? parts[2] : \"\";\n@@ -460,1 +436,1 @@\n-        if ((mode.length() == 0) && (pad.length() == 0)) {\n+        if (mode.isEmpty() && pad.isEmpty()) {\n@@ -487,0 +463,24 @@\n+    private static Service tryGetService(Provider p, String canonicalTransform,\n+            String svcSearchKey) {\n+        ProvidersFilter.CipherTransformation ct =\n+                new ProvidersFilter.CipherTransformation(\n+                        canonicalTransform, svcSearchKey);\n+        try (ct) {\n+            Service s = p.getService(\"Cipher\", svcSearchKey);\n+            if (s == null || !ProvidersFilter.isAllowed(s)) {\n+                return null;\n+            }\n+            return s;\n+        }\n+    }\n+\n+    private static Object newInstance(Service s, String canonicalTransform,\n+            String svcSearchKey) throws NoSuchAlgorithmException {\n+        ProvidersFilter.CipherTransformation ct =\n+                new ProvidersFilter.CipherTransformation(\n+                        canonicalTransform, svcSearchKey);\n+        try (ct) {\n+            return s.newInstance(null);\n+        }\n+    }\n+\n@@ -545,0 +545,1 @@\n+        String canonicalTransform = transforms.getFirst().transform;\n@@ -551,1 +552,1 @@\n-        Iterator<Service> t = GetInstance.getServices(cipherServices);\n+        Iterator<Service> t = GetInstance.getCipherServices(cipherServices);\n@@ -555,1 +556,1 @@\n-            if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -572,1 +573,2 @@\n-                CipherSpi spi = (CipherSpi)s.newInstance(null);\n+                CipherSpi spi = (CipherSpi)newInstance(s, canonicalTransform,\n+                        tr.transform);\n@@ -719,0 +721,1 @@\n+        String canonicalTransform = transforms.getFirst().transform;\n@@ -722,1 +725,2 @@\n-            Service s = provider.getService(\"Cipher\", tr.transform);\n+            Service s = tryGetService(provider, canonicalTransform,\n+                    tr.transform);\n@@ -726,1 +730,1 @@\n-            if (providerChecked == false) {\n+            if (!providerChecked) {\n@@ -729,2 +733,2 @@\n-                \/\/ and a SecurityException if the\n-                \/\/ provider does not support the algorithm.\n+                \/\/ and a SecurityException if the provider does not support\n+                \/\/ the algorithm.\n@@ -734,1 +738,1 @@\n-                        + provider.getName();\n+                            + provider.getName();\n@@ -747,1 +751,2 @@\n-                CipherSpi spi = (CipherSpi)s.newInstance(null);\n+                CipherSpi spi = (CipherSpi)newInstance(s, canonicalTransform,\n+                        tr.transform);\n@@ -757,1 +762,0 @@\n-\n@@ -814,0 +818,1 @@\n+            String canonicalTransform = transforms.getFirst().transform;\n@@ -827,1 +832,1 @@\n-                if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -840,1 +845,2 @@\n-                        Object obj = s.newInstance(null);\n+                        Object obj = newInstance(s, canonicalTransform,\n+                                tr.transform);\n@@ -908,0 +914,1 @@\n+            String canonicalTransform = transforms.getFirst().transform;\n@@ -922,1 +929,1 @@\n-                if (s.supportsParameter(key) == false) {\n+                if (!s.supportsParameter(key)) {\n@@ -925,1 +932,1 @@\n-                if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n@@ -938,1 +945,2 @@\n-                        thisSpi = (CipherSpi)s.newInstance(null);\n+                        thisSpi = (CipherSpi)newInstance(s, canonicalTransform,\n+                                tr.transform);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":67,"deletions":59,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.security.Provider;\n+import java.util.List;\n+import java.util.Set;\n+\n+public interface JavaSecurityProviderAccess {\n+    Set<Provider.Service> getServicesNotAllowed(Provider p);\n+    List<String> getAliases(Provider.Service svc);\n+    boolean isAllowed(Provider.Service svc);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecurityProviderAccess.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.security.Provider;\n@@ -90,0 +91,1 @@\n+    private static JavaSecurityProviderAccess javaSecurityProviderAccess;\n@@ -325,0 +327,14 @@\n+    public static void setJavaSecurityProviderAccess(\n+            JavaSecurityProviderAccess jspa) {\n+        javaSecurityProviderAccess = jspa;\n+    }\n+\n+    public static JavaSecurityProviderAccess getJavaSecurityProviderAccess() {\n+        var access = javaSecurityProviderAccess;\n+        if (access == null) {\n+            ensureClassInitialized(Provider.class);\n+            access = javaSecurityProviderAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+        java.security.sasl,\n@@ -317,0 +318,1 @@\n+        java.xml.crypto,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.Collections;\n@@ -143,0 +142,24 @@\n+    private static void printSecurityProviderServices(\n+            Set<Provider.Service> services) {\n+        if (!services.isEmpty()) {\n+            services.stream().sorted(\n+                    Comparator.comparing(Provider.Service::getType)\n+                            .thenComparing(Provider.Service::getAlgorithm))\n+                    .forEach(ps -> {\n+                        ostream.println(THREEINDENT +\n+                                ps.getType() + \".\" + ps.getAlgorithm());\n+                        List<String> aliases = SharedSecrets\n+                                .getJavaSecurityProviderAccess().getAliases(ps);\n+\n+                        if (!aliases.isEmpty()) {\n+                            ostream.println(wrappedString(\n+                                    aliases.stream().sorted()\n+                                            .collect(Collectors.joining(\", \", INDENT + \" aliases: [\", \"]\")),\n+                                    80, \" \" + TWOINDENT, INDENT + THREEINDENT));\n+                        }\n+                    });\n+        } else {\n+            ostream.println(THREEINDENT + \"<none>\");\n+        }\n+    }\n+\n@@ -152,33 +175,8 @@\n-                ostream.println(wrappedString(PROV_INFO_STRING + p.getInfo(), 80,\n-                        TWOINDENT, THREEINDENT));\n-                ostream.println(TWOINDENT + \"Provider services: (type : algorithm)\");\n-                Set<Provider.Service> services = p.getServices();\n-                Set<String> keys = Collections.list(p.keys())\n-                        .stream()\n-                        .map(String.class::cast)\n-                        .filter(s -> s.startsWith(\"Alg.Alias.\"))\n-                        .collect(Collectors.toSet());\n-                if (!services.isEmpty()) {\n-                    services.stream()\n-                            .sorted(Comparator.comparing(Provider.Service::getType)\n-                                    .thenComparing(Provider.Service::getAlgorithm))\n-                            .forEach(ps -> {\n-                                ostream.println(THREEINDENT +\n-                                        ps.getType() + \".\" + ps.getAlgorithm());\n-                                List<String> aliases = keys\n-                                        .stream()\n-                                        .filter(s -> s.startsWith(\"Alg.Alias.\" + ps.getType()))\n-                                        .filter(s -> p.getProperty(s).equals(ps.getAlgorithm()))\n-                                        .map(s -> s.substring((\"Alg.Alias.\" + ps.getType() + \".\").length()))\n-                                        .toList();\n-\n-                                if (!aliases.isEmpty()) {\n-                                    ostream.println(wrappedString(\n-                                            aliases.stream()\n-                                                    .collect(Collectors.joining(\", \", INDENT + \" aliases: [\", \"]\")),\n-                                            80, \" \" + TWOINDENT, INDENT + THREEINDENT));\n-                                }\n-                            });\n-                } else {\n-                    ostream.println(THREEINDENT + \"<none>\");\n-                }\n+                ostream.println(wrappedString(PROV_INFO_STRING + p.getInfo(),\n+                        80, TWOINDENT, THREEINDENT));\n+                ostream.println(TWOINDENT + \"Provider services allowed: (type : algorithm)\");\n+                printSecurityProviderServices(p.getServices());\n+                ostream.println(TWOINDENT + \"Provider services NOT allowed: (type : algorithm)\");\n+                printSecurityProviderServices(\n+                        SharedSecrets.getJavaSecurityProviderAccess()\n+                                .getServicesNotAllowed(p));\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/SecuritySettings.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        if (s == null) {\n+        if (s == null || !ProvidersFilter.isAllowed(s)) {\n@@ -99,1 +99,1 @@\n-        if (s == null) {\n+        if (s == null || !ProvidersFilter.isAllowed(s)) {\n@@ -126,0 +126,5 @@\n+    public static Iterator<Service> getCipherServices(List<ServiceId> ids) {\n+        ProviderList list = Providers.getProviderList();\n+        return list.getCipherServices(ids);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/GetInstance.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,1 +371,1 @@\n-                if (s != null) {\n+                if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -379,1 +379,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -403,0 +403,4 @@\n+    public Iterator<Service> getCipherServices(List<ServiceId> ids) {\n+        return new CipherServiceIterator(ids);\n+    }\n+\n@@ -408,1 +412,2 @@\n-    private final class ServiceIterator implements Iterator<Service> {\n+    private sealed class ServiceIterator implements Iterator<Service>\n+            permits CipherServiceIterator {\n@@ -500,1 +505,1 @@\n-                    Service s = p.getService(type, algorithm);\n+                    Service s = tryGetService(p, type, algorithm);\n@@ -507,1 +512,1 @@\n-                        Service s = p.getService(id.type, id.algorithm);\n+                        Service s = tryGetService(p, id.type, id.algorithm);\n@@ -516,0 +521,8 @@\n+        Service tryGetService(Provider p, String type, String algorithm) {\n+            Service s = p.getService(type, algorithm);\n+            if (s == null || !ProvidersFilter.isAllowed(s)) {\n+                return null;\n+            }\n+            return s;\n+        }\n+\n@@ -539,0 +552,19 @@\n+    private final class CipherServiceIterator extends ServiceIterator {\n+        private final String canonicalTransform;\n+\n+        CipherServiceIterator(List<ServiceId> ids) {\n+            super(ids);\n+            canonicalTransform = ids.getFirst().algorithm;\n+        }\n+\n+        @Override\n+        Service tryGetService(Provider p, String type, String algorithm) {\n+            ProvidersFilter.CipherTransformation ct =\n+                    new ProvidersFilter.CipherTransformation(\n+                            canonicalTransform, algorithm);\n+            try (ct) {\n+                return super.tryGetService(p, type, algorithm);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,807 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.jca;\n+\n+import java.io.Closeable;\n+import java.nio.CharBuffer;\n+import java.security.Provider;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.access.JavaSecurityProviderAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.Debug;\n+import sun.security.util.SecurityProperties;\n+\n+public final class ProvidersFilter {\n+\n+    private static final String FILTER_PROP = \"jdk.security.providers.filter\";\n+\n+    private static final Debug debug = Debug.getInstance(\"jca\",\n+            \"ProvidersFilter\");\n+\n+    private static final JavaSecurityProviderAccess jspa = SharedSecrets\n+            .getJavaSecurityProviderAccess();\n+\n+    private static final class FilterDecision {\n+        private enum Result {\n+            DENY,\n+            ALLOW,\n+            UNDECIDED\n+        }\n+        private static final int UNDEFINED_PRIORITY = -1;\n+        private static final FilterDecision UNDECIDED = new FilterDecision();\n+        private final Result result;\n+        private final int priority;\n+\n+        private FilterDecision() {\n+            this.result = Result.UNDECIDED;\n+            this.priority = UNDEFINED_PRIORITY;\n+        }\n+\n+        FilterDecision(Result result, int priority) {\n+            assert result != Result.UNDECIDED : \"Invalid result.\";\n+            assert priority >= 0 : \"Invalid priority\";\n+            this.result = result;\n+            this.priority = priority;\n+        }\n+\n+        boolean isAllow() {\n+            return result == ProvidersFilter.FilterDecision.Result.ALLOW;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return result + (priority != UNDEFINED_PRIORITY ? \" - priority: \" +\n+                    priority : \"\");\n+        }\n+\n+        void debugDisplay() {\n+            if (debug == null) {\n+                return;\n+            }\n+            debug.println(\" * Decision: \" + this);\n+        }\n+    }\n+\n+    private record FilterQuery(String provider, String svcType,\n+            String svcAlgo) {\n+        private FilterQuery {\n+            assert provider != null && svcType != null && svcAlgo != null :\n+                    \"Invalid FilterQuery.\";\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Service filter query (Provider: \" + provider +\n+                    \", Service type: \" + svcType + \", Algorithm: \" +\n+                    svcAlgo + \")\";\n+        }\n+    }\n+\n+    private static final class Filter {\n+        private sealed interface Rule permits PatternRule, DefaultRule {\n+            FilterDecision apply(FilterQuery q);\n+        }\n+\n+        private record PatternRuleComponent(Type type, String value,\n+                Pattern regexp) {\n+            enum Type {\n+                PROVIDER(\"Provider\"),\n+                SVC_TYPE(\"Service type\"),\n+                SVC_ALGO(\"Algorithm\");\n+\n+                private final String type;\n+\n+                Type(String type) {\n+                    this.type = type;\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return type;\n+                }\n+            }\n+\n+            private static final Pattern ALL_PATTERN = Pattern.compile(\".*\");\n+\n+            static final PatternRuleComponent ANY_SVC_TYPE =\n+                    new PatternRuleComponent(Type.SVC_TYPE, \"*\", ALL_PATTERN);\n+\n+            static final PatternRuleComponent ANY_SVC_ALGO =\n+                    new PatternRuleComponent(Type.SVC_ALGO, \"*\", ALL_PATTERN);\n+\n+            PatternRuleComponent {\n+                assert value != null && !value.isEmpty() && regexp != null :\n+                        \"Invalid PatternRuleComponent instance.\";\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return value;\n+            }\n+\n+            void debugDisplay() {\n+                if (debug == null) {\n+                    return;\n+                }\n+                debug.println(\" * \" + type + \": \" + value + \" (regexp: \" +\n+                        regexp + \")\");\n+            }\n+        }\n+\n+        private static final class PatternRule implements Rule {\n+            private FilterDecision decision;\n+            private PatternRuleComponent provider;\n+            private PatternRuleComponent svcType;\n+            private PatternRuleComponent svcAlgo;\n+\n+            @Override\n+            public FilterDecision apply(FilterQuery q) {\n+                assert assertIsValid();\n+                if (provider.regexp.matcher(q.provider).matches() &&\n+                        svcType.regexp.matcher(q.svcType).matches() &&\n+                        svcAlgo.regexp.matcher(q.svcAlgo).matches()) {\n+                    return decision;\n+                }\n+                return FilterDecision.UNDECIDED;\n+            }\n+\n+            private boolean assertIsValid() {\n+                assert decision.result != FilterDecision.Result.UNDECIDED :\n+                        \"Invalid decision result.\";\n+                assert decision.priority != FilterDecision.UNDEFINED_PRIORITY :\n+                        \"Invalid decision priority.\";\n+                assert provider != null : \"Invalid provider.\";\n+                assert svcType != null : \"Invalid service type.\";\n+                assert svcAlgo != null : \"Invalid algorithm.\";\n+                return true;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return (decision.result == FilterDecision.Result.DENY ? \"!\" :\n+                        \"\") + provider + \".\" + svcType + \".\" + svcAlgo;\n+            }\n+\n+            void debugDisplay() {\n+                if (debug == null) {\n+                    return;\n+                }\n+                provider.debugDisplay();\n+                svcType.debugDisplay();\n+                svcAlgo.debugDisplay();\n+                decision.debugDisplay();\n+            }\n+        }\n+\n+        private static final class DefaultRule implements Rule {\n+            private final FilterDecision d;\n+\n+            DefaultRule(int priority) {\n+                d = new FilterDecision(FilterDecision.Result.DENY, priority);\n+            }\n+\n+            @Override\n+            public FilterDecision apply(FilterQuery q) {\n+                return d;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"!* (DEFAULT)\";\n+            }\n+        }\n+\n+        private static final class ParserException extends Exception {\n+            @java.io.Serial\n+            private static final long serialVersionUID = -6981287318167654426L;\n+\n+            private static final String LN = System.lineSeparator();\n+\n+            private static final String HEADER_STR = \" * Filter string: \";\n+\n+            private static final String MORE_STR = \"(...)\";\n+\n+            private static final int MORE_TOTAL = MORE_STR.length() + 1;\n+\n+            private static final int MAX_MARK = 7;\n+\n+            private static final int MAX_LINE = 80;\n+\n+            static {\n+                assert MAX_LINE >= HEADER_STR.length() + (MORE_TOTAL * 2) + 1\n+                        : \"Not enough line space.\";\n+            }\n+\n+            private static String addStateInfo(String message, Parser parser) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(message);\n+                sb.append(LN);\n+                sb.append(\" * State: \");\n+                sb.append(parser.state);\n+                sb.append(LN);\n+                renderFilterStr(parser.filterBuff.asReadOnlyBuffer(), sb);\n+                return sb.toString();\n+            }\n+\n+            private static void renderFilterStr(CharBuffer filterBuff,\n+                    StringBuilder sb) {\n+                int filterBuffLen = filterBuff.limit();\n+                int cursor = filterBuff.position() - 1;\n+                int preCutMark, postCutMark;\n+                int lineAvailable = MAX_LINE - HEADER_STR.length() - 1;\n+                int preAvailable = lineAvailable \/ 2;\n+                int postAvailable = (lineAvailable + 1) \/ 2;\n+                boolean preMore = false, postMore = false;\n+                int preCursor, preSpaceCount, preDashCount, postDashCount;\n+\n+                \/\/ Calculate the filter line\n+                if (preAvailable < cursor) {\n+                    preMore = true;\n+                    preAvailable -= MORE_TOTAL;\n+                }\n+                if (postAvailable + cursor + 1 < filterBuffLen) {\n+                    postMore = true;\n+                    postAvailable -= MORE_TOTAL;\n+                }\n+                preCutMark = Math.max(0, cursor - preAvailable);\n+                preAvailable -= cursor - preCutMark;\n+                postCutMark = Math.min(filterBuffLen, cursor + 1 +\n+                        postAvailable);\n+                postAvailable -= postCutMark - (cursor + 1);\n+                if (postAvailable > 0 && preMore) {\n+                    if (preCutMark - (postAvailable + MORE_TOTAL) <= 0) {\n+                        postAvailable += MORE_TOTAL;\n+                        preMore = false;\n+                    }\n+                    preCutMark = Math.max(0, preCutMark - postAvailable);\n+                }\n+                if (preAvailable > 0 && postMore) {\n+                    if (postCutMark + preAvailable + MORE_TOTAL >=\n+                            filterBuffLen) {\n+                        preAvailable += MORE_TOTAL;\n+                        postMore = false;\n+                    }\n+                    postCutMark = Math.min(filterBuffLen, postCutMark +\n+                            preAvailable);\n+                }\n+\n+                \/\/ Calculate the underlining line\n+                preCursor = HEADER_STR.length() + (preMore ? MORE_TOTAL : 0) +\n+                        cursor - preCutMark;\n+                preSpaceCount = Math.max(0, preCursor - MAX_MARK\/2);\n+                preDashCount = Math.min(preCursor, MAX_MARK\/2);\n+                postDashCount = Math.min(MAX_LINE - 1 - preSpaceCount -\n+                        preDashCount, MAX_MARK\/2);\n+\n+                \/\/ Render the filter line\n+                sb.append(HEADER_STR);\n+                if (preMore) {\n+                    sb.append(MORE_STR);\n+                    sb.append(' ');\n+                }\n+                filterBuff.position(0);\n+                sb.append(filterBuff, preCutMark, postCutMark);\n+                if (postMore) {\n+                    sb.append(' ');\n+                    sb.append(MORE_STR);\n+                }\n+                sb.append(LN);\n+\n+                \/\/ Render the underlining line\n+                sb.append(\" \".repeat(preSpaceCount));\n+                sb.append(\"-\".repeat(preDashCount));\n+                sb.append(\"^\");\n+                sb.append(\"-\".repeat(postDashCount));\n+                sb.append(LN);\n+            }\n+\n+            ParserException(String message, Parser parser) {\n+                super(addStateInfo(message, parser));\n+            }\n+        }\n+\n+        private static final class Parser {\n+            private enum ParsingState {\n+                PRE_PATTERN,\n+                PRE_PATTERN_DENY,\n+                PATTERN,\n+                POST_PATTERN\n+            }\n+\n+            private enum Transition {\n+                WHITESPACE_CHAR,\n+                DENY_CHAR,\n+                REGULAR_CHAR,\n+                PATTERN_LEVEL_CHAR,\n+                PATTERN_END_CHAR\n+            }\n+\n+            static List<Rule> parse(String filterStr) throws ParserException {\n+                return new Parser(filterStr).getRules();\n+            }\n+\n+            private final CharBuffer filterBuff;\n+            private final List<Rule> rules;\n+            private PatternRule rule;\n+            private ParsingState state;\n+            private final StringBuffer buff;\n+            private final StringBuffer buffR;\n+            private boolean escape;\n+            private boolean quote;\n+\n+            private Parser(String filterStr) throws ParserException {\n+                filterBuff = CharBuffer.wrap(filterStr);\n+                rules = new ArrayList<>();\n+                rule = new PatternRule();\n+                state = ParsingState.PRE_PATTERN;\n+                buff = new StringBuffer();\n+                buffR = new StringBuffer();\n+                escape = false;\n+                quote = false;\n+                parse();\n+            }\n+\n+            private List<Rule> getRules() {\n+                return rules;\n+            }\n+\n+            private PatternRuleComponent getComponent(\n+                    PatternRuleComponent.Type type) throws ParserException {\n+                if (buff.isEmpty()) {\n+                    throw new ParserException(\"Missing \" +\n+                            type.toString().toLowerCase() + \" in \" +\n+                            \"pattern rule.\", this);\n+                }\n+                if (quote) {\n+                    buffR.append(\"\\\\E\");\n+                    quote = false;\n+                }\n+                return new PatternRuleComponent(type, buff.toString(),\n+                        Pattern.compile(buffR.toString(),\n+                                Pattern.CASE_INSENSITIVE));\n+            }\n+\n+            private void flushBuffers() throws ParserException {\n+                if (rule.provider == null) {\n+                    rule.provider = getComponent(\n+                            PatternRuleComponent.Type.PROVIDER);\n+                } else if (rule.svcType == null) {\n+                    rule.svcType = getComponent(\n+                            PatternRuleComponent.Type.SVC_TYPE);\n+                } else if (rule.svcAlgo == null) {\n+                    rule.svcAlgo = getComponent(\n+                            PatternRuleComponent.Type.SVC_ALGO);\n+                } else {\n+                    assert false : \"Should not reach.\";\n+                }\n+                buff.setLength(0);\n+                buffR.setLength(0);\n+            }\n+\n+            private void endPattern() throws ParserException {\n+                if (escape) {\n+                    throw new ParserException(\"Invalid escaping.\", this);\n+                }\n+                flushBuffers();\n+                if (rule.svcType == null) {\n+                    rule.svcType = PatternRuleComponent.ANY_SVC_TYPE;\n+                }\n+                if (rule.svcAlgo == null) {\n+                    rule.svcAlgo = PatternRuleComponent.ANY_SVC_ALGO;\n+                }\n+                if (debug != null) {\n+                    debug.println(\"--------------------\");\n+                    debug.println(\"Rule parsed: \" + rule);\n+                    rule.debugDisplay();\n+                }\n+                rules.add(rule);\n+                rule = new PatternRule();\n+            }\n+\n+            \/*\n+             * Transition to the next state if there is a valid reason. If the\n+             * reason is not valid, throw an exception. If there are no reasons\n+             * to transition, stay in the same state.\n+             *\/\n+            private void nextState(Transition transition)\n+                    throws ParserException {\n+                if (state == ParsingState.PRE_PATTERN) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in PRE_PATTERN state and ignore whitespaces\n+                        \/\/ at the beginning of a pattern:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm;\"\n+                        \/\/  ^^^^\n+                        \/\/\n+                        \/\/ or\n+                        \/\/\n+                        \/\/ \"    !    Provider.ServiceType.Algorithm;\"\n+                        \/\/  ^^^^\n+                    } else if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Transition to PATTERN state:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;\"\n+                        \/\/     ^^^^\n+                        state = ParsingState.PATTERN;\n+                        rule.decision = new FilterDecision(\n+                                FilterDecision.Result.ALLOW, rules.size());\n+                    } else if (transition == Transition.DENY_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN_DENY state:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/      ^^^^\n+                        state = ParsingState.PRE_PATTERN_DENY;\n+                        rule.decision = new FilterDecision(\n+                                FilterDecision.Result.DENY, rules.size());\n+                    } else {\n+                        throw new ParserException(\"A pattern must start with \" +\n+                                \"a '!' or a security provider name.\", this);\n+                    }\n+                } else if (state == ParsingState.PRE_PATTERN_DENY) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in PRE_PATTERN_DENY state and ignore whitespaces\n+                        \/\/ before the provider:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/      ^^^^\n+                    } else if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Transition to PATTERN state:\n+                        \/\/\n+                        \/\/ \"   !    Provider.ServiceType.Algorithm;\"\n+                        \/\/          ^^^^\n+                        state = ParsingState.PATTERN;\n+                    } else {\n+                        throw new ParserException(\"A pattern must have a \" +\n+                                \"security provider name after '!'.\", this);\n+                    }\n+                } else if (state == ParsingState.PATTERN) {\n+                    if (transition == Transition.REGULAR_CHAR) {\n+                        \/\/ Stay in PATTERN while the provider, service type\n+                        \/\/ and algorithm names fill up:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;\"\n+                        \/\/     ^^^^\n+                    } else if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Transition to POST_PATTERN state, after recording\n+                        \/\/ the parsed rule:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm    ;\"\n+                        \/\/                                   ^^^^\n+                        endPattern();\n+                        state = ParsingState.POST_PATTERN;\n+                    } else if (transition == Transition.PATTERN_END_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN state, after recording\n+                        \/\/ the parsed rule:\n+                        \/\/\n+                        \/\/ \"   Provider.ServiceType.Algorithm;    Provider...\"\n+                        \/\/                                  ^^^\n+                        endPattern();\n+                        state = ParsingState.PRE_PATTERN;\n+                    } else if (transition == Transition.PATTERN_LEVEL_CHAR) {\n+                        \/\/ Stay in PATTERN state while recording characters\n+                        \/\/ for the next level (service type or algorithm):\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm;\"\n+                        \/\/               ^^^^\n+                        if (rule.svcType != null) {\n+                            throw new ParserException(\"Too many levels. Dots \" +\n+                                    \"that are part of a provider name, \" +\n+                                    \"service type or algorithm must be \" +\n+                                    \"escaped.\", this);\n+                        }\n+                        flushBuffers();\n+                    } else {\n+                        throw new ParserException(\"Invalid name in pattern.\",\n+                                this);\n+                    }\n+                } else if (state == ParsingState.POST_PATTERN) {\n+                    if (transition == Transition.WHITESPACE_CHAR) {\n+                        \/\/ Stay in POST_PATTERN state and ignore whitespaces\n+                        \/\/ until the end of the pattern:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm    ;    Provider\"\n+                        \/\/                                    ^^^^\n+                    } else if (transition == Transition.PATTERN_END_CHAR) {\n+                        \/\/ Transition to PRE_PATTERN state:\n+                        \/\/\n+                        \/\/ \"    Provider.ServiceType.Algorithm    ;    Provider\"\n+                        \/\/                                       ^^^\n+                        state = ParsingState.PRE_PATTERN;\n+                    } else {\n+                        throw new ParserException(\"Unescaped whitespaces are \" +\n+                                \"only valid at the end of a pattern. \" +\n+                                \"Whitespace characters internal to a \" +\n+                                \"provider name, service type or algorithm \" +\n+                                \"must be escaped.\", this);\n+                    }\n+                } else {\n+                    \/\/ Should not reach.\n+                    throw new RuntimeException(\"Unexpected Providers filter \" +\n+                            \"parser state.\");\n+                }\n+            }\n+\n+            private void appendChar(char c) {\n+                if (c == '*' && !escape) {\n+                    \/\/ Character is a wildcard.\n+                    if (quote) {\n+                        buffR.append(\"\\\\E\");\n+                        quote = false;\n+                    }\n+                    buffR.append(\".*\");\n+                } else {\n+                    \/\/ Character is not a wildcard.\n+                    if (escape) {\n+                        buff.append(\"\\\\\");\n+                    }\n+                    if (!quote) {\n+                        buffR.append(\"\\\\Q\");\n+                        quote = true;\n+                    }\n+                    buffR.append(c);\n+                    if (c == '\\\\') {\n+                        \/\/ A '\\' could be problematic because if an 'E' comes\n+                        \/\/ next the sequence \"\\E\" would interfere with regexp\n+                        \/\/ quoting. Split these sequences into separated\n+                        \/\/ quoting units. I.e: \"...\\\\E\\QE...\".\n+                        buffR.append(\"\\\\E\\\\Q\");\n+                    }\n+                }\n+                buff.append(c);\n+            }\n+\n+            private void parse() throws ParserException {\n+                if (debug != null) {\n+                    debug.println(\"Parsing: \" + filterBuff);\n+                }\n+                assert filterBuff.hasRemaining() : \"Cannot parse an empty \" +\n+                        \"filter.\";\n+                while (filterBuff.hasRemaining()) {\n+                    char c = filterBuff.get();\n+                    if (c == '\\n' || c == '\\0') {\n+                        throw new ParserException(\"Invalid filter character: \" +\n+                                \"'\" + c + \"'\", this);\n+                    } else if (escape) {\n+                        appendChar(c);\n+                        escape = false;\n+                    } else if (c == '\\\\') {\n+                        nextState(Transition.REGULAR_CHAR);\n+                        escape = true;\n+                    } else if (c == '.') {\n+                        nextState(Transition.PATTERN_LEVEL_CHAR);\n+                    } else if (c == ';') {\n+                        nextState(Transition.PATTERN_END_CHAR);\n+                    } else if (Character.isWhitespace(c)) {\n+                        nextState(Transition.WHITESPACE_CHAR);\n+                    } else if (c == '!') {\n+                        nextState(Transition.DENY_CHAR);\n+                    } else if (c == ':' || c == ',') {\n+                        throw new ParserException(\"Reserved character '\" + c +\n+                                \"' must be escaped.\", this);\n+                    } else {\n+                        nextState(Transition.REGULAR_CHAR);\n+                        appendChar(c);\n+                    }\n+                }\n+                if (state != ParsingState.PRE_PATTERN || rules.size() == 0) {\n+                    nextState(Transition.PATTERN_END_CHAR);\n+                }\n+                assert state == ParsingState.PRE_PATTERN : \"Parser state \" +\n+                        \"must finish in PRE_PATTERN.\";\n+            }\n+        }\n+\n+        private final List<Rule> rules;\n+\n+        Filter(String filterStr) throws IllegalArgumentException {\n+            try {\n+                rules = Parser.parse(filterStr);\n+            } catch (ParserException e) {\n+                throw new IllegalArgumentException(\"Invalid Providers filter:\" +\n+                        \" \" + filterStr, e);\n+            }\n+            rules.add(new DefaultRule(rules.size()));\n+        }\n+\n+        FilterDecision apply(FilterQuery q) {\n+            for (Rule r : rules) {\n+                FilterDecision d = r.apply(q);\n+                if (d != FilterDecision.UNDECIDED) {\n+                    if (debug != null) {\n+                        debug.println(\"--------------------\");\n+                        debug.println(q.toString());\n+                        debug.println(\" * Decision: \" + d);\n+                        debug.println(\" * Made by: \" + r);\n+                    }\n+                    return d;\n+                }\n+            }\n+            \/\/ Should never reach this point: there is always a DefaultRule\n+            \/\/ capable of deciding.\n+            throw new RuntimeException(\"Unexpected Providers filter failure: \" +\n+                    \"decision not made.\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Filter: \");\n+            Iterator<Rule> ri = rules.iterator();\n+            while (ri.hasNext()) {\n+                sb.append(ri.next());\n+                if (ri.hasNext()) {\n+                    sb.append(\"; \");\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final Filter filter;\n+\n+    static {\n+        Filter tmpFilter = null;\n+        String fStr = SecurityProperties.getOverridableProperty(FILTER_PROP);\n+        if (debug != null) {\n+            debug.println(\"Filter property value read at this point:\");\n+            for (StackTraceElement ste : new Exception().getStackTrace()) {\n+                debug.println(\" \".repeat(4) + ste);\n+            }\n+        }\n+        if (fStr != null && !fStr.isEmpty()) {\n+            tmpFilter = new Filter(fStr);\n+        }\n+        filter = tmpFilter;\n+        if (debug != null) {\n+            debug.println(filter != null ? filter.toString() : \"No filter\");\n+        }\n+    }\n+\n+    \/*\n+     * This method has to be called every time that a Provider.Service instance\n+     * is obtained with Provider::getService or Provider::getServices.\n+     *\/\n+    public static boolean isAllowed(Provider.Service svc) {\n+        if (filter == null) {\n+            return true;\n+        }\n+        \/\/ For services added to the Provider's ServicesMap (most cases), this\n+        \/\/ call is expected to be fast: a Provider.Service field read only. It\n+        \/\/ might take longer on the first time for uncommon services (see\n+        \/\/ Provider.Service::isAllowed).\n+        return jspa.isAllowed(svc);\n+    }\n+\n+    \/*\n+     * This method is called from Provider.Service::computeSvcAllowed and\n+     * Provider.Service::isTransformationAllowed.\n+     *\/\n+    public static boolean computeSvcAllowed(String providerName,\n+            String svcType, String algo, List<String> aliases) {\n+        if (filter == null) {\n+            return true;\n+        }\n+        FilterDecision d = isAllowed(providerName, svcType, algo);\n+        if (debug != null && aliases.size() > 0) {\n+            debug.println(\"--------------------\");\n+            debug.println(\"The queried service has aliases. Checking them \" +\n+                    \"for a final decision...\");\n+        }\n+        for (String algAlias : aliases) {\n+            FilterDecision da = isAllowed(providerName, svcType, algAlias);\n+            if (da.priority < d.priority) {\n+                d = da;\n+                if (debug != null) {\n+                    algo = algAlias;\n+                }\n+            }\n+        }\n+        if (debug != null && aliases.size() > 0) {\n+            debug.println(\"--------------------\");\n+            debug.println(\"Final decision based on \" + algo + \" algorithm\" +\n+                    \": \" + d);\n+        }\n+        return d.isAllow();\n+    }\n+\n+    private static FilterDecision isAllowed(String provider, String svcType,\n+            String svcAlgo) {\n+        return filter.apply(new FilterQuery(provider, svcType, svcAlgo));\n+    }\n+\n+    \/*\n+     * CipherContext is an auxiliary class to bundle information required by\n+     * CipherTransformation. The field \"transformation\" is the ongoing Cipher\n+     * transformation for which a service is being looked up. The field\n+     * \"svcSearchKey\" is the key (algorithm or alias) used to look up a\n+     * service that might support the transformation.\n+     *\/\n+    public record CipherContext(String transformation, String svcSearchKey) {}\n+\n+    \/*\n+     * CipherTransformation is used from the Cipher::tryGetService,\n+     * Cipher::newInstance and ProviderList.CipherServiceIterator::tryGetService\n+     * methods for a thread to indicate that a service will be looked up for a\n+     * Cipher transformation. In these cases, the service evaluation against\n+     * the Providers Filter is based on the transformation and not the service\n+     * algorithm or aliases. Thus, a Filter value such as\n+     * \"*.Cipher.AES\/ECB\/PKCS5Padding; !*\" would allow\n+     * Cipher.getInstance(\"AES\/ECB\/PKCS5Padding\") but block\n+     * Cipher.getInstance(\"AES\") even when the supporting service is the same.\n+     *\/\n+    public static final class CipherTransformation implements Closeable {\n+        private static final ThreadLocal<CipherContext> cipherTransformContext =\n+                new ThreadLocal<>();\n+        private CipherContext prevContext;\n+\n+        public CipherTransformation(String transformation,\n+                String svcSearchKey) {\n+            if (filter == null) {\n+                return;\n+            }\n+            prevContext = cipherTransformContext.get();\n+            if (!transformation.equalsIgnoreCase(svcSearchKey)) {\n+                cipherTransformContext.set(new CipherContext(\n+                        transformation.toUpperCase(Locale.ENGLISH),\n+                        svcSearchKey));\n+            } else {\n+                \/\/ The transformation matches the service algorithm or alias.\n+                \/\/ Set the context to null to indicate that a regular service\n+                \/\/ evaluation (not based on the transformation) should be done.\n+                cipherTransformContext.set(null);\n+            }\n+        }\n+\n+        \/*\n+         * This method is called from Provider.Service::isAllowed for a thread\n+         * to get the CipherContext related to a service lookup. Returns\n+         * null if 1) there is not an ongoing service lookup based on a Cipher\n+         * transformation or 2) the transformation matches the service\n+         * algorithm or any of its aliases. A regular service evaluation (not\n+         * based on the transformation) should be done if null is returned.\n+         *\/\n+        public static CipherContext getContext() {\n+            if (filter == null) {\n+                return null;\n+            }\n+            return cipherTransformContext.get();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (filter == null) {\n+                return;\n+            }\n+            cipherTransformContext.set(prevContext);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProvidersFilter.java","additions":807,"deletions":0,"binary":false,"changes":807,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,43 @@\n+\n+    private static final String SHA512TRUNCATED = \"SHA512\/2\";\n+\n+    \/**\n+     * Split a Cipher transformation of the form algorithm\/mode\/padding,\n+     * algorithm\/mode or algorithm into its components.\n+     *\n+     * Array components of a Cipher transformation:\n+     *\n+     * index 0: algorithm component (e.g. AES)\n+     * index 1: feedback component (e.g. CFB)\n+     * index 2: padding component (e.g. PKCS5Padding)\n+     *\/\n+    public static String[] getTransformationTokens(String transformation) {\n+        \/\/ check if the transformation contains algorithms with \"\/\" in their\n+        \/\/ name which can cause the parsing logic to go wrong\n+        int sha512Idx = transformation.toUpperCase(Locale.ENGLISH)\n+                .indexOf(SHA512TRUNCATED);\n+        int startIdx = (sha512Idx == -1 ? 0 :\n+                sha512Idx + SHA512TRUNCATED.length());\n+        int endIdx = transformation.indexOf('\/', startIdx);\n+        if (endIdx == -1) {\n+            \/\/ algorithm\n+            return new String[] { transformation.trim() };\n+        } else {\n+            String algorithm;\n+            String mode;\n+            String padding;\n+            algorithm = transformation.substring(0, endIdx).trim();\n+            startIdx = endIdx + 1;\n+            endIdx = transformation.indexOf('\/', startIdx);\n+            if (endIdx == -1) {\n+                \/\/ algorithm\/mode\n+                mode = transformation.substring(startIdx).trim();\n+                return new String[] { algorithm, mode };\n+            } else {\n+                \/\/ algorithm\/mode\/padding\n+                mode = transformation.substring(startIdx, endIdx).trim();\n+                padding = transformation.substring(endIdx + 1).trim();\n+                return new String[] { algorithm, mode, padding };\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AlgorithmDecomposer.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1529,0 +1529,103 @@\n+\n+#\n+# Security Providers Filter (JEP TBD)\n+#\n+# This filter can be used to constrain which services, implemented by installed\n+# security providers, are available for use in the getInstance JCA APIs (Cipher,\n+# Signature, Mac, KeyFactory, etc). Services filtering is independent of other\n+# mechanisms such as jdk.tls.disabledAlgorithms, jdk.jar.disabledAlgorithms and\n+# jdk.certpath.disabledAlgorithms.\n+#\n+# The scope of this filter includes services implemented by statically installed\n+# security providers (security.provider.<n> security properties) and dynamically\n+# installed ones (java.security.Security::addProvider API). No distinctions are\n+# made between OpenJDK and third-party security providers.\n+#\n+# If the system property jdk.security.providers.filter is set, it supersedes\n+# the security one defined here. If any of these properties is set at run time,\n+# the filter could be initialized already and the new value will not take effect\n+# until the JVM is relaunched. When a filter is not set or is set to the empty\n+# string, filtering is disabled: all services are allowed.\n+#\n+# A service is typically evaluated against the filter at provider registration\n+# time (java.security.Provider ::put or ::putService APIs). In special cases, when\n+# a provider overrides java.security.Provider ::getService or ::getServices APIs to\n+# return unregistered services, filter evaluation is deferred until its first use.\n+# Services are identifiable as a combination of a security provider, a service type\n+# and an algorithm name. Optionally, an algorithm alias can be used to replace the\n+# algorithm name. A filter is made of a sequence of patterns that identify a service\n+# according to a matching criteria (as we shall see later) and indicate an action:\n+# allow or deny the service under evaluation.\n+#\n+# The filter syntax is as follows:\n+#\n+# pattern-1; pattern-2; ...; pattern-n\n+#\n+# Each pattern in the sequence can be optionally prefixed by a '!' character (e.g.\n+# \" ! pattern-1 \"). White spaces between patterns, pattern prefixes ('!') and pattern\n+# separators (';') are not significant. A service is evaluated against the filter\n+# from left to right. If a service matches one of the patterns in the sequence, an\n+# authorization decision is made: if the pattern is prefixed by a '!' character, the\n+# decision is to deny it; otherwise, the decision is to allow it. If none of the\n+# patterns match, the default decision is to deny the service. Once a decision is\n+# made, remaining patterns are not considered.\n+#\n+# Each pattern's syntax has one of the following forms:\n+#\n+# 1) security-provider\n+# 2) security-provider.service-type\n+# 3.a) security-provider.service-type.algorithm-name\n+# 3.b) security-provider.service-type.algorithm-alias\n+# 3.c) security-provider.Cipher.transformation\n+# 3.d) security-provider.Cipher.transformation-alias\n+#\n+# In form #1, a security provider name equal to security-provider is enough for a\n+# match to be successful. In form #2, the service type must also be equal to\n+# service-type. In form #3.a, the service algorithm must also be equal to\n+# algorithm-name. In form #3.b, it is enough that one of the service aliases matches\n+# algorithm-alias, in addition to the requirements for form #2. Form #3.c is similar\n+# to form #3.a but applies to cipher transformations with multiple components\n+# (algorithm\/mode\/padding). Form #3.d is equivalent to #3.c but looks for a\n+# transformation alias match (algorithm-alias\/mode\/padding). In all cases, pattern and\n+# service names must have valid characters and cannot be empty. Pattern matching is\n+# always case insensitive.\n+#\n+# Characters '\\n' and '\\0' are not valid in a pattern. The character '.' is used as a\n+# separator between different levels: security provider, service type, algorithm name or\n+# algorithm alias. The following characters, when part of one of the listed levels, must\n+# be escaped by prepending a '\\' character: '!', '*', ' ' (white space), '.', ';', '\\',\n+# ':' and ','. Escaping any other character has no effect other than silently discarding\n+# the '\\' character.\n+#\n+# The aforementioned escaping rules apply to the filter value as read in the\n+# java.security.Security::getProperty and java.lang.System::getProperty APIs:\n+# additional escaping might be needed depending on how the filter value is passed. For\n+# example, security properties require '\\' characters to be escaped. Thus, to match a\n+# provider whose name is abc\\123, a pattern must be escaped as abc\\\\\\\\123 if passed as a\n+# security property.\n+#\n+# In addition to character escape sequences, pattern names can contain '*' wildcards to\n+# imply zero or more repetitions of any character. Wildcards behave in greedy mode, trying\n+# to consume as many characters as possible and backing off if necessary.\n+#\n+# When a service has aliases, its algorithm name and each of the aliases are independently\n+# evaluated against the filter. Notice that the security provider and service type for each\n+# of these evaluations are the same. From the set of authorization decisions obtained which\n+# can potentially be contradictory, the one made by the left-most pattern in the filter has\n+# the highest priority and is finally effective. This strategy would be equivalent to\n+# modifying the evaluation of a service against each pattern so that each alias is tried\n+# (besides the algorithm name) and stopping if a decision is made for one of them.\n+#\n+# For troubleshooting, it is possible to enable filter debugging logs with the system\n+# property java.security.debug=jca and look for messages prefixed by ProvidersFilter. To list\n+# services allowed and not allowed by a filter for each installed security provider, run java\n+# with the argument -XshowSettings:security:providers. When a filter value is syntactically\n+# invalid, the exception message thrown points to the exact location in the pattern that could\n+# not be parsed.\n+#\n+# Example\n+#\n+# Enable all services except those involving the algorithms MD2 or MD5:\n+# jdk.security.providers.filter=!*.*.*MD2*; !*.*.*MD5*; *\n+#\n+#jdk.security.providers.filter=\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import sun.security.jca.ProvidersFilter;\n+\n@@ -422,1 +424,2 @@\n-                    if (service == null) {\n+                    if (service == null ||\n+                            !ProvidersFilter.isAllowed(service)) {\n@@ -568,1 +571,1 @@\n-                if (service == null) {\n+                if (service == null || !ProvidersFilter.isAllowed(service)) {\n@@ -643,1 +646,2 @@\n-                if (s.getType().equals(serviceName)) {\n+                if (ProvidersFilter.isAllowed(s) &&\n+                        s.getType().equals(serviceName)) {\n","filename":"src\/java.security.sasl\/share\/classes\/javax\/security\/sasl\/Sasl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -180,1 +181,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -242,1 +243,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -313,1 +314,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/TransformService.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -206,1 +207,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -257,1 +258,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -320,1 +321,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/XMLSignatureFactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import sun.security.jca.ProvidersFilter;\n@@ -161,1 +162,1 @@\n-            if (s != null) {\n+            if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -212,1 +213,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n@@ -273,1 +274,1 @@\n-        if (s != null) {\n+        if (s != null && ProvidersFilter.isAllowed(s)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,1077 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.util.*;\n+import javax.crypto.*;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.login.Configuration;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslServer;\n+import javax.smartcardio.TerminalFactory;\n+import javax.xml.crypto.dsig.Transform;\n+import javax.xml.crypto.dsig.TransformService;\n+import javax.xml.crypto.dsig.XMLSignatureFactory;\n+import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\n+\n+import sun.security.jca.GetInstance;\n+import sun.security.util.KnownOIDs;\n+\n+import jdk.test.lib.process.Proc;\n+import jdk.test.lib.util.FileUtils;\n+\n+\/*\n+ * @test\n+ * @bug 8315487\n+ * @summary\n+ *   Tests the sun.security.jca.ProvidersFilter.\n+ * @modules java.base\/sun.security.jca\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=600 -enablesystemassertions ProvidersFilterTest\n+ *\/\n+\n+public final class ProvidersFilterTest {\n+    private static final boolean DEBUG = false;\n+\n+    private static final String SEC_FILTER_PROP =\n+            \"jdk.security.providers.filter\";\n+\n+    private static final String FILTER_EXCEPTION_HDR = \" * Filter string: \";\n+\n+    private static final String FILTER_EXCEPTION_MORE = \"(...)\";\n+\n+    private static final int FILTER_EXCEPTION_MAX_LINE = 80;\n+\n+    private static Path workspace;\n+\n+    private static final String TEST_SERVICE_TYPE = \"TestServiceType\";\n+\n+    \/*\n+     * Class used as a service SPI for services added by security providers\n+     * installed dynamically.\n+     *\/\n+    public static final class TestServiceSpi {\n+    }\n+\n+    @FunctionalInterface\n+    private interface ServiceChecker {\n+        boolean check(ServiceData svcData);\n+    }\n+\n+    @FunctionalInterface\n+    private interface ServiceOp {\n+        void doOp() throws Throwable;\n+    }\n+\n+    private static boolean serviceCheck(ServiceOp serviceOp) {\n+        try {\n+            serviceOp.doOp();\n+            return true;\n+        } catch (Throwable t) {\n+            if (DEBUG) {\n+                t.printStackTrace();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static final Map<String, ServiceChecker> serviceCheckers =\n+            new HashMap<>();\n+\n+    static {\n+        serviceCheckers.put(\"AlgorithmParameterGenerator\", (ServiceData d) ->\n+                serviceCheck(() -> AlgorithmParameterGenerator\n+                        .getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"AlgorithmParameters\",\n+                (ServiceData d) -> serviceCheck(() -> AlgorithmParameters\n+                        .getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"CertificateFactory\", (ServiceData d) ->\n+                serviceCheck(() ->\n+                        CertificateFactory.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"CertPathBuilder\", (ServiceData d) -> serviceCheck(\n+                () -> CertPathBuilder.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"CertPathValidator\", (ServiceData d) ->\n+                serviceCheck(() ->\n+                        CertPathValidator.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"CertStore\", (ServiceData d) -> serviceCheck(\n+                () -> {\n+                    if (d.svcAlgo.equals(\"Collection\")) {\n+                        CertStore.getInstance(d.svcAlgo,\n+                                new CollectionCertStoreParameters(),\n+                                d.provider);\n+                    } else {\n+                        try {\n+                            CertStore.getInstance(d.svcAlgo,\n+                                    new LDAPCertStoreParameters(),\n+                                    d.provider);\n+                        } catch (InvalidAlgorithmParameterException ignored) {\n+                            \/\/ The InitialDirContext could not be created as\n+                            \/\/ there is not a server in localhost but this is\n+                            \/\/ an indication that the service is available:\n+                            \/\/ NoSuchAlgorithmException would have been thrown\n+                            \/\/ otherwise.\n+                        }\n+                    }\n+                }));\n+        serviceCheckers.put(\"Cipher\", (ServiceData d) -> serviceCheck(\n+                () -> Cipher.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"Configuration\", (ServiceData d) ->\n+                serviceCheck(() -> Configuration\n+                        .getInstance(d.svcAlgo, null, d.provider)));\n+        serviceCheckers.put(\"KEM\", (ServiceData d) -> serviceCheck(\n+                () -> KEM.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyAgreement\", (ServiceData d) -> serviceCheck(\n+                () -> KeyAgreement.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyFactory\", (ServiceData d) -> serviceCheck(\n+                () -> KeyFactory.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyGenerator\", (ServiceData d) -> serviceCheck(\n+                () -> KeyGenerator.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyInfoFactory\", (ServiceData d) ->\n+                serviceCheck(() -> KeyInfoFactory\n+                        .getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyManagerFactory\", (ServiceData d) ->\n+                serviceCheck(() ->\n+                        KeyManagerFactory.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyPairGenerator\", (ServiceData d) -> serviceCheck(\n+                () -> KeyPairGenerator.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"KeyStore\", (ServiceData d) -> serviceCheck(\n+                () -> KeyStore.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"Mac\", (ServiceData d) -> serviceCheck(\n+                () -> Mac.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"MessageDigest\", (ServiceData d) -> serviceCheck(\n+                () -> MessageDigest.getInstance(d.svcAlgo, d.provider)));\n+        final CallbackHandler saslCallbackHandler = callbacks -> {\n+            for (Callback cb : callbacks) {\n+                if (cb instanceof PasswordCallback) {\n+                    ((PasswordCallback) cb).setPassword(\n+                            \"password\".toCharArray());\n+                } else if (cb instanceof NameCallback) {\n+                    ((NameCallback) cb).setName(\"username\");\n+                }\n+            }\n+        };\n+        serviceCheckers.put(\"SaslClientFactory\", (ServiceData d) ->\n+                serviceCheck(() -> {\n+                    SaslClient c = Sasl.createSaslClient(\n+                            new String[] { d.svcAlgo }, \"username\",\n+                            \"ldap\", \"server1\", Collections.emptyMap(),\n+                            saslCallbackHandler);\n+                    if (c == null) {\n+                        throw new NoSuchAlgorithmException();\n+                    }\n+                }));\n+        serviceCheckers.put(\"SaslServerFactory\", (ServiceData d) ->\n+                serviceCheck(() -> {\n+                    SaslServer s = Sasl.createSaslServer(\n+                            d.svcAlgo, \"ldap\", \"server1\",\n+                            Collections.emptyMap(), saslCallbackHandler);\n+                    if (s == null) {\n+                        throw new NoSuchAlgorithmException();\n+                    }\n+                }));\n+        serviceCheckers.put(\"SecretKeyFactory\", (ServiceData d) -> serviceCheck(\n+                () -> SecretKeyFactory.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"SecureRandom\", (ServiceData d) -> serviceCheck(\n+                () -> SecureRandom.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"Signature\", (ServiceData d) -> serviceCheck(\n+                () -> Signature.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"SSLContext\", (ServiceData d) -> serviceCheck(\n+                () -> SSLContext.getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"TerminalFactory\", (ServiceData d) ->\n+                serviceCheck(() -> TerminalFactory\n+                        .getInstance(d.svcAlgo, null, d.provider)));\n+        serviceCheckers.put(\"TransformService\", (ServiceData d) ->\n+                serviceCheck(() -> TransformService\n+                        .getInstance(d.svcAlgo, \"DOM\", d.provider)));\n+        serviceCheckers.put(\"TrustManagerFactory\", (ServiceData d) ->\n+                serviceCheck(() -> TrustManagerFactory\n+                        .getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(\"XMLSignatureFactory\", (ServiceData d) ->\n+                serviceCheck(() -> XMLSignatureFactory\n+                        .getInstance(d.svcAlgo, d.provider)));\n+        serviceCheckers.put(TEST_SERVICE_TYPE,\n+                (ServiceData d) -> serviceCheck(() -> GetInstance.getInstance(\n+                        TEST_SERVICE_TYPE, TestServiceSpi.class, d.svcAlgo,\n+                        d.provider)));\n+    }\n+\n+    private static sealed class ServiceData implements Serializable\n+            permits DynamicServiceData {\n+        @Serial\n+        private static final long serialVersionUID = -351065619007499507L;\n+        protected final String provider;\n+        private final String svcType;\n+        protected final String svcAlgo;\n+\n+        private ServiceData(String provider, String svcType, String svcAlgo) {\n+            this.provider = provider;\n+            this.svcType = svcType;\n+            this.svcAlgo = svcAlgo;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return provider + \" \/ \" + svcType + \" \/ \" + svcAlgo;\n+        }\n+    }\n+\n+    private static final class DynamicServiceData extends ServiceData {\n+        @Serial\n+        private static final long serialVersionUID = 6156428473910912042L;\n+        final List<String> aliases;\n+        final Boolean legacy;\n+\n+        DynamicServiceData(String provider, String svcType,\n+                String svcAlgo, List<String> aliases, Boolean legacy) {\n+            super(provider, svcType, svcAlgo);\n+            if (aliases != null) {\n+                this.aliases = aliases;\n+            } else {\n+                this.aliases = List.of();\n+            }\n+            this.legacy = legacy;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return super.toString() + (aliases != null ?\n+                    \" \/ aliases: \" + aliases : \"\") + \" \/ legacy: \" + (legacy ==\n+                    null ? \"unregistered\" : legacy);\n+        }\n+    }\n+\n+    private record ExpectedExceptionData(String exceptionClass,\n+            String filterLine, String underliningLine) implements Serializable {\n+    }\n+\n+    private static final class TestExecutor {\n+        enum FilterPropertyType {\n+            SYSTEM, SECURITY\n+        }\n+\n+        @FunctionalInterface\n+        private interface AssertionDataLoader {\n+            void apply(TestExecutor testExecutor, String provider,\n+                    String svcType, String svcAlgo) throws Throwable;\n+        }\n+\n+        private final List<DynamicServiceData> dynamicServices =\n+                new ArrayList<>();\n+        private final List<ServiceData> expected = new ArrayList<>();\n+        private final List<ServiceData> notExpected = new ArrayList<>();\n+        private ExpectedExceptionData expectedException = null;\n+        private String filterStr;\n+        private FilterPropertyType propertyType;\n+\n+        void setFilter(String filterStr) {\n+            setFilter(filterStr, FilterPropertyType.SECURITY);\n+        }\n+\n+        void setFilter(String filterStr, FilterPropertyType propertyType) {\n+            if (propertyType == FilterPropertyType.SECURITY) {\n+                StringBuilder sb = new StringBuilder(filterStr.length());\n+                CharBuffer cb = CharBuffer.wrap(filterStr);\n+                while (cb.hasRemaining()) {\n+                    char c = cb.get();\n+                    if (c == '\\\\') {\n+                        sb.append('\\\\');\n+                    }\n+                    if (Character.UnicodeBlock.of(c) ==\n+                            Character.UnicodeBlock.BASIC_LATIN) {\n+                        sb.append(c);\n+                    } else {\n+                        sb.append(\"\\\\u%04x\".formatted((int) c));\n+                    }\n+                }\n+                this.filterStr = sb.toString();\n+            } else {\n+                this.filterStr = filterStr;\n+            }\n+            this.propertyType = propertyType;\n+            if (DEBUG) {\n+                System.out.println(\"Filter: \" + filterStr);\n+            }\n+        }\n+\n+        private void addDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy,\n+                AssertionDataLoader assertionDataLoader) throws Throwable {\n+            DynamicServiceData svcData = new DynamicServiceData(provider,\n+                    TEST_SERVICE_TYPE, svcAlgo, aliases, legacy);\n+            dynamicServices.add(svcData);\n+            \/\/ Sanity check: install the dynamic security provider without a\n+            \/\/ filter.\n+            DynamicProvider dynamicProvider = DynamicProvider.install(svcData);\n+            dynamicProvider.putAlgo(svcData);\n+            assertionDataLoader.apply(this, provider, TEST_SERVICE_TYPE,\n+                    svcAlgo);\n+        }\n+\n+        void addExpectedDynamicService(String provider, String svcAlgo)\n+                throws Throwable {\n+            addExpectedDynamicService(provider, svcAlgo, null, false);\n+        }\n+\n+        void addExpectedDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy) throws Throwable {\n+            addDynamicService(provider, svcAlgo, aliases, legacy,\n+                    TestExecutor::addExpectedService);\n+        }\n+\n+        void addExpectedService(String provider, String svcType,\n+                String svcAlgo) throws Throwable {\n+            expected.add(checkSvcAvailable(new ServiceData(provider,\n+                    svcType, svcAlgo)));\n+        }\n+\n+        void addNotExpectedDynamicService(String provider, String svcAlgo)\n+                throws Throwable {\n+            addNotExpectedDynamicService(provider, svcAlgo, null, false);\n+        }\n+\n+        void addNotExpectedDynamicService(String provider, String svcAlgo,\n+                List<String> aliases, Boolean legacy) throws Throwable {\n+            addDynamicService(provider, svcAlgo, aliases, legacy,\n+                    TestExecutor::addNotExpectedService);\n+        }\n+\n+        void addNotExpectedService(String provider, String svcType,\n+                String svcAlgo) throws Throwable {\n+            notExpected.add(checkSvcAvailable(new ServiceData(provider,\n+                    svcType, svcAlgo)));\n+        }\n+\n+        \/*\n+         * Sanity check: services must be available without a filter.\n+         *\/\n+        private ServiceData checkSvcAvailable(ServiceData svcData)\n+                throws Throwable {\n+            if (!serviceCheckers.get(svcData.svcType).check(svcData)) {\n+                throw new Exception(\"The service \" + svcData + \" is not\" +\n+                        \" available without a filter.\");\n+            }\n+            return svcData;\n+        }\n+\n+        void addExpectedFilterException(String filterLine,\n+                int underliningSpaces) {\n+            String underliningLine = \" \".repeat(underliningSpaces) +\n+                    \"---^---\";\n+            underliningLine = underliningLine.substring(0, Math.min(\n+                    underliningLine.length(), FILTER_EXCEPTION_MAX_LINE));\n+            expectedException = new ExpectedExceptionData(\"sun.security.jca\" +\n+                    \".ProvidersFilter$Filter$ParserException\",\n+                    FILTER_EXCEPTION_HDR + filterLine, underliningLine);\n+        }\n+\n+        void execute() throws Throwable {\n+            String testClassName = getClass().getEnclosingClass().getName();\n+            Path dynamicServicesPath = getSvcDataFile(dynamicServices,\n+                    \"Dynamically installed services\");\n+            Path expectedPath = getSvcDataFile(expected, \"Expected\");\n+            Path notExpectedPath = getSvcDataFile(notExpected, \"Not expected\");\n+            Path expectedExceptionPath = serializeObject(expectedException);\n+            if (DEBUG) {\n+                System.out.println(\"=========================================\");\n+            }\n+            Proc p = Proc.create(testClassName).args(\n+                    dynamicServicesPath.toString(), expectedPath.toString(),\n+                    notExpectedPath.toString(), (expectedExceptionPath == null ?\n+                            \"\" : expectedExceptionPath.toString()));\n+            p.env(\"JDK_JAVA_OPTIONS\", \"-enablesystemassertions\");\n+            if (propertyType == FilterPropertyType.SECURITY) {\n+                p.secprop(SEC_FILTER_PROP, filterStr);\n+            } else {\n+                p.prop(SEC_FILTER_PROP, filterStr);\n+            }\n+            if (DEBUG) {\n+                p.inheritIO();\n+                p.prop(\"java.security.debug\", \"jca\");\n+                p.debug(testClassName);\n+\n+                \/\/ Need the launched process to connect to a debugger?\n+                \/\/System.setProperty(\"test.vm.opts\", \"-Xrunjdwp:transport=\" +\n+                \/\/        \"dt_socket,address=localhost:8000,suspend=y\");\n+            } else {\n+                p.nodump();\n+            }\n+            p.start().waitFor(0);\n+            for (ServiceData svcData : dynamicServices) {\n+                Security.removeProvider(svcData.provider);\n+            }\n+        }\n+    }\n+\n+    private static Path getSvcDataFile(Object svcData, String title)\n+            throws Throwable {\n+        assert svcData != null : \"Service data cannot be null.\";\n+        Path svcDataFilePath = serializeObject(svcData);\n+        showFileContent(svcDataFilePath, title);\n+        return svcDataFilePath;\n+    }\n+\n+    private static List<ServiceData> getSvcData(Path svcDataPath)\n+            throws Throwable {\n+        return (List<ServiceData>) deserializeObject(svcDataPath);\n+    }\n+\n+    private static Path serializeObject(Object obj) throws Throwable {\n+        if (obj == null) {\n+            return null;\n+        }\n+        Path objFilePath = Files.createTempFile(workspace, null, null);\n+        try (FileOutputStream fos =\n+                     new FileOutputStream(objFilePath.toFile())) {\n+            ObjectOutputStream oos = new ObjectOutputStream(fos);\n+            oos.writeObject(obj);\n+            oos.flush();\n+        }\n+        return objFilePath;\n+    }\n+\n+    private static Object deserializeObject(Path filePath)\n+            throws Throwable {\n+        try (FileInputStream fos = new FileInputStream(filePath.toFile())) {\n+            ObjectInputStream ois = new ObjectInputStream(fos);\n+            return ois.readObject();\n+        }\n+    }\n+\n+    private static void showFileContent(Path filePath, String title)\n+            throws Throwable {\n+        if (DEBUG) {\n+            System.out.println(\"-----------------------------------------\");\n+            System.out.println(title + \" assertion data (\" + filePath + \"):\");\n+            for (ServiceData svcData : getSvcData(filePath)) {\n+                System.out.println(svcData);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length == 4) {\n+            \/\/ Executed by a child process.\n+            mainChild(args[0], args[1], args[2], args[3]);\n+        } else if (args.length == 0) {\n+            \/\/ Executed by the parent process.\n+            try {\n+                workspace = Files.createTempDirectory(null);\n+                mainLauncher();\n+            } finally {\n+                FileUtils.deleteFileTreeWithRetry(workspace);\n+            }\n+            System.out.println(\"TEST PASS - OK\");\n+        } else {\n+            throw new Exception(\"Unexpected number of arguments.\");\n+        }\n+    }\n+\n+    private interface SvcDataConsumer {\n+        void consume(ServiceData data, boolean available) throws Throwable;\n+    }\n+\n+    private static void mainChild(String dynamicServicesPath,\n+            String expectedPropsPath, String notExpectedPropsPath,\n+            String expectedExceptionPath) throws Throwable {\n+        if (!expectedExceptionPath.isEmpty()) {\n+            ExpectedExceptionData expectedException = (ExpectedExceptionData)\n+                    deserializeObject(Paths.get(expectedExceptionPath));\n+            try {\n+                \/\/ Force the filter to be loaded.\n+                Security.getProviders();\n+            } catch (Throwable t) {\n+                if (DEBUG) {\n+                    System.out.println(\"Filter line expected: \" +\n+                            expectedException.filterLine);\n+                    System.out.println(\"Filter underlining line expected: \" +\n+                            expectedException.underliningLine);\n+                    t.printStackTrace();\n+                }\n+                Throwable ultimateCause = t.getCause();\n+                while (ultimateCause.getCause() != null) {\n+                    ultimateCause = ultimateCause.getCause();\n+                }\n+                if (ultimateCause.getClass().getName()\n+                        .equals(expectedException.exceptionClass)) {\n+                    String[] lines = ultimateCause.getMessage().split(\"\\\\R\");\n+                    for (int i = 0; i < lines.length; i++) {\n+                        if (lines[i].startsWith(FILTER_EXCEPTION_HDR)) {\n+                            if (lines[i].equals(expectedException.filterLine) &&\n+                                i < lines.length - 1 && lines[i + 1].equals(\n+                                        expectedException.underliningLine)) {\n+                                return;\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            throw new Exception(\"Expected filter exception could not be \" +\n+                    \"verified.\");\n+        }\n+        installDynamicServices(dynamicServicesPath);\n+        if (DEBUG) {\n+            System.out.println(\"Security Providers installed:\");\n+            for (Provider provider : Security.getProviders()) {\n+                System.out.println(\"Provider: \" + provider);\n+            }\n+        }\n+        perSvcDataDo(expectedPropsPath,\n+                (ServiceData data, boolean available) -> {\n+            if (!available) {\n+                throw new Exception(\"The service '\" + data + \"' is not \" +\n+                        \"available when it was expected.\");\n+            }\n+        });\n+        perSvcDataDo(notExpectedPropsPath,\n+                (ServiceData data, boolean available) -> {\n+            if (available) {\n+                throw new Exception(\"The service '\" + data + \"' is \" +\n+                        \"available when it was not expected.\");\n+            }\n+        });\n+    }\n+\n+    private static abstract sealed class DynamicProvider extends Provider\n+            permits DynamicProviderCurrent, DynamicProviderLegacy,\n+            DynamicProviderUnregistered {\n+        @Serial\n+        private static final long serialVersionUID = 6088341396620902983L;\n+\n+        static DynamicProvider install(DynamicServiceData svcData)\n+                throws Throwable {\n+            DynamicProvider dynamicProvider;\n+            if (Security.getProvider(svcData.provider)\n+                    instanceof DynamicProvider dP) {\n+                dynamicProvider = dP;\n+            } else {\n+                if (svcData.legacy == null) {\n+                    dynamicProvider = new DynamicProviderUnregistered(svcData);\n+                } else if (svcData.legacy) {\n+                    dynamicProvider = new DynamicProviderLegacy(svcData);\n+                } else {\n+                    dynamicProvider = new DynamicProviderCurrent(svcData);\n+                }\n+                if (Security.addProvider(dynamicProvider) == -1) {\n+                    throw new Exception(\"Could not install dynamic provider.\");\n+                }\n+            }\n+            return dynamicProvider;\n+        }\n+\n+        DynamicProvider(ServiceData svcData) {\n+            super(svcData.provider, \"\", svcData.toString());\n+        }\n+        abstract void putAlgo(DynamicServiceData svcData);\n+    }\n+\n+    private static final class DynamicProviderCurrent extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 7754296009615868997L;\n+\n+        DynamicProviderCurrent(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            putService(new Service(this, TEST_SERVICE_TYPE, svcData.svcAlgo,\n+                    TestServiceSpi.class.getName(), svcData.aliases, null));\n+        }\n+    }\n+\n+    private static final class DynamicProviderLegacy extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 1859892951118353404L;\n+\n+        DynamicProviderLegacy(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            put(TEST_SERVICE_TYPE + \".\" + svcData.svcAlgo,\n+                    TestServiceSpi.class.getName());\n+            for (String alias : svcData.aliases) {\n+                put(\"Alg.Alias.\" + TEST_SERVICE_TYPE + \".\" + alias,\n+                        svcData.svcAlgo);\n+            }\n+        }\n+    }\n+\n+    private static final class DynamicProviderUnregistered\n+            extends DynamicProvider {\n+        @Serial\n+        private static final long serialVersionUID = 4421847184357342760L;\n+        private final Map<String, Service> services = new HashMap<>();\n+\n+        DynamicProviderUnregistered(DynamicServiceData svcData) {\n+            super(svcData);\n+        }\n+\n+        @Override\n+        void putAlgo(DynamicServiceData svcData) {\n+            Provider.Service s = new Service(this, TEST_SERVICE_TYPE,\n+                    svcData.svcAlgo, TestServiceSpi.class.getName(),\n+                    svcData.aliases, null);\n+            services.put(s.getType() + \".\" + s.getAlgorithm(), s);\n+            for (String alias : svcData.aliases) {\n+                services.put(s.getType() + \".\" + alias, s);\n+            }\n+        }\n+\n+        @Override\n+        public Provider.Service getService(String type, String algorithm) {\n+            return services.get(type + \".\" + algorithm);\n+        }\n+\n+        @Override\n+        public Set<Provider.Service> getServices() {\n+            return new HashSet<>(services.values());\n+        }\n+    }\n+\n+    private static void installDynamicServices(String svcDataPath)\n+            throws Throwable {\n+        for (ServiceData svcDataObj : getSvcData(Paths.get(svcDataPath))) {\n+            DynamicServiceData svcData = (DynamicServiceData)svcDataObj;\n+            DynamicProvider dynamicProvider = DynamicProvider.install(svcData);\n+            dynamicProvider.putAlgo(svcData);\n+        }\n+    }\n+\n+    private static Provider getProviderByName(String providerName) {\n+        Provider[] providers = Security.getProviders();\n+        for (Provider p : providers) {\n+            if (p.getName().equals(providerName)) {\n+                return p;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void perSvcDataDo(String svcDataPath,\n+            SvcDataConsumer svcDataDo) throws Throwable {\n+        for (ServiceData svcData : getSvcData(Paths.get(svcDataPath))) {\n+            Provider p = getProviderByName(svcData.provider);\n+            ServiceChecker checker = serviceCheckers.get(svcData.svcType);\n+            boolean availableInCryptoCheckers = checker.check(svcData);\n+            List<String> allAlgos = new ArrayList<>(List.of(svcData.svcAlgo));\n+            if (svcData instanceof DynamicServiceData dynamicSvcData) {\n+                allAlgos.addAll(dynamicSvcData.aliases);\n+            }\n+            for (String algo : allAlgos) {\n+                String filter = svcData.svcType + \".\" + algo;\n+                if (availableInCryptoCheckers &&\n+                        svcData.svcType.equalsIgnoreCase(\"Cipher\")) {\n+                    Provider.Service svc = p.getService(svcData.svcType, algo);\n+                    if (svc == null) {\n+                        \/\/ The Security::getProviders API does not support\n+                        \/\/ transformations except when the service is explicitly\n+                        \/\/ registered for it.\n+                        continue;\n+                    }\n+                }\n+                if (filter.indexOf(':') != -1) {\n+                    \/\/ Character not supported for algorithms in\n+                    \/\/ Security::getProviders.\n+                    continue;\n+                }\n+                boolean availableInFiltered = findSvcInFilteredProviders(\n+                        svcData.provider, filter);\n+                if (availableInCryptoCheckers != availableInFiltered) {\n+                    throw new Exception(\"Inconsistent Security.getProviders(\" +\n+                            \"\\\"\" + filter + \"\\\") filtering result.\");\n+                }\n+            }\n+            svcDataDo.consume(svcData, availableInCryptoCheckers);\n+        }\n+    }\n+\n+    private static boolean findSvcInFilteredProviders(String provider,\n+            String filter) {\n+        Provider[] filteredProviders = Security.getProviders(filter);\n+        if (filteredProviders != null) {\n+            for (Provider p : filteredProviders) {\n+                if (p.getName().equals(provider)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void mainLauncher() throws Throwable {\n+        for (Method m : ProvidersFilterTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                printTestHeader(m.getName());\n+                TestExecutor t = new TestExecutor();\n+                m.invoke(null, t);\n+                t.execute();\n+            }\n+        }\n+    }\n+\n+    private static void printTestHeader(String testName) {\n+        if (DEBUG) {\n+            System.out.println(\"=========================================\");\n+            System.out.println(testName);\n+            System.out.println(\"-----------------------------------------\");\n+        }\n+    }\n+\n+    \/*\n+     * Valid filters\n+     *\/\n+\n+    private static void testBasicFiltering(TestExecutor t) throws Throwable {\n+        t.setFilter(\"  SunJCE.Mac.HmacSHA512; SUN.MessageDigest.SHA-512  ;\" +\n+                \"  !  *.*.*WeaK*;MyProvider.*.myStrongAlgorithm*; \" +\n+                \"!NonExistentProvider  \");\n+        t.addExpectedService(\"SunJCE\", \"Mac\", \"HmacSHA512\");\n+        t.addExpectedDynamicService(\"MyProvider\", \"MyStrongAlgorithm\");\n+        t.addExpectedDynamicService(\"MyProvider\", \"MyStrongAlgorithm2\");\n+        t.addNotExpectedService(\"SunJCE\", \"KeyGenerator\", \"HmacSHA3-512\");\n+        t.addNotExpectedDynamicService(\"MyProvider\", \"MyWeakAlgorithm\");\n+    }\n+\n+    private static void testBasicFilteringUnregistered(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider.*.strong; !R1_MyProvider;\" +\n+                \"!R2_MyProvider.*.weak; R2_MyProvider\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"strong\", List.of(), null);\n+        t.addExpectedDynamicService(\"R2_MyProvider\", \"Algo\", List.of(), null);\n+        t.addNotExpectedDynamicService(\"R1_MyProvider\", \"Algo\", List.of(),\n+                null);\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"weak\", List.of(),\n+                null);\n+    }\n+\n+    private static void testCipherFiltering(TestExecutor t) throws Throwable {\n+        t.setFilter(\"!*.Cipher.AES; *.Cipher.AES\/CBC\/PKCS5Padding; \" +\n+                \"*.Cipher.\" + KnownOIDs.AES.value().replace(\".\", \"\\\\.\") +\n+                \"\/OFB\/NoPadding; *.Cipher.AES_128\/CBC\/*; \" +\n+                \"*.Cipher.PBEWithHmacSHA512\/256AndAES_128\/CBC\/PKCS5Padding;\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\/CBC\/PKCS5Padding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES\/OFB\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\", \"AES_128\/CBC\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES.value() + \"\/CBC\/PKCS5Padding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES.value() + \"\/OFB\/NoPadding\");\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                KnownOIDs.AES_128$CBC$NoPadding.value());\n+        t.addExpectedService(\"SunJCE\", \"Cipher\",\n+                \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/PKCS5Padding\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", \"AES\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", \"AES\/\/\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", KnownOIDs.AES.value() +\n+                \"\/\/\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", KnownOIDs.AES.value());\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\", \"AES\/CBC\/NoPadding\");\n+        t.addNotExpectedService(\"SunJCE\", \"Cipher\",\n+                \"PBEWithHmacSHA512\/256AndAES_128\");\n+    }\n+\n+    private static void testAllServiceTypesFiltering(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"*.AlgorithmParameterGenerator.DiffieHellman; \" +\n+                \"*.AlgorithmParameters.PBES2;\" +\n+                \"*.CertStore.Collection; \" +\n+                \"*.KeyAgreement.ECDH; \" +\n+                \"*.KeyFactory.DiffieHellman; \" +\n+                \"*.KeyGenerator.HmacSHA3-512; \" +\n+                \"*.KeyManagerFactory.NewSunX509; \" +\n+                \"*.KeyPairGenerator.DiffieHellman; \" +\n+                \"*.KeyStore.PKCS12; \" +\n+                \"*.Mac.HmacSHA512; \" +\n+                \"*.MessageDigest.SHA-512; \" +\n+                \"*.SaslClientFactory.EXTERNAL; \" +\n+                \"*.SaslServerFactory.CRAM-MD5; \" +\n+                \"*.SecretKeyFactory.PBEWithHmacSHA512\/256AndAES_256; \" +\n+                \"*.SecureRandom.SHA1PRNG; *.MessageDigest.SHA-1; \" +\n+                \"*.Signature.EdDSA; \" +\n+                \"*.SSLContext.TLSv1\\\\.3; \" +\n+                \"*.TransformService.\" +\n+                Transform.XPATH.replace(\".\", \"\\\\.\").replace(\":\", \"\\\\:\") + \"; \" +\n+                \"*.TrustManagerFactory.PKIX\");\n+\n+        \/\/ Expected services\n+        t.addExpectedService(\"SunJCE\", \"AlgorithmParameterGenerator\",\n+                \"DiffieHellman\");\n+        t.addExpectedService(\"SunJCE\", \"AlgorithmParameters\", \"PBES2\");\n+        t.addExpectedService(\"SUN\", \"CertStore\", \"Collection\");\n+        t.addExpectedService(\"SunEC\", \"KeyAgreement\", \"ECDH\");\n+        t.addExpectedService(\"SunJCE\", \"KeyFactory\", \"DiffieHellman\");\n+        t.addExpectedService(\"SunJCE\", \"KeyGenerator\", \"HmacSHA3-512\");\n+        t.addExpectedService(\"SunJSSE\", \"KeyManagerFactory\", \"NewSunX509\");\n+        t.addExpectedService(\"SunJCE\", \"KeyPairGenerator\", \"DiffieHellman\");\n+        t.addExpectedService(\"SunJSSE\", \"KeyStore\", \"PKCS12\");\n+        t.addExpectedService(\"SunJCE\", \"Mac\", \"HmacSHA512\");\n+        t.addExpectedService(\"SUN\", \"MessageDigest\", \"SHA-512\");\n+        t.addExpectedService(\"SunSASL\", \"SaslClientFactory\", \"EXTERNAL\");\n+        t.addExpectedService(\"SunSASL\", \"SaslServerFactory\", \"CRAM-MD5\");\n+        t.addExpectedService(\"SunJCE\", \"SecretKeyFactory\",\n+                \"PBEWithHmacSHA512\/256AndAES_256\");\n+        t.addExpectedService(\"SUN\", \"SecureRandom\", \"SHA1PRNG\");\n+        t.addExpectedService(\"SunEC\", \"Signature\", \"EdDSA\");\n+        t.addExpectedService(\"SunJSSE\", \"SSLContext\", \"TLSv1.3\");\n+        t.addExpectedService(\"XMLDSig\", \"TransformService\",\n+                Transform.XPATH);\n+        t.addExpectedService(\"SunJSSE\", \"TrustManagerFactory\", \"PKIX\");\n+\n+        \/\/ Not expected services\n+        t.addNotExpectedService(\"SUN\", \"AlgorithmParameterGenerator\", \"DSA\");\n+        t.addNotExpectedService(\"SUN\", \"AlgorithmParameters\", \"DSA\");\n+        t.addNotExpectedService(\"SUN\", \"CertificateFactory\", \"X.509\");\n+        t.addNotExpectedService(\"SUN\", \"CertPathBuilder\", \"PKIX\");\n+        t.addNotExpectedService(\"SUN\", \"CertPathValidator\", \"PKIX\");\n+        t.addNotExpectedService(\"JdkLDAP\", \"CertStore\", \"LDAP\");\n+        t.addNotExpectedService(\"SUN\", \"Configuration\", \"JavaLoginConfig\");\n+        t.addNotExpectedService(\"SunJCE\", \"KEM\", \"DHKEM\");\n+        t.addNotExpectedService(\"SunEC\", \"KeyAgreement\", \"X25519\");\n+        t.addNotExpectedService(\"SUN\", \"KeyFactory\", \"DSA\");\n+        t.addNotExpectedService(\"SunJCE\", \"KeyGenerator\", \"Blowfish\");\n+        t.addNotExpectedService(\"XMLDSig\", \"KeyInfoFactory\", \"DOM\");\n+        t.addNotExpectedService(\"SunJSSE\", \"KeyManagerFactory\", \"SunX509\");\n+        t.addNotExpectedService(\"SUN\", \"KeyPairGenerator\", \"DSA\");\n+        t.addNotExpectedService(\"SUN\", \"KeyStore\", \"JKS\");\n+        t.addNotExpectedService(\"SunJCE\", \"Mac\", \"HmacSHA1\");\n+        t.addNotExpectedService(\"SUN\", \"MessageDigest\", \"MD5\");\n+        t.addNotExpectedService(\"SunSASL\", \"SaslClientFactory\", \"PLAIN\");\n+        t.addNotExpectedService(\"SunSASL\", \"SaslServerFactory\", \"DIGEST-MD5\");\n+        t.addNotExpectedService(\"SunJCE\", \"SecretKeyFactory\", \"DES\");\n+        t.addNotExpectedService(\"SUN\", \"SecureRandom\", \"DRBG\");\n+        t.addNotExpectedService(\"SUN\", \"Signature\", \"SHA1withDSA\");\n+        t.addNotExpectedService(\"SunJSSE\", \"SSLContext\", \"TLSv1.2\");\n+        t.addNotExpectedService(\"SunPCSC\", \"TerminalFactory\", \"PC\/SC\");\n+        t.addNotExpectedService(\"XMLDSig\", \"TransformService\",\n+                Transform.ENVELOPED);\n+        t.addNotExpectedService(\"SunJSSE\", \"TrustManagerFactory\", \"SunX509\");\n+        t.addNotExpectedService(\"XMLDSig\", \"XMLSignatureFactory\", \"DOM\");\n+    }\n+\n+    private static void testCharsEscaping(TestExecutor t) throws Throwable {\n+        t.setFilter(\"R1_\\\\M\\\\!\\\\ \\\\.Pr\\\\*\\\\\\\\\/\\\\;der \\t; \" +\n+                \"R2_My\\\\\\\\E\\\\.\\\\\\\\QProvider;\" +\n+                \"\\\\!R3_M\\\\:Pr\\\\\\tvi\\\\,de\\u2014r.*;\");\n+        t.addExpectedDynamicService(\"R1_M! .Pr*\\\\\/;der\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_My\\\\E.\\\\QProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"!R3_M:Pr\\tvi,de\\u2014r\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_\\\\M! .Pr*\\\\\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pro\\\\\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\/;der\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\\\\\/\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R1_M! .Pr*\\\\\/\\\\\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R2_MyXProvider\", \"Algo\");\n+    }\n+\n+    private static void testWildcardGreediness(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider*; R2_MyProviderA**B**C; \" +\n+                \"R3_MyProvider*ABC\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"R1_MyProviderX\", \"Algo\");\n+        t.addExpectedDynamicService(\"R1_MyProviderXX\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABCDC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R2_MyProviderABCCCC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R3_MyProviderABC\", \"Algo\");\n+        t.addExpectedDynamicService(\"R3_MyProviderABCABC\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R2_MyProviderA\", \"Algo\");\n+    }\n+\n+    private static void testLeftPrecedence(TestExecutor t) throws Throwable {\n+        t.setFilter(\"R1_MyProvider; !R1_MyProvider; !R2_MyProvider; \" +\n+                \"R2_MyProvider; !R3_*; R3_MyProvider; !R4_*.*.AES; \" +\n+                \"R4_*.*.RSA\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\");\n+        t.addExpectedDynamicService(\"R4_MyProvider\", \"RSA\");\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R3_MyProvider\", \"Algo\");\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"AES\");\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"*\");\n+    }\n+\n+    private static void aliasesCommon(TestExecutor t, Boolean legacy)\n+            throws Throwable {\n+        t.setFilter(\"R1_MyProvider.*.Alias; !R1_MyProvider.*.Algo; \" +\n+                \"!R2_MyProvider.*.Alias; R2_MyProvider.*.Algo;\" +\n+                \"R3_MyProvider.*.Algo; !R3_MyProvider.*.Alias;\" +\n+                \"!R4_MyProvider.*.Algo; R4_MyProvider.*.Alias;\" +\n+                \"R5_MyProvider.*.ALIAS1; !R5_MyProvider.*.ALIAS2\");\n+        t.addExpectedDynamicService(\"R1_MyProvider\", \"Algo\", List.of(\"Alias\"),\n+                legacy);\n+        t.addExpectedDynamicService(\"R3_MyProvider\", \"Algo\", List.of(\"Alias\"),\n+                legacy);\n+        t.addExpectedDynamicService(\"R5_MyProvider\", \"Algo\", List.of(\"Alias1\",\n+                \"Alias2\"), legacy);\n+        t.addNotExpectedDynamicService(\"R2_MyProvider\", \"Algo\",\n+                List.of(\"Alias\"), legacy);\n+        t.addNotExpectedDynamicService(\"R4_MyProvider\", \"Algo\",\n+                List.of(\"Alias\"), legacy);\n+    }\n+\n+    private static void testAliases(TestExecutor t) throws Throwable {\n+        aliasesCommon(t, false);\n+    }\n+\n+    private static void testAliasesLegacy(TestExecutor t) throws Throwable {\n+        aliasesCommon(t, true);\n+    }\n+\n+    private static void testAliasesUnregistered(TestExecutor t)\n+            throws Throwable {\n+        aliasesCommon(t, null);\n+    }\n+\n+    \/*\n+     * Invalid filters (must throw an exception)\n+     *\/\n+\n+    private static void testWhitespacesOnlyInFilter(TestExecutor t)\n+            throws Throwable {\n+        t.setFilter(\"\\t\\t\\t\", TestExecutor.FilterPropertyType.SYSTEM);\n+        t.addExpectedFilterException(\"\\t\\t\\t\", 17);\n+    }\n+\n+    private static void testWhitespacesOnlyInRule(TestExecutor t) {\n+        t.setFilter(\"*;    ;\");\n+        t.addExpectedFilterException(\"*;    ;\", 21);\n+    }\n+\n+    private static void testDenyOnly(TestExecutor t) {\n+        t.setFilter(\"!\");\n+        t.addExpectedFilterException(\"!\", 15);\n+    }\n+\n+    private static void testTooManyLevels(TestExecutor t) {\n+        t.setFilter(\"*.*.*.*\");\n+        t.addExpectedFilterException(\"*.*.*.*\", 20);\n+    }\n+\n+    private static void testMissingSecurityProvider(TestExecutor t) {\n+        t.setFilter(\".*.*\");\n+        t.addExpectedFilterException(\".*.*\", 15);\n+    }\n+\n+    private static void testDenyMissingSecurityProvider(TestExecutor t) {\n+        t.setFilter(\"!.*\");\n+        t.addExpectedFilterException(\"!.*\", 16);\n+    }\n+\n+    private static void testMissingServiceType(TestExecutor t) {\n+        t.setFilter(\"*.\");\n+        t.addExpectedFilterException(\"*.\", 16);\n+    }\n+\n+    private static void testMissingServiceType2(TestExecutor t) {\n+        t.setFilter(\"*..*\");\n+        t.addExpectedFilterException(\"*..*\", 17);\n+    }\n+\n+    private static void testMissingAlgorithm(TestExecutor t) {\n+        t.setFilter(\"*.*.\");\n+        t.addExpectedFilterException(\"*.*.\", 18);\n+    }\n+\n+    private static void testUnescapedSpaceInProvider(TestExecutor t) {\n+        t.setFilter(\"My Provider\");\n+        t.addExpectedFilterException(\"My Provider\", 18);\n+    }\n+\n+    private static void testUnescapedSpaceInServiceType(TestExecutor t) {\n+        t.setFilter(\"MyProvider. MyService\");\n+        t.addExpectedFilterException(\"MyProvider. MyService\", 26);\n+    }\n+\n+    private static void testUnescapedExclamationMark(TestExecutor t) {\n+        t.setFilter(\"My!Provider\");\n+        t.addExpectedFilterException(\"My!Provider\", 17);\n+    }\n+\n+    private static void testUnescapedColonInProvider(TestExecutor t) {\n+        t.setFilter(\"My:Provider\");\n+        t.addExpectedFilterException(\"My:Provider\", 17);\n+    }\n+\n+    private static void testUnescapedCommaInProvider(TestExecutor t) {\n+        t.setFilter(\"My,Provider\");\n+        t.addExpectedFilterException(\"My,Provider\", 17);\n+    }\n+\n+    private static void testFilterEndsInEscape(TestExecutor t) {\n+        t.setFilter(\"\\\\\");\n+        t.addExpectedFilterException(\"\\\\\", 15);\n+    }\n+\n+    private static void testProviderEndsInEscape(TestExecutor t) {\n+        t.setFilter(\"MyProvider\\\\\");\n+        t.addExpectedFilterException(\"MyProvider\\\\\", 25);\n+    }\n+\n+    private static void testParserExceptionLineMoreRight(TestExecutor t) {\n+        t.setFilter(\".\" + \";\".repeat(FILTER_EXCEPTION_MAX_LINE + 10));\n+        t.addExpectedFilterException(\".\" + \";\".repeat(\n+                FILTER_EXCEPTION_MAX_LINE - FILTER_EXCEPTION_HDR.length() - 1\n+                        - FILTER_EXCEPTION_MORE.length() - 1) + \" \" +\n+                FILTER_EXCEPTION_MORE, 15);\n+    }\n+\n+    private static void testParserExceptionLineMoreLeft(TestExecutor t) {\n+        t.setFilter(\"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10) + \"!\");\n+        t.addExpectedFilterException(FILTER_EXCEPTION_MORE + \" \" + \"*\".repeat(\n+                FILTER_EXCEPTION_MAX_LINE - FILTER_EXCEPTION_HDR.length() - 1\n+                        - FILTER_EXCEPTION_MORE.length() - 1) + \"!\", 76);\n+    }\n+\n+    private static void testParserExceptionLineMoreBoth(TestExecutor t) {\n+        t.setFilter(\"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10) + \"!\" +\n+                \"*\".repeat(FILTER_EXCEPTION_MAX_LINE + 10));\n+        float halfWildcards = (FILTER_EXCEPTION_MAX_LINE -\n+                FILTER_EXCEPTION_HDR.length() - (FILTER_EXCEPTION_MORE.length()\n+                + 1) * 2 - 1) \/ 2.0f;\n+        int preWildcards = (int) halfWildcards;\n+        int postWildcards = (int) (halfWildcards + 0.5f);\n+        t.addExpectedFilterException(FILTER_EXCEPTION_MORE + \" \" + \"*\".repeat(\n+                preWildcards) + \"!\" + \"*\".repeat(postWildcards) + \" \" +\n+                FILTER_EXCEPTION_MORE, 45);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/ProvidersFilterTest.java","additions":1077,"deletions":0,"binary":false,"changes":1077,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.util.Iterator;\n@@ -28,1 +29,1 @@\n- * @bug 6994753 7123582 8305950 8281658 8310201 8311653 8343804\n+ * @bug 6994753 7123582 8305950 8281658 8310201 8311653 8343804 8315487\n@@ -67,0 +68,22 @@\n+    static void checkServicesAllowed(TestResult tr, boolean servicesAllowed) {\n+        String noneSvcHdr = \"Provider services \" + (servicesAllowed ?\n+                \"NOT \" : \"\") + \"allowed: (type : algorithm)\";\n+        String errorMsg = \"Expected header '\" + noneSvcHdr + \"' not found\";\n+        Iterator<String> oi = tr.testOutput.iterator();\n+        while (oi.hasNext()) {\n+            if (oi.next().contains(noneSvcHdr)) {\n+                if (oi.next().contains(\"<none>\")) {\n+                    errorMsg = null;\n+                } else {\n+                    errorMsg = \"Unexpected services listed under '\" +\n+                            noneSvcHdr + \"'\";\n+                    break;\n+                }\n+            }\n+        }\n+        if (errorMsg != null) {\n+            System.out.println(tr);\n+            throw new RuntimeException(errorMsg);\n+        }\n+    }\n+\n@@ -218,2 +241,5 @@\n-    static void runTestOptionSecurityProv() throws IOException {\n-        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:providers\");\n+    static void runTestOptionSecurityProv(boolean servicesAllowed)\n+            throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:providers\",\n+                \"-Djdk.security.providers.filter=\" + (servicesAllowed ? \"\" :\n+                        \"!*\"));\n@@ -228,0 +254,7 @@\n+        \/\/ test services filter information\n+        checkServicesAllowed(tr, servicesAllowed);\n+    }\n+\n+    static void runTestOptionSecurityProv() throws IOException {\n+        runTestOptionSecurityProv(true);\n+        runTestOptionSecurityProv(false);\n","filename":"test\/jdk\/tools\/launcher\/Settings.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"}]}