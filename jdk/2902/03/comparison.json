{"files":[{"patch":"@@ -201,2 +201,5 @@\n-                               int mark, int pos, int lim, int cap,\n-                               int off, MemorySegmentProxy segment)\n+                               int mark, int pos, int lim, int cap, int off,\n+#if[byte]\n+                               FileDescriptor fd, boolean isSync,\n+#end[byte]\n+                               MemorySegmentProxy segment)\n@@ -205,1 +208,5 @@\n-        super(mark, pos, lim, cap, segment);\n+        super(mark, pos, lim, cap,\n+#if[byte]\n+              fd, isSync,\n+#end[byte]\n+              segment);\n@@ -213,1 +220,5 @@\n-        super(db, mark, pos, lim, cap, off, segment);\n+        super(db, mark, pos, lim, cap, off,\n+#if[byte]\n+              fd, isSync,\n+#end[byte]\n+              segment);\n@@ -223,1 +234,1 @@\n-    public $Type$Buffer slice() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} slice() {\n@@ -229,1 +240,11 @@\n-        return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off, segment);\n+        return new Direct$Type$Buffer$RW$$BO$(this,\n+                                              -1,\n+                                              0,\n+                                              rem, \n+                                              rem,\n+                                              off,\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n+                                              segment);\n@@ -233,1 +254,1 @@\n-    public $Type$Buffer slice(int index, int length) {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} slice(int index, int length) {\n@@ -241,0 +262,4 @@\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n@@ -244,1 +269,1 @@\n-    public $Type$Buffer duplicate() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} duplicate() {\n@@ -250,1 +275,6 @@\n-                                              0, segment);\n+                                              0,\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n+                                              segment);\n@@ -260,1 +290,6 @@\n-                                           0, segment);\n+                                           0,\n+#if[byte]\n+                                           fileDescriptor(),\n+                                           isSync(),\n+#end[byte]\n+                                           segment);\n@@ -509,1 +544,1 @@\n-    public $Type$Buffer compact() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} compact() {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":46,"deletions":11,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    private boolean isSync() {\n+    final boolean isSync() { \/\/ package-private\n@@ -158,0 +158,10 @@\n+    \/**\n+     * Returns the {@code FileDescriptor} associated with this\n+     * {@code MappedByteBuffer}.\n+     *\n+     * @return the buffer's file descriptor; may be {@code null}\n+     *\/\n+    final FileDescriptor fileDescriptor() { \/\/ package-private\n+        return fd;\n+    }\n+\n@@ -207,1 +217,4 @@\n-     * storage device containing the mapped file.\n+     * storage device containing the mapped file.  The region starts at index\n+     * zero in this buffer and is {@code limit} bytes.  An invocation of this\n+     * method behaves in exactly the same way as the invocation\n+     * {@link force(int,int) force(0,limit())}.\n@@ -356,0 +369,37 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p> Reading bytes into physical memory by invoking {@code load()} on the\n+     * returned buffer, or writing bytes to the storage device by invoking\n+     * {@code force()} on the returned buffer, will only act on the sub-range\n+     * of this buffer that the returned buffer represents, namely\n+     * {@code [position(),limit()]}.\n+     *\/\n+    @Override\n+    public abstract MappedByteBuffer slice();\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p> Reading bytes into physical memory by invoking {@code load()} on the\n+     * returned buffer, or writing bytes to the storage device by invoking\n+     * {@code force()} on the returned buffer, will only act on the sub-range\n+     * of this buffer that the returned buffer represents, namely\n+     * {@code [index,index+length)}, where {@code index} and {@code length} are\n+     * assumed to satisfy the preconditions.\n+     *\/\n+    @Override\n+    public abstract MappedByteBuffer slice(int index, int length);\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public abstract MappedByteBuffer duplicate();\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public abstract MappedByteBuffer compact();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4833719\n+ * @summary Verify MappedByteBuffer force on compact, duplicate, and slice views\n+ * @run testng ForceViews\n+ *\/\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.ReadOnlyBufferException;\n+import java.nio.channels.FileChannel;\n+import static java.nio.channels.FileChannel.MapMode.*;\n+import java.nio.file.Path;\n+import static java.nio.file.StandardOpenOption.*;\n+import java.util.function.BiFunction;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class ForceViews {\n+\n+    static record Segment(int position, int length) {}\n+\n+    private FileChannel fc;\n+\n+    @BeforeTest(alwaysRun=true)\n+    public void openChannel() throws IOException {\n+        Path file = Path.of(System.getProperty(\"test.src\", \".\"), \"junk\");\n+        fc = FileChannel.open(file, CREATE_NEW, READ, WRITE, DELETE_ON_CLOSE);\n+        ByteBuffer buf = ByteBuffer.wrap(new byte[1024]);\n+        fc.write(buf);\n+        fc.position(0);\n+    }\n+\n+    @AfterTest(alwaysRun=true)\n+    public void closeChannel() throws IOException {\n+        fc.close();\n+    }\n+\n+    @DataProvider\n+    public Object[][] provider() throws IOException {\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> absSlice =\n+            (m, s) -> { return m.slice(s.position, s.length); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> relSlice =\n+            (m, s) -> { m.position(s.position); m.limit(s.position + s.length);\n+                        return m.slice(); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> duplicate=\n+            (m, s) -> { return m.duplicate(); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> compact =\n+            (m, s) -> { return m.compact(); };\n+\n+        Object[][] result = new Object[][] {\n+            {\"Absolute slice\", fc, 256, 512, 128, 128, 32, 32, absSlice},\n+            {\"Relative slice\", fc, 256, 512, 0, 128, 32, 32, relSlice},\n+            {\"Duplicate\", fc, 256, 512, 0, 256, 32, 32, duplicate},\n+            {\"Compact\", fc, 256, 512, 0, 256, 32, 32, compact}\n+        };\n+\n+        return result;\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void test(String tst, FileChannel fc, int mapPosition, int mapLength,\n+        int sliceIndex, int sliceLength, int regionOffset, int regionLength,\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> f)\n+        throws Exception {\n+        MappedByteBuffer mbb = fc.map(READ_WRITE, mapPosition, mapLength);\n+        mbb = f.apply(mbb, new Segment(sliceIndex, sliceLength));\n+        for (int i = regionOffset; i < regionOffset + regionLength; i++) {\n+            mbb.put(i, (byte)i);\n+        }\n+        mbb.force(regionOffset, regionOffset + regionLength);\n+\n+        int fcPos = mapPosition + sliceIndex + regionOffset;\n+        int mbbPos = regionOffset;\n+        int length = regionLength;\n+\n+        ByteBuffer buf = ByteBuffer.allocate(length);\n+        fc.position(fcPos);\n+        fc.read(buf);\n+        for (int i = 0; i < length; i++) {\n+            int fcVal = buf.get(i);\n+            int mbbVal = mbb.get(mbbPos + i);\n+            int val = regionOffset + i;\n+            Assert.assertTrue(fcVal == val && mbbVal == val,\n+                String.format(\"%s: i %d, fcVal %d, mbbVal %d, val %d\",\n+                    tst, i, fcVal, mbbVal, val));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/MappedByteBuffer\/ForceViews.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}