{"files":[{"patch":"@@ -52,1 +52,0 @@\n-import java.util.Collections;\n@@ -281,8 +280,0 @@\n-            if (options.modulePath.isEmpty()) {\n-                \/\/ no --module-path specified - try to set $JAVA_HOME\/jmods if that exists\n-                Path jmods = getDefaultModulePath();\n-                if (jmods != null) {\n-                    options.modulePath.add(jmods);\n-                }\n-            }\n-\n@@ -381,0 +372,22 @@\n+        \/\/ Empty module path not allowed with ALL-MODULE-PATH in --add-modules\n+        if (options.modulePath.isEmpty() && options.addMods.contains(ALL_MODULE_PATH)) {\n+            throw taskHelper.newBadArgs(\"err.all.module.path.empty.mod.path\");\n+        }\n+        ModuleFinder initialFinder = createFinderFromPath(options.modulePath);\n+        boolean isLinkFromRuntime = determineLinkFromRuntime(initialFinder, options.modulePath);\n+        ModuleFinder rootsFinder = isLinkFromRuntime ? ModuleFinder.compose(ModuleFinder.ofSystem(),\n+                                                                            initialFinder) :\n+                                                       initialFinder;\n+        if (rootsFinder.find(\"java.base\").isEmpty()) {\n+            assert !isLinkFromRuntime : \"Expected regular JMODs based link\";\n+            \/\/ External module linked into a custom runtime, but JDK modules\n+            \/\/ not observable on the module path. Add the default module path\n+            \/\/ if that exists. Adding it here is OK, because we limit the set\n+            \/\/ in the ALL-MODULE-PATH case using initialFinder.\n+            Path defModPath = getDefaultModulePath();\n+            if (defModPath != null) {\n+                options.modulePath.add(defModPath);\n+                rootsFinder = createFinderFromPath(options.modulePath);\n+            }\n+        }\n+\n@@ -384,1 +397,16 @@\n-                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of());\n+                \/\/ Apply a module limit for the roots finder if it was otherwise empty.\n+                \/\/ Since we are using the same finder for determining the roots set as\n+                \/\/ for the actual link, we need to apply this trick so as to not\n+                \/\/ include all modules of the JDK plus the extra module path in\n+                \/\/ the roots set.\n+                Set<String> allModsLimits = options.limitMods;\n+                if (options.limitMods.isEmpty()) {\n+                    Set<String> modsLimits = new HashSet<>();\n+                    initialFinder.findAll()\n+                                 .stream()\n+                                 .map(ModuleReference::descriptor)\n+                                 .map(ModuleDescriptor::name)\n+                                 .forEach(mn -> modsLimits.add(mn));\n+                    allModsLimits = modsLimits;\n+                }\n+                ModuleFinder mf = newModuleFinder(rootsFinder, allModsLimits, Set.of(), isLinkFromRuntime);\n@@ -386,5 +414,5 @@\n-                finder.findAll()\n-                      .stream()\n-                      .map(ModuleReference::descriptor)\n-                      .map(ModuleDescriptor::name)\n-                      .forEach(mn -> roots.add(mn));\n+                mf.findAll()\n+                  .stream()\n+                  .map(ModuleReference::descriptor)\n+                  .map(ModuleDescriptor::name)\n+                  .forEach(mn -> roots.add(mn));\n@@ -396,21 +424,1 @@\n-        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n-        if (finder.find(\"java.base\").isEmpty()) {\n-            Path defModPath = getDefaultModulePath();\n-            if (defModPath != null) {\n-                options.modulePath.add(defModPath);\n-            }\n-            finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n-        }\n-\n-        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n-        \/\/ In case of custom modules outside the JDK we may\n-        \/\/ have a non-empty module path, which must not include\n-        \/\/ java.base. If it did, we link using packaged modules from that\n-        \/\/ module path. If the module path does not include java.base, we have\n-        \/\/ the case where we link from the run-time image. In that case, we take\n-        \/\/ the JDK modules from the run-time image (ModuleFinder.ofSystem()).\n-        if (finder.find(\"java.base\").isEmpty()) {\n-            isLinkFromRuntime = true;\n-            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n-            finder = combinedFinders(runtimeImageFinder, finder, options.limitMods, roots);\n-        }\n+        ModuleFinder finder = newModuleFinder(rootsFinder, options.limitMods, roots, isLinkFromRuntime);\n@@ -432,10 +440,3 @@\n-    \/**\n-     * Creates a combined module finder of {@code finder} and\n-     * {@code runtimeImageFinder} that first looks-up modules in the\n-     * {@code runtimeImageFinder} and if not present in {@code finder}.\n-     *\n-     * @param runtimeImageFinder A system modules finder.\n-     * @param finder A module finder based on packaged modules.\n-     * @param limitMods The set of limited modules for the resulting\n-     *                  finder (if any).\n-     * @param roots All module roots.\n+    \/*\n+     * Determine whether or not JDK modules should be resolved from the run-time\n+     * image.\n@@ -443,2 +444,3 @@\n-     * @return A combined finder, or the input finder, potentially applying\n-     *         module limits.\n+     * @return {@code false} if JMODs including java.base are present on the\n+     *         module path or in the default module path ('jmods'). {@code true}\n+     *         otherwise.\n@@ -446,21 +448,18 @@\n-    private ModuleFinder combinedFinders(ModuleFinder runtimeImageFinder,\n-                                         ModuleFinder finder,\n-                                         Set<String> limitMods,\n-                                         Set<String> roots) {\n-        ModuleFinder combined = new ModuleFinder() {\n-\n-            @Override\n-            public Optional<ModuleReference> find(String name) {\n-                Optional<ModuleReference> mref = runtimeImageFinder.find(name);\n-                if (mref.isEmpty()) {\n-                    return finder.find(name);\n-                }\n-                return mref;\n-            }\n-\n-            @Override\n-            public Set<ModuleReference> findAll() {\n-                Set<ModuleReference> all = new HashSet<>();\n-                all.addAll(runtimeImageFinder.findAll());\n-                all.addAll(finder.findAll());\n-                return Collections.unmodifiableSet(all);\n+    private static boolean determineLinkFromRuntime(ModuleFinder initialFinder,\n+                                                    List<Path> modulePath) {\n+        boolean linkFromRuntime = false;\n+        if (!initialFinder.find(\"java.base\").isPresent()) {\n+            \/\/ If the initial finder doesn't contain the java.base module\n+            \/\/ we have one of two cases:\n+            \/\/ 1. A custom module is being linked into a runtime, but the JDK\n+            \/\/    modules have not been provided.\n+            \/\/ 2. We have a run-time image based link.\n+            \/\/\n+            \/\/ Distinguish case 2 by adding the default 'jmods' folder and try\n+            \/\/ the look-up again. For case 1 this will now find java.base, but\n+            \/\/ not for case 2, since the jmods folder is not there or doesn't\n+            \/\/ include the java.base module.\n+            List<Path> pathCopy = new ArrayList<>(modulePath);\n+            Path defaultPath = getDefaultModulePath();\n+            if (defaultPath != null) {\n+                pathCopy.add(defaultPath);\n@@ -468,4 +467,2 @@\n-        };\n-        \/\/ if limitmods is specified then limit the universe\n-        if (limitMods != null && !limitMods.isEmpty()) {\n-            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n+            ModuleFinder finder = createFinderFromPath(pathCopy);\n+            linkFromRuntime = !finder.find(\"java.base\").isPresent();\n@@ -473,1 +470,10 @@\n-        return combined;\n+        return linkFromRuntime;\n+    }\n+\n+    \/*\n+     * Creates a ModuleFinder for the given module paths.\n+     *\/\n+    public static ModuleFinder createFinderFromPath(List<Path> paths) {\n+        Runtime.Version version = Runtime.version();\n+        Path[] entries = paths.toArray(new Path[0]);\n+        return ModulePath.of(version, true, entries);\n@@ -513,4 +519,4 @@\n-     * Returns a module finder of the given module path or the system modules\n-     * if the module path is empty that limits the observable modules to those\n-     * in the transitive closure of the modules specified in {@code limitMods}\n-     * plus other modules specified in the {@code roots} set.\n+     * Returns a module finder of the given module finder that limits the\n+     * observable modules to those in the transitive closure of the modules\n+     * specified in {@code limitMods} plus other modules specified in the\n+     * {@code roots} set.\n@@ -519,1 +525,2 @@\n-     * but its descriptor has no version\n+     * but its descriptor has no version or the java.base version is not the\n+     * same as the current runtime.\n@@ -521,1 +528,1 @@\n-    public static ModuleFinder newModuleFinder(List<Path> paths,\n+    public static ModuleFinder newModuleFinder(ModuleFinder original,\n@@ -523,1 +530,2 @@\n-                                               Set<String> roots)\n+                                               Set<String> roots,\n+                                               boolean isRuntimeLink)\n@@ -526,4 +534,2 @@\n-        Path[] entries = paths.toArray(new Path[0]);\n-        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n-                                              : ModulePath.of(version, true, entries);\n-        if (finder.find(\"java.base\").isPresent()) {\n+        ModuleFinder finder = original;\n+        if (!isRuntimeLink && finder.find(\"java.base\").isPresent()) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":91,"deletions":85,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+err.all.module.path.empty.mod.path=ALL-MODULE-PATH requires --module-path option\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import tests.Helper;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @summary Test ALL-MODULE-PATH option\n+ * @bug 8345259 8345573\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @run main\/othervm -Xmx1g AllModulePathTest\n+ *\/\n+public class AllModulePathTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jlink tool not found\")\n+        );\n+\n+    private final Helper helper;\n+\n+    public AllModulePathTest(Helper helper) {\n+        this.helper = helper;\n+    }\n+\n+    private void noModulePath() {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-no-mod-path\");\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"ALL-MODULE-PATH requires --module-path option\");\n+    }\n+\n+    private void modulePathWithLimitMods() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mods-limit-mods\");\n+        String moduleName = \"com.baz.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--limit-modules\", \"jdk.jfr\", \/\/ A dependency of com.baz.runtime\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.shouldBeEmpty();\n+        List<String> expected = List.of(\"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    private void modulePath() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-w-mod-path\");\n+        String moduleName = \"com.foo.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString(),\n+                                       \"--verbose\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stderrShouldBeEmpty();\n+        analyzer.stdoutShouldContain(moduleName);\n+        analyzer.stdoutShouldContain(\"java.base\");\n+        analyzer.stdoutShouldContain(\"jdk.jfr\");\n+        \/\/ Verify the output image's modules\n+        List<String> expected = List.of(moduleName, \"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    private void verifyListModules(Path targetPath, List<String> expected) throws Exception {\n+        String jlink = \"java\" + (Platform.isWindows() ? \".exe\" : \"\");\n+        Path javaExe = targetPath.resolve(Path.of(\"bin\"), Path.of(jlink));\n+        List<String> listMods = List.of(javaExe.toString(), \"--list-modules\");\n+        OutputAnalyzer out = ProcessTools.executeCommand(listMods.toArray(new String[] {}));\n+        if (out.getExitValue() != 0) {\n+            throw new AssertionError(\"java --list-modules failed\");\n+        }\n+        List<String> actual = Stream.of(out.getStdout().split(Pattern.quote(System.lineSeparator())))\n+                                    .map(s -> { return s.split(\"@\")[0]; })\n+                                    .sorted()\n+                                    .toList();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected list of modules: \" + actual + \" expected: \" + expected);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean linkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+        Helper helper = Helper.newHelper(linkableRuntime);\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        AllModulePathTest test = new AllModulePathTest(helper);\n+        test.noModulePath();\n+        test.modulePath();\n+        test.modulePathWithLimitMods();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/AllModulePathTest.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -157,0 +157,1 @@\n+        boolean linkFromRuntime = false;\n@@ -159,1 +160,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, false, false);\n+                JlinkTask.newModuleFinder(JlinkTask.createFinderFromPath(modulePaths), limits, mods, linkFromRuntime), linkFromRuntime, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static jdk.test.lib.process.ProcessTools.executeProcess;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -36,3 +39,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n-import static jdk.test.lib.process.ProcessTools.*;\n-\n@@ -41,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -45,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -47,1 +49,1 @@\n- * @modules jdk.compiler jdk.jlink\n+ * @modules jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -50,1 +52,1 @@\n- * @run testng BindServices\n+ * @run testng\/othervm BindServices\n@@ -59,0 +61,2 @@\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n@@ -60,3 +64,3 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-            File.pathSeparator + MODS_DIR.toString();\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                                 MODS_DIR.toString();\n@@ -68,4 +72,6 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n@@ -81,1 +87,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -92,1 +98,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -106,1 +112,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -125,1 +131,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -156,1 +162,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/BindServices.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n@@ -35,1 +38,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n@@ -39,1 +41,3 @@\n-import static org.testng.Assert.*;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -43,1 +47,1 @@\n- * @bug 8174826\n+ * @bug 8174826 8345573\n@@ -45,1 +49,1 @@\n- * @modules jdk.charsets jdk.compiler jdk.jlink\n+ * @modules jdk.charsets jdk.compiler jdk.jlink\/jdk.tools.jlink.internal\n@@ -57,3 +61,6 @@\n-    private static final String MODULE_PATH =\n-        Paths.get(JAVA_HOME, \"jmods\").toString() +\n-        File.pathSeparator + MODS_DIR.toString();\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(Paths.get(JAVA_HOME, \"jmods\"));\n+\n+    private static final String MODULE_PATH = (JMODS_EXIST ? Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                                             File.pathSeparator : \"\") +\n+                                              MODS_DIR.toString();\n@@ -65,4 +72,6 @@\n-    private static boolean hasJmods() {\n-        if (!Files.exists(Paths.get(JAVA_HOME, \"jmods\"))) {\n-            System.err.println(\"Test skipped. NO jmods directory\");\n-            return false;\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n@@ -78,1 +87,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -128,1 +137,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -148,1 +157,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -168,1 +177,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -187,1 +196,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -206,1 +215,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -224,1 +233,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -239,1 +248,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -253,1 +262,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n@@ -271,1 +280,1 @@\n-        if (!hasJmods()) return;\n+        if (!isApplicable()) return;\n","filename":"test\/jdk\/tools\/jlink\/bindservices\/SuggestProviders.java","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+            String msg = String.format(\"Expected jlink to %s given a run-time image \" +\n+                                       \"link capable image. Exit code was: %d\",\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}