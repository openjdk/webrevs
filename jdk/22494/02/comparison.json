{"files":[{"patch":"@@ -280,8 +280,0 @@\n-            if (options.modulePath.isEmpty()) {\n-                \/\/ no --module-path specified - try to set $JAVA_HOME\/jmods if that exists\n-                Path jmods = getDefaultModulePath();\n-                if (jmods != null) {\n-                    options.modulePath.add(jmods);\n-                }\n-            }\n-\n@@ -380,0 +372,4 @@\n+        \/\/ Empty module path not allowed with ALL-MODULE-PATH in --add-modules\n+        if (options.modulePath.isEmpty() && options.addMods.contains(ALL_MODULE_PATH)) {\n+            throw taskHelper.newBadArgs(\"err.all.module.path.empty.mod.path\");\n+        }\n@@ -389,1 +385,2 @@\n-            \/\/ if that exists.\n+            \/\/ if that exists. Adding it here is OK, because we limit the set\n+            \/\/ in the ALL-MODULE-PATH case using initialFinder.\n@@ -400,1 +397,16 @@\n-                ModuleFinder mf = newModuleFinder(rootsFinder, options.limitMods, Set.of(), isLinkFromRuntime);\n+                \/\/ Apply a module limit for the roots finder if it was otherwise empty.\n+                \/\/ Since we are using the same finder for determining the roots set as\n+                \/\/ for the actual link, we need to apply this trick so as to not\n+                \/\/ include all modules of the JDK plus the extra module path in\n+                \/\/ the roots set.\n+                Set<String> allModsLimits = options.limitMods;\n+                if (options.limitMods.isEmpty()) {\n+                    Set<String> modsLimits = new HashSet<>();\n+                    initialFinder.findAll()\n+                                 .stream()\n+                                 .map(ModuleReference::descriptor)\n+                                 .map(ModuleDescriptor::name)\n+                                 .forEach(mn -> modsLimits.add(mn));\n+                    allModsLimits = modsLimits;\n+                }\n+                ModuleFinder mf = newModuleFinder(rootsFinder, allModsLimits, Set.of(), isLinkFromRuntime);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+err.all.module.path.empty.mod.path=ALL-MODULE-PATH requires --module-path option\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import tests.Helper;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @summary Test ALL-MODULE-PATH option\n+ * @bug 8345259 8345573\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @run main\/othervm -Xmx1g AllModulePathTest\n+ *\/\n+public class AllModulePathTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jlink tool not found\")\n+        );\n+\n+    private final Helper helper;\n+\n+    public AllModulePathTest(Helper helper) {\n+        this.helper = helper;\n+    }\n+\n+    private void noModulePath() {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-no-mod-path\");\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"ALL-MODULE-PATH requires --module-path option\");\n+    }\n+\n+    private void modulePathWithLimitMods() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mods-limit-mods\");\n+        String moduleName = \"com.baz.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--limit-modules\", \"jdk.jfr\", \/\/ A dependency of com.baz.runtime\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.shouldBeEmpty();\n+        List<String> expected = List.of(\"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    private void modulePath() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-w-mod-path\");\n+        String moduleName = \"com.foo.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString(),\n+                                       \"--verbose\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stderrShouldBeEmpty();\n+        analyzer.stdoutShouldContain(moduleName);\n+        analyzer.stdoutShouldContain(\"java.base\");\n+        analyzer.stdoutShouldContain(\"jdk.jfr\");\n+        \/\/ Verify the output image's modules\n+        List<String> expected = List.of(moduleName, \"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    private void verifyListModules(Path targetPath, List<String> expected) throws Exception {\n+        String jlink = \"java\" + (Platform.isWindows() ? \".exe\" : \"\");\n+        Path javaExe = targetPath.resolve(Path.of(\"bin\"), Path.of(jlink));\n+        List<String> listMods = List.of(javaExe.toString(), \"--list-modules\");\n+        OutputAnalyzer out = ProcessTools.executeCommand(listMods.toArray(new String[] {}));\n+        if (out.getExitValue() != 0) {\n+            throw new AssertionError(\"java --list-modules failed\");\n+        }\n+        List<String> actual = Stream.of(out.getStdout().split(Pattern.quote(System.lineSeparator())))\n+                                    .map(s -> { return s.split(\"@\")[0]; })\n+                                    .sorted()\n+                                    .toList();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected list of modules: \" + actual + \" expected: \" + expected);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean linkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+        Helper helper = Helper.newHelper(linkableRuntime);\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        AllModulePathTest test = new AllModulePathTest(helper);\n+        test.noModulePath();\n+        test.modulePath();\n+        test.modulePathWithLimitMods();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/AllModulePathTest.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}