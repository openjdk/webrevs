{"files":[{"patch":"@@ -280,8 +280,0 @@\n-            if (options.modulePath.isEmpty()) {\n-                \/\/ no --module-path specified - try to set $JAVA_HOME\/jmods if that exists\n-                Path jmods = getDefaultModulePath();\n-                if (jmods != null) {\n-                    options.modulePath.add(jmods);\n-                }\n-            }\n-\n@@ -380,0 +372,5 @@\n+        \/\/ Empty module path not allowed with ALL-MODULE-PATH in --add-modules\n+        if (options.addMods.contains(ALL_MODULE_PATH) && options.modulePath.isEmpty()) {\n+            throw taskHelper.newBadArgs(\"err.no.module.path\");\n+        }\n+        List<Path> originalModulePath = new ArrayList<>(options.modulePath);\n@@ -382,0 +379,1 @@\n+\n@@ -422,2 +420,24 @@\n-                ModuleFinder mf = newLimitedFinder(finder, options.limitMods,\n-                                              Set.of());\n+                \/\/ all observable modules in the app module path are roots\n+                Set<String> initialRoots = appModuleFinder.findAll()\n+                        .stream()\n+                        .map(ModuleReference::descriptor)\n+                        .map(ModuleDescriptor::name)\n+                        .collect(Collectors.toSet());\n+\n+                \/\/ Error if no module is found on the app module path\n+                if (initialRoots.isEmpty()) {\n+                    String modPath = originalModulePath.stream()\n+                            .map(a -> a.toString())\n+                            .collect(Collectors.joining(\", \"));\n+                    throw taskHelper.newBadArgs(\"err.empty.module.path\", modPath);\n+                }\n+\n+                \/\/ Use a module finder with limited observability, as determined\n+                \/\/ by initialRoots, to find the observable modules from the\n+                \/\/ application module path (--module-path option) only. We must\n+                \/\/ not include JDK modules from the default module path or the\n+                \/\/ run-time image. Only do this if no --limit-modules has been\n+                \/\/ specified to begin with.\n+                ModuleFinder mf = newLimitedFinder(finder,\n+                                                   options.limitMods.isEmpty() ? initialRoots : options.limitMods,\n+                                                   Set.of());\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -130,1 +130,2 @@\n-err.empty.module.path=empty module path\n+err.no.module.path=--module-path option must be specified with --add-modules ALL-MODULE-PATH\n+err.empty.module.path=No module found in module path ''{0}'' with --add-modules ALL-MODULE-PATH\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.Paths;\n@@ -32,1 +31,0 @@\n-import java.util.Collections;\n@@ -39,1 +37,0 @@\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -41,0 +38,1 @@\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -138,1 +136,1 @@\n-            String imageDir = \"bug8189777-all-module-path\";\n+            String imageDir = \"bug8345259-all-module-path\";\n@@ -142,1 +140,1 @@\n-                    .call().assertSuccess();\n+                    .call().assertFailure();\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,10 +24,2 @@\n-\/*\n- * @test\n- * @summary jlink test of --add-module ALL-MODULE-PATH\n- * @library \/test\/lib\n- * @modules jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- * @run testng AllModulePath\n- *\/\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n@@ -35,0 +27,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -47,0 +40,2 @@\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n@@ -49,4 +44,0 @@\n-import java.util.spi.ToolProvider;\n-\n-import jdk.test.lib.compiler.CompilerUtils;\n-import jdk.test.lib.process.ProcessTools;\n@@ -56,1 +47,0 @@\n-import static org.testng.Assert.*;\n@@ -58,0 +48,20 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import tests.Helper;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @summary jlink test of --add-module ALL-MODULE-PATH\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules jdk.compiler\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US AllModulePath\n+ *\/\n@@ -60,3 +70,5 @@\n-    private final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n-    private final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n-    private final Path MODS = Paths.get(\"mods\");\n+    private static final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n+    private static final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n+    private static final Path MODS = Paths.get(\"mods\");\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(JMODS);\n@@ -70,0 +82,9 @@\n+    private static Helper HELPER;\n+\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -73,1 +94,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -76,0 +97,1 @@\n+        HELPER = Helper.newHelper(LINKABLE_RUNTIME);\n@@ -89,1 +111,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -98,1 +120,2 @@\n-        Files.find(JMODS, 1, (Path p, BasicFileAttributes attr) ->\n+        if (JMODS_EXIST) {\n+            Files.find(JMODS, 1, (Path p, BasicFileAttributes attr) ->\n@@ -100,3 +123,7 @@\n-             .map(p -> JMODS.relativize(p).toString())\n-             .map(n -> n.substring(0, n.length()-5))\n-             .forEach(modules::add);\n+                 .map(p -> JMODS.relativize(p).toString())\n+                 .map(n -> n.substring(0, n.length()-5))\n+                 .forEach(modules::add);\n+        } else {\n+            \/\/ java.base is a dependency of external modules\n+            modules.add(\"java.base\");\n+        }\n@@ -110,1 +137,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -125,1 +152,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -140,1 +167,111 @@\n-     * check the modules linked in the image\n+     * No --module-path with --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    @Test\n+    public void noModulePath() {\n+        if (isExplodedJDKImage()) {\n+            return;\n+        }\n+        Path targetPath = HELPER.createNewImageDir(\"all-mod-path-no-mod-path\");\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc != 0);\n+        String actual = new String(baos.toByteArray()).trim();\n+        assertEquals(actual, \"Error: --module-path option must be specified with --add-modules ALL-MODULE-PATH\");\n+    }\n+\n+    \/*\n+     * --module-path not-exist and --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    @Test\n+    public void modulePathEmpty() {\n+        if (isExplodedJDKImage()) {\n+            return;\n+        }\n+        Path targetPath = HELPER.createNewImageDir(\"all-mod-path-not-existing\");\n+        String strNotExists = \"not-exist\";\n+        Path notExists = Path.of(strNotExists);\n+        if (Files.exists(notExists)) {\n+            throw new RuntimeException(\"Test setup error, path must not exist!\");\n+        }\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", notExists.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc != 0);\n+        String actual = new String(baos.toByteArray()).trim();\n+        assertTrue(actual.startsWith(\"Error: No module found in module path\"));\n+        assertTrue(actual.contains(strNotExists));\n+    }\n+\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with an existing module path and module\n+     * limits applied.\n+     *\/\n+    @Test\n+    public void modulePathWithLimitMods() throws Exception {\n+        if (isExplodedJDKImage()) {\n+            return;\n+        }\n+        Path targetPath = HELPER.createNewImageDir(\"all-mods-limit-mods\");\n+        String moduleName = \"com.baz.runtime\";\n+        Result result = HELPER.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--limit-modules\", \"jdk.jfr\", \/\/ A dependency of com.baz.runtime\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc == 0);\n+        String stdOut = new String(baos.toByteArray());\n+        String stdErr = new String(berrOs.toByteArray());\n+        assertTrue(stdOut.isEmpty());\n+        assertTrue(stdErr.isEmpty());\n+        List<String> expected = List.of(\"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with an existing module-path.\n+     *\/\n+    @Test\n+    public void modulePath() throws Exception {\n+        Path targetPath = HELPER.createNewImageDir(\"all-mod-path-w-mod-path\");\n+        String moduleName = \"com.foo.runtime\";\n+        Result result = HELPER.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString(),\n+                                       \"--verbose\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc == 0);\n+        String stdOut = new String(baos.toByteArray());\n+        String stdErr = new String(berrOs.toByteArray());\n+        assertTrue(stdErr.isEmpty());\n+        assertTrue(stdOut.contains(moduleName));\n+        assertTrue(stdOut.contains(\"java.base\"));\n+        assertTrue(stdOut.contains(\"jdk.jfr\"));\n+        \/\/ Verify the output image's modules\n+        List<String> expected = List.of(moduleName, \"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    \/*\n+     * check the modules linked in the image using m1\/p.ListModules\n@@ -156,0 +293,17 @@\n+    \/*\n+     * Verify linked modules using java --list-modules\n+     *\/\n+    private void verifyListModules(Path targetPath, List<String> expected) throws Exception {\n+        Path java = findTool(targetPath, \"java\");\n+        List<String> listMods = List.of(java.toString(), \"--list-modules\");\n+        OutputAnalyzer out = ProcessTools.executeCommand(listMods.toArray(new String[] {}));\n+        if (out.getExitValue() != 0) {\n+            throw new AssertionError(\"java --list-modules failed\");\n+        }\n+        List<String> actual = Stream.of(out.getStdout().split(Pattern.quote(System.lineSeparator())))\n+                                    .map(s -> { return s.split(\"@\")[0]; })\n+                                    .sorted()\n+                                    .toList();\n+        assertEquals(actual, expected);\n+    }\n+\n@@ -168,1 +322,2 @@\n-        String modulepath = JMODS.toString() + File.pathSeparator + MODS.toString();\n+        String modulepath = (JMODS_EXIST ? JMODS.toString() + File.pathSeparator : \"\")\n+                                + MODS.toString();\n","filename":"test\/jdk\/tools\/jlink\/basic\/AllModulePath.java","additions":183,"deletions":28,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -24,15 +24,0 @@\n-\/*\n- * @test\n- * @summary Basic test of jlink to create jmods and images\n- * @author Andrei Eremeev\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.module\n- *          jdk.jlink\n- *          jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- *        jdk.test.lib.util.JarUtils\n- * @run main BasicTest\n- *\/\n-\n@@ -53,0 +38,1 @@\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -54,0 +40,14 @@\n+\/*\n+ * @test\n+ * @summary Basic test of jlink to create jmods and images\n+ * @author Andrei Eremeev\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.module\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.compiler\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.util.JarUtils\n+ * @run main\/othervm BasicTest\n+ *\/\n@@ -65,8 +65,10 @@\n-    private final String TEST_MODULE = \"test\";\n-    private final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n-    private final Path jdkMods = jdkHome.resolve(\"jmods\");\n-    private final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n-    private final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n-    private final Path classes = Paths.get(\"classes\");\n-    private final Path jmods = Paths.get(\"jmods\");\n-    private final Path jars = Paths.get(\"jars\");\n+    private static final String TEST_MODULE = \"test\";\n+    private static final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n+    private static final Path jdkMods = jdkHome.resolve(\"jmods\");\n+    private static final boolean JMODS_EXIST = Files.exists(jdkMods);\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n+    private static final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n+    private static final Path classes = Paths.get(\"classes\");\n+    private static final Path jmods = Paths.get(\"jmods\");\n+    private static final Path jars = Paths.get(\"jars\");\n@@ -78,0 +80,8 @@\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n+        }\n+        return false;\n+    }\n+\n@@ -79,1 +89,1 @@\n-        if (Files.notExists(jdkMods)) {\n+        if (isExplodedJDKImage()) {\n@@ -149,0 +159,2 @@\n+        String modPathArg = (JMODS_EXIST ? jdkMods + File.pathSeparator : \"\") +\n+                                jmods;\n@@ -150,1 +162,1 @@\n-                \"--module-path\", jdkMods + File.pathSeparator + jmods,\n+                \"--module-path\", modPathArg,\n","filename":"test\/jdk\/tools\/jlink\/basic\/BasicTest.java","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"}]}