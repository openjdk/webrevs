{"files":[{"patch":"@@ -280,8 +280,0 @@\n-            if (options.modulePath.isEmpty()) {\n-                \/\/ no --module-path specified - try to set $JAVA_HOME\/jmods if that exists\n-                Path jmods = getDefaultModulePath();\n-                if (jmods != null) {\n-                    options.modulePath.add(jmods);\n-                }\n-            }\n-\n@@ -380,0 +372,5 @@\n+        \/\/ Empty module path not allowed with ALL-MODULE-PATH in --add-modules\n+        boolean hasAllModulePath = options.addMods.contains(ALL_MODULE_PATH);\n+        if (options.modulePath.isEmpty() && hasAllModulePath) {\n+            throw taskHelper.newBadArgs(\"err.all.module.path.empty.mod.path\");\n+        }\n@@ -381,0 +378,4 @@\n+        if (hasAllModulePath && initialFinder.findAll().isEmpty()) {\n+            \/\/ ALL-MODULE-PATH and empty module paths are an error.\n+            throw taskHelper.newBadArgs(\"err.all.module.path.empty.mod.path\");\n+        }\n@@ -389,1 +390,2 @@\n-            \/\/ if that exists.\n+            \/\/ if that exists. Adding it here is OK, because we limit the set\n+            \/\/ in the ALL-MODULE-PATH case using initialFinder.\n@@ -400,1 +402,16 @@\n-                ModuleFinder mf = newModuleFinder(rootsFinder, options.limitMods, Set.of(), isLinkFromRuntime);\n+                \/\/ Apply a module limit for the roots finder if it was otherwise empty.\n+                \/\/ Since we are using the same finder for determining the roots set as\n+                \/\/ for the actual link, we need to apply this trick so as to not\n+                \/\/ include all modules of the JDK plus the extra module path in\n+                \/\/ the roots set.\n+                Set<String> allModsLimits = options.limitMods;\n+                if (options.limitMods.isEmpty()) {\n+                    Set<String> modsLimits = new HashSet<>();\n+                    initialFinder.findAll()\n+                                 .stream()\n+                                 .map(ModuleReference::descriptor)\n+                                 .map(ModuleDescriptor::name)\n+                                 .forEach(mn -> modsLimits.add(mn));\n+                    allModsLimits = modsLimits;\n+                }\n+                ModuleFinder mf = newModuleFinder(rootsFinder, allModsLimits, Set.of(), isLinkFromRuntime);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+err.all.module.path.empty.mod.path=ALL-MODULE-PATH requires --module-path option (or --module-path does not exist)\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.Paths;\n@@ -32,1 +31,0 @@\n-import java.util.Collections;\n@@ -39,1 +37,0 @@\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -41,0 +38,1 @@\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -138,1 +136,1 @@\n-            String imageDir = \"bug8189777-all-module-path\";\n+            String imageDir = \"bug8345259-all-module-path\";\n@@ -142,1 +140,1 @@\n-                    .call().assertSuccess();\n+                    .call().assertFailure();\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,10 +24,3 @@\n-\/*\n- * @test\n- * @summary jlink test of --add-module ALL-MODULE-PATH\n- * @library \/test\/lib\n- * @modules jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- * @run testng AllModulePath\n- *\/\n+\n+\n+import static org.testng.Assert.assertTrue;\n@@ -47,0 +40,1 @@\n+import java.util.spi.ToolProvider;\n@@ -49,4 +43,0 @@\n-import java.util.spi.ToolProvider;\n-\n-import jdk.test.lib.compiler.CompilerUtils;\n-import jdk.test.lib.process.ProcessTools;\n@@ -56,1 +46,0 @@\n-import static org.testng.Assert.*;\n@@ -58,0 +47,15 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+\n+\/*\n+ * @test\n+ * @summary jlink test of --add-module ALL-MODULE-PATH\n+ * @library \/test\/lib\n+ * @modules jdk.compiler\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ * @run testng\/othervm AllModulePath\n+ *\/\n@@ -60,3 +64,5 @@\n-    private final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n-    private final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n-    private final Path MODS = Paths.get(\"mods\");\n+    private static final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n+    private static final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n+    private static final Path MODS = Paths.get(\"mods\");\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(JMODS);\n@@ -71,0 +77,10 @@\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -73,1 +89,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (!isApplicable()) {\n@@ -89,1 +105,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (!isApplicable()) {\n@@ -98,1 +114,2 @@\n-        Files.find(JMODS, 1, (Path p, BasicFileAttributes attr) ->\n+        if (JMODS_EXIST) {\n+            Files.find(JMODS, 1, (Path p, BasicFileAttributes attr) ->\n@@ -100,3 +117,7 @@\n-             .map(p -> JMODS.relativize(p).toString())\n-             .map(n -> n.substring(0, n.length()-5))\n-             .forEach(modules::add);\n+                 .map(p -> JMODS.relativize(p).toString())\n+                 .map(n -> n.substring(0, n.length()-5))\n+                 .forEach(modules::add);\n+        } else {\n+            \/\/ java.base is a dependency of external modules\n+            modules.add(\"java.base\");\n+        }\n@@ -110,1 +131,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (!isApplicable()) {\n@@ -125,1 +146,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (!isApplicable()) {\n@@ -168,1 +189,2 @@\n-        String modulepath = JMODS.toString() + File.pathSeparator + MODS.toString();\n+        String modulepath = (JMODS_EXIST ? JMODS.toString() + File.pathSeparator : \"\")\n+                                + MODS.toString();\n","filename":"test\/jdk\/tools\/jlink\/basic\/AllModulePath.java","additions":49,"deletions":27,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import tests.Helper;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @summary Test ALL-MODULE-PATH option\n+ * @bug 8345259 8345573\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @run main\/othervm -Xmx1g AllModulePathTest\n+ *\/\n+public class AllModulePathTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jlink tool not found\")\n+        );\n+\n+    private final Helper helper;\n+\n+    public AllModulePathTest(Helper helper) {\n+        this.helper = helper;\n+    }\n+\n+    \/*\n+     * No --module-path with --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    private void noModulePath() {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-no-mod-path\");\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc != 0);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"ALL-MODULE-PATH requires --module-path option\");\n+    }\n+\n+    \/*\n+     * --module-path not-exist and --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    private void modulePathEmpty() {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-not-existing\");\n+        Path notExists = Path.of(\"not-exist\");\n+        if (Files.exists(notExists)) {\n+            throw new RuntimeException(\"Test setup error, path must not exist!\");\n+        }\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", notExists.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc != 0);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"ALL-MODULE-PATH requires --module-path option\");\n+    }\n+\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with an existing module path and module\n+     * limits applied.\n+     *\/\n+    private void modulePathWithLimitMods() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mods-limit-mods\");\n+        String moduleName = \"com.baz.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--limit-modules\", \"jdk.jfr\", \/\/ A dependency of com.baz.runtime\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString());\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc == 0);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.shouldBeEmpty();\n+        List<String> expected = List.of(\"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with an existing module-path.\n+     *\/\n+    private void modulePath() throws Exception {\n+        Path targetPath = helper.createNewImageDir(\"all-mod-path-w-mod-path\");\n+        String moduleName = \"com.foo.runtime\";\n+        Result result = helper.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString(),\n+                                       \"--verbose\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, allArgs.toArray(new String[] {}));\n+        assertTrue(rc == 0);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(new String(baos.toByteArray(), StandardCharsets.UTF_8),\n+                                                     new String(berrOs.toByteArray(), StandardCharsets.UTF_8));\n+        analyzer.stderrShouldBeEmpty();\n+        analyzer.stdoutShouldContain(moduleName);\n+        analyzer.stdoutShouldContain(\"java.base\");\n+        analyzer.stdoutShouldContain(\"jdk.jfr\");\n+        \/\/ Verify the output image's modules\n+        List<String> expected = List.of(moduleName, \"java.base\", \"jdk.jfr\");\n+        verifyListModules(targetPath, expected);\n+    }\n+\n+    private static void assertTrue(boolean cond) {\n+        if (!cond) {\n+            throw new AssertionError(\"Expected to be true, was false\");\n+        }\n+    }\n+\n+    private void verifyListModules(Path targetPath, List<String> expected) throws Exception {\n+        String jlink = \"java\" + (Platform.isWindows() ? \".exe\" : \"\");\n+        Path javaExe = targetPath.resolve(Path.of(\"bin\"), Path.of(jlink));\n+        List<String> listMods = List.of(javaExe.toString(), \"--list-modules\");\n+        OutputAnalyzer out = ProcessTools.executeCommand(listMods.toArray(new String[] {}));\n+        if (out.getExitValue() != 0) {\n+            throw new AssertionError(\"java --list-modules failed\");\n+        }\n+        List<String> actual = Stream.of(out.getStdout().split(Pattern.quote(System.lineSeparator())))\n+                                    .map(s -> { return s.split(\"@\")[0]; })\n+                                    .sorted()\n+                                    .toList();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected list of modules: \" + actual + \" expected: \" + expected);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean linkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+        Helper helper = Helper.newHelper(linkableRuntime);\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        AllModulePathTest test = new AllModulePathTest(helper);\n+        test.noModulePath();\n+        test.modulePathEmpty();\n+        test.modulePath();\n+        test.modulePathWithLimitMods();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/basic\/AllModulePathTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -24,15 +24,0 @@\n-\/*\n- * @test\n- * @summary Basic test of jlink to create jmods and images\n- * @author Andrei Eremeev\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.module\n- *          jdk.jlink\n- *          jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- *        jdk.test.lib.util.JarUtils\n- * @run main BasicTest\n- *\/\n-\n@@ -53,0 +38,1 @@\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -54,0 +40,14 @@\n+\/*\n+ * @test\n+ * @summary Basic test of jlink to create jmods and images\n+ * @author Andrei Eremeev\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.module\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.compiler\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.util.JarUtils\n+ * @run main\/othervm BasicTest\n+ *\/\n@@ -65,8 +65,10 @@\n-    private final String TEST_MODULE = \"test\";\n-    private final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n-    private final Path jdkMods = jdkHome.resolve(\"jmods\");\n-    private final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n-    private final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n-    private final Path classes = Paths.get(\"classes\");\n-    private final Path jmods = Paths.get(\"jmods\");\n-    private final Path jars = Paths.get(\"jars\");\n+    private static final String TEST_MODULE = \"test\";\n+    private static final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n+    private static final Path jdkMods = jdkHome.resolve(\"jmods\");\n+    private static final boolean JMODS_EXIST = Files.exists(jdkMods);\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n+    private static final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n+    private static final Path classes = Paths.get(\"classes\");\n+    private static final Path jmods = Paths.get(\"jmods\");\n+    private static final Path jars = Paths.get(\"jars\");\n@@ -78,0 +80,10 @@\n+    private static boolean isApplicable() {\n+        if (!JMODS_EXIST) {\n+            if (!LINKABLE_RUNTIME) {\n+                System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -79,1 +91,1 @@\n-        if (Files.notExists(jdkMods)) {\n+        if (!isApplicable()) {\n@@ -149,0 +161,2 @@\n+        String modPathArg = (JMODS_EXIST ? jdkMods + File.pathSeparator : \"\") +\n+                                jmods;\n@@ -150,1 +164,1 @@\n-                \"--module-path\", jdkMods + File.pathSeparator + jmods,\n+                \"--module-path\", modPathArg,\n","filename":"test\/jdk\/tools\/jlink\/basic\/BasicTest.java","additions":39,"deletions":25,"binary":false,"changes":64,"status":"modified"}]}