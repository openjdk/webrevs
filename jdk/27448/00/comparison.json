{"files":[{"patch":"@@ -219,4 +219,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-    stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::r0_opr, 0);\n@@ -2484,1 +2484,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2492,1 +2491,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, rscratch2);\n@@ -69,1 +69,1 @@\n-  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  str(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -73,1 +73,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, temp, rscratch2, slow_case);\n@@ -79,2 +79,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, rscratch2);\n@@ -83,1 +83,1 @@\n-  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ldr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,4 +58,4 @@\n-  \/\/ hdr     : must be r0, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n-  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n+  \/\/ hdr       : must be r0, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic lock, contents preserved\n+  \/\/ temp      : temporary register, must not be rscratch1 or rscratch2\n@@ -63,1 +63,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n@@ -66,5 +66,5 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be r0 & must point to the displaced header location, contents destroyed\n-  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n-  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be r0 & must point to the basic lock, contents destroyed\n+  \/\/ temp      : temporary register, must not be rscratch1 or rscratch2\n+  void unlock_object(Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1766,3 +1766,0 @@\n-    Label count;\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,3 +203,4 @@\n-  if (_compute_lock) {\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-    stub = new MonitorExitStub(FrameMap::R0_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::R0_opr, 0);\n@@ -2430,1 +2430,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n@@ -183,1 +183,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n+  assert_different_registers(hdr, obj, basic_lock, tmp2);\n@@ -189,1 +189,1 @@\n-  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  str(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -200,3 +200,3 @@\n-  Register t1 = disp_hdr; \/\/ Needs saving, probably\n-  Register t2 = hdr;      \/\/ blow\n-  Register t3 = Rtemp;    \/\/ blow\n+  Register t1 = basic_lock; \/\/ Needs saving, probably\n+  Register t2 = hdr;        \/\/ blow\n+  Register t3 = Rtemp;      \/\/ blow\n@@ -209,2 +209,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, Rtemp);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, Rtemp);\n@@ -215,1 +215,1 @@\n-  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ldr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -217,3 +217,3 @@\n-  Register t1 = disp_hdr; \/\/ Needs saving, probably\n-  Register t2 = hdr;      \/\/ blow\n-  Register t3 = Rtemp;    \/\/ blow\n+  Register t1 = basic_lock; \/\/ Needs saving, probably\n+  Register t2 = hdr;        \/\/ blow\n+  Register t3 = Rtemp;      \/\/ blow\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1132,1 +1132,1 @@\n-  const Register disp_hdr    = altFP_7_11;\n+  const Register basic_lock  = altFP_7_11;\n@@ -1143,1 +1143,1 @@\n-    __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+    __ lightweight_lock(sync_obj \/* object *\/, basic_lock \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n@@ -1258,1 +1258,1 @@\n-    __ mov(R1, disp_hdr);\n+    __ mov(R1, basic_lock);\n@@ -1273,1 +1273,1 @@\n-    assert_different_registers(Rtmp_save1, sync_obj, disp_hdr);\n+    assert_different_registers(Rtmp_save1, sync_obj, basic_lock);\n@@ -1278,1 +1278,1 @@\n-    __ mov(R1, disp_hdr);\n+    __ mov(R1, basic_lock);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -271,3 +271,4 @@\n-  if (_compute_lock) {\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::R4_opr, 0);\n@@ -2617,1 +2617,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2629,1 +2628,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,4 +207,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    stub = new MonitorExitStub(FrameMap::r10_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::r10_opr, 0);\n@@ -1497,1 +1497,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -1504,1 +1503,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, t0, t1);\n@@ -58,1 +58,1 @@\n-  sd(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  sd(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -62,1 +62,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, temp, t1, slow_case);\n@@ -67,2 +67,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, t0, t1);\n@@ -71,1 +71,1 @@\n-  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ld(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,4 +59,4 @@\n-  \/\/ hdr     : must be x10, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n-  \/\/ temp : temporary register, must not be scratch register t0 or t1\n+  \/\/ hdr       : must be x10, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic_lock, contents preserved\n+  \/\/ temp      : temporary register, must not be scratch register t0 or t1\n@@ -64,1 +64,1 @@\n-  int lock_object(Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n+  int lock_object(Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n@@ -67,4 +67,4 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be x10 & must point to the displaced header location, contents destroyed\n-  \/\/ temp : temporary register, must not be scratch register t0 or t1\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be x10 & must point to the basic lock, contents destroyed\n+  \/\/ temp      : temporary register, must not be scratch register t0 or t1\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1682,2 +1682,0 @@\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,6 +237,4 @@\n-  if (_compute_lock) {\n-    \/\/ Lock_reg was destroyed by fast unlocking attempt => recompute it.\n-    ce->monitor_address(_monitor_ix, FrameMap::as_opr(Z_R1_scratch));\n-  } else {\n-    __ lgr_if_needed(Z_R1_scratch, _lock_reg->as_register());\n-  }\n+\n+  \/\/ Lock_reg was destroyed by fast unlocking attempt => recompute it.\n+  ce->monitor_address(_monitor_ix, FrameMap::as_opr(Z_R1_scratch));\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    stub = new MonitorExitStub(lock, true, 0);\n+    stub = new MonitorExitStub(lock, 0);\n@@ -2714,1 +2714,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2722,1 +2721,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,4 +210,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-    stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::rax_opr, 0);\n@@ -2733,1 +2733,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2742,1 +2741,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register tmp, Label& slow_case) {\n@@ -46,1 +46,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp);\n+  assert_different_registers(hdr, obj, basic_lock, tmp);\n@@ -52,1 +52,1 @@\n-  movptr(Address(disp_hdr, BasicObjectLock::obj_offset()), obj);\n+  movptr(Address(basic_lock, BasicObjectLock::obj_offset()), obj);\n@@ -56,1 +56,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, tmp, slow_case);\n@@ -61,3 +61,3 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  assert(disp_hdr == rax, \"disp_hdr must be rax, for the cmpxchg instruction\");\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n+  assert(basic_lock == rax, \"basic_lock must be rax, for the cmpxchg instruction\");\n+  assert(hdr != obj && hdr != basic_lock && obj != basic_lock, \"registers must be different\");\n@@ -66,1 +66,1 @@\n-  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  movptr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -69,1 +69,1 @@\n-  lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n+  lightweight_unlock(obj, rax, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,3 @@\n-  \/\/ hdr     : must be rax, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n+  \/\/ hdr       : must be rax, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic lock, contents preserved\n@@ -53,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register basic_lock, Register tmp, Label& slow_case);\n@@ -56,4 +56,4 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be eax & must point to the displaced header location, contents destroyed\n-  void unlock_object(Register swap, Register obj, Register lock, Label& slow_case);\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be eax & must point to the basic lock, contents destroyed\n+  void unlock_object(Register swap, Register obj, Register basic_lock, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -374,1 +374,0 @@\n-  bool _compute_lock;\n@@ -378,1 +377,1 @@\n-  MonitorExitStub(LIR_Opr lock_reg, bool compute_lock, int monitor_ix)\n+  MonitorExitStub(LIR_Opr lock_reg, int monitor_ix)\n@@ -380,1 +379,1 @@\n-      _compute_lock(compute_lock), _monitor_ix(monitor_ix) { }\n+      _monitor_ix(monitor_ix) { }\n@@ -384,5 +383,1 @@\n-    if (_compute_lock) {\n-      visitor->do_temp(_lock_reg);\n-    } else {\n-      visitor->do_input(_lock_reg);\n-    }\n+    visitor->do_temp(_lock_reg);\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, true, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n+  volatile_nonstatic_field(BasicLock,          _monitor,                               ObjectMonitor*)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    dest->set_bad_metadata_deopt();\n+    dest->set_bad_monitor_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  volatile uintptr_t _metadata;\n+  ObjectMonitor* volatile _monitor;\n@@ -42,3 +42,3 @@\n-  uintptr_t get_metadata() const { return AtomicAccess::load(&_metadata); }\n-  void set_metadata(uintptr_t value) { AtomicAccess::store(&_metadata, value); }\n-  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+  ObjectMonitor* get_monitor() const { return AtomicAccess::load(&_monitor); }\n+  void set_monitor(ObjectMonitor* mon) { AtomicAccess::store(&_monitor, mon); }\n+  static int monitor_offset_in_bytes() { return (int)offset_of(BasicLock, _monitor); }\n@@ -47,1 +47,1 @@\n-  BasicLock() : _metadata(0) {}\n+  BasicLock() : _monitor(nullptr) {}\n@@ -49,3 +49,1 @@\n-  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n-\n-  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+  void set_bad_monitor_deopt() { set_monitor(reinterpret_cast<ObjectMonitor*>(badDispHeaderDeopt)); }\n@@ -56,1 +54,1 @@\n-  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+  static int object_monitor_cache_offset_in_bytes() { return monitor_offset_in_bytes(); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+  return reinterpret_cast<ObjectMonitor*>(get_monitor());\n@@ -39,1 +39,1 @@\n-  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  \/\/ that the monitor either is nullptr or a valid ObjectMonitor*.\n@@ -46,1 +46,1 @@\n-  set_metadata(0);\n+  set_monitor(nullptr);\n@@ -51,1 +51,1 @@\n-  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+  set_monitor(mon);\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1659,1 +1659,1 @@\n-                mon_info->lock()->set_bad_metadata_deopt();\n+                mon_info->lock()->set_bad_monitor_deopt();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    LightweightSynchronizer::enter(obj, lock, current);\n+  LightweightSynchronizer::enter(obj, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n+  volatile_nonstatic_field(BasicLock,          _monitor,                                      ObjectMonitor*)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,6 +154,0 @@\n-  public BasicLock locker() {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(hasLocker(), \"check\");\n-    }\n-    return new BasicLock(valueAsAddress());\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-          initialize(VM.getVM().getTypeDataBase());\n@@ -44,7 +43,0 @@\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type  = db.lookupType(\"BasicLock\");\n-    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n-  }\n-\n-  private static CIntegerField displacedHeaderField;\n-\n@@ -54,4 +46,0 @@\n-\n-  public Mark displacedHeader() {\n-    return new Mark(addr.addOffsetTo(displacedHeaderField.getOffset()));\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}