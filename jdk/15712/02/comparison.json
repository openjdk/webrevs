{"files":[{"patch":"@@ -3819,196 +3819,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-      __ b(count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n-      __ b(count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -16629,1 +16433,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n@@ -16642,1 +16448,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":198,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -48,0 +48,196 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n+    b(count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n+    b(count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,217 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmp1Reg,\n+                                  Register tmp2Reg) {\n+  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n+  Register flag = t1;\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmp1Reg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr, t0);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(flag, oop);\n+    lwu(flag, Address(flag, Klass::access_flags_offset()));\n+    test_bit(flag, flag, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS), tmp \/* tmp *\/);\n+    bnez(flag, cont, true \/* is_far *\/);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  test_bit(t0, disp_hdr, exact_log2(markWord::monitor_value));\n+  bnez(t0, object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+    j(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    ori(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n+            Assembler::rl, \/*result*\/disp_hdr);\n+    mv(flag, zr);\n+    beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    sub(disp_hdr, disp_hdr, sp);\n+    mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n+    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n+    \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n+    \/\/ recursive lock.\n+    andr(tmp\/*==0?*\/, disp_hdr, tmp);\n+    sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n+    j(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+    Label slow;\n+    lightweight_lock(oop, disp_hdr, tmp, t0, slow);\n+\n+    \/\/ Indicate success on completion.\n+    mv(flag, zr);\n+    j(count);\n+    bind(slow);\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+    j(no_count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n+  cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/xthread, Assembler::int64, Assembler::aq,\n+          Assembler::rl, \/*result*\/flag); \/\/ cas succeeds if flag == zr(expected)\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n+    mv(tmp, (address)markWord::unused_mark().value());\n+    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+\n+  beqz(flag, cont); \/\/ CAS success means locking succeeded\n+\n+  bne(flag, xthread, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  mv(flag, zr);\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, t0, tmp);\n+\n+  bind(cont);\n+  \/\/ zero flag indicates success\n+  \/\/ non-zero flag indicates failure\n+  bnez(flag, no_count);\n+\n+  bind(count);\n+  increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmp1Reg,\n+                                    Register tmp2Reg) {\n+  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n+  Register flag = t1;\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmp1Reg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr, flag);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    mv(flag, disp_hdr);\n+    beqz(disp_hdr, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n+  bnez(t0, object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    j(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n+            Assembler::rl, \/*result*\/tmp);\n+    xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n+    j(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+    Label slow;\n+    lightweight_unlock(oop, tmp, box, disp_hdr, slow);\n+\n+    \/\/ Indicate success on completion.\n+    mv(flag, zr);\n+    j(count);\n+    bind(slow);\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    j(no_count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ld(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    test_bit(t0, tmp2, exact_log2(ObjectMonitor::ANONYMOUS_OWNER));\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    bnez(t0, stub->entry(), \/* is_far *\/ true);\n+    bind(stub->continuation());\n+  }\n+\n+  ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n+\n+  \/\/ Recursive lock\n+  addi(disp_hdr, disp_hdr, -1);\n+  sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  mv(flag, zr);\n+  j(cont);\n+\n+  bind(notRecursive);\n+  ld(flag, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(flag, flag, disp_hdr); \/\/ Will be 0 if both are 0.\n+  bnez(flag, cont);\n+  \/\/ need a release store here\n+  la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+  sd(zr, Address(tmp)); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ zero flag indicates success\n+  \/\/ non-zero flag indicates failure\n+  bnez(flag, no_count);\n+\n+  bind(count);\n+  decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":217,"deletions":0,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_riscv.cpp.\n+  void fast_lock(Register object, Register box, Register tmp1, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2439,217 +2439,0 @@\n-  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n-  enc_class riscv_enc_fast_lock(iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register flag = t1;\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp1$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr, t0);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(flag, oop);\n-      __ lwu(flag, Address(flag, Klass::access_flags_offset()));\n-      __ test_bit(flag, flag, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS), tmp \/* tmp *\/);\n-      __ bnez(flag, cont, true \/* is_far *\/);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ test_bit(t0, disp_hdr, exact_log2(markWord::monitor_value));\n-    __ bnez(t0, object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n-      __ j(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n-                 Assembler::rl, \/*result*\/disp_hdr);\n-      __ mv(flag, zr);\n-      __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ sub(disp_hdr, disp_hdr, sp);\n-      __ mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-      \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n-      \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-      \/\/ recursive lock.\n-      __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-      __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n-      __ j(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      Label slow;\n-      __ lightweight_lock(oop, disp_hdr, tmp, t0, slow);\n-\n-      \/\/ Indicate success on completion.\n-      __ mv(flag, zr);\n-      __ j(count);\n-      __ bind(slow);\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n-      __ j(no_count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n-    __ cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/xthread, Assembler::int64, Assembler::aq,\n-             Assembler::rl, \/*result*\/flag); \/\/ cas succeeds if flag == zr(expected)\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n-      __ mv(tmp, (address)markWord::unused_mark().value());\n-      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-\n-    __ beqz(flag, cont); \/\/ CAS success means locking succeeded\n-\n-    __ bne(flag, xthread, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ mv(flag, zr);\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, t0, tmp);\n-\n-    __ bind(cont);\n-    \/\/ zero flag indicates success\n-    \/\/ non-zero flag indicates failure\n-    __ bnez(flag, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n-\n-    __ bind(no_count);\n-  %}\n-\n-  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n-  enc_class riscv_enc_fast_unlock(iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register flag = t1;\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp1$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr, flag);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ mv(flag, disp_hdr);\n-      __ beqz(disp_hdr, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n-    __ bnez(t0, object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n-      __ j(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n-                 Assembler::rl, \/*result*\/tmp);\n-      __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n-      __ j(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      Label slow;\n-      __ lightweight_unlock(oop, tmp, box, disp_hdr, slow);\n-\n-      \/\/ Indicate success on completion.\n-      __ mv(flag, zr);\n-      __ j(count);\n-      __ bind(slow);\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n-      __ j(no_count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ld(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      __ test_bit(t0, tmp2, exact_log2(ObjectMonitor::ANONYMOUS_OWNER));\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ bnez(t0, stub->entry(), \/* is_far *\/ true);\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n-\n-    \/\/ Recursive lock\n-    __ addi(disp_hdr, disp_hdr, -1);\n-    __ sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ mv(flag, zr);\n-    __ j(cont);\n-\n-    __ bind(notRecursive);\n-    __ ld(flag, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(flag, flag, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ bnez(flag, cont);\n-    \/\/ need a release store here\n-    __ la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    __ sd(zr, Address(tmp)); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ zero flag indicates success\n-    \/\/ non-zero flag indicates failure\n-    __ bnez(flag, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -10419,1 +10202,3 @@\n-  ins_encode(riscv_enc_fast_lock(object, box, tmp1, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+  %}\n@@ -10433,1 +10218,3 @@\n-  ins_encode(riscv_enc_fast_unlock(object, box, tmp1, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":219,"binary":false,"changes":225,"status":"modified"}]}