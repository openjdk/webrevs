{"files":[{"patch":"@@ -289,0 +289,1 @@\n+    PhaseIterGVN::add_users_of_use_to_worklist(nn, use, *_igvn_worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-void PhaseIterGVN::add_users_to_worklist0( Node *n ) {\n+void PhaseIterGVN::add_users_to_worklist0(Node* n, Unique_Node_List& worklist) {\n@@ -1454,1 +1454,1 @@\n-    _worklist.push(n->fast_out(i));  \/\/ Push on worklist\n+    worklist.push(n->fast_out(i));  \/\/ Push on worklist\n@@ -1479,2 +1479,2 @@\n-void PhaseIterGVN::add_users_to_worklist( Node *n ) {\n-  add_users_to_worklist0(n);\n+void PhaseIterGVN::add_users_to_worklist(Node *n) {\n+  add_users_to_worklist0(n, _worklist);\n@@ -1482,0 +1482,1 @@\n+  Unique_Node_List& worklist = _worklist;\n@@ -1485,0 +1486,3 @@\n+    add_users_of_use_to_worklist(n, use, worklist);\n+  }\n+}\n@@ -1486,13 +1490,13 @@\n-    if( use->is_Multi() ||      \/\/ Multi-definer?  Push projs on worklist\n-        use->is_Store() )       \/\/ Enable store\/load same address\n-      add_users_to_worklist0(use);\n-\n-    \/\/ If we changed the receiver type to a call, we need to revisit\n-    \/\/ the Catch following the call.  It's looking for a non-null\n-    \/\/ receiver to know when to enable the regular fall-through path\n-    \/\/ in addition to the NullPtrException path.\n-    if (use->is_CallDynamicJava() && n == use->in(TypeFunc::Parms)) {\n-      Node* p = use->as_CallDynamicJava()->proj_out_or_null(TypeFunc::Control);\n-      if (p != nullptr) {\n-        add_users_to_worklist0(p);\n-      }\n+void PhaseIterGVN::add_users_of_use_to_worklist(Node* n, Node* use, Unique_Node_List& worklist) {\n+  if(use->is_Multi() ||      \/\/ Multi-definer?  Push projs on worklist\n+      use->is_Store() )       \/\/ Enable store\/load same address\n+    add_users_to_worklist0(use, worklist);\n+\n+  \/\/ If we changed the receiver type to a call, we need to revisit\n+  \/\/ the Catch following the call.  It's looking for a non-null\n+  \/\/ receiver to know when to enable the regular fall-through path\n+  \/\/ in addition to the NullPtrException path.\n+  if (use->is_CallDynamicJava() && n == use->in(TypeFunc::Parms)) {\n+    Node* p = use->as_CallDynamicJava()->proj_out_or_null(TypeFunc::Control);\n+    if (p != nullptr) {\n+      add_users_to_worklist0(p, worklist);\n@@ -1500,0 +1504,1 @@\n+  }\n@@ -1501,18 +1506,17 @@\n-    uint use_op = use->Opcode();\n-    if(use->is_Cmp()) {       \/\/ Enable CMP\/BOOL optimization\n-      add_users_to_worklist(use); \/\/ Put Bool on worklist\n-      if (use->outcnt() > 0) {\n-        Node* bol = use->raw_out(0);\n-        if (bol->outcnt() > 0) {\n-          Node* iff = bol->raw_out(0);\n-          if (iff->outcnt() == 2) {\n-            \/\/ Look for the 'is_x2logic' pattern: \"x ? : 0 : 1\" and put the\n-            \/\/ phi merging either 0 or 1 onto the worklist\n-            Node* ifproj0 = iff->raw_out(0);\n-            Node* ifproj1 = iff->raw_out(1);\n-            if (ifproj0->outcnt() > 0 && ifproj1->outcnt() > 0) {\n-              Node* region0 = ifproj0->raw_out(0);\n-              Node* region1 = ifproj1->raw_out(0);\n-              if( region0 == region1 )\n-                add_users_to_worklist0(region0);\n-            }\n+  uint use_op = use->Opcode();\n+  if(use->is_Cmp()) {       \/\/ Enable CMP\/BOOL optimization\n+    add_users_to_worklist0(use, worklist); \/\/ Put Bool on worklist\n+    if (use->outcnt() > 0) {\n+      Node* bol = use->raw_out(0);\n+      if (bol->outcnt() > 0) {\n+        Node* iff = bol->raw_out(0);\n+        if (iff->outcnt() == 2) {\n+          \/\/ Look for the 'is_x2logic' pattern: \"x ? : 0 : 1\" and put the\n+          \/\/ phi merging either 0 or 1 onto the worklist\n+          Node* ifproj0 = iff->raw_out(0);\n+          Node* ifproj1 = iff->raw_out(1);\n+          if (ifproj0->outcnt() > 0 && ifproj1->outcnt() > 0) {\n+            Node* region0 = ifproj0->raw_out(0);\n+            Node* region1 = ifproj1->raw_out(0);\n+            if( region0 == region1 )\n+              add_users_to_worklist0(region0, worklist);\n@@ -1522,8 +1526,8 @@\n-      if (use_op == Op_CmpI || use_op == Op_CmpL) {\n-        Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n-        if (phi != nullptr) {\n-          \/\/ Input to the cmp of a loop exit check has changed, thus\n-          \/\/ the loop limit may have changed, which can then change the\n-          \/\/ range values of the trip-count Phi.\n-          _worklist.push(phi);\n-        }\n+    }\n+    if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+      Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n+      if (phi != nullptr) {\n+        \/\/ Input to the cmp of a loop exit check has changed, thus\n+        \/\/ the loop limit may have changed, which can then change the\n+        \/\/ range values of the trip-count Phi.\n+        worklist.push(phi);\n@@ -1531,39 +1535,39 @@\n-      if (use_op == Op_CmpI) {\n-        Node* cmp = use;\n-        Node* in1 = cmp->in(1);\n-        Node* in2 = cmp->in(2);\n-        \/\/ Notify CmpI \/ If pattern from CastIINode::Value (left pattern).\n-        \/\/ Must also notify if in1 is modified and possibly turns into X (right pattern).\n-        \/\/\n-        \/\/ in1  in2                   in1  in2\n-        \/\/  |    |                     |    |\n-        \/\/  +--- | --+                 |    |\n-        \/\/  |    |   |                 |    |\n-        \/\/ CmpINode  |                CmpINode\n-        \/\/    |      |                   |\n-        \/\/ BoolNode  |                BoolNode\n-        \/\/    |      |        OR         |\n-        \/\/  IfNode   |                 IfNode\n-        \/\/    |      |                   |\n-        \/\/  IfProj   |                 IfProj   X\n-        \/\/    |      |                   |      |\n-        \/\/   CastIINode                 CastIINode\n-        \/\/\n-        if (in1 != in2) { \/\/ if they are equal, the CmpI can fold them away\n-          if (in1 == n) {\n-            \/\/ in1 modified -> could turn into X -> do traversal based on right pattern.\n-            for (DUIterator_Fast i2max, i2 = cmp->fast_outs(i2max); i2 < i2max; i2++) {\n-              Node* bol = cmp->fast_out(i2); \/\/ For each Bool\n-              if (bol->is_Bool()) {\n-                for (DUIterator_Fast i3max, i3 = bol->fast_outs(i3max); i3 < i3max; i3++) {\n-                  Node* iff = bol->fast_out(i3); \/\/ For each If\n-                  if (iff->is_If()) {\n-                    for (DUIterator_Fast i4max, i4 = iff->fast_outs(i4max); i4 < i4max; i4++) {\n-                      Node* if_proj = iff->fast_out(i4); \/\/ For each IfProj\n-                      assert(if_proj->is_IfProj(), \"If only has IfTrue and IfFalse as outputs\");\n-                      for (DUIterator_Fast i5max, i5 = if_proj->fast_outs(i5max); i5 < i5max; i5++) {\n-                        Node* castii = if_proj->fast_out(i5); \/\/ For each CastII\n-                        if (castii->is_CastII() &&\n-                            castii->as_CastII()->carry_dependency()) {\n-                          _worklist.push(castii);\n-                        }\n+    }\n+    if (use_op == Op_CmpI) {\n+      Node* cmp = use;\n+      Node* in1 = cmp->in(1);\n+      Node* in2 = cmp->in(2);\n+      \/\/ Notify CmpI \/ If pattern from CastIINode::Value (left pattern).\n+      \/\/ Must also notify if in1 is modified and possibly turns into X (right pattern).\n+      \/\/\n+      \/\/ in1  in2                   in1  in2\n+      \/\/  |    |                     |    |\n+      \/\/  +--- | --+                 |    |\n+      \/\/  |    |   |                 |    |\n+      \/\/ CmpINode  |                CmpINode\n+      \/\/    |      |                   |\n+      \/\/ BoolNode  |                BoolNode\n+      \/\/    |      |        OR         |\n+      \/\/  IfNode   |                 IfNode\n+      \/\/    |      |                   |\n+      \/\/  IfProj   |                 IfProj   X\n+      \/\/    |      |                   |      |\n+      \/\/   CastIINode                 CastIINode\n+      \/\/\n+      if (in1 != in2) { \/\/ if they are equal, the CmpI can fold them away\n+        if (in1 == n) {\n+          \/\/ in1 modified -> could turn into X -> do traversal based on right pattern.\n+          for (DUIterator_Fast i2max, i2 = cmp->fast_outs(i2max); i2 < i2max; i2++) {\n+            Node* bol = cmp->fast_out(i2); \/\/ For each Bool\n+            if (bol->is_Bool()) {\n+              for (DUIterator_Fast i3max, i3 = bol->fast_outs(i3max); i3 < i3max; i3++) {\n+                Node* iff = bol->fast_out(i3); \/\/ For each If\n+                if (iff->is_If()) {\n+                  for (DUIterator_Fast i4max, i4 = iff->fast_outs(i4max); i4 < i4max; i4++) {\n+                    Node* if_proj = iff->fast_out(i4); \/\/ For each IfProj\n+                    assert(if_proj->is_IfProj(), \"If only has IfTrue and IfFalse as outputs\");\n+                    for (DUIterator_Fast i5max, i5 = if_proj->fast_outs(i5max); i5 < i5max; i5++) {\n+                      Node* castii = if_proj->fast_out(i5); \/\/ For each CastII\n+                      if (castii->is_CastII() &&\n+                          castii->as_CastII()->carry_dependency()) {\n+                        worklist.push(castii);\n@@ -1576,14 +1580,14 @@\n-          } else {\n-            \/\/ Only in2 modified -> can assume X == in2 (left pattern).\n-            assert(n == in2, \"only in2 modified\");\n-            \/\/ Find all CastII with input in1.\n-            for (DUIterator_Fast jmax, j = in1->fast_outs(jmax); j < jmax; j++) {\n-              Node* castii = in1->fast_out(j);\n-              if (castii->is_CastII() && castii->as_CastII()->carry_dependency()) {\n-                \/\/ Find If.\n-                if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n-                  Node* ifnode = castii->in(0)->in(0);\n-                  \/\/ Check that if connects to the cmp\n-                  if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == cmp) {\n-                    _worklist.push(castii);\n-                  }\n+          }\n+        } else {\n+          \/\/ Only in2 modified -> can assume X == in2 (left pattern).\n+          assert(n == in2, \"only in2 modified\");\n+          \/\/ Find all CastII with input in1.\n+          for (DUIterator_Fast jmax, j = in1->fast_outs(jmax); j < jmax; j++) {\n+            Node* castii = in1->fast_out(j);\n+            if (castii->is_CastII() && castii->as_CastII()->carry_dependency()) {\n+              \/\/ Find If.\n+              if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n+                Node* ifnode = castii->in(0)->in(0);\n+                \/\/ Check that if connects to the cmp\n+                if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == cmp) {\n+                  worklist.push(castii);\n@@ -1597,0 +1601,1 @@\n+  }\n@@ -1598,21 +1603,9 @@\n-    \/\/ If changed Cast input, notify down for Phi, Sub, and Xor - all do \"uncast\"\n-    \/\/ Patterns:\n-    \/\/ ConstraintCast+ -> Sub\n-    \/\/ ConstraintCast+ -> Phi\n-    \/\/ ConstraintCast+ -> Xor\n-    if (use->is_ConstraintCast()) {\n-      auto push_the_uses_to_worklist = [&](Node* n){\n-        if (n->is_Phi() || n->is_Sub() || n->Opcode() == Op_XorI || n->Opcode() == Op_XorL) {\n-          _worklist.push(n);\n-        }\n-      };\n-      auto is_boundary = [](Node* n){ return !n->is_ConstraintCast(); };\n-      use->visit_uses(push_the_uses_to_worklist, is_boundary);\n-\n-    }\n-    \/\/ If changed LShift inputs, check RShift users for useless sign-ext\n-    if( use_op == Op_LShiftI ) {\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        if (u->Opcode() == Op_RShiftI)\n-          _worklist.push(u);\n+  \/\/ If changed Cast input, notify down for Phi, Sub, and Xor - all do \"uncast\"\n+  \/\/ Patterns:\n+  \/\/ ConstraintCast+ -> Sub\n+  \/\/ ConstraintCast+ -> Phi\n+  \/\/ ConstraintCast+ -> Xor\n+  if (use->is_ConstraintCast()) {\n+    auto push_the_uses_to_worklist = [&](Node* n){\n+      if (n->is_Phi() || n->is_Sub() || n->Opcode() == Op_XorI || n->Opcode() == Op_XorL) {\n+        worklist.push(n);\n@@ -1620,0 +1613,10 @@\n+    };\n+    auto is_boundary = [](Node* n){ return !n->is_ConstraintCast(); };\n+    use->visit_uses(push_the_uses_to_worklist, is_boundary);\n+  }\n+  \/\/ If changed LShift inputs, check RShift users for useless sign-ext\n+  if( use_op == Op_LShiftI ) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_RShiftI)\n+        worklist.push(u);\n@@ -1621,7 +1624,7 @@\n-    \/\/ If changed LShift inputs, check And users for shift and mask (And) operation\n-    if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        if (u->Opcode() == Op_AndI || u->Opcode() == Op_AndL) {\n-          _worklist.push(u);\n-        }\n+  }\n+  \/\/ If changed LShift inputs, check And users for shift and mask (And) operation\n+  if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_AndI || u->Opcode() == Op_AndL) {\n+        worklist.push(u);\n@@ -1630,7 +1633,7 @@\n-    \/\/ If changed AddI\/SubI inputs, check CmpU for range check optimization.\n-    if (use_op == Op_AddI || use_op == Op_SubI) {\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        if (u->is_Cmp() && (u->Opcode() == Op_CmpU)) {\n-          _worklist.push(u);\n-        }\n+  }\n+  \/\/ If changed AddI\/SubI inputs, check CmpU for range check optimization.\n+  if (use_op == Op_AddI || use_op == Op_SubI) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->is_Cmp() && (u->Opcode() == Op_CmpU)) {\n+        worklist.push(u);\n@@ -1639,7 +1642,7 @@\n-    \/\/ If changed AddP inputs, check Stores for loop invariant\n-    if( use_op == Op_AddP ) {\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        if (u->is_Mem())\n-          _worklist.push(u);\n-      }\n+  }\n+  \/\/ If changed AddP inputs, check Stores for loop invariant\n+  if( use_op == Op_AddP ) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->is_Mem())\n+        worklist.push(u);\n@@ -1647,7 +1650,7 @@\n-    \/\/ If changed initialization activity, check dependent Stores\n-    if (use_op == Op_Allocate || use_op == Op_AllocateArray) {\n-      InitializeNode* init = use->as_Allocate()->initialization();\n-      if (init != nullptr) {\n-        Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n-        if (imem != nullptr)  add_users_to_worklist0(imem);\n-      }\n+  }\n+  \/\/ If changed initialization activity, check dependent Stores\n+  if (use_op == Op_Allocate || use_op == Op_AllocateArray) {\n+    InitializeNode* init = use->as_Allocate()->initialization();\n+    if (init != nullptr) {\n+      Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n+      if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n@@ -1655,8 +1658,8 @@\n-    \/\/ If the ValidLengthTest input changes then the fallthrough path out of the AllocateArray may have become dead.\n-    \/\/ CatchNode::Value() is responsible for killing that path. The CatchNode has to be explicitly enqueued for igvn\n-    \/\/ to guarantee the change is not missed.\n-    if (use_op == Op_AllocateArray && n == use->in(AllocateNode::ValidLengthTest)) {\n-      Node* p = use->as_AllocateArray()->proj_out_or_null(TypeFunc::Control);\n-      if (p != nullptr) {\n-        add_users_to_worklist0(p);\n-      }\n+  }\n+  \/\/ If the ValidLengthTest input changes then the fallthrough path out of the AllocateArray may have become dead.\n+  \/\/ CatchNode::Value() is responsible for killing that path. The CatchNode has to be explicitly enqueued for igvn\n+  \/\/ to guarantee the change is not missed.\n+  if (use_op == Op_AllocateArray && n == use->in(AllocateNode::ValidLengthTest)) {\n+    Node* p = use->as_AllocateArray()->proj_out_or_null(TypeFunc::Control);\n+    if (p != nullptr) {\n+      add_users_to_worklist0(p, worklist);\n@@ -1664,0 +1667,1 @@\n+  }\n@@ -1665,22 +1669,21 @@\n-    if (use_op == Op_Initialize) {\n-      Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n-      if (imem != nullptr)  add_users_to_worklist0(imem);\n-    }\n-    \/\/ Loading the java mirror from a Klass requires two loads and the type\n-    \/\/ of the mirror load depends on the type of 'n'. See LoadNode::Value().\n-    \/\/   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))\n-    BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-    bool has_load_barrier_nodes = bs->has_load_barrier_nodes();\n-\n-    if (use_op == Op_LoadP && use->bottom_type()->isa_rawptr()) {\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        const Type* ut = u->bottom_type();\n-        if (u->Opcode() == Op_LoadP && ut->isa_instptr()) {\n-          if (has_load_barrier_nodes) {\n-            \/\/ Search for load barriers behind the load\n-            for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n-              Node* b = u->fast_out(i3);\n-              if (bs->is_gc_barrier_node(b)) {\n-                _worklist.push(b);\n-              }\n+  if (use_op == Op_Initialize) {\n+    Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n+    if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+  }\n+  \/\/ Loading the java mirror from a Klass requires two loads and the type\n+  \/\/ of the mirror load depends on the type of 'n'. See LoadNode::Value().\n+  \/\/   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool has_load_barrier_nodes = bs->has_load_barrier_nodes();\n+\n+  if (use_op == Op_LoadP && use->bottom_type()->isa_rawptr()) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      const Type* ut = u->bottom_type();\n+      if (u->Opcode() == Op_LoadP && ut->isa_instptr()) {\n+        if (has_load_barrier_nodes) {\n+          \/\/ Search for load barriers behind the load\n+          for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n+            Node* b = u->fast_out(i3);\n+            if (bs->is_gc_barrier_node(b)) {\n+              worklist.push(b);\n@@ -1689,1 +1692,0 @@\n-          _worklist.push(u);\n@@ -1691,0 +1693,1 @@\n+        worklist.push(u);\n@@ -1693,6 +1696,6 @@\n-    if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n-      assert(use->outcnt() <= 1, \"OpaqueZeroTripGuard can't be shared\");\n-      if (use->outcnt() == 1) {\n-        Node* cmp = use->unique_out();\n-        _worklist.push(cmp);\n-      }\n+  }\n+  if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+    assert(use->outcnt() <= 1, \"OpaqueZeroTripGuard can't be shared\");\n+    if (use->outcnt() == 1) {\n+      Node* cmp = use->unique_out();\n+      worklist.push(cmp);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":185,"deletions":182,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -531,2 +531,3 @@\n-  void add_users_to_worklist0( Node *n );\n-  void add_users_to_worklist ( Node *n );\n+  static void add_users_to_worklist0(Node* n, Unique_Node_List& worklist);\n+  static void add_users_of_use_to_worklist(Node* n, Node* use, Unique_Node_List& worklist);\n+  void add_users_to_worklist(Node* n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+    uint index_before_clone = C->unique();\n@@ -254,0 +255,3 @@\n+          if (n->_idx < index_before_clone) {\n+            PhaseIterGVN::add_users_of_use_to_worklist(clone, n, *C->igvn_worklist());\n+          }\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8318826\n+ * @summary C2: \"Bad graph detected in build_loop_late\" with incremental inlining\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline -XX:-BackgroundCompilation TestNullAtCallAfterLateInline\n+ *\/\n+\n+\n+public class TestNullAtCallAfterLateInline {\n+    private static final C c = new C();\n+    private static final A a = new A();\n+    private static volatile int volatileField;\n+    private static B b= new B();\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper1(0, true);\n+            testHelper1(1, true);\n+            testHelper1(2, true);\n+            test1(false);\n+            testHelper2(0, true, b);\n+            testHelper2(1, true, c);\n+            testHelper2(2, true, a);\n+            inlined2(null, 3);\n+            test2(false, null);\n+        }\n+    }\n+\n+    private static int test1(boolean flag) {\n+        for (int i = 0; i < 10; i++) {\n+        }\n+        return testHelper1(3, flag);\n+    }\n+\n+    private static int testHelper1(int i, boolean flag) {\n+        int v;\n+        if (flag) {\n+            A a = inlined1(i);\n+            a.notInlined();\n+            v = a.field;\n+        } else {\n+            volatileField = 42;\n+            v = volatileField;\n+        }\n+        return v;\n+    }\n+\n+    private static A inlined1(int i) {\n+        if (i == 0) {\n+            return b;\n+        } else if (i == 1) {\n+            return c;\n+        } else if (i == 2) {\n+            return a;\n+        }\n+        return null;\n+    }\n+\n+    private static int test2(boolean flag, A a) {\n+        for (int i = 0; i < 10; i++) {\n+        }\n+        return testHelper2(3, flag, a);\n+    }\n+\n+    private static int testHelper2(int i, boolean flag, A a) {\n+        int v;\n+        if (flag) {\n+            inlined2(a, i);\n+            a.notInlined();\n+            v = a.field;\n+        } else {\n+            volatileField = 42;\n+            v = volatileField;\n+        }\n+        return v;\n+    }\n+\n+    private static void inlined2(Object a, int i) {\n+        if (i == 0) {\n+            if (!(a instanceof B)) {\n+            }\n+        } else if (i == 1) {\n+            if (!(a instanceof C)) {\n+\n+            }\n+        } else if (i == 2) {\n+            if (!(a instanceof A)) {\n+\n+            }\n+        } else {\n+            if (!(a instanceof D)) {\n+            }\n+        }\n+    }\n+\n+    private static class A {\n+        public int field;\n+\n+        void notInlined() {}\n+    }\n+\n+    private static class B extends A {\n+        void notInlined() {}\n+    }\n+\n+    private static class C extends A {\n+        void notInlined() {}\n+    }\n+\n+    private static class D {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/TestNullAtCallAfterLateInline.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}