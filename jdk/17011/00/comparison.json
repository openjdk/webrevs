{"files":[{"patch":"@@ -226,0 +226,1 @@\n+JVM_VirtualThreadSync\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -600,0 +600,1 @@\n+  do_intrinsic(_notifyJvmtiVThreadSync, java_lang_VirtualThread, notifyJvmtiSync_name, bool_void_signature, F_RN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -422,0 +422,1 @@\n+  template(notifyJvmtiSync_name,                      \"notifyJvmtiSync\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1157,0 +1157,3 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadSync(JNIEnv* env, jobject vthread, jboolean enter);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_critical_section,                       bool))                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -825,0 +825,1 @@\n+  case vmIntrinsics::_notifyJvmtiVThreadSync:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+  case vmIntrinsics::_notifyJvmtiVThreadSync:       return inline_native_notify_jvmti_sync();\n@@ -2953,0 +2954,23 @@\n+\/\/ Always update the is_in_critical_section bit.\n+bool LibraryCallKit::inline_native_notify_jvmti_sync() {\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    return true;\n+  }\n+  IdealKit ideal(this);\n+\n+  {\n+    \/\/ unconditionally update the is_in_critical_section bit in current JavaThread\n+    Node* thread = ideal.thread();\n+    Node* arg = _gvn.transform(argument(1)); \/\/ argument for critical section notification\n+    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_critical_section_offset()));\n+    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n+\n+    sync_kit(ideal);\n+    access_store_at(nullptr, addr, addr_type, arg, _gvn.type(arg), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    ideal.sync_kit(this);\n+  }\n+  final_sync(ideal);\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  bool inline_native_notify_jvmti_sync();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4011,0 +4011,15 @@\n+\/\/ Notification from VirtualThread about entering\/exiting sync critical section.\n+\/\/ Needed to avoid deadlocks with JVMTI suspend mechanism.\n+JVM_ENTRY(void, JVM_VirtualThreadSync(JNIEnv* env, jobject vthread, jboolean enter))\n+#if INCLUDE_JVMTI\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+    return;\n+  }\n+  assert(thread->is_in_critical_section() != (bool)enter, \"sanity check\");\n+  thread->toggle_is_in_critical_section();\n+#else\n+  fatal(\"Should only be called with JVMTI enabled\");\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -490,0 +490,4 @@\n+  if (allow_suspend && _handshakee->is_in_critical_section()) {\n+    \/\/ avoid dealocks between VT critical sections and JVMTI suspend mechanism\n+    allow_suspend = false;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+  _is_in_critical_section(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -320,0 +320,1 @@\n+  bool                  _is_in_critical_section;         \/\/ thread is in a locking critical section\n@@ -650,0 +651,3 @@\n+  bool is_in_critical_section() const            { return _is_in_critical_section; }\n+  void toggle_is_in_critical_section()           { _is_in_critical_section = !_is_in_critical_section; };\n+\n@@ -814,0 +818,1 @@\n+  static ByteSize is_in_critical_section_offset()    { return byte_offset_of(JavaThread, _is_in_critical_section); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,0 +358,1 @@\n+            notifyJvmtiSync(true);\n@@ -364,0 +365,1 @@\n+            notifyJvmtiSync(false);\n@@ -381,0 +383,1 @@\n+        notifyJvmtiSync(true);\n@@ -385,0 +388,1 @@\n+        notifyJvmtiSync(false);\n@@ -741,0 +745,1 @@\n+                notifyJvmtiSync(true);\n@@ -748,0 +753,1 @@\n+                notifyJvmtiSync(false);\n@@ -843,0 +849,1 @@\n+            notifyJvmtiSync(true);\n@@ -854,0 +861,1 @@\n+            notifyJvmtiSync(false);\n@@ -871,0 +879,1 @@\n+            notifyJvmtiSync(true);\n@@ -875,0 +884,1 @@\n+            notifyJvmtiSync(false);\n@@ -896,5 +906,8 @@\n-                \/\/ if mounted then return state of carrier thread\n-                synchronized (carrierThreadAccessLock()) {\n-                    Thread carrierThread = this.carrierThread;\n-                    if (carrierThread != null) {\n-                        return carrierThread.threadState();\n+                notifyJvmtiSync(true);\n+                try {\n+                    \/\/ if mounted then return state of carrier thread\n+                    synchronized (carrierThreadAccessLock()) {\n+                        Thread carrierThread = this.carrierThread;\n+                        if (carrierThread != null) {\n+                            return carrierThread.threadState();\n+                        }\n@@ -902,0 +915,2 @@\n+                } finally {\n+                    notifyJvmtiSync(false);\n@@ -993,0 +1008,1 @@\n+            notifyJvmtiSync(true);\n@@ -1003,0 +1019,1 @@\n+            notifyJvmtiSync(false);\n@@ -1100,0 +1117,3 @@\n+    @IntrinsicCandidate\n+    private native void notifyJvmtiSync(boolean enter);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    { \"notifyJvmtiSync\",         \"(Z)V\", (void *)&JVM_VirtualThreadSync },\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Do not suspend virtual threads in a critical section.\n+ * @bug 8311218\n+ * @requires vm.continuations\n+ * @library \/testlibrary\n+ * @run main\/othervm -Xint SuspendWithInterruptLock\n+ *\/\n+\n+import jvmti.JVMTIUtils;\n+\n+public class SuspendWithInterruptLock {\n+    static boolean done;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread yielder = Thread.ofVirtual().name(\"yielder\").start(() -> yielder());\n+        Thread stateReader = Thread.ofVirtual().name(\"stateReader\").start(() -> stateReader(yielder));\n+        Thread suspender = new Thread(() -> suspender(stateReader));\n+        suspender.start();\n+\n+        yielder.join();\n+        stateReader.join();\n+        suspender.join();\n+    }\n+\n+    static private void yielder() {\n+        int iterations = 100_000;\n+        while (iterations-- > 0) {\n+            Thread.yield();\n+        }\n+        done = true;\n+    }\n+\n+    static private void stateReader(Thread target) {\n+        while (!done) {\n+            target.getState();\n+        }\n+    }\n+\n+    static private void suspender(Thread target) {\n+        while (!done) {\n+            suspendThread(target);\n+            sleep(1);\n+            resumeThread(target);\n+            \/\/ Allow progress\n+            sleep(5);\n+        }\n+    }\n+\n+    static void suspendThread(Thread t) {\n+        try {\n+            JVMTIUtils.suspendThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static void resumeThread(Thread t) {\n+        try {\n+            JVMTIUtils.resumeThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static private void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {}\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendWithInterruptLock\/SuspendWithInterruptLock.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}