{"files":[{"patch":"@@ -226,0 +226,1 @@\n+JVM_VirtualThreadDisableSuspend\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -600,0 +600,1 @@\n+  do_intrinsic(_notifyJvmtiVThreadDisableSuspend, java_lang_VirtualThread, notifyJvmtiDisableSuspend_name, bool_void_signature, F_RN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -424,0 +424,1 @@\n+  template(notifyJvmtiDisableSuspend_name,            \"notifyJvmtiDisableSuspend\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1157,0 +1157,3 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadDisableSuspend(JNIEnv* env, jobject vthread, jboolean enter);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_disable_suspend,                           bool))                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -825,0 +825,1 @@\n+  case vmIntrinsics::_notifyJvmtiVThreadDisableSuspend:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -495,1 +495,2 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadHideFrames: return inline_native_notify_jvmti_hide();\n+  case vmIntrinsics::_notifyJvmtiVThreadHideFrames:     return inline_native_notify_jvmti_hide();\n+  case vmIntrinsics::_notifyJvmtiVThreadDisableSuspend: return inline_native_notify_jvmti_sync();\n@@ -2953,0 +2954,23 @@\n+\/\/ Always update the is_disable_suspend bit.\n+bool LibraryCallKit::inline_native_notify_jvmti_sync() {\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    return true;\n+  }\n+  IdealKit ideal(this);\n+\n+  {\n+    \/\/ unconditionally update the is_disable_suspend bit in current JavaThread\n+    Node* thread = ideal.thread();\n+    Node* arg = _gvn.transform(argument(1)); \/\/ argument for notification\n+    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_disable_suspend_offset()));\n+    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n+\n+    sync_kit(ideal);\n+    access_store_at(nullptr, addr, addr_type, arg, _gvn.type(arg), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    ideal.sync_kit(this);\n+  }\n+  final_sync(ideal);\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  bool inline_native_notify_jvmti_sync();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4011,0 +4011,16 @@\n+\/\/ Notification from VirtualThread about disabling JVMTI Suspend in a sync critical section.\n+\/\/ Needed to avoid deadlocks with JVMTI suspend mechanism.\n+JVM_ENTRY(void, JVM_VirtualThreadDisableSuspend(JNIEnv* env, jobject vthread, jboolean enter))\n+#if INCLUDE_JVMTI\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+    return;\n+  }\n+  assert(thread->is_disable_suspend() != (bool)enter,\n+         \"nested or unbalanced monitor enter\/exit is not allowed\");\n+  thread->toggle_is_disable_suspend();\n+#else\n+  fatal(\"Should only be called with JVMTI enabled\");\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -490,0 +490,4 @@\n+  if (allow_suspend && _handshakee->is_disable_suspend()) {\n+    \/\/ filter out suspend operations while JavaThread is in disable_suspend mode\n+    allow_suspend = false;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+  _is_disable_suspend(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -320,0 +320,1 @@\n+  bool                  _is_disable_suspend;             \/\/ JVMTI suspend is temporarily disabled; used on current thread only\n@@ -650,0 +651,3 @@\n+  bool is_disable_suspend() const                { return _is_disable_suspend; }\n+  void toggle_is_disable_suspend()               { _is_disable_suspend = !_is_disable_suspend; };\n+\n@@ -814,0 +818,1 @@\n+  static ByteSize is_disable_suspend_offset()        { return byte_offset_of(JavaThread, _is_disable_suspend); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -746,4 +746,7 @@\n-                synchronized (carrierThreadAccessLock()) {\n-                    Thread carrier = carrierThread;\n-                    if (carrier != null && ((s = state()) == PINNED || s == TIMED_PINNED)) {\n-                        U.unpark(carrier);\n+                notifyJvmtiDisableSuspend(true);\n+                try {\n+                    synchronized (carrierThreadAccessLock()) {\n+                        Thread carrier = carrierThread;\n+                        if (carrier != null && ((s = state()) == PINNED || s == TIMED_PINNED)) {\n+                            U.unpark(carrier);\n+                        }\n@@ -751,0 +754,2 @@\n+                } finally {\n+                    notifyJvmtiDisableSuspend(false);\n@@ -847,6 +852,8 @@\n-            synchronized (interruptLock) {\n-                interrupted = true;\n-                Interruptible b = nioBlocker;\n-                if (b != null) {\n-                    b.interrupt(this);\n-                }\n+            notifyJvmtiDisableSuspend(true);\n+            try {\n+                synchronized (interruptLock) {\n+                    interrupted = true;\n+                    Interruptible b = nioBlocker;\n+                    if (b != null) {\n+                        b.interrupt(this);\n+                    }\n@@ -854,3 +861,6 @@\n-                \/\/ interrupt carrier thread if mounted\n-                Thread carrier = carrierThread;\n-                if (carrier != null) carrier.setInterrupt();\n+                    \/\/ interrupt carrier thread if mounted\n+                    Thread carrier = carrierThread;\n+                    if (carrier != null) carrier.setInterrupt();\n+                }\n+            } finally {\n+                notifyJvmtiDisableSuspend(false);\n@@ -875,3 +885,8 @@\n-            synchronized (interruptLock) {\n-                interrupted = false;\n-                carrierThread.clearInterrupt();\n+            notifyJvmtiDisableSuspend(true);\n+            try {\n+                synchronized (interruptLock) {\n+                    interrupted = false;\n+                    carrierThread.clearInterrupt();\n+                }\n+            } finally {\n+                notifyJvmtiDisableSuspend(false);\n@@ -902,4 +917,7 @@\n-                synchronized (carrierThreadAccessLock()) {\n-                    Thread carrierThread = this.carrierThread;\n-                    if (carrierThread != null) {\n-                        return carrierThread.threadState();\n+                notifyJvmtiDisableSuspend(true);\n+                try {\n+                    synchronized (carrierThreadAccessLock()) {\n+                        Thread carrierThread = this.carrierThread;\n+                        if (carrierThread != null) {\n+                            return carrierThread.threadState();\n+                        }\n@@ -907,0 +925,2 @@\n+                } finally {\n+                    notifyJvmtiDisableSuspend(false);\n@@ -1022,7 +1042,10 @@\n-            synchronized (carrierThreadAccessLock()) {\n-                carrier = carrierThread;\n-                if (carrier != null) {\n-                    String stateAsString = carrier.threadState().toString();\n-                    sb.append(stateAsString.toLowerCase(Locale.ROOT));\n-                    sb.append('@');\n-                    sb.append(carrier.getName());\n+            notifyJvmtiDisableSuspend(true);\n+            try {\n+                synchronized (carrierThreadAccessLock()) {\n+                    carrier = carrierThread;\n+                    if (carrier != null) {\n+                        String stateAsString = carrier.threadState().toString();\n+                        sb.append(stateAsString.toLowerCase(Locale.ROOT));\n+                        sb.append('@');\n+                        sb.append(carrier.getName());\n+                    }\n@@ -1030,0 +1053,2 @@\n+            } finally {\n+                notifyJvmtiDisableSuspend(false);\n@@ -1128,0 +1153,3 @@\n+    @IntrinsicCandidate\n+    private native void notifyJvmtiDisableSuspend(boolean enter);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":55,"deletions":27,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -35,5 +35,6 @@\n-    { \"notifyJvmtiStart\",        \"()V\",  (void *)&JVM_VirtualThreadStart },\n-    { \"notifyJvmtiEnd\",          \"()V\",  (void *)&JVM_VirtualThreadEnd },\n-    { \"notifyJvmtiMount\",        \"(Z)V\", (void *)&JVM_VirtualThreadMount },\n-    { \"notifyJvmtiUnmount\",      \"(Z)V\", (void *)&JVM_VirtualThreadUnmount },\n-    { \"notifyJvmtiHideFrames\",   \"(Z)V\", (void *)&JVM_VirtualThreadHideFrames },\n+    { \"notifyJvmtiStart\",          \"()V\",  (void *)&JVM_VirtualThreadStart },\n+    { \"notifyJvmtiEnd\",            \"()V\",  (void *)&JVM_VirtualThreadEnd },\n+    { \"notifyJvmtiMount\",          \"(Z)V\", (void *)&JVM_VirtualThreadMount },\n+    { \"notifyJvmtiUnmount\",        \"(Z)V\", (void *)&JVM_VirtualThreadUnmount },\n+    { \"notifyJvmtiHideFrames\",     \"(Z)V\", (void *)&JVM_VirtualThreadHideFrames },\n+    { \"notifyJvmtiDisableSuspend\", \"(Z)V\", (void *)&JVM_VirtualThreadDisableSuspend },\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @summary Do not suspend virtual threads in a critical section.\n+ * @bug 8311218\n+ * @requires vm.continuations\n+ * @library \/testlibrary\n+ * @run main\/othervm SuspendWithInterruptLock\n+ *\/\n+\n+\/**\n+ * @test id=xint\n+ * @summary Do not suspend virtual threads in a critical section.\n+ * @bug 8311218\n+ * @requires vm.continuations\n+ * @library \/testlibrary\n+ * @run main\/othervm -Xint SuspendWithInterruptLock\n+ *\/\n+\n+import jvmti.JVMTIUtils;\n+\n+public class SuspendWithInterruptLock {\n+    static volatile boolean done;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread yielder = Thread.ofVirtual().name(\"yielder\").start(() -> yielder());\n+        Thread stateReader = Thread.ofVirtual().name(\"stateReader\").start(() -> stateReader(yielder));\n+        Thread suspender = new Thread(() -> suspender(stateReader));\n+        suspender.start();\n+\n+        yielder.join();\n+        stateReader.join();\n+        suspender.join();\n+    }\n+\n+    static private void yielder() {\n+        int iterations = 100_000;\n+        while (iterations-- > 0) {\n+            Thread.yield();\n+        }\n+        done = true;\n+    }\n+\n+    static private void stateReader(Thread target) {\n+        while (!done) {\n+            target.getState();\n+        }\n+    }\n+\n+    static private void suspender(Thread target) {\n+        while (!done) {\n+            suspendThread(target);\n+            sleep(1);\n+            resumeThread(target);\n+            \/\/ Allow progress\n+            sleep(5);\n+        }\n+    }\n+\n+    static void suspendThread(Thread t) {\n+        try {\n+            JVMTIUtils.suspendThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static void resumeThread(Thread t) {\n+        try {\n+            JVMTIUtils.resumeThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static private void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {}\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendWithInterruptLock\/SuspendWithInterruptLock.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}