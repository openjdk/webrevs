{"files":[{"patch":"@@ -132,0 +132,7 @@\n+    inline void update_livedata(size_t live) {\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -92,0 +92,11 @@\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n+  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n+  \/\/ us to more quickly replenish free memory with empty regions.\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n+    ShenandoahHeapRegion* r = _region_data[i].get_region();\n+    _region_data[i].update_livedata(r->get_mixed_candidate_live_data_bytes());\n+  }\n+  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n+                              compare_by_live);\n+\n@@ -417,0 +428,2 @@\n+\n+    r->capture_mixed_candidate_garbage();\n@@ -459,0 +472,2 @@\n+\n+      r->capture_mixed_candidate_garbage();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  _mixed_candidate_garbage_words(0),\n@@ -568,0 +569,1 @@\n+  _mixed_candidate_garbage_words = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+\n@@ -262,0 +263,2 @@\n+  size_t _mixed_candidate_garbage_words;\n+\n@@ -401,0 +404,8 @@\n+  inline size_t get_mixed_candidate_live_data_bytes() const;\n+  inline size_t get_mixed_candidate_live_data_words() const;\n+\n+  inline void capture_mixed_candidate_garbage();\n+\n+  \/\/ Returns garbage by calculating difference between used and get_live_data_words.  The value returned is only\n+  \/\/ meaningful immediately following completion of marking.  If there have been subsequent allocations in this region,\n+  \/\/ use a different approach to determine garbage, such as (used() - get_mixed_candidate_live_data_bytes())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -166,0 +166,17 @@\n+inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_bytes() const {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n+  return used() - _mixed_candidate_garbage_words * HeapWordSize;\n+}\n+\n+inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_words() const {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n+  return used() \/ HeapWordSize - _mixed_candidate_garbage_words;\n+}\n+\n+inline void ShenandoahHeapRegion::capture_mixed_candidate_garbage() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _mixed_candidate_garbage_words = garbage() \/ HeapWordSize;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}