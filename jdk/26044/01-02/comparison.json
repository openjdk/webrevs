{"files":[{"patch":"@@ -59,3 +59,1 @@\n-@Fork(value = 1, jvmArgs = {\n-        \"--add-exports\", \"java.base\/jdk.internal.jimage=ALL-UNNAMED\",\n-        \"--add-exports\", \"java.base\/jdk.internal.jrtfs=ALL-UNNAMED\"})\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.jimage=ALL-UNNAMED\"})\n@@ -71,2 +69,3 @@\n-    \/\/\/ NOT a @State since that causes setUp()\/tearDown() to be shared, but we\n-    \/\/\/ want a new copied file every time.\n+    \/\/\/ NOT annotated with `@State` since it needs to potentially be used as a\n+    \/\/\/ per-benchmark or a per-iteration state object. The subclasses provide\n+    \/\/\/ any lifetime annotations that are needed.\n@@ -90,0 +89,16 @@\n+    @State(Scope.Benchmark)\n+    public static class WarmStartWithImageReader extends BaseState {\n+        ImageReader reader;\n+\n+        @Setup(Level.Trial)\n+        public void setUp() throws IOException {\n+            super.setUp();\n+            reader = ImageReader.open(copiedImageFile, byteOrder);\n+        }\n+\n+        @TearDown(Level.Trial)\n+        public void tearDown() throws IOException {\n+            super.tearDown();\n+        }\n+    }\n+\n@@ -123,3 +138,0 @@\n-    \/\/\/\n-    \/\/\/ By running this benchmark first, it should also ensure the later (one shot)\n-    \/\/\/ benchmarks are using hotspot compiled code.\n@@ -128,1 +140,1 @@\n-    public void warmCache_CountAllNodes(ColdStartWithImageReader state) throws IOException {\n+    public void warmCache_CountAllNodes(WarmStartWithImageReader state) throws IOException {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"}]}