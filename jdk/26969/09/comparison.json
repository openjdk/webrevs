{"files":[{"patch":"@@ -129,0 +129,14 @@\n+    \/**\n+     * Default delay in milliseconds for mouse\n+     * {@link #glide(int, int, int, int) glide},\n+     * {@link #type(int) type}, and\n+     * {@link #click(int) click}.\n+     *\/\n+    public static final int DEFAULT_DELAY = 20;\n+\n+    \/**\n+     * Default pixel step-length for mouse\n+     * {@link #glide(int, int, int, int) glide}.\n+     *\/\n+    public static final int DEFAULT_STEP_LENGTH = 2;\n+\n@@ -776,0 +790,213 @@\n+\n+    \/**\n+     * A convenience method that simulates clicking a mouse button by calling {@code mousePress}, {@code mouseRelease},\n+     * and {@code waitForIdle}. Invokes {@code waitForIdle} with a default delay of {@value #DEFAULT_DELAY} milliseconds after\n+     * {@code mousePress} and {@code mouseRelease} calls. For specifics on valid inputs see\n+     * {@link java.awt.Robot#mousePress(int)}.\n+     *\n+     * @param   buttons The button mask; a combination of one or more mouse button masks.\n+     * @throws  IllegalArgumentException if the {@code buttons} mask contains the mask for\n+     *          extra mouse button and support for extended mouse buttons is\n+     *          {@linkplain Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n+     * @throws  IllegalArgumentException if the {@code buttons} mask contains the mask for\n+     *          extra mouse button that does not exist on the mouse and support for extended\n+     *          mouse buttons is {@linkplain Toolkit#areExtraMouseButtonsEnabled() enabled}\n+     *          by Java\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching thread\n+     * @see     #DEFAULT_DELAY\n+     * @see     #mousePress(int)\n+     * @see     #mouseRelease(int)\n+     * @see     InputEvent#getMaskForButton(int)\n+     * @see     Toolkit#areExtraMouseButtonsEnabled()\n+     * @see     java.awt.event.MouseEvent\n+     * @since   26\n+     *\/\n+    public void click(int buttons) {\n+        try {\n+            mousePress(buttons);\n+            waitForIdle(DEFAULT_DELAY);\n+        } finally {\n+            mouseRelease(buttons);\n+            waitForIdle(DEFAULT_DELAY);\n+        }\n+    }\n+\n+    \/**\n+     * A convenience method that clicks mouse button 1.\n+     *\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching thread\n+     * @see     #click(int)\n+     * @since   26\n+     *\/\n+    public void click() {\n+        click(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    \/**\n+     * A convenience method that calls {@code waitForIdle} then waits an additional specified\n+     * {@code delayValue} time in milliseconds.\n+     *\n+     * @param   delayValue  Additional delay length in milliseconds to wait until thread\n+     *                      sync been completed\n+     * @throws  IllegalThreadStateException if called on the AWT event\n+     *          dispatching thread\n+     * @throws  IllegalArgumentException if {@code delayValue} is not between {@code 0}\n+     *          and {@code 60,000} milliseconds inclusive\n+     * @since   26\n+     *\/\n+    public void waitForIdle(int delayValue) {\n+        waitForIdle();\n+        delay(delayValue);\n+    }\n+\n+    \/**\n+     * A convenience method that moves the mouse in multiple\n+     * steps from its current location to the destination coordinates.\n+     *\n+     * @implSpec Invokes {@link #mouseMove(int, int) mouseMove} with a step-length\n+     * of {@value #DEFAULT_STEP_LENGTH} and a step-delay of {@value #DEFAULT_DELAY}.\n+     *\n+     * @param   x   Destination point x coordinate\n+     * @param   y   Destination point y coordinate\n+     *\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching\n+     *          thread and {@code isAutoWaitForIdle} would return true\n+     * @see     #DEFAULT_STEP_LENGTH\n+     * @see     #DEFAULT_DELAY\n+     * @see     #glide(int, int, int, int, int, int)\n+     * @since   26\n+     *\/\n+    public void glide(int x, int y) {\n+        Point p = MouseInfo.getPointerInfo().getLocation();\n+        glide(p.x, p.y, x, y);\n+    }\n+\n+    \/**\n+     * A convenience method that moves the mouse in multiple steps\n+     * from source coordinates to the destination coordinates.\n+     *\n+     * @implSpec Invokes {@link #mouseMove(int, int) mouseMove} with a step-length\n+     * of {@value #DEFAULT_STEP_LENGTH} and a step-delay of {@value #DEFAULT_DELAY}.\n+     *\n+     * @param   srcX   Source point x coordinate\n+     * @param   srcY   Source point y coordinate\n+     * @param   dstX   Destination point x coordinate\n+     * @param   dstY   Destination point y coordinate\n+     *\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching\n+     *          thread and {@code isAutoWaitForIdle} would return true\n+     * @see     #DEFAULT_STEP_LENGTH\n+     * @see     #DEFAULT_DELAY\n+     * @see     #glide(int, int, int, int, int, int)\n+     * @since   26\n+     *\/\n+    public void glide(int srcX, int srcY, int dstX, int dstY) {\n+        glide(srcX, srcY, dstX, dstY, DEFAULT_STEP_LENGTH, DEFAULT_DELAY);\n+    }\n+\n+    \/**\n+     * A convenience method that moves the mouse in multiple\n+     * steps from source point to the destination point with a\n+     * given {@code stepLength} and {@code stepDelay}.\n+     *\n+     * @param   srcX        Source point x coordinate\n+     * @param   srcY        Source point y coordinate\n+     * @param   destX       Destination point x coordinate\n+     * @param   destY       Destination point y coordinate\n+     * @param   stepLength  Preferred length of one step in pixels\n+     * @param   stepDelay   Delay between steps in milliseconds\n+     *\n+     * @throws  IllegalArgumentException if {@code stepLength} is not greater than zero\n+     * @throws  IllegalArgumentException if {@code stepDelay} is not between {@code 0}\n+     *          and {@code 60,000} milliseconds inclusive\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching\n+     *          thread and {@code isAutoWaitForIdle} would return true\n+     * @see     #mouseMove(int, int)\n+     * @see     #delay(int)\n+     * @since   26\n+     *\/\n+    public void glide(int srcX, int srcY, int destX, int destY, int stepLength, int stepDelay) {\n+        if (stepLength <= 0) {\n+            throw new IllegalArgumentException(\"Step length must be greater than zero\");\n+        }\n+        if (stepDelay <= 0 || stepDelay > 60000) {\n+            throw new IllegalArgumentException(\"Step delay must be between 0 and 60,000 milliseconds\");\n+        }\n+\n+        int stepNum;\n+        double tDx, tDy;\n+        double dx, dy, ds;\n+        double x, y;\n+\n+        dx = (destX - srcX);\n+        dy = (destY - srcY);\n+        ds = Math.sqrt(dx*dx + dy*dy);\n+\n+        tDx = dx \/ ds * stepLength;\n+        tDy = dy \/ ds * stepLength;\n+\n+        int stepsCount = (int) ds \/ stepLength;\n+\n+        \/\/ Walk the mouse to the destination one step at a time\n+        mouseMove(srcX, srcY);\n+\n+        for (x = srcX, y = srcY, stepNum = 0;\n+             stepNum < stepsCount;\n+             stepNum++) {\n+            x += tDx;\n+            y += tDy;\n+            mouseMove((int)x, (int)y);\n+            delay(stepDelay);\n+        }\n+\n+        \/\/ Ensure the mouse moves to the right destination.\n+        \/\/ The steps may have led the mouse to a slightly wrong place.\n+        if (x != destX || y != destY) {\n+            mouseMove(destX, destY);\n+        }\n+    }\n+\n+    \/**\n+     * A convenience method that simulates typing a key by calling {@code keyPress}\n+     * and {@code keyRelease}. Invokes {@code waitForIdle} with a delay of {@value #DEFAULT_DELAY} milliseconds\n+     * after {@code keyPress} and {@code keyRelease} calls.\n+     * <p>\n+     * Key codes that have more than one physical key associated with them\n+     * (e.g. {@code KeyEvent.VK_SHIFT} could mean either the\n+     * left or right shift key) will map to the left key.\n+     *\n+     * @param   keycode Key to type (e.g. {@code KeyEvent.VK_A})\n+     * @throws  IllegalArgumentException if {@code keycode} is not\n+     *          a valid key\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching thread\n+     * @see     #DEFAULT_DELAY\n+     * @see     #keyPress(int)\n+     * @see     #keyRelease(int)\n+     * @see     java.awt.event.KeyEvent\n+     * @since   26\n+     *\/\n+    public synchronized void type(int keycode) {\n+        keyPress(keycode);\n+        waitForIdle(DEFAULT_DELAY);\n+        keyRelease(keycode);\n+        waitForIdle(DEFAULT_DELAY);\n+    }\n+\n+    \/**\n+     * A convenience method that simulates typing a char by calling {@code keyPress}\n+     * and {@code keyRelease}. Gets the ExtendedKeyCode for the char and calls\n+     * {@code type(int keycode)}.\n+     *\n+     * @param   c   Character to be typed (e.g. {@code 'a'})\n+     * @throws  IllegalArgumentException if {@code keycode} is not\n+     *          a valid key\n+     * @throws  IllegalThreadStateException if called on the AWT event dispatching thread\n+     * @see     #type(int)\n+     * @see     #keyPress(int)\n+     * @see     #keyRelease(int)\n+     * @see     java.awt.event.KeyEvent\n+     * @since   26\n+     *\/\n+    public synchronized void type(char c) {\n+        type(KeyEvent.getExtendedKeyCodeForChar(c));\n+    }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Robot.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"modified"}]}