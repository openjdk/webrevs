{"files":[{"patch":"@@ -292,1 +292,2 @@\n-     * of locally cached reads.\n+     * of locally cached reads, and include fall-backs for exceptional\n+     * cases including OutOfMemoryErrors and JVM exceptions.\n@@ -1185,2 +1186,1 @@\n-    private void tryInitializeHead() {\n-        Node h = new WriterNode();\n+    private void tryInitializeHead(Node h) {\n@@ -1206,0 +1206,1 @@\n+        long nanos = 0L;\n@@ -1230,1 +1231,5 @@\n-                node = new WriterNode();\n+                try {\n+                    node = new WriterNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return spinLockOnOOME(true, interruptible, timed, time);\n+                }\n@@ -1234,2 +1239,9 @@\n-                if (t == null)\n-                    tryInitializeHead();\n+                if (t == null) {                \/\/ try to initialize\n+                    Node h;\n+                    try {\n+                        h = new WriterNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return spinLockOnOOME(true, interruptible, timed, time);\n+                    }\n+                    tryInitializeHead(h);\n+                }\n@@ -1247,9 +1259,10 @@\n-            } else {\n-                long nanos;\n-                spins = postSpins = (byte)((postSpins << 1) | 1);\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+            } else if (!timed || (nanos = time - System.nanoTime()) > 0L) {\n+                try {\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else\n+                        LockSupport.parkNanos(this, nanos);\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node);\n+                    throw ex;\n+                }\n@@ -1259,1 +1272,3 @@\n-            }\n+                spins = postSpins = (byte)((postSpins << 1) | 1);\n+            } else\n+                break;\n@@ -1261,1 +1276,2 @@\n-        return cancelAcquire(node, interrupted);\n+        cancelAcquire(node);\n+        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1288,2 +1304,9 @@\n-            else if (t == null)\n-                tryInitializeHead();\n+            else if (t == null) {\n+                 Node h;\n+                 try {\n+                     h = new WriterNode();\n+                 } catch (OutOfMemoryError oome) {\n+                     return spinLockOnOOME(false, interruptible, timed, time);\n+                 }\n+                 tryInitializeHead(h);\n+            }\n@@ -1291,2 +1314,7 @@\n-                if (node == null)\n-                    node = new ReaderNode();\n+                if (node == null) {\n+                    try {\n+                        node = new ReaderNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return spinLockOnOOME(false, interruptible, timed, time);\n+                    }\n+                }\n@@ -1305,2 +1333,7 @@\n-                    else if (node == null)\n-                        node = new ReaderNode();\n+                    else if (node == null) {\n+                        try {\n+                            node = new ReaderNode();\n+                        } catch (OutOfMemoryError oome) {\n+                            return spinLockOnOOME(false, interruptible, timed, time);\n+                        }\n+                    }\n@@ -1316,5 +1349,10 @@\n-                        long nanos = 0L;\n-                        if (!timed)\n-                            LockSupport.park(this);\n-                        else if ((nanos = time - System.nanoTime()) > 0L)\n-                            LockSupport.parkNanos(this, nanos);\n+                        long nanos = (timed) ? time - System.nanoTime(): 0L;\n+                        try {\n+                            if (!timed)\n+                                LockSupport.park(this);\n+                            else if (nanos > 0L)\n+                                LockSupport.parkNanos(this, nanos);\n+                        } catch (Error | RuntimeException ex) {\n+                            cancelCowaiter(node, leader);\n+                            throw ex;\n+                        }\n@@ -1323,2 +1361,4 @@\n-                            (timed && nanos <= 0L))\n-                            return cancelCowaiter(node, leader, interrupted);\n+                            (timed && nanos <= 0L)) {\n+                            cancelCowaiter(node, leader);\n+                            return (interrupted) ? INTERRUPTED : 0L;\n+                        }\n@@ -1344,0 +1384,1 @@\n+        long nanos = 0L;\n@@ -1374,9 +1415,10 @@\n-            } else {\n-                long nanos;\n-                spins = postSpins = (byte)((postSpins << 1) | 1);\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+            } else if (!timed || (nanos = time - System.nanoTime()) > 0) {\n+                try {\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else\n+                        LockSupport.parkNanos(this, nanos);\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node);\n+                    throw ex;\n+                }\n@@ -1386,1 +1428,3 @@\n-            }\n+                spins = postSpins = (byte)((postSpins << 1) | 1);\n+            } else\n+                break;\n@@ -1388,1 +1432,2 @@\n-        return cancelAcquire(node, interrupted);\n+        cancelAcquire(node);\n+        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1453,2 +1498,0 @@\n-     * @param interrupted if already interrupted\n-     * @return INTERRUPTED if interrupted or Thread.interrupted, else zero\n@@ -1456,1 +1499,1 @@\n-    private long cancelAcquire(Node node, boolean interrupted) {\n+    private void cancelAcquire(Node node) {\n@@ -1464,1 +1507,0 @@\n-        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n@@ -1473,2 +1515,0 @@\n-     * @param interrupted if already interrupted\n-     * @return INTERRUPTED if interrupted or Thread.interrupted, else zero\n@@ -1476,2 +1516,1 @@\n-    private long cancelCowaiter(ReaderNode node, ReaderNode leader,\n-                                boolean interrupted) {\n+    private void cancelCowaiter(ReaderNode node, ReaderNode leader) {\n@@ -1483,1 +1522,20 @@\n-        return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;\n+    }\n+\n+    \/**\n+     * Fallback upon encountering OutOfMemoryErrors\n+     *\/\n+    private long spinLockOnOOME(boolean write, boolean interruptible,\n+                                boolean timed, long time) {\n+        long startTime = (timed) ? System.nanoTime() : 0L;\n+        for (int spins = 0;;) {\n+            long s =  (write) ? tryAcquireWrite() : tryAcquireRead();\n+            if (s != 0L)\n+                return s;\n+            Thread.onSpinWait();\n+            if ((++spins & (1 << 8)) == 0) {  \/\/ occasionally check\n+                if (interruptible && Thread.interrupted())\n+                    return INTERRUPTED;\n+                if (timed && System.nanoTime() - startTime > time)\n+                    return 0L;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/StampedLock.java","additions":108,"deletions":50,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8066859\n+ * @summary An adaptation of OOMEInAQS test for StampedLocks\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+UseG1GC -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInStampedLock\n+ *\/\n+\n+public class OOMEInStampedLock extends Thread {\n+    static final int NTHREADS = 3;\n+    static final int NREPS = 100;\n+    \/\/ statically allocate\n+    static final StampedLock stampedLock = new StampedLock();\n+    static final Lock wLock = stampedLock.asWriteLock();\n+    static final Lock rLock = stampedLock.asReadLock();\n+    static final CountDownLatch started = new CountDownLatch(1);\n+    static final CountDownLatch filled = new CountDownLatch(1);\n+    static final CountDownLatch canFill = new CountDownLatch(NTHREADS);\n+    static volatile Object data;\n+    static volatile Throwable exception;\n+    static int turn;\n+\n+    \/**\n+     * For each of NTHREADS threads, REPS times: Take turns\n+     * executing. Introduce OOM using fillHeap during runs. In\n+     * addition to testing AQS, the CountDownLatches ensure that\n+     * methods execute at least once before OutOfMemory occurs, to\n+     * avoid uncontrollable impact of OOME during class-loading.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        OOMEInStampedLock[] threads = new OOMEInStampedLock[NTHREADS];\n+        for (int i = 0; i < NTHREADS; ++i)\n+            (threads[i] = new OOMEInStampedLock(i)).start();\n+        started.countDown();\n+        canFill.await();\n+        long t0 = System.nanoTime();\n+        data = fillHeap();\n+        filled.countDown();\n+        long t1 = System.nanoTime();\n+        for (int i = 0; i < NTHREADS; ++i)\n+            threads[i].join();\n+        data = null;  \/\/ free heap before reporting and terminating\n+        System.gc();\n+        Throwable ex = exception;\n+        if (ex != null)\n+            throw ex;\n+        System.out.println(\n+            \"fillHeap time: \" + (t1 - t0) \/ 1000_000 +\n+            \" millis, whole test time: \" + (System.nanoTime() - t0) \/ 1000_000 +\n+            \" millis\"\n+        );\n+    }\n+\n+    final int tid;\n+    OOMEInStampedLock(int tid) {\n+        this.tid = tid;\n+    }\n+\n+    @Override\n+    public void run() {\n+        int id = tid, nextId = (id + 1) % NTHREADS;\n+        final Lock wl = wLock, rl = rLock;\n+        try {\n+            started.await();\n+            for (int i = 0; i < NREPS; i++) {\n+                int t;\n+                rl.lock(); t = turn; rl.unlock();\n+                wl.lock();\n+                try {\n+                    if (turn == t && turn == id)\n+                        turn = nextId;\n+                } finally {\n+                    wl.unlock();\n+                }\n+                if (i == 2) {  \/\/ Subsequent AQS methods encounter OOME\n+                    canFill.countDown();\n+                    filled.await();\n+                }\n+            }\n+            data = null;\n+            System.gc(); \/\/ avoid getting stuck while exiting\n+        } catch (Throwable ex) {\n+            data = null;\n+            System.gc(); \/\/ avoid nested OOME\n+            exception = ex;\n+        }\n+    }\n+\n+    static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}