{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -66,1 +67,2 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(cg_infos[CPU_IDX]._mount_path, cg_infos[CPU_IDX]._cgroup_path);\n@@ -69,1 +71,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu);\n@@ -109,1 +111,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(info._root_mount_path, info._mount_path);\n@@ -478,1 +480,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +486,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController*>* contrl = cpu_controller();\n@@ -492,17 +494,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +512,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController*>* contrl = memory_controller();\n@@ -532,22 +519,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -559,17 +525,45 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == nullptr) {\n-    return OSCONTAINER_ERROR;\n-  }\n-  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n-  \/\/ some controllers, for example the pids controller.\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n-  }\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n-  }\n-  os::free(limit_str);\n-  return (jlong)limit;\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":57,"deletions":63,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+template <class T>\n@@ -251,1 +252,1 @@\n-    CgroupController* _controller;\n+    T _controller;\n@@ -255,1 +256,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T cont) {\n@@ -261,1 +262,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T controller() { return _controller; }\n@@ -264,1 +265,1 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+class CgroupCpuController: public CgroupController {\n@@ -266,4 +267,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-    jlong limit_from_str(char* limit_str);\n-\n@@ -273,2 +270,6 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual char *subsystem_path() = 0;\n+};\n+\n+class CgroupMemoryController: public CgroupController {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -276,3 +277,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -282,0 +283,11 @@\n+    virtual char *subsystem_path() = 0;\n+};\n+\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n@@ -283,0 +295,3 @@\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n@@ -285,1 +300,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -287,2 +301,2 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n+    virtual CachingCgroupController<CgroupMemoryController*>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController*>* cpu_controller() = 0;\n@@ -290,0 +304,7 @@\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":37,"deletions":16,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n+\n+jlong CgroupUtil::limit_from_str(char* limit_str) {\n+  if (limit_str == nullptr) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n+  \/\/ some controllers, for example the pids controller.\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static jlong limit_from_str(char* limit_str);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  int err = cg_file_contents_ctrl(this, \"\/memory.use_hierarchy\", JLONG_FORMAT, &use_hierarchy);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.use_hierarchy\", JLONG_FORMAT, &use_hierarchy);\n@@ -96,1 +97,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void do_trace_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -98,1 +121,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.limit_in_bytes\", JULONG_FORMAT, &memlimit);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.limit_in_bytes\", JULONG_FORMAT, &memlimit);\n@@ -101,0 +124,1 @@\n+    do_trace_log(OSCONTAINER_ERROR, phys_mem);\n@@ -105,1 +129,1 @@\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  if (memlimit >= phys_mem) {\n@@ -107,2 +131,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -110,1 +133,1 @@\n-      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+      err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\",\n@@ -113,0 +136,1 @@\n+        do_trace_log(OSCONTAINER_ERROR, phys_mem);\n@@ -116,1 +140,1 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n+      if (hier_memlimit >= phys_mem) {\n@@ -119,0 +143,1 @@\n+        do_trace_log(hier_memlimit, phys_mem);\n@@ -122,0 +147,1 @@\n+    do_trace_log(memlimit, phys_mem);\n@@ -123,2 +149,2 @@\n-  }\n-  else {\n+  } else {\n+    do_trace_log(memlimit, phys_mem);\n@@ -141,2 +167,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -145,1 +170,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", JULONG_FORMAT, &memswlimit);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.memsw.limit_in_bytes\", JULONG_FORMAT, &memswlimit);\n@@ -151,1 +176,0 @@\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n@@ -154,2 +178,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -157,1 +180,1 @@\n-      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", matchline, JULONG_FORMAT, &hier_memswlimit);\n+      err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", matchline, JULONG_FORMAT, &hier_memswlimit);\n@@ -174,2 +197,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -184,1 +207,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -207,3 +230,3 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -213,1 +236,1 @@\n-      return memory_swap_usage_impl(_memory->controller());\n+      return memory_swap_usage_impl(static_cast<CgroupV1Controller*>(this));\n@@ -219,1 +242,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -221,1 +244,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.swappiness\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.swappiness\",\n@@ -231,1 +254,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n@@ -233,1 +256,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.soft_limit_in_bytes\",\n@@ -240,1 +263,1 @@\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  if (memsoftlimit >= upper_bound) {\n@@ -257,1 +280,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -259,1 +282,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.usage_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.usage_in_bytes\",\n@@ -277,1 +300,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -279,1 +302,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.max_usage_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.max_usage_in_bytes\",\n@@ -289,1 +312,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -291,1 +314,1 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"rss\", JULONG_FORMAT, &rss);\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", \"rss\", JULONG_FORMAT, &rss);\n@@ -299,1 +322,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -301,1 +324,1 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"cache\", JULONG_FORMAT, &cache);\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.stat\", \"cache\", JULONG_FORMAT, &cache);\n@@ -309,1 +332,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -311,1 +334,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.usage_in_bytes\",\n@@ -321,1 +344,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -323,1 +346,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.limit_in_bytes\",\n@@ -330,1 +353,1 @@\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  if (kmem_limit >= phys_mem) {\n@@ -336,1 +359,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -338,1 +361,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.max_usage_in_bytes\",\n@@ -349,3 +372,5 @@\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+  julong phys_mem = os::Linux::physical_memory();\n+  CgroupV1MemoryController* ctrl = reinterpret_cast<CgroupV1MemoryController*>(memory_controller()->controller());\n+  jlong kmem_usage = ctrl->kernel_memory_usage_in_bytes();\n+  jlong kmem_limit = ctrl->kernel_memory_limit_in_bytes(phys_mem);\n+  jlong kmem_max_usage = ctrl->kernel_memory_max_usage_in_bytes();\n@@ -388,1 +413,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -390,1 +415,1 @@\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_quota_us\", \"%d\", &quota);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.cfs_quota_us\", \"%d\", &quota);\n@@ -399,1 +424,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -401,1 +426,1 @@\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_period_us\", \"%d\", &period);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.cfs_period_us\", \"%d\", &period);\n@@ -420,1 +445,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -422,1 +447,1 @@\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.shares\", \"%d\", &shares);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV1Controller*>(this), \"\/cpu.shares\", \"%d\", &shares);\n@@ -457,1 +482,1 @@\n-  return limit_from_str(pidsmax_str);\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":79,"deletions":54,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n@@ -54,1 +53,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController: public CgroupV1Controller, public CgroupMemoryController {\n@@ -59,0 +58,12 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n@@ -66,0 +77,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -74,1 +87,1 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController: public CgroupV1Controller, public CgroupCpuController {\n@@ -77,8 +90,11 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+  public:\n+    CgroupV1CpuController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+    }\n+    char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -86,0 +102,1 @@\n+  public:\n@@ -93,5 +110,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -106,2 +118,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n@@ -111,1 +123,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n@@ -113,1 +125,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n@@ -119,3 +131,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -124,1 +133,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -129,1 +138,1 @@\n-      _cpu = new CachingCgroupController(cpu);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n@@ -132,1 +141,1 @@\n-      _memory = new CachingCgroupController(memory);\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.weight\", \"%d\", &shares);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/cpu.weight\", \"%d\", &shares);\n@@ -80,0 +81,11 @@\n+static\n+char* cpu_quota_val(CgroupV2Controller* ctrl) {\n+  char quota[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/cpu.max\", \"%1023s %*d\", quota);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Raw value for CPU quota is: %s\", quota);\n+  return os::strdup(quota);\n+}\n+\n@@ -90,3 +102,3 @@\n-int CgroupV2Subsystem::cpu_quota() {\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+int CgroupV2CpuController::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val(static_cast<CgroupV2Controller*>(this));\n+  int limit = (int)CgroupUtil::limit_from_str(cpu_quota_str);\n@@ -99,1 +111,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.cpus\", \"%1023s\", cpus);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.cpus\", \"%1023s\", cpus);\n@@ -107,10 +119,0 @@\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  char quota[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%1023s %*d\", quota);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Raw value for CPU quota is: %s\", quota);\n-  return os::strdup(quota);\n-}\n-\n@@ -119,1 +121,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.mems\", \"%1023s\", mems);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.mems\", \"%1023s\", mems);\n@@ -127,1 +129,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -129,1 +131,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%*s %d\", &period);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/cpu.max\", \"%*s %d\", &period);\n@@ -147,1 +149,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -149,1 +151,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.current\", JLONG_FORMAT, &memusage);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.current\", JLONG_FORMAT, &memusage);\n@@ -158,3 +160,14 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+static\n+char* mem_soft_limit_val(CgroupController* ctrl) {\n+  char mem_soft_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.low\", \"%1023s\", mem_soft_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Memory Soft Limit is: %s\", mem_soft_limit_str);\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+  char* mem_soft_limit_str = mem_soft_limit_val(static_cast<CgroupV2Controller*>(this));\n+  return CgroupUtil::limit_from_str(mem_soft_limit_str);\n@@ -163,1 +176,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -169,1 +182,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -171,1 +184,1 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.stat\",\n@@ -180,1 +193,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -182,1 +195,1 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+  int err = cg_file_multi_line_ctrl(static_cast<CgroupV2Controller*>(this), \"\/memory.stat\",\n@@ -191,3 +204,4 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  char mem_soft_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.low\", \"%1023s\", mem_soft_limit_str);\n+static\n+char* mem_swp_limit_val(CgroupController* ctrl) {\n+  char mem_swp_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.swap.max\", \"%1023s\", mem_swp_limit_str);\n@@ -197,2 +211,4 @@\n-  log_trace(os, container)(\"Memory Soft Limit is: %s\", mem_soft_limit_str);\n-  return os::strdup(mem_soft_limit_str);\n+  \/\/ FIXME: This log-line is misleading, since it reads the swap limit only, not memory *and*\n+  \/\/ swap limit.\n+  log_trace(os, container)(\"Memory and Swap Limit is: %s\", mem_swp_limit_str);\n+  return os::strdup(mem_swp_limit_str);\n@@ -206,2 +222,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem, julong host_swap) {\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(this));\n@@ -212,1 +228,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -214,1 +230,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -216,1 +232,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -224,13 +240,5 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        char* mem_swp_current_str = mem_swp_current_val();\n-        jlong swap_current = limit_from_str(mem_swp_current_str);\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n-}\n-\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  char mem_swp_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.max\", \"%1023s\", mem_swp_limit_str);\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+char* mem_swp_current_val(CgroupV2Controller* ctrl) {\n+  char mem_swp_current_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.swap.current\", \"%1023s\", mem_swp_current_str);\n@@ -240,4 +248,2 @@\n-  \/\/ FIXME: This log-line is misleading, since it reads the swap limit only, not memory *and*\n-  \/\/ swap limit.\n-  log_trace(os, container)(\"Memory and Swap Limit is: %s\", mem_swp_limit_str);\n-  return os::strdup(mem_swp_limit_str);\n+  log_trace(os, container)(\"Swap currently used is: %s\", mem_swp_current_str);\n+  return os::strdup(mem_swp_current_str);\n@@ -246,4 +252,15 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  char mem_swp_current_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.current\", \"%1023s\", mem_swp_current_str);\n+\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(this));\n+      jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n+}\n+\n+static\n+char* mem_limit_val(CgroupV2Controller* ctrl) {\n+  char mem_limit_str[1024];\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.max\", \"%1023s\", mem_limit_str);\n@@ -253,2 +270,2 @@\n-  log_trace(os, container)(\"Swap currently used is: %s\", mem_swp_current_str);\n-  return os::strdup(mem_swp_current_str);\n+  log_trace(os, container)(\"Raw value for memory limit is: %s\", mem_limit_str);\n+  return os::strdup(mem_limit_str);\n@@ -257,1 +274,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -265,3 +282,3 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  char * mem_limit_str = mem_limit_val(static_cast<CgroupV2Controller*>(this));\n+  jlong limit = CgroupUtil::limit_from_str(mem_limit_str);\n@@ -275,0 +292,16 @@\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n@@ -278,9 +311,0 @@\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  char mem_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.max\", \"%1023s\", mem_limit_str);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Raw value for memory limit is: %s\", mem_limit_str);\n-  return os::strdup(mem_limit_str);\n-}\n@@ -289,2 +313,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n+  char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n@@ -292,2 +316,2 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -310,1 +334,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/pids.max\", \"%1023s\", pidsmax);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/pids.max\", \"%1023s\", pidsmax);\n@@ -329,1 +353,1 @@\n-  return limit_from_str(pidsmax_str);\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n@@ -342,1 +366,1 @@\n-  int err = cg_file_contents_ctrl(_unified, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n+  int err = cg_file_contents_ctrl(static_cast<CgroupV2Controller*>(_unified), \"\/pids.current\", JLONG_FORMAT, &pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":106,"deletions":82,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -51,0 +51,26 @@\n+class CgroupV2CpuController: public CgroupV2Controller, public CgroupCpuController {\n+  public:\n+    CgroupV2CpuController(char * mount_path, char *cgroup_path) : CgroupV2Controller(mount_path, cgroup_path) {\n+    }\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n+};\n+\n+class CgroupV2MemoryController: public CgroupV2Controller, public CgroupMemoryController {\n+  public:\n+    CgroupV2MemoryController(char * mount_path, char *cgroup_path) : CgroupV2Controller(mount_path, cgroup_path) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n+};\n+\n@@ -54,1 +80,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2MemoryController* _unified = nullptr;\n@@ -56,8 +82,3 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n-\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *cpu_quota_val();\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n+\n@@ -67,4 +88,5 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                      CgroupV2CpuController* cpu) {\n+      _unified = memory; \/\/ Use memory for now, should have all separate later\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n@@ -95,2 +117,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"}]}