{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -66,1 +67,2 @@\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(cg_infos[CPU_IDX]._mount_path, cg_infos[CPU_IDX]._cgroup_path);\n@@ -69,1 +71,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu);\n@@ -109,1 +111,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(info._root_mount_path, info._mount_path);\n@@ -478,1 +480,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +486,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController*>* contrl = cpu_controller();\n@@ -492,17 +494,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +512,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController*>* contrl = memory_controller();\n@@ -532,22 +519,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -648,1 +614,1 @@\n-  jlong val = CgroupSubsystem::limit_from_str(t);\n+  jlong val = CgroupUtil::limit_from_str(t);\n@@ -711,17 +677,45 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == nullptr) {\n-    return OSCONTAINER_ERROR;\n-  }\n-  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n-  \/\/ some controllers, for example the pids controller.\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n-  }\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n-  }\n-  os::free(limit_str);\n-  return (jlong)limit;\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":58,"deletions":64,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+template <class T>\n@@ -142,1 +143,1 @@\n-    CgroupController* _controller;\n+    T _controller;\n@@ -146,1 +147,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T cont) {\n@@ -152,1 +153,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T controller() { return _controller; }\n@@ -155,1 +156,1 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+class CgroupCpuController: public CgroupController {\n@@ -157,4 +158,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-    static jlong limit_from_str(char* limit_str);\n-\n@@ -164,2 +161,6 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual char *subsystem_path() = 0;\n+};\n+\n+class CgroupMemoryController: public CgroupController {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -167,3 +168,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -173,0 +174,3 @@\n+    virtual char *subsystem_path() = 0;\n+};\n+\n@@ -174,0 +178,11 @@\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n@@ -176,1 +191,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -178,3 +192,10 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n+    virtual CachingCgroupController<CgroupMemoryController*>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController*>* cpu_controller() = 0;\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n+\n+jlong CgroupUtil::limit_from_str(char* limit_str) {\n+  if (limit_str == nullptr) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n+  \/\/ some controllers, for example the pids controller.\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static jlong limit_from_str(char* limit_str);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n@@ -91,1 +92,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void do_trace_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -93,2 +116,3 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  CgroupV1Controller* v1_controller = static_cast<CgroupV1Controller*>(this);\n+  CONTAINER_READ_NUMBER_CHECKED(v1_controller, \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n@@ -96,2 +120,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -99,2 +122,1 @@\n-      bool is_ok = _memory->controller()->\n-                        read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n+      bool is_ok = v1_controller->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n@@ -105,1 +127,1 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n+      if (hier_memlimit >= phys_mem) {\n@@ -108,0 +130,1 @@\n+        do_trace_log(hier_memlimit, phys_mem);\n@@ -111,0 +134,1 @@\n+    do_trace_log(memlimit, phys_mem);\n@@ -112,2 +136,2 @@\n-  }\n-  else {\n+  } else {\n+    do_trace_log(memlimit, phys_mem);\n@@ -130,2 +154,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -134,2 +157,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+  CgroupV1Controller* v1_controller = static_cast<CgroupV1Controller*>(this);\n+  CONTAINER_READ_NUMBER_CHECKED(v1_controller, \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -138,2 +161,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -141,2 +163,1 @@\n-      bool is_ok = _memory->controller()->\n-                      read_numerical_key_value(\"\/memory.stat\", matchline, &hier_memswlimit);\n+      bool is_ok = v1_controller->read_numerical_key_value(\"\/memory.stat\", matchline, &hier_memswlimit);\n@@ -159,2 +180,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -169,1 +190,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -187,3 +208,3 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -193,1 +214,1 @@\n-      return memory_swap_usage_impl(_memory->controller());\n+      return memory_swap_usage_impl(static_cast<CgroupV1Controller*>(this));\n@@ -199,1 +220,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -201,1 +222,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -205,1 +226,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -207,2 +228,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -225,1 +246,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -227,1 +248,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n@@ -239,1 +260,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -241,1 +262,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n@@ -245,1 +266,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -247,2 +268,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n+  bool is_ok = static_cast<CgroupV1Controller*>(this)->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n@@ -256,1 +276,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -258,2 +278,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n+  bool is_ok = static_cast<CgroupV1Controller*>(this)->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n@@ -267,1 +286,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -269,1 +288,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n@@ -273,1 +292,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -275,2 +294,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -282,1 +301,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -284,1 +303,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n@@ -289,3 +308,5 @@\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+  julong phys_mem = os::Linux::physical_memory();\n+  CgroupV1MemoryController* ctrl = reinterpret_cast<CgroupV1MemoryController*>(memory_controller()->controller());\n+  jlong kmem_usage = ctrl->kernel_memory_usage_in_bytes();\n+  jlong kmem_limit = ctrl->kernel_memory_limit_in_bytes(phys_mem);\n+  jlong kmem_max_usage = ctrl->kernel_memory_max_usage_in_bytes();\n@@ -320,1 +341,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -322,2 +343,1 @@\n-  bool is_ok = _cpu->controller()->\n-                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  bool is_ok = static_cast<CgroupV1Controller*>(this)->read_number(\"\/cpu.cfs_quota_us\", &quota);\n@@ -335,1 +355,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -337,1 +357,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n@@ -351,1 +371,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -353,1 +373,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV1Controller*>(this), \"\/cpu.shares\", \"CPU Shares\", shares);\n@@ -380,1 +400,1 @@\n-  return limit_from_str(pidsmax_str);\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":79,"deletions":59,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n@@ -54,1 +53,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController: public CgroupV1Controller, public CgroupMemoryController {\n@@ -59,0 +58,12 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n@@ -66,0 +77,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -74,1 +87,1 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController: public CgroupV1Controller, public CgroupCpuController {\n@@ -77,8 +90,11 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+  public:\n+    CgroupV1CpuController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+    }\n+    char *subsystem_path() override { return CgroupV1Controller::subsystem_path(); }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -86,0 +102,1 @@\n+  public:\n@@ -93,5 +110,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -106,2 +118,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n@@ -111,1 +123,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n@@ -113,1 +125,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n@@ -119,3 +131,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -124,1 +133,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -129,1 +138,1 @@\n-      _cpu = new CachingCgroupController(cpu);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n@@ -132,1 +141,1 @@\n-      _memory = new CachingCgroupController(memory);\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV2Controller*>(this), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n@@ -86,1 +87,1 @@\n-int CgroupV2Subsystem::cpu_quota() {\n+int CgroupV2CpuController::cpu_quota() {\n@@ -88,1 +89,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", FIRST, &quota_val);\n+  bool is_ok = static_cast<CgroupV2Controller*>(this)->read_numerical_tuple_value(\"\/cpu.max\", FIRST, &quota_val);\n@@ -99,1 +100,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n+  CONTAINER_READ_STRING_CHECKED(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n@@ -105,1 +106,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems);\n+  CONTAINER_READ_STRING_CHECKED(static_cast<CgroupV2Controller*>(_unified), \"\/cpuset.mems\", \"cpuset.mems\", mems);\n@@ -109,1 +110,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -111,1 +112,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", SECOND, &period_val);\n+  bool is_ok = static_cast<CgroupV2Controller*>(this)->read_numerical_tuple_value(\"\/cpu.max\", SECOND, &period_val);\n@@ -130,1 +131,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -132,1 +133,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV2Controller*>(this), \"\/memory.current\", \"Memory Usage\", memusage);\n@@ -136,3 +137,10 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+static\n+char* mem_soft_limit_val(CgroupController* ctrl) {\n+  char* mem_soft_limit_str = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(ctrl, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit_str);\n+  return mem_soft_limit_str;\n+}\n+\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+  char* mem_soft_limit_str = mem_soft_limit_val(static_cast<CgroupV2Controller*>(this));\n+  return CgroupUtil::limit_from_str(mem_soft_limit_str);\n@@ -141,1 +149,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -147,1 +155,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -149,2 +157,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  bool is_ok = static_cast<CgroupV2Controller*>(this)->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n@@ -158,1 +165,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -160,2 +167,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  bool is_ok = static_cast<CgroupV2Controller*>(this)->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n@@ -169,4 +175,5 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  char* mem_soft_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit_str);\n-  return mem_soft_limit_str;\n+static\n+char* mem_swp_limit_val(CgroupController* ctrl) {\n+  char* mem_swp_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(ctrl, \"\/memory.swap.max\", \"Swap Limit\", mem_swp_limit_str);\n+  return mem_swp_limit_str;\n@@ -180,2 +187,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem, julong host_swap) {\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(this));\n@@ -186,1 +193,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -188,1 +195,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -190,1 +197,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -198,8 +205,6 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        char* mem_swp_current_str = mem_swp_current_val();\n-        jlong swap_current = limit_from_str(mem_swp_current_str);\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+char* mem_swp_current_val(CgroupV2Controller* ctrl) {\n+  char* mem_swp_current_str;\n+  CONTAINER_READ_STRING_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", mem_swp_current_str);\n+  return mem_swp_current_str;\n@@ -208,4 +213,9 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  char* mem_swp_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.max\", \"Swap Limit\", mem_swp_limit_str);\n-  return mem_swp_limit_str;\n+\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(this));\n+      jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n@@ -214,5 +224,5 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  char* mem_swp_current_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", mem_swp_current_str);\n-  return mem_swp_current_str;\n+static\n+char* mem_limit_val(CgroupV2Controller* ctrl) {\n+  char* mem_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(ctrl, \"\/memory.max\", \"Raw value for memory limit\", mem_limit_str);\n+  return mem_limit_str;\n@@ -221,1 +231,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -229,3 +239,3 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  char * mem_limit_str = mem_limit_val(static_cast<CgroupV2Controller*>(this));\n+  jlong limit = CgroupUtil::limit_from_str(mem_limit_str);\n@@ -239,0 +249,16 @@\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n@@ -242,5 +268,0 @@\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  char* mem_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.max\", \"Raw value for memory limit\", mem_limit_str);\n-  return mem_limit_str;\n-}\n@@ -249,2 +270,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n+  char* mem_swp_current_str = mem_swp_current_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_current = CgroupUtil::limit_from_str(mem_swp_current_str);\n@@ -252,2 +273,2 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  char* mem_swp_limit_str = mem_swp_limit_val(static_cast<CgroupV2Controller*>(_unified));\n+  jlong swap_limit = CgroupUtil::limit_from_str(mem_swp_limit_str);\n@@ -268,1 +289,2 @@\n-char* CgroupV2Subsystem::pids_max_val() {\n+static\n+char* pids_max_val(CgroupController* ctrl) {\n@@ -270,1 +292,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n+  CONTAINER_READ_STRING_CHECKED(ctrl, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n@@ -284,2 +306,2 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  char * pidsmax_str = pids_max_val(static_cast<CgroupV2Controller*>(_unified));\n+  return CgroupUtil::limit_from_str(pidsmax_str);\n@@ -298,1 +320,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  CONTAINER_READ_NUMBER_CHECKED(static_cast<CgroupV2Controller*>(_unified), \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":86,"deletions":64,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -51,0 +51,26 @@\n+class CgroupV2CpuController: public CgroupV2Controller, public CgroupCpuController {\n+  public:\n+    CgroupV2CpuController(char * mount_path, char *cgroup_path) : CgroupV2Controller(mount_path, cgroup_path) {\n+    }\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n+};\n+\n+class CgroupV2MemoryController: public CgroupV2Controller, public CgroupMemoryController {\n+  public:\n+    CgroupV2MemoryController(char * mount_path, char *cgroup_path) : CgroupV2Controller(mount_path, cgroup_path) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound);\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    char *subsystem_path() { return CgroupV2Controller::subsystem_path(); }\n+};\n+\n@@ -54,1 +80,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2MemoryController* _unified = nullptr;\n@@ -56,8 +82,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n-\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *pids_max_val();\n+    CachingCgroupController<CgroupMemoryController*>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController*>* _cpu = nullptr;\n@@ -66,4 +86,5 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                      CgroupV2CpuController* cpu) {\n+      _unified = memory; \/\/ Use memory for now, should have all separate later\n+      _memory = new CachingCgroupController<CgroupMemoryController*>(memory);\n+      _cpu = new CachingCgroupController<CgroupCpuController*>(cpu);\n@@ -94,2 +115,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController*>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController*>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"}]}