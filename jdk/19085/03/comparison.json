{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -64,3 +65,5 @@\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    \/\/ Note: We use the memory for non-cpu non-memory controller look-ups.\n+    \/\/       Perhaps we ought to have separate controllers for all.\n+    CgroupV2Controller* mem_other = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(mem_other);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(new CgroupV2Controller(cg_infos[CPU_IDX]._mount_path, cg_infos[CPU_IDX]._cgroup_path));\n@@ -69,1 +72,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu, mem_other);\n@@ -103,1 +106,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1MemoryController(new CgroupV1Controller(info._root_mount_path, info._mount_path));\n@@ -109,2 +112,3 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-        cpu->set_subsystem_path(info._cgroup_path);\n+        CgroupV1Controller* c_r = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(c_r);\n+        c_r->set_subsystem_path(info._cgroup_path);\n@@ -478,1 +482,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +488,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n@@ -492,17 +496,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +514,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n@@ -532,22 +521,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -718,0 +686,52 @@\n+\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n+  julong phys_mem = os::Linux::physical_memory();\n+  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":70,"deletions":50,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+template <class T>\n@@ -184,1 +185,1 @@\n-    CgroupController* _controller;\n+    T* _controller;\n@@ -188,1 +189,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T* cont) {\n@@ -194,1 +195,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T* controller() { return _controller; }\n@@ -197,1 +198,2 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+\/\/ Pure virtual class representing version agnostic CPU controllers\n+class CgroupCpuController: public CHeapObj<mtInternal> {\n@@ -199,3 +201,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-\n@@ -205,2 +204,6 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+};\n+\n+\/\/ Pure virtual class representing version agnostic memory controllers\n+class CgroupMemoryController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -208,3 +211,3 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -214,0 +217,2 @@\n+    virtual void print_version_specific_info(outputStream* st, julong host_mem);\n+};\n@@ -215,0 +220,11 @@\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n@@ -217,1 +233,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -219,4 +234,11 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n-    virtual void print_version_specific_info(outputStream* st) = 0;\n+    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n@@ -84,1 +85,1 @@\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  _reader->set_subsystem_path(cgroup_path);\n@@ -91,1 +92,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void do_trace_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -93,2 +116,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n@@ -96,2 +119,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -99,3 +121,1 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   \"hierarchical_memory_limit\",\n-                                                                   &hier_memlimit);\n+      bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n@@ -106,3 +126,2 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n+      if (hier_memlimit < phys_mem) {\n+        do_trace_log(hier_memlimit, phys_mem);\n@@ -111,0 +130,1 @@\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -112,0 +132,1 @@\n+    do_trace_log(memlimit, phys_mem);\n@@ -113,2 +134,2 @@\n-  }\n-  else {\n+  } else {\n+    do_trace_log(memlimit, phys_mem);\n@@ -131,2 +152,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -135,2 +155,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -139,2 +158,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -142,3 +160,3 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   matchline,\n-                                                                   &hier_memswlimit);\n+      bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\",\n+                                                           matchline,\n+                                                           &hier_memswlimit);\n@@ -161,2 +179,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -171,1 +189,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -189,3 +207,3 @@\n-jlong CgroupV1Subsystem::memory_and_swap_usage_in_bytes() {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes();\n-  jlong memory_limit = CgroupSubsystem::memory_limit_in_bytes();\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -195,1 +213,1 @@\n-      return memory_swap_usage_impl(_memory->controller());\n+      return memory_swap_usage_impl(_reader);\n@@ -201,1 +219,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -203,1 +221,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -207,1 +225,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -209,2 +227,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -227,1 +245,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -229,1 +247,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n@@ -241,1 +259,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -243,1 +261,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n@@ -247,1 +265,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -249,3 +267,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"rss\",\n-                                                               &rss);\n+  bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n@@ -259,1 +275,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -261,3 +277,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                               \"cache\",\n-                                                               &cache);\n+  bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n@@ -271,1 +285,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -273,1 +287,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n@@ -277,1 +291,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -279,2 +293,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -286,1 +300,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -288,1 +302,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n@@ -292,1 +306,1 @@\n-void CgroupV1Subsystem::print_version_specific_info(outputStream* st) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n@@ -294,1 +308,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n@@ -324,1 +338,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -326,2 +340,1 @@\n-  bool is_ok = _cpu->controller()->\n-                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  bool is_ok = _reader->read_number(\"\/cpu.cfs_quota_us\", &quota);\n@@ -339,1 +352,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -341,1 +354,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n@@ -355,1 +368,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -357,1 +370,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/cpu.shares\", \"CPU Shares\", shares);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":77,"deletions":64,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n@@ -54,1 +53,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController : public CgroupMemoryController {\n@@ -56,0 +55,2 @@\n+  private:\n+    CgroupV1Controller* _reader;\n@@ -59,0 +60,12 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n@@ -66,0 +79,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -68,2 +83,3 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n+    CgroupV1MemoryController(CgroupV1Controller* reader)\n+      : _reader(reader),\n+        _uses_mem_hierarchy(false) {\n@@ -74,1 +90,8 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController: public CgroupCpuController {\n+\n+  private:\n+    CgroupV1Controller* _reader;\n+  public:\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n@@ -77,8 +100,3 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    CgroupV1CpuController(CgroupV1Controller* reader) : _reader(reader) {\n+    }\n+};\n@@ -86,0 +104,3 @@\n+class CgroupV1Subsystem: public CgroupSubsystem {\n+\n+  public:\n@@ -93,5 +114,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -106,2 +122,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n@@ -111,1 +127,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n@@ -113,1 +129,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -117,3 +133,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -122,1 +135,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -125,6 +138,6 @@\n-                      CgroupV1MemoryController* memory) {\n-      _cpuset = cpuset;\n-      _cpu = new CachingCgroupController(cpu);\n-      _cpuacct = cpuacct;\n-      _pids = pids;\n-      _memory = new CachingCgroupController(memory);\n+                      CgroupV1MemoryController* memory) :\n+      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _cpuset(cpuset),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpuacct(cpuacct),\n+      _pids(pids) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":45,"deletions":32,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n@@ -86,1 +87,1 @@\n-int CgroupV2Subsystem::cpu_quota() {\n+int CgroupV2CpuController::cpu_quota() {\n@@ -88,1 +89,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  bool is_ok = _reader->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n@@ -109,1 +110,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -111,1 +112,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  bool is_ok = _reader->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n@@ -130,1 +131,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -132,1 +133,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(_reader, \"\/memory.current\", \"Memory Usage\", memusage);\n@@ -136,1 +137,1 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -138,1 +139,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_reader, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n@@ -142,1 +143,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -148,1 +149,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -150,2 +151,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n@@ -159,1 +159,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -161,2 +161,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  bool is_ok = _reader->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n@@ -175,1 +174,1 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem, julong host_swap) {\n@@ -177,1 +176,1 @@\n-  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  bool is_ok = _reader->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n@@ -182,1 +181,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -186,1 +185,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -194,7 +193,6 @@\n-jlong CgroupV2Subsystem::memory_and_swap_usage_in_bytes() {\n-    jlong memory_usage = memory_usage_in_bytes();\n-    if (memory_usage >= 0) {\n-        jlong swap_current = mem_swp_current_val();\n-        return memory_usage + (swap_current >= 0 ? swap_current : 0);\n-    }\n-    return memory_usage; \/\/ not supported or unlimited case\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+jlong mem_swp_current_val(CgroupV2Controller* ctrl) {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -203,4 +201,7 @@\n-jlong CgroupV2Subsystem::mem_swp_limit_val() {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      jlong swap_current = mem_swp_current_val(_reader);\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n@@ -209,5 +210,5 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-jlong CgroupV2Subsystem::mem_swp_current_val() {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+static\n+jlong mem_limit_val(CgroupV2Controller* ctrl) {\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -216,1 +217,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -224,4 +225,33 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  jlong limit = mem_limit_val(_reader);\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n+  return limit;\n+}\n+\n+static\n+jlong mem_swp_limit_val(CgroupV2Controller* ctrl) {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -230,3 +260,3 @@\n-void CgroupV2Subsystem::print_version_specific_info(outputStream* st) {\n-  jlong swap_current = mem_swp_current_val();\n-  jlong swap_limit = mem_swp_limit_val();\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+  jlong swap_current = mem_swp_current_val(_reader);\n+  jlong swap_limit = mem_swp_limit_val(_reader);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":75,"deletions":45,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -51,0 +51,29 @@\n+class CgroupV2CpuController: public CgroupCpuController {\n+  private:\n+    CgroupV2Controller* _reader;\n+  public:\n+    CgroupV2CpuController(CgroupV2Controller* reader) : _reader(reader) {\n+    }\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+};\n+\n+class CgroupV2MemoryController: public CgroupMemoryController {\n+  private:\n+    CgroupV2Controller* _reader;\n+  public:\n+    CgroupV2MemoryController(CgroupV2Controller* reader) : _reader(reader) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+};\n+\n@@ -54,1 +83,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller* _unified = nullptr;\n@@ -56,5 +85,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n-\n-    jlong mem_swp_limit_val();\n-    jlong mem_swp_current_val();\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -63,4 +89,6 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+                      CgroupV2CpuController* cpu,\n+                      CgroupV2Controller* unified) :\n+        _unified(unified),\n+        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n@@ -91,2 +119,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"}]}