{"files":[{"patch":"@@ -119,1 +119,1 @@\n-    final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);\n+    final Logger debug = Utils.getDebugLogger(this::dbgString);\n@@ -121,1 +121,1 @@\n-            Utils.getDebugLogger(\"Http2Connection\"::toString, Utils.DEBUG);\n+            Utils.getDebugLogger(\"Http2Connection\"::toString);\n@@ -123,1 +123,1 @@\n-            Utils.getHpackLogger(this::dbgString, Utils.DEBUG_HPACK);\n+            Utils.getHpackLogger(this::dbgString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        debug = Utils.getWebSocketLogger(dbgTag::toString, Utils.DEBUG_WS);\n+        debug = Utils.getWebSocketLogger(dbgTag::toString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RawChannelTube.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * <p> See {@link Utils#getDebugLogger(Supplier, boolean)} and\n- * {@link Utils#getHpackLogger(Supplier, boolean)}.\n+ * <p> See {@link Utils#getDebugLogger(Supplier)} and\n+ * {@link Utils#getHpackLogger(Supplier)}.\n@@ -48,0 +48,62 @@\n+\n+    \/**\n+     * A DebugLogger configuration is composed of three levels.\n+     * The three levels can be configured independently, but are\n+     * typically either Level.ALL or Level.OFF.\n+     *\n+     * @param outLevel the level above which messages will be directly\n+     *                printed to {@link System#out}\n+     * @param errLevel the level above which messages will be directly\n+     *                printed to {@link System#err}\n+     * @param logLevel the level above which messages will be forwarded\n+     *               to an underlying {@link System.Logger}\n+     *\/\n+    public record LoggerConfig(Level outLevel, Level errLevel, Level logLevel) {\n+        public LoggerConfig {\n+            Objects.requireNonNull(outLevel);\n+            Objects.requireNonNull(errLevel);\n+            Objects.requireNonNull(logLevel);\n+        }\n+\n+        \/\/ true if at least on of the three levels is not Level.OFF\n+        public boolean on() {\n+            return minSeverity() <= Level.OFF.getSeverity();\n+        }\n+        \/\/ The minimal severity of the three level. Messages below\n+        \/\/ that severity will not be logged anywhere.\n+        public int minSeverity() {\n+            return Math.min(outLevel.getSeverity(),\n+                    Math.min(errLevel.getSeverity(), logLevel.getSeverity()));\n+        }\n+        \/\/ Whether the given level can be logged with the given logger\n+        public boolean levelEnabledFor(Level level, System.Logger logger) {\n+            if (level == Level.OFF) return false;\n+            int severity = level.getSeverity();\n+            if (severity >= errLevel.getSeverity()) return true;\n+            if (severity >= outLevel.getSeverity()) return true;\n+            if (severity >= logLevel.getSeverity()) return logger.isLoggable(level);\n+            return false;\n+        }\n+        \/\/ The same configuration, but with the given {@link #errLevel}\n+        public LoggerConfig withErrLevel(Level errLevel) {\n+            return new LoggerConfig(outLevel, errLevel, logLevel);\n+        }\n+        \/\/ The same configuration, but with the given {@link #outLevel}\n+        public LoggerConfig withOutLevel(Level outLevel) {\n+            return new LoggerConfig(outLevel, errLevel, logLevel);\n+        }\n+        \/\/ The same configuration, but with the given {@link #logLevel}\n+        public LoggerConfig withLogLevel(Level logLevel) {\n+            return new LoggerConfig(outLevel, errLevel, logLevel);\n+        }\n+\n+        \/** Logs on {@link System#err} only, does not forward to System.Logger **\/\n+        public static final LoggerConfig STDERR = new LoggerConfig(Level.OFF, Level.ALL, Level.OFF);\n+        \/** Logs on {@link System#out} only, does not forward to System.Logger **\/\n+        public static final LoggerConfig STDOUT = new LoggerConfig(Level.OFF, Level.ALL, Level.OFF);\n+        \/** Forward to System.Logger, doesn't log directly to System.out or System.err **\/\n+        public static final LoggerConfig LOG = new LoggerConfig(Level.OFF, Level.OFF, Level.ALL);\n+        \/** does not log anywhere **\/\n+        public static final LoggerConfig OFF = new LoggerConfig(Level.OFF, Level.OFF, Level.OFF);\n+    };\n+\n@@ -56,1 +118,1 @@\n-            new DebugLogger(HTTP, \"HTTP\"::toString, Level.OFF, Level.OFF);\n+            new DebugLogger(HTTP, \"HTTP\"::toString, LoggerConfig.OFF);\n@@ -58,1 +120,1 @@\n-            new DebugLogger(HTTP, \"WS\"::toString, Level.OFF, Level.OFF);\n+            new DebugLogger(HTTP, \"WS\"::toString, LoggerConfig.OFF);\n@@ -60,1 +122,1 @@\n-            new DebugLogger(HTTP, \"HPACK\"::toString, Level.OFF, Level.OFF);\n+            new DebugLogger(HTTP, \"HPACK\"::toString, LoggerConfig.OFF);\n@@ -64,2 +126,2 @@\n-    private final Level errLevel;\n-    private final Level outLevel;\n+    private final LoggerConfig config;\n+    private final int minSeverity;\n@@ -73,7 +135,14 @@\n-     *\n-     * By default, this logger will forward all messages logged to the supplied\n-     * {@code logger}.\n-     * But in addition, if the message severity level is {@code >=} to\n-     * the provided {@code errLevel} it will print the messages on System.err,\n-     * and if the message severity level is {@code >=} to\n-     * the provided {@code outLevel} it will also print the messages on System.out.\n+     * <p>\n+     * By default, this logger will print message whose severity is\n+     * above the severity configured in the logger {@code config}\n+     * <ul>\n+     *     <li>If {@code config.outLevel()} is not Level.OFF, messages\n+     *     whose severity are at or above that severity will be directly\n+     *     printed on System.out<\/li>\n+     *     <li>If {@code config.errLevel()} is not Level.OFF, messages\n+     *     whose severity are at or above that severity will be directly\n+     *     printed on System.err<\/li>\n+     *     <li>If {@code config.logLevel()} is not Level.OFF, messages\n+     *     whose severity are at or above that severity will be forwarded\n+     *     to the supplied {@code logger}.<\/li>\n+     * <\/ul>\n@@ -86,1 +155,2 @@\n-     *          {@code new DebugLogger(logger, this::dbgTag, Level.OFF, Level.ALL);}.\n+     *          {@code new DebugLogger(logger, this::dbgTag,\n+     *                                 LoggerConfig.LOG.withErrLevel(Level.ALL));}.\n@@ -88,1 +158,1 @@\n-     *          use {@code new DebugLogger(logger, this::dbgTag, Level.OFF, Level.OFF);}.\n+     *          use {@code new DebugLogger(logger, this::dbgTag, LoggerConfig.LOG);}.\n@@ -91,1 +161,1 @@\n-     *               This should be either {@link #HPACK} or {@link #HTTP};\n+     *               This should be either {@link #WS}, {@link #HPACK}, or {@link #HTTP};\n@@ -95,4 +165,2 @@\n-     * @param outLevel The level above which messages will be also printed on\n-     *               System.out (in addition to being forwarded to the internal logger).\n-     * @param errLevel The level above which messages will be also printed on\n-     *               System.err (in addition to being forwarded to the internal logger).\n+     * @param config The levels above which messages will be printed to the\n+     *               corresponding destination.\n@@ -104,2 +172,1 @@\n-                Level outLevel,\n-                Level errLevel) {\n+                LoggerConfig config) {\n@@ -107,2 +174,1 @@\n-        this.errLevel = errLevel;\n-        this.outLevel = outLevel;\n+        this.config = Objects.requireNonNull(config);\n@@ -110,0 +176,1 @@\n+        this.minSeverity = config.minSeverity();\n@@ -121,1 +188,3 @@\n-        return levelEnabledFor(level, outLevel, errLevel, logger);\n+        int severity = level.getSeverity();\n+        if (severity < minSeverity) return false;\n+        return levelEnabledFor(level, config, logger);\n@@ -129,7 +198,3 @@\n-    static boolean levelEnabledFor(Level level, Level outLevel, Level errLevel,\n-                                   System.Logger logger) {\n-        if (level == Level.OFF) return false;\n-        int severity = level.getSeverity();\n-        return severity >= errLevel.getSeverity()\n-                || severity >= outLevel.getSeverity()\n-                || logger.isLoggable(level);\n+    static boolean levelEnabledFor(Level level, LoggerConfig config,\n+                            System.Logger logger) {\n+        return config.levelEnabledFor(level, logger);\n@@ -154,1 +219,0 @@\n-\n@@ -156,0 +220,3 @@\n+        if (severity < minSeverity) return;\n+\n+        var errLevel = config.errLevel();\n@@ -160,0 +227,1 @@\n+        var outLevel = config.outLevel();\n@@ -164,1 +232,4 @@\n-        if (logger.isLoggable(level)) {\n+        var logLevel = config.logLevel();\n+        if (logLevel != Level.OFF\n+                && logLevel.getSeverity() <= severity\n+                && logger.isLoggable(level)) {\n@@ -177,0 +248,2 @@\n+        int severity = level.getSeverity();\n+        if (severity < minSeverity) return;\n@@ -178,0 +251,1 @@\n+        var errLevel = config.errLevel();\n@@ -179,1 +253,1 @@\n-                && errLevel.getSeverity() <= level.getSeverity()) {\n+                && errLevel.getSeverity() <= severity) {\n@@ -182,0 +256,1 @@\n+        var outLevel = config.outLevel();\n@@ -183,1 +258,1 @@\n-                && outLevel.getSeverity() <= level.getSeverity()) {\n+                && outLevel.getSeverity() <= severity) {\n@@ -186,1 +261,4 @@\n-        if (logger.isLoggable(level)) {\n+        var logLevel = config.logLevel();\n+        if (logLevel != Level.OFF\n+                && logLevel.getSeverity() <= severity\n+                && logger.isLoggable(level)) {\n@@ -229,1 +307,0 @@\n-\n@@ -263,4 +340,3 @@\n-                                               Level outLevel,\n-                                               Level errLevel) {\n-        if (levelEnabledFor(Level.DEBUG, outLevel, errLevel, HTTP)) {\n-            return new DebugLogger(HTTP, dbgTag, outLevel, errLevel);\n+                                               LoggerConfig config) {\n+        if (levelEnabledFor(Level.DEBUG, config, HTTP)) {\n+            return new DebugLogger(HTTP, dbgTag, config);\n@@ -274,4 +350,3 @@\n-                                                    Level outLevel,\n-                                                    Level errLevel) {\n-        if (levelEnabledFor(Level.DEBUG, outLevel, errLevel, WS)) {\n-            return new DebugLogger(WS, dbgTag, outLevel, errLevel);\n+                                                    LoggerConfig config) {\n+        if (levelEnabledFor(Level.DEBUG, config, WS)) {\n+            return new DebugLogger(WS, dbgTag, config);\n@@ -284,5 +359,3 @@\n-    public static DebugLogger createHpackLogger(Supplier<String> dbgTag,\n-                                                Level outLevel,\n-                                                Level errLevel) {\n-        if (levelEnabledFor(Level.DEBUG, outLevel, errLevel, HPACK)) {\n-            return new DebugLogger(HPACK, dbgTag, outLevel, errLevel);\n+    public static DebugLogger createHpackLogger(Supplier<String> dbgTag, LoggerConfig config) {\n+        if (levelEnabledFor(Level.DEBUG, config, HPACK)) {\n+            return new DebugLogger(HPACK, dbgTag, config);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/DebugLogger.java","additions":126,"deletions":53,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,3 @@\n- * {@link Utils#getDebugLogger(Supplier, boolean)},\n- * {@link Utils#getWebSocketLogger(Supplier, boolean)}and\n- * {@link Utils#getHpackLogger(Supplier, boolean)}.\n+ * {@link Utils#getDebugLogger(Supplier)},\n+ * {@link Utils#getWebSocketLogger(Supplier)} and\n+ * {@link Utils#getHpackLogger(Supplier)}.\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Logger.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import sun.net.NetProperties;\n-import sun.net.util.IPAddressUtil;\n-import sun.net.www.HeaderParser;\n-\n@@ -76,0 +72,7 @@\n+import jdk.internal.net.http.common.DebugLogger.LoggerConfig;\n+import jdk.internal.net.http.HttpRequestImpl;\n+\n+import sun.net.NetProperties;\n+import sun.net.util.IPAddressUtil;\n+import sun.net.www.HeaderParser;\n+\n@@ -79,1 +82,0 @@\n-import jdk.internal.net.http.HttpRequestImpl;\n@@ -101,6 +103,9 @@\n-    public static final boolean DEBUG = \/\/ Revisit: temporary dev flag.\n-            getBooleanProperty(DebugLogger.HTTP_NAME, false);\n-    public static final boolean DEBUG_WS = \/\/ Revisit: temporary dev flag.\n-            getBooleanProperty(DebugLogger.WS_NAME, false);\n-    public static final boolean DEBUG_HPACK = \/\/ Revisit: temporary dev flag.\n-            getBooleanProperty(DebugLogger.HPACK_NAME, false);\n+    public static final LoggerConfig DEBUG_CONFIG =\n+            getLoggerConfig(DebugLogger.HTTP_NAME, LoggerConfig.OFF);\n+    public static final LoggerConfig DEBUG_WS_CONFIG =\n+            getLoggerConfig(DebugLogger.WS_NAME, LoggerConfig.OFF);\n+    public static final LoggerConfig DEBUG_HPACK_CONFIG =\n+            getLoggerConfig(DebugLogger.HPACK_NAME, LoggerConfig.OFF);\n+\n+    public static final boolean DEBUG = DEBUG_CONFIG.on(); \/\/ Revisit: temporary dev flag.\n+    public static final boolean DEBUG_WS = DEBUG_WS_CONFIG.on(); \/\/ Revisit: temporary dev flag.\n@@ -112,0 +117,35 @@\n+    private static LoggerConfig getLoggerConfig(String loggerName, LoggerConfig def) {\n+        PrivilegedAction<String> action = () -> System.getProperty(loggerName);\n+        @SuppressWarnings(\"removal\")\n+        var prop = AccessController.doPrivileged(action);\n+        if (prop == null) return def;\n+        var config = LoggerConfig.OFF;\n+        for (var s : prop.split(\",\")) {\n+            s = s.trim();\n+            if (s.isEmpty()) continue;\n+            int len = s.length();\n+            switch (len) {\n+                case 3 -> {\n+                    if (s.regionMatches(true, 0, \"err\", 0, 3)) {\n+                        config = config.withErrLevel(Level.ALL);\n+                        continue;\n+                    }\n+                    if (s.regionMatches(true, 0, \"out\", 0, 3)) {\n+                        config = config.withOutLevel(Level.ALL);\n+                        continue;\n+                    }\n+                    if (s.regionMatches(true, 0, \"log\", 0, 3)) {\n+                        config = config.withLogLevel(Level.ALL);\n+                    }\n+                }\n+                case 4 -> {\n+                    if (s.regionMatches(true, 0, \"true\", 0, 4)) {\n+                        config = config.withErrLevel(Level.ALL).withLogLevel(Level.ALL);\n+                    }\n+                }\n+                default -> { continue; }\n+            }\n+        }\n+        return config;\n+    }\n+\n@@ -776,1 +816,1 @@\n-     *\n+     * <p>\n@@ -778,5 +818,16 @@\n-     * {@code <= DEBUG}. By default, this logger will forward all messages\n-     * logged to an internal logger named \"jdk.internal.httpclient.debug\".\n-     * In addition, if the property -Djdk.internal.httpclient.debug=true is set,\n-     * it will print the messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n+     * {@code <= DEBUG}.\n+     * <p>\n+     * The output of this logger is controlled by the system property\n+     * -Djdk.internal.httpclient.debug. The value of the property is\n+     * a comma separated list of tokens. The following tokens are\n+     * recognized:\n+     * <ul>\n+     *   <li> err: the messages will be logged on System.err<\/li>\n+     *   <li> out: the messages will be logged on System.out<\/li>\n+     *   <li> log: the messages will be forwarded to an internal\n+     *        System.Logger named \"jdk.internal.httpclient.debug\"<\/li>\n+     *   <li> true: this is equivalent to \"err,log\":  the messages will be logged\n+     *        both on System.err, and forwarded to the internal logger.<\/li>\n+     * <\/ul>\n+     *\n+     * This logger will add some decoration to the printed message, in the form of\n@@ -791,1 +842,1 @@\n-        return getDebugLogger(dbgTag, DEBUG);\n+        return DebugLogger.createHttpLogger(dbgTag, DEBUG_CONFIG);\n@@ -794,31 +845,0 @@\n-    \/**\n-     * Get a logger for debug HTTP traces.The logger should only be used\n-     * with levels whose severity is {@code <= DEBUG}.\n-     *\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.debug\".\n-     * In addition, if the message severity level is >= to\n-     * the provided {@code errLevel} it will print the messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n-     * {@code <Level>:[<thread-name>] [<elapsed-time>] <dbgTag>: <formatted message>}\n-     *\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getDebugLogger(this::dbgTag, Level.ALL);}.\n-     *          This is also equivalent to calling\n-     *          {@code getDebugLogger(this::dbgTag, true);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getDebugLogger(this::dbgTag, Level.OFF);}.\n-     *          This is also equivalent to calling\n-     *          {@code getDebugLogger(this::dbgTag, false);}.\n-     *\n-     * @param dbgTag A lambda that returns a string that identifies the caller\n-     *               (e.g: \"SocketTube(3)\", or \"Http2Connection(SocketTube(3))\")\n-     * @param errLevel The level above which messages will be also printed on\n-     *               stderr (in addition to be forwarded to the internal logger).\n-     *\n-     * @return A logger for HTTP internal debug traces\n-     *\/\n-    static Logger getDebugLogger(Supplier<String> dbgTag, Level errLevel) {\n-        return DebugLogger.createHttpLogger(dbgTag, Level.OFF, errLevel);\n-    }\n@@ -830,16 +850,2 @@\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.debug\".\n-     * In addition, the provided boolean {@code on==true}, it will print the\n-     * messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n-     * {@code <Level>:[<thread-name>] [<elapsed-time>] <dbgTag>: <formatted message>}\n-     *\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getDebugLogger(this::dbgTag, true);}.\n-     *          This is also equivalent to calling\n-     *          {@code getDebugLogger(this::dbgTag, Level.ALL);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getDebugLogger(this::dbgTag, false);}.\n-     *          This is also equivalent to calling\n-     *          {@code getDebugLogger(this::dbgTag, Level.OFF);}.\n+     * If {@code on} is false, returns a logger that doesn't log anything.\n+     * Otherwise, returns a logger equivalent to {@link #getDebugLogger(Supplier)}.\n@@ -849,2 +855,1 @@\n-     * @param on  Whether messages should also be printed on\n-     *               stderr (in addition to be forwarded to the internal logger).\n+     * @param on  Whether the logger is enabled.\n@@ -855,2 +860,2 @@\n-        Level errLevel = on ? Level.ALL : Level.OFF;\n-        return getDebugLogger(dbgTag, errLevel);\n+        LoggerConfig config = on ? DEBUG_CONFIG : LoggerConfig.OFF;\n+        return DebugLogger.createHttpLogger(dbgTag, config);\n@@ -890,16 +895,6 @@\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.hpack.debug\".\n-     * In addition, if the message severity level is >= to\n-     * the provided {@code errLevel} it will print the messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n-     * {@code <Level>:[<thread-name>] [<elapsed-time>] <dbgTag>: <formatted message>}\n-     *\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getHpackLogger(this::dbgTag, Level.ALL);}.\n-     *          This is also equivalent to calling\n-     *          {@code getHpackLogger(this::dbgTag, true);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getHpackLogger(this::dbgTag, Level.OFF);}.\n-     *          This is also equivalent to calling\n-     *          {@code getHpackLogger(this::dbgTag, false);}.\n+     * By default, this logger has a configuration equivalent to that\n+     * returned by {@link #getHpackLogger(Supplier)}. This original\n+     * configuration is amended by the provided {@code errLevel} in\n+     * the following way: if the message severity level is >= to\n+     * the provided {@code errLevel} the message will additionally\n+     * be printed on stderr.\n@@ -915,2 +910,1 @@\n-        Level outLevel = Level.OFF;\n-        return DebugLogger.createHpackLogger(dbgTag, outLevel, errLevel);\n+        return DebugLogger.createHpackLogger(dbgTag, DEBUG_HPACK_CONFIG.withErrLevel(errLevel));\n@@ -923,5 +917,17 @@\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.hpack.debug\".\n-     * In addition, the provided boolean {@code on==true}, it will print the\n-     * messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n+     * The logger should only be used with levels whose severity is\n+     * {@code <= DEBUG}.\n+     * <p>\n+     * The output of this logger is controlled by the system property\n+     * -Djdk.internal.httpclient.hpack.debug. The value of the property is\n+     * a comma separated list of tokens. The following tokens are\n+     * recognized:\n+     * <ul>\n+     *   <li> err: the messages will be logged on System.err<\/li>\n+     *   <li> out: the messages will be logged on System.out<\/li>\n+     *   <li> log: the messages will be forwarded to an internal\n+     *        System.Logger named \"jdk.internal.httpclient.hpack.debug\"<\/li>\n+     *   <li> true: this is equivalent to \"err,log\":  the messages will be logged\n+     *        both on System.err, and forwarded to the internal logger.<\/li>\n+     * <\/ul>\n+     *\n+     * This logger will add some decoration to the printed message, in the form of\n@@ -930,10 +936,0 @@\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getHpackLogger(this::dbgTag, true);}.\n-     *          This is also equivalent to calling\n-     *          {@code getHpackLogger(this::dbgTag, Level.ALL);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getHpackLogger(this::dbgTag, false);}.\n-     *          This is also equivalent to calling\n-     *          {@code getHpackLogger(this::dbgTag, Level.OFF);}.\n-     *\n@@ -942,2 +938,0 @@\n-     * @param on  Whether messages should also be printed on\n-     *            stderr (in addition to be forwarded to the internal logger).\n@@ -947,3 +941,2 @@\n-    public static Logger getHpackLogger(Supplier<String> dbgTag, boolean on) {\n-        Level errLevel = on ? Level.ALL : Level.OFF;\n-        return getHpackLogger(dbgTag, errLevel);\n+    public static Logger getHpackLogger(Supplier<String> dbgTag) {\n+        return DebugLogger.createHpackLogger(dbgTag, DEBUG_HPACK_CONFIG);\n@@ -955,39 +948,18 @@\n-     *\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.websocket.debug\".\n-     * In addition, if the message severity level is >= to\n-     * the provided {@code errLevel} it will print the messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n-     * {@code <Level>:[<thread-name>] [<elapsed-time>] <dbgTag>: <formatted message>}\n-     *\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getWebSocketLogger(this::dbgTag, Level.ALL);}.\n-     *          This is also equivalent to calling\n-     *          {@code getWSLogger(this::dbgTag, true);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getWebSocketLogger(this::dbgTag, Level.OFF);}.\n-     *          This is also equivalent to calling\n-     *          {@code getWSLogger(this::dbgTag, false);}.\n-     *\n-     * @param dbgTag A lambda that returns a string that identifies the caller\n-     *               (e.g: \"WebSocket(3)\")\n-     * @param errLevel The level above which messages will be also printed on\n-     *               stderr (in addition to be forwarded to the internal logger).\n-     *\n-     * @return A logger for HPACK internal debug traces\n-     *\/\n-    public static Logger getWebSocketLogger(Supplier<String> dbgTag, Level errLevel) {\n-        Level outLevel = Level.OFF;\n-        return DebugLogger.createWebSocketLogger(dbgTag, outLevel, errLevel);\n-    }\n-\n-    \/**\n-     * Get a logger for debug WebSocket traces.The logger should only be used\n-     * with levels whose severity is {@code <= DEBUG}.\n-     *\n-     * By default, this logger will forward all messages logged to an internal\n-     * logger named \"jdk.internal.httpclient.websocket.debug\".\n-     * In addition, the provided boolean {@code on==true}, it will print the\n-     * messages on stderr.\n-     * The logger will add some decoration to the printed message, in the form of\n+     * <p>\n+     * The logger should only be used with levels whose severity is\n+     * {@code <= DEBUG}.\n+     * <p>\n+     * The output of this logger is controlled by the system property\n+     * -Djdk.internal.httpclient.websocket.debug. The value of the property is\n+     * a comma separated list of tokens. The following tokens are\n+     * recognized:\n+     * <ul>\n+     *   <li> err: the messages will be logged on System.err<\/li>\n+     *   <li> out: the messages will be logged on System.out<\/li>\n+     *   <li> log: the messages will be forwarded to an internal\n+     *        System.Logger named \"jdk.internal.httpclient.websocket.debug\"<\/li>\n+     *   <li> true: this is equivalent to \"err,log\":  the messages will be logged\n+     *        both on System.err, and forwarded to the internal logger.<\/li>\n+     * <\/ul>\n+     *\n+     * This logger will add some decoration to the printed message, in the form of\n@@ -996,9 +968,0 @@\n-     * @apiNote To obtain a logger that will always print things on stderr in\n-     *          addition to forwarding to the internal logger, use\n-     *          {@code getWebSocketLogger(this::dbgTag, true);}.\n-     *          This is also equivalent to calling\n-     *          {@code getWebSocketLogger(this::dbgTag, Level.ALL);}.\n-     *          To obtain a logger that will only forward to the internal logger,\n-     *          use {@code getWebSocketLogger(this::dbgTag, false);}.\n-     *          This is also equivalent to calling\n-     *          {@code getHpackLogger(this::dbgTag, Level.OFF);}.\n@@ -1008,2 +971,0 @@\n-     * @param on  Whether messages should also be printed on\n-     *            stderr (in addition to be forwarded to the internal logger).\n@@ -1013,3 +974,2 @@\n-    public static Logger getWebSocketLogger(Supplier<String> dbgTag, boolean on) {\n-        Level errLevel = on ? Level.ALL : Level.OFF;\n-        return getWebSocketLogger(dbgTag, errLevel);\n+    public static Logger getWebSocketLogger(Supplier<String> dbgTag) {\n+        return DebugLogger.createWebSocketLogger(dbgTag, DEBUG_CONFIG);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":121,"deletions":161,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-            Utils.getWebSocketLogger(\"[Input]\"::toString, Utils.DEBUG_WS);\n+            Utils.getWebSocketLogger(\"[Input]\"::toString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            Utils.getWebSocketLogger(\"[Output]\"::toString, Utils.DEBUG_WS);\n+            Utils.getWebSocketLogger(\"[Output]\"::toString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageEncoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-            Utils.getWebSocketLogger(\"[Transport]\"::toString, Utils.DEBUG_WS);\n+            Utils.getWebSocketLogger(\"[Transport]\"::toString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/TransportImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            Utils.getWebSocketLogger(\"[WebSocket]\"::toString, Utils.DEBUG_WS);\n+            Utils.getWebSocketLogger(\"[WebSocket]\"::toString);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/WebSocketImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.net.http.common.Utils;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+\/*\n+ * @test\n+ * @summary Verify the behaviour of the debug logger.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n+ *        DebugLoggerTest\n+ * @run main\/othervm  DebugLoggerTest\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=errr  DebugLoggerTest\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=err  DebugLoggerTest ERR\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=out  DebugLoggerTest OUT\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=log  DebugLoggerTest LOG\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=true DebugLoggerTest ERR LOG\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=err,OUT  DebugLoggerTest ERR OUT\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=err,out,log DebugLoggerTest ERR OUT LOG\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=true,log DebugLoggerTest ERR LOG\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=true,out DebugLoggerTest ERR OUT LOG\n+ * @run main\/othervm -Djdk.internal.httpclient.debug=err,OUT,foo  DebugLoggerTest ERR OUT\n+ *\/\n+public class DebugLoggerTest {\n+    static final PrintStream stdErr = System.err;\n+    static final PrintStream stdOut = System.out;\n+    static final String LOGGER_NAME = \"jdk.internal.httpclient.debug\";\n+    static final String MESSAGE = \"May the luck of the Irish be with you!\";\n+    static final String MESSAGE2 = \"May the wind be at your back!\";\n+    static final String MESSAGE3 = \"May the sun shine warm upon your face!\";\n+\n+    static RecordingPrintStream err = null;\n+    static RecordingPrintStream out = null;\n+\n+    \/**\n+     * A {@code RecordingPrintStream} is a {@link PrintStream} that makes\n+     * it possible to record part of the data stream in memory while still\n+     * forwarding everything to a delegated {@link OutputStream}.\n+     * @apiNote\n+     * For instance, a {@code RecordingPrintStream} might be used as an\n+     * interceptor to record anything printed on {@code }System.err}\n+     * at specific times. Recording can be started and stopped\n+     * at any time, and multiple times. For instance, a typical\n+     * usage might be:\n+     * <pre>static final PrintStream stderr = System.err;\n+     * static final RecordingPrintString recorder =\n+     *     new RecordingPrintStream(stderr, true, UTF_8);\n+     * static {\n+     *     System.setErr(recorder);\n+     * }\n+     *\n+     * ...\n+     *      \/\/ ....\n+     *      recorder.startRecording();\n+     *      try {\n+     *          \/\/ do something\n+     *          String str1 = recorder.drainRecordedData();\n+     *          \/\/ do something else\n+     *          String str2 = recorder.drainRecordedData();\n+     *          \/\/ ....\n+     *      } finally {\n+     *          recorder.stopRecording();\n+     *      }\n+     *      \/\/ ....\n+     * ...\n+     * <\/pre>\n+     * <p>Though the methods are thread safe, {@link #startRecording()}\n+     * {@link #stopRecording()} and {@link #drainRecordedData()} must\n+     * not be called concurrently by different threads without external\n+     * orchestration, as calling these methods mutate the state of\n+     * the recorder in a way that can be globally observed by all\n+     * threads.\n+     *\/\n+    public static final class RecordingPrintStream extends PrintStream {\n+        private final Charset charset;\n+        private final ByteArrayOutputStream recordedData;\n+        private volatile boolean recording;\n+\n+        \/**\n+         * Creates a new {@code RecordingPrintStream} instance that wraps\n+         * the provided {@code OutputStream}.\n+         * @implSpec Calls {@link PrintStream#PrintStream(\n+         *            OutputStream, boolean, Charset)}.\n+         * @param out An {@code OutputStream} instance to which all bytes will\n+         *            be forwarded.\n+         * @param autoFlush Whether {@linkplain PrintStream#PrintStream(\n+         *            OutputStream, boolean, Charset) autoFlush} is on.\n+         * @param charset A {@linkplain Charset} used to transform text to\n+         *                bytes and bytes to string.\n+         *\/\n+        public RecordingPrintStream(OutputStream out, boolean autoFlush, Charset charset) {\n+            super(out, autoFlush, charset);\n+            this.charset = charset;\n+            recordedData = new ByteArrayOutputStream();\n+        }\n+\n+        \/**\n+         * Flushes the stream and starts recording.\n+         * If recording is already started, this method has no effect beyond\n+         * {@linkplain PrintStream#flush() flushing} the stream.\n+         *\/\n+        public void startRecording() {\n+            flush(); \/\/ make sure everything that was printed before is flushed\n+            synchronized (recordedData) {\n+                recording = true;\n+            }\n+        }\n+\n+        \/**\n+         * Flushes the stream and stops recording.\n+         * If recording is already stopped, this method has no effect beyond\n+         * {@linkplain PrintStream#flush() flushing} the stream.\n+         *\/\n+        public void stopRecording() {\n+            flush(); \/\/ make sure everything that was printed before is flushed\n+            synchronized (recordedData) {\n+                recording = false;\n+            }\n+        }\n+\n+        \/**\n+         * Flushes the stream, drains the recorded data, convert it\n+         * to a string, and returns it. This has the effect of\n+         * flushing any recorded data from memory: the next call\n+         * to {@code drainRecordedData()} will not return any data\n+         * previously returned.\n+         * This method can be called regardless of whether recording\n+         * is started or stopped.\n+         *\/\n+        public String drainRecordedData() {\n+            flush(); \/\/ make sure everything that was printed before is flushed\n+            synchronized (recordedData) {\n+                String data = recordedData.toString(charset);\n+                recordedData.reset();\n+                return data;\n+            }\n+        }\n+\n+        @Override\n+        public void write(int b) {\n+            super.write(b);\n+            if (recording) {\n+                synchronized (recordedData) {\n+                    if (recording) recordedData.write(b);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void write(byte[] buf, int off, int len) {\n+            super.write(buf, off, len);\n+            if (recording) {\n+                synchronized (recordedData) {\n+                    if (recording) recordedData.write(buf, off, len);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class TestHandler extends Handler {\n+        final CopyOnWriteArrayList logs = new CopyOnWriteArrayList();\n+        TestHandler() {\n+            setLevel(Level.ALL);\n+        }\n+        @Override\n+        public void publish(LogRecord record) {\n+            logs.add(record);\n+        }\n+        @Override\n+        public void flush() {\n+        }\n+        @Override\n+        public void close() throws SecurityException {\n+        }\n+    }\n+\n+    enum Destination {OUT, ERR, LOG}\n+\n+    static Set<Destination> getDestinations(String prop) {\n+        if (prop == null) return Set.of();\n+        String[] values = prop.split(\",\");\n+        if (values.length == 0) return Set.of();\n+        Set<Destination> dest = new HashSet<>(3);\n+        for (var v : values) {\n+            v = v.trim().toLowerCase(Locale.ROOT);\n+            if (\"log\".equals(v)) dest.add(Destination.LOG);\n+            if (\"err\".equals(v)) dest.add(Destination.ERR);\n+            if (\"out\".equals(v)) dest.add(Destination.OUT);\n+            if (\"true\".equals(v)) dest.addAll(EnumSet.of(Destination.ERR, Destination.LOG));\n+        }\n+        return Set.copyOf(dest);\n+    }\n+\n+    public static void main(String[] args) {\n+        err =  new RecordingPrintStream(stdErr, true, UTF_8);\n+        out =  new RecordingPrintStream(stdOut, true, UTF_8);\n+        System.setErr(err);\n+        System.setOut(out);\n+        TestHandler logHandler = new TestHandler();\n+        Logger julLogger = Logger.getLogger(LOGGER_NAME);\n+        julLogger.setLevel(Level.ALL);\n+        julLogger.setUseParentHandlers(false);\n+        julLogger.addHandler(logHandler);\n+        System.Logger sysLogger = System.getLogger(LOGGER_NAME);\n+        var debug = Utils.getDebugLogger(() -> \"DebugLoggerTest\", Utils.DEBUG);\n+        String prop = System.getProperty(LOGGER_NAME);\n+        stdOut.printf(\"DebugLoggerTest: [\\\"%s\\\", %s] start%n\", prop, Arrays.asList(args));\n+        var dest = getDestinations(prop);\n+        var dest2 = Stream.of(args)\n+                .map(Destination::valueOf)\n+                .collect(Collectors.toSet());\n+        assertEquals(debug.on(), !dest.isEmpty());\n+        assertEquals(dest, dest2);\n+\n+        Predicate<LogRecord> matcher1 = (r) -> r.getMessage() != null && r.getMessage().contains(MESSAGE);\n+        doTest(() -> debug.log(MESSAGE), logHandler, dest, MESSAGE, matcher1);\n+        Exception thrown = new Exception(MESSAGE3);\n+        Predicate<LogRecord> matcher2 = (r) -> r.getMessage() != null\n+                && r.getMessage().contains(MESSAGE2)\n+                && thrown.equals(r.getThrown());\n+        doTest(() -> debug.log(MESSAGE2, thrown), logHandler, dest, MESSAGE2, matcher2);\n+        stdOut.printf(\"Test [\\\"%s\\\", %s] passed%n\", prop, Arrays.asList(args));\n+    }\n+\n+    private static void doTest(Runnable test,\n+                               TestHandler logHandler,\n+                               Set<Destination> dest,\n+                               String msg,\n+                               Predicate<LogRecord> logMatcher) {\n+        logHandler.logs.clear();\n+        err.drainRecordedData();\n+        out.drainRecordedData();\n+\n+        err.startRecording();\n+        out.startRecording();\n+        test.run();\n+        err.stopRecording();\n+        out.stopRecording();\n+        String outStr = out.drainRecordedData();\n+        String errStr = err.drainRecordedData();\n+        List<LogRecord> logs = logHandler.logs.stream().toList();\n+\n+        if (dest.contains(Destination.ERR)) {\n+            if (!errStr.contains(msg)) {\n+                throw new AssertionError(\"stderr does not contain the expected message\");\n+            }\n+        } else if (errStr.contains(msg)) {\n+            throw new AssertionError(\"stderr should not contain the log message\");\n+        }\n+        if (dest.contains(Destination.OUT)) {\n+            if (!outStr.contains(msg)) {\n+                throw new AssertionError(\"stdout does not contain the expected message\");\n+            }\n+        } else if (outStr.contains(msg)) {\n+            throw new AssertionError(\"stdout should not contain the log message\");\n+        }\n+        boolean logMatches = logs.stream().anyMatch(logMatcher);\n+        if (dest.contains(Destination.LOG)) {\n+            if (!logMatches) {\n+                throw new AssertionError(\"expected message not found in logs\");\n+            }\n+        } else {\n+            if (logMatches) {\n+                throw new AssertionError(\"logs should not contain the message!\");\n+            }\n+        }\n+    }\n+\n+    static void assertEquals(Object o1, Object o2) {\n+        if (!Objects.equals(o1, o2)) {\n+            throw new AssertionError(\"Not equals: \\\"\"\n+                    + o1 + \"\\\" != \\\"\" + o2 + \"\\\"\");\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/DebugLoggerTest.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"}]}