{"files":[{"patch":"@@ -115,1 +115,0 @@\n-\n@@ -117,1 +116,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -999,25 +999,0 @@\n-\/\/ Fill in default values for various flag fields\n-void nmethod::init_defaults() {\n-  \/\/ avoid uninitialized fields, even for short time periods\n-  _exception_cache            = nullptr;\n-  _gc_data                    = nullptr;\n-  _oops_do_mark_link          = nullptr;\n-  _compiled_ic_data           = nullptr;\n-\n-#if INCLUDE_RTM_OPT\n-  _rtm_state                  = NoRTM;\n-#endif\n-  _is_unloading_state         = 0;\n-  _state                      = not_installed;\n-\n-  _has_unsafe_access          = 0;\n-  _has_method_handle_invokes  = 0;\n-  _has_wide_vectors           = 0;\n-  _has_monitors               = 0;\n-  _has_flushed_dependencies   = 0;\n-  _is_unlinked                = 0;\n-  _load_reported              = 0; \/\/ jvmti state\n-\n-  _deoptimization_status      = not_marked;\n-}\n-\n@@ -1198,0 +1173,47 @@\n+\/\/ Fill in default values for various fields\n+void nmethod::init_defaults(CodeBuffer *code_buffer, CodeOffsets* offsets) {\n+  \/\/ avoid uninitialized fields, even for short time periods\n+  _exception_cache            = nullptr;\n+  _gc_data                    = nullptr;\n+  _oops_do_mark_link          = nullptr;\n+  _compiled_ic_data           = nullptr;\n+\n+#if INCLUDE_RTM_OPT\n+  _rtm_state                  = NoRTM;\n+#endif\n+  _is_unloading_state         = 0;\n+  _state                      = not_installed;\n+\n+  _has_unsafe_access          = 0;\n+  _has_method_handle_invokes  = 0;\n+  _has_wide_vectors           = 0;\n+  _has_monitors               = 0;\n+  _has_flushed_dependencies   = 0;\n+  _is_unlinked                = 0;\n+  _load_reported              = 0; \/\/ jvmti state\n+\n+  _deoptimization_status      = not_marked;\n+\n+  \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n+  int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n+  assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n+\n+  _entry_offset          = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n+  _verified_entry_offset = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n+  _stub_offset           = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n+\n+  _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n+}\n+\n+\/\/ Post initialization\n+void nmethod::post_init() {\n+  clear_unloading_state();\n+\n+  finalize_relocations();\n+\n+  Universe::heap()->register_nmethod(this);\n+  debug_only(Universe::heap()->verify_nmethod(this));\n+\n+  CodeCache::commit(this);\n+}\n+\n@@ -1213,0 +1235,1 @@\n+  _gc_epoch(CodeCache::gc_epoch()),\n@@ -1221,2 +1244,3 @@\n-    init_defaults();\n-    _comp_level              = CompLevel_none;\n+    init_defaults(code_buffer, offsets);\n+\n+    _osr_entry_point         = nullptr;\n@@ -1224,3 +1248,3 @@\n-    \/\/ We have no exception handler or deopt handler make the\n-    \/\/ values something that will never match a pc like the nmethod vtable entry\n-    _exception_offset        = 0;\n+    _compile_id              = compile_id;\n+    _comp_level              = CompLevel_none;\n+    _compiler_type           = type;\n@@ -1228,0 +1252,9 @@\n+\n+    if (offsets->value(CodeOffsets::Exceptions) != -1) {\n+      \/\/ Continuation enter intrinsic\n+      _exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n+    } else {\n+      _exception_offset      = 0;\n+    }\n+    \/\/ Native wrappers do not have deopt handlers. Make the values\n+    \/\/ something that will never match a pc like the nmethod vtable entry\n@@ -1231,7 +1264,0 @@\n-    _gc_epoch                = CodeCache::gc_epoch();\n-\n-    \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n-    int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n-    assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n-\n-    _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n@@ -1239,1 +1265,0 @@\n-    _stub_offset             = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n@@ -1261,5 +1286,0 @@\n-    _compile_id              = compile_id;\n-    _compiler_type           = type;\n-    _entry_offset            = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n-    _verified_entry_offset   = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n-    _osr_entry_point         = nullptr;\n@@ -1268,3 +1288,0 @@\n-    if (offsets->value(CodeOffsets::Exceptions) != -1) {\n-      _exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n-    }\n@@ -1274,8 +1291,1 @@\n-    clear_unloading_state();\n-\n-    finalize_relocations();\n-\n-    Universe::heap()->register_nmethod(this);\n-    debug_only(Universe::heap()->verify_nmethod(this));\n-\n-    CodeCache::commit(this);\n+    post_init();\n@@ -1339,0 +1349,1 @@\n+\/\/ For normal JIT compiled code\n@@ -1365,0 +1376,1 @@\n+  _gc_epoch(CodeCache::gc_epoch()),\n@@ -1373,11 +1385,1 @@\n-    init_defaults();\n-    _entry_bci      = entry_bci;\n-    _compile_id     = compile_id;\n-    _compiler_type  = type;\n-    _comp_level     = comp_level;\n-    _orig_pc_offset = orig_pc_offset;\n-    _gc_epoch       = CodeCache::gc_epoch();\n-\n-    \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n-    int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n-    assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n+    init_defaults(code_buffer, offsets);\n@@ -1385,1 +1387,6 @@\n-    _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n+    _osr_entry_point = code_begin() + offsets->value(CodeOffsets::OSR_Entry);\n+    _entry_bci       = entry_bci;\n+    _compile_id      = compile_id;\n+    _comp_level      = comp_level;\n+    _compiler_type   = type;\n+    _orig_pc_offset  = orig_pc_offset;\n@@ -1387,1 +1394,0 @@\n-    _stub_offset = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n@@ -1451,4 +1457,1 @@\n-    _entry_offset          = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n-    _verified_entry_offset = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n-    _osr_entry_point       = code_begin()          + offsets->value(CodeOffsets::OSR_Entry);\n-\n+    \/\/ after _scopes_pcs_offset is set\n@@ -1462,1 +1465,0 @@\n-    clear_unloading_state();\n@@ -1471,7 +1473,0 @@\n-    finalize_relocations();\n-\n-    Universe::heap()->register_nmethod(this);\n-    debug_only(Universe::heap()->verify_nmethod(this));\n-\n-    CodeCache::commit(this);\n-\n@@ -1488,0 +1483,2 @@\n+\n+    post_init();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":76,"deletions":79,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -297,0 +297,6 @@\n+  \/\/ Initialize fields to their default values\n+  void init_defaults(CodeBuffer *code_buffer, CodeOffsets* offsets);\n+\n+  \/\/ Post initialization\n+  void post_init();\n+\n@@ -309,1 +315,1 @@\n-  \/\/ Creation support\n+  \/\/ For normal JIT compiled code\n@@ -353,3 +359,0 @@\n-  \/\/ Initialize fields to their default values\n-  void init_defaults();\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"}]}