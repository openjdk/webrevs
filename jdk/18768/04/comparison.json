{"files":[{"patch":"@@ -76,36 +76,2 @@\n-#ifdef ASSERT\n-void CodeBlob::verify_parameters() {\n-  assert(is_aligned(_size,            oopSize), \"unaligned size\");\n-  assert(is_aligned(_header_size,     oopSize), \"unaligned size\");\n-  assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n-  assert(_data_offset <= size(), \"codeBlob is too small\");\n-  assert(code_end() == content_end(), \"must be the same - see code_end()\");\n-#ifdef COMPILER1\n-  \/\/ probably wrong for tiered\n-  assert(frame_size() >= -1, \"must use frame size or -1 for runtime stubs\");\n-#endif \/\/ COMPILER1\n-}\n-#endif\n-\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n-                   int content_offset, int code_offset, int frame_complete_offset, int data_offset,\n-                   int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments) :\n-  _oop_maps(oop_maps),\n-  _name(name),\n-  _size(size),\n-  _header_size(header_size),\n-  _relocation_size(relocation_size),\n-  _content_offset(content_offset),\n-  _code_offset(code_offset),\n-  _frame_complete_offset(frame_complete_offset),\n-  _data_offset(data_offset),\n-  _frame_size(frame_size),\n-  S390_ONLY(_ctable_offset(0) COMMA)\n-  _kind(kind),\n-  _caller_must_gc_arguments(caller_must_gc_arguments)\n-{\n-  DEBUG_ONLY( verify_parameters(); )\n-}\n-\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n-                   int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size,\n+                   int16_t frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n@@ -115,1 +81,0 @@\n-  _header_size(header_size),\n@@ -117,1 +82,1 @@\n-  _content_offset(CodeBlob::align_code_offset(_header_size + _relocation_size)),\n+  _content_offset(CodeBlob::align_code_offset(header_size + _relocation_size)),\n@@ -119,1 +84,0 @@\n-  _frame_complete_offset(frame_complete_offset),\n@@ -123,0 +87,2 @@\n+  _header_size(header_size),\n+  _frame_complete_offset(frame_complete_offset),\n@@ -126,1 +92,9 @@\n-  DEBUG_ONLY( verify_parameters(); )\n+  assert(is_aligned(_size,            oopSize), \"unaligned size\");\n+  assert(is_aligned(header_size,      oopSize), \"unaligned size\");\n+  assert(is_aligned(_relocation_size, oopSize), \"unaligned size\");\n+  assert(_data_offset <= _size, \"codeBlob is too small: %d > %d\", _data_offset, _size);\n+  assert(code_end() == content_end(), \"must be the same - see code_end()\");\n+#ifdef COMPILER1\n+  \/\/ probably wrong for tiered\n+  assert(_frame_size >= -1, \"must use frame size or -1 for runtime stubs\");\n+#endif \/\/ COMPILER1\n@@ -132,1 +106,1 @@\n-CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size) :\n+CodeBlob::CodeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size) :\n@@ -136,1 +110,0 @@\n-  _header_size(header_size),\n@@ -140,1 +113,0 @@\n-  _frame_complete_offset(CodeOffsets::frame_never_safe),\n@@ -143,0 +115,1 @@\n+\n@@ -144,0 +117,3 @@\n+\n+  _header_size(header_size),\n+  _frame_complete_offset(CodeOffsets::frame_never_safe),\n@@ -151,1 +127,1 @@\n-void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n+void CodeBlob::purge() {\n@@ -188,2 +164,2 @@\n-  int         header_size,\n-  int         frame_complete,\n+  uint16_t    header_size,\n+  int16_t     frame_complete,\n@@ -201,1 +177,1 @@\n-  blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n+  blob->purge();\n@@ -411,1 +387,1 @@\n-  int         frame_complete,\n+  int16_t     frame_complete,\n@@ -423,1 +399,1 @@\n-                                           int frame_complete,\n+                                           int16_t frame_complete,\n@@ -671,4 +647,0 @@\n-void UpcallStub::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n-  ShouldNotReachHere(); \/\/ caller should never have to gc arguments\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":25,"deletions":53,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-class UpcallStub; \/\/ for as_upcall_stub()\n-class RuntimeStub; \/\/ for as_runtime_stub()\n+class UpcallStub;      \/\/ for as_upcall_stub()\n+class RuntimeStub;     \/\/ for as_runtime_stub()\n@@ -104,1 +104,1 @@\n-  ImmutableOopMapSet* _oop_maps;                 \/\/ OopMap for this CodeBlob\n+  ImmutableOopMapSet* _oop_maps;   \/\/ OopMap for this CodeBlob\n@@ -107,11 +107,4 @@\n-  int        _size;                              \/\/ total size of CodeBlob in bytes\n-  int        _header_size;                       \/\/ size of header (depends on subclass)\n-  int        _relocation_size;                   \/\/ size of relocation\n-  int        _content_offset;                    \/\/ offset to where content region begins (this includes consts, insts, stubs)\n-  int        _code_offset;                       \/\/ offset to where instructions region begins (this includes insts, stubs)\n-  int        _frame_complete_offset;             \/\/ instruction offsets in [0.._frame_complete_offset) have\n-                                                 \/\/ not finished setting up their frame. Beware of pc's in\n-                                                 \/\/ that range. There is a similar range(s) on returns\n-                                                 \/\/ which we don't detect.\n-  int        _data_offset;                       \/\/ offset to where data region begins\n-  int        _frame_size;                        \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n+  int      _size;                  \/\/ total size of CodeBlob in bytes\n+  int      _relocation_size;       \/\/ size of relocation (could be bigger than 64Kb)\n+  int      _content_offset;        \/\/ offset to where content region begins (this includes consts, insts, stubs)\n+  int      _code_offset;           \/\/ offset to where instructions region begins (this includes insts, stubs)\n@@ -119,1 +112,2 @@\n-  S390_ONLY(int       _ctable_offset;)\n+  int      _data_offset;           \/\/ offset to where data region begins\n+  int      _frame_size;            \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n@@ -121,1 +115,1 @@\n-  CodeBlobKind        _kind;                     \/\/ Kind of this code blob\n+  S390_ONLY(int _ctable_offset;)\n@@ -123,1 +117,9 @@\n-  bool                _caller_must_gc_arguments;\n+  uint16_t _header_size;           \/\/ size of header (depends on subclass)\n+  int16_t  _frame_complete_offset; \/\/ instruction offsets in [0.._frame_complete_offset) have\n+                                   \/\/ not finished setting up their frame. Beware of pc's in\n+                                   \/\/ that range. There is a similar range(s) on returns\n+                                   \/\/ which we don't detect.\n+\n+  CodeBlobKind _kind;              \/\/ Kind of this code blob\n+\n+  bool _caller_must_gc_arguments;\n@@ -128,7 +130,1 @@\n-#endif \/\/ not PRODUCT\n-\n-  DEBUG_ONLY( void verify_parameters() );\n-\n-  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size, int relocation_size,\n-           int content_offset, int code_offset, int data_offset, int frame_complete_offset,\n-           int frame_size, ImmutableOopMapSet* oop_maps, bool caller_must_gc_arguments);\n+#endif\n@@ -136,2 +132,2 @@\n-  CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, int header_size,\n-           int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments);\n+  CodeBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size,\n+           int16_t frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments);\n@@ -140,1 +136,1 @@\n-  CodeBlob(const char* name, CodeBlobKind kind, int size, int header_size);\n+  CodeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size);\n@@ -155,1 +151,1 @@\n-  virtual void purge(bool free_code_cache_data, bool unregister_nmethod);\n+  void purge();\n@@ -228,1 +224,0 @@\n-  virtual void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) = 0;\n@@ -276,1 +271,1 @@\n-  RuntimeBlob(const char* name, CodeBlobKind kind, int size, int header_size)\n+  RuntimeBlob(const char* name, CodeBlobKind kind, int size, uint16_t header_size)\n@@ -288,2 +283,2 @@\n-    int         header_size,\n-    int         frame_complete,\n+    uint16_t    header_size,\n+    int16_t     frame_complete,\n@@ -327,3 +322,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n-\n+  \/\/ Verification support\n@@ -331,0 +324,1 @@\n+\n@@ -384,1 +378,1 @@\n-    int         frame_complete,\n+    int16_t     frame_complete,\n@@ -397,1 +391,1 @@\n-    int         frame_complete,\n+    int16_t     frame_complete,\n@@ -408,3 +402,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n-\n+  \/\/ Verification support\n@@ -412,0 +404,1 @@\n+\n@@ -432,1 +425,1 @@\n-     int          header_size,\n+     uint16_t     header_size,\n@@ -441,2 +434,1 @@\n-  \/\/ GC\/Verification support\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override { \/* nothing to do *\/ }\n+  \/\/ Verification support\n@@ -444,0 +436,1 @@\n+\n@@ -635,1 +628,0 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) override;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -247,1 +247,0 @@\n-  int chunks_reshared;\n@@ -251,4 +250,2 @@\n-    tty->print_cr(\"Debug Data Chunks: %d, shared %d+%d, non-SP's elided %d\",\n-                  chunks_queried,\n-                  chunks_shared, chunks_reshared,\n-                  chunks_elided);\n+    tty->print_cr(\"Debug Data Chunks: %d, shared %d, non-SP's elided %d\",\n+                  chunks_queried, chunks_shared, chunks_elided);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -391,3 +391,1 @@\n-  Copy::disjoint_words((HeapWord*) content_bytes(),\n-                       (HeapWord*) beg,\n-                       size_in_bytes() \/ sizeof(HeapWord));\n+  (void)memcpy(beg, content_bytes(), size_in_bytes());\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -140,3 +140,0 @@\n-  uint size_gt_32k;\n-  int size_max;\n-\n@@ -161,3 +158,0 @@\n-    int short_pos_max = ((1<<15) - 1);\n-    if (nm->size() > short_pos_max) size_gt_32k++;\n-    if (nm->size() > size_max) size_max = nm->size();\n@@ -186,2 +180,0 @@\n-    if (size_gt_32k != 0)         tty->print_cr(\" size > 32k     = %u\", size_gt_32k);\n-    if (size_max != 0)            tty->print_cr(\" max size       = %d\", size_max);\n@@ -1011,0 +1003,9 @@\n+  _gc_data                    = nullptr;\n+  _oops_do_mark_link          = nullptr;\n+  _compiled_ic_data           = nullptr;\n+\n+#if INCLUDE_RTM_OPT\n+  _rtm_state                  = NoRTM;\n+#endif\n+  _is_unloading_state         = 0;\n+  _state                      = not_installed;\n@@ -1016,2 +1017,0 @@\n-\n-  _state                      = not_installed;\n@@ -1019,1 +1018,2 @@\n-  _load_reported              = false; \/\/ jvmti state\n+  _is_unlinked                = 0;\n+  _load_reported              = 0; \/\/ jvmti state\n@@ -1021,5 +1021,1 @@\n-  _oops_do_mark_link          = nullptr;\n-  _osr_link                   = nullptr;\n-#if INCLUDE_RTM_OPT\n-  _rtm_state                  = NoRTM;\n-#endif\n+  _deoptimization_status      = not_marked;\n@@ -1218,3 +1214,0 @@\n-  _gc_data(nullptr),\n-  _compiled_ic_data(nullptr),\n-  _is_unlinked(false),\n@@ -1222,3 +1215,1 @@\n-  _native_basic_lock_sp_offset(basic_lock_sp_offset),\n-  _is_unloading_state(0),\n-  _deoptimization_status(not_marked)\n+  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n@@ -1239,0 +1230,1 @@\n+    _unwind_handler_offset   = 0;\n@@ -1241,8 +1233,18 @@\n-    _consts_offset           = content_offset()      + code_buffer->total_offset_of(code_buffer->consts());\n-    _stub_offset             = content_offset()      + code_buffer->total_offset_of(code_buffer->stubs());\n-    _oops_offset             = data_offset();\n-    _metadata_offset         = _oops_offset          + align_up(code_buffer->total_oop_size(), oopSize);\n-    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n-    _scopes_pcs_offset       = _scopes_data_offset;\n-    _dependencies_offset     = _scopes_pcs_offset;\n-    _handler_table_offset    = _dependencies_offset;\n+    \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n+    int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n+    assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n+\n+    _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n+\n+    _stub_offset             = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n+#ifdef ASSERT\n+    int oops_size     = align_up(code_buffer->total_oop_size(), oopSize);\n+    int metadata_size = align_up(code_buffer->total_metadata_size(), wordSize);\n+    int sum_size      = oops_size + metadata_size;\n+    assert((sum_size >> 16) == 0, \"data size is bigger than 64Kb: %d\", sum_size);\n+#endif\n+    _metadata_offset         = checked_cast<uint16_t>(align_up(code_buffer->total_oop_size(), oopSize));\n+    _dependencies_offset     = _metadata_offset + checked_cast<uint16_t>(align_up(code_buffer->total_metadata_size(), wordSize));\n+    _scopes_pcs_offset       = _dependencies_offset;\n+    _scopes_data_offset      = _scopes_pcs_offset;\n+    _handler_table_offset    = _scopes_data_offset;\n@@ -1250,1 +1252,0 @@\n-    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -1254,1 +1255,1 @@\n-    _nmethod_end_offset      = _jvmci_data_offset;\n+    DEBUG_ONLY( int data_end_offset = _jvmci_data_offset; )\n@@ -1256,1 +1257,1 @@\n-    _nmethod_end_offset      = _nul_chk_table_offset;\n+    DEBUG_ONLY( int data_end_offset = _nul_chk_table_offset; )\n@@ -1258,0 +1259,2 @@\n+    assert((data_offset() + data_end_offset) <= nmethod_size, \"wrong nmethod's size: %d < %d\", nmethod_size, (data_offset() + data_end_offset));\n+\n@@ -1260,2 +1263,2 @@\n-    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n-    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n+    _entry_offset            = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n+    _verified_entry_offset   = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n@@ -1263,1 +1266,0 @@\n-    _exception_cache         = nullptr;\n@@ -1266,2 +1268,3 @@\n-    _exception_offset        = code_offset()         + offsets->value(CodeOffsets::Exceptions);\n-\n+    if (offsets->value(CodeOffsets::Exceptions) != -1) {\n+      _exception_offset      = code_offset() + offsets->value(CodeOffsets::Exceptions);\n+    }\n@@ -1363,7 +1366,1 @@\n-  _gc_data(nullptr),\n-  _compiled_ic_data(nullptr),\n-  _is_unlinked(false),\n-  _native_receiver_sp_offset(in_ByteSize(-1)),\n-  _native_basic_lock_sp_offset(in_ByteSize(-1)),\n-  _is_unloading_state(0),\n-  _deoptimization_status(not_marked)\n+  _osr_link(nullptr)\n@@ -1384,5 +1381,8 @@\n-    \/\/ Section offsets\n-    _consts_offset  = content_offset() + code_buffer->total_offset_of(code_buffer->consts());\n-    _stub_offset    = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n-    set_ctable_begin(header_begin() + _consts_offset);\n-    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n+    \/\/ SECT_CONSTS is first in code buffer so the offset should be 0.\n+    int consts_offset = code_buffer->total_offset_of(code_buffer->consts());\n+    assert(consts_offset == 0, \"const_offset: %d\", consts_offset);\n+\n+    _skipped_instructions_size = checked_cast<uint16_t>(code_buffer->total_skipped_instructions_size());\n+\n+    _stub_offset = content_offset() + code_buffer->total_offset_of(code_buffer->stubs());\n+    set_ctable_begin(header_begin() + content_offset());\n@@ -1428,9 +1428,13 @@\n-\n-    _oops_offset             = data_offset();\n-    _metadata_offset         = _oops_offset          + align_up(code_buffer->total_oop_size(), oopSize);\n-    _scopes_data_offset      = _metadata_offset      + align_up(code_buffer->total_metadata_size(), wordSize);\n-\n-    _scopes_pcs_offset       = _scopes_data_offset   + align_up(debug_info->data_size       (), oopSize);\n-    _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n-    _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies->size_in_bytes(), oopSize);\n-    _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n+#ifdef ASSERT\n+    int oops_size     = align_up(code_buffer->total_oop_size(), oopSize);\n+    int metadata_size = align_up(code_buffer->total_metadata_size(), wordSize);\n+    int deps_size     = align_up((int)dependencies->size_in_bytes(), oopSize);\n+    int sum_size      = oops_size + metadata_size + deps_size;\n+    assert((sum_size >> 16) == 0, \"data size is bigger than 64Kb: %d\", sum_size);\n+#endif\n+    _metadata_offset      = checked_cast<uint16_t>(align_up(code_buffer->total_oop_size(), oopSize));\n+    _dependencies_offset  = _metadata_offset      + checked_cast<uint16_t>(align_up(code_buffer->total_metadata_size(), wordSize));\n+    _scopes_pcs_offset    = _dependencies_offset  + checked_cast<uint16_t>(align_up((int)dependencies->size_in_bytes(), oopSize));\n+    _scopes_data_offset   = _scopes_pcs_offset    + adjust_pcs_size(debug_info->pcs_size());\n+    _handler_table_offset = _scopes_data_offset   + align_up(debug_info->data_size       (), oopSize);\n+    _nul_chk_table_offset = _handler_table_offset + align_up(handler_table->size_in_bytes(), oopSize);\n@@ -1438,4 +1442,4 @@\n-    _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n-    _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);\n-    int jvmci_data_size      = compiler->is_jvmci() ? jvmci_data->size() : 0;\n-    _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);\n+    _speculations_offset  = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n+    _jvmci_data_offset    = _speculations_offset  + align_up(speculations_len, oopSize);\n+    int jvmci_data_size   = compiler->is_jvmci() ? jvmci_data->size() : 0;\n+    DEBUG_ONLY( int data_end_offset = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize); )\n@@ -1443,1 +1447,1 @@\n-    _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize);\n+    DEBUG_ONLY( int data_end_offset = _nul_chk_table_offset + align_up(nul_chk_table->size_in_bytes(), oopSize); )\n@@ -1445,4 +1449,5 @@\n-    _entry_point             = code_begin()          + offsets->value(CodeOffsets::Entry);\n-    _verified_entry_point    = code_begin()          + offsets->value(CodeOffsets::Verified_Entry);\n-    _osr_entry_point         = code_begin()          + offsets->value(CodeOffsets::OSR_Entry);\n-    _exception_cache         = nullptr;\n+    assert((data_offset() + data_end_offset) <= nmethod_size, \"wrong nmethod's size: %d < %d\", nmethod_size, (data_offset() + data_end_offset));\n+\n+    _entry_offset          = checked_cast<uint16_t>(offsets->value(CodeOffsets::Entry));\n+    _verified_entry_offset = checked_cast<uint16_t>(offsets->value(CodeOffsets::Verified_Entry));\n+    _osr_entry_point       = code_begin()          + offsets->value(CodeOffsets::OSR_Entry);\n@@ -1487,1 +1492,1 @@\n-           _method->is_static() == (entry_point() == _verified_entry_point),\n+           _method->is_static() == (entry_point() == verified_entry_point()),\n@@ -2000,1 +2005,1 @@\n-  if (_is_unlinked) {\n+  if (is_unlinked()) {\n@@ -2034,2 +2039,1 @@\n-void nmethod::purge(bool free_code_cache_data, bool unregister_nmethod) {\n-  assert(!free_code_cache_data, \"must only call not freeing code cache data\");\n+void nmethod::purge(bool unregister_nmethod) {\n@@ -2063,1 +2067,1 @@\n-  CodeBlob::purge(free_code_cache_data, unregister_nmethod);\n+  CodeBlob::purge();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":77,"deletions":73,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -191,2 +191,17 @@\n-  \/\/ To support simple linked-list chaining of nmethods:\n-  nmethod*  _osr_link;         \/\/ from InstanceKlass::osr_nmethods_head\n+  \/\/ To reduce header size union fields which usages do not overlap.\n+  union {\n+    \/\/ To support simple linked-list chaining of nmethods:\n+    nmethod*  _osr_link; \/\/ from InstanceKlass::osr_nmethods_head\n+    struct {\n+      \/\/ These are used for compiled synchronized native methods to\n+      \/\/ locate the owner and stack slot for the BasicLock. They are\n+      \/\/ needed because there is no debug information for compiled native\n+      \/\/ wrappers and the oop maps are insufficient to allow\n+      \/\/ frame::retrieve_receiver() to work. Currently they are expected\n+      \/\/ to be byte offsets from the Java stack pointer for maximum code\n+      \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n+      \/\/ offsets to find the receiver for non-static native wrapper frames.\n+      ByteSize _native_receiver_sp_offset;\n+      ByteSize _native_basic_lock_sp_offset;\n+    };\n+  };\n@@ -203,0 +218,2 @@\n+  CompiledICData* _compiled_ic_data;\n+\n@@ -204,3 +221,4 @@\n-  address _entry_point;                      \/\/ entry point with class check\n-  address _verified_entry_point;             \/\/ entry point without class check\n-  address _osr_entry_point;                  \/\/ entry point for on stack replacement\n+  address  _osr_entry_point;       \/\/ entry point for on stack replacement\n+  uint16_t _entry_offset;          \/\/ entry point with class check\n+  uint16_t _verified_entry_offset; \/\/ entry point without class check\n+  int      _entry_bci;             \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n@@ -208,1 +226,1 @@\n-  CompiledICData* _compiled_ic_data;\n+  \/\/ _consts_offset == _content_offset because SECT_CONSTS is first in code buffer\n@@ -210,2 +228,1 @@\n-  \/\/ Shared fields for all nmethod's\n-  int _entry_bci;      \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n+  int _stub_offset;\n@@ -213,2 +230,2 @@\n-  \/\/ Offsets for different nmethod parts\n-  int  _exception_offset;\n+  \/\/ Offsets for different stubs section parts\n+  int _exception_offset;\n@@ -224,9 +241,9 @@\n-  int _consts_offset;\n-  int _stub_offset;\n-  int _oops_offset;                       \/\/ offset to where embedded oop table begins (inside data)\n-  int _metadata_offset;                   \/\/ embedded meta data table\n-  int _scopes_data_offset;\n-  int _scopes_pcs_offset;\n-  int _dependencies_offset;\n-  int _handler_table_offset;\n-  int _nul_chk_table_offset;\n+  uint16_t _skipped_instructions_size;\n+\n+  \/\/ _oops_offset == _data_offset,  offset where embedded oop table begins (inside data)\n+  uint16_t _metadata_offset; \/\/ embedded meta data table\n+  uint16_t _dependencies_offset;\n+  uint16_t _scopes_pcs_offset;\n+  int      _scopes_data_offset;\n+  int      _handler_table_offset;\n+  int      _nul_chk_table_offset;\n@@ -234,2 +251,2 @@\n-  int _speculations_offset;\n-  int _jvmci_data_offset;\n+  int      _speculations_offset;\n+  int      _jvmci_data_offset;\n@@ -237,2 +254,0 @@\n-  int _nmethod_end_offset;\n-  int _skipped_instructions_size;\n@@ -244,5 +259,3 @@\n-  int _compile_id;                        \/\/ which compilation made this nmethod\n-\n-  CompilerType _compiler_type;            \/\/ which compiler made this nmethod (u1)\n-\n-  bool _is_unlinked;\n+  int          _compile_id;            \/\/ which compilation made this nmethod\n+  CompLevel    _comp_level;            \/\/ compilation level (s1)\n+  CompilerType _compiler_type;         \/\/ which compiler made this nmethod (u1)\n@@ -256,13 +269,0 @@\n-  \/\/ These are used for compiled synchronized native methods to\n-  \/\/ locate the owner and stack slot for the BasicLock. They are\n-  \/\/ needed because there is no debug information for compiled native\n-  \/\/ wrappers and the oop maps are insufficient to allow\n-  \/\/ frame::retrieve_receiver() to work. Currently they are expected\n-  \/\/ to be byte offsets from the Java stack pointer for maximum code\n-  \/\/ sharing between platforms. JVMTI's GetLocalInstance() uses these\n-  \/\/ offsets to find the receiver for non-static native wrapper frames.\n-  ByteSize _native_receiver_sp_offset;\n-  ByteSize _native_basic_lock_sp_offset;\n-\n-  CompLevel _comp_level;               \/\/ compilation level (s1)\n-\n@@ -272,3 +272,0 @@\n-  \/\/ used by jvmti to track if an event has been posted for this nmethod.\n-  bool _load_reported;\n-\n@@ -283,1 +280,3 @@\n-          _has_flushed_dependencies:1; \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+          _has_flushed_dependencies:1, \/\/ Used for maintenance of dependencies (under CodeCache_lock)\n+          _is_unlinked:1,              \/\/ mark during class unloading\n+          _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n@@ -524,3 +523,3 @@\n-  address consts_begin          () const { return           header_begin() + _consts_offset           ; }\n-  address consts_end            () const { return           header_begin() +  code_offset()           ; }\n-  address insts_begin           () const { return           header_begin() +  code_offset()           ; }\n+  address consts_begin          () const { return           content_begin(); }\n+  address consts_end            () const { return           code_begin()   ; }\n+  address insts_begin           () const { return           code_begin()   ; }\n@@ -529,1 +528,1 @@\n-  address stub_end              () const { return           header_begin() + _oops_offset             ; }\n+  address stub_end              () const { return           data_begin()   ; }\n@@ -534,15 +533,16 @@\n-  oop*    oops_begin            () const { return (oop*)   (header_begin() + _oops_offset)            ; }\n-  oop*    oops_end              () const { return (oop*)   (header_begin() + _metadata_offset)        ; }\n-\n-  Metadata** metadata_begin     () const { return (Metadata**) (header_begin() + _metadata_offset)    ; }\n-  Metadata** metadata_end       () const { return (Metadata**) (header_begin() + _scopes_data_offset) ; }\n-\n-  address scopes_data_begin     () const { return           header_begin() + _scopes_data_offset      ; }\n-  address scopes_data_end       () const { return           header_begin() + _scopes_pcs_offset       ; }\n-  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(header_begin() + _scopes_pcs_offset)      ; }\n-  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(header_begin() + _dependencies_offset)    ; }\n-  address dependencies_begin    () const { return           header_begin() + _dependencies_offset     ; }\n-  address dependencies_end      () const { return           header_begin() + _handler_table_offset    ; }\n-  address handler_table_begin   () const { return           header_begin() + _handler_table_offset    ; }\n-  address handler_table_end     () const { return           header_begin() + _nul_chk_table_offset    ; }\n-  address nul_chk_table_begin   () const { return           header_begin() + _nul_chk_table_offset    ; }\n+\n+  oop*    oops_begin            () const { return (oop*)    data_begin(); }\n+  oop*    oops_end              () const { return (oop*)   (data_begin() + _metadata_offset)          ; }\n+\n+  Metadata** metadata_begin     () const { return (Metadata**) (data_begin() + _metadata_offset)      ; }\n+  Metadata** metadata_end       () const { return (Metadata**) (data_begin() + _dependencies_offset)  ; }\n+\n+  address dependencies_begin    () const { return           data_begin() + _dependencies_offset       ; }\n+  address dependencies_end      () const { return           data_begin() + _scopes_pcs_offset         ; }\n+  PcDesc* scopes_pcs_begin      () const { return (PcDesc*)(data_begin() + _scopes_pcs_offset)        ; }\n+  PcDesc* scopes_pcs_end        () const { return (PcDesc*)(data_begin() + _scopes_data_offset)       ; }\n+  address scopes_data_begin     () const { return           data_begin() + _scopes_data_offset        ; }\n+  address scopes_data_end       () const { return           data_begin() + _handler_table_offset      ; }\n+  address handler_table_begin   () const { return           data_begin() + _handler_table_offset      ; }\n+  address handler_table_end     () const { return           data_begin() + _nul_chk_table_offset      ; }\n+  address nul_chk_table_begin   () const { return           data_begin() + _nul_chk_table_offset      ; }\n@@ -551,5 +551,5 @@\n-  address nul_chk_table_end     () const { return           header_begin() + _speculations_offset     ; }\n-  address speculations_begin    () const { return           header_begin() + _speculations_offset     ; }\n-  address speculations_end      () const { return           header_begin() + _jvmci_data_offset       ; }\n-  address jvmci_data_begin      () const { return           header_begin() + _jvmci_data_offset       ; }\n-  address jvmci_data_end        () const { return           header_begin() + _nmethod_end_offset      ; }\n+  address nul_chk_table_end     () const { return           data_begin() + _speculations_offset       ; }\n+  address speculations_begin    () const { return           data_begin() + _speculations_offset       ; }\n+  address speculations_end      () const { return           data_begin() + _jvmci_data_offset         ; }\n+  address jvmci_data_begin      () const { return           data_begin() + _jvmci_data_offset         ; }\n+  address jvmci_data_end        () const { return           data_end(); }\n@@ -557,1 +557,1 @@\n-  address nul_chk_table_end     () const { return           header_begin() + _nmethod_end_offset      ; }\n+  address nul_chk_table_end     () const { return           data_end(); }\n@@ -597,2 +597,2 @@\n-  address entry_point() const          { return _entry_point;          } \/\/ normal entry point\n-  address verified_entry_point() const { return _verified_entry_point; } \/\/ if klass is correct\n+  address entry_point() const          { return code_begin() + _entry_offset;          } \/\/ normal entry point\n+  address verified_entry_point() const { return code_begin() + _verified_entry_offset; } \/\/ if klass is correct\n@@ -618,3 +618,0 @@\n-  bool is_unlinked() const             { return _is_unlinked; }\n-  void set_is_unlinked()               { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n-\n@@ -680,0 +677,6 @@\n+  bool  is_unlinked() const                       { return _is_unlinked; }\n+  void  set_is_unlinked()                         {\n+     assert(!_is_unlinked, \"already unlinked\");\n+      _is_unlinked = true;\n+  }\n+\n@@ -724,1 +727,0 @@\n-  void set_exception_cache(ExceptionCache *ec)    { _exception_cache = ec; }\n@@ -753,1 +755,1 @@\n-  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) override;\n+  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f);\n@@ -789,5 +791,5 @@\n-  int   osr_entry_bci() const                     { assert(is_osr_method(), \"wrong kind of nmethod\"); return _entry_bci; }\n-  address  osr_entry() const                      { assert(is_osr_method(), \"wrong kind of nmethod\"); return _osr_entry_point; }\n-  void  invalidate_osr_method();\n-  nmethod* osr_link() const                       { return _osr_link; }\n-  void     set_osr_link(nmethod *n)               { _osr_link = n; }\n+  int      osr_entry_bci()    const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _entry_bci; }\n+  address  osr_entry()        const { assert(is_osr_method(), \"wrong kind of nmethod\"); return _osr_entry_point; }\n+  nmethod* osr_link()         const { return _osr_link; }\n+  void     set_osr_link(nmethod *n) { _osr_link = n; }\n+  void     invalidate_osr_method();\n@@ -802,1 +804,1 @@\n-  void purge(bool free_code_cache_data, bool unregister_nmethod) override;\n+  void purge(bool unregister_nmethod);\n@@ -967,0 +969,1 @@\n+    assert(is_native_method(), \"sanity\");\n@@ -970,0 +973,1 @@\n+    assert(is_native_method(), \"sanity\");\n@@ -974,3 +978,2 @@\n-  static ByteSize verified_entry_point_offset() { return byte_offset_of(nmethod, _verified_entry_point); }\n-  static ByteSize osr_entry_point_offset()      { return byte_offset_of(nmethod, _osr_entry_point); }\n-  static ByteSize state_offset()                { return byte_offset_of(nmethod, _state); }\n+  static ByteSize osr_entry_point_offset() { return byte_offset_of(nmethod, _osr_entry_point); }\n+  static ByteSize state_offset()           { return byte_offset_of(nmethod, _state); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":89,"deletions":86,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -1796,1 +1796,1 @@\n-    blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n+    blob->purge();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-enum RTMState {\n+enum RTMState: u1 {\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-      nm->purge(false \/* free_code_cache_data *\/, _unregister_nmethods_during_purge);\n+      nm->purge(_unregister_nmethods_during_purge);\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  nonstatic_field(nmethod,                     _verified_entry_point,                         address)                               \\\n+  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    size_t  _length;                             \/\/ the length in segments\n-    bool    _used;                               \/\/ Used bit\n+    uint32_t  _length;                           \/\/ the length in segments\n+    bool      _used;                             \/\/ Used bit\n@@ -54,1 +54,1 @@\n-  void initialize(size_t length)                 { _header._length = length; set_used(); }\n+  void initialize(size_t length)                 { set_length(length); set_used(); }\n@@ -56,1 +56,3 @@\n-  void set_length(size_t length)                 { _header._length = length; }\n+  void set_length(size_t length)                 {\n+    _header._length = checked_cast<uint32_t>(length);\n+  }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -977,2 +977,3 @@\n-    if (reg_map->include_argument_oops()) {\n-      _cb->preserve_callee_argument_oops(*this, reg_map, f);\n+    if (reg_map->include_argument_oops() && _cb->is_nmethod()) {\n+      \/\/ Only nmethod preserves outgoing arguments at call.\n+      _cb->as_nmethod()->preserve_callee_argument_oops(*this, reg_map, f);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  nonstatic_field(HeapBlock::Header,           _length,                                       size_t)                                \\\n+  nonstatic_field(HeapBlock::Header,           _length,                                       uint32_t)                              \\\n@@ -553,1 +553,1 @@\n-  nonstatic_field(CodeBlob,                    _header_size,                                  int)                                   \\\n+  nonstatic_field(CodeBlob,                    _header_size,                                  u2)                                    \\\n@@ -557,1 +557,1 @@\n-  nonstatic_field(CodeBlob,                    _frame_complete_offset,                        int)                                   \\\n+  nonstatic_field(CodeBlob,                    _frame_complete_offset,                        int16_t)                               \\\n@@ -578,3 +578,2 @@\n-  nonstatic_field(nmethod,                     _consts_offset,                                int)                                   \\\n-  nonstatic_field(nmethod,                     _oops_offset,                                  int)                                   \\\n-  nonstatic_field(nmethod,                     _metadata_offset,                              int)                                   \\\n+  nonstatic_field(nmethod,                     _metadata_offset,                              u2)                                    \\\n+  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            u2)                                    \\\n@@ -582,2 +581,1 @@\n-  nonstatic_field(nmethod,                     _scopes_pcs_offset,                            int)                                   \\\n-  nonstatic_field(nmethod,                     _dependencies_offset,                          int)                                   \\\n+  nonstatic_field(nmethod,                     _dependencies_offset,                          u2)                                    \\\n@@ -586,3 +584,2 @@\n-  nonstatic_field(nmethod,                     _nmethod_end_offset,                           int)                                   \\\n-  nonstatic_field(nmethod,                     _entry_point,                                  address)                               \\\n-  nonstatic_field(nmethod,                     _verified_entry_point,                         address)                               \\\n+  nonstatic_field(nmethod,                     _entry_offset,                                 u2)                                    \\\n+  nonstatic_field(nmethod,                     _verified_entry_offset,                        u2)                                    \\\n@@ -1134,0 +1131,1 @@\n+  declare_integer_type(int16_t)                                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.oops.CIntField;\n@@ -32,0 +33,1 @@\n+import sun.jvm.hotspot.types.JShortField;\n@@ -44,1 +46,0 @@\n-  private static CIntegerField headerSizeField;\n@@ -46,0 +47,1 @@\n+  private static CIntField     headerSizeField;\n@@ -48,1 +50,1 @@\n-  private static CIntegerField frameCompleteOffsetField;\n+  private static CIntField     frameCompleteOffsetField;\n@@ -64,1 +66,0 @@\n-    headerSizeField          = type.getCIntegerField(\"_header_size\");\n@@ -66,0 +67,1 @@\n+    headerSizeField          = new CIntField(type.getCIntegerField(\"_header_size\"), 0);\n@@ -68,1 +70,1 @@\n-    frameCompleteOffsetField = type.getCIntegerField(\"_frame_complete_offset\");\n+    frameCompleteOffsetField = new CIntField(type.getCIntegerField(\"_frame_complete_offset\"), 0);\n@@ -106,1 +108,1 @@\n-  public int getCodeOffset()      { return (int) codeOffsetField   .getValue(addr); }\n+  public int getCodeOffset()      { return (int) codeOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,2 +52,3 @@\n-  private static CIntegerField oopsOffsetField;\n-  private static CIntegerField metadataOffsetField;\n+  private static CIntField     metadataOffsetField;\n+  private static CIntField     dependenciesOffsetField;\n+  private static CIntField     scopesPCsOffsetField;\n@@ -55,2 +56,0 @@\n-  private static CIntegerField scopesPCsOffsetField;\n-  private static CIntegerField dependenciesOffsetField;\n@@ -59,1 +58,0 @@\n-  private static CIntegerField nmethodEndOffsetField;\n@@ -63,1 +61,1 @@\n-  private static AddressField  entryPointField;\n+  private static CIntField  entryOffsetField;\n@@ -65,1 +63,1 @@\n-  private static AddressField  verifiedEntryPointField;\n+  private static CIntField  verifiedEntryOffsetField;\n@@ -71,1 +69,1 @@\n-  private static CIntegerField compLevelField;\n+  private static CIntField compLevelField;\n@@ -93,2 +91,3 @@\n-    oopsOffsetField             = type.getCIntegerField(\"_oops_offset\");\n-    metadataOffsetField         = type.getCIntegerField(\"_metadata_offset\");\n+    metadataOffsetField         = new CIntField(type.getCIntegerField(\"_metadata_offset\"), 0);\n+    dependenciesOffsetField     = new CIntField(type.getCIntegerField(\"_dependencies_offset\"), 0);\n+    scopesPCsOffsetField        = new CIntField(type.getCIntegerField(\"_scopes_pcs_offset\"), 0);\n@@ -96,2 +95,0 @@\n-    scopesPCsOffsetField        = type.getCIntegerField(\"_scopes_pcs_offset\");\n-    dependenciesOffsetField     = type.getCIntegerField(\"_dependencies_offset\");\n@@ -100,3 +97,2 @@\n-    nmethodEndOffsetField       = type.getCIntegerField(\"_nmethod_end_offset\");\n-    entryPointField             = type.getAddressField(\"_entry_point\");\n-    verifiedEntryPointField     = type.getAddressField(\"_verified_entry_point\");\n+    entryOffsetField            = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n+    verifiedEntryOffsetField    = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n@@ -104,1 +100,1 @@\n-    compLevelField              = type.getCIntegerField(\"_comp_level\");\n+    compLevelField              = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n@@ -129,1 +125,1 @@\n-  public Address constantsEnd()         { return getEntryPoint();                                    }\n+  public Address constantsEnd()         { return codeBegin();                                        }\n@@ -136,15 +132,15 @@\n-  public Address stubEnd()              { return headerBegin().addOffsetTo(getOopsOffset());         }\n-  public Address oopsBegin()            { return headerBegin().addOffsetTo(getOopsOffset());         }\n-  public Address oopsEnd()              { return headerBegin().addOffsetTo(getMetadataOffset());     }\n-  public Address metadataBegin()        { return headerBegin().addOffsetTo(getMetadataOffset());     }\n-  public Address metadataEnd()          { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataBegin()      { return headerBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataEnd()        { return headerBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsBegin()       { return headerBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsEnd()         { return headerBegin().addOffsetTo(getDependenciesOffset()); }\n-  public Address dependenciesBegin()    { return headerBegin().addOffsetTo(getDependenciesOffset()); }\n-  public Address dependenciesEnd()      { return headerBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableBegin()    { return headerBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableEnd()      { return headerBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableBegin()     { return headerBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableEnd()       { return headerBegin().addOffsetTo(getNMethodEndOffset());   }\n+  public Address stubEnd()              { return dataBegin();                                        }\n+  public Address oopsBegin()            { return dataBegin();                                        }\n+  public Address oopsEnd()              { return dataBegin().addOffsetTo(getMetadataOffset());       }\n+  public Address metadataBegin()        { return dataBegin().addOffsetTo(getMetadataOffset());       }\n+  public Address metadataEnd()          { return dataBegin().addOffsetTo(getDependenciesOffset());   }\n+  public Address dependenciesBegin()    { return dataBegin().addOffsetTo(getDependenciesOffset());   }\n+  public Address dependenciesEnd()      { return dataBegin().addOffsetTo(getScopesDataOffset());     }\n+  public Address scopesDataBegin()      { return dataBegin().addOffsetTo(getScopesDataOffset());     }\n+  public Address scopesDataEnd()        { return dataBegin().addOffsetTo(getScopesPCsOffset());      }\n+  public Address scopesPCsBegin()       { return dataBegin().addOffsetTo(getScopesPCsOffset());      }\n+  public Address scopesPCsEnd()         { return dataBegin().addOffsetTo(getHandlerTableOffset());   }\n+  public Address handlerTableBegin()    { return dataBegin().addOffsetTo(getHandlerTableOffset());   }\n+  public Address handlerTableEnd()      { return dataBegin().addOffsetTo(getNulChkTableOffset());    }\n+  public Address nulChkTableBegin()     { return dataBegin().addOffsetTo(getNulChkTableOffset());    }\n+  public Address nulChkTableEnd()       { return dataEnd();                                          }\n@@ -190,2 +186,2 @@\n-  public Address getEntryPoint()         { return entryPointField.getValue(addr);         }\n-  public Address getVerifiedEntryPoint() { return verifiedEntryPointField.getValue(addr); }\n+  public Address getEntryPoint()         { return codeBegin().addOffsetTo(getEntryPointOffset());         }\n+  public Address getVerifiedEntryPoint() { return codeBegin().addOffsetTo(getVerifiedEntryPointOffset()); }\n@@ -435,5 +431,5 @@\n-  public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }\n-  public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }\n-  public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }\n-  public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }\n-  public static int getMethodOffset()                { return (int) methodField.getOffset();                }\n+  public int getEntryPointOffset()            { return (int) entryOffsetField.getValue(addr);        }\n+  public int getVerifiedEntryPointOffset()    { return (int) verifiedEntryOffsetField.getValue(addr);}\n+  public static int getOSREntryPointOffset()  { return (int) osrEntryPointField.getOffset();         }\n+  public static int getEntryBCIOffset()       { return (int) entryBCIField.getOffset();              }\n+  public static int getMethodOffset()         { return (int) methodField.getOffset();                }\n@@ -520,1 +516,0 @@\n-  private int getOopsOffset()         { return (int) oopsOffsetField        .getValue(addr); }\n@@ -527,1 +522,0 @@\n-  private int getNMethodEndOffset()   { return (int) nmethodEndOffsetField  .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":35,"deletions":41,"binary":false,"changes":76,"status":"modified"}]}