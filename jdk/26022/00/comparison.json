{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,2 @@\n+\n+import sun.nio.cs.UTF_8;\n@@ -78,7 +81,1 @@\n-    private Writer out;\n-\n-    private char[] cb;\n-    private int nChars;\n-    private int nextChar;\n-    private final int maxChars;  \/\/ maximum number of buffers chars\n-\n+    private final BufferedImpl impl;\n@@ -105,4 +102,6 @@\n-        this.out = out;\n-        this.cb = new char[initialSize];\n-        this.nChars = initialSize;\n-        this.maxChars = maxSize;\n+        if (out instanceof OutputStreamWriter w && w.se.getCharset() == UTF_8.INSTANCE) {\n+            w.se.growByteBufferIfEmptyNeeded(initialSize);\n+            this.impl = new OutputStreamWriterImpl(w);\n+        } else {\n+            this.impl = new WriterImpl(out, initialSize, maxSize);\n+        }\n@@ -136,20 +135,1 @@\n-        if (out == null)\n-            throw new IOException(\"Stream closed\");\n-    }\n-\n-    \/**\n-     * Grow char array to fit an additional len characters if needed.\n-     * If possible, it grows by len+1 to avoid flushing when len chars\n-     * are added.\n-     *\n-     * This method should only be called while holding the lock.\n-     *\/\n-    private void growIfNeeded(int len) {\n-        int neededSize = nextChar + len + 1;\n-        if (neededSize < 0)\n-            neededSize = Integer.MAX_VALUE;\n-        if (neededSize > nChars && nChars < maxChars) {\n-            int newSize = min(neededSize, maxChars);\n-            cb = Arrays.copyOf(cb, newSize);\n-            nChars = newSize;\n-        }\n+        impl.ensureOpen();\n@@ -163,1 +143,1 @@\n-    void flushBuffer() throws IOException {\n+    final void flushBuffer() throws IOException {\n@@ -165,5 +145,1 @@\n-            ensureOpen();\n-            if (nextChar == 0)\n-                return;\n-            out.write(cb, 0, nextChar);\n-            nextChar = 0;\n+            impl.flushBuffer();\n@@ -180,5 +156,1 @@\n-            ensureOpen();\n-            growIfNeeded(1);\n-            if (nextChar >= nChars)\n-                flushBuffer();\n-            cb[nextChar++] = (char) c;\n+            impl.write(c);\n@@ -188,9 +160,0 @@\n-    \/**\n-     * Our own little min method, to avoid loading java.lang.Math if we've run\n-     * out of file descriptors and we're trying to print a stack trace.\n-     *\/\n-    private int min(int a, int b) {\n-        if (a < b) return a;\n-        return b;\n-    }\n-\n@@ -220,26 +183,1 @@\n-            ensureOpen();\n-            Objects.checkFromIndexSize(off, len, cbuf.length);\n-            if (len == 0) {\n-                return;\n-            }\n-\n-            if (len >= maxChars) {\n-                \/* If the request length exceeds the max size of the output buffer,\n-                   flush the buffer and then write the data directly.  In this\n-                   way buffered streams will cascade harmlessly. *\/\n-                flushBuffer();\n-                out.write(cbuf, off, len);\n-                return;\n-            }\n-\n-            growIfNeeded(len);\n-            int b = off, t = off + len;\n-            while (b < t) {\n-                int d = min(nChars - nextChar, t - b);\n-                System.arraycopy(cbuf, b, cb, nextChar, d);\n-                b += d;\n-                nextChar += d;\n-                if (nextChar >= nChars) {\n-                    flushBuffer();\n-                }\n-            }\n+            impl.write(cbuf, off, len);\n@@ -273,11 +211,1 @@\n-            ensureOpen();\n-            growIfNeeded(len);\n-            int b = off, t = off + len;\n-            while (b < t) {\n-                int d = min(nChars - nextChar, t - b);\n-                s.getChars(b, b + d, cb, nextChar);\n-                b += d;\n-                nextChar += d;\n-                if (nextChar >= nChars)\n-                    flushBuffer();\n-            }\n+            impl.write(s, off, len);\n@@ -305,2 +233,1 @@\n-            flushBuffer();\n-            out.flush();\n+            impl.flush();\n@@ -313,0 +240,176 @@\n+            impl.close();\n+        }\n+    }\n+\n+    private static abstract sealed class BufferedImpl permits WriterImpl, OutputStreamWriterImpl {\n+        Writer out;\n+\n+        public BufferedImpl(Writer out) {\n+            this.out = out;\n+        }\n+\n+        \/** Checks to make sure that the stream has not been closed *\/\n+        final void ensureOpen() throws IOException {\n+            if (out == null)\n+                throw new IOException(\"Stream closed\");\n+        }\n+\n+        abstract void flushBuffer() throws IOException;\n+\n+        abstract void write(int c) throws IOException;\n+\n+        abstract void write(char[] cbuf, int off, int len) throws IOException;\n+\n+        abstract void write(String s, int off, int len) throws IOException;\n+\n+        abstract void flush() throws IOException;\n+\n+        abstract void close() throws IOException;\n+    }\n+\n+    private static final class WriterImpl extends BufferedImpl {\n+        private char[] cb;\n+        private int nChars;\n+        private int nextChar;\n+        private final int maxChars;  \/\/ maximum number of buffers chars\n+\n+        WriterImpl(Writer out, int initialSize, int maxSize) {\n+            super(out);\n+            this.cb = new char[initialSize];\n+            this.nChars = initialSize;\n+            this.maxChars = maxSize;\n+        }\n+\n+        \/**\n+         * Grow char array to fit an additional len characters if needed.\n+         * If possible, it grows by len+1 to avoid flushing when len chars\n+         * are added.\n+         *\n+         * This method should only be called while holding the lock.\n+         *\/\n+        private void growIfNeeded(int len) {\n+            int neededSize = nextChar + len + 1;\n+            if (neededSize < 0)\n+                neededSize = Integer.MAX_VALUE;\n+            if (neededSize > nChars && nChars < maxChars) {\n+                int newSize = min(neededSize, maxChars);\n+                cb = Arrays.copyOf(cb, newSize);\n+                nChars = newSize;\n+            }\n+        }\n+\n+        @Override\n+        void flushBuffer() throws IOException {\n+            ensureOpen();\n+            if (nextChar == 0)\n+                return;\n+            out.write(cb, 0, nextChar);\n+            nextChar = 0;\n+        }\n+\n+        \/**\n+         * Writes a single character.\n+         *\n+         * @throws     IOException  If an I\/O error occurs\n+         *\/\n+        @Override\n+        void write(int c) throws IOException {\n+            ensureOpen();\n+            growIfNeeded(1);\n+            if (nextChar >= nChars)\n+                flushBuffer();\n+            cb[nextChar++] = (char) c;\n+        }\n+\n+        \/**\n+         * Writes a portion of an array of characters.\n+         *\n+         * <p> Ordinarily this method stores characters from the given array into\n+         * this stream's buffer, flushing the buffer to the underlying stream as\n+         * needed.  If the requested length is at least as large as the buffer,\n+         * however, then this method will flush the buffer and write the characters\n+         * directly to the underlying stream.  Thus redundant\n+         * {@code BufferedWriter}s will not copy data unnecessarily.\n+         *\n+         * @param  cbuf  A character array\n+         * @param  off   Offset from which to start reading characters\n+         * @param  len   Number of characters to write\n+         *\n+         * @throws  IndexOutOfBoundsException\n+         *          If {@code off} is negative, or {@code len} is negative,\n+         *          or {@code off + len} is negative or greater than the length\n+         *          of the given array\n+         *\n+         * @throws  IOException  If an I\/O error occurs\n+         *\/\n+        @Override\n+        void write(char[] cbuf, int off, int len) throws IOException {\n+            ensureOpen();\n+            Objects.checkFromIndexSize(off, len, cbuf.length);\n+            if (len == 0) {\n+                return;\n+            }\n+\n+            if (len >= maxChars) {\n+                \/* If the request length exceeds the max size of the output buffer,\n+                   flush the buffer and then write the data directly.  In this\n+                   way buffered streams will cascade harmlessly. *\/\n+                flushBuffer();\n+                out.write(cbuf, off, len);\n+                return;\n+            }\n+\n+            growIfNeeded(len);\n+            int b = off, t = off + len;\n+            while (b < t) {\n+                int d = min(nChars - nextChar, t - b);\n+                System.arraycopy(cbuf, b, cb, nextChar, d);\n+                b += d;\n+                nextChar += d;\n+                if (nextChar >= nChars) {\n+                    flushBuffer();\n+                }\n+            }\n+        }\n+\n+\n+        \/**\n+         * Writes a portion of a String.\n+         *\n+         * @implSpec\n+         * While the specification of this method in the\n+         * {@linkplain java.io.Writer#write(java.lang.String,int,int) superclass}\n+         * recommends that an {@link IndexOutOfBoundsException} be thrown\n+         * if {@code len} is negative or {@code off + len} is negative,\n+         * the implementation in this class does not throw such an exception in\n+         * these cases but instead simply writes no characters.\n+         *\n+         * @param  s     String to be written\n+         * @param  off   Offset from which to start reading characters\n+         * @param  len   Number of characters to be written\n+         *\n+         * @throws  IndexOutOfBoundsException\n+         *          If {@code off} is negative,\n+         *          or {@code off + len} is greater than the length\n+         *          of the given string\n+         *\n+         * @throws  IOException  If an I\/O error occurs\n+         *\/\n+        @Override\n+        void write(String s, int off, int len) throws IOException {\n+            ensureOpen();\n+            growIfNeeded(len);\n+            int b = off, t = off + len;\n+            while (b < t) {\n+                int d = min(nChars - nextChar, t - b);\n+                s.getChars(b, b + d, cb, nextChar);\n+                b += d;\n+                nextChar += d;\n+                if (nextChar >= nChars)\n+                    flushBuffer();\n+            }\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        void close() throws IOException {\n@@ -323,0 +426,65 @@\n+\n+        \/**\n+         * Flushes the stream.\n+         *\n+         * @throws     IOException  If an I\/O error occurs\n+         *\/\n+        @Override\n+        void flush() throws IOException {\n+            flushBuffer();\n+            out.flush();\n+        }\n+\n+        \/**\n+         * Our own little min method, to avoid loading java.lang.Math if we've run\n+         * out of file descriptors and we're trying to print a stack trace.\n+         *\/\n+        private static int min(int a, int b) {\n+            return a < b ? a : b;\n+        }\n+    }\n+\n+    private static final class OutputStreamWriterImpl extends BufferedImpl {\n+        OutputStreamWriter os;\n+        OutputStreamWriterImpl(OutputStreamWriter out) {\n+            super(out);\n+            this.os = out;\n+        }\n+\n+        @Override\n+        void flushBuffer() throws IOException {\n+            os.flushBuffer();\n+        }\n+\n+        @Override\n+        void write(int c) throws IOException {\n+            os.write(new char[] {(char) c});\n+        }\n+\n+        @Override\n+        void write(char[] cbuf, int off, int len) throws IOException {\n+            os.write(cbuf, off, len);\n+        }\n+\n+        @Override\n+        void write(String s, int off, int len) throws IOException {\n+            os.write(s, off, len);\n+        }\n+\n+        @Override\n+        void flush() throws IOException {\n+            os.flush();\n+        }\n+\n+        @Override\n+        void close() throws IOException {\n+            if (out == null) {\n+                return;\n+            }\n+            try (OutputStreamWriter w = os) {\n+                w.flushBuffer();\n+            } finally {\n+                out = null;\n+                os = null;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":259,"deletions":91,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    private final StreamEncoder se;\n+    final StreamEncoder se;\n","filename":"src\/java.base\/share\/classes\/java\/io\/OutputStreamWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1284,1 +1284,1 @@\n-            return encodeUTF8_UTF16(val, doReplace);\n+            return encodeUTF8_UTF16(val, 0, val.length >> 1, doReplace);\n@@ -1307,1 +1307,45 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    long computeSizeUTF8(int sp, int sl) {\n+        byte[] val = this.value;\n+        if (!isLatin1()) {\n+            return computeSizeUTF8_UTF16(val, true);\n+        }\n+\n+        int count = StringCoding.countPositives(val, sp, sl);\n+        if (count == sl) {\n+            return count;\n+        }\n+\n+        int i = count;\n+        count = sl;\n+        while (i < sl) {\n+            if (val[i++] < 0) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    int encodeUTF8(int sp, int sl, byte[] dst, int dp) {\n+        byte[] val = this.value;\n+        if (!isLatin1()) {\n+            return encodeUTF8_UTF16(val, sp, sl, true, dst, dp);\n+        }\n+\n+        if (!StringCoding.hasNegatives(val, sp, sl)) {\n+            System.arraycopy(val, sp, dst, dp, sl);\n+            return dp + sl;\n+        }\n+\n+        for (int i = 0; i < sl; i++) {\n+            byte c = val[sp + i];\n+            if (c < 0) {\n+                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n+                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n+            } else {\n+                dst[dp++] = c;\n+            }\n+        }\n+        return dp;\n+    }\n+\n+    private static byte[] encodeUTF8_UTF16(byte[] val, int sp, int sl, boolean doReplace) {\n@@ -1309,2 +1353,0 @@\n-        int sp = 0;\n-        int sl = val.length >> 1;\n@@ -1318,1 +1360,10 @@\n-        while (sp < sl) {\n+        dp = encodeUTF8_UTF16(val, 0, sl, doReplace, dst, dp);\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static int encodeUTF8_UTF16(byte[] val, int sp, int sl, boolean doReplace, byte[] dst, int dp) {\n+        int end = sp + sl;\n+        while (sp < end) {\n@@ -1327,1 +1378,1 @@\n-        while (sp < sl) {\n+        while (sp < end) {\n@@ -1361,4 +1412,1 @@\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n+        return dp;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":58,"deletions":10,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2212,0 +2212,4 @@\n+            public int encodeUTF8(String s, int sp, int sl, byte[] dst, int dp) {\n+                return s.encodeUTF8(sp, sl, dst, dp);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,0 +490,2 @@\n+    int encodeUTF8(String s, int sp, int sl, byte[] dst, int dp);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2054, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -41,1 +42,5 @@\n-public final class StreamEncoder extends Writer {\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+public sealed class StreamEncoder extends Writer permits StreamEncoder.UTF8Impl {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -60,1 +65,1 @@\n-            return new StreamEncoder(out, lock, Charset.forName(charsetName));\n+            return forOutputStreamWriter(out, lock, Charset.forName(charsetName));\n@@ -70,0 +75,3 @@\n+        if (cs == UTF_8.INSTANCE) {\n+            return new UTF8Impl(out, lock);\n+        }\n@@ -92,1 +100,1 @@\n-    public String getEncoding() {\n+    public final String getEncoding() {\n@@ -98,1 +106,5 @@\n-    public void flushBuffer() throws IOException {\n+    public Charset getCharset() {\n+        return cs;\n+    }\n+\n+    public final void flushBuffer() throws IOException {\n@@ -107,1 +119,1 @@\n-    public void write(int c) throws IOException {\n+    public final void write(int c) throws IOException {\n@@ -113,1 +125,1 @@\n-    public void write(char[] cbuf, int off, int len) throws IOException {\n+    public final void write(char[] cbuf, int off, int len) throws IOException {\n@@ -135,1 +147,1 @@\n-    public void write(CharBuffer cb) throws IOException {\n+    public final void write(CharBuffer cb) throws IOException {\n@@ -147,1 +159,1 @@\n-    public void flush() throws IOException {\n+    public final void flush() throws IOException {\n@@ -154,1 +166,1 @@\n-    public void close() throws IOException {\n+    public final void close() throws IOException {\n@@ -175,2 +187,2 @@\n-    private ByteBuffer bb;\n-    private final int maxBufferCapacity;\n+    protected ByteBuffer bb;\n+    protected final int maxBufferCapacity;\n@@ -178,1 +190,1 @@\n-    private final OutputStream out;\n+    protected final OutputStream out;\n@@ -181,1 +193,1 @@\n-    private boolean haveLeftoverChar = false;\n+    protected boolean haveLeftoverChar = false;\n@@ -185,1 +197,1 @@\n-    private StreamEncoder(OutputStream out, Object lock, Charset cs) {\n+    StreamEncoder(OutputStream out, Object lock, Charset cs) {\n@@ -263,1 +275,1 @@\n-    void implWrite(char[] cbuf, int off, int len)\n+    final void implWrite(char[] cbuf, int off, int len)\n@@ -270,1 +282,1 @@\n-    void implWrite(CharBuffer cb)\n+    final void implWrite(CharBuffer cb)\n@@ -298,0 +310,14 @@\n+    public final void growByteBufferIfEmptyNeeded(int len) {\n+        if (bb.position() != 0) {\n+            return;\n+        }\n+        int cap = bb.capacity();\n+        if (cap < maxBufferCapacity) {\n+            int maxBytes = len;\n+            int newCap = Math.min(maxBytes, maxBufferCapacity);\n+            if (newCap > cap) {\n+                bb = ByteBuffer.allocate(newCap);\n+            }\n+        }\n+    }\n+\n@@ -301,1 +327,1 @@\n-    void growByteBufferIfNeeded(int len) throws IOException {\n+    public final void growByteBufferIfNeeded(int len) throws IOException {\n@@ -313,1 +339,1 @@\n-    void implFlushBuffer() throws IOException {\n+    final void implFlushBuffer() throws IOException {\n@@ -319,1 +345,1 @@\n-    void implFlush() throws IOException {\n+    final void implFlush() throws IOException {\n@@ -324,1 +350,1 @@\n-    void implClose() throws IOException {\n+    final void implClose() throws IOException {\n@@ -348,1 +374,1 @@\n-    String encodingName() {\n+    final String encodingName() {\n@@ -353,0 +379,46 @@\n+\n+    private final static class UTF8Impl extends StreamEncoder {\n+        UTF8Impl(OutputStream out, Object lock) {\n+            super(out, lock, UTF_8.INSTANCE);\n+        }\n+\n+        public void write(String str, int off, int len) throws IOException {\n+            \/* Check the len before creating a char buffer *\/\n+            if (len < 0)\n+                throw new IndexOutOfBoundsException();\n+            if (haveLeftoverChar) {\n+                super.write(str, off, len);\n+                return;\n+            }\n+\n+            int utf8Size = len * 3;\n+            if (utf8Size >= maxBufferCapacity) {\n+                byte[] utf8 = new byte[utf8Size];\n+                utf8Size = JLA.encodeUTF8(str, off, len, utf8, 0);\n+                \/* If the request length exceeds the max size of the output buffer,\n+                   flush the buffer and then write the data directly.  In this\n+                   way buffered streams will cascade harmlessly. *\/\n+                implFlushBuffer();\n+                out.write(utf8, 0, utf8Size);\n+                return;\n+            }\n+\n+            int cap = bb.capacity();\n+            int newCap = bb.position() + utf8Size;\n+            if (newCap >= maxBufferCapacity) {\n+                implFlushBuffer();\n+            }\n+\n+            if (newCap > cap) {\n+                implFlushBuffer();\n+                bb = ByteBuffer.allocate(newCap);\n+            }\n+\n+            byte[] cb = bb.array();\n+            int lim = bb.limit();\n+            int pos = bb.position();\n+\n+            pos = JLA.encodeUTF8(str, off, len, cb, pos);\n+            bb.position(pos);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":94,"deletions":22,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.io;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HexFormat;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(2)\n+@Measurement(iterations = 6, time = 1)\n+@Warmup(iterations = 4, time = 2)\n+@State(Scope.Thread)\n+public class BufferedWriterBench {\n+\n+    @Param({\"ascii\", \"utf8_2_bytes\", \"utf8_3_bytes\", \"emoji\"})\n+    public String charType;\n+\n+    @Param({\"UTF8\"})\n+    public String charset;\n+\n+    ByteArrayOutputStream bytesOutput;\n+    BufferedWriter dataOutput;\n+    String[] strings;\n+    char[][] charArrays;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws Exception {\n+        byte[] bytes = HexFormat.of().parseHex(\n+                switch (charType) {\n+                    case \"ascii\"        -> \"78\";\n+                    case \"utf8_2_bytes\" -> \"c2a9\";\n+                    case \"utf8_3_bytes\" -> \"e6b8a9\";\n+                    case \"emoji\"        -> \"e29da3efb88f\";\n+                    default -> throw new IllegalArgumentException(\"bad charType: \" + charType);\n+                }\n+        );\n+        String s = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n+        strings = new String[128];\n+        charArrays = new char[strings.length][];\n+        for (int i = 0; i < strings.length; i++) {\n+            strings[i] = \"A\".repeat(i).concat(s.repeat(i));\n+            charArrays[i] = strings[i].toCharArray();\n+        }\n+\n+        bytesOutput = new ByteArrayOutputStream(1024 * 64);\n+        dataOutput = new BufferedWriter(\n+                new OutputStreamWriter(bytesOutput, Charset.forName(charset)));\n+    }\n+\n+    @Benchmark\n+    public void writeString(Blackhole bh) throws Exception {\n+        bytesOutput.reset();\n+        for (var s : strings) {\n+            dataOutput.write(s);\n+        }\n+        dataOutput.flush();\n+        bh.consume(bytesOutput.size());\n+    }\n+\n+    @Benchmark\n+    public void writeCharArray(Blackhole bh) throws Exception {\n+        bytesOutput.reset();\n+        for (var s : charArrays) {\n+            dataOutput.write(s);\n+        }\n+        dataOutput.flush();\n+        bh.consume(bytesOutput.size());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/BufferedWriterBench.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}