{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.util.random.RandomSupport.*;\n@@ -40,0 +39,2 @@\n+import static java.lang.Math.*;\n+\n@@ -255,0 +256,241 @@\n+    private DoubleStream equiDoubles(double left, double right,\n+            boolean isLeftClosed, boolean isRightOpen) {\n+        \/*\n+         * Inspired by\n+         *      Goualard, \"Drawing random floating-point numbers from an\n+         *      interval\", ACM TOMACS, 2022, 32 (3)\n+         *      (https:\/\/hal.science\/hal-03282794v4)\n+         * although implemented differently.\n+         *\n+         * It is assumed that left <= right.\n+         * Whether the boundaries of the interval I = <left, right> are included\n+         * is indicated by isLeftClosed and isRightOpen.\n+         *\n+         * delta > 0 is the smallest double such that every product k delta\n+         * (k integer) that lies in I is an exact double as well.\n+         * It turns out that delta is always a power of 2.\n+         *\n+         * kl is the k for the leftmost product k delta in I.\n+         * kr is the k for the leftmost product k delta to the right of I.\n+         * n is kr - kl\n+         *\/\n+        double delta;\n+        long kl;\n+        long kr;\n+        long n;\n+\n+        if (left <= -right) {\n+            \/*\n+             * Here,\n+             *      left <= 0,      left <= right <= -left\n+             *      P = Double.PRECISION\n+             *\n+             * delta is the distance from left to the next double in the\n+             * direction of positive infinity.\n+             * Every product k delta lying in [left, -left] is an exact double.\n+             * Thus, every product k delta lying in I is an exact double, too.\n+             * Any other positive eps < delta does not meet this property:\n+             * some product k eps lying in I is not an exact double.\n+             * On the other hand, any other eps > delta would generate more\n+             * sparse products k eps, that is, less doubles in I.\n+             * delta is therefore the best value to ensure the largest number\n+             * of equidistant doubles in I.\n+             *\n+             * left \/ delta is an exact double and an exact integer with\n+             *      -2^P <= left \/ delta <= 0\n+             * Thus, kl is computed exactly.\n+             *\n+             * Mathematically,\n+             *      kr = ceil(right \/ delta),           if isRightOpen\n+             *      kr = floor(right \/ delta) + 1,      if !isRightOpen\n+             * The double division rd = right \/ delta never overflows and is\n+             * exact, except in the presence of underflows. But even underflows\n+             * do not affect the outcomes of ceil() and floor(), except,\n+             * in turn, when the result drops to 0, that is, rd = 0.\n+             *\n+             * crd is a corrected version of rd when rd is zero. It is simply\n+             * right \/ delta, but rounded away from 0 to preserve information\n+             * ensuring correct outcomes in ceil() and floor().\n+             *\n+             * We know that -2^P <= kl, so\n+             *      -2^P <= kl + nextLong(n)\n+             * Also, since right <= -left, we know that\n+             *      kr <= -kl + 1\n+             * so that\n+             *      0 < n <= -2 kl + 1\n+             * This implies\n+             *      kl + nextLong(n) <= kl + (-2 kl) = -kl <= 2^P\n+             * and thus\n+             *      -2^P <= kl + nextLong(n) <= 2^P\n+             * which shows that kl + nextLong(n) can be cast exactly to double.\n+             *\n+             * Further, if isLeftClosed then left = kl delta, so that we get\n+             *      left = kl * delta <= (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would have\n+             *      (k + nextLong(n)) * delta < left\n+             * Otherwise, left = (kl - 1) delta, and therefore\n+             *      left = (kl - 1) * delta < (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would get\n+             *      (k + nextLong(n)) * delta <= left\n+             * Either way, the lhs expression would not belong to I.\n+             * That is, kl is the smallest integer such that kl delta always\n+             * lies in I (it is an exact double).\n+             *\n+             * Similar considerations show that kr is the smallest integer such\n+             * that kr delta lies to the right of I (it is an exact double).\n+             *\n+             * All the above means that (kl + nextLong(n)) * delta is an exact\n+             * double lying in I and that kl and kr, thus n, are the best\n+             * possible choices to ensure the largest number of equidistant\n+             * doubles in I. Uniform distribution relies on the guarantee\n+             * afforded by nextLong().\n+             *\/\n+            delta = nextUp(left) - left;\n+            double rd = right \/ delta;\n+            double crd = rd != 0 || right == 0 ? rd : copySign(Double.MIN_VALUE, right);\n+            kr = isRightOpen ? (long) ceil(crd) : (long) floor(crd) + 1;\n+            kl = (long) (left \/ delta) + (isLeftClosed ? 0 : 1);\n+        } else {\n+            \/* Here,\n+             *      right > 0,      -right < left <= right\n+             *\n+             * Considerations similar to the ones above apply here as well.\n+             *\/\n+            delta = right - nextDown(right);\n+            double ld = left \/ delta;\n+            double cld = ld != 0 || left == 0 ? ld : copySign(Double.MIN_VALUE, left);\n+            kl = isLeftClosed ? (long) ceil(cld) : (long) floor(cld) + 1;\n+            kr = (long) (right \/ delta) + (isRightOpen ? 0 : 1);\n+        }\n+        n = kr - kl;\n+        return DoubleStream.generate(() -> (kl + nextLong(n)) * delta).sequential();\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified origin\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * <p>The uniformity of the distribution of the {@code double}s produced by\n+     * the stream is as good as the one of {@link #nextLong(long)}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n+     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n+     * is the smallest number for which all these multiples are exact {@code double}s.\n+     *\n+     * @param origin the least value (inclusive) that can be produced\n+     * @param bound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive).\n+     *         The stream never generates {@code -0.0}, although it may generate\n+     *         {@code 0.0}\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\/\n+    default DoubleStream equiDoublesLeftClosedRightOpen(double origin, double bound) {\n+        if (!(Double.NEGATIVE_INFINITY < origin && origin < bound &&\n+                bound < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(\"the interval must not be empty\");\n+        }\n+        return equiDoubles(origin, bound, true, true);\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified origin\n+     * (inclusive) and the specified bound (inclusive).\n+     *\n+     * <p>The uniformity of the distribution of the {@code double}s produced by\n+     * the stream is as good as the one of {@link #nextLong(long)}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n+     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n+     * is the smallest number for which all these multiples are exact {@code double}s.\n+     *\n+     * @param origin the least value (inclusive) that can be produced\n+     * @param bound the upper bound (inclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (inclusive) and the specified bound (inclusive).\n+     *         The stream never generates {@code -0.0}, although it may generate\n+     *         {@code 0.0}\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or {@code origin}\n+     *         is greater than {@code bound}\n+     *\/\n+    default DoubleStream equiDoublesLeftClosedRightClosed(double origin, double bound) {\n+        if (!(Double.NEGATIVE_INFINITY < origin && origin <= bound &&\n+                bound < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(\"the interval must not be empty\");\n+        }\n+        return equiDoubles(origin, bound, true, false);\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified origin\n+     * (exclusive) and the specified bound (exclusive).\n+     *\n+     * <p>The uniformity of the distribution of the {@code double}s produced by\n+     * the stream is as good as the one of {@link #nextLong(long)}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n+     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n+     * is the smallest number for which all these multiples are exact {@code double}s.\n+     *\n+     * @param origin the least value (exclusive) that can be produced\n+     * @param bound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (exclusive) and the specified bound (exclusive).\n+     *         The stream never generates {@code -0.0}, although it may generate\n+     *         {@code 0.0}\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or if the successor of {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\/\n+    default DoubleStream equiDoublesLeftOpenRightOpen(double origin, double bound) {\n+        if (!(Double.NEGATIVE_INFINITY < origin && nextUp(origin) < bound &&\n+                bound < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(\"the interval must not be empty\");\n+        }\n+        return equiDoubles(origin, bound, false, true);\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified origin\n+     * (exclusive) and the specified bound (inclusive).\n+     *\n+     * <p>The uniformity of the distribution of the {@code double}s produced by\n+     * the stream is as good as the one of {@link #nextLong(long)}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n+     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n+     * is the smallest number for which all these multiples are exact {@code double}s.\n+     *\n+     * @param origin the least value (exclusive) that can be produced\n+     * @param bound the upper bound (inclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (exclusive) and the specified bound (inclusive).\n+     *         The stream never generates {@code -0.0}, although it may generate\n+     *         {@code 0.0}\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\/\n+    default DoubleStream equiDoublesLeftOpenRightClosed(double origin, double bound) {\n+        if (!(Double.NEGATIVE_INFINITY < origin && origin < bound &&\n+                bound < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(\"the interval must not be empty\");\n+        }\n+        return equiDoubles(origin, bound, false, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":244,"deletions":2,"binary":false,"changes":246,"status":"modified"}]}