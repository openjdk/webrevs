{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.util.random.RandomSupport.*;\n@@ -40,0 +39,2 @@\n+import static java.lang.Math.*;\n+\n@@ -255,0 +256,152 @@\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified\n+     * {@code left} boundary and the specified {@code right} boundary.\n+     * The {@code left} boundary is included as indicated by\n+     * {@code isLeftIncluded}; similarly, the {@code right} boundary is included\n+     * as indicated by {@code isRightIncluded}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta;\n+     * (<i>k<\/i> integer) lying in the interval specified by the parameters,\n+     * where &delta; > 0 is the smallest number for which all these multiples\n+     * are exact {@code double}s.\n+     * They are therefore all equidistant.\n+     *\n+     * <p>The uniformity of the distribution of the {@code double}s produced by\n+     * the stream is as good as the one of {@link #nextLong(long)}.\n+     *\n+     * @param left the left boundary\n+     * @param right the right boundary\n+     * @param isLeftIncluded whether the {@code left} boundary is included\n+     * @param isRightIncluded whether the {@code right} boundary is included\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each\n+     *         between {@code left} and {@code right}, as specified above.\n+     *         The stream never produces {@code -0.0}, although it may produce\n+     *         {@code 0.0} if the specified interval contains 0.\n+     *\n+     * @throws IllegalArgumentException if {@code left} is not finite,\n+     *         or {@code right} is not finite, or if the specified interval\n+     *         is empty.\n+     *\/\n+    default DoubleStream equiDoubles(double left, double right,\n+        boolean isLeftIncluded, boolean isRightIncluded) {\n+        if (!(Double.NEGATIVE_INFINITY < left\n+                && right < Double.POSITIVE_INFINITY\n+                && (isLeftIncluded ? left : nextUp(left))\n+                    <= (isRightIncluded ? right : nextDown(right)))) {\n+            throw new IllegalArgumentException(\n+                    \"the boundaries must be finite and the interval must not be empty\");\n+        }\n+\n+        \/*\n+         * Inspired by\n+         *      Goualard, \"Drawing random floating-point numbers from an\n+         *      interval\", ACM TOMACS, 2022, 32 (3)\n+         *      (https:\/\/hal.science\/hal-03282794v4)\n+         * although implemented differently.\n+         *\n+         * It is assumed that left <= right.\n+         * Whether the boundaries of the interval I = <left, right> are included\n+         * is indicated by isLeftIncluded and isRightIncluded.\n+         *\n+         * delta > 0 is the smallest double such that every product k delta\n+         * (k integer) that lies in I is an exact double as well.\n+         * It turns out that delta is always a power of 2.\n+         *\n+         * kl is the k for the leftmost product k delta in I.\n+         * kr is the k for the leftmost product k delta to the right of I.\n+         * n is kr - kl\n+         *\/\n+        double delta;  \/\/ captured\n+        long kl;  \/\/ captured\n+        long kr;\n+        long n;  \/\/ captured\n+\n+        if (left <= -right) {\n+            \/*\n+             * Here,\n+             *      left <= 0,      left <= right <= -left\n+             *      P = Double.PRECISION\n+             *\n+             * delta is the distance from left to the next double in the\n+             * direction of positive infinity.\n+             * Every product k delta lying in [left, -left] is an exact double.\n+             * Thus, every product k delta lying in I is an exact double, too.\n+             * Any other positive eps < delta does not meet this property:\n+             * some product k eps lying in I is not an exact double.\n+             * On the other hand, any other eps > delta would generate more\n+             * sparse products k eps, that is, less doubles in I.\n+             * delta is therefore the best value to ensure the largest number\n+             * of equidistant doubles in I.\n+             *\n+             * left \/ delta is an exact double and an exact integer with\n+             *      -2^P <= left \/ delta <= 0\n+             * Thus, kl is computed exactly.\n+             *\n+             * Mathematically,\n+             *      kr = ceil(right \/ delta),           if isRightIncluded\n+             *      kr = floor(right \/ delta) + 1,      if !isRightIncluded\n+             * The double division rd = right \/ delta never overflows and is\n+             * exact, except in the presence of underflows. But even underflows\n+             * do not affect the outcomes of ceil() and floor(), except,\n+             * in turn, when the result drops to 0, that is, rd = 0.\n+             *\n+             * crd is a corrected version of rd when rd is zero. It is simply\n+             * right \/ delta, but rounded away from 0 to preserve information\n+             * ensuring correct outcomes in ceil() and floor().\n+             *\n+             * We know that -2^P <= kl, so\n+             *      -2^P <= kl + nextLong(n)\n+             * Also, since right <= -left, we know that\n+             *      kr <= -kl + 1\n+             * so that\n+             *      0 < n <= -2 kl + 1\n+             * This implies\n+             *      kl + nextLong(n) <= kl + (-2 kl) = -kl <= 2^P\n+             * and thus\n+             *      -2^P <= kl + nextLong(n) <= 2^P\n+             * which shows that kl + nextLong(n) can be cast exactly to double.\n+             *\n+             * Further, if isLeftIncluded then left = kl delta, so that we get\n+             *      left = kl * delta <= (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would have\n+             *      (k + nextLong(n)) * delta < left\n+             * Otherwise, left = (kl - 1) delta, and therefore\n+             *      left = (kl - 1) * delta < (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would get\n+             *      (k + nextLong(n)) * delta <= left\n+             * Either way, the lhs expression would not belong to I.\n+             * That is, kl is the smallest integer such that kl delta always\n+             * lies in I (it is an exact double).\n+             *\n+             * Similar considerations show that kr is the smallest integer such\n+             * that kr delta lies to the right of I (it is an exact double).\n+             *\n+             * All the above means that (kl + nextLong(n)) * delta is an exact\n+             * double lying in I and that kl and kr, thus n, are the best\n+             * possible choices to ensure the largest number of equidistant\n+             * doubles in I. Uniform distribution relies on the guarantee\n+             * afforded by nextLong().\n+             *\/\n+            delta = nextUp(left) - left;\n+            double rd = right \/ delta;\n+            double crd = rd != 0 || right == 0 ? rd : copySign(Double.MIN_VALUE, right);\n+            kr = isRightIncluded ? (long) floor(crd) + 1 : (long) ceil(crd);\n+            kl = (long) (left \/ delta) + (isLeftIncluded ? 0 : 1);\n+        } else {\n+            \/* Here,\n+             *      right > 0,      -right < left <= right\n+             *\n+             * Considerations similar to the ones above apply here as well.\n+             *\/\n+            delta = right - nextDown(right);\n+            double ld = left \/ delta;\n+            double cld = ld != 0 || left == 0 ? ld : copySign(Double.MIN_VALUE, left);\n+            kl = isLeftIncluded ? (long) ceil(cld) : (long) floor(cld) + 1;\n+            kr = (long) (right \/ delta) + (isRightIncluded ? 1 : 0);\n+        }\n+        n = kr - kl;\n+        return DoubleStream.generate(() -> (kl + nextLong(n)) * delta).sequential();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":155,"deletions":2,"binary":false,"changes":157,"status":"modified"}]}