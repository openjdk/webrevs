{"files":[{"patch":"@@ -257,1 +257,1 @@\n-            boolean isLeftClosed, boolean isRightOpen) {\n+            boolean isLeftIncluded, boolean isRightIncluded) {\n@@ -267,1 +267,1 @@\n-         * is indicated by isLeftClosed and isRightOpen.\n+         * is indicated by isLeftIncluded and isRightIncluded.\n@@ -304,2 +304,2 @@\n-             *      kr = ceil(right \/ delta),           if isRightOpen\n-             *      kr = floor(right \/ delta) + 1,      if !isRightOpen\n+             *      kr = ceil(right \/ delta),           if isRightIncluded\n+             *      kr = floor(right \/ delta) + 1,      if !isRightIncluded\n@@ -327,1 +327,1 @@\n-             * Further, if isLeftClosed then left = kl delta, so that we get\n+             * Further, if isLeftIncluded then left = kl delta, so that we get\n@@ -351,2 +351,2 @@\n-            kr = isRightOpen ? (long) ceil(crd) : (long) floor(crd) + 1;\n-            kl = (long) (left \/ delta) + (isLeftClosed ? 0 : 1);\n+            kr = isRightIncluded ? (long) floor(crd) + 1 : (long) ceil(crd);\n+            kl = (long) (left \/ delta) + (isLeftIncluded ? 0 : 1);\n@@ -362,2 +362,2 @@\n-            kl = isLeftClosed ? (long) ceil(cld) : (long) floor(cld) + 1;\n-            kr = (long) (right \/ delta) + (isRightOpen ? 0 : 1);\n+            kl = isLeftIncluded ? (long) ceil(cld) : (long) floor(cld) + 1;\n+            kr = (long) (right \/ delta) + (isRightIncluded ? 1 : 0);\n@@ -371,2 +371,11 @@\n-     * {@code double} values, where each value is between the specified origin\n-     * (inclusive) and the specified bound (exclusive).\n+     * {@code double} values, where each value is between the specified\n+     * {@code left} boundary and the specified {@code right} boundary.\n+     * The {@code left} boundary is included as indicated by\n+     * {@code isLeftIncluded}; similarly, the {@code right} boundary is included\n+     * as indicated by {@code isRightIncluded}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i>&delta;\n+     * (<i>k<\/i> integer) lying in the interval specified by the parameters,\n+     * where &delta; > 0 is the smallest number for which all these multiples\n+     * are exact {@code double}s.\n+     * They are therefore all equidistant.\n@@ -377,28 +386,4 @@\n-     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n-     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n-     * is the smallest number for which all these multiples are exact {@code double}s.\n-     *\n-     * @param origin the least value (inclusive) that can be produced\n-     * @param bound the upper bound (exclusive) for each value produced\n-     *\n-     * @return a stream of pseudorandomly chosen {@code double} values, each between\n-     *         the specified origin (inclusive) and the specified bound (exclusive).\n-     *         The stream never generates {@code -0.0}, although it may generate\n-     *         {@code 0.0}\n-     *\n-     * @throws IllegalArgumentException if {@code origin} is not finite,\n-     *         or {@code bound} is not finite, or {@code origin}\n-     *         is greater than or equal to {@code bound}\n-     *\/\n-    default DoubleStream equiDoublesLeftClosedRightOpen(double origin, double bound) {\n-        if (!(Double.NEGATIVE_INFINITY < origin && origin < bound &&\n-                bound < Double.POSITIVE_INFINITY)) {\n-            throw new IllegalArgumentException(\"the interval must not be empty\");\n-        }\n-        return equiDoubles(origin, bound, true, true);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandomly chosen\n-     * {@code double} values, where each value is between the specified origin\n-     * (inclusive) and the specified bound (inclusive).\n+     * @param left the left boundary\n+     * @param right the right boundary\n+     * @param isLeftIncluded whether the {@code left} boundary is included\n+     * @param isRightIncluded whether the {@code right} boundary is included\n@@ -406,78 +391,4 @@\n-     * <p>The uniformity of the distribution of the {@code double}s produced by\n-     * the stream is as good as the one of {@link #nextLong(long)}.\n-     *\n-     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n-     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n-     * is the smallest number for which all these multiples are exact {@code double}s.\n-     *\n-     * @param origin the least value (inclusive) that can be produced\n-     * @param bound the upper bound (inclusive) for each value produced\n-     *\n-     * @return a stream of pseudorandomly chosen {@code double} values, each between\n-     *         the specified origin (inclusive) and the specified bound (inclusive).\n-     *         The stream never generates {@code -0.0}, although it may generate\n-     *         {@code 0.0}\n-     *\n-     * @throws IllegalArgumentException if {@code origin} is not finite,\n-     *         or {@code bound} is not finite, or {@code origin}\n-     *         is greater than {@code bound}\n-     *\/\n-    default DoubleStream equiDoublesLeftClosedRightClosed(double origin, double bound) {\n-        if (!(Double.NEGATIVE_INFINITY < origin && origin <= bound &&\n-                bound < Double.POSITIVE_INFINITY)) {\n-            throw new IllegalArgumentException(\"the interval must not be empty\");\n-        }\n-        return equiDoubles(origin, bound, true, false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandomly chosen\n-     * {@code double} values, where each value is between the specified origin\n-     * (exclusive) and the specified bound (exclusive).\n-     *\n-     * <p>The uniformity of the distribution of the {@code double}s produced by\n-     * the stream is as good as the one of {@link #nextLong(long)}.\n-     *\n-     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n-     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n-     * is the smallest number for which all these multiples are exact {@code double}s.\n-     *\n-     * @param origin the least value (exclusive) that can be produced\n-     * @param bound the upper bound (exclusive) for each value produced\n-     *\n-     * @return a stream of pseudorandomly chosen {@code double} values, each between\n-     *         the specified origin (exclusive) and the specified bound (exclusive).\n-     *         The stream never generates {@code -0.0}, although it may generate\n-     *         {@code 0.0}\n-     *\n-     * @throws IllegalArgumentException if {@code origin} is not finite,\n-     *         or {@code bound} is not finite, or if the successor of {@code origin}\n-     *         is greater than or equal to {@code bound}\n-     *\/\n-    default DoubleStream equiDoublesLeftOpenRightOpen(double origin, double bound) {\n-        if (!(Double.NEGATIVE_INFINITY < origin && nextUp(origin) < bound &&\n-                bound < Double.POSITIVE_INFINITY)) {\n-            throw new IllegalArgumentException(\"the interval must not be empty\");\n-        }\n-        return equiDoubles(origin, bound, false, true);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandomly chosen\n-     * {@code double} values, where each value is between the specified origin\n-     * (exclusive) and the specified bound (inclusive).\n-     *\n-     * <p>The uniformity of the distribution of the {@code double}s produced by\n-     * the stream is as good as the one of {@link #nextLong(long)}.\n-     *\n-     * <p>The stream potentially produces all multiples <i>k<\/i>&delta; (<i>k<\/i>\n-     * integer) lying in the given range, where &delta; &ge; {@link Double#MIN_VALUE}\n-     * is the smallest number for which all these multiples are exact {@code double}s.\n-     *\n-     * @param origin the least value (exclusive) that can be produced\n-     * @param bound the upper bound (inclusive) for each value produced\n-     *\n-     * @return a stream of pseudorandomly chosen {@code double} values, each between\n-     *         the specified origin (exclusive) and the specified bound (inclusive).\n-     *         The stream never generates {@code -0.0}, although it may generate\n-     *         {@code 0.0}\n+     * @return a stream of pseudorandomly chosen {@code double} values, each\n+     *         between {@code left} and {@code right}, as specified above.\n+     *         The stream never produces {@code -0.0}, although it may produce\n+     *         {@code 0.0} if the specified interval contains 0.\n@@ -485,3 +396,3 @@\n-     * @throws IllegalArgumentException if {@code origin} is not finite,\n-     *         or {@code bound} is not finite, or {@code origin}\n-     *         is greater than or equal to {@code bound}\n+     * @throws IllegalArgumentException if {@code left} is not finite,\n+     *         or {@code right} is not finite, or if the specified interval\n+     *         is empty.\n@@ -489,4 +400,7 @@\n-    default DoubleStream equiDoublesLeftOpenRightClosed(double origin, double bound) {\n-        if (!(Double.NEGATIVE_INFINITY < origin && origin < bound &&\n-                bound < Double.POSITIVE_INFINITY)) {\n-            throw new IllegalArgumentException(\"the interval must not be empty\");\n+    default DoubleStream equiDoublesLeftClosedRightOpen(double left, double right,\n+        boolean isLeftIncluded, boolean isRightIncluded) {\n+        if (!((isLeftIncluded ? left : nextUp(left)) < (isRightIncluded ? nextUp(right) : right)\n+                && Double.NEGATIVE_INFINITY < left\n+                && right < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(\n+                    \"the boundaries must be finite and the interval must not be empty\");\n@@ -494,1 +408,1 @@\n-        return equiDoubles(origin, bound, false, false);\n+        return equiDoubles(left, right, isLeftIncluded, isRightIncluded);\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":39,"deletions":125,"binary":false,"changes":164,"status":"modified"}]}