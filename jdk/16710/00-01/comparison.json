{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.channels.Selector;\n+\n@@ -29,1 +31,2 @@\n- * A JFR event for selection operations.  This event is mirrored in\n+ * A JFR event for operations on {@link Selector#select()} and it's variants.\n+ * This event is mirrored in\n@@ -36,1 +39,1 @@\n-public class SelectionEvent extends Event {\n+public class SelectorSelectEvent extends Event {\n@@ -38,1 +41,1 @@\n-    public int count;\n+    public int selectionKeyCount;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SelectorSelectEvent.java","additions":6,"deletions":3,"binary":false,"changes":9,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SelectionEvent.java","status":"renamed"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.event.SelectionEvent;\n+import jdk.internal.event.SelectorSelectEvent;\n@@ -143,1 +143,2 @@\n-        if (!SelectionEvent.enabled()) {\n+        \/\/ filter selectNow ops from consideration (timeout == 0)\n+        if ((timeout == 0) || (!SelectorSelectEvent.enabled())) {\n@@ -146,1 +147,1 @@\n-        long start = SelectionEvent.timestamp();\n+        long start = SelectorSelectEvent.timestamp();\n@@ -148,3 +149,4 @@\n-        long duration = SelectionEvent.timestamp() - start;\n-        if (SelectionEvent.shouldCommit(duration)) {\n-            SelectionEvent.commit(start, duration, n);\n+        long duration = SelectorSelectEvent.timestamp() - start;\n+        \/\/ always send event if timed out (n == 0)\n+        if ((n == 0) || (SelectorSelectEvent.shouldCommit(duration))) {\n+            SelectorSelectEvent.commit(start, duration, n);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorImpl.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-\n-import jdk.jfr.Category;\n-import jdk.jfr.Description;\n-import jdk.jfr.Label;\n-import jdk.jfr.Name;\n-import jdk.jfr.internal.MirrorEvent;\n-import jdk.jfr.internal.Type;\n-\n-@Name(Type.EVENT_NAME_PREFIX + \"Selection\")\n-@Label(\"Selection\")\n-@Category(\"Java Application\")\n-@Description(\"Selection Operation\")\n-@MirrorEvent(className = \"jdk.internal.event.SelectionEvent\")\n-public class SelectionEvent extends AbstractJDKEvent {\n-\n-    @Label(\"Selection Count\")\n-    @Description(\"Number of channels selected\")\n-    public int count;\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SelectionEvent.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+import jdk.jfr.internal.Type;\n+\n+@Name(Type.EVENT_NAME_PREFIX + \"SelectorSelect\")\n+@Label(\"SelectorSelect\")\n+@Category(\"Java Application\")\n+@Description(\"Selector Select Operation\")\n+@MirrorEvent(className = \"jdk.internal.event.SelectorSelectEvent\")\n+public class SelectorSelectEvent extends AbstractJDKEvent {\n+\n+    @Label(\"SelectionKey Count\")\n+    @Description(\"Number of channels ready for I\/O or added to ready set\")\n+    public int selectionKeyCount;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SelectorSelectEvent.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.jfr.events.SelectionEvent;\n+import jdk.jfr.events.SelectorSelectEvent;\n@@ -56,1 +56,1 @@\n-        SelectionEvent.class,\n+        SelectorSelectEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        jdk.internal.event.SelectionEvent.class,\n+        jdk.internal.event.SelectorSelectEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-    <event name=\"jdk.Selection\">\n+    <event name=\"jdk.SelectorSelect\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-    <event name=\"jdk.Selection\">\n+    <event name=\"jdk.SelectorSelect\">\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.io;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.SocketChannel;\n-import java.util.List;\n-\n-\/**\n- * @test\n- * @bug 8310994\n- * @summary test selection events\n- * @key jfr\n- * @requires vm.hasJFR\n- * @library \/test\/lib \/test\/jdk\n- * @run main\/othervm jdk.jfr.event.io.TestSelectionEvents\n- *\/\n-public class TestSelectionEvents {\n-\n-    private static String COUNT_FIELD = \"count\";\n-\n-    public static void main(String[] args) throws Throwable {\n-        new TestSelectionEvents().test();\n-    }\n-\n-    public void test() throws Throwable {\n-        try (Recording recording = new Recording()) {\n-            try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n-                recording.enable(EventNames.Selection).withoutThreshold();\n-                recording.start();\n-\n-                InetAddress lb = InetAddress.getLoopbackAddress();\n-                ssc.bind(new InetSocketAddress(lb, 0));\n-\n-                try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n-                    SocketChannel sc2 = ssc.accept();\n-                    Selector sel = Selector.open()) {\n-\n-                    \/\/ register for read events, channel should not be selected\n-                    sc1.configureBlocking(false);\n-                    SelectionKey key = sc1.register(sel, SelectionKey.OP_READ);\n-                    int n = sel.selectNow();\n-                    Asserts.assertTrue(n == 0);\n-\n-                    \/\/ write bytes to other end of connection\n-                    ByteBuffer msg = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n-                    int nwrote = sc2.write(msg);\n-                    Asserts.assertTrue(nwrote >= 0);\n-\n-                    \/\/ channel should be selected\n-                    n = sel.select();\n-                    Asserts.assertTrue(n == 1);\n-                }\n-                recording.stop();\n-\n-                List<RecordedEvent> events = Events.fromRecording(recording);\n-                Asserts.assertEquals(events.size(), 2);\n-                Asserts.assertTrue(events.get(0).getInt(COUNT_FIELD) == 0);\n-                Asserts.assertTrue(events.get(1).getInt(COUNT_FIELD) == 1);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSelectionEvents.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Duration;\n+import java.util.List;\n+\n+\/**\n+ * @test\n+ * @bug 8310994\n+ * @summary test selection events\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.event.io.TestSelectorSelectEvent\n+ *\/\n+public class TestSelectorSelectEvent {\n+\n+    private static String COUNT_FIELD = \"selectionKeyCount\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        var tests = new TestSelectorSelectEvent();\n+        tests.test1();\n+        tests.test2();\n+    }\n+\n+    public void test1() throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                recording.enable(EventNames.SelectorSelect).withoutThreshold();\n+                recording.start();\n+\n+                InetAddress lb = InetAddress.getLoopbackAddress();\n+                ssc.bind(new InetSocketAddress(lb, 0));\n+\n+                try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                    SocketChannel sc2 = ssc.accept();\n+                    Selector sel = Selector.open()) {\n+\n+                    \/\/ register for read events, channel should not be selected\n+                    \/\/ no event should be generated for selectNow().\n+                    sc1.configureBlocking(false);\n+                    SelectionKey key = sc1.register(sel, SelectionKey.OP_READ);\n+                    int n = sel.selectNow();\n+                    Asserts.assertTrue(n == 0);\n+\n+                    \/\/ write bytes to other end of connection\n+                    ByteBuffer msg = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+                    int nwrote = sc2.write(msg);\n+                    Asserts.assertTrue(nwrote >= 0);\n+\n+                    \/\/ channel should be selected\n+                    n = sel.select();\n+                    Asserts.assertTrue(n == 1);\n+                }\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Asserts.assertEquals(events.size(), 1);\n+                Asserts.assertTrue(events.get(0).getInt(COUNT_FIELD) == 1);\n+            }\n+        }\n+    }\n+    public void test2() throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                recording.enable(EventNames.SelectorSelect).withThreshold(Duration.ofMillis(100));\n+                recording.start();\n+\n+                InetAddress lb = InetAddress.getLoopbackAddress();\n+                ssc.bind(new InetSocketAddress(lb, 0));\n+\n+                try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                     SocketChannel sc2 = ssc.accept();\n+                     Selector sel = Selector.open()) {\n+\n+                    \/\/ Register for read events, channel should not be selected\n+                    \/\/ and should time out.  An event should be generated.\n+                    sc1.configureBlocking(false);\n+                    SelectionKey key = sc1.register(sel, SelectionKey.OP_READ);\n+                    int n = sel.select(1);\n+                    Asserts.assertTrue(n == 0);\n+\n+                    \/\/ write bytes to other end of connection\n+                    ByteBuffer msg = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+                    int nwrote = sc2.write(msg);\n+                    Asserts.assertTrue(nwrote >= 0);\n+\n+                    \/\/ channel should be selected, but no events should be generated\n+                    \/\/ due to high threshold\n+                    n = sel.select();\n+                    Asserts.assertTrue(n == 1);\n+                }\n+                recording.stop();\n+\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                Asserts.assertEquals(events.size(), 1);\n+                Asserts.assertTrue(events.get(0).getInt(COUNT_FIELD) == 0);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSelectorSelectEvent.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -196,1 +196,1 @@\n-    public static final String Selection = PREFIX + \"Selection\";\n+    public static final String SelectorSelect = PREFIX + \"SelectorSelect\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}