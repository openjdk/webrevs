{"files":[{"patch":"@@ -26,0 +26,3 @@\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n@@ -27,0 +30,1 @@\n+import java.util.function.Function;\n@@ -37,0 +41,18 @@\n+    private static final Generator<Integer> INTS = Generators.G.ints();\n+    private static final Generator<Long> LONGS = Generators.G.longs();\n+\n+    private static final int[] LIMITS_32 = new int[8];\n+    private static final int[] LIMITS_64 = new int[8];\n+\n+    private static final Range<Integer> RANGE_INT = Range.generate(INTS);\n+    private static final Range<Long> RANGE_LONG = Range.generate(LONGS);\n+\n+    static {\n+        var INTS_32 = Generators.G.ints().restricted(0, 32);\n+        var INTS_64 = Generators.G.ints().restricted(0, 64);\n+        for (int i = 0; i < 8; ++i) {\n+            LIMITS_32[i] = INTS_32.next();\n+            LIMITS_64[i] = INTS_64.next();\n+        }\n+    }\n+\n@@ -42,4 +64,4 @@\n-        \"clzConstInts\", \"clzCompareInt\", \"clzDiv8Int\",\n-        \"clzConstLongs\", \"clzCompareLong\", \"clzDiv8Long\",\n-        \"ctzConstInts\", \"ctzCompareInt\", \"ctzDiv8Int\",\n-        \"ctzConstLongs\", \"ctzCompareLong\", \"ctzDiv8Long\",\n+        \"clzConstInts\", \"clzCompareInt\", \"clzDiv8Int\", \"clzRandLimitInt\",\n+        \"clzConstLongs\", \"clzCompareLong\", \"clzDiv8Long\", \"clzRandLimitLong\",\n+        \"ctzConstInts\", \"ctzCompareInt\", \"ctzDiv8Int\", \"ctzRandLimitInt\",\n+        \"ctzConstLongs\", \"ctzCompareLong\", \"ctzDiv8Long\", \"ctzRandLimitLong\",\n@@ -48,2 +70,2 @@\n-        int randInt = RunInfo.getRandom().nextInt();\n-        long randLong = RunInfo.getRandom().nextLong();\n+        int randInt = INTS.next();\n+        long randLong = LONGS.next();\n@@ -55,5 +77,1 @@\n-        int[] results = clzConstInts();\n-        Asserts.assertEQ(Integer.numberOfLeadingZeros(0), results[0]);\n-        for (int i = 0; i < 32; ++i) {\n-            Asserts.assertEQ(Integer.numberOfLeadingZeros(1 << i), results[i + 1]);\n-        }\n+        checkConstResults(clzConstInts(), x -> Integer.numberOfLeadingZeros(x.intValue()));\n@@ -65,0 +83,1 @@\n+        Asserts.assertEQ(clzRandLimitInterpretedInt(randInt), clzRandLimitInt(randInt));\n@@ -66,5 +85,1 @@\n-        results = clzConstLongs();\n-        Asserts.assertEQ(Long.numberOfLeadingZeros(0), results[0]);\n-        for (int i = 0; i < 64; ++i) {\n-            Asserts.assertEQ(Long.numberOfLeadingZeros(1l << i), results[i + 1]);\n-        }\n+        checkConstResults(clzConstLongs(), x -> Long.numberOfLeadingZeros(x.longValue()));\n@@ -76,0 +91,1 @@\n+        Asserts.assertEQ(clzRandLimitInterpretedLong(randLong), clzRandLimitLong(randLong));\n@@ -77,5 +93,1 @@\n-        results = ctzConstInts();\n-        Asserts.assertEQ(Integer.numberOfTrailingZeros(0), results[0]);\n-        for (int i = 0; i < 32; ++i) {\n-            Asserts.assertEQ(Integer.numberOfTrailingZeros(1 << i), results[i + 1]);\n-        }\n+        checkConstResults(ctzConstInts(), x -> Integer.numberOfTrailingZeros(x.intValue()));\n@@ -87,0 +99,1 @@\n+        Asserts.assertEQ(ctzRandLimitInterpretedInt(randInt), ctzRandLimitInt(randInt));\n@@ -88,5 +101,1 @@\n-        results = ctzConstLongs();\n-        Asserts.assertEQ(Long.numberOfTrailingZeros(0), results[0]);\n-        for (int i = 0; i < 64; ++i) {\n-            Asserts.assertEQ(Long.numberOfTrailingZeros(1l << i), results[i + 1]);\n-        }\n+        checkConstResults(ctzConstLongs(), x -> Long.numberOfTrailingZeros(x.longValue()));\n@@ -98,0 +107,9 @@\n+        Asserts.assertEQ(ctzRandLimitInterpretedLong(randLong), ctzRandLimitLong(randLong));\n+    }\n+\n+    @DontCompile\n+    public void checkConstResults(int[] results, Function<Long, Integer> op) {\n+        Asserts.assertEQ(op.apply(Long.valueOf(0)), results[0]);\n+        for (int i = 0; i < results.length - 1; ++i) {\n+            Asserts.assertEQ(op.apply(Long.valueOf(1l << i)), results[i + 1]);\n+        }\n@@ -100,0 +118,2 @@\n+    \/\/ Test CLZ with constant integer inputs.\n+    \/\/ All CLZs in this test are expected to be optimized away.\n@@ -140,0 +160,3 @@\n+    \/\/ Test the range of CLZ with random integer input.\n+    \/\/ The result of CLZ should be in range [0, 32], so CLZs in this test are\n+    \/\/ expected to be optimized away, and the test should always return false.\n@@ -147,0 +170,3 @@\n+    \/\/ Test the combination of CLZ and division by 8.\n+    \/\/ The result of CLZ should be positive, so the division by 8 should be\n+    \/\/ optimized to a simple right shift without rounding.\n@@ -156,0 +182,17 @@\n+    \/\/ Test the output range of CLZ with random input range.\n+    @Test\n+    public int clzRandLimitInt(int randInt) {\n+        randInt = RANGE_INT.clamp(randInt);\n+        int result = Integer.numberOfLeadingZeros(randInt);\n+        return getResultChecksum(result, LIMITS_32);\n+    }\n+\n+    @DontCompile\n+    public int clzRandLimitInterpretedInt(int randInt) {\n+        randInt = RANGE_INT.clamp(randInt);\n+        int result = Integer.numberOfLeadingZeros(randInt);\n+        return getResultChecksum(result, LIMITS_32);\n+    }\n+\n+    \/\/ Test CLZ with constant long inputs.\n+    \/\/ All CLZs in this test are expected to be optimized away.\n@@ -228,0 +271,3 @@\n+    \/\/ Test the range of CLZ with random long input.\n+    \/\/ The result of CLZ should be in range [0, 64], so CLZs in this test are\n+    \/\/ expected to be optimized away, and the test should always return false.\n@@ -235,0 +281,3 @@\n+    \/\/ Test the combination of CLZ and division by 8.\n+    \/\/ The result of CLZ should be positive, so the division by 8 should be\n+    \/\/ optimized to a simple right shift without rounding.\n@@ -244,0 +293,17 @@\n+    \/\/ Test the output range of CLZ with random input range.\n+    @Test\n+    public int clzRandLimitLong(long randLong) {\n+        randLong = RANGE_LONG.clamp(randLong);\n+        int result = Long.numberOfLeadingZeros(randLong);\n+        return getResultChecksum(result, LIMITS_64);\n+    }\n+\n+    @DontCompile\n+    public int clzRandLimitInterpretedLong(long randLong) {\n+        randLong = RANGE_LONG.clamp(randLong);\n+        int result = Long.numberOfLeadingZeros(randLong);\n+        return getResultChecksum(result, LIMITS_64);\n+    }\n+\n+    \/\/ Test CTZ with constant integer inputs.\n+    \/\/ All CTZs in this test are expected to be optimized away.\n@@ -284,0 +350,3 @@\n+    \/\/ Test the range of CTZ with random integer input.\n+    \/\/ The result of CTZ should be in range [0, 32], so CTZs in this test are\n+    \/\/ expected to be optimized away, and the test should always return false.\n@@ -291,0 +360,3 @@\n+    \/\/ Test the combination of CTZ and division by 8.\n+    \/\/ The result of CTZ should be positive, so the division by 8 should be\n+    \/\/ optimized to a simple right shift without rounding.\n@@ -300,0 +372,17 @@\n+    \/\/ Test the output range of CTZ with random input range.\n+    @Test\n+    public int ctzRandLimitInt(int randInt) {\n+        randInt = RANGE_INT.clamp(randInt);\n+        int result = Integer.numberOfTrailingZeros(randInt);\n+        return getResultChecksum(result, LIMITS_32);\n+    }\n+\n+    @DontCompile\n+    public int ctzRandLimitInterpretedInt(int randInt) {\n+        randInt = RANGE_INT.clamp(randInt);\n+        int result = Integer.numberOfTrailingZeros(randInt);\n+        return getResultChecksum(result, LIMITS_32);\n+    }\n+\n+    \/\/ Test CTZ with constant long inputs.\n+    \/\/ All CTZs in this test are expected to be optimized away.\n@@ -372,0 +461,3 @@\n+    \/\/ Test the range of CTZ with random long input.\n+    \/\/ The result of CTZ should be in range [0, 64], so CTZs in this test are\n+    \/\/ expected to be optimized away, and the test should always return false.\n@@ -379,0 +471,3 @@\n+    \/\/ Test the combination of CTZ and division by 8.\n+    \/\/ The result of CTZ should be positive, so the division by 8 should be\n+    \/\/ optimized to a simple right shift without rounding.\n@@ -387,0 +482,43 @@\n+\n+    \/\/ Test the output range of CTZ with random input range.\n+    @Test\n+    public int ctzRandLimitLong(long randLong) {\n+        randLong = RANGE_LONG.clamp(randLong);\n+        int result = Long.numberOfLeadingZeros(randLong);\n+        return getResultChecksum(result, LIMITS_64);\n+    }\n+\n+    @DontCompile\n+    public int ctzRandLimitInterpretedLong(long randLong) {\n+        randLong = RANGE_LONG.clamp(randLong);\n+        int result = Long.numberOfLeadingZeros(randLong);\n+        return getResultChecksum(result, LIMITS_64);\n+    }\n+\n+    record Range<T extends Comparable<T>>(T lo, T hi) {\n+        Range {\n+            if (lo.compareTo(hi) > 0) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        T clamp(T v) {\n+            return v.compareTo(lo) < 0 ? lo :\n+                   v.compareTo(hi) > 0 ? hi : v;\n+        }\n+\n+        static <T extends Comparable<T>> Range generate(Generator<T> g) {\n+            T a = g.next(), b = g.next();\n+            return a.compareTo(b) < 0 ? new Range(a, b) : new Range(b, a);\n+        }\n+    }\n+\n+    int getResultChecksum(int result, int[] LIMITS) {\n+        int sum = 0;\n+        for (int i = 0; i < LIMITS.length; i += 2) {\n+            if (result < LIMITS[i]) sum += 1 << i;\n+            if (result > LIMITS[i + 1]) sum += 1 << (i + 1);\n+        }\n+        return sum;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestCountBitsRange.java","additions":164,"deletions":26,"binary":false,"changes":190,"status":"modified"}]}