{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +36,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -36,0 +40,1 @@\n+import java.util.function.BiFunction;\n@@ -38,0 +43,3 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.SwitchCase;\n@@ -40,0 +48,2 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -57,4 +67,0 @@\n-    private static final MethodHandle INSTANCEOF_CHECK;\n-    private static final MethodHandle INTEGER_EQ_CHECK;\n-    private static final MethodHandle OBJECT_EQ_CHECK;\n-    private static final MethodHandle ENUM_EQ_CHECK;\n@@ -68,9 +74,0 @@\n-            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n-                                                                                 MethodType.methodType(boolean.class, Object.class)),\n-                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n-            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n-            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n-                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n-            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n@@ -158,1 +155,3 @@\n-        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+        MethodHandle target = generateInnerClass(lookup, labels);\n+\n+        target = withIndexCheck(target, labels.length);\n@@ -176,73 +175,0 @@\n-    \/*\n-     * Construct test chains for labels inside switch, to handle switch repeats:\n-     * switch (idx) {\n-     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n-     *     case 1 -> if (selector matches label[1]) return 1; else ...\n-     *     ...\n-     * }\n-     *\/\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        MethodHandle[] testChains = new MethodHandle[labels.length];\n-        List<Object> labelsList = List.of(labels).reversed();\n-\n-        for (int i = 0; i < labels.length; i++) {\n-            MethodHandle test = def;\n-            int idx = labels.length - 1;\n-            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n-\n-            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n-                Object currentLabel = currentLabels.get(j);\n-                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n-                MethodHandle currentTest;\n-                if (currentLabel instanceof Class<?>) {\n-                    currentTest = INSTANCEOF_CHECK;\n-                } else if (currentLabel instanceof Integer) {\n-                    currentTest = INTEGER_EQ_CHECK;\n-                } else if (currentLabel instanceof EnumDesc) {\n-                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n-                } else {\n-                    currentTest = OBJECT_EQ_CHECK;\n-                }\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n-                                                   test);\n-            }\n-            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n-        }\n-\n-        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n-    }\n-\n-    \/*\n-     * Construct code that maps the given selector and repeat index to a case label number:\n-     * if (selector == null) return -1;\n-     * else return \"createRepeatIndexSwitch(labels)\"\n-     *\/\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle mainTest;\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        if (labels.length > 0) {\n-            mainTest = createRepeatIndexSwitch(lookup, labels);\n-        } else {\n-            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n-        }\n-        MethodHandle body =\n-                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n-                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                            mainTest);\n-        MethodHandle switchImpl =\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n-        return withIndexCheck(switchImpl, labels.length);\n-    }\n-\n-    private static boolean integerEqCheck(Object value, Integer constant) {\n-        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n-            return true;\n-        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n@@ -333,1 +259,1 @@\n-            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            \/\/else return \"typeSwitch(labels)\"\n@@ -338,1 +264,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            generateInnerClass(lookup, labels),\n@@ -342,1 +268,1 @@\n-            target = createMethodHandleSwitch(lookup, labels);\n+            target = generateInnerClass(lookup, labels);\n@@ -392,3 +318,2 @@\n-    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n-        if (resolvedEnum.resolvedEnum == null) {\n-            Object resolved;\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n@@ -396,2 +321,2 @@\n-            try {\n-                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n@@ -399,3 +324,1 @@\n-                if (value.getClass() != clazz) {\n-                    return false;\n-                }\n+    private static final class ResolvedEnumLabels implements BiFunction<Integer, Object, Object> {\n@@ -403,4 +326,4 @@\n-                resolved = label.resolveConstantDesc(lookup);\n-            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n-                resolved = SENTINEL;\n-            }\n+        private final MethodHandles.Lookup lookup;\n+        private final EnumDesc<?>[] enumDescs;\n+        @Stable\n+        private Object[] resolvedEnum;\n@@ -408,1 +331,4 @@\n-            resolvedEnum.resolvedEnum = resolved;\n+        public ResolvedEnumLabels(MethodHandles.Lookup lookup, EnumDesc<?>[] enumDescs) {\n+            this.lookup = lookup;\n+            this.enumDescs = enumDescs;\n+            this.resolvedEnum = new Object[enumDescs.length];\n@@ -411,2 +337,3 @@\n-        return value == resolvedEnum.resolvedEnum;\n-    }\n+        @Override\n+        public Object apply(Integer labelIndex, Object value) {\n+            Object result = resolvedEnum[labelIndex];\n@@ -414,2 +341,4 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+            if (result == null) {\n+                try {\n+                    EnumDesc<?> label = enumDescs[labelIndex];\n+                    Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -417,2 +346,3 @@\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n+                    if (value.getClass() != clazz) {\n+                        return SENTINEL;\n+                    }\n@@ -420,3 +350,10 @@\n-    private static final class ResolvedEnumLabel {\n-        @Stable\n-        public Object resolvedEnum;\n+                    result = label.resolveConstantDesc(lookup);\n+                } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                    result = SENTINEL;\n+                }\n+\n+                resolvedEnum[labelIndex] = result;\n+            }\n+\n+            return result;\n+        }\n@@ -429,0 +366,158 @@\n+\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0;\n+     *     case 1 -> if (selector matches label[1]) return 1;\n+     *     ...\n+     * }\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+\n+        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+            clb.withFlags(AccessFlag.FINAL, AccessFlag.SYNTHETIC)\n+              .withMethod(\"typeSwitch\", MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiFunction;)I\"), Classfile.ACC_STATIC, mb -> {\n+                  mb.withFlags(AccessFlag.PUBLIC, AccessFlag.FINAL, AccessFlag.STATIC)\n+                    .withCode(cb -> {\n+                        cb.aload(0);\n+                        Label nonNullLabel = cb.newLabel();\n+                        cb.if_nonnull(nonNullLabel);\n+                        cb.iconst_m1();\n+                        cb.ireturn();\n+                        cb.labelBinding(nonNullLabel);\n+                        if (labels.length == 0) {\n+                            cb.constantInstruction(0)\n+                              .ireturn();\n+                            return ;\n+                        }\n+                        cb.iload(1);\n+                        Label dflt = cb.newLabel();\n+                        record Element(Label target, Label next, Object label) {}\n+                        List<Element> cases = new ArrayList<>();\n+                        List<SwitchCase> switchCases = new ArrayList<>();\n+                        Object lastLabel = null;\n+                        for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                            Object currentLabel = labels[idx];\n+                            Label target = cb.newLabel();\n+                            Label next;\n+                            if (lastLabel == null) {\n+                                next = dflt;\n+                            } else if (lastLabel.equals(currentLabel)) {\n+                                next = cases.getLast().next();\n+                            } else {\n+                                next = cases.getLast().target();\n+                            }\n+                            lastLabel = currentLabel;\n+                            cases.add(new Element(target, next, currentLabel));\n+                            switchCases.add(SwitchCase.of(idx, target));\n+                        }\n+                        cases = cases.reversed();\n+                        switchCases = switchCases.reversed();\n+                        cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                        for (int idx = 0; idx < cases.size(); idx++) {\n+                            Element element = cases.get(idx);\n+                            Label next = element.next();\n+                            cb.labelBinding(element.target());\n+                            if (element.label() instanceof Class<?> classLabel) {\n+                                cb.aload(0);\n+                                cb.instanceof_(classLabel.describeConstable().get());\n+                                cb.ifeq(next);\n+                            } else if (element.label() instanceof EnumDesc<?> enumLabel) {\n+                                int enumIdx = enumDescs.size();\n+                                enumDescs.add(enumLabel);\n+                                cb.aload(2);\n+                                cb.constantInstruction(enumIdx);\n+                                cb.invokestatic(Integer.class.describeConstable().get(),\n+                                                \"valueOf\",\n+                                                MethodType.methodType(Integer.class,\n+                                                                      int.class)\n+                                                          .describeConstable()\n+                                                          .get());\n+                                cb.aload(0);\n+                                cb.invokeinterface(BiFunction.class.describeConstable().get(),\n+                                                   \"apply\",\n+                                                   MethodType.methodType(Object.class,\n+                                                                         Object.class,\n+                                                                         Object.class)\n+                                                             .describeConstable()\n+                                                             .get());\n+                                cb.aload(0);\n+                                cb.if_acmpne(next);\n+                            } else if (element.label() instanceof String stringLabel) {\n+                                cb.ldc(stringLabel);\n+                                cb.aload(0);\n+                                cb.invokevirtual(Object.class.describeConstable().get(),\n+                                                 \"equals\",\n+                                                 MethodType.methodType(boolean.class,\n+                                                                       Object.class)\n+                                                           .describeConstable()\n+                                                           .get());\n+                                cb.ifeq(next);\n+                            } else if (element.label() instanceof Integer integerLabel) {\n+                                Label compare = cb.newLabel();\n+                                Label notNumber = cb.newLabel();\n+                                cb.aload(0);\n+                                cb.instanceof_(Number.class.describeConstable().get());\n+                                cb.ifeq(notNumber);\n+                                cb.aload(0);\n+                                cb.checkcast(Number.class.describeConstable().get());\n+                                cb.invokevirtual(Number.class.describeConstable().get(),\n+                                                 \"intValue\",\n+                                                 MethodType.methodType(int.class)\n+                                                           .describeConstable()\n+                                                           .get());\n+                                cb.goto_(compare);\n+                                cb.labelBinding(notNumber);\n+                                cb.aload(0);\n+                                cb.instanceof_(Character.class.describeConstable().get());\n+                                cb.ifeq(next);\n+                                cb.aload(0);\n+                                cb.checkcast(Character.class.describeConstable().get());\n+                                cb.invokevirtual(Character.class.describeConstable().get(),\n+                                                 \"charValue\",\n+                                                 MethodType.methodType(char.class)\n+                                                           .describeConstable()\n+                                                           .get());\n+                                cb.labelBinding(compare);\n+                                cb.ldc(integerLabel);\n+                                cb.if_icmpne(next);\n+                            } else {\n+                                throw new InternalError(\"Unsupported label type: \" + element.label().getClass());\n+                            }\n+                            cb.constantInstruction(idx);\n+                            cb.ireturn();\n+                        }\n+                        cb.labelBinding(dflt);\n+                        cb.constantInstruction(cases.size());\n+                        cb.ireturn();\n+                    });\n+              });\n+        });\n+\n+        try {\n+            \/\/ this class is linked at the indy callsite; so define a hidden nestmate\n+            MethodHandles.Lookup lookup;\n+            lookup = caller.defineHiddenClass(classBytes, true, NESTMATE, STRONG);\n+            MethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(),\n+                                                        \"typeSwitch\",\n+                                                        MethodType.methodType(int.class,\n+                                                                              Object.class,\n+                                                                              int.class,\n+                                                                              BiFunction.class));\n+            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(s -> new EnumDesc<?>[s])));\n+        } catch (Throwable t) {\n+            throw new IllegalArgumentException(t);\n+        }\n+    }\n+\n+    \/\/based on src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java:\n+    private static String typeSwitchClassName(Class<?> targetClass) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$TypeSwitch\";\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":207,"deletions":112,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -111,3 +111,6 @@\n-        testType(\"\", 0, 0, String.class, String.class, String.class);\n-        testType(\"\", 1, 1, String.class, String.class, String.class);\n-        testType(\"\", 2, 2, String.class, String.class, String.class);\n+        testType(\"\", 0, 0, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 4, 4, String.class, String.class, String.class, String.class, String.class);\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}