{"files":[{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +37,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -36,0 +41,2 @@\n+import java.util.Optional;\n+import java.util.function.BiPredicate;\n@@ -38,0 +45,3 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.SwitchCase;\n@@ -40,0 +50,2 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -57,4 +69,0 @@\n-    private static final MethodHandle INSTANCEOF_CHECK;\n-    private static final MethodHandle INTEGER_EQ_CHECK;\n-    private static final MethodHandle OBJECT_EQ_CHECK;\n-    private static final MethodHandle ENUM_EQ_CHECK;\n@@ -66,0 +74,3 @@\n+    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n+\n@@ -68,9 +79,0 @@\n-            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n-                                                                                 MethodType.methodType(boolean.class, Object.class)),\n-                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n-            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n-            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n-                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n-            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n@@ -158,1 +160,3 @@\n-        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+        MethodHandle target = generateInnerClass(lookup, labels);\n+\n+        target = withIndexCheck(target, labels.length);\n@@ -176,73 +180,0 @@\n-    \/*\n-     * Construct test chains for labels inside switch, to handle switch repeats:\n-     * switch (idx) {\n-     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n-     *     case 1 -> if (selector matches label[1]) return 1; else ...\n-     *     ...\n-     * }\n-     *\/\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        MethodHandle[] testChains = new MethodHandle[labels.length];\n-        List<Object> labelsList = List.of(labels).reversed();\n-\n-        for (int i = 0; i < labels.length; i++) {\n-            MethodHandle test = def;\n-            int idx = labels.length - 1;\n-            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n-\n-            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n-                Object currentLabel = currentLabels.get(j);\n-                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n-                MethodHandle currentTest;\n-                if (currentLabel instanceof Class<?>) {\n-                    currentTest = INSTANCEOF_CHECK;\n-                } else if (currentLabel instanceof Integer) {\n-                    currentTest = INTEGER_EQ_CHECK;\n-                } else if (currentLabel instanceof EnumDesc) {\n-                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n-                } else {\n-                    currentTest = OBJECT_EQ_CHECK;\n-                }\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n-                                                   test);\n-            }\n-            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n-        }\n-\n-        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n-    }\n-\n-    \/*\n-     * Construct code that maps the given selector and repeat index to a case label number:\n-     * if (selector == null) return -1;\n-     * else return \"createRepeatIndexSwitch(labels)\"\n-     *\/\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle mainTest;\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        if (labels.length > 0) {\n-            mainTest = createRepeatIndexSwitch(lookup, labels);\n-        } else {\n-            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n-        }\n-        MethodHandle body =\n-                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n-                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                            mainTest);\n-        MethodHandle switchImpl =\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n-        return withIndexCheck(switchImpl, labels.length);\n-    }\n-\n-    private static boolean integerEqCheck(Object value, Integer constant) {\n-        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n-            return true;\n-        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n@@ -333,1 +264,1 @@\n-            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            \/\/else return \"typeSwitch(labels)\"\n@@ -338,1 +269,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            generateInnerClass(lookup, labels),\n@@ -342,1 +273,1 @@\n-            target = createMethodHandleSwitch(lookup, labels);\n+            target = generateInnerClass(lookup, labels);\n@@ -363,1 +294,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n+            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n@@ -392,3 +323,2 @@\n-    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n-        if (resolvedEnum.resolvedEnum == null) {\n-            Object resolved;\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n@@ -396,2 +326,2 @@\n-            try {\n-                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n@@ -399,3 +329,1 @@\n-                if (value.getClass() != clazz) {\n-                    return false;\n-                }\n+    private static final class ResolvedEnumLabels implements BiPredicate<Integer, Object> {\n@@ -403,4 +331,4 @@\n-                resolved = label.resolveConstantDesc(lookup);\n-            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n-                resolved = SENTINEL;\n-            }\n+        private final MethodHandles.Lookup lookup;\n+        private final EnumDesc<?>[] enumDescs;\n+        @Stable\n+        private Object[] resolvedEnum;\n@@ -408,1 +336,4 @@\n-            resolvedEnum.resolvedEnum = resolved;\n+        public ResolvedEnumLabels(MethodHandles.Lookup lookup, EnumDesc<?>[] enumDescs) {\n+            this.lookup = lookup;\n+            this.enumDescs = enumDescs;\n+            this.resolvedEnum = new Object[enumDescs.length];\n@@ -411,2 +342,3 @@\n-        return value == resolvedEnum.resolvedEnum;\n-    }\n+        @Override\n+        public boolean test(Integer labelIndex, Object value) {\n+            Object result = resolvedEnum[labelIndex];\n@@ -414,2 +346,4 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+            if (result == null) {\n+                try {\n+                    EnumDesc<?> label = enumDescs[labelIndex];\n+                    Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -417,2 +351,3 @@\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n+                    if (value.getClass() != clazz) {\n+                        return false;\n+                    }\n@@ -420,3 +355,10 @@\n-    private static final class ResolvedEnumLabel {\n-        @Stable\n-        public Object resolvedEnum;\n+                    result = label.resolveConstantDesc(lookup);\n+                } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                    result = SENTINEL;\n+                }\n+\n+                resolvedEnum[labelIndex] = result;\n+            }\n+\n+            return result == value;\n+        }\n@@ -429,0 +371,169 @@\n+\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0;\n+     *     case 1 -> if (selector matches label[1]) return 1;\n+     *     ...\n+     * }\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"typeSwitch\",\n+                               TYPES_SWITCH_DESCRIPTOR,\n+                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               cb -> {\n+                    cb.aload(0);\n+                    Label nonNullLabel = cb.newLabel();\n+                    cb.if_nonnull(nonNullLabel);\n+                    cb.iconst_m1();\n+                    cb.ireturn();\n+                    cb.labelBinding(nonNullLabel);\n+                    if (labels.length == 0) {\n+                        cb.constantInstruction(0)\n+                          .ireturn();\n+                        return ;\n+                    }\n+                    cb.iload(1);\n+                    Label dflt = cb.newLabel();\n+                    record Element(Label target, Label next, Object caseLabel) {}\n+                    List<Element> cases = new ArrayList<>();\n+                    List<SwitchCase> switchCases = new ArrayList<>();\n+                    Object lastLabel = null;\n+                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                        Object currentLabel = labels[idx];\n+                        Label target = cb.newLabel();\n+                        Label next;\n+                        if (lastLabel == null) {\n+                            next = dflt;\n+                        } else if (lastLabel.equals(currentLabel)) {\n+                            next = cases.getLast().next();\n+                        } else {\n+                            next = cases.getLast().target();\n+                        }\n+                        lastLabel = currentLabel;\n+                        cases.add(new Element(target, next, currentLabel));\n+                        switchCases.add(SwitchCase.of(idx, target));\n+                    }\n+                    cases = cases.reversed();\n+                    switchCases = switchCases.reversed();\n+                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                    for (int idx = 0; idx < cases.size(); idx++) {\n+                        Element element = cases.get(idx);\n+                        Label next = element.next();\n+                        cb.labelBinding(element.target());\n+                        if (element.caseLabel() instanceof Class<?> classLabel) {\n+                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                            if (classLabelConstableOpt.isPresent()) {\n+                                cb.aload(0);\n+                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                                cb.ifeq(next);\n+                            } else {\n+                                cb.aload(3);\n+                                cb.constantInstruction(extraClassLabels.size());\n+                                cb.invokeinterface(ConstantDescs.CD_List,\n+                                                   \"get\",\n+                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                                                     ConstantDescs.CD_int));\n+                                cb.checkcast(ConstantDescs.CD_Class);\n+                                cb.aload(0);\n+                                cb.invokevirtual(ConstantDescs.CD_Class,\n+                                                 \"isInstance\",\n+                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(next);\n+                                extraClassLabels.add(classLabel);\n+                            }\n+                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                            int enumIdx = enumDescs.size();\n+                            enumDescs.add(enumLabel);\n+                            cb.aload(2);\n+                            cb.constantInstruction(enumIdx);\n+                            cb.invokestatic(ConstantDescs.CD_Integer,\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                                              ConstantDescs.CD_int));\n+                            cb.aload(0);\n+                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                                               \"test\",\n+                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                 ConstantDescs.CD_Object,\n+                                                                 ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof String stringLabel) {\n+                            cb.ldc(stringLabel);\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                            Label compare = cb.newLabel();\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.ifeq(notNumber);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.invokevirtual(ConstantDescs.CD_Number,\n+                                             \"intValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n+                            cb.goto_(compare);\n+                            cb.labelBinding(notNumber);\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Character);\n+                            cb.ifeq(next);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Character);\n+                            cb.invokevirtual(ConstantDescs.CD_Character,\n+                                             \"charValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n+                            cb.labelBinding(compare);\n+                            cb.ldc(integerLabel);\n+                            cb.if_icmpne(next);\n+                        } else {\n+                            throw new InternalError(\"Unsupported label type: \" +\n+                                                    element.caseLabel().getClass());\n+                        }\n+                        cb.constantInstruction(idx);\n+                        cb.ireturn();\n+                    }\n+                    cb.labelBinding(dflt);\n+                    cb.constantInstruction(cases.size());\n+                    cb.ireturn();\n+                });\n+        });\n+\n+        try {\n+            \/\/ this class is linked at the indy callsite; so define a hidden nestmate\n+            MethodHandles.Lookup lookup;\n+            lookup = caller.defineHiddenClass(classBytes, true, NESTMATE, STRONG);\n+            MethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(),\n+                                                        \"typeSwitch\",\n+                                                        MethodType.methodType(int.class,\n+                                                                              Object.class,\n+                                                                              int.class,\n+                                                                              BiPredicate.class,\n+                                                                              List.class));\n+            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                                List.copyOf(extraClassLabels));\n+        } catch (Throwable t) {\n+            throw new IllegalArgumentException(t);\n+        }\n+    }\n+\n+    \/\/based on src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java:\n+    private static String typeSwitchClassName(Class<?> targetClass) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$TypeSwitch\";\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":224,"deletions":113,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -33,0 +36,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -44,0 +48,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -111,3 +116,6 @@\n-        testType(\"\", 0, 0, String.class, String.class, String.class);\n-        testType(\"\", 1, 1, String.class, String.class, String.class);\n-        testType(\"\", 2, 2, String.class, String.class, String.class);\n+        testType(\"\", 0, 0, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 4, 4, String.class, String.class, String.class, String.class, String.class);\n@@ -319,0 +327,28 @@\n+    public void testHiddenClassAsCaseLabel() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        byte[] classBytes = createClass();\n+        Class<?> classA = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Class<?> classB = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Object[] labels = new Object[] {\n+            classA,\n+            classB,\n+        };\n+        testType(classA.getConstructor().newInstance(), 0, 0, labels);\n+        testType(classB.getConstructor().newInstance(), 0, 1, labels);\n+    }\n+\n+    private static byte[] createClass() {\n+        return Classfile.of().build(ClassDesc.of(\"C\"), clb -> {\n+            clb.withFlags(AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"<init>\",\n+                               MethodTypeDesc.of(ConstantDescs.CD_void),\n+                               Classfile.ACC_PUBLIC,\n+                               cb -> {\n+                                   cb.aload(0);\n+                                   cb.invokespecial(ConstantDescs.CD_Object,\n+                                                    \"<init>\",\n+                                                    MethodTypeDesc.of(ConstantDescs.CD_void));\n+                                   cb.return_();\n+                               });\n+                    });\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"}]}