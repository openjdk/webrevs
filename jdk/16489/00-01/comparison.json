{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -40,1 +41,1 @@\n-import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n@@ -72,0 +73,3 @@\n+    private static final MethodTypeDesc typesSwitchDescriptor =\n+            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;[Ljava\/lang\/Class;)I\");\n+\n@@ -289,1 +293,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n+            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n@@ -324,1 +328,1 @@\n-    private static final class ResolvedEnumLabels implements BiFunction<Integer, Object, Object> {\n+    private static final class ResolvedEnumLabels implements BiPredicate<Integer, Object> {\n@@ -338,1 +342,1 @@\n-        public Object apply(Integer labelIndex, Object value) {\n+        public boolean test(Integer labelIndex, Object value) {\n@@ -347,1 +351,1 @@\n-                        return SENTINEL;\n+                        return false;\n@@ -358,1 +362,1 @@\n-            return result;\n+            return result == value;\n@@ -378,0 +382,1 @@\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n@@ -381,34 +386,31 @@\n-              .withMethod(\"typeSwitch\", MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiFunction;)I\"), Classfile.ACC_STATIC, mb -> {\n-                  mb.withFlags(AccessFlag.PUBLIC, AccessFlag.FINAL, AccessFlag.STATIC)\n-                    .withCode(cb -> {\n-                        cb.aload(0);\n-                        Label nonNullLabel = cb.newLabel();\n-                        cb.if_nonnull(nonNullLabel);\n-                        cb.iconst_m1();\n-                        cb.ireturn();\n-                        cb.labelBinding(nonNullLabel);\n-                        if (labels.length == 0) {\n-                            cb.constantInstruction(0)\n-                              .ireturn();\n-                            return ;\n-                        }\n-                        cb.iload(1);\n-                        Label dflt = cb.newLabel();\n-                        record Element(Label target, Label next, Object label) {}\n-                        List<Element> cases = new ArrayList<>();\n-                        List<SwitchCase> switchCases = new ArrayList<>();\n-                        Object lastLabel = null;\n-                        for (int idx = labels.length - 1; idx >= 0; idx--) {\n-                            Object currentLabel = labels[idx];\n-                            Label target = cb.newLabel();\n-                            Label next;\n-                            if (lastLabel == null) {\n-                                next = dflt;\n-                            } else if (lastLabel.equals(currentLabel)) {\n-                                next = cases.getLast().next();\n-                            } else {\n-                                next = cases.getLast().target();\n-                            }\n-                            lastLabel = currentLabel;\n-                            cases.add(new Element(target, next, currentLabel));\n-                            switchCases.add(SwitchCase.of(idx, target));\n+               .withMethodBody(\"typeSwitch\",\n+                               typesSwitchDescriptor,\n+                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               cb -> {\n+                    cb.aload(0);\n+                    Label nonNullLabel = cb.newLabel();\n+                    cb.if_nonnull(nonNullLabel);\n+                    cb.iconst_m1();\n+                    cb.ireturn();\n+                    cb.labelBinding(nonNullLabel);\n+                    if (labels.length == 0) {\n+                        cb.constantInstruction(0)\n+                          .ireturn();\n+                        return ;\n+                    }\n+                    cb.iload(1);\n+                    Label dflt = cb.newLabel();\n+                    record Element(Label target, Label next, Object caseLabel) {}\n+                    List<Element> cases = new ArrayList<>();\n+                    List<SwitchCase> switchCases = new ArrayList<>();\n+                    Object lastLabel = null;\n+                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                        Object currentLabel = labels[idx];\n+                        Label target = cb.newLabel();\n+                        Label next;\n+                        if (lastLabel == null) {\n+                            next = dflt;\n+                        } else if (lastLabel.equals(currentLabel)) {\n+                            next = cases.getLast().next();\n+                        } else {\n+                            next = cases.getLast().target();\n@@ -416,75 +418,78 @@\n-                        cases = cases.reversed();\n-                        switchCases = switchCases.reversed();\n-                        cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n-                        for (int idx = 0; idx < cases.size(); idx++) {\n-                            Element element = cases.get(idx);\n-                            Label next = element.next();\n-                            cb.labelBinding(element.target());\n-                            if (element.label() instanceof Class<?> classLabel) {\n-                                cb.aload(0);\n-                                cb.instanceof_(classLabel.describeConstable().get());\n-                                cb.ifeq(next);\n-                            } else if (element.label() instanceof EnumDesc<?> enumLabel) {\n-                                int enumIdx = enumDescs.size();\n-                                enumDescs.add(enumLabel);\n-                                cb.aload(2);\n-                                cb.constantInstruction(enumIdx);\n-                                cb.invokestatic(Integer.class.describeConstable().get(),\n-                                                \"valueOf\",\n-                                                MethodType.methodType(Integer.class,\n-                                                                      int.class)\n-                                                          .describeConstable()\n-                                                          .get());\n-                                cb.aload(0);\n-                                cb.invokeinterface(BiFunction.class.describeConstable().get(),\n-                                                   \"apply\",\n-                                                   MethodType.methodType(Object.class,\n-                                                                         Object.class,\n-                                                                         Object.class)\n-                                                             .describeConstable()\n-                                                             .get());\n-                                cb.aload(0);\n-                                cb.if_acmpne(next);\n-                            } else if (element.label() instanceof String stringLabel) {\n-                                cb.ldc(stringLabel);\n-                                cb.aload(0);\n-                                cb.invokevirtual(Object.class.describeConstable().get(),\n-                                                 \"equals\",\n-                                                 MethodType.methodType(boolean.class,\n-                                                                       Object.class)\n-                                                           .describeConstable()\n-                                                           .get());\n-                                cb.ifeq(next);\n-                            } else if (element.label() instanceof Integer integerLabel) {\n-                                Label compare = cb.newLabel();\n-                                Label notNumber = cb.newLabel();\n-                                cb.aload(0);\n-                                cb.instanceof_(Number.class.describeConstable().get());\n-                                cb.ifeq(notNumber);\n-                                cb.aload(0);\n-                                cb.checkcast(Number.class.describeConstable().get());\n-                                cb.invokevirtual(Number.class.describeConstable().get(),\n-                                                 \"intValue\",\n-                                                 MethodType.methodType(int.class)\n-                                                           .describeConstable()\n-                                                           .get());\n-                                cb.goto_(compare);\n-                                cb.labelBinding(notNumber);\n-                                cb.aload(0);\n-                                cb.instanceof_(Character.class.describeConstable().get());\n-                                cb.ifeq(next);\n-                                cb.aload(0);\n-                                cb.checkcast(Character.class.describeConstable().get());\n-                                cb.invokevirtual(Character.class.describeConstable().get(),\n-                                                 \"charValue\",\n-                                                 MethodType.methodType(char.class)\n-                                                           .describeConstable()\n-                                                           .get());\n-                                cb.labelBinding(compare);\n-                                cb.ldc(integerLabel);\n-                                cb.if_icmpne(next);\n-                            } else {\n-                                throw new InternalError(\"Unsupported label type: \" + element.label().getClass());\n-                            }\n-                            cb.constantInstruction(idx);\n-                            cb.ireturn();\n+                        lastLabel = currentLabel;\n+                        cases.add(new Element(target, next, currentLabel));\n+                        switchCases.add(SwitchCase.of(idx, target));\n+                    }\n+                    cases = cases.reversed();\n+                    switchCases = switchCases.reversed();\n+                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                    for (int idx = 0; idx < cases.size(); idx++) {\n+                        Element element = cases.get(idx);\n+                        Label next = element.next();\n+                        cb.labelBinding(element.target());\n+                        if (element.caseLabel() instanceof Class<?> classLabel &&\n+                            classLabel.describeConstable().isPresent()) {\n+                            cb.aload(0);\n+                            cb.instanceof_(classLabel.describeConstable().orElseThrow());\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Class<?> classLabel) {\n+                            cb.aload(3);\n+                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.aaload();\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                             \"isInstance\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                            extraClassLabels.add(classLabel);\n+                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                            int enumIdx = enumDescs.size();\n+                            enumDescs.add(enumLabel);\n+                            cb.aload(2);\n+                            cb.constantInstruction(enumIdx);\n+                            cb.invokestatic(ConstantDescs.CD_Integer,\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                                              ConstantDescs.CD_int));\n+                            cb.aload(0);\n+                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                                               \"test\",\n+                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                 ConstantDescs.CD_Object,\n+                                                                 ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof String stringLabel) {\n+                            cb.ldc(stringLabel);\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                            Label compare = cb.newLabel();\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.ifeq(notNumber);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.invokevirtual(ConstantDescs.CD_Number,\n+                                             \"intValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n+                            cb.goto_(compare);\n+                            cb.labelBinding(notNumber);\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Character);\n+                            cb.ifeq(next);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Character);\n+                            cb.invokevirtual(ConstantDescs.CD_Character,\n+                                             \"charValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n+                            cb.labelBinding(compare);\n+                            cb.ldc(integerLabel);\n+                            cb.if_icmpne(next);\n+                        } else {\n+                            throw new InternalError(\"Unsupported label type: \" +\n+                                                    element.caseLabel().getClass());\n@@ -492,2 +497,1 @@\n-                        cb.labelBinding(dflt);\n-                        cb.constantInstruction(cases.size());\n+                        cb.constantInstruction(idx);\n@@ -495,2 +499,5 @@\n-                    });\n-              });\n+                    }\n+                    cb.labelBinding(dflt);\n+                    cb.constantInstruction(cases.size());\n+                    cb.ireturn();\n+                });\n@@ -508,2 +515,4 @@\n-                                                                              BiFunction.class));\n-            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(s -> new EnumDesc<?>[s])));\n+                                                                              BiPredicate.class,\n+                                                                              Class[].class));\n+            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(s -> new EnumDesc<?>[s])),\n+                                                                extraClassLabels.toArray(s -> new Class<?>[s]));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":130,"deletions":121,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -33,0 +36,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -44,0 +48,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -322,0 +327,28 @@\n+    public void testHiddenClassAsCaseLabel() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        byte[] classBytes = createClass();\n+        Class<?> classA = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Class<?> classB = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Object[] labels = new Object[] {\n+            classA,\n+            classB,\n+        };\n+        testType(classA.getConstructor().newInstance(), 0, 0, labels);\n+        testType(classB.getConstructor().newInstance(), 0, 1, labels);\n+    }\n+\n+    private static byte[] createClass() {\n+        return Classfile.of().build(ClassDesc.of(\"C\"), clb -> {\n+            clb.withFlags(AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"<init>\",\n+                               MethodTypeDesc.of(ConstantDescs.CD_void),\n+                               Classfile.ACC_PUBLIC,\n+                               cb -> {\n+                                   cb.aload(0);\n+                                   cb.invokespecial(ConstantDescs.CD_Object,\n+                                                    \"<init>\",\n+                                                    MethodTypeDesc.of(ConstantDescs.CD_void));\n+                                   cb.return_();\n+                               });\n+                    });\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"}]}