{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.net.http.HttpClient;\n@@ -78,1 +79,1 @@\n-        this.sniServerNames = formSNIServerNames(serverName);\n+        this.sniServerNames = formSNIServerNames(serverName, client);\n@@ -105,0 +106,14 @@\n+    \/**\n+     * Returns the {@link SSLParameters} to be used by the {@link SSLEngine} for this connection.\n+     * <p>\n+     * The returned {@code SSLParameters} will have its {@link SNIServerName}s set to the given\n+     * {@code sniServerNames}. If {@code alpn} is non-null then the returned {@code SSLParameters}\n+     * will have its {@linkplain SSLParameters#getApplicationProtocols() application layer protocols}\n+     * set to this value. All other parameters in the returned {@code SSLParameters} will be\n+     * copied over from {@link HttpClient#sslParameters()} of the given {@code client}.\n+     *\n+     * @param client         the HttpClient\n+     * @param sniServerNames the SNIServerName(s)\n+     * @param alpn           the application layer protocols\n+     * @return the SSLParameters to be set on the SSLEngine used by this connection.\n+     *\/\n@@ -135,7 +150,21 @@\n-    private static List<SNIServerName> formSNIServerNames(final ServerName serverName) {\n-        if (serverName == null) {\n-            return List.of();\n-        }\n-        if (!serverName.isLiteral()) {\n-            String name = serverName.name();\n-            if (name != null && name.length() > 0) {\n+    \/**\n+     * Returns a list of {@link SNIServerName}s that are expected to be used to\n+     * configure the {@link SSLEngine} used by this connection.\n+     * <p>\n+     * The given {@code serverName} is given preference, and if it is not null and\n+     * is not a IP address literal, then the returned list will contain only one\n+     * {@code SNIServerName} formed out of the {@code serverName}. If {@code serverName}\n+     * is null or is an IP address literal then the {@code SNIServerName}(s)\n+     * configured through {@link HttpClient#sslParameters()} will be returned. If none have\n+     * been configured, then an empty list is returned.\n+     *\n+     * @param serverName the {@link ServerName}, typically computed based on the request URI\n+     * @param client     the {@code HttpClient}\n+     * @return a list of {@code SNIServerName}s to be used by the {@code SSLEngine}\n+     *         of this connection.\n+     *\/\n+    private static List<SNIServerName> formSNIServerNames(final ServerName serverName,\n+                                                          final HttpClientImpl client) {\n+        if (serverName != null && !serverName.isLiteral()) {\n+            final String name = serverName.name();\n+            if (name != null && !name.isEmpty()) {\n@@ -145,1 +174,4 @@\n-        return List.of();\n+        \/\/ fallback on any SNIServerName(s) configured through HttpClient.sslParameters()\n+        final SSLParameters clientSSLParams = client.sslParameters();\n+        final List<SNIServerName> clientConfigured = clientSSLParams.getServerNames();\n+        return clientConfigured != null ? clientConfigured : List.of();\n@@ -148,1 +180,1 @@\n-    private static SSLEngine createEngine(SSLContext context, String serverName, int port,\n+    private static SSLEngine createEngine(SSLContext context, String peerHost, int port,\n@@ -150,1 +182,1 @@\n-        SSLEngine engine = context.createSSLEngine(serverName, port);\n+        SSLEngine engine = context.createSSLEngine(peerHost, port);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AbstractAsyncSSLConnection.java","additions":44,"deletions":12,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.List;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsParameters;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.common.ServerNameMatcher;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8346705\n+ * @summary verify the behaviour of java.net.http.HttpClient\n+ *          when sending a Server Name Indication in the TLS\n+ *          connections that it establishes for the requests\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.test.lib.net.URIBuilder\n+ * @run junit HttpClientSNITest\n+ *\/\n+public class HttpClientSNITest {\n+    private static final String RESP_BODY_TEXT = \"hello world\";\n+\n+    private static SSLContext sslContext;\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exch) throws IOException {\n+            System.out.println(\"handling request \" + exch.getRequestURI());\n+            final byte[] respBody = RESP_BODY_TEXT.getBytes(US_ASCII);\n+            exch.sendResponseHeaders(200, respBody.length);\n+            try (final OutputStream os = exch.getResponseBody()) {\n+                os.write(respBody);\n+            }\n+        }\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        assertNotNull(sslContext, \"could not create a SSLContext\");\n+    }\n+\n+    \/*\n+     * Creates and configures a HTTPS server with a SNIMatcher that\n+     * expects a specific SNI name to be sent by the connection client.\n+     * The test uses a HttpClient to issue a couple of requests with the URI having\n+     * a IP address literal as the host. For one of the request, the HttpClient\n+     * is configured with specific ServerName(s) through HttpClient.sslParameters()\n+     * and for the other request, it isn't.\n+     * The test then verifies that for such requests with a IP address literal as the host,\n+     * the HttpClient sends across the ServerName(s) if any has been configured on the client.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    void testRequestToIPLiteralHost(final boolean sniConfiguredOnClient) throws Exception {\n+        final String expectedSNI = \"non-dns-resolvable.foo.bar.localhost\";\n+        final ServerNameMatcher matcher = new ServerNameMatcher(expectedSNI);\n+        final HttpTestServer server = createServer(matcher);\n+        try {\n+            final HttpClient.Builder builder = HttpClient.newBuilder().sslContext(sslContext);\n+            if (sniConfiguredOnClient) {\n+                final SSLParameters clientConfiguredSSLParams = new SSLParameters();\n+                clientConfiguredSSLParams.setServerNames(List.of(new SNIHostName(expectedSNI)));\n+                builder.sslParameters(clientConfiguredSSLParams);\n+            }\n+            try (final HttpClient client = builder.build()) {\n+                final String ipLiteral = InetAddress.getLoopbackAddress().getHostAddress();\n+                final URI reqURI = URIBuilder.newBuilder()\n+                        .host(ipLiteral)\n+                        .port(server.getAddress().getPort())\n+                        .scheme(\"https\")\n+                        .path(\"\/\")\n+                        .build();\n+                final HttpRequest req = HttpRequest.newBuilder(reqURI).build();\n+                System.out.println(\"issuing request \" + reqURI);\n+                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString(US_ASCII));\n+                assertEquals(200, resp.statusCode(), \"unexpected response status code\");\n+                assertEquals(RESP_BODY_TEXT, resp.body(), \"unexpected response body\");\n+                if (sniConfiguredOnClient) {\n+                    assertTrue(matcher.wasInvoked(), \"SNIMatcher wasn't invoked on the server\");\n+                } else {\n+                    assertFalse(matcher.wasInvoked(), \"SNIMatcher was unexpectedly invoked\" +\n+                            \" on the server\");\n+                }\n+            }\n+        } finally {\n+            System.out.println(\"stopping server \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/*\n+     * Creates and configures a HTTPS server with a SNIMatcher that\n+     * expects a specific SNI name to be sent by the connection client.\n+     * The test uses a HttpClient to issue a couple of requests with the URI having\n+     * a hostname (i.e. not a IP address literal) as the host. For one of the request,\n+     * the HttpClient is configured with specific ServerName(s) through\n+     * HttpClient.sslParameters() and for the other request, it isn't.\n+     * The test then verifies that for such requests with a hostname\n+     * (i.e. not a IP address literal) in the request URI,\n+     * the HttpClient never sends ServerName(s) that may have been configured on the\n+     * client and instead it sends the hostname (from the request URI) as the ServerName\n+     * for each of the request.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    void testRequestResolvedHostName(final boolean sniConfiguredOnClient) throws Exception {\n+        final String resolvedHostName = InetAddress.getLoopbackAddress().getHostName();\n+        final String expectedSNI = resolvedHostName;\n+        final ServerNameMatcher matcher = new ServerNameMatcher(expectedSNI);\n+        final HttpTestServer server = createServer(matcher);\n+        try {\n+            final HttpClient.Builder builder = HttpClient.newBuilder().sslContext(sslContext);\n+            if (sniConfiguredOnClient) {\n+                final SSLParameters clientConfiguredSSLParams = new SSLParameters();\n+                clientConfiguredSSLParams.setServerNames(List.of(new SNIHostName(\"does-not-matter\")));\n+                builder.sslParameters(clientConfiguredSSLParams);\n+            }\n+            try (final HttpClient client = builder.build()) {\n+                final URI reqURI = URIBuilder.newBuilder()\n+                        .host(resolvedHostName)\n+                        .port(server.getAddress().getPort())\n+                        .scheme(\"https\")\n+                        .path(\"\/\")\n+                        .build();\n+                final HttpRequest req = HttpRequest.newBuilder(reqURI).build();\n+                System.out.println(\"issuing request \" + reqURI);\n+                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString(US_ASCII));\n+                assertEquals(200, resp.statusCode(), \"unexpected response status code\");\n+                assertEquals(RESP_BODY_TEXT, resp.body(), \"unexpected response body\");\n+                assertTrue(matcher.wasInvoked(), \"SNIMatcher wasn't invoked on the server\");\n+            }\n+        } finally {\n+            System.out.println(\"stopping server \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/*\n+     * Creates a HttpsServer configured to use the given SNIMatcher\n+     *\/\n+    private static HttpTestServer createServer(final SNIMatcher matcher) throws Exception {\n+        final InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        final int backlog = 0;\n+        final HttpsServer httpsServer = HttpsServer.create(addr, backlog);\n+        final HttpsConfigurator configurator = new HttpsConfigurator(sslContext) {\n+            @Override\n+            public void configure(final HttpsParameters params) {\n+                final SSLParameters sslParameters = sslContext.getDefaultSSLParameters();\n+                \/\/ add the SNIMatcher\n+                sslParameters.setSNIMatchers(List.of(matcher));\n+                params.setSSLParameters(sslParameters);\n+                System.out.println(\"configured HttpsServer with SNIMatcher: \" + matcher);\n+            }\n+        };\n+        httpsServer.setHttpsConfigurator(configurator);\n+        final HttpTestServer server = HttpTestServer.of(httpsServer);\n+        server.addHandler(new Handler(), \"\/\");\n+        server.start();\n+        System.out.println(\"server started at \" + server.getAddress());\n+        return server;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientSNITest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+    private volatile boolean invoked;\n@@ -100,0 +101,1 @@\n+        this.invoked = true;\n@@ -131,0 +133,8 @@\n+    \/**\n+     * @return true if the {@link #matches(SNIServerName)} method of this SNIMatcher instance\n+     * was invoked at least once, false otherwise.\n+     *\/\n+    public boolean wasInvoked() {\n+        return this.invoked;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/ServerNameMatcher.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}