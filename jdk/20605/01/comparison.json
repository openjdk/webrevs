{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -250,0 +251,1 @@\n+  GCForwarding::initialize_flags(heap_reserved_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -1437,0 +1438,2 @@\n+  GCForwarding::initialize(heap_rs.region());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -44,1 +45,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -55,2 +56,2 @@\n-  assert(obj->is_forwarded(), \"Sanity!\");\n-  assert(obj->forwardee() != obj, \"Object must have a new location\");\n+  assert(GCForwarding::is_forwarded(obj), \"Sanity!\");\n+  assert(GCForwarding::forwardee(obj) != obj, \"Object must have a new location\");\n@@ -61,1 +62,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n@@ -124,1 +125,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -109,2 +110,2 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    GCForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(GCForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -112,1 +113,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(!GCForwarding::is_forwarded(object), \"must not be forwarded\");\n@@ -175,2 +176,2 @@\n-  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n-  assert(obj->is_forwarded(), \"Object must be forwarded!\");\n+  GCForwarding::forward_to(obj, cast_to_oop(dest_hr->bottom()));\n+  assert(GCForwarding::is_forwarded(obj), \"Object must be forwarded!\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -68,2 +69,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = obj->forwardee();\n+  if (GCForwarding::is_forwarded(obj)) {\n+    oop forwardee = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -117,1 +118,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -120,1 +121,1 @@\n-    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n+    if (cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj)) < _dense_prefix_top) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -130,0 +131,1 @@\n+  GCForwarding::initialize_flags(heap_reserved_size_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -132,0 +133,2 @@\n+  GCForwarding::initialize(heap_rs.region());\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -1595,1 +1596,1 @@\n-              obj->forward_to(cast_to_oop(new_addr));\n+              GCForwarding::forward_to(obj, cast_to_oop(new_addr));\n@@ -1638,1 +1639,1 @@\n-        assert(obj->forwardee() == cast_to_oop(bump_ptr), \"inv\");\n+        assert(GCForwarding::forwardee(obj) == cast_to_oop(bump_ptr), \"inv\");\n@@ -2401,2 +2402,2 @@\n-    assert(cast_to_oop(source())->is_forwarded(), \"inv\");\n-    assert(cast_to_oop(source())->forwardee() == cast_to_oop(destination()), \"inv\");\n+    assert(GCForwarding::is_forwarded(cast_to_oop(source())), \"inv\");\n+    assert(GCForwarding::forwardee(cast_to_oop(source())) == cast_to_oop(destination()), \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -82,1 +83,1 @@\n-    oop new_obj = obj->forwardee();\n+    oop new_obj = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -30,0 +31,5 @@\n+void SerialArguments::initialize_heap_flags_and_sizes() {\n+  GenArguments::initialize_heap_flags_and_sizes();\n+  GCForwarding::initialize_flags(MaxNewSize + MaxOldSize);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  void initialize_heap_flags_and_sizes();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialArguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -233,1 +234,1 @@\n-      obj->forward_to(cast_to_oop(new_addr));\n+      GCForwarding::forward_to(obj, cast_to_oop(new_addr));\n@@ -258,1 +259,1 @@\n-    oop new_obj = obj->forwardee();\n+    oop new_obj = GCForwarding::forwardee(obj);\n@@ -355,1 +356,1 @@\n-      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+      if (!GCForwarding::is_forwarded(cast_to_oop(cur_addr))) {\n@@ -361,1 +362,1 @@\n-        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+        if (!GCForwarding::is_forwarded(cast_to_oop(cur_addr))) {\n@@ -627,2 +628,2 @@\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n+    if (GCForwarding::is_forwarded(obj)) {\n+      oop new_obj = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -203,0 +204,2 @@\n+  GCForwarding::initialize(_reserved);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+\n+HeapWord* GCForwarding::_heap_base = nullptr;\n+int GCForwarding::_num_low_bits = 0;\n+\n+void GCForwarding::initialize_flags(size_t max_heap_size) {\n+#ifdef _LP64\n+  \/\/ Nothing to do here, yet. As soon as we have compact\n+  \/\/ object headers, we will disable the flag when the\n+  \/\/ heap size exceeds the narrow-encodable address space.\n+\n+  \/\/ size_t max_narrow_heap_size = right_n_bits(NumLowBitsNarrow - Shift);\n+  \/\/ if (UseCompactObjectHeaders && max_heap_size > max_narrow_heap_size * HeapWordSize) {\n+  \/\/   FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  \/\/ }\n+#endif\n+}\n+\n+void GCForwarding::initialize(MemRegion heap) {\n+#ifdef _LP64\n+  _heap_base = heap.start();\n+  if (heap.word_size() <= right_n_bits(NumLowBitsNarrow - Shift)) {\n+    _num_low_bits = NumLowBitsNarrow;\n+  } else {\n+    \/\/ assert(!UseCompactObjectHeaders, \"Compact object headers should be turned off for large heaps\");\n+    _num_low_bits = NumLowBitsWide;\n+  }\n+#endif\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/*\n+ * Implements forwarding for the full-GCs of Serial, Parallel, G1 and Shenandoan in\n+ * a way that preserves upper N bits of object mark-words, which contain crucial\n+ * Klass* information when running with compact headers. The encoding is similar to\n+ * compressed-oops encoding: it basically subtracts the forwardee address from the\n+ * heap-base, shifts that difference into the right place, and sets the lowest two\n+ * bits (to indicate 'forwarded' state as usual).\n+ *\/\n+class GCForwarding : public AllStatic {\n+  static const int NumKlassBits        = 32; \/\/ Will be 22 with Tiny Class-Pointers\n+  static const int NumLowBitsNarrow = BitsPerWord - NumKlassBits;\n+  static const int NumLowBitsWide   = BitsPerWord;\n+  static const int Shift = markWord::lock_bits + markWord::lock_shift;\n+\n+  static HeapWord* _heap_base;\n+  static int _num_low_bits;\n+public:\n+  static void initialize_flags(size_t max_heap_size);\n+  static void initialize(MemRegion heap);\n+  static inline void forward_to(oop from, oop to);\n+  static inline oop forwardee(oop from);\n+  static inline bool is_forwarded(oop obj);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef GC_SHARED_GCFORWARDING_INLINE_HPP\n+#define GC_SHARED_GCFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+void GCForwarding::forward_to(oop from, oop to) {\n+#ifdef _LP64\n+  uintptr_t encoded = pointer_delta(cast_from_oop<HeapWord*>(to), _heap_base) << Shift;\n+  assert(encoded <= static_cast<uintptr_t>(right_n_bits(_num_low_bits)), \"encoded forwardee must fit\");\n+  uintptr_t mark = from->mark().value();\n+  mark &= ~right_n_bits(_num_low_bits);\n+  mark |= (encoded | markWord::marked_value);\n+  from->set_mark(markWord(mark));\n+#else\n+  from->forward_to(to);\n+#endif\n+}\n+\n+oop GCForwarding::forwardee(oop from) {\n+#ifdef _LP64\n+  uintptr_t mark = from->mark().value();\n+  HeapWord* decoded = _heap_base + ((mark & right_n_bits(_num_low_bits)) >> Shift);\n+  return cast_to_oop(decoded);\n+#else\n+  return from->forwardee();\n+#endif\n+}\n+\n+bool GCForwarding::is_forwarded(oop obj) {\n+  return obj->mark().is_forwarded();\n+}\n+\n+#endif \/\/ GC_SHARED_GCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.inline.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -45,2 +46,2 @@\n-  if (obj->is_forwarded()) {\n-    elem->set_oop(obj->forwardee());\n+  if (GCForwarding::is_forwarded(obj)) {\n+    elem->set_oop(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -201,0 +202,5 @@\n+void ShenandoahArguments::initialize_heap_flags_and_sizes() {\n+  GCArguments::initialize_heap_flags_and_sizes();\n+  GCForwarding::initialize_flags(MaxHeapSize);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  virtual void initialize_heap_flags_and_sizes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -372,1 +373,1 @@\n-      p->forward_to(cast_to_oop(_compact_point));\n+      GCForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -495,1 +496,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        GCForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -755,2 +756,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = obj->forwardee();\n+      if (GCForwarding::is_forwarded(obj)) {\n+        oop forw = GCForwarding::forwardee(obj);\n@@ -866,1 +867,1 @@\n-    if (p->is_forwarded()) {\n+    if (GCForwarding::is_forwarded(p)) {\n@@ -868,1 +869,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(GCForwarding::forwardee(p));\n@@ -973,1 +974,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (!GCForwarding::is_forwarded(old_obj)) {\n@@ -982,1 +983,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(GCForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -425,0 +426,2 @@\n+  GCForwarding::initialize(_heap_region);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -29,23 +30,2 @@\n-\/\/ Class to create a \"fake\" oop with a mark that will\n-\/\/ return true for calls to must_be_preserved().\n-class FakeOop {\n-  \/\/ Align at least to 8 bytes, otherwise the lowest address bit\n-  \/\/ could be interpreted as 'self-forwarded' when encoded as\n-  \/\/ forwardee in the mark-word. This is required on 32 bit builds,\n-  \/\/ where the oop could be 4-byte-aligned.\n-  alignas(BytesPerLong) oopDesc _oop;\n-\n-public:\n-  FakeOop() : _oop() { _oop.set_mark(originalMark()); }\n-\n-  oop get_oop() { return &_oop; }\n-  markWord mark() { return _oop.mark(); }\n-  void set_mark(markWord m) { _oop.set_mark(m); }\n-  void forward_to(oop obj) {\n-    markWord m = markWord::encode_pointer_as_mark(obj);\n-    _oop.set_mark(m);\n-  }\n-\n-  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n-  static markWord changedMark()  { return markWord(0x4711); }\n-};\n+static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n+static markWord changedMark()  { return markWord(0x4711); }\n@@ -57,4 +37,9 @@\n-  FakeOop o1;\n-  FakeOop o2;\n-  FakeOop o3;\n-  FakeOop o4;\n+\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n+  GCForwarding::initialize(MemRegion(&heap[0], &heap[16]));\n+\n+  oop o1 = cast_to_oop(&heap[0]); o1->set_mark(originalMark());\n+  oop o2 = cast_to_oop(&heap[2]); o2->set_mark(originalMark());\n+  oop o3 = cast_to_oop(&heap[4]); o3->set_mark(originalMark());\n+  oop o4 = cast_to_oop(&heap[6]); o4->set_mark(originalMark());\n@@ -63,4 +48,4 @@\n-  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::originalMark());\n-  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::originalMark());\n-  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::originalMark());\n-  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o1->mark(), originalMark());\n+  ASSERT_MARK_WORD_EQ(o2->mark(), originalMark());\n+  ASSERT_MARK_WORD_EQ(o3->mark(), originalMark());\n+  ASSERT_MARK_WORD_EQ(o4->mark(), originalMark());\n@@ -69,4 +54,4 @@\n-  o1.set_mark(FakeOop::changedMark());\n-  o2.set_mark(FakeOop::changedMark());\n-  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::changedMark());\n-  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::changedMark());\n+  o1->set_mark(changedMark());\n+  o2->set_mark(changedMark());\n+  ASSERT_MARK_WORD_EQ(o1->mark(), changedMark());\n+  ASSERT_MARK_WORD_EQ(o2->mark(), changedMark());\n@@ -75,2 +60,2 @@\n-  pm.push_if_necessary(o1.get_oop(), o1.mark());\n-  pm.push_if_necessary(o2.get_oop(), o2.mark());\n+  pm.push_if_necessary(o1, o1->mark());\n+  pm.push_if_necessary(o2, o2->mark());\n@@ -79,4 +64,4 @@\n-  o1.forward_to(o3.get_oop());\n-  o2.forward_to(o4.get_oop());\n-  ASSERT_EQ(o1.get_oop()->forwardee(), o3.get_oop());\n-  ASSERT_EQ(o2.get_oop()->forwardee(), o4.get_oop());\n+  GCForwarding::forward_to(o1, o3);\n+  GCForwarding::forward_to(o2, o4);\n+  ASSERT_EQ(GCForwarding::forwardee(o1), o3);\n+  ASSERT_EQ(GCForwarding::forwardee(o2), o4);\n@@ -90,2 +75,2 @@\n-  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::changedMark());\n-  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o3->mark(), changedMark());\n+  ASSERT_MARK_WORD_EQ(o4->mark(), changedMark());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":28,"deletions":43,"binary":false,"changes":71,"status":"modified"}]}