{"files":[{"patch":"@@ -49,0 +49,4 @@\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  ShouldNotCallThis();\n+}\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zNUMA_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+static uint* z_numa_id_to_node = nullptr;\n+static uint32_t* z_node_to_numa_id = nullptr;\n+\n@@ -38,0 +41,20 @@\n+  size_t configured_nodes = 0;\n+\n+  if (UseNUMA) {\n+    const size_t max_nodes = os::Linux::numa_num_configured_nodes();\n+    z_numa_id_to_node = NEW_C_HEAP_ARRAY(uint, max_nodes, mtGC);\n+    configured_nodes = os::numa_get_leaf_groups(z_numa_id_to_node, 0);\n+\n+    z_node_to_numa_id = NEW_C_HEAP_ARRAY(uint32_t, max_nodes, mtGC);\n+\n+    \/\/ Fill the array with invalid NUMA ids\n+    for (uint32_t i = 0; i < max_nodes; i++) {\n+      z_node_to_numa_id[i] = (uint32_t)-1;\n+    }\n+\n+    \/\/ Fill the reverse mappings\n+    for (uint32_t i = 0; i < configured_nodes; i++) {\n+      z_node_to_numa_id[z_numa_id_to_node[i]] = i;\n+    }\n+  }\n+\n@@ -40,1 +63,1 @@\n-      ? os::Linux::numa_max_node() + 1\n+      ? configured_nodes\n@@ -57,1 +80,1 @@\n-  return os::Linux::get_node_by_cpu(ZCPU::id());\n+  return z_node_to_numa_id[os::Linux::get_node_by_cpu(ZCPU::id())];\n@@ -66,1 +89,1 @@\n-  uint32_t id = (uint32_t)-1;\n+  int node = -1;\n@@ -68,1 +91,1 @@\n-  if (ZSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n+  if (ZSyscall::get_mempolicy(&node, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n@@ -73,1 +96,8 @@\n-  assert(id < _count, \"Invalid NUMA id\");\n+  DEBUG_ONLY(const int max_nodes = os::Linux::numa_num_configured_nodes();)\n+  assert(node < max_nodes, \"NUMA node is out of bounds node=%d, max=%d\", node, max_nodes);\n+\n+  return z_node_to_numa_id[node];\n+}\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  assert(numa_id < _count, \"NUMA id out of range 0 <= %ud <= %ud\", numa_id, _count);\n@@ -75,1 +105,1 @@\n-  return id;\n+  return (int)z_numa_id_to_node[numa_id];\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zNUMA_linux.cpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-  os::Linux::numa_set_preferred((int)numa_id);\n+  os::Linux::numa_set_preferred(ZNUMA::numa_id_to_node(numa_id));\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  ShouldNotCallThis();\n+}\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zNUMA_windows.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+\n+  static int numa_id_to_node(uint32_t numa_id);\n","filename":"src\/hotspot\/share\/gc\/z\/zNUMA.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  if (!commit(vmem, (uint32_t)-1) || !uncommit(vmem)) {\n+  if (!commit(vmem, 0) || !uncommit(vmem)) {\n@@ -296,1 +296,1 @@\n-    os::numa_make_local((char*)addr, size, (int)numa_id);\n+    os::numa_make_local((char*)addr, size, ZNUMA::numa_id_to_node(numa_id));\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}