{"files":[{"patch":"@@ -118,2 +118,1 @@\n-  ShenandoahMetricsSnapshot metrics;\n-  metrics.snap_before();\n+  ShenandoahMetricsSnapshot metrics(heap->free_set());\n@@ -311,2 +310,0 @@\n-  metrics.snap_after();\n-\n@@ -314,1 +311,1 @@\n-  const bool progress = metrics.is_good_progress(_generation);\n+  const bool progress = metrics.is_good_progress();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,2 +107,3 @@\n-  ShenandoahMetricsSnapshot metrics;\n-  metrics.snap_before();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  ShenandoahMetricsSnapshot metrics(heap->free_set());\n@@ -113,2 +114,0 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-\n@@ -119,3 +118,1 @@\n-  metrics.snap_after();\n-\n-  if (metrics.is_good_progress(heap->global_generation())) {\n+  if (metrics.is_good_progress()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,2 +31,5 @@\n-ShenandoahMetricsSnapshot::ShenandoahMetricsSnapshot() {\n-  _heap = ShenandoahHeap::heap();\n+ShenandoahMetricsSnapshot::ShenandoahMetricsSnapshot(ShenandoahFreeSet* free_set)\n+  : _free_set(free_set)\n+  , _used_before(free_set->used())\n+  , _if_before(free_set->internal_fragmentation())\n+  , _ef_before(free_set->external_fragmentation()) {\n@@ -35,24 +38,1 @@\n-void ShenandoahMetricsSnapshot::snap_before() {\n-  _used_before = _heap->used();\n-  _if_before = _heap->free_set()->internal_fragmentation();\n-  _ef_before = _heap->free_set()->external_fragmentation();\n-}\n-void ShenandoahMetricsSnapshot::snap_after() {\n-  _used_after = _heap->used();\n-  _if_after = _heap->free_set()->internal_fragmentation();\n-  _ef_after = _heap->free_set()->external_fragmentation();\n-}\n-\n-\/\/ For degenerated GC, generation is Young in generational mode, Global in non-generational mode.\n-\/\/ For full GC, generation is always Global.\n-\/\/\n-\/\/ Note that the size of the chosen collection set is proportional to the relevant generation's collection set.\n-\/\/ Note also that the generation size may change following selection of the collection set, as a side effect\n-\/\/ of evacuation.  Evacuation may promote objects, causing old to grow and young to shrink.  Or this may be a\n-\/\/ mixed evacuation.  When old regions are evacuated, this typically allows young to expand.  In all of these\n-\/\/ various scenarios, the purpose of asking is_good_progress() is to determine if there is enough memory available\n-\/\/ within young generation to justify making an attempt to perform a concurrent collection.  For this reason, we'll\n-\/\/ use the current size of the generation (which may not be different than when the collection set was chosen) to\n-\/\/ assess how much free memory we require in order to consider the most recent GC to have had good progress.\n-\n-bool ShenandoahMetricsSnapshot::is_good_progress(ShenandoahGeneration* generation) {\n+bool ShenandoahMetricsSnapshot::is_good_progress() const {\n@@ -60,2 +40,1 @@\n-  ShenandoahFreeSet* free_set = _heap->free_set();\n-  size_t free_actual   = free_set->available();\n+  const size_t free_actual = _free_set->available();\n@@ -64,10 +43,7 @@\n-  \/\/ ShenandoahCriticalFreeThreshold is expressed as a percentage.  We multiple this percentage by 1\/100th\n-  \/\/ of the generation capacity to determine whether the available memory within the generation exceeds the\n-  \/\/ critical threshold.\n-  size_t free_expected = (ShenandoahHeap::heap()->soft_max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n-\n-  bool prog_free = free_actual >= free_expected;\n-  log_info(gc, ergo)(\"%s progress for free space: %zu%s, need %zu%s\",\n-                     prog_free ? \"Good\" : \"Bad\",\n-                     byte_size_in_proper_unit(free_actual),   proper_unit_for_byte_size(free_actual),\n-                     byte_size_in_proper_unit(free_expected), proper_unit_for_byte_size(free_expected));\n+  \/\/ ShenandoahCriticalFreeThreshold is expressed as a percentage.  We multiply this percentage by 1\/100th\n+  \/\/ of the soft max capacity to determine whether the available memory within the mutator partition of the\n+  \/\/ freeset exceeds the critical threshold.\n+  const size_t free_expected = (ShenandoahHeap::heap()->soft_max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n+  const bool prog_free = free_actual >= free_expected;\n+  log_info(gc, ergo)(\"%s progress for free space: \" PROPERFMT \", need \" PROPERFMT,\n+                     prog_free ? \"Good\" : \"Bad\", PROPERFMTARGS(free_actual), PROPERFMTARGS(free_expected));\n@@ -79,7 +55,6 @@\n-  size_t progress_actual   = (_used_before > _used_after) ? _used_before - _used_after : 0;\n-  size_t progress_expected = ShenandoahHeapRegion::region_size_bytes();\n-  bool prog_used = progress_actual >= progress_expected;\n-  log_info(gc, ergo)(\"%s progress for used space: %zu%s, need %zu%s\",\n-                     prog_used ? \"Good\" : \"Bad\",\n-                     byte_size_in_proper_unit(progress_actual),   proper_unit_for_byte_size(progress_actual),\n-                     byte_size_in_proper_unit(progress_expected), proper_unit_for_byte_size(progress_expected));\n+  const size_t used_after = _free_set->used();\n+  const size_t progress_actual   = (_used_before > used_after) ? _used_before - used_after : 0;\n+  const size_t progress_expected = ShenandoahHeapRegion::region_size_bytes();\n+  const bool prog_used = progress_actual >= progress_expected;\n+  log_info(gc, ergo)(\"%s progress for used space: \" PROPERFMT \", need \" PROPERFMT,\n+                     prog_used ? \"Good\" : \"Bad\", PROPERFMTARGS(progress_actual), PROPERFMTARGS(progress_expected));\n@@ -91,3 +66,4 @@\n-  double if_actual = _if_before - _if_after;\n-  double if_expected = 0.01; \/\/ 1% should be enough\n-  bool prog_if = if_actual >= if_expected;\n+  const double if_after = _free_set->internal_fragmentation();\n+  const double if_actual = _if_before - if_after;\n+  const double if_expected = 0.01; \/\/ 1% should be enough\n+  const bool prog_if = if_actual >= if_expected;\n@@ -102,3 +78,4 @@\n-  double ef_actual = _ef_before - _ef_after;\n-  double ef_expected = 0.01; \/\/ 1% should be enough\n-  bool prog_ef = ef_actual >= ef_expected;\n+  const double ef_after = _free_set->external_fragmentation();\n+  const double ef_actual = _ef_before - ef_after;\n+  const double ef_expected = 0.01; \/\/ 1% should be enough\n+  const bool prog_ef = ef_actual >= ef_expected;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":28,"deletions":51,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -32,4 +32,4 @@\n-  ShenandoahHeap* _heap;\n-  size_t _used_before, _used_after;\n-  double _if_before, _if_after;\n-  double _ef_before, _ef_after;\n+  ShenandoahFreeSet* _free_set;\n+  size_t _used_before;\n+  double _if_before;\n+  double _ef_before;\n@@ -38,1 +38,1 @@\n-  ShenandoahMetricsSnapshot();\n+  explicit ShenandoahMetricsSnapshot(ShenandoahFreeSet* free_set);\n@@ -40,4 +40,2 @@\n-  void snap_before();\n-  void snap_after();\n-\n-  bool is_good_progress(ShenandoahGeneration *generation);\n+  \/\/ Decide if the GC made \"good\" progress (i.e., reduced fragmentation, freed up sufficient memory).\n+  bool is_good_progress() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"}]}