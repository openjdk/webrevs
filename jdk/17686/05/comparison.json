{"files":[{"patch":"@@ -1,834 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.shellsupport.doc;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.IdentityHashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.Stack;\n-import java.util.TreeMap;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n-import javax.lang.model.util.Elements;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.JavaFileObject.Kind;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.StandardLocation;\n-import javax.tools.ToolProvider;\n-\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.InheritDocTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.tree.MethodTree;\n-import com.sun.source.tree.VariableTree;\n-import com.sun.source.util.DocSourcePositions;\n-import com.sun.source.util.DocTreePath;\n-import com.sun.source.util.DocTreeScanner;\n-import com.sun.source.util.DocTrees;\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.TreePath;\n-import com.sun.source.util.TreePathScanner;\n-import com.sun.source.util.Trees;\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.Pair;\n-\n-\/**Helper to find javadoc and resolve @inheritDoc.\n- *\/\n-public abstract class JavadocHelper implements AutoCloseable {\n-    private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-\n-    \/**Create the helper.\n-     *\n-     * @param mainTask JavacTask from which the further Elements originate\n-     * @param sourceLocations paths where source files should be searched\n-     * @return a JavadocHelper\n-     *\/\n-    public static JavadocHelper create(JavacTask mainTask, Collection<? extends Path> sourceLocations) {\n-        StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n-        try {\n-            fm.setLocationFromPaths(StandardLocation.SOURCE_PATH, sourceLocations);\n-            return new OnDemandJavadocHelper(mainTask, fm);\n-        } catch (IOException ex) {\n-            try {\n-                fm.close();\n-            } catch (IOException closeEx) {\n-            }\n-            return new JavadocHelper() {\n-                @Override\n-                public String getResolvedDocComment(Element forElement) throws IOException {\n-                    return null;\n-                }\n-                @Override\n-                public Element getSourceElement(Element forElement) throws IOException {\n-                    return forElement;\n-                }\n-                @Override\n-                public void close() throws IOException {}\n-            };\n-        }\n-    }\n-\n-    \/**Returns javadoc for the given element, if it can be found, or null otherwise. The javadoc\n-     * will have @inheritDoc resolved.\n-     *\n-     * @param forElement element for which the javadoc should be searched\n-     * @return javadoc if found, null otherwise\n-     * @throws IOException if something goes wrong in the search\n-     *\/\n-    public abstract String getResolvedDocComment(Element forElement) throws IOException;\n-\n-    \/**Returns an element representing the same given program element, but the returned element will\n-     * be resolved from source, if it can be found. Returns the original element if the source for\n-     * the given element cannot be found.\n-     *\n-     * @param forElement element for which the source element should be searched\n-     * @return source element if found, the original element otherwise\n-     * @throws IOException if something goes wrong in the search\n-     *\/\n-    public abstract Element getSourceElement(Element forElement) throws IOException;\n-\n-    \/**Closes the helper.\n-     *\n-     * @throws IOException if something foes wrong during the close\n-     *\/\n-    @Override\n-    public abstract void close() throws IOException;\n-\n-    private static final class OnDemandJavadocHelper extends JavadocHelper {\n-        private final JavacTask mainTask;\n-        private final JavaFileManager baseFileManager;\n-        private final StandardJavaFileManager fm;\n-        private final Map<String, Pair<JavacTask, TreePath>> signature2Source = new HashMap<>();\n-\n-        private OnDemandJavadocHelper(JavacTask mainTask, StandardJavaFileManager fm) {\n-            this.mainTask = mainTask;\n-            this.baseFileManager = ((JavacTaskImpl) mainTask).getContext().get(JavaFileManager.class);\n-            this.fm = fm;\n-        }\n-\n-        @Override\n-        public String getResolvedDocComment(Element forElement) throws IOException {\n-            Pair<JavacTask, TreePath> sourceElement = getSourceElement(mainTask, forElement);\n-\n-            if (sourceElement == null)\n-                return null;\n-\n-            return getResolvedDocComment(sourceElement.fst, sourceElement.snd);\n-        }\n-\n-        @Override\n-        public Element getSourceElement(Element forElement) throws IOException {\n-            Pair<JavacTask, TreePath> sourceElement = getSourceElement(mainTask, forElement);\n-\n-            if (sourceElement == null)\n-                return forElement;\n-\n-            Element result = Trees.instance(sourceElement.fst).getElement(sourceElement.snd);\n-\n-            if (result == null)\n-                return forElement;\n-\n-            return result;\n-        }\n-\n-        private String getResolvedDocComment(JavacTask task, TreePath el) throws IOException {\n-            DocTrees trees = DocTrees.instance(task);\n-            Element element = trees.getElement(el);\n-            String docComment = trees.getDocComment(el);\n-\n-            if (docComment == null && element.getKind() == ElementKind.METHOD) {\n-                \/\/if a method does not have a javadoc,\n-                \/\/try to use javadoc from the methods overridden by this method:\n-                ExecutableElement executableElement = (ExecutableElement) element;\n-                Iterable<Element> superTypes =\n-                        () -> superTypeForInheritDoc(task, element.getEnclosingElement()).iterator();\n-                for (Element sup : superTypes) {\n-                   for (ExecutableElement supMethod : ElementFilter.methodsIn(sup.getEnclosedElements())) {\n-                       TypeElement clazz = (TypeElement) executableElement.getEnclosingElement();\n-                       if (task.getElements().overrides(executableElement, supMethod, clazz)) {\n-                           Pair<JavacTask, TreePath> source = getSourceElement(task, supMethod);\n-\n-                           if (source != null) {\n-                               String overriddenComment = getResolvedDocComment(source.fst, source.snd);\n-\n-                               if (overriddenComment != null) {\n-                                   return overriddenComment;\n-                               }\n-                           }\n-                       }\n-                   }\n-                }\n-            }\n-\n-            if (docComment == null)\n-                return null;\n-\n-            Pair<DocCommentTree, Integer> parsed = parseDocComment(task, docComment);\n-            DocCommentTree docCommentTree = parsed.fst;\n-            int offset = parsed.snd;\n-            IOException[] exception = new IOException[1];\n-            Comparator<int[]> spanComp =\n-                    (span1, span2) -> span1[0] != span2[0] ? span2[0] - span1[0]\n-                                                           : span2[1] - span1[0];\n-            \/\/spans in the docComment that should be replaced with the given Strings:\n-            Map<int[], List<String>> replace = new TreeMap<>(spanComp);\n-            DocSourcePositions sp = trees.getSourcePositions();\n-\n-            \/\/fill in missing elements and resolve {@inheritDoc}\n-            \/\/if an element is (silently) missing in the javadoc, a synthetic {@inheritDoc}\n-            \/\/is created for it.\n-            new DocTreeScanner<Void, Void>() {\n-                \/* enclosing doctree that may contain {@inheritDoc} (explicit or synthetic)*\/\n-                private Stack<DocTree> interestingParent = new Stack<>();\n-                \/* current top-level DocCommentTree*\/\n-                private DocCommentTree dcTree;\n-                \/* javadoc from a super method from which we may copy elements.*\/\n-                private String inherited;\n-                \/* JavacTask from which inherited originates.*\/\n-                private JavacTask inheritedJavacTask;\n-                \/* TreePath to the super method from which inherited originates.*\/\n-                private TreePath inheritedTreePath;\n-                \/* Synthetic trees that contain {@inheritDoc} and\n-                 * texts which which they should be replaced.*\/\n-                private Map<DocTree, String> syntheticTrees = new IdentityHashMap<>();\n-                \/* Position on which the synthetic trees should be inserted.*\/\n-                private long insertPos = offset;\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void visitDocComment(DocCommentTree node, Void p) {\n-                    dcTree = node;\n-                    interestingParent.push(node);\n-                    try {\n-                        if (node.getFullBody().isEmpty()) {\n-                            \/\/there is no body in the javadoc, add synthetic {@inheritDoc}, which\n-                            \/\/will be automatically filled in visitInheritDoc:\n-                            DocCommentTree dc = parseDocComment(task, \"{@inheritDoc}\").fst;\n-                            syntheticTrees.put(dc, \"*\\n\");\n-                            interestingParent.push(dc);\n-                            boolean prevInSynthetic = inSynthetic;\n-                            try {\n-                                inSynthetic = true;\n-                                scan(dc.getFirstSentence(), p);\n-                                scan(dc.getBody(), p);\n-                            } finally {\n-                                inSynthetic = prevInSynthetic;\n-                                interestingParent.pop();\n-                            }\n-                        } else {\n-                            scan(node.getFirstSentence(), p);\n-                            scan(node.getBody(), p);\n-                        }\n-                        \/\/add missing @param, @throws and @return, augmented with {@inheritDoc}\n-                        \/\/which will be resolved in visitInheritDoc:\n-                        List<DocTree> augmentedBlockTags = new ArrayList<>(node.getBlockTags());\n-                        if (element.getKind() == ElementKind.METHOD) {\n-                            ExecutableElement executableElement = (ExecutableElement) element;\n-                            List<String> parameters =\n-                                    executableElement.getParameters()\n-                                                     .stream()\n-                                                     .map(param -> param.getSimpleName().toString())\n-                                                     .toList();\n-                            List<String> throwsList =\n-                                    executableElement.getThrownTypes()\n-                                                     .stream()\n-                                                     .map(TypeMirror::toString)\n-                                                     .toList();\n-                            Set<String> missingParams = new HashSet<>(parameters);\n-                            Set<String> missingThrows = new HashSet<>(throwsList);\n-                            boolean hasReturn = false;\n-\n-                            for (DocTree dt : augmentedBlockTags) {\n-                                switch (dt.getKind()) {\n-                                    case PARAM:\n-                                        missingParams.remove(((ParamTree) dt).getName().getName().toString());\n-                                        break;\n-                                    case THROWS:\n-                                        missingThrows.remove(getThrownException(task, el, docCommentTree, (ThrowsTree) dt));\n-                                        break;\n-                                    case RETURN:\n-                                        hasReturn = true;\n-                                        break;\n-                                }\n-                            }\n-\n-                            for (String missingParam : missingParams) {\n-                                DocTree syntheticTag = parseBlockTag(task, \"@param \" + missingParam + \" {@inheritDoc}\");\n-                                syntheticTrees.put(syntheticTag, \"@param \" + missingParam + \" *\\n\");\n-                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n-                            }\n-\n-                            for (String missingThrow : missingThrows) {\n-                                DocTree syntheticTag = parseBlockTag(task, \"@throws \" + missingThrow + \" {@inheritDoc}\");\n-                                syntheticTrees.put(syntheticTag, \"@throws \" + missingThrow + \" *\\n\");\n-                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n-                            }\n-\n-                            if (!hasReturn) {\n-                                DocTree syntheticTag = parseBlockTag(task, \"@return {@inheritDoc}\");\n-                                syntheticTrees.put(syntheticTag, \"@return *\\n\");\n-                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n-                            }\n-                        }\n-                        scan(augmentedBlockTags, p);\n-                        return null;\n-                    } finally {\n-                        interestingParent.pop();\n-                    }\n-                }\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void visitParam(ParamTree node, Void p) {\n-                    interestingParent.push(node);\n-                    try {\n-                        return super.visitParam(node, p);\n-                    } finally {\n-                        interestingParent.pop();\n-                    }\n-                }\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void visitThrows(ThrowsTree node, Void p) {\n-                    interestingParent.push(node);\n-                    try {\n-                        return super.visitThrows(node, p);\n-                    } finally {\n-                        interestingParent.pop();\n-                    }\n-                }\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void visitReturn(ReturnTree node, Void p) {\n-                    interestingParent.push(node);\n-                    try {\n-                        return super.visitReturn(node, p);\n-                    } finally {\n-                        interestingParent.pop();\n-                    }\n-                }\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void visitInheritDoc(InheritDocTree node, Void p) {\n-                    \/\/replace (schedule replacement into the replace map)\n-                    \/\/{@inheritDoc} with the corresponding text from an overridden method\n-\n-                    \/\/first, fill in inherited, inheritedJavacTask and inheritedTreePath if not\n-                    \/\/done yet:\n-                    if (inherited == null) {\n-                        try {\n-                            if (element.getKind() == ElementKind.METHOD) {\n-                                ExecutableElement executableElement = (ExecutableElement) element;\n-                                Iterable<ExecutableElement> superMethods =\n-                                        () -> superMethodsForInheritDoc(task, executableElement).\n-                                              iterator();\n-                                for (Element supMethod : superMethods) {\n-                                   Pair<JavacTask, TreePath> source =\n-                                           getSourceElement(task, supMethod);\n-\n-                                   if (source != null) {\n-                                       String overriddenComment =\n-                                               getResolvedDocComment(source.fst,\n-                                                                     source.snd);\n-\n-                                       if (overriddenComment != null) {\n-                                           inheritedJavacTask = source.fst;\n-                                           inheritedTreePath = source.snd;\n-                                           inherited = overriddenComment;\n-                                           break;\n-                                       }\n-                                   }\n-                                }\n-                            }\n-                        } catch (IOException ex) {\n-                            exception[0] = ex;\n-                            return null;\n-                        }\n-                    }\n-                    if (inherited == null) {\n-                        return null;\n-                    }\n-                    Pair<DocCommentTree, Integer> parsed =\n-                            parseDocComment(inheritedJavacTask, inherited);\n-                    DocCommentTree inheritedDocTree = parsed.fst;\n-                    int offset = parsed.snd;\n-                    List<List<? extends DocTree>> inheritedText = new ArrayList<>();\n-                    \/\/find the corresponding piece in the inherited javadoc\n-                    \/\/(interesting parent keeps the enclosing tree):\n-                    DocTree parent = interestingParent.peek();\n-                    switch (parent.getKind()) {\n-                        case DOC_COMMENT:\n-                            inheritedText.add(inheritedDocTree.getFullBody());\n-                            break;\n-                        case PARAM:\n-                            String paramName = ((ParamTree) parent).getName().getName().toString();\n-                            new DocTreeScanner<Void, Void>() {\n-                                @Override @DefinedBy(Api.COMPILER_TREE)\n-                                public Void visitParam(ParamTree node, Void p) {\n-                                    if (node.getName().getName().contentEquals(paramName)) {\n-                                        inheritedText.add(node.getDescription());\n-                                    }\n-                                    return super.visitParam(node, p);\n-                                }\n-                            }.scan(inheritedDocTree, null);\n-                            break;\n-                        case THROWS:\n-                            String thrownName = getThrownException(task, el, docCommentTree, (ThrowsTree) parent);\n-                            new DocTreeScanner<Void, Void>() {\n-                                @Override @DefinedBy(Api.COMPILER_TREE)\n-                                public Void visitThrows(ThrowsTree node, Void p) {\n-                                    if (Objects.equals(getThrownException(inheritedJavacTask, inheritedTreePath, inheritedDocTree, node), thrownName)) {\n-                                        inheritedText.add(node.getDescription());\n-                                    }\n-                                    return super.visitThrows(node, p);\n-                                }\n-                            }.scan(inheritedDocTree, null);\n-                            break;\n-                        case RETURN:\n-                            new DocTreeScanner<Void, Void>() {\n-                                @Override @DefinedBy(Api.COMPILER_TREE)\n-                                public Void visitReturn(ReturnTree node, Void p) {\n-                                    inheritedText.add(node.getDescription());\n-                                    return super.visitReturn(node, p);\n-                                }\n-                            }.scan(inheritedDocTree, null);\n-                            break;\n-                    }\n-                    if (!inheritedText.isEmpty()) {\n-                        long start = Long.MAX_VALUE;\n-                        long end = Long.MIN_VALUE;\n-\n-                        for (DocTree t : inheritedText.get(0)) {\n-                            start = Math.min(start,\n-                                             sp.getStartPosition(null, inheritedDocTree, t) - offset);\n-                            end   = Math.max(end,\n-                                             sp.getEndPosition(null, inheritedDocTree, t) - offset);\n-                        }\n-                        String text = end >= 0 ? inherited.substring((int) start, (int) end) : \"\";\n-\n-                        if (syntheticTrees.containsKey(parent)) {\n-                            \/\/if the {@inheritDoc} is inside a synthetic tree, don't delete anything,\n-                            \/\/but insert the required text\n-                            \/\/(insertPos is the position at which new stuff should be added):\n-                            int[] span = new int[] {(int) insertPos, (int) insertPos};\n-                            replace.computeIfAbsent(span, s -> new ArrayList<>())\n-                                    .add(syntheticTrees.get(parent).replace(\"*\", text));\n-                        } else {\n-                            \/\/replace the {@inheritDoc} with the full text from\n-                            \/\/the overridden method:\n-                            long inheritedStart = sp.getStartPosition(null, dcTree, node);\n-                            long inheritedEnd   = sp.getEndPosition(null, dcTree, node);\n-                            int[] span = new int[] {(int) inheritedStart, (int) inheritedEnd};\n-\n-                            replace.computeIfAbsent(span, s -> new ArrayList<>())\n-                                    .add(text);\n-                        }\n-                    }\n-                    return super.visitInheritDoc(node, p);\n-                }\n-                private boolean inSynthetic;\n-                @Override @DefinedBy(Api.COMPILER_TREE)\n-                public Void scan(DocTree tree, Void p) {\n-                    if (exception[0] != null) {\n-                        return null;\n-                    }\n-                    boolean prevInSynthetic = inSynthetic;\n-                    try {\n-                        inSynthetic |= syntheticTrees.containsKey(tree);\n-                        return super.scan(tree, p);\n-                    } finally {\n-                        if (!inSynthetic && tree != null) {\n-                            \/\/for nonsynthetic trees, preserve the ending position as the future\n-                            \/\/insertPos (as future missing elements should be inserted behind\n-                            \/\/this tree)\n-                            \/\/if there is a newline immediately behind this tree, insert behind\n-                            \/\/the newline:\n-                            long endPos = sp.getEndPosition(null, dcTree, tree);\n-                            if (endPos >= offset) {\n-                                if (endPos - offset + 1 < docComment.length() &&\n-                                    docComment.charAt((int) (endPos - offset + 1)) == '\\n') {\n-                                    endPos++;\n-                                }\n-                                if (endPos - offset < docComment.length()) {\n-                                    insertPos = endPos + 1;\n-                                } else {\n-                                    insertPos = endPos;\n-                                }\n-                            }\n-                        }\n-                        inSynthetic = prevInSynthetic;\n-                    }\n-                }\n-\n-                \/* Insert a synthetic tag (toInsert) into the list of tags at\n-                 * an appropriate position.*\/\n-                private void insertTag(List<DocTree> tags, DocTree toInsert, List<String> parameters, List<String> throwsTypes) {\n-                    Comparator<DocTree> comp = (tag1, tag2) -> {\n-                        if (tag1.getKind() == tag2.getKind()) {\n-                            switch (toInsert.getKind()) {\n-                                case PARAM: {\n-                                    ParamTree p1 = (ParamTree) tag1;\n-                                    ParamTree p2 = (ParamTree) tag2;\n-                                    int i1 = parameters.indexOf(p1.getName().getName().toString());\n-                                    int i2 = parameters.indexOf(p2.getName().getName().toString());\n-\n-                                    return i1 - i2;\n-                                }\n-                                case THROWS: {\n-                                    ThrowsTree t1 = (ThrowsTree) tag1;\n-                                    ThrowsTree t2 = (ThrowsTree) tag2;\n-                                    int i1 = throwsTypes.indexOf(getThrownException(task, el, docCommentTree, t1));\n-                                    int i2 = throwsTypes.indexOf(getThrownException(task, el, docCommentTree, t2));\n-\n-                                    return i1 - i2;\n-                                }\n-                            }\n-                        }\n-\n-                        int i1 = tagOrder.indexOf(tag1.getKind());\n-                        int i2 = tagOrder.indexOf(tag2.getKind());\n-\n-                        return i1 - i2;\n-                    };\n-\n-                    for (int i = 0; i < tags.size(); i++) {\n-                        if (comp.compare(tags.get(i), toInsert) >= 0) {\n-                            tags.add(i, toInsert);\n-                            return ;\n-                        }\n-                    }\n-                    tags.add(toInsert);\n-                }\n-\n-                private final List<DocTree.Kind> tagOrder = Arrays.asList(DocTree.Kind.PARAM, DocTree.Kind.THROWS, DocTree.Kind.RETURN);\n-            }.scan(docCommentTree, null);\n-\n-            if (replace.isEmpty())\n-                return docComment;\n-\n-            \/\/do actually replace {@inheritDoc} with the new text (as scheduled by the visitor\n-            \/\/above):\n-            StringBuilder replacedInheritDoc = new StringBuilder(docComment);\n-\n-            for (Entry<int[], List<String>> e : replace.entrySet()) {\n-                replacedInheritDoc.delete(e.getKey()[0] - offset, e.getKey()[1] - offset);\n-                replacedInheritDoc.insert(e.getKey()[0] - offset,\n-                                          e.getValue().stream().collect(Collectors.joining(\"\")));\n-            }\n-\n-            return replacedInheritDoc.toString();\n-        }\n-\n-        \/* Find methods from which the given method may inherit javadoc, in the proper order.*\/\n-        private Stream<ExecutableElement> superMethodsForInheritDoc(JavacTask task,\n-                                                                     ExecutableElement method) {\n-            TypeElement type = (TypeElement) method.getEnclosingElement();\n-\n-            return this.superTypeForInheritDoc(task, type)\n-                       .flatMap(sup -> ElementFilter.methodsIn(sup.getEnclosedElements()).stream())\n-                       .filter(supMethod -> task.getElements().overrides(method, supMethod, type));\n-        }\n-\n-        \/* Find types from which methods in type may inherit javadoc, in the proper order.*\/\n-        private Stream<Element> superTypeForInheritDoc(JavacTask task, Element type) {\n-            TypeElement clazz = (TypeElement) type;\n-            Stream<Element> result = interfaces(clazz);\n-            result = Stream.concat(result, interfaces(clazz).flatMap(el -> superTypeForInheritDoc(task, el)));\n-\n-            if (clazz.getSuperclass().getKind() == TypeKind.DECLARED) {\n-                Element superClass = ((DeclaredType) clazz.getSuperclass()).asElement();\n-                result = Stream.concat(result, Stream.of(superClass));\n-                result = Stream.concat(result, superTypeForInheritDoc(task, superClass));\n-            }\n-\n-            return result;\n-        }\n-        \/\/where:\n-            private Stream<Element> interfaces(TypeElement clazz) {\n-                return clazz.getInterfaces()\n-                            .stream()\n-                            .filter(tm -> tm.getKind() == TypeKind.DECLARED)\n-                            .map(tm -> ((DeclaredType) tm).asElement());\n-            }\n-\n-         private DocTree parseBlockTag(JavacTask task, String blockTag) {\n-            DocCommentTree dc = parseDocComment(task, blockTag).fst;\n-\n-            return dc.getBlockTags().get(0);\n-        }\n-\n-        private Pair<DocCommentTree, Integer> parseDocComment(JavacTask task, String javadoc) {\n-            DocTrees trees = DocTrees.instance(task);\n-            try {\n-                SimpleJavaFileObject fo =\n-                        new SimpleJavaFileObject(new URI(\"mem:\/\/doc.html\"), Kind.HTML) {\n-                    @Override @DefinedBy(Api.COMPILER)\n-                    public CharSequence getCharContent(boolean ignoreEncodingErrors)\n-                            throws IOException {\n-                        return \"<body>\" + javadoc + \"<\/body>\";\n-                    }\n-                };\n-                DocCommentTree tree = trees.getDocCommentTree(fo);\n-                int offset = (int) trees.getSourcePositions().getStartPosition(null, tree, tree);\n-                offset += \"<body>\".length();\n-                return Pair.of(tree, offset);\n-            } catch (URISyntaxException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n-        }\n-\n-        private String getThrownException(JavacTask task, TreePath rootOn, DocCommentTree comment, ThrowsTree tt) {\n-            DocTrees trees = DocTrees.instance(task);\n-            Element exc = trees.getElement(new DocTreePath(new DocTreePath(rootOn, comment), tt.getExceptionName()));\n-            return exc != null ? exc.toString() : null;\n-        }\n-\n-        private Pair<JavacTask, TreePath> getSourceElement(JavacTask origin, Element el) throws IOException {\n-            String handle = elementSignature(el);\n-            Pair<JavacTask, TreePath> cached = signature2Source.get(handle);\n-\n-            if (cached != null) {\n-                return cached.fst != null ? cached : null;\n-            }\n-\n-            TypeElement type = topLevelType(el);\n-\n-            if (type == null)\n-                return null;\n-\n-            Elements elements = origin.getElements();\n-            String binaryName = elements.getBinaryName(type).toString();\n-            ModuleElement module = elements.getModuleOf(type);\n-            String moduleName = module == null || module.isUnnamed()\n-                    ? null\n-                    : module.getQualifiedName().toString();\n-            Pair<JavacTask, CompilationUnitTree> source = findSource(moduleName, binaryName);\n-\n-            if (source == null)\n-                return null;\n-\n-            fillElementCache(source.fst, source.snd);\n-\n-            cached = signature2Source.get(handle);\n-\n-            if (cached != null) {\n-                return cached;\n-            } else {\n-                signature2Source.put(handle, Pair.of(null, null));\n-                return null;\n-            }\n-        }\n-        \/\/where:\n-            private String elementSignature(Element el) {\n-                switch (el.getKind()) {\n-                    case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE: case RECORD:\n-                        return ((TypeElement) el).getQualifiedName().toString();\n-                    case FIELD:\n-                        return elementSignature(el.getEnclosingElement()) + \".\" + el.getSimpleName() + \":\" + el.asType();\n-                    case ENUM_CONSTANT:\n-                        return elementSignature(el.getEnclosingElement()) + \".\" + el.getSimpleName();\n-                    case EXCEPTION_PARAMETER: case LOCAL_VARIABLE: case PARAMETER: case RESOURCE_VARIABLE:\n-                        return el.getSimpleName() + \":\" + el.asType();\n-                    case CONSTRUCTOR: case METHOD:\n-                        StringBuilder header = new StringBuilder();\n-                        header.append(elementSignature(el.getEnclosingElement()));\n-                        if (el.getKind() == ElementKind.METHOD) {\n-                            header.append(\".\");\n-                            header.append(el.getSimpleName());\n-                        }\n-                        header.append(\"(\");\n-                        String sep = \"\";\n-                        ExecutableElement method = (ExecutableElement) el;\n-                        for (Iterator<? extends VariableElement> i = method.getParameters().iterator(); i.hasNext();) {\n-                            VariableElement p = i.next();\n-                            header.append(sep);\n-                            header.append(p.asType());\n-                            sep = \", \";\n-                        }\n-                        header.append(\")\");\n-                        return header.toString();\n-                    case PACKAGE, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER,\n-                         OTHER, MODULE, RECORD_COMPONENT, BINDING_VARIABLE:\n-                        return el.toString();\n-                    default:\n-                        throw Assert.error(el.getKind().name());\n-                }\n-            }\n-\n-            private TypeElement topLevelType(Element el) {\n-                if (el.getKind() == ElementKind.PACKAGE)\n-                    return null;\n-\n-                while (el != null && el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {\n-                    el = el.getEnclosingElement();\n-                }\n-\n-                return el != null && (el.getKind().isClass() || el.getKind().isInterface()) ? (TypeElement) el : null;\n-            }\n-\n-            private void fillElementCache(JavacTask task, CompilationUnitTree cut) throws IOException {\n-                Trees trees = Trees.instance(task);\n-\n-                new TreePathScanner<Void, Void>() {\n-                    @Override @DefinedBy(Api.COMPILER_TREE)\n-                    public Void visitMethod(MethodTree node, Void p) {\n-                        handleDeclaration();\n-                        return null;\n-                    }\n-\n-                    @Override @DefinedBy(Api.COMPILER_TREE)\n-                    public Void visitClass(ClassTree node, Void p) {\n-                        handleDeclaration();\n-                        return super.visitClass(node, p);\n-                    }\n-\n-                    @Override @DefinedBy(Api.COMPILER_TREE)\n-                    public Void visitVariable(VariableTree node, Void p) {\n-                        handleDeclaration();\n-                        return super.visitVariable(node, p);\n-                    }\n-\n-                    private void handleDeclaration() {\n-                        Element currentElement = trees.getElement(getCurrentPath());\n-\n-                        if (currentElement != null) {\n-                            signature2Source.put(elementSignature(currentElement), Pair.of(task, getCurrentPath()));\n-                        }\n-                    }\n-                }.scan(cut, null);\n-            }\n-\n-        private Pair<JavacTask, CompilationUnitTree> findSource(String moduleName,\n-                                                                String binaryName) throws IOException {\n-            JavaFileObject jfo = fm.getJavaFileForInput(StandardLocation.SOURCE_PATH,\n-                                                        binaryName,\n-                                                        JavaFileObject.Kind.SOURCE);\n-\n-            if (jfo == null)\n-                return null;\n-\n-            List<JavaFileObject> jfos = Arrays.asList(jfo);\n-            JavaFileManager patchFM = moduleName != null\n-                    ? new PatchModuleFileManager(baseFileManager, jfo, moduleName)\n-                    : baseFileManager;\n-            JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, patchFM, d -> {}, null, null, jfos);\n-            Iterable<? extends CompilationUnitTree> cuts = task.parse();\n-\n-            task.enter();\n-\n-            return Pair.of(task, cuts.iterator().next());\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-            fm.close();\n-        }\n-\n-        private static final class PatchModuleFileManager\n-                extends ForwardingJavaFileManager<JavaFileManager> {\n-\n-            private final JavaFileObject file;\n-            private final String moduleName;\n-\n-            public PatchModuleFileManager(JavaFileManager fileManager,\n-                                          JavaFileObject file,\n-                                          String moduleName) {\n-                super(fileManager);\n-                this.file = file;\n-                this.moduleName = moduleName;\n-            }\n-\n-            @Override @DefinedBy(Api.COMPILER)\n-            public Location getLocationForModule(Location location,\n-                                                 JavaFileObject fo) throws IOException {\n-                return fo == file\n-                        ? PATCH_LOCATION\n-                        : super.getLocationForModule(location, fo);\n-            }\n-\n-            @Override @DefinedBy(Api.COMPILER)\n-            public String inferModuleName(Location location) throws IOException {\n-                return location == PATCH_LOCATION\n-                        ? moduleName\n-                        : super.inferModuleName(location);\n-            }\n-\n-            @Override @DefinedBy(Api.COMPILER)\n-            public boolean hasLocation(Location location) {\n-                return location == StandardLocation.PATCH_MODULE_PATH ||\n-                       super.hasLocation(location);\n-            }\n-\n-            private static final Location PATCH_LOCATION = new Location() {\n-                @Override @DefinedBy(Api.COMPILER)\n-                public String getName() {\n-                    return \"PATCH_LOCATION\";\n-                }\n-\n-                @Override @DefinedBy(Api.COMPILER)\n-                public boolean isOutputLocation() {\n-                    return false;\n-                }\n-\n-                @Override @DefinedBy(Api.COMPILER)\n-                public boolean isModuleOrientedLocation() {\n-                    return false;\n-                }\n-\n-            };\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","additions":0,"deletions":834,"binary":false,"changes":834,"status":"deleted"},{"patch":"@@ -271,2 +271,0 @@\n-    exports jdk.internal.shellsupport.doc to\n-        jdk.jshell;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","status":"renamed"},{"patch":"@@ -0,0 +1,1058 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.shellsupport.doc;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Elements.DocCommentKind;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.JavaFileObject.Kind;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.InheritDocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.doctree.ParamTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.ReturnTree;\n+import com.sun.source.doctree.ThrowsTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.DocSourcePositions;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.DefinedBy;\n+import com.sun.tools.javac.util.DefinedBy.Api;\n+import com.sun.tools.javac.util.Pair;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TablesExtension;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.IncludeSourceSpans;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+\n+\/**Helper to find javadoc and resolve @inheritDoc.\n+ *\/\n+public abstract class JavadocHelper implements AutoCloseable {\n+    private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+\n+    \/**Create the helper.\n+     *\n+     * @param mainTask JavacTask from which the further Elements originate\n+     * @param sourceLocations paths where source files should be searched\n+     * @return a JavadocHelper\n+     *\/\n+    public static JavadocHelper create(JavacTask mainTask, Collection<? extends Path> sourceLocations) {\n+        StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+        try {\n+            fm.setLocationFromPaths(StandardLocation.SOURCE_PATH, sourceLocations);\n+            return new OnDemandJavadocHelper(mainTask, fm);\n+        } catch (IOException ex) {\n+            try {\n+                fm.close();\n+            } catch (IOException closeEx) {\n+            }\n+            return new JavadocHelper() {\n+                @Override\n+                public String getResolvedDocComment(Element forElement) throws IOException {\n+                    return null;\n+                }\n+                @Override\n+                public Element getSourceElement(Element forElement) throws IOException {\n+                    return forElement;\n+                }\n+                @Override\n+                public void close() throws IOException {}\n+            };\n+        }\n+    }\n+\n+    \/**Returns javadoc for the given element, if it can be found, or null otherwise. The javadoc\n+     * will have @inheritDoc resolved.\n+     *\n+     * @param forElement element for which the javadoc should be searched\n+     * @return javadoc if found, null otherwise\n+     * @throws IOException if something goes wrong in the search\n+     *\/\n+    public abstract String getResolvedDocComment(Element forElement) throws IOException;\n+\n+    \/**Returns an element representing the same given program element, but the returned element will\n+     * be resolved from source, if it can be found. Returns the original element if the source for\n+     * the given element cannot be found.\n+     *\n+     * @param forElement element for which the source element should be searched\n+     * @return source element if found, the original element otherwise\n+     * @throws IOException if something goes wrong in the search\n+     *\/\n+    public abstract Element getSourceElement(Element forElement) throws IOException;\n+\n+    \/**Closes the helper.\n+     *\n+     * @throws IOException if something foes wrong during the close\n+     *\/\n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    private static final class OnDemandJavadocHelper extends JavadocHelper {\n+        private final JavacTask mainTask;\n+        private final JavaFileManager baseFileManager;\n+        private final StandardJavaFileManager fm;\n+        private final Map<String, Pair<JavacTask, TreePath>> signature2Source = new HashMap<>();\n+\n+        private OnDemandJavadocHelper(JavacTask mainTask, StandardJavaFileManager fm) {\n+            this.mainTask = mainTask;\n+            this.baseFileManager = ((JavacTaskImpl) mainTask).getContext().get(JavaFileManager.class);\n+            this.fm = fm;\n+        }\n+\n+        @Override\n+        public String getResolvedDocComment(Element forElement) throws IOException {\n+            Pair<JavacTask, TreePath> sourceElement = getSourceElement(mainTask, forElement);\n+\n+            if (sourceElement == null)\n+                return null;\n+\n+            return getResolvedDocComment(sourceElement.fst, sourceElement.snd);\n+        }\n+\n+        @Override\n+        public Element getSourceElement(Element forElement) throws IOException {\n+            Pair<JavacTask, TreePath> sourceElement = getSourceElement(mainTask, forElement);\n+\n+            if (sourceElement == null)\n+                return forElement;\n+\n+            Element result = Trees.instance(sourceElement.fst).getElement(sourceElement.snd);\n+\n+            if (result == null)\n+                return forElement;\n+\n+            return result;\n+        }\n+\n+        private String getResolvedDocComment(JavacTask task, TreePath el) throws IOException {\n+            DocTrees trees = DocTrees.instance(task);\n+            Element element = trees.getElement(el);\n+            String docComment = trees.getDocComment(el);\n+\n+            if (docComment == null && element.getKind() == ElementKind.METHOD) {\n+                \/\/if a method does not have a javadoc,\n+                \/\/try to use javadoc from the methods overridden by this method:\n+                ExecutableElement executableElement = (ExecutableElement) element;\n+                Iterable<Element> superTypes =\n+                        () -> superTypeForInheritDoc(task, element.getEnclosingElement()).iterator();\n+                for (Element sup : superTypes) {\n+                   for (ExecutableElement supMethod : ElementFilter.methodsIn(sup.getEnclosedElements())) {\n+                       TypeElement clazz = (TypeElement) executableElement.getEnclosingElement();\n+                       if (task.getElements().overrides(executableElement, supMethod, clazz)) {\n+                           Pair<JavacTask, TreePath> source = getSourceElement(task, supMethod);\n+\n+                           if (source != null) {\n+                               String overriddenComment = getResolvedDocComment(source.fst, source.snd);\n+\n+                               if (overriddenComment != null) {\n+                                   return overriddenComment;\n+                               }\n+                           }\n+                       }\n+                   }\n+                }\n+            }\n+\n+            if (docComment == null)\n+                return null;\n+\n+            DocCommentKind docCommentKind = trees.getDocCommentKind(el);\n+            Pair<DocCommentTree, Integer> parsed = parseDocComment(task, docComment, docCommentKind);\n+            DocCommentTree docCommentTree = parsed.fst;\n+            int offset = parsed.snd;\n+            IOException[] exception = new IOException[1];\n+            Comparator<int[]> spanComp =\n+                    (span1, span2) -> span1[0] != span2[0] ? span2[0] - span1[0]\n+                                                           : span2[1] - span1[1];\n+            \/\/spans in the docComment that should be replaced with the given Strings:\n+            Map<int[], List<String>> replace = new TreeMap<>(spanComp);\n+            SyntheticAwareTreeDocSourcePositions sp =\n+                    new SyntheticAwareTreeDocSourcePositions(trees.getSourcePositions());\n+\n+            \/\/fill in missing elements and resolve {@inheritDoc}\n+            \/\/if an element is (silently) missing in the javadoc, a synthetic {@inheritDoc}\n+            \/\/is created for it.\n+            new DocTreeScanner<Void, Void>() {\n+                \/* enclosing doctree that may contain {@inheritDoc} (explicit or synthetic)*\/\n+                private Stack<DocTree> interestingParent = new Stack<>();\n+                \/* current top-level DocCommentTree*\/\n+                private DocCommentTree dcTree;\n+                \/* javadoc from a super method from which we may copy elements.*\/\n+                private String inherited;\n+                \/* JavacTask from which inherited originates.*\/\n+                private JavacTask inheritedJavacTask;\n+                \/* TreePath to the super method from which inherited originates.*\/\n+                private TreePath inheritedTreePath;\n+                \/* Synthetic trees that contain {@inheritDoc} and\n+                 * texts which which they should be replaced.*\/\n+                private Map<DocTree, String> syntheticTrees = new IdentityHashMap<>();\n+                \/* Position on which the synthetic trees should be inserted.*\/\n+                private long insertPos = offset;\n+                @Override\n+                public Void scan(Iterable<? extends DocTree> nodes, Void p) {\n+                    if (nodes != null && containsMarkdown(nodes)) {\n+                        JoinedMarkdown joinedMarkdowns = joinMarkdown(sp, dcTree, nodes);\n+                        String source = joinedMarkdowns.source();\n+                        Parser parser = Parser.builder()\n+                                .extensions(List.of(TablesExtension.create()))\n+                                .includeSourceSpans(IncludeSourceSpans.BLOCKS_AND_INLINES)\n+                                .build();\n+                        Node document = parser.parse(source);\n+                        String htmlWithPlaceHolders = stripParagraphs(HtmlRenderer.builder()\n+                                                                                  .build()\n+                                                                                  .render(document));\n+\n+                        for (String part : htmlWithPlaceHolders.split(PLACEHOLDER_PATTERN, -1)) {\n+                            int[] replaceSpan = joinedMarkdowns.replaceSpans.remove(0);\n+\n+                            replace.computeIfAbsent(replaceSpan, _ -> new ArrayList<>())\n+                                   .add(part);\n+                        }\n+                    }\n+                    return super.scan(nodes, p);\n+                }\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void visitDocComment(DocCommentTree node, Void p) {\n+                    dcTree = node;\n+                    interestingParent.push(node);\n+                    try {\n+                        if (node.getFullBody().isEmpty()) {\n+                            \/\/there is no body in the javadoc, add synthetic {@inheritDoc}, which\n+                            \/\/will be automatically filled in visitInheritDoc:\n+                            DocCommentTree dc = parseDocComment(task, \"{@inheritDoc}\", DocCommentKind.TRADITIONAL).fst;\n+                            syntheticTrees.put(dc, \"*\\n\");\n+                            interestingParent.push(dc);\n+                            boolean prevInSynthetic = inSynthetic;\n+                            try {\n+                                inSynthetic = true;\n+                                scan(dc.getFullBody(), p);\n+                            } finally {\n+                                inSynthetic = prevInSynthetic;\n+                                interestingParent.pop();\n+                            }\n+                        } else {\n+                            scan(node.getFullBody(), p);\n+                        }\n+                        \/\/add missing @param, @throws and @return, augmented with {@inheritDoc}\n+                        \/\/which will be resolved in visitInheritDoc:\n+                        List<DocTree> augmentedBlockTags = new ArrayList<>(node.getBlockTags());\n+                        if (element.getKind() == ElementKind.METHOD) {\n+                            ExecutableElement executableElement = (ExecutableElement) element;\n+                            List<String> parameters =\n+                                    executableElement.getParameters()\n+                                                     .stream()\n+                                                     .map(param -> param.getSimpleName().toString())\n+                                                     .toList();\n+                            List<String> throwsList =\n+                                    executableElement.getThrownTypes()\n+                                                     .stream()\n+                                                     .map(TypeMirror::toString)\n+                                                     .toList();\n+                            Set<String> missingParams = new HashSet<>(parameters);\n+                            Set<String> missingThrows = new HashSet<>(throwsList);\n+                            boolean hasReturn = false;\n+\n+                            for (DocTree dt : augmentedBlockTags) {\n+                                switch (dt.getKind()) {\n+                                    case PARAM:\n+                                        missingParams.remove(((ParamTree) dt).getName().getName().toString());\n+                                        break;\n+                                    case THROWS:\n+                                        missingThrows.remove(getThrownException(task, el, docCommentTree, (ThrowsTree) dt));\n+                                        break;\n+                                    case RETURN:\n+                                        hasReturn = true;\n+                                        break;\n+                                }\n+                            }\n+\n+                            for (String missingParam : missingParams) {\n+                                DocTree syntheticTag = parseBlockTag(task, \"@param \" + missingParam + \" {@inheritDoc}\");\n+                                syntheticTrees.put(syntheticTag, \"@param \" + missingParam + \" *\\n\");\n+                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n+                            }\n+\n+                            for (String missingThrow : missingThrows) {\n+                                DocTree syntheticTag = parseBlockTag(task, \"@throws \" + missingThrow + \" {@inheritDoc}\");\n+                                syntheticTrees.put(syntheticTag, \"@throws \" + missingThrow + \" *\\n\");\n+                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n+                            }\n+\n+                            if (!hasReturn) {\n+                                DocTree syntheticTag = parseBlockTag(task, \"@return {@inheritDoc}\");\n+                                syntheticTrees.put(syntheticTag, \"@return *\\n\");\n+                                insertTag(augmentedBlockTags, syntheticTag, parameters, throwsList);\n+                            }\n+                        }\n+                        scan(augmentedBlockTags, p);\n+                        return null;\n+                    } finally {\n+                        interestingParent.pop();\n+                    }\n+                }\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void visitParam(ParamTree node, Void p) {\n+                    interestingParent.push(node);\n+                    try {\n+                        return super.visitParam(node, p);\n+                    } finally {\n+                        interestingParent.pop();\n+                    }\n+                }\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void visitThrows(ThrowsTree node, Void p) {\n+                    interestingParent.push(node);\n+                    try {\n+                        return super.visitThrows(node, p);\n+                    } finally {\n+                        interestingParent.pop();\n+                    }\n+                }\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void visitReturn(ReturnTree node, Void p) {\n+                    interestingParent.push(node);\n+                    try {\n+                        return super.visitReturn(node, p);\n+                    } finally {\n+                        interestingParent.pop();\n+                    }\n+                }\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void visitInheritDoc(InheritDocTree node, Void p) {\n+                    \/\/replace (schedule replacement into the replace map)\n+                    \/\/{@inheritDoc} with the corresponding text from an overridden method\n+\n+                    \/\/first, fill in inherited, inheritedJavacTask and inheritedTreePath if not\n+                    \/\/done yet:\n+                    if (inherited == null) {\n+                        try {\n+                            if (element.getKind() == ElementKind.METHOD) {\n+                                ExecutableElement executableElement = (ExecutableElement) element;\n+                                Iterable<ExecutableElement> superMethods =\n+                                        () -> superMethodsForInheritDoc(task, executableElement).\n+                                              iterator();\n+                                for (Element supMethod : superMethods) {\n+                                   Pair<JavacTask, TreePath> source =\n+                                           getSourceElement(task, supMethod);\n+\n+                                   if (source != null) {\n+                                       String overriddenComment =\n+                                               getResolvedDocComment(source.fst,\n+                                                                     source.snd);\n+\n+                                       if (overriddenComment != null) {\n+                                           inheritedJavacTask = source.fst;\n+                                           inheritedTreePath = source.snd;\n+                                           inherited = overriddenComment;\n+                                           break;\n+                                       }\n+                                   }\n+                                }\n+                            }\n+                        } catch (IOException ex) {\n+                            exception[0] = ex;\n+                            return null;\n+                        }\n+                    }\n+                    if (inherited == null) {\n+                        return null;\n+                    }\n+                    Pair<DocCommentTree, Integer> parsed =\n+                            parseDocComment(inheritedJavacTask, inherited, DocCommentKind.TRADITIONAL);\n+                    DocCommentTree inheritedDocTree = parsed.fst;\n+                    int offset = parsed.snd;\n+                    List<List<? extends DocTree>> inheritedText = new ArrayList<>();\n+                    \/\/find the corresponding piece in the inherited javadoc\n+                    \/\/(interesting parent keeps the enclosing tree):\n+                    DocTree parent = interestingParent.peek();\n+                    switch (parent.getKind()) {\n+                        case DOC_COMMENT:\n+                            inheritedText.add(inheritedDocTree.getFullBody());\n+                            break;\n+                        case PARAM:\n+                            String paramName = ((ParamTree) parent).getName().getName().toString();\n+                            new DocTreeScanner<Void, Void>() {\n+                                @Override @DefinedBy(Api.COMPILER_TREE)\n+                                public Void visitParam(ParamTree node, Void p) {\n+                                    if (node.getName().getName().contentEquals(paramName)) {\n+                                        inheritedText.add(node.getDescription());\n+                                    }\n+                                    return super.visitParam(node, p);\n+                                }\n+                            }.scan(inheritedDocTree, null);\n+                            break;\n+                        case THROWS:\n+                            String thrownName = getThrownException(task, el, docCommentTree, (ThrowsTree) parent);\n+                            new DocTreeScanner<Void, Void>() {\n+                                @Override @DefinedBy(Api.COMPILER_TREE)\n+                                public Void visitThrows(ThrowsTree node, Void p) {\n+                                    if (Objects.equals(getThrownException(inheritedJavacTask, inheritedTreePath, inheritedDocTree, node), thrownName)) {\n+                                        inheritedText.add(node.getDescription());\n+                                    }\n+                                    return super.visitThrows(node, p);\n+                                }\n+                            }.scan(inheritedDocTree, null);\n+                            break;\n+                        case RETURN:\n+                            new DocTreeScanner<Void, Void>() {\n+                                @Override @DefinedBy(Api.COMPILER_TREE)\n+                                public Void visitReturn(ReturnTree node, Void p) {\n+                                    inheritedText.add(node.getDescription());\n+                                    return super.visitReturn(node, p);\n+                                }\n+                            }.scan(inheritedDocTree, null);\n+                            break;\n+                    }\n+                    if (!inheritedText.isEmpty()) {\n+                        long start = Long.MAX_VALUE;\n+                        long end = Long.MIN_VALUE;\n+\n+                        for (DocTree t : inheritedText.get(0)) {\n+                            start = Math.min(start,\n+                                             sp.getStartPosition(null, inheritedDocTree, t) - offset);\n+                            end   = Math.max(end,\n+                                             sp.getEndPosition(null, inheritedDocTree, t) - offset);\n+                        }\n+                        String text = end >= 0 ? inherited.substring((int) start, (int) end) : \"\";\n+\n+                        if (syntheticTrees.containsKey(parent)) {\n+                            \/\/if the {@inheritDoc} is inside a synthetic tree, don't delete anything,\n+                            \/\/but insert the required text\n+                            \/\/(insertPos is the position at which new stuff should be added):\n+                            int[] span = new int[] {(int) insertPos, (int) insertPos};\n+                            replace.computeIfAbsent(span, s -> new ArrayList<>())\n+                                    .add(syntheticTrees.get(parent).replace(\"*\", text));\n+                        } else {\n+                            \/\/replace the {@inheritDoc} with the full text from\n+                            \/\/the overridden method:\n+                            long inheritedStart = sp.getStartPosition(null, dcTree, node);\n+                            long inheritedEnd   = sp.getEndPosition(null, dcTree, node);\n+                            int[] span = new int[] {(int) inheritedStart, (int) inheritedEnd};\n+\n+                            replace.computeIfAbsent(span, s -> new ArrayList<>())\n+                                    .add(text);\n+                        }\n+                    }\n+                    return super.visitInheritDoc(node, p);\n+                }\n+                @Override\n+                public Void visitLink(LinkTree node, Void p) {\n+                    if (sp.isRewrittenTree(null, dcTree, node)) {\n+                        \/\/this link is a synthetic rewritten link, replace\n+                        \/\/the original span with the new link:\n+                        int start = (int) sp.getStartPosition(null, dcTree, node);\n+                        int end   = (int) sp.getEndPosition(null, dcTree, node);\n+\n+                        replace.computeIfAbsent(new int[] {start, end}, _ -> new ArrayList<>())\n+                               .add(node.toString());\n+\n+                        return null;\n+                    }\n+                    return super.visitLink(node, p);\n+                }\n+                private boolean inSynthetic;\n+                @Override @DefinedBy(Api.COMPILER_TREE)\n+                public Void scan(DocTree tree, Void p) {\n+                    if (exception[0] != null) {\n+                        return null;\n+                    }\n+                    boolean prevInSynthetic = inSynthetic;\n+                    try {\n+                        inSynthetic |= syntheticTrees.containsKey(tree);\n+                        return super.scan(tree, p);\n+                    } finally {\n+                        if (!inSynthetic && tree != null) {\n+                            \/\/for nonsynthetic trees, preserve the ending position as the future\n+                            \/\/insertPos (as future missing elements should be inserted behind\n+                            \/\/this tree)\n+                            \/\/if there is a newline immediately behind this tree, insert behind\n+                            \/\/the newline:\n+                            long endPos = sp.getEndPosition(null, dcTree, tree);\n+                            if (endPos >= offset) {\n+                                if (endPos - offset + 1 < docComment.length() &&\n+                                    docComment.charAt((int) (endPos - offset + 1)) == '\\n') {\n+                                    endPos++;\n+                                }\n+                                if (endPos - offset < docComment.length()) {\n+                                    insertPos = endPos + 1;\n+                                } else {\n+                                    insertPos = endPos;\n+                                }\n+                            }\n+                        }\n+                        inSynthetic = prevInSynthetic;\n+                    }\n+                }\n+\n+                \/* Insert a synthetic tag (toInsert) into the list of tags at\n+                 * an appropriate position.*\/\n+                private void insertTag(List<DocTree> tags, DocTree toInsert, List<String> parameters, List<String> throwsTypes) {\n+                    Comparator<DocTree> comp = (tag1, tag2) -> {\n+                        if (tag1.getKind() == tag2.getKind()) {\n+                            switch (toInsert.getKind()) {\n+                                case PARAM: {\n+                                    ParamTree p1 = (ParamTree) tag1;\n+                                    ParamTree p2 = (ParamTree) tag2;\n+                                    int i1 = parameters.indexOf(p1.getName().getName().toString());\n+                                    int i2 = parameters.indexOf(p2.getName().getName().toString());\n+\n+                                    return i1 - i2;\n+                                }\n+                                case THROWS: {\n+                                    ThrowsTree t1 = (ThrowsTree) tag1;\n+                                    ThrowsTree t2 = (ThrowsTree) tag2;\n+                                    int i1 = throwsTypes.indexOf(getThrownException(task, el, docCommentTree, t1));\n+                                    int i2 = throwsTypes.indexOf(getThrownException(task, el, docCommentTree, t2));\n+\n+                                    return i1 - i2;\n+                                }\n+                            }\n+                        }\n+\n+                        int i1 = tagOrder.indexOf(tag1.getKind());\n+                        int i2 = tagOrder.indexOf(tag2.getKind());\n+\n+                        return i1 - i2;\n+                    };\n+\n+                    for (int i = 0; i < tags.size(); i++) {\n+                        if (comp.compare(tags.get(i), toInsert) >= 0) {\n+                            tags.add(i, toInsert);\n+                            return ;\n+                        }\n+                    }\n+                    tags.add(toInsert);\n+                }\n+\n+                private static final List<DocTree.Kind> tagOrder =\n+                        Arrays.asList(DocTree.Kind.PARAM, DocTree.Kind.THROWS,\n+                                      DocTree.Kind.RETURN, DocTree.Kind.SEE,\n+                                      DocTree.Kind.SINCE);\n+            }.scan(docCommentTree, null);\n+\n+            if (replace.isEmpty())\n+                return docComment;\n+\n+            \/\/do actually replace {@inheritDoc} with the new text (as scheduled by the visitor\n+            \/\/above):\n+            StringBuilder replacedInheritDoc = new StringBuilder(docComment);\n+\n+            for (Entry<int[], List<String>> e : replace.entrySet()) {\n+                replacedInheritDoc.delete(e.getKey()[0] - offset, e.getKey()[1] - offset);\n+                replacedInheritDoc.insert(e.getKey()[0] - offset,\n+                                          e.getValue().stream().collect(Collectors.joining(\"\")));\n+            }\n+\n+            return replacedInheritDoc.toString();\n+        }\n+\n+        \/* Find methods from which the given method may inherit javadoc, in the proper order.*\/\n+        private Stream<ExecutableElement> superMethodsForInheritDoc(JavacTask task,\n+                                                                     ExecutableElement method) {\n+            TypeElement type = (TypeElement) method.getEnclosingElement();\n+\n+            return this.superTypeForInheritDoc(task, type)\n+                       .flatMap(sup -> ElementFilter.methodsIn(sup.getEnclosedElements()).stream())\n+                       .filter(supMethod -> task.getElements().overrides(method, supMethod, type));\n+        }\n+\n+        \/* Find types from which methods in type may inherit javadoc, in the proper order.*\/\n+        private Stream<Element> superTypeForInheritDoc(JavacTask task, Element type) {\n+            TypeElement clazz = (TypeElement) type;\n+            Stream<Element> result = interfaces(clazz);\n+            result = Stream.concat(result, interfaces(clazz).flatMap(el -> superTypeForInheritDoc(task, el)));\n+\n+            if (clazz.getSuperclass().getKind() == TypeKind.DECLARED) {\n+                Element superClass = ((DeclaredType) clazz.getSuperclass()).asElement();\n+                result = Stream.concat(result, Stream.of(superClass));\n+                result = Stream.concat(result, superTypeForInheritDoc(task, superClass));\n+            }\n+\n+            return result;\n+        }\n+        \/\/where:\n+            private Stream<Element> interfaces(TypeElement clazz) {\n+                return clazz.getInterfaces()\n+                            .stream()\n+                            .filter(tm -> tm.getKind() == TypeKind.DECLARED)\n+                            .map(tm -> ((DeclaredType) tm).asElement());\n+            }\n+\n+         private DocTree parseBlockTag(JavacTask task, String blockTag) {\n+            DocCommentTree dc = parseDocComment(task, blockTag, DocCommentKind.TRADITIONAL).fst;\n+\n+            return dc.getBlockTags().get(0);\n+        }\n+\n+        private Pair<DocCommentTree, Integer> parseDocComment(JavacTask task, String javadoc, DocCommentKind docCommentKind) {\n+            DocTrees trees = DocTrees.instance(task);\n+            try {\n+                URI uri;\n+                Kind kind;\n+                String content;\n+                int offset;\n+                if (docCommentKind == DocCommentKind.TRADITIONAL) {\n+                    uri = new URI(\"mem:\/\/\/doc.html\");\n+                    kind = Kind.HTML;\n+                    content = \"<body>\" + javadoc + \"<\/body>\";\n+                    offset = \"<body>\".length();\n+                } else {\n+                    uri = new URI(\"mem:\/\/\/doc.md\");\n+                    kind = Kind.OTHER;\n+                    content = javadoc;\n+                    offset = 0;\n+                }\n+                SimpleJavaFileObject fo = new SimpleJavaFileObject(uri, kind) {\n+                        @Override @DefinedBy(Api.COMPILER)\n+                        public CharSequence getCharContent(boolean ignoreEncodingErrors)\n+                                throws IOException {\n+                            return content;\n+                        }\n+                    };\n+                DocCommentTree tree = trees.getDocCommentTree(fo);\n+                offset += (int) trees.getSourcePositions().getStartPosition(null, tree, tree);\n+                return Pair.of(tree, offset);\n+            } catch (URISyntaxException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        private String getThrownException(JavacTask task, TreePath rootOn, DocCommentTree comment, ThrowsTree tt) {\n+            DocTrees trees = DocTrees.instance(task);\n+            Element exc = trees.getElement(new DocTreePath(new DocTreePath(rootOn, comment), tt.getExceptionName()));\n+            return exc != null ? exc.toString() : null;\n+        }\n+\n+        private Pair<JavacTask, TreePath> getSourceElement(JavacTask origin, Element el) throws IOException {\n+            String handle = elementSignature(el);\n+            Pair<JavacTask, TreePath> cached = signature2Source.get(handle);\n+\n+            if (cached != null) {\n+                return cached.fst != null ? cached : null;\n+            }\n+\n+            TypeElement type = topLevelType(el);\n+\n+            if (type == null)\n+                return null;\n+\n+            Elements elements = origin.getElements();\n+            String binaryName = elements.getBinaryName(type).toString();\n+            ModuleElement module = elements.getModuleOf(type);\n+            String moduleName = module == null || module.isUnnamed()\n+                    ? null\n+                    : module.getQualifiedName().toString();\n+            Pair<JavacTask, CompilationUnitTree> source = findSource(moduleName, binaryName);\n+\n+            if (source == null)\n+                return null;\n+\n+            fillElementCache(source.fst, source.snd);\n+\n+            cached = signature2Source.get(handle);\n+\n+            if (cached != null) {\n+                return cached;\n+            } else {\n+                signature2Source.put(handle, Pair.of(null, null));\n+                return null;\n+            }\n+        }\n+        \/\/where:\n+            private String elementSignature(Element el) {\n+                switch (el.getKind()) {\n+                    case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE: case RECORD:\n+                        return ((TypeElement) el).getQualifiedName().toString();\n+                    case FIELD:\n+                        return elementSignature(el.getEnclosingElement()) + \".\" + el.getSimpleName() + \":\" + el.asType();\n+                    case ENUM_CONSTANT:\n+                        return elementSignature(el.getEnclosingElement()) + \".\" + el.getSimpleName();\n+                    case EXCEPTION_PARAMETER: case LOCAL_VARIABLE: case PARAMETER: case RESOURCE_VARIABLE:\n+                        return el.getSimpleName() + \":\" + el.asType();\n+                    case CONSTRUCTOR: case METHOD:\n+                        StringBuilder header = new StringBuilder();\n+                        header.append(elementSignature(el.getEnclosingElement()));\n+                        if (el.getKind() == ElementKind.METHOD) {\n+                            header.append(\".\");\n+                            header.append(el.getSimpleName());\n+                        }\n+                        header.append(\"(\");\n+                        String sep = \"\";\n+                        ExecutableElement method = (ExecutableElement) el;\n+                        for (Iterator<? extends VariableElement> i = method.getParameters().iterator(); i.hasNext();) {\n+                            VariableElement p = i.next();\n+                            header.append(sep);\n+                            header.append(p.asType());\n+                            sep = \", \";\n+                        }\n+                        header.append(\")\");\n+                        return header.toString();\n+                    case PACKAGE, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER,\n+                         OTHER, MODULE, RECORD_COMPONENT, BINDING_VARIABLE:\n+                        return el.toString();\n+                    default:\n+                        throw Assert.error(el.getKind().name());\n+                }\n+            }\n+\n+            private TypeElement topLevelType(Element el) {\n+                if (el.getKind() == ElementKind.PACKAGE)\n+                    return null;\n+\n+                while (el != null && el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {\n+                    el = el.getEnclosingElement();\n+                }\n+\n+                return el != null && (el.getKind().isClass() || el.getKind().isInterface()) ? (TypeElement) el : null;\n+            }\n+\n+            private void fillElementCache(JavacTask task, CompilationUnitTree cut) throws IOException {\n+                Trees trees = Trees.instance(task);\n+\n+                new TreePathScanner<Void, Void>() {\n+                    @Override @DefinedBy(Api.COMPILER_TREE)\n+                    public Void visitMethod(MethodTree node, Void p) {\n+                        handleDeclaration();\n+                        return null;\n+                    }\n+\n+                    @Override @DefinedBy(Api.COMPILER_TREE)\n+                    public Void visitClass(ClassTree node, Void p) {\n+                        handleDeclaration();\n+                        return super.visitClass(node, p);\n+                    }\n+\n+                    @Override @DefinedBy(Api.COMPILER_TREE)\n+                    public Void visitVariable(VariableTree node, Void p) {\n+                        handleDeclaration();\n+                        return super.visitVariable(node, p);\n+                    }\n+\n+                    private void handleDeclaration() {\n+                        Element currentElement = trees.getElement(getCurrentPath());\n+\n+                        if (currentElement != null) {\n+                            signature2Source.put(elementSignature(currentElement), Pair.of(task, getCurrentPath()));\n+                        }\n+                    }\n+                }.scan(cut, null);\n+            }\n+\n+        private Pair<JavacTask, CompilationUnitTree> findSource(String moduleName,\n+                                                                String binaryName) throws IOException {\n+            JavaFileObject jfo = fm.getJavaFileForInput(StandardLocation.SOURCE_PATH,\n+                                                        binaryName,\n+                                                        JavaFileObject.Kind.SOURCE);\n+\n+            if (jfo == null)\n+                return null;\n+\n+            List<JavaFileObject> jfos = Arrays.asList(jfo);\n+            JavaFileManager patchFM = moduleName != null\n+                    ? new PatchModuleFileManager(baseFileManager, jfo, moduleName)\n+                    : baseFileManager;\n+            JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, patchFM, d -> {}, null, null, jfos);\n+            Iterable<? extends CompilationUnitTree> cuts = task.parse();\n+\n+            task.enter();\n+\n+            return Pair.of(task, cuts.iterator().next());\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fm.close();\n+        }\n+\n+        private static boolean containsMarkdown(Iterable<? extends DocTree> trees) {\n+            return StreamSupport.stream(trees.spliterator(), false)\n+                                .anyMatch(t -> t.getKind() == DocTree.Kind.MARKDOWN);\n+        }\n+\n+        private static final char PLACEHOLDER = '\\uFFFC'; \/\/ Unicode Object Replacement Character\n+\n+        private static JoinedMarkdown joinMarkdown(SyntheticAwareTreeDocSourcePositions sp,\n+                                                   DocCommentTree comment,\n+                                                   Iterable<? extends DocTree> trees) {\n+            StringBuilder sourceBuilder = new StringBuilder();\n+            List<int[]> replaceSpans = new ArrayList<>();\n+            int currentSpanStart = (int) sp.getStartPosition(null, comment, trees.iterator().next());\n+            DocTree lastTree = null;\n+\n+            for (DocTree tree : trees) {\n+                if (tree instanceof RawTextTree t) {\n+                    if (t.getKind() != DocTree.Kind.MARKDOWN) {\n+                        throw new IllegalStateException(t.getKind().toString());\n+                    }\n+                    String code = t.getContent();\n+                    \/\/ handle the (unlikely) case of any U+FFFC characters existing in the code\n+                    int start = 0;\n+                    int pos;\n+                    while ((pos = code.indexOf(PLACEHOLDER, start)) != -1) {\n+                        replaceSpans.add(new int[] {currentSpanStart, currentSpanStart + pos - start});\n+                        currentSpanStart += pos - start + 1;\n+                        start = pos + 1;\n+                    }\n+                    sourceBuilder.append(code);\n+                } else {\n+                    int treeStart = (int) sp.getStartPosition(null, comment, tree);\n+                    int treeEnd = (int) sp.getEndPosition(null, comment, tree);\n+                    replaceSpans.add(new int[] {currentSpanStart, treeStart});\n+                    currentSpanStart = treeEnd;\n+                    sourceBuilder.append(PLACEHOLDER);\n+                }\n+                lastTree = tree;\n+            }\n+\n+            int end = (int) sp.getEndPosition(null, comment, lastTree);\n+\n+            replaceSpans.add(new int[] {currentSpanStart, end});\n+\n+            return new JoinedMarkdown(sourceBuilder.toString(), replaceSpans);\n+        }\n+\n+        private static String stripParagraphs(String input) {\n+            input = input.replace(\"<\/p>\", \"\");\n+\n+            if (input.startsWith(\"<p>\")) {\n+                input = input.substring(3);\n+            }\n+\n+            if (input.endsWith(\"\\n\")) {\n+                input = input.substring(0, input.length() - 1);\n+            }\n+\n+            return input.replace(\"<p>\", \"\\n<p>\");\n+        }\n+\n+        private static final String PLACEHOLDER_PATTERN = Pattern.quote(\"\" + PLACEHOLDER);\n+\n+        private record JoinedMarkdown(String source, List<int[]> replaceSpans) {}\n+\n+        \/\/embedded transformers may produce rewritten trees for link,\n+        \/\/there re-written trees has start position -1, the DocSourcePositions\n+        \/\/will provide an adjusted span based on the link nested nodes:\n+        private static final class SyntheticAwareTreeDocSourcePositions implements DocSourcePositions {\n+\n+            private final DocSourcePositions delegate;\n+            private final Map<DocTree, long[]> adjustedSpan = new HashMap<>();\n+            private final Set<DocTree> rewrittenTrees = new HashSet<>();\n+\n+            public SyntheticAwareTreeDocSourcePositions(DocSourcePositions delegate) {\n+                this.delegate = delegate;\n+            }\n+\n+            @Override\n+            public long getStartPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {\n+                ensureAdjustedSpansFilled(file, comment, tree);\n+\n+                long[] adjusted = adjustedSpan.get(tree);\n+\n+                if (adjusted != null) {\n+                    return adjusted[0];\n+                }\n+\n+                return delegate.getStartPosition(file, comment, tree);\n+            }\n+\n+            @Override\n+            public long getEndPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {\n+                ensureAdjustedSpansFilled(file, comment, tree);\n+\n+                long[] adjusted = adjustedSpan.get(tree);\n+\n+                if (adjusted != null) {\n+                    return adjusted[1];\n+                }\n+\n+                return delegate.getEndPosition(file, comment, tree);\n+            }\n+\n+            @Override\n+            public long getStartPosition(CompilationUnitTree file, Tree tree) {\n+                return delegate.getStartPosition(file, tree);\n+            }\n+\n+            @Override\n+            public long getEndPosition(CompilationUnitTree file, Tree tree) {\n+                return delegate.getEndPosition(file, tree);\n+            }\n+\n+            boolean isRewrittenTree(CompilationUnitTree file,\n+                                    DocCommentTree comment,\n+                                    DocTree tree) {\n+                ensureAdjustedSpansFilled(file, comment, tree);\n+                return rewrittenTrees.contains(tree);\n+            }\n+\n+            private void ensureAdjustedSpansFilled(CompilationUnitTree file,\n+                                                   DocCommentTree comment,\n+                                                   DocTree tree) {\n+                if (tree.getKind() != DocTree.Kind.LINK &&\n+                    tree.getKind() != DocTree.Kind.LINK_PLAIN) {\n+                    return ;\n+                }\n+\n+                long[] span;\n+                long treeStart = delegate.getStartPosition(file, comment, tree);\n+\n+                if (treeStart == (-1)) {\n+                    LinkTree link = (LinkTree) tree;\n+                    Iterable<? extends DocTree> nested = () -> Stream.concat(link.getLabel().stream(),\n+                                                                             Stream.of(link.getReference()))\n+                                                                     .iterator();\n+                    long start = Long.MAX_VALUE;\n+                    long end = Long.MIN_VALUE;\n+\n+                    for (DocTree t : nested) {\n+                        start = Math.min(start,\n+                                         delegate.getStartPosition(file, comment, t));\n+                        end   = Math.max(end,\n+                                         delegate.getEndPosition(file, comment, t));\n+                    }\n+\n+                    span = new long[] {(int) start - 1, (int) end + 1};\n+                    rewrittenTrees.add(tree);\n+                } else {\n+                    long treeEnd = delegate.getEndPosition(file, comment, tree);\n+                    span = new long[] {treeStart, treeEnd};\n+                }\n+\n+                adjustedSpan.put(tree, span);\n+            }\n+        }\n+\n+        private static final class PatchModuleFileManager\n+                extends ForwardingJavaFileManager<JavaFileManager> {\n+\n+            private final JavaFileObject file;\n+            private final String moduleName;\n+\n+            public PatchModuleFileManager(JavaFileManager fileManager,\n+                                          JavaFileObject file,\n+                                          String moduleName) {\n+                super(fileManager);\n+                this.file = file;\n+                this.moduleName = moduleName;\n+            }\n+\n+            @Override @DefinedBy(Api.COMPILER)\n+            public Location getLocationForModule(Location location,\n+                                                 JavaFileObject fo) throws IOException {\n+                return fo == file\n+                        ? PATCH_LOCATION\n+                        : super.getLocationForModule(location, fo);\n+            }\n+\n+            @Override @DefinedBy(Api.COMPILER)\n+            public String inferModuleName(Location location) throws IOException {\n+                return location == PATCH_LOCATION\n+                        ? moduleName\n+                        : super.inferModuleName(location);\n+            }\n+\n+            @Override @DefinedBy(Api.COMPILER)\n+            public boolean hasLocation(Location location) {\n+                return location == StandardLocation.PATCH_MODULE_PATH ||\n+                       super.hasLocation(location);\n+            }\n+\n+            private static final Location PATCH_LOCATION = new Location() {\n+                @Override @DefinedBy(Api.COMPILER)\n+                public String getName() {\n+                    return \"PATCH_LOCATION\";\n+                }\n+\n+                @Override @DefinedBy(Api.COMPILER)\n+                public boolean isOutputLocation() {\n+                    return false;\n+                }\n+\n+                @Override @DefinedBy(Api.COMPILER)\n+                public boolean isModuleOrientedLocation() {\n+                    return false;\n+                }\n+\n+            };\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","additions":1058,"deletions":0,"binary":false,"changes":1058,"status":"added"},{"patch":"","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/resources\/javadocformatter.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/resources\/javadocformatter.properties","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+    requires jdk.internal.md;\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *          jdk.compiler\/jdk.internal.shellsupport.doc\n+ *          jdk.jshell\/jdk.internal.shellsupport.doc\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/FullJavadocHelperTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules jdk.compiler\/jdk.internal.shellsupport.doc\n+ * @modules jdk.jshell\/jdk.internal.shellsupport.doc\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocFormatterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *          jdk.compiler\/jdk.internal.shellsupport.doc\n+ *          jdk.jshell\/jdk.internal.shellsupport.doc\n@@ -96,6 +96,0 @@\n-    private Element getFirstMethod(JavacTask task, String typeName) {\n-        return ElementFilter.methodsIn(task.getElements().getTypeElement(typeName).getEnclosedElements()).get(0);\n-    }\n-\n-    private Function<JavacTask, Element> getSubTest = t -> getFirstMethod(t, \"test.Sub\");\n-\n@@ -304,0 +298,144 @@\n+    public void testMarkdown() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/ Prefix {@inheritDoc} suffix.\n+                      \/\/\/\n+                      \/\/\/ *Another* __paragraph__.\n+                      \/\/\/\n+                      \/\/\/ Paragraph \\ufffc with \\ufffc replacement \\ufffc character.\n+                      \/\/\/\n+                      \/\/\/ @param p1 prefix {@inheritDoc} suffix\n+                      \/\/\/ @param p2 prefix {@inheritDoc} suffix\n+                      \/\/\/ @param p3 prefix {@inheritDoc} suffix\n+                      \/\/\/ @throws IllegalStateException prefix {@inheritDoc} suffix\n+                      \/\/\/ @throws IllegalArgumentException prefix {@inheritDoc} suffix\n+                      \/\/\/ @throws IllegalAccessException prefix {@inheritDoc} suffix\n+                      \/\/\/ @return prefix {@inheritDoc} suffix\n+                      \"\"\",\n+                      getSubTest,\n+                      \"\"\"\n+                      Prefix javadoc1 suffix.\n+\n+                      <p><em>Another<\/em> <strong>paragraph<\/strong>.\n+\n+                      <p>Paragraph \\ufffc with \\ufffc replacement \\ufffc character.\n+\n+                      @param p1 prefix param1 suffix\n+                      @param p2 prefix param2 suffix\n+                      @param p3 prefix param3 suffix\n+                      @throws IllegalStateException prefix exc1 suffix\n+                      @throws IllegalArgumentException prefix exc2 suffix\n+                      @throws IllegalAccessException prefix exc3 suffix\n+                      @return prefix value suffix\"\"\");\n+    }\n+\n+    public void testMarkdown2() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/ {@inheritDoc}\n+                      \/\/\/\n+                      \/\/\/ *Another* __paragraph__. [java.lang.Object]\n+                      \/\/\/\n+                      \/\/\/ @since snc\n+                      \"\"\",\n+                      getSubTest,\n+                      \"\"\"\n+                      javadoc1\n+\n+                      <p><em>Another<\/em> <strong>paragraph<\/strong>. {@link java.lang.Object}\n+\n+                      @param p1 param1\n+                      @param p2 param2\n+                      @param p3 param3\n+                      @throws java.lang.IllegalStateException exc1\n+                      @throws java.lang.IllegalArgumentException exc2\n+                      @throws java.lang.IllegalAccessException exc3\n+                      @return value\n+                      @since snc\"\"\");\n+    }\n+\n+    public void testMarkdown3() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/ {@inheritDoc}\n+                      \/\/\/\n+                      \/\/\/ *Another* __paragraph__.\n+                      \"\"\",\n+                      getSubTest,\n+                      \/\/the formatting could be improved:\n+                      \"\"\"\n+                      javadoc1\n+\n+                      <p><em>Another<\/em> <strong>paragraph<\/strong>.@param p1 param1\n+                      @param p2 param2\n+                      @param p3 param3\n+                      @throws java.lang.IllegalStateException exc1\n+                      @throws java.lang.IllegalArgumentException exc2\n+                      @throws java.lang.IllegalAccessException exc3\n+                      @return value\n+                      \"\"\");\n+    }\n+\n+    public void testMarkdown4() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/ {@inheritDoc}\n+                      \/\/\/\n+                      \/\/\/ *Another* __paragraph__. [test][java.lang.Object]\n+                      \/\/\/\n+                      \/\/\/ @since snc\n+                      \"\"\",\n+                      getSubTest,\n+                      \"\"\"\n+                      javadoc1\n+\n+                      <p><em>Another<\/em> <strong>paragraph<\/strong>. {@linkplain java.lang.Object test}\n+\n+                      @param p1 param1\n+                      @param p2 param2\n+                      @param p3 param3\n+                      @throws java.lang.IllegalStateException exc1\n+                      @throws java.lang.IllegalArgumentException exc2\n+                      @throws java.lang.IllegalAccessException exc3\n+                      @return value\n+                      @since snc\"\"\");\n+    }\n+\n+    public void testMarkdown5() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/[define classes][java.lang.invoke.MethodHandles.Lookup#defineClass(byte\\\\[\\\\])]\n+                      \/\/\/\n+                      \/\/\/ @since snc\n+                      \"\"\",\n+                      getSubTest,\n+                      \"\"\"\n+                      {@linkplain java.lang.invoke.MethodHandles.Lookup#defineClass(byte[]) define classes}\n+\n+                      @param p1 param1\n+                      @param p2 param2\n+                      @param p3 param3\n+                      @throws java.lang.IllegalStateException exc1\n+                      @throws java.lang.IllegalArgumentException exc2\n+                      @throws java.lang.IllegalAccessException exc3\n+                      @return value\n+                       @since snc\"\"\");\n+    }\n+\n+    public void testMarkdown6() throws Exception {\n+        doTestJavadoc(\"\"\"\n+                      \/\/\/Text1 [define classes][java.lang.invoke.MethodHandles.Lookup#defineClass(byte\\\\[\\\\])]\n+                      \/\/\/text2\n+                      \/\/\/\n+                      \/\/\/ @since snc\n+                      \"\"\",\n+                      getSubTest,\n+                      \"\"\"\n+                      Text1 {@linkplain java.lang.invoke.MethodHandles.Lookup#defineClass(byte[]) define classes}\n+                      text2\n+\n+                      @param p1 param1\n+                      @param p2 param2\n+                      @param p3 param3\n+                      @throws java.lang.IllegalStateException exc1\n+                      @throws java.lang.IllegalArgumentException exc2\n+                      @throws java.lang.IllegalAccessException exc3\n+                      @return value\n+                       @since snc\"\"\");\n+    }\n+\n@@ -373,0 +511,6 @@\n+    private Element getFirstMethod(JavacTask task, String typeName) {\n+        return ElementFilter.methodsIn(task.getElements().getTypeElement(typeName).getEnclosedElements()).get(0);\n+    }\n+\n+    private Function<JavacTask, Element> getSubTest = t -> getFirstMethod(t, \"test.Sub\");\n+\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocHelperTest.java","additions":151,"deletions":7,"binary":false,"changes":158,"status":"modified"}]}