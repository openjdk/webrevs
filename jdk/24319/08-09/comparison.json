{"files":[{"patch":"@@ -91,11 +91,1 @@\n-  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n-  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n-  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n-  \/\/ us to more quickly replenish free memory with empty regions.\n-  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n-    ShenandoahHeapRegion* r = _region_data[i].get_region();\n-    _region_data[i].update_livedata(r->get_live_data_bytes());\n-  }\n-  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n-                              compare_by_live);\n-\n+  sort_candidates_by_live();\n@@ -326,1 +316,10 @@\n-void ShenandoahOldHeuristics::recalibrate_old_collection_candidates_live_memory() {\n+void ShenandoahOldHeuristics::sort_candidates_by_live() {\n+  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first, so we sort by live-data.\n+  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n+  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n+  \/\/ in old-gen.  Overwrite _live_bytes_in_unprocessed_candidates with most current data.\n+\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n+  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n+  \/\/ us to more quickly replenish free memory with empty regions.\n@@ -398,6 +397,3 @@\n-  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first.  We sort by live-data.\n-  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n-  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n-  \/\/ in old-gen.\n-\n-  QuickSort::sort<RegionData>(candidates, cand_idx, compare_by_live);\n+  _next_old_collection_candidate = 0;\n+  _last_old_collection_candidate = (uint)cand_idx;\n+  sort_candidates_by_live();\n@@ -414,1 +410,0 @@\n-  _last_old_collection_candidate = (uint)cand_idx;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -134,6 +134,3 @@\n-  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n-  \/\/ promotions and old-gen evacuations.  Recompute live data in candidates and re--sort the candidate regions in\n-  \/\/ order to first evacuate regions that have the smallest amount of live data.  These are easiest to evacuate\n-  \/\/ with least effort.  Doing these first allows us to more quickly replenish free memory with entirely empty regions.\n-  \/\/ Call this during final mark before adjusting the old-evacuation ratio.\n-  void recalibrate_old_collection_candidates_live_memory();\n+  \/\/ Sort candidates between _next_old_collection_candidate (inclusive) and _last_old_collection_candidate (exclusive)\n+  \/\/ by live data, updating _live_bytes_in_unprocessed_candidates to represent the amount of data remaining to be evacuated.\n+  void sort_candidates_by_live();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2560,2 +2560,1 @@\n-\n-    old_heuristics->recalibrate_old_collection_candidates_live_memory();\n+    old_heuristics->sort_candidates_by_live();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}