{"files":[{"patch":"@@ -132,0 +132,7 @@\n+    inline void update_livedata(size_t live) {\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,0 +91,11 @@\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n+  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n+  \/\/ us to more quickly replenish free memory with empty regions.\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n+    ShenandoahHeapRegion* r = _region_data[i].get_region();\n+    _region_data[i].update_livedata(r->get_mixed_candidate_live_data_bytes());\n+  }\n+  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n+                              compare_by_live);\n+\n@@ -406,0 +417,2 @@\n+\n+    r->capture_mixed_candidate_garbage();\n@@ -448,0 +461,2 @@\n+\n+      r->capture_mixed_candidate_garbage();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  _mixed_candidate_garbage_words(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+  size_t _mixed_candidate_garbage_words;\n+\n@@ -379,0 +381,2 @@\n+\n+  \/\/ Returns bytes identified as live at time of most recent mark. Does not include allocations subsequent to last mark.\n@@ -380,0 +384,2 @@\n+\n+  \/\/ Returns words identified as live at time of most recent mark. Does not include allocations subsequent to last mark.\n@@ -382,0 +388,8 @@\n+  inline size_t get_mixed_candidate_live_data_bytes() const;\n+  inline size_t get_mixed_candidate_live_data_words() const;\n+\n+  inline void capture_mixed_candidate_garbage();\n+\n+  \/\/ Returns garbage by calculating difference between used and get_live_data_words.  The value returned is only\n+  \/\/ meaningful immediately following completion of marking.  If there have been subsequent allocations in this region,\n+  \/\/ use a different approach to determine garbage, such as (used() - get_mixed_candidate_live_data_bytes())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -158,0 +158,17 @@\n+inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_bytes() const {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at Shenandoah safepoint\");\n+  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n+  return used() - _mixed_candidate_garbage_words * HeapWordSize;\n+}\n+\n+inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_words() const {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at Shenandoah safepoint\");\n+  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n+  return used() \/ HeapWordSize - _mixed_candidate_garbage_words;\n+}\n+\n+inline void ShenandoahHeapRegion::capture_mixed_candidate_garbage() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at Shenandoah safepoint\");\n+  _mixed_candidate_garbage_words = garbage() \/ HeapWordSize;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}