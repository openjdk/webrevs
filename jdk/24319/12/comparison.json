{"files":[{"patch":"@@ -111,1 +111,1 @@\n-\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -114,3 +114,4 @@\n-\n-    size_t new_cset    = cur_cset + r->get_live_data_bytes();\n-    size_t new_garbage = cur_garbage + r->garbage();\n+    size_t region_index = r->index();\n+    size_t region_garbage = r->garbage(context, region_index);\n+    size_t new_cset    = cur_cset + r->get_live_data_bytes(context, region_index);\n+    size_t new_garbage = cur_garbage + region_garbage;\n@@ -122,2 +123,2 @@\n-    if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n-      cset->add_region(r);\n+    if ((new_garbage < min_garbage) || (region_garbage > garbage_threshold)) {\n+      cset->add_region(r, context, r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -47,2 +48,3 @@\n-    if (r->garbage() > 0) {\n-      cset->add_region(r);\n+    size_t region_index = r->index();\n+    if (r->garbage(context, region_index) > 0) {\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -95,2 +95,3 @@\n-    size_t new_cset = live_cset + r->get_live_data_bytes();\n-    if (new_cset < max_cset && r->garbage() > threshold) {\n+    size_t region_index = r->index();\n+    size_t new_cset = live_cset + r->get_live_data_bytes(context, region_index);\n+    if (new_cset < max_cset && r->garbage(context, region_index) > threshold) {\n@@ -98,1 +99,1 @@\n-      cset->add_region(r);\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  ShenandoahMarkingContext* context = _generation->complete_marking_context();\n@@ -79,1 +80,1 @@\n-    ShenandoahHeapRegion* region = heap->get_region(i);\n+    ShenandoahHeapRegion* const region = heap->get_region(i);\n@@ -83,1 +84,1 @@\n-    size_t garbage = region->garbage();\n+    size_t garbage = region->garbage(context, i);\n@@ -89,1 +90,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n@@ -115,1 +116,1 @@\n-            regular_regions_promoted_garbage += region->garbage();\n+            regular_regions_promoted_garbage += region->garbage(context, i);\n@@ -129,2 +130,2 @@\n-      bool reg_live = region->has_live();\n-      bool bm_live = _generation->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n+      bool reg_live = region->has_live(context, i);\n+      bool bm_live = context->is_marked(cast_to_oop(region->bottom()));\n@@ -133,1 +134,1 @@\n-             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n+             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words(context, i));\n@@ -135,1 +136,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n@@ -207,0 +208,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -209,1 +211,2 @@\n-    if (cset->is_preselected(r->index())) {\n+    size_t region_index = r->index();\n+    if (cset->is_preselected(region_index)) {\n@@ -220,2 +223,2 @@\n-      cur_young_garbage += r->garbage();\n-      cset->add_region(r);\n+      cur_young_garbage += r->garbage(context, region_index);\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -98,2 +99,4 @@\n-    ShenandoahHeapRegion* r = data[idx].get_region();\n-    assert(!cset->is_preselected(r->index()), \"There should be no preselected regions during GLOBAL GC\");\n+    ShenandoahHeapRegion* const r = data[idx].get_region();\n+    const size_t region_index = r->index();\n+    const size_t region_garbage = r->garbage(context, region_index);\n+    assert(!cset->is_preselected(region_index), \"There should be no preselected regions during GLOBAL GC\");\n@@ -102,2 +105,2 @@\n-      size_t new_cset = old_cur_cset + r->get_live_data_bytes();\n-      if ((r->garbage() > garbage_threshold)) {\n+      size_t new_cset = old_cur_cset + r->get_live_data_bytes(context, region_index);\n+      if ((region_garbage > garbage_threshold)) {\n@@ -110,1 +113,1 @@\n-      if ((new_cset <= max_old_cset) && (r->garbage() > garbage_threshold)) {\n+      if ((new_cset <= max_old_cset) && (region_garbage > garbage_threshold)) {\n@@ -116,2 +119,1 @@\n-      size_t new_cset = young_cur_cset + r->get_live_data_bytes();\n-      size_t region_garbage = r->garbage();\n+      size_t new_cset = young_cur_cset + r->get_live_data_bytes(context, region_index);\n@@ -121,1 +123,1 @@\n-      if (add_regardless || (r->garbage() > garbage_threshold)) {\n+      if (add_regardless || (region_garbage > garbage_threshold)) {\n@@ -134,1 +136,1 @@\n-      cset->add_region(r);\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+  ShenandoahMarkingContext* context = heap->global_generation()->complete_marking_context();\n@@ -103,1 +104,1 @@\n-    size_t garbage = region->garbage();\n+    size_t garbage = region->garbage(context, i);\n@@ -110,1 +111,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n@@ -123,2 +124,2 @@\n-      bool reg_live = region->has_live();\n-      bool bm_live = heap->global_generation()->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n+      bool reg_live = region->has_live(context, i);\n+      bool bm_live = context->is_marked(cast_to_oop(region->bottom()));\n@@ -127,1 +128,1 @@\n-             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words());\n+             BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region->get_live_data_words(context, i));\n@@ -129,1 +130,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,0 +132,7 @@\n+    inline void update_livedata(size_t live) {\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  sort_candidates_by_live();\n@@ -133,0 +134,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -139,0 +141,1 @@\n+    size_t region_index = r->index();\n@@ -144,1 +147,1 @@\n-    const size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    const size_t live_data_for_evacuation = r->get_live_data_bytes(context, region_index);\n@@ -201,1 +204,1 @@\n-    collection_set->add_region(r);\n+    collection_set->add_region(r, context, region_index);\n@@ -204,1 +207,1 @@\n-    collected_old_bytes += r->garbage();\n+    collected_old_bytes += r->garbage(context, region_index);\n@@ -319,0 +322,23 @@\n+void ShenandoahOldHeuristics::sort_candidates_by_live() {\n+  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first, so we sort by live-data.\n+  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n+  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n+  \/\/ in old-gen.  Overwrite _live_bytes_in_unprocessed_candidates with most current data.\n+\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n+  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n+  \/\/ us to more quickly replenish free memory with empty regions.\n+  size_t total_live_data = 0;\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n+    ShenandoahHeapRegion* r = _region_data[i].get_region();\n+    size_t region_live = r->get_live_data_bytes(context, r->index());\n+    total_live_data += region_live;\n+    _region_data[i].update_livedata(region_live);\n+  }\n+  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n+                              compare_by_live);\n+  _live_bytes_in_unprocessed_candidates = total_live_data;\n+}\n+\n@@ -329,0 +355,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -335,2 +362,2 @@\n-    size_t garbage = region->garbage();\n-    size_t live_bytes = region->get_live_data_bytes();\n+    size_t garbage = region->garbage(context, i);\n+    size_t live_bytes = region->get_live_data_bytes(context, i);\n@@ -344,1 +371,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n@@ -358,1 +385,1 @@\n-      if (!region->has_live()) {\n+      if (!region->has_live(context, i)) {\n@@ -378,6 +405,3 @@\n-  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first.  We sort by live-data.\n-  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n-  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n-  \/\/ in old-gen.\n-\n-  QuickSort::sort<RegionData>(candidates, cand_idx, compare_by_live);\n+  _next_old_collection_candidate = 0;\n+  _last_old_collection_candidate = (uint)cand_idx;\n+  sort_candidates_by_live();\n@@ -394,1 +418,0 @@\n-  _last_old_collection_candidate = (uint)cand_idx;\n@@ -407,3 +430,4 @@\n-    ShenandoahHeapRegion* r = candidates[i].get_region();\n-    size_t region_garbage = r->garbage();\n-    size_t region_free = r->free();\n+    ShenandoahHeapRegion* const r = candidates[i].get_region();\n+    const size_t region_index = r->index();\n+    const size_t region_garbage = r->garbage(context, region_index);\n+    const size_t region_free = r->free();\n@@ -447,1 +471,2 @@\n-      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate].get_region();\n+      ShenandoahHeapRegion* const r = candidates[_last_old_collection_candidate].get_region();\n+      const size_t region_index = r->index();\n@@ -449,2 +474,2 @@\n-             r->index(), ShenandoahHeapRegion::region_state_to_string(r->state()));\n-      const size_t region_garbage = r->garbage();\n+             region_index, ShenandoahHeapRegion::region_state_to_string(r->state()));\n+      const size_t region_garbage = r->garbage(context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":45,"deletions":20,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -134,0 +134,4 @@\n+  \/\/ Sort candidates between _next_old_collection_candidate (inclusive) and _last_old_collection_candidate (exclusive)\n+  \/\/ by live data, updating _live_bytes_in_unprocessed_candidates to represent the amount of data remaining to be evacuated.\n+  void sort_candidates_by_live();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -73,2 +74,3 @@\n-    size_t new_cset = live_cset + r->get_live_data_bytes();\n-    if (new_cset < max_cset && r->garbage() > threshold) {\n+    size_t region_index = r->index();\n+    size_t new_cset = live_cset + r->get_live_data_bytes(context, region_index);\n+    if (new_cset < max_cset && r->garbage(context, region_index) > threshold) {\n@@ -76,1 +78,1 @@\n-      cset->add_region(r);\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -71,2 +71,3 @@\n-    if (r->garbage() > threshold) {\n-      cset->add_region(r);\n+    size_t region_index = r->index();\n+    if (r->garbage(context, region_index) > threshold) {\n+      cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -85,2 +85,3 @@\n-    ShenandoahHeapRegion* r = data[idx].get_region();\n-    if (cset->is_preselected(r->index())) {\n+    ShenandoahHeapRegion* const r = data[idx].get_region();\n+    const size_t region_index = r->index();\n+    if (cset->is_preselected(region_index)) {\n@@ -94,2 +95,2 @@\n-      const size_t new_cset = cur_cset + r->get_live_data_bytes();\n-      const size_t region_garbage = r->garbage();\n+      const size_t new_cset = cur_cset + r->get_live_data_bytes(context, region_index);\n+      const size_t region_garbage = r->garbage(context, region_index);\n@@ -102,1 +103,1 @@\n-        cset->add_region(r);\n+        cset->add_region(r, context, region_index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-void ShenandoahCollectionSet::add_region(ShenandoahHeapRegion* r) {\n+void ShenandoahCollectionSet::add_region(ShenandoahHeapRegion* r, ShenandoahMarkingContext* context, size_t index) {\n@@ -96,2 +96,2 @@\n-  size_t live    = r->get_live_data_bytes();\n-  size_t garbage = r->garbage();\n+  size_t live    = r->get_live_data_bytes(context, index);\n+  size_t garbage = r->garbage(context, index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  void add_region(ShenandoahHeapRegion* r);\n+  void add_region(ShenandoahHeapRegion* r, ShenandoahMarkingContext* context, size_t index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-    assert(!r->has_live(), \"Region %zu should have no live data\", r->index());\n+    assert(!r->has_marked(), \"Region %zu should have no marked data\", r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -452,1 +453,1 @@\n-    if (from_region->has_live()) {\n+    if (from_region->has_live(context, from_region->index())) {\n@@ -555,1 +556,1 @@\n-        assert(!r->has_live(), \"Region %zu is not marked, should not have live\", r->index());\n+        assert(!r->has_live(_ctx, r->index()), \"Region %zu is not marked, should not have live\", r->index());\n@@ -558,1 +559,1 @@\n-        assert(r->has_live(), \"Region %zu should have live\", r->index());\n+        assert(r->has_live(_ctx, r->index()), \"Region %zu should have live\", r->index());\n@@ -562,1 +563,1 @@\n-      assert(r->humongous_start_region()->has_live(), \"Region %zu should have live\", r->index());\n+      assert(r->humongous_start_region()->has_live(_ctx, r->humongous_start_region()->index()), \"Region %zu should have live\", r->humongous_start_region()->index());\n@@ -564,1 +565,1 @@\n-      if (!r->has_live()) {\n+      if (!r->has_live(_ctx, r->index())) {\n@@ -608,0 +609,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->global_generation()->complete_marking_context();\n@@ -612,1 +614,1 @@\n-      total_live += r->get_live_data_words();\n+      total_live += r->get_live_data_words(context, idx);\n@@ -653,1 +655,1 @@\n-        live[wid] += r->get_live_data_words();\n+        live[wid] += r->get_live_data_words(context, prefix_idx);\n@@ -668,1 +670,1 @@\n-      size_t live_region = r->get_live_data_words();\n+      size_t live_region = r->get_live_data_words(context, tail_idx);\n@@ -806,0 +808,1 @@\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -807,1 +810,1 @@\n-      if (!r->is_humongous_continuation() && r->has_live()) {\n+      if (!r->is_humongous_continuation() && r->has_live(context, r->index())) {\n@@ -903,0 +906,1 @@\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -905,1 +909,1 @@\n-      if (r->has_live()) {\n+      if (r->has_live(context, r->index())) {\n@@ -918,0 +922,1 @@\n+  ShenandoahMarkingContext* _mark_context;\n@@ -924,0 +929,1 @@\n+                                   _mark_context(_heap->marking_context()),\n@@ -976,1 +982,1 @@\n-    r->set_live_data(live);\n+    r->set_live_data_after_fullgc(live, _mark_context, r->index());\n@@ -1070,1 +1076,1 @@\n-      if (heap->is_bitmap_slice_committed(region) && !region->is_pinned() && region->has_live()) {\n+      if (heap->is_bitmap_slice_committed(region) && !region->is_pinned() && region->has_marked()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-      NOT_PRODUCT(_total_pop += r->get_live_data_words();)\n+      NOT_PRODUCT(_total_pop += r->get_live_data_words(_ctx, r->index());)\n@@ -549,1 +549,0 @@\n-\n@@ -566,0 +565,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -568,1 +568,1 @@\n-    if (r->is_empty() || !r->has_live() || !r->is_young() || !r->is_regular()) {\n+    if (r->is_empty() || !r->has_live(context, i) || !r->is_young() || !r->is_regular()) {\n@@ -573,2 +573,2 @@\n-      if ((r->garbage() < old_garbage_threshold) && (r->used() > pip_used_threshold)) {\n-        \/\/ We prefer to promote this region in place because it has a small amount of garbage and a large usage.\n+      if ((r->garbage(context, i) < old_garbage_threshold) && (r->used() > pip_used_threshold)) {\n+        \/\/ We prefer to promote this region in place because is has a small amount of garbage and a large usage.\n@@ -643,1 +643,1 @@\n-        sorted_regions[candidates++]._live_data = r->get_live_data_bytes();\n+        sorted_regions[candidates++]._live_data = r->get_live_data_bytes(context, i);\n@@ -662,2 +662,2 @@\n-        if (r->garbage() >= old_garbage_threshold) {\n-          promo_potential += r->get_live_data_bytes();\n+        if (r->garbage(context, i) >= old_garbage_threshold) {\n+          promo_potential += r->get_live_data_bytes(context, i);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -211,1 +212,1 @@\n-        young_region_ages.add(r->age(), r->get_live_data_words());\n+        young_region_ages.add(r->age(), r->get_live_data_words(context, i));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -127,1 +128,1 @@\n-      assert(r->has_live(), \"Region %zu should have been reclaimed early\", r->index());\n+      assert(r->has_live(context, r->index()), \"Region %zu should have been reclaimed early\", r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -114,1 +115,1 @@\n-        live_bytes_in_old += r->get_live_data_bytes();\n+        live_bytes_in_old += r->get_live_data_bytes(context, i);\n@@ -176,1 +177,2 @@\n-        _worker_id(worker_id) {\n+        _worker_id(worker_id),\n+        _ctx(_heap->marking_context()) {\n@@ -191,1 +193,2 @@\n-                from_region->index(), from_region->used(), from_region->has_live()? \"has\": \"does not have\");\n+                from_region->index(), from_region->used(),\n+                from_region->has_live(_ctx, from_region->index())? \"has\": \"does not have\");\n@@ -195,1 +198,1 @@\n-  if (_from_region->has_live()) {\n+  if (_from_region->has_live(_ctx, _from_region->index())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  ShenandoahMarkingContext*      _ctx;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,0 +1133,3 @@\n+#ifdef ASSERT\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n+#endif\n@@ -1134,1 +1137,1 @@\n-      assert(r->has_live(), \"Region %zu should have been reclaimed early\", r->index());\n+      assert(r->has_live(context, r->index()), \"Region %zu should have been reclaimed early\", r->index());\n@@ -1415,1 +1418,1 @@\n-  assert(!start->has_live(), \"liveness must be zero\");\n+  assert(!start->has_live(ShenandoahHeap::heap()->marking_context(), start->index()), \"liveness must be zero\");\n@@ -2539,0 +2542,3 @@\n+    ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+    ShenandoahOldHeuristics* old_heuristics = old_gen->heuristics();\n+    old_heuristics->sort_candidates_by_live();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-void ShenandoahHeapRegion::set_live_data(size_t s) {\n+void ShenandoahHeapRegion::set_live_data_after_fullgc(size_t s, ShenandoahMarkingContext* marking_context, size_t index) {\n@@ -386,1 +386,2 @@\n-  _live_data = (s >> LogHeapWordSize);\n+  size_t words_allocated_above_tams = pointer_delta(top(), marking_context->top_at_mark_start(index));\n+  _live_data = (s >> LogHeapWordSize) - words_allocated_above_tams;\n@@ -445,1 +446,2 @@\n-  st->print(\"|L %5zu%1s\", byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));\n+  size_t live_bytes = get_live_data_bytes(ShenandoahHeap::heap()->marking_context(), index());\n+  st->print(\"|L %5zu%1s\", byte_size_in_proper_unit(live_bytes),            proper_unit_for_byte_size(live_bytes));\n@@ -888,1 +890,1 @@\n-      assert(!has_live(), \"Free region should not have live data\");\n+      assert(!has_live(ctx, index()), \"Free region should not have live data\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -373,4 +373,1 @@\n-  void set_live_data(size_t s);\n-\n-  \/\/ Increase live data for newly allocated region\n-  inline void increase_live_data_alloc_words(size_t s);\n+  void set_live_data_after_fullgc(size_t s, ShenandoahMarkingContext* context, size_t index);\n@@ -380,0 +377,10 @@\n+  inline bool has_marked() const;\n+\n+  inline bool has_live(ShenandoahMarkingContext* context, size_t index) const;\n+\n+  \/\/ Returns bytes identified as live by most recently completed marking effort.  Can only be called during safepoints.\n+  inline size_t get_marked_data_bytes() const;\n+\n+  \/\/ Returns bytes identified as live by most recently completed marking effort, plus allocations above TAMS.\n+  \/\/ Can only be called during safepoints.\n+  inline size_t get_live_data_bytes(ShenandoahMarkingContext* context, size_t index) const;\n@@ -381,3 +388,3 @@\n-  inline bool has_live() const;\n-  inline size_t get_live_data_bytes() const;\n-  inline size_t get_live_data_words() const;\n+  \/\/ Returns words identified as live by most recently completed marking effort, plus allocations above TAMS.\n+  \/\/ Can only be called during safepoints.\n+  inline size_t get_live_data_words(ShenandoahMarkingContext* context, size_t index) const;\n@@ -385,1 +392,3 @@\n-  inline size_t garbage() const;\n+  \/\/ Returns garbage by calculating difference between used and get_live_data_words.  Can only be called at\n+  \/\/ safepoints. Allocations above TAMS are considered live.\n+  inline size_t garbage(ShenandoahMarkingContext* context, size_t index) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -149,4 +149,0 @@\n-inline void ShenandoahHeapRegion::increase_live_data_alloc_words(size_t s) {\n-  internal_increase_live_data(s);\n-}\n-\n@@ -158,1 +154,1 @@\n-  size_t new_live_data = AtomicAccess::add(&_live_data, s, memory_order_relaxed);\n+  AtomicAccess::add(&_live_data, s, memory_order_relaxed);\n@@ -165,2 +161,2 @@\n-inline size_t ShenandoahHeapRegion::get_live_data_words() const {\n-  return AtomicAccess::load(&_live_data);\n+inline size_t ShenandoahHeapRegion::get_marked_data_bytes() const {\n+  return AtomicAccess::load(&_live_data) * HeapWordSize;\n@@ -169,2 +165,6 @@\n-inline size_t ShenandoahHeapRegion::get_live_data_bytes() const {\n-  return get_live_data_words() * HeapWordSize;\n+inline size_t ShenandoahHeapRegion::get_live_data_words(ShenandoahMarkingContext* ctx, size_t index) const {\n+  assert(this->index() == index, \"Consistency: %zu != %zu\", this->index(), index);\n+  HeapWord* tams = ctx->top_at_mark_start(index);\n+  size_t words_above_tams = pointer_delta(top(), tams);\n+  size_t result = AtomicAccess::load(&_live_data) + words_above_tams;\n+  return result;\n@@ -173,2 +173,2 @@\n-inline bool ShenandoahHeapRegion::has_live() const {\n-  return get_live_data_words() != 0;\n+inline size_t ShenandoahHeapRegion::get_live_data_bytes(ShenandoahMarkingContext* ctx, size_t index) const {\n+  return get_live_data_words(ctx, index) * HeapWordSize;\n@@ -177,4 +177,7 @@\n-inline size_t ShenandoahHeapRegion::garbage() const {\n-  assert(used() >= get_live_data_bytes(),\n-         \"Live Data must be a subset of used() live: %zu used: %zu\",\n-         get_live_data_bytes(), used());\n+inline bool ShenandoahHeapRegion::has_marked() const {\n+  return AtomicAccess::load(&_live_data) != 0;\n+}\n+\n+inline bool ShenandoahHeapRegion::has_live(ShenandoahMarkingContext* ctx, size_t index) const {\n+  return get_live_data_words(ctx, index) != 0;\n+}\n@@ -182,1 +185,5 @@\n-  size_t result = used() - get_live_data_bytes();\n+inline size_t ShenandoahHeapRegion::garbage(ShenandoahMarkingContext* context, size_t index) const {\n+  assert(used() >= get_live_data_bytes(context, index),\n+         \"Live Data must be a subset of used() live: %zu used: %zu\",\n+         get_live_data_bytes(context, index), used());\n+  size_t result = used() - get_live_data_bytes(context, index);\n@@ -189,1 +196,1 @@\n-  assert(used_before_promote >= get_live_data_bytes(),\n+  assert(used_before_promote >= get_marked_data_bytes(),\n@@ -191,2 +198,5 @@\n-         get_live_data_bytes(), used_before_promote);\n-  size_t result = used_before_promote - get_live_data_bytes();\n+         get_marked_data_bytes(), used_before_promote);\n+  ShenandoahMarkingContext *ctx = ShenandoahHeap::heap()->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(this);\n+  size_t bytes_allocated_during_mark = pointer_delta(get_top_before_promote(), tams) * HeapWordSize;\n+  size_t result = used_before_promote - (get_marked_data_bytes() + bytes_allocated_during_mark);\n@@ -194,1 +204,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -60,15 +60,0 @@\n-    if (_ctx != nullptr) {\n-      \/\/ _ctx may be null when this closure is used to sync only the pin status\n-      \/\/ update the watermark of old regions. For old regions we cannot reset\n-      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n-      \/\/ old marking is complete.\n-\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-    }\n-\n@@ -84,1 +69,1 @@\n-    assert(!r->has_live(), \"Region %zu should have no live data\", r->index());\n+    assert(!r->has_live(ShenandoahHeap::heap()->marking_context(), r->index()), \"Region %zu should have no live data\", r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+        ShenandoahMarkingContext* context = heap->marking_context();\n@@ -123,6 +124,6 @@\n-          data |= ((100 * r->used() \/ rs)                & PERCENT_MASK) << USED_SHIFT;\n-          data |= ((100 * r->get_live_data_bytes() \/ rs) & PERCENT_MASK) << LIVE_SHIFT;\n-          data |= ((100 * r->get_tlab_allocs() \/ rs)     & PERCENT_MASK) << TLAB_SHIFT;\n-          data |= ((100 * r->get_gclab_allocs() \/ rs)    & PERCENT_MASK) << GCLAB_SHIFT;\n-          data |= ((100 * r->get_plab_allocs() \/ rs)     & PERCENT_MASK) << PLAB_SHIFT;\n-          data |= ((100 * r->get_shared_allocs() \/ rs)   & PERCENT_MASK) << SHARED_SHIFT;\n+          data |= ((100 * r->used() \/ rs)                          & PERCENT_MASK) << USED_SHIFT;\n+          data |= ((100 * r->get_live_data_bytes(context, i) \/ rs) & PERCENT_MASK) << LIVE_SHIFT;\n+          data |= ((100 * r->get_tlab_allocs() \/ rs)               & PERCENT_MASK) << TLAB_SHIFT;\n+          data |= ((100 * r->get_gclab_allocs() \/ rs)              & PERCENT_MASK) << GCLAB_SHIFT;\n+          data |= ((100 * r->get_plab_allocs() \/ rs)               & PERCENT_MASK) << PLAB_SHIFT;\n+          data |= ((100 * r->get_shared_allocs() \/ rs)             & PERCENT_MASK) << SHARED_SHIFT;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  inline HeapWord* top_at_mark_start(const size_t index) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+inline HeapWord* ShenandoahMarkingContext::top_at_mark_start(const size_t index) const {\n+  return _top_at_mark_starts_base[index];\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,3 +190,2 @@\n-          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live() ||\n-                (obj_reg->is_old() && _generation->is_young()),\n-                   \"Object must belong to region with live data\");\n+          check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live(ShenandoahHeap::heap()->marking_context(), obj_reg->index())\n+                || (obj_reg->is_old() && _generation->is_young()), \"Object must belong to region with live data\");\n@@ -370,0 +369,1 @@\n+  ShenandoahMarkingContext* _context;\n@@ -377,0 +377,1 @@\n+    _context = ShenandoahHeap::heap()->marking_context();\n@@ -380,0 +381,1 @@\n+    size_t index = r->index();\n@@ -384,1 +386,1 @@\n-      _garbage += _region_size_bytes - r->get_live_data_bytes();\n+      _garbage += _region_size_bytes - r->get_live_data_bytes(_context, index);\n@@ -392,1 +394,1 @@\n-        _garbage += _region_size_bytes - r->get_live_data_bytes();\n+        _garbage += _region_size_bytes - r->get_live_data_bytes(_context, index);\n@@ -401,1 +403,1 @@\n-        size_t bytes_garbage_in_region = bytes_used_in_region - r->get_live_data_bytes();\n+        size_t bytes_garbage_in_region = bytes_used_in_region - r->get_live_data_bytes(_context, index);\n@@ -538,0 +540,2 @@\n+    ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n+    size_t region_index = r->index();\n@@ -550,1 +554,1 @@\n-    verify(r, r->get_live_data_bytes() <= r->capacity(),\n+    verify(r, r->get_live_data_bytes(context, region_index) <= r->capacity(),\n@@ -553,1 +557,1 @@\n-    verify(r, r->garbage() <= r->capacity(),\n+    verify(r, r->garbage(context, region_index) <= r->capacity(),\n@@ -574,1 +578,1 @@\n-    verify(r, !r->is_empty() || !r->has_live(),\n+    verify(r, !r->is_empty() || !r->has_live(context, region_index),\n@@ -1020,0 +1024,1 @@\n+  ShenandoahMarkingContext* context = ShenandoahHeap::heap()->marking_context();\n@@ -1039,1 +1044,1 @@\n-      size_t reg_live = r->get_live_data_words();\n+      size_t reg_live = r->get_live_data_words(context, i);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    region->increase_live_data_alloc_words(live_bytes \/ HeapWordSize);\n+    region->increase_live_data_gc_words(live_bytes \/ HeapWordSize);\n@@ -110,1 +110,2 @@\n-    return region->garbage();\n+    ShenandoahMarkingContext* context = _heap->marking_context();\n+    return region->garbage(context, region->index());\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}