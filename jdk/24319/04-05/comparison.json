{"files":[{"patch":"@@ -326,0 +326,13 @@\n+void ShenandoahOldHeuristics::recalibrate_old_collection_candidates_live_memory() {\n+  size_t total_live_data;\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n+    ShenandoahHeapRegion* r = _region_data[i].get_region();\n+    size_t region_live = r->get_live_data_bytes();\n+    total_live_data += region_live;\n+    _region_data[i].update_livedata(region_live);\n+  }\n+  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n+                              compare_by_live);\n+  _live_bytes_in_unprocessed_candidates = total_live_data;\n+}\n+\n@@ -417,4 +430,0 @@\n-\n-#ifdef KELVIN_DEPRECATE\n-    r->capture_mixed_candidate_garbage();\n-#endif\n@@ -463,4 +472,0 @@\n-\n-#ifdef KELVIN_DEPRECATE\n-      r->capture_mixed_candidate_garbage();\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -134,0 +134,7 @@\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Recompute live data in candidates and re--sort the candidate regions in\n+  \/\/ order to first evacuate regions that have the smallest amount of live data.  These are easiest to evacuate\n+  \/\/ with least effort.  Doing these first allows us to more quickly replenish free memory with entirely empty regions.\n+  \/\/ Call this during final mark before adjusting the old-evacuation ratio.\n+  void recalibrate_old_collection_candidates_live_memory();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2564,0 +2564,4 @@\n+    ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+    ShenandoahOldHeuristics* old_heuristics = old_gen->heuristics();\n+\n+    old_heuristics->recalibrate_old_collection_candidates_live_memory();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,5 +374,0 @@\n-#ifdef KELVIN_DEPRECATE\n-  \/\/ Increase live data for newly allocated region\n-  inline void increase_live_data_alloc_words(size_t s);\n-#endif\n-\n@@ -396,6 +391,0 @@\n-#ifdef KELVIN_DEPRECATE\n-  inline size_t get_mixed_candidate_live_data_bytes() const;\n-  inline size_t get_mixed_candidate_live_data_words() const;\n-\n-  inline void capture_mixed_candidate_garbage();\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -131,6 +131,0 @@\n-#ifdef KELVIN_DEPRECATE\n-inline void ShenandoahHeapRegion::increase_live_data_alloc_words(size_t s) {\n-  internal_increase_live_data(s);\n-}\n-#endif\n-\n@@ -167,19 +161,0 @@\n-#ifdef KELVIN_DEPRECATE\n-inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_bytes() const {\n-  shenandoah_assert_safepoint();\n-  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n-  return used() - _mixed_candidate_garbage_words * HeapWordSize;\n-}\n-\n-inline size_t ShenandoahHeapRegion::get_mixed_candidate_live_data_words() const {\n-  shenandoah_assert_safepoint();\n-  assert(used() >= _mixed_candidate_garbage_words * HeapWordSize, \"used must exceed garbage\");\n-  return used() \/ HeapWordSize - _mixed_candidate_garbage_words;\n-}\n-\n-inline void ShenandoahHeapRegion::capture_mixed_candidate_garbage() {\n-  shenandoah_assert_safepoint();\n-  _mixed_candidate_garbage_words = garbage() \/ HeapWordSize;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -60,17 +60,0 @@\n-#ifdef KELVIN_DEPRECATE\n-    if (_ctx != nullptr) {\n-      \/\/ _ctx may be null when this closure is used to sync only the pin status\n-      \/\/ update the watermark of old regions. For old regions we cannot reset\n-      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n-      \/\/ old marking is complete.\n-\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-    }\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"}]}