{"files":[{"patch":"@@ -132,0 +132,7 @@\n+    inline void update_livedata(size_t live) {\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  sort_candidates_by_live();\n@@ -315,0 +316,22 @@\n+void ShenandoahOldHeuristics::sort_candidates_by_live() {\n+  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first, so we sort by live-data.\n+  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n+  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n+  \/\/ in old-gen.  Overwrite _live_bytes_in_unprocessed_candidates with most current data.\n+\n+  \/\/ Between consecutive mixed-evacuation cycles, the live data within each candidate region may change due to\n+  \/\/ promotions and old-gen evacuations.  Re-sort the candidate regions in order to first evacuate regions that have\n+  \/\/ the smallest amount of live data.  These are easiest to evacuate with least effort.  Doing these first allows\n+  \/\/ us to more quickly replenish free memory with empty regions.\n+  size_t total_live_data = 0;\n+  for (uint i = _next_old_collection_candidate; i < _last_old_collection_candidate; i++) {\n+    ShenandoahHeapRegion* r = _region_data[i].get_region();\n+    size_t region_live = r->get_live_data_bytes();\n+    total_live_data += region_live;\n+    _region_data[i].update_livedata(region_live);\n+  }\n+  QuickSort::sort<RegionData>(_region_data + _next_old_collection_candidate, unprocessed_old_collection_candidates(),\n+                              compare_by_live);\n+  _live_bytes_in_unprocessed_candidates = total_live_data;\n+}\n+\n@@ -374,6 +397,3 @@\n-  \/\/ Unlike young, we are more interested in efficiently packing OLD-gen than in reclaiming garbage first.  We sort by live-data.\n-  \/\/ Some regular regions may have been promoted in place with no garbage but also with very little live data.  When we \"compact\"\n-  \/\/ old-gen, we want to pack these underutilized regions together so we can have more unaffiliated (unfragmented) free regions\n-  \/\/ in old-gen.\n-\n-  QuickSort::sort<RegionData>(candidates, cand_idx, compare_by_live);\n+  _next_old_collection_candidate = 0;\n+  _last_old_collection_candidate = (uint)cand_idx;\n+  sort_candidates_by_live();\n@@ -390,1 +410,0 @@\n-  _last_old_collection_candidate = (uint)cand_idx;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -134,0 +134,4 @@\n+  \/\/ Sort candidates between _next_old_collection_candidate (inclusive) and _last_old_collection_candidate (exclusive)\n+  \/\/ by live data, updating _live_bytes_in_unprocessed_candidates to represent the amount of data remaining to be evacuated.\n+  void sort_candidates_by_live();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-    assert(!r->has_live(), \"Region %zu should have no live data\", r->index());\n+    assert(!r->has_marked(), \"Region %zu should have no marked data\", r->index());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -935,0 +935,1 @@\n+  ShenandoahMarkingContext* _mark_context;\n@@ -941,0 +942,1 @@\n+                                   _mark_context(_heap->marking_context()),\n@@ -993,1 +995,1 @@\n-    r->set_live_data(live);\n+    r->set_live_data_after_fullgc(live);\n@@ -1103,1 +1105,1 @@\n-      if (heap->is_bitmap_slice_committed(region) && !region->is_pinned() && region->has_live()) {\n+      if (heap->is_bitmap_slice_committed(region) && !region->is_pinned() && region->has_marked()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2558,0 +2558,3 @@\n+    ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+    ShenandoahOldHeuristics* old_heuristics = old_gen->heuristics();\n+    old_heuristics->sort_candidates_by_live();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  _mixed_candidate_garbage_words(0),\n@@ -384,1 +385,1 @@\n-void ShenandoahHeapRegion::set_live_data(size_t s) {\n+void ShenandoahHeapRegion::set_live_data_after_fullgc(size_t s) {\n@@ -386,1 +387,3 @@\n-  _live_data = (s >> LogHeapWordSize);\n+  ShenandoahMarkingContext* marking_context = ShenandoahHeap::heap()->marking_context();\n+  size_t words_allocated_above_tams = pointer_delta(top(), marking_context->top_at_mark_start(this));\n+  _live_data = (s >> LogHeapWordSize) - words_allocated_above_tams;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+  size_t _mixed_candidate_garbage_words;\n+\n@@ -370,4 +372,1 @@\n-  void set_live_data(size_t s);\n-\n-  \/\/ Increase live data for newly allocated region\n-  inline void increase_live_data_alloc_words(size_t s);\n+  void set_live_data_after_fullgc(size_t s);\n@@ -378,0 +377,2 @@\n+  inline bool has_marked() const;\n+\n@@ -379,0 +380,6 @@\n+\n+  \/\/ Returns bytes identified as live by most recently completed marking effort.  Can only be called during safepoints.\n+  inline size_t get_marked_data_bytes() const;\n+\n+  \/\/ Returns bytes identified as live by most recently completed marking effort, plus allocations above TAMS.\n+  \/\/ Can only be called during safepoints.\n@@ -380,0 +387,3 @@\n+\n+  \/\/ Returns words identified as live by most recently completed marking effort, plus allocations above TAMS.\n+  \/\/ Can only be called during safepoints.\n@@ -382,0 +392,2 @@\n+  \/\/ Returns garbage by calculating difference between used and get_live_data_words.  Can only be called at\n+  \/\/ safepoints. Allocations above TAMS are considered live.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,4 +132,0 @@\n-inline void ShenandoahHeapRegion::increase_live_data_alloc_words(size_t s) {\n-  internal_increase_live_data(s);\n-}\n-\n@@ -148,0 +144,4 @@\n+inline size_t ShenandoahHeapRegion::get_marked_data_bytes() const {\n+  return AtomicAccess::load(&_live_data) * HeapWordSize;\n+}\n+\n@@ -149,1 +149,4 @@\n-  return AtomicAccess::load(&_live_data);\n+  ShenandoahMarkingContext *ctx = ShenandoahHeap::heap()->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(this);\n+  size_t words_above_tams = pointer_delta(top(), tams);\n+  return AtomicAccess::load(&_live_data) + words_above_tams;\n@@ -156,0 +159,4 @@\n+inline bool ShenandoahHeapRegion::has_marked() const {\n+  return AtomicAccess::load(&_live_data) != 0;\n+}\n+\n@@ -164,1 +171,0 @@\n-\n@@ -172,1 +178,1 @@\n-  assert(used_before_promote >= get_live_data_bytes(),\n+  assert(used_before_promote >= get_marked_data_bytes(),\n@@ -174,2 +180,5 @@\n-         get_live_data_bytes(), used_before_promote);\n-  size_t result = used_before_promote - get_live_data_bytes();\n+         get_marked_data_bytes(), used_before_promote);\n+  ShenandoahMarkingContext *ctx = ShenandoahHeap::heap()->marking_context();\n+  HeapWord* tams = ctx->top_at_mark_start(this);\n+  size_t bytes_allocated_during_mark = pointer_delta(get_top_before_promote(), tams) * HeapWordSize;\n+  size_t result = used_before_promote - (get_marked_data_bytes() + bytes_allocated_during_mark);\n@@ -177,1 +186,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -60,15 +60,0 @@\n-    if (_ctx != nullptr) {\n-      \/\/ _ctx may be null when this closure is used to sync only the pin status\n-      \/\/ update the watermark of old regions. For old regions we cannot reset\n-      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n-      \/\/ old marking is complete.\n-\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    region->increase_live_data_alloc_words(live_bytes \/ HeapWordSize);\n+    region->increase_live_data_gc_words(live_bytes \/ HeapWordSize);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}