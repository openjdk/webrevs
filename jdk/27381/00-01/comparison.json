{"files":[{"patch":"@@ -127,1 +127,1 @@\n-\/\/ Basically, the contents of one OS page span several regions.\n+\/\/ Basically, the contents of one OS page spans several regions.\n@@ -167,42 +167,0 @@\n-  \/\/ Given increasing integers, applies the method OnNewRange(size_t range_start, size_t range_size)\n-  \/\/ in the constructor all ranges of consecutive indexes. Consecutive means that\n-  \/\/ the difference between integers is 1.\n-  \/\/ Call apply_last() to cover the last range.\n-  template <typename OnNewRange>\n-  class RangeApplicator {\n-    size_t const NoIndex = SIZE_MAX;\n-\n-    size_t _cur_start;\n-    size_t _cur_end;\n-\n-    OnNewRange _on_new_range;\n-\n-  public:\n-    RangeApplicator(OnNewRange on_new_range) : _cur_start(NoIndex), _cur_end(NoIndex), _on_new_range(on_new_range) { }\n-    ~RangeApplicator() {\n-      assert(_cur_start == NoIndex, \"must be, missing application of lambda\");\n-      assert(_cur_end == NoIndex, \"must be, missing application of lambda\");\n-    }\n-\n-    void next_value(size_t index) {\n-      assert(_cur_end == NoIndex || _cur_end < index, \"Given indexes must be ascending\");\n-\n-      if (_cur_start == NoIndex) {\n-        _cur_start = _cur_end = index;\n-      } else if (_cur_end + 1 != index) {\n-        _on_new_range(_cur_start, _cur_end - _cur_start + 1);\n-        _cur_start = _cur_end = index;\n-      } else {\n-        _cur_end = index;\n-      }\n-    }\n-\n-    void apply_last() {\n-      if (_cur_start != NoIndex) {\n-        assert(_cur_end != NoIndex, \"must be\");\n-        _on_new_range(_cur_start, _cur_end - _cur_start + 1);\n-        _cur_start = _cur_end = NoIndex;\n-      }\n-    }\n-  };\n-\n@@ -223,0 +181,15 @@\n+  size_t find_first_uncommitted(size_t page, size_t end) {\n+    assert(page < end, \"must be\");\n+    while (page < end && is_page_committed(page)) {\n+      page++;\n+    }\n+    return MIN2(page, end);\n+  }\n+\n+  size_t find_first_committed(size_t page, size_t end) {\n+    while (page < end && !is_page_committed(page)) {\n+      page++;\n+    }\n+    return MIN2(page, end);\n+  }\n+\n@@ -231,2 +204,2 @@\n-    size_t first_committed = NoPage;\n-    size_t num_committed = 0;\n+    size_t first_newly_committed = NoPage;\n+    size_t num_committed_pages = 0;\n@@ -234,2 +207,2 @@\n-    size_t start_page = region_idx_to_page_idx(start_idx);\n-    size_t end_page = region_idx_to_page_idx(region_limit - 1);\n+    size_t const start_page = region_idx_to_page_idx(start_idx);\n+    size_t const end_page = region_idx_to_page_idx(region_limit - 1) + 1;\n@@ -242,7 +215,0 @@\n-      auto commit_range = [&](size_t page_start, size_t size_in_pages) {\n-        if (!commit_pages(page_start, size_in_pages)) {\n-          all_zero_filled = false;\n-        }\n-      };\n-      RangeApplicator range(commit_range);\n-\n@@ -250,13 +216,12 @@\n-      for (size_t page = start_page; page <= end_page; page++) {\n-        if (!is_page_committed(page)) {\n-          \/\/ Page not committed.\n-          if (num_committed == 0) {\n-            first_committed = page;\n-          }\n-          num_committed++;\n-\n-          range.next_value(page);\n-        } else {\n-          \/\/ Page already committed.\n-          all_zero_filled = false;\n-        }\n+      log_debug(gc,ihop)(\"commit-regions start-region %u num_regions %zu start-page %zu end-page %zu\", start_idx, num_regions, start_page, end_page);\n+\n+      size_t uncommitted_l = find_first_uncommitted(start_page, end_page);\n+      size_t committed_r = find_first_committed(uncommitted_l + 1, end_page);\n+\n+      first_newly_committed = uncommitted_l;\n+      num_committed_pages = committed_r - uncommitted_l;\n+\n+      log_debug(gc,ihop)(\"uncommit-regions chunk page %zu to page %zu size %zu\", uncommitted_l, committed_r, num_committed_pages);\n+      if (num_committed_pages > 0 &&\n+          !commit_pages(first_newly_committed, num_committed_pages)) {\n+        all_zero_filled = false;\n@@ -264,1 +229,2 @@\n-      range.apply_last();\n+\n+      all_zero_filled &= (uncommitted_l == start_page) && (committed_r == end_page);\n@@ -271,2 +237,2 @@\n-    if (AlwaysPreTouch && num_committed > 0) {\n-      _storage.pretouch(first_committed, num_committed, pretouch_workers);\n+    if (AlwaysPreTouch && num_committed_pages > 0) {\n+      _storage.pretouch(first_newly_committed, num_committed_pages, pretouch_workers);\n@@ -284,7 +250,2 @@\n-    size_t start_page = region_idx_to_page_idx(start_idx);\n-    size_t end_page = region_idx_to_page_idx(region_limit - 1);\n-\n-    auto uncommit_range = [&](size_t page_start, size_t size_in_pages) {\n-      _storage.uncommit(page_start, size_in_pages);\n-    };\n-    RangeApplicator r(uncommit_range);\n+    size_t const start_page = region_idx_to_page_idx(start_idx);\n+    size_t const end_page = region_idx_to_page_idx(region_limit - 1) + 1;\n@@ -295,0 +256,3 @@\n+\n+    log_debug(gc,ihop)(\"uncommit-regions start-region %u num_regions %zu start-page %zu end-page %zu\", start_idx, num_regions, start_page, end_page);\n+\n@@ -299,7 +263,12 @@\n-    for (size_t page = start_page; page <= end_page; page++) {\n-      \/\/ We know all pages were committed before clearing the map. If the\n-      \/\/ the page is still marked as committed after the clear we should\n-      \/\/ not uncommit it.\n-      if (!is_page_committed(page)) {\n-        r.next_value(page);\n-      }\n+    \/\/ We know all pages were committed before clearing the map. If the\n+    \/\/ the page is still marked as committed after the clear we should\n+    \/\/ not uncommit it.\n+    size_t uncommitted_l = find_first_uncommitted(start_page, end_page);\n+    size_t committed_r = find_first_committed(uncommitted_l + 1, end_page);\n+\n+    size_t num_uncommitted_pages_found = committed_r - uncommitted_l;\n+\n+    log_debug(gc,ihop)(\"uncommit-regions chunk page %zu to page %zu size %zu\", uncommitted_l, committed_r, num_uncommitted_pages_found);\n+\n+    if (num_uncommitted_pages_found > 0) {\n+      _storage.uncommit(uncommitted_l, num_uncommitted_pages_found);\n@@ -307,1 +276,0 @@\n-    r.apply_last();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":53,"deletions":85,"binary":false,"changes":138,"status":"modified"}]}