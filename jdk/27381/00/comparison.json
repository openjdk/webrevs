{"files":[{"patch":"@@ -206,3 +206,1 @@\n-  if (!is_enabled()) {\n-    return;\n-  }\n+  assert(is_enabled(), \"must be, check before\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,2 @@\n-    if (_memory_tag == mtJavaHeap) {\n+\n+    if (should_distribute_across_numa_nodes()) {\n@@ -106,0 +107,1 @@\n+\n@@ -151,6 +153,10 @@\n-  void numa_request_on_node(size_t page_idx) {\n-    if (_memory_tag == mtJavaHeap) {\n-      uint region = (uint)(page_idx * _regions_per_page);\n-      void* address = _storage.page_start(page_idx);\n-      size_t size_in_bytes = _storage.page_size();\n-      G1NUMA::numa()->request_memory_on_node(address, size_in_bytes, region);\n+  bool commit_pages(size_t start_page, size_t size_in_pages) {\n+    bool result = _storage.commit(start_page, size_in_pages);\n+\n+    if (should_distribute_across_numa_nodes()) {\n+      for (size_t page = start_page; page < start_page + size_in_pages; page++) {\n+        uint region = checked_cast<uint>(page * _regions_per_page);\n+        void* address = _storage.page_start(page);\n+        size_t size_in_bytes = _storage.page_size();\n+        G1NUMA::numa()->request_memory_on_node(address, size_in_bytes, region);\n+      }\n@@ -158,0 +164,1 @@\n+    return result;\n@@ -160,0 +167,42 @@\n+  \/\/ Given increasing integers, applies the method OnNewRange(size_t range_start, size_t range_size)\n+  \/\/ in the constructor all ranges of consecutive indexes. Consecutive means that\n+  \/\/ the difference between integers is 1.\n+  \/\/ Call apply_last() to cover the last range.\n+  template <typename OnNewRange>\n+  class RangeApplicator {\n+    size_t const NoIndex = SIZE_MAX;\n+\n+    size_t _cur_start;\n+    size_t _cur_end;\n+\n+    OnNewRange _on_new_range;\n+\n+  public:\n+    RangeApplicator(OnNewRange on_new_range) : _cur_start(NoIndex), _cur_end(NoIndex), _on_new_range(on_new_range) { }\n+    ~RangeApplicator() {\n+      assert(_cur_start == NoIndex, \"must be, missing application of lambda\");\n+      assert(_cur_end == NoIndex, \"must be, missing application of lambda\");\n+    }\n+\n+    void next_value(size_t index) {\n+      assert(_cur_end == NoIndex || _cur_end < index, \"Given indexes must be ascending\");\n+\n+      if (_cur_start == NoIndex) {\n+        _cur_start = _cur_end = index;\n+      } else if (_cur_end + 1 != index) {\n+        _on_new_range(_cur_start, _cur_end - _cur_start + 1);\n+        _cur_start = _cur_end = index;\n+      } else {\n+        _cur_end = index;\n+      }\n+    }\n+\n+    void apply_last() {\n+      if (_cur_start != NoIndex) {\n+        assert(_cur_end != NoIndex, \"must be\");\n+        _on_new_range(_cur_start, _cur_end - _cur_start + 1);\n+        _cur_start = _cur_end = NoIndex;\n+      }\n+    }\n+  };\n+\n@@ -193,0 +242,7 @@\n+      auto commit_range = [&](size_t page_start, size_t size_in_pages) {\n+        if (!commit_pages(page_start, size_in_pages)) {\n+          all_zero_filled = false;\n+        }\n+      };\n+      RangeApplicator range(commit_range);\n+\n@@ -202,7 +258,1 @@\n-          if (!_storage.commit(page, 1)) {\n-            \/\/ Found dirty region during commit.\n-            all_zero_filled = false;\n-          }\n-\n-          \/\/ Move memory to correct NUMA node for the heap.\n-          numa_request_on_node(page);\n+          range.next_value(page);\n@@ -214,0 +264,1 @@\n+      range.apply_last();\n@@ -236,0 +287,5 @@\n+    auto uncommit_range = [&](size_t page_start, size_t size_in_pages) {\n+      _storage.uncommit(page_start, size_in_pages);\n+    };\n+    RangeApplicator r(uncommit_range);\n+\n@@ -248,1 +304,1 @@\n-        _storage.uncommit(page, 1);\n+        r.next_value(page);\n@@ -251,0 +307,1 @@\n+    r.apply_last();\n@@ -260,0 +317,4 @@\n+bool G1RegionToSpaceMapper::should_distribute_across_numa_nodes() const {\n+  return _memory_tag == mtJavaHeap && G1NUMA::numa()->is_enabled();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":76,"deletions":15,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+\n+  bool should_distribute_across_numa_nodes() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}