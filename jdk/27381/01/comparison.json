{"files":[{"patch":"@@ -206,3 +206,1 @@\n-  if (!is_enabled()) {\n-    return;\n-  }\n+  assert(is_enabled(), \"must be, check before\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,2 @@\n-    if (_memory_tag == mtJavaHeap) {\n+\n+    if (should_distribute_across_numa_nodes()) {\n@@ -106,0 +107,1 @@\n+\n@@ -125,1 +127,1 @@\n-\/\/ Basically, the contents of one OS page span several regions.\n+\/\/ Basically, the contents of one OS page spans several regions.\n@@ -151,6 +153,10 @@\n-  void numa_request_on_node(size_t page_idx) {\n-    if (_memory_tag == mtJavaHeap) {\n-      uint region = (uint)(page_idx * _regions_per_page);\n-      void* address = _storage.page_start(page_idx);\n-      size_t size_in_bytes = _storage.page_size();\n-      G1NUMA::numa()->request_memory_on_node(address, size_in_bytes, region);\n+  bool commit_pages(size_t start_page, size_t size_in_pages) {\n+    bool result = _storage.commit(start_page, size_in_pages);\n+\n+    if (should_distribute_across_numa_nodes()) {\n+      for (size_t page = start_page; page < start_page + size_in_pages; page++) {\n+        uint region = checked_cast<uint>(page * _regions_per_page);\n+        void* address = _storage.page_start(page);\n+        size_t size_in_bytes = _storage.page_size();\n+        G1NUMA::numa()->request_memory_on_node(address, size_in_bytes, region);\n+      }\n@@ -158,0 +164,1 @@\n+    return result;\n@@ -174,0 +181,15 @@\n+  size_t find_first_uncommitted(size_t page, size_t end) {\n+    assert(page < end, \"must be\");\n+    while (page < end && is_page_committed(page)) {\n+      page++;\n+    }\n+    return MIN2(page, end);\n+  }\n+\n+  size_t find_first_committed(size_t page, size_t end) {\n+    while (page < end && !is_page_committed(page)) {\n+      page++;\n+    }\n+    return MIN2(page, end);\n+  }\n+\n@@ -182,2 +204,2 @@\n-    size_t first_committed = NoPage;\n-    size_t num_committed = 0;\n+    size_t first_newly_committed = NoPage;\n+    size_t num_committed_pages = 0;\n@@ -185,2 +207,2 @@\n-    size_t start_page = region_idx_to_page_idx(start_idx);\n-    size_t end_page = region_idx_to_page_idx(region_limit - 1);\n+    size_t const start_page = region_idx_to_page_idx(start_idx);\n+    size_t const end_page = region_idx_to_page_idx(region_limit - 1) + 1;\n@@ -194,19 +216,12 @@\n-      for (size_t page = start_page; page <= end_page; page++) {\n-        if (!is_page_committed(page)) {\n-          \/\/ Page not committed.\n-          if (num_committed == 0) {\n-            first_committed = page;\n-          }\n-          num_committed++;\n-\n-          if (!_storage.commit(page, 1)) {\n-            \/\/ Found dirty region during commit.\n-            all_zero_filled = false;\n-          }\n-\n-          \/\/ Move memory to correct NUMA node for the heap.\n-          numa_request_on_node(page);\n-        } else {\n-          \/\/ Page already committed.\n-          all_zero_filled = false;\n-        }\n+      log_debug(gc,ihop)(\"commit-regions start-region %u num_regions %zu start-page %zu end-page %zu\", start_idx, num_regions, start_page, end_page);\n+\n+      size_t uncommitted_l = find_first_uncommitted(start_page, end_page);\n+      size_t committed_r = find_first_committed(uncommitted_l + 1, end_page);\n+\n+      first_newly_committed = uncommitted_l;\n+      num_committed_pages = committed_r - uncommitted_l;\n+\n+      log_debug(gc,ihop)(\"uncommit-regions chunk page %zu to page %zu size %zu\", uncommitted_l, committed_r, num_committed_pages);\n+      if (num_committed_pages > 0 &&\n+          !commit_pages(first_newly_committed, num_committed_pages)) {\n+        all_zero_filled = false;\n@@ -215,0 +230,2 @@\n+      all_zero_filled &= (uncommitted_l == start_page) && (committed_r == end_page);\n+\n@@ -220,2 +237,2 @@\n-    if (AlwaysPreTouch && num_committed > 0) {\n-      _storage.pretouch(first_committed, num_committed, pretouch_workers);\n+    if (AlwaysPreTouch && num_committed_pages > 0) {\n+      _storage.pretouch(first_newly_committed, num_committed_pages, pretouch_workers);\n@@ -233,2 +250,2 @@\n-    size_t start_page = region_idx_to_page_idx(start_idx);\n-    size_t end_page = region_idx_to_page_idx(region_limit - 1);\n+    size_t const start_page = region_idx_to_page_idx(start_idx);\n+    size_t const end_page = region_idx_to_page_idx(region_limit - 1) + 1;\n@@ -239,0 +256,3 @@\n+\n+    log_debug(gc,ihop)(\"uncommit-regions start-region %u num_regions %zu start-page %zu end-page %zu\", start_idx, num_regions, start_page, end_page);\n+\n@@ -243,7 +263,12 @@\n-    for (size_t page = start_page; page <= end_page; page++) {\n-      \/\/ We know all pages were committed before clearing the map. If the\n-      \/\/ the page is still marked as committed after the clear we should\n-      \/\/ not uncommit it.\n-      if (!is_page_committed(page)) {\n-        _storage.uncommit(page, 1);\n-      }\n+    \/\/ We know all pages were committed before clearing the map. If the\n+    \/\/ the page is still marked as committed after the clear we should\n+    \/\/ not uncommit it.\n+    size_t uncommitted_l = find_first_uncommitted(start_page, end_page);\n+    size_t committed_r = find_first_committed(uncommitted_l + 1, end_page);\n+\n+    size_t num_uncommitted_pages_found = committed_r - uncommitted_l;\n+\n+    log_debug(gc,ihop)(\"uncommit-regions chunk page %zu to page %zu size %zu\", uncommitted_l, committed_r, num_uncommitted_pages_found);\n+\n+    if (num_uncommitted_pages_found > 0) {\n+      _storage.uncommit(uncommitted_l, num_uncommitted_pages_found);\n@@ -260,0 +285,4 @@\n+bool G1RegionToSpaceMapper::should_distribute_across_numa_nodes() const {\n+  return _memory_tag == mtJavaHeap && G1NUMA::numa()->is_enabled();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":71,"deletions":42,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+\n+  bool should_distribute_across_numa_nodes() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}