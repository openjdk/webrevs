{"files":[{"patch":"@@ -636,0 +636,3 @@\n+  develop(bool, VerifyNoNewIrreducibleLoops, false,                         \\\n+          \"Verify that no new irreducible loops are created after parsing\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -442,4 +442,7 @@\n-#ifdef ASSERT\n-void RegionNode::verify_can_be_irreducible_entry() const {\n-  assert(loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry, \"must be marked irreducible\");\n-  assert(!is_Loop(), \"LoopNode cannot be irreducible loop entry\");\n+\/\/ A Region can only be an irreducible entry if:\n+\/\/ - It is marked as \"maybe irreducible entry\". Any other loop status would guarantee\n+\/\/   that it is never an irreducible loop entry.\n+\/\/ - It is not a LoopNode, those are guaranteed to be reducible loop entries.\n+bool RegionNode::can_be_irreducible_entry() const {\n+  return loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry &&\n+         !is_Loop();\n@@ -447,1 +450,0 @@\n-#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  DEBUG_ONLY(void verify_can_be_irreducible_entry() const;)\n+  bool can_be_irreducible_entry() const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5634,1 +5634,6 @@\n-      DEBUG_ONLY(secondary_entry->verify_can_be_irreducible_entry();)\n+\n+      if (!secondary_entry->can_be_irreducible_entry()) {\n+        assert(!VerifyNoNewIrreducibleLoops, \"A new irreducible loop was created after parsing.\");\n+        C->record_method_not_compilable(\"A new irreducible loop was created after parsing.\");\n+        return pre_order;\n+      }\n@@ -5641,1 +5646,5 @@\n-        DEBUG_ONLY(head->verify_can_be_irreducible_entry();)\n+        if (!head->can_be_irreducible_entry()) {\n+          assert(!VerifyNoNewIrreducibleLoops, \"A new irreducible loop was created after parsing.\");\n+          C->record_method_not_compilable(\"A new irreducible loop was created after parsing.\");\n+          return pre_order;\n+        }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8348572\n+ * @summary Tests where new irreducible loop is introduced by split_if.\n+ *\n+ * @run driver compiler.loopopts.TestSplitIfNewIrreducibleLoop\n+ *\n+ * @run main\/othervm -Xcomp -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TestSplitIfNewIrreducibleLoop::test\n+ *                   compiler.loopopts.TestSplitIfNewIrreducibleLoop\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestSplitIfNewIrreducibleLoop {\n+\n+    static class A {\n+        public A parent;\n+    }\n+\n+    static class B extends A {}\n+\n+    public static void main(String[] args) {\n+        \/\/ Instanciate one each: classes are loaded.\n+        A a = new A();\n+        B b = new B();\n+        test(b);\n+    }\n+\n+    static int test(A parent) {\n+        do {\n+            if (parent instanceof B b) { return 1; }\n+            if (parent != null) { parent = parent.parent; }\n+            if (parent == null) { return 0; }\n+        } while (true);\n+    }\n+\n+    \/\/ Before split_if it looks like this (the instanceof check has already been partial peeled):\n+    \/\/\n+    \/\/ if (parent instanceof B b) { return 1; }\n+    \/\/ do {\n+    \/\/     if (parent != null) { parent = parent.parent; }\n+    \/\/     if (parent == null) { return 0; }\n+    \/\/     if (parent instanceof B b) { return 1; }\n+    \/\/ } while (true);\n+    \/\/\n+    \/\/\n+    \/\/ Now, we want to split_if the first if in the loop body, like this:\n+    \/\/\n+    \/\/ if (parent instanceof B b) { return 1; }\n+    \/\/ if (parent != null) { goto LOOP2; } else { goto LOOP1; }\n+    \/\/ do {\n+    \/\/     :LOOP1\n+    \/\/     parent = parent.parent;\n+    \/\/     :LOOP2\n+    \/\/     if (parent == null) { return 0; }\n+    \/\/     if (parent instanceof B b) { return 1; }\n+    \/\/     if (parent != null) { goto LOOP2; } else { goto LOOP1; }\n+    \/\/ } while (true);\n+    \/\/\n+    \/\/ As the comment in ifnode.cpp \/ split_if says: we know that on the backedge\n+    \/\/ \"parent\" cannot be null, and so we would be able to split the if through\n+    \/\/ the region, and on the backedge it would constant fold away, and we would\n+    \/\/ only have to check the split if in the loop entry.\n+    \/\/\n+    \/\/ Problem: we have introduced an irreducible loop!\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSplitIfNewIrreducibleLoop.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}