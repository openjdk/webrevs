{"files":[{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.Opcode;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +39,1 @@\n+import java.lang.reflect.Modifier;\n@@ -40,0 +46,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -61,3 +69,3 @@\n-    private static final MethodHandle OBJECTS_EQUALS;\n-    private static final MethodHandle OBJECTS_HASHCODE;\n-    private static final MethodHandle OBJECTS_TOSTRING;\n+    private static final MethodHandle IS_NULL;\n+    private static final MethodHandle IS_ARG0_NULL;\n+    private static final MethodHandle IS_ARG1_NULL;\n@@ -66,0 +74,2 @@\n+    private static final MethodType MT_OBJECT_BOOLEAN = MethodType.methodType(boolean.class, Object.class);\n+    private static final MethodType MT_INT = MethodType.methodType(int.class);\n@@ -69,1 +79,0 @@\n-    private static final HashMap<Class<?>, MethodHandle> primitiveToString = new HashMap<>();\n@@ -79,6 +88,6 @@\n-            OBJECTS_EQUALS = publicLookup.findStatic(Objects.class, \"equals\",\n-                                                     MethodType.methodType(boolean.class, Object.class, Object.class));\n-            OBJECTS_HASHCODE = publicLookup.findStatic(Objects.class, \"hashCode\",\n-                                                       MethodType.methodType(int.class, Object.class));\n-            OBJECTS_TOSTRING = publicLookup.findStatic(Objects.class, \"toString\",\n-                                                       MethodType.methodType(String.class, Object.class));\n+\n+            var objectsIsNull = publicLookup.findStatic(Objects.class, \"isNull\",\n+                                                        MethodType.methodType(boolean.class, Object.class));\n+            IS_NULL = objectsIsNull;\n+            IS_ARG0_NULL = MethodHandles.dropArguments(objectsIsNull, 1, Object.class);\n+            IS_ARG1_NULL = MethodHandles.dropArguments(objectsIsNull, 0, Object.class);\n@@ -124,17 +133,0 @@\n-\n-            primitiveToString.put(byte.class, lookup.findStatic(Byte.class, \"toString\",\n-                                                                MethodType.methodType(String.class, byte.class)));\n-            primitiveToString.put(short.class, lookup.findStatic(Short.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, short.class)));\n-            primitiveToString.put(char.class, lookup.findStatic(Character.class, \"toString\",\n-                                                                MethodType.methodType(String.class, char.class)));\n-            primitiveToString.put(int.class, lookup.findStatic(Integer.class, \"toString\",\n-                                                               MethodType.methodType(String.class, int.class)));\n-            primitiveToString.put(long.class, lookup.findStatic(Long.class, \"toString\",\n-                                                                MethodType.methodType(String.class, long.class)));\n-            primitiveToString.put(float.class, lookup.findStatic(Float.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, float.class)));\n-            primitiveToString.put(double.class, lookup.findStatic(Double.class, \"toString\",\n-                                                                  MethodType.methodType(String.class, double.class)));\n-            primitiveToString.put(boolean.class, lookup.findStatic(Boolean.class, \"toString\",\n-                                                                   MethodType.methodType(String.class, boolean.class)));\n@@ -162,4 +154,7 @@\n-    private static MethodHandle equalator(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveEquals.get(clazz)\n-                : OBJECTS_EQUALS.asType(MethodType.methodType(boolean.class, clazz, clazz)));\n+    private static MethodHandle equalator(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveEquals.get(clazz);\n+        MethodType mt = MethodType.methodType(boolean.class, clazz, clazz);\n+        return MethodHandles.guardWithTest(IS_ARG0_NULL.asType(mt),\n+                                           IS_ARG1_NULL.asType(mt),\n+                                           lookup.findVirtual(clazz, \"equals\", MT_OBJECT_BOOLEAN).asType(mt));\n@@ -169,4 +164,7 @@\n-    private static MethodHandle hasher(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveHashers.get(clazz)\n-                : OBJECTS_HASHCODE.asType(MethodType.methodType(int.class, clazz)));\n+    private static MethodHandle hasher(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveHashers.get(clazz);\n+        MethodType mt = MethodType.methodType(int.class, clazz);\n+        return MethodHandles.guardWithTest(IS_NULL.asType(MethodType.methodType(boolean.class, clazz)),\n+                                           MethodHandles.dropArguments(MethodHandles.zero(int.class), 0, clazz),\n+                                           lookup.findVirtual(clazz, \"hashCode\", MT_INT).asType(mt));\n@@ -175,5 +173,15 @@\n-    \/** Get the stringifier for a value of a given type *\/\n-    private static MethodHandle stringifier(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveToString.get(clazz)\n-                : OBJECTS_TOSTRING.asType(MethodType.methodType(String.class, clazz)));\n+    \/\/ If this type must be a monomorphic receiver, that is, one that has no\n+    \/\/ subtypes in the JVM.  For example, Object-typed fields may have a more\n+    \/\/ specific one type at runtime and optimized so.\n+    private static boolean isMonomorphic(Class<?> type) {\n+        \/\/ Includes primitives and final classes\n+        return Modifier.isFinal(type.getModifiers()) && !type.isArray();\n+    }\n+\n+    private static String specializerClassName(Class<?> targetClass, String kind) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$\" + kind + \"Specializer\";\n@@ -188,2 +196,2 @@\n-    private static MethodHandle makeEquals(Class<?> receiverClass,\n-                                          List<MethodHandle> getters) {\n+    private static MethodHandle makeEquals(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                           List<MethodHandle> getters) throws Throwable {\n@@ -198,2 +206,64 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle equalator = equalator(getter.type().returnType()); \/\/ (TT)Z\n+        int size = getters.size();\n+        MethodHandle[] equalators = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                equalators[i] = equalator(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.equals,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Equalator\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (equalators[i] == null) {\n+                        var name = \"equalator\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_boolean, typeDesc, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            var fail = cob.newLabel();\n+                            cob.aload(0)\n+                               .ifnonnull(nonNullPath)\n+                               .aload(1)\n+                               .ifnonnull(fail)\n+                               .iconst_1() \/\/ arg0 null, arg1 null\n+                               .ireturn()\n+                               .labelBinding(fail)\n+                               .iconst_0() \/\/ arg0 null, arg1 non-null\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.equals(arg1) - bytecode subject to customized profiling\n+                               .aload(1)\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MethodTypeDesc.of(CD_boolean, CD_Object), isInterface)\n+                               .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (equalators[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    equalators[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(boolean.class, type, type));\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle equalator = equalators[i]; \/\/ (TT)Z\n@@ -215,2 +285,2 @@\n-    private static MethodHandle makeHashCode(Class<?> receiverClass,\n-                                            List<MethodHandle> getters) {\n+    private static MethodHandle makeHashCode(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                             List<MethodHandle> getters) throws Throwable {\n@@ -219,0 +289,54 @@\n+        int size = getters.size();\n+        MethodHandle[] hashers = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                hashers[i] = hasher(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.hashCode,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Hasher\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (hashers[i] == null) {\n+                        var name = \"hasher\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_int, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            cob.aload(0)\n+                                    .ifnonnull(nonNullPath)\n+                                    .iconst_0() \/\/ null hash is 0\n+                                    .ireturn()\n+                                    .labelBinding(nonNullPath)\n+                                    .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n+                                    .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MethodTypeDesc.of(CD_int), isInterface)\n+                                    .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (hashers[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    hashers[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(int.class, type));\n+                }\n+            }\n+        }\n+\n@@ -220,2 +344,3 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle hasher = hasher(getter.type().returnType()); \/\/ (T)I\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle hasher = hashers[i]; \/\/ (T)I\n@@ -406,1 +531,1 @@\n-                yield makeEquals(recordClass, getterList);\n+                yield makeEquals(lookup, recordClass, getterList);\n@@ -411,1 +536,1 @@\n-                yield makeHashCode(recordClass, getterList);\n+                yield makeHashCode(lookup, recordClass, getterList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":175,"deletions":50,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/\/\/ Tests the generated equals and hashCode for records.\n+\/\/\/ There are 3 types of methods:\n+\/\/\/  - distinct: distinct sites for type profiling\n+\/\/\/  - polluted: megamorphic site that blocks type profiling\n+\/\/\/  - generated: actual body generated by ObjectMethods::bootstrap\n+\/\/\/ The result of generated compared to the other two shows whether the\n+\/\/\/ generated code could perform type profiling.\n+@Fork(3)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class RecordMethodsBenchmark {\n+\n+    record One(int a) {}\n+\n+    @State(Scope.Thread)\n+    public static class BenchmarkState {\n+        Key k1 = new Key(new One(1), \"a\");\n+        Key k2 = new Key(new One(1), new String(\"a\"));\n+    }\n+\n+    @Benchmark\n+    public int hashCodeDistinct(BenchmarkState state) {\n+        return state.k1.hashCodeDistinct();\n+    }\n+\n+    @Benchmark\n+    public int hashCodePolluted(BenchmarkState state) {\n+        return state.k1.hashCodePolluted();\n+    }\n+\n+    @Benchmark\n+    public int hashCodeGenerated(BenchmarkState state) {\n+        return state.k1.hashCode();\n+    }\n+\n+    @Benchmark\n+    public boolean equalsDistinct(BenchmarkState state) {\n+        return state.k1.equalsDistinct(state.k2);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsPolluted(BenchmarkState state) {\n+        return state.k1.equalsPolluted(state.k2);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsGenerated(BenchmarkState state) {\n+        return state.k1.equals(state.k2);\n+    }\n+\n+    \/\/\/ A key object.\n+    \/\/\/\n+    \/\/\/ Having both field as Object pollutes Object.equals for record object\n+    \/\/\/ method MH tree.  We must verify the leaf Object.equals calls don't\n+    \/\/\/ share the same profile in generated code.\n+    record Key(Object key1, Object key2) {\n+        \/\/\/ A hashCode method which has distinct hashCode invocations\n+        \/\/\/ in bytecode for each field for type profiling.\n+        public int hashCodeDistinct() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + ((key1 == null) ? 0 : key1.hashCode());\n+            result = prime * result + ((key2 == null) ? 0 : key2.hashCode());\n+            return result;\n+        }\n+\n+        \/\/\/ A hashCode method which uses a megamorphic polluted\n+        \/\/\/ Object.hashCode virtual invocation in Objects.hashCode.\n+        public int hashCodePolluted() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + Objects.hashCode(key1);\n+            result = prime * result + Objects.hashCode(key2);\n+            return result;\n+        }\n+\n+        \/\/\/ An equals method which has distinct equals invocations\n+        \/\/\/ in bytecode for each field for type profiling.\n+        public boolean equalsDistinct(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Key other = (Key) obj;\n+            if (key1 == null) {\n+                if (other.key1 != null)\n+                    return false;\n+            }\n+            else if (!key1.equals(other.key1))\n+                return false;\n+            if (key2 == null) {\n+                if (other.key2 != null)\n+                    return false;\n+            }\n+            else if (!key2.equals(other.key2))\n+                return false;\n+            return true;\n+        }\n+\n+        \/\/\/ An equals method which uses a megamorphic polluted\n+        \/\/\/ Object.equals virtual invocation in Objects.equals.\n+        public boolean equalsPolluted(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Key other = (Key) obj;\n+            return Objects.equals(key1, other.key1) && Objects.equals(key2, other.key2);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/RecordMethodsBenchmark.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}