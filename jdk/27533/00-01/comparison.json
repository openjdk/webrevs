{"files":[{"patch":"@@ -76,0 +76,2 @@\n+    private static final MethodTypeDesc MTD_OBJECT_BOOLEAN = MethodTypeDesc.of(CD_boolean, CD_Object);\n+    private static final MethodTypeDesc MTD_INT = MethodTypeDesc.of(CD_int);\n@@ -175,1 +177,1 @@\n-    \/\/ specific one type at runtime and optimized so.\n+    \/\/ specific one type at runtime and thus need optimizations.\n@@ -177,1 +179,2 @@\n-        \/\/ Includes primitives and final classes\n+        \/\/ Includes primitives and final classes, but not arrays.\n+        \/\/ All array classes are reported to be final, but Object[] can have subtypes like String[]\n@@ -250,1 +253,1 @@\n-                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MethodTypeDesc.of(CD_boolean, CD_Object), isInterface)\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MTD_OBJECT_BOOLEAN, isInterface)\n@@ -321,7 +324,7 @@\n-                                    .ifnonnull(nonNullPath)\n-                                    .iconst_0() \/\/ null hash is 0\n-                                    .ireturn()\n-                                    .labelBinding(nonNullPath)\n-                                    .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n-                                    .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MethodTypeDesc.of(CD_int), isInterface)\n-                                    .ireturn();\n+                               .ifnonnull(nonNullPath)\n+                               .iconst_0() \/\/ null hash is 0\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MTD_INT, isInterface)\n+                               .ireturn();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/\/ There are 3 types of methods:\n+\/\/\/ There are 4 types of methods:\n@@ -44,2 +44,4 @@\n-\/\/\/ The result of generated compared to the other two shows whether the\n-\/\/\/ generated code could perform type profiling.\n+\/\/\/  - specialized: generated body for non-extensible types\n+\/\/\/ The result of generated compared to the other distinct\/polluted shows\n+\/\/\/ whether the generated code could perform type profiling.\n+\/\/\/ Specialized is the result of distinct without trap, should be even faster.\n@@ -59,0 +61,2 @@\n+        SpecializedKey sk1 = new SpecializedKey(new One(1), \"a\");\n+        SpecializedKey sk2 = new SpecializedKey(new One(1), new String(\"a\"));\n@@ -76,0 +80,5 @@\n+    @Benchmark\n+    public int hashCodeSpecial(BenchmarkState state) {\n+        return state.sk1.hashCode();\n+    }\n+\n@@ -91,0 +100,5 @@\n+    @Benchmark\n+    public boolean equalsSpecial(BenchmarkState state) {\n+        return state.sk1.equals(state.sk2);\n+    }\n+\n@@ -155,1 +169,3 @@\n-}\n\\ No newline at end of file\n+\n+    record SpecializedKey(One key1, String key2) {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/RecordMethodsBenchmark.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"}]}