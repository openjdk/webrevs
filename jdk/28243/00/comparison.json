{"files":[{"patch":"@@ -1645,1 +1645,1 @@\n-    private static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {\n+    static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -496,0 +496,12 @@\n+    @SuppressWarnings({\"unchecked\"})\n+    private void putMapEntries(HashMap<? extends K, ? extends V> src, boolean evict) {\n+        if (src.table != null) {\n+            for (Node<? extends K, ? extends V> node : src.table) {\n+                while (node != null) {\n+                    putVal(node.hash, node.key, node.value, false, evict);\n+                    node = node.next;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -504,0 +516,5 @@\n+        if (m.getClass() == Collections.UnmodifiableMap.class) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<? extends K, ? extends V> unwrapped = ((Collections.UnmodifiableMap<K, V>) m).m;\n+            m = unwrapped;\n+        }\n@@ -520,4 +537,10 @@\n-            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n-                K key = e.getKey();\n-                V value = e.getValue();\n-                putVal(hash(key), key, value, false, evict);\n+            if (m.getClass() == HashMap.class) {\n+                @SuppressWarnings(\"unchecked\")\n+                HashMap<K, V> hashMap = (HashMap<K, V>) m;\n+                putMapEntries(hashMap, evict);\n+            } else {\n+                for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n+                    K key = e.getKey();\n+                    V value = e.getValue();\n+                    putVal(hash(key), key, value, false, evict);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+        testImmutableMap(unmodifiableMap(new HashMap<>(Map.of(1, 101, 2, 202, 3, 303))));\n@@ -160,0 +161,2 @@\n+        testHashMapPutAll();\n+\n@@ -422,0 +425,27 @@\n+    \/\/ Test HashMap.putAll() with various source map types\n+    private static void testHashMapPutAll() {\n+        Map<Integer,Integer> testData = Map.of(1, 101, 2, 202, 3, 303);\n+        HashMap<Integer,Integer> target = new HashMap<>();\n+\n+        target.putAll(new TreeMap<>(testData));\n+        check(target.equals(testData));\n+\n+        target.clear();\n+        target.putAll(new ConcurrentHashMap<>(testData));\n+        check(target.equals(testData));\n+\n+        target.clear();\n+        target.putAll(unmodifiableMap(new HashMap<>(testData)));\n+        check(target.equals(testData));\n+\n+        target.clear();\n+        target.putAll(unmodifiableMap(new TreeMap<>(testData)));\n+        check(target.equals(testData));\n+\n+        \/\/ Test empty HashMap putAll (regression test for NPE)\n+        target.clear();\n+        HashMap<Integer,Integer> emptySource = new HashMap<>();\n+        target.putAll(emptySource);\n+        check(target.isEmpty());\n+    }\n+\n@@ -718,0 +748,5 @@\n+\n+            \/\/ Test putAll from immutable map to HashMap\n+            HashMap<Integer,Integer> target = new HashMap<>();\n+            target.putAll(m);\n+            check(target.equals(m));\n@@ -1426,0 +1461,10 @@\n+\n+                \/\/ Test putAll with HashMap\n+                HashMap<Integer,Integer> source = new HashMap<>();\n+                source.put(1, 101);\n+                source.put(2, 202);\n+                source.put(3, 303);\n+\n+                m.clear();\n+                m.putAll(source);\n+                check(m.equals(source));\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark demonstrating performance impact of polymorphic call sites on HashMap.<init>(Map).\n+ *\n+ * This test shows that manual inlining of HashMap construction can significantly outperform\n+ * the built-in HashMap(Map) constructor when the constructor call site becomes polymorphic.\n+ *\n+ * The setup ensures polymorphic call sites by using HashMap, TreeMap, and LinkedHashMap\n+ * in both the constructor and manual iteration patterns before benchmarking begins.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgs = {\"-XX:+UseParallelGC\", \"-Xmx3g\"})\n+public class HashMapConstructorBenchmark {\n+\n+    private static final int POISON_ITERATIONS = 40000;\n+    private static final double CAPACITY_FACTOR = 1.35; \/\/ Account for 0.75 load factor\n+\n+    @Param({\"0\", \"5\", \"25\"})\n+    private int mapSize;\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean poisonCallSites;\n+\n+    @Param({\"HashMap\", \"TreeMap\", \"ConcurrentHashMap\", \"UnmodifiableMap(HashMap)\", \"UnmodifiableMap(TreeMap)\"})\n+    private String inputType;\n+\n+    private HashMap<String, Integer> inputHashMap;\n+    private TreeMap<String, Integer> inputTreeMap;\n+    private LinkedHashMap<String, Integer> inputLinkedHashMap;\n+    private ConcurrentHashMap<String, Integer> inputConcurrentHashMap;\n+    private WeakHashMap<String, Integer> inputWeakHashMap;\n+    private Map<String, Integer> inputSynchronizedMap;\n+    private Map<String, Integer> inputUnmodifiableMap;\n+    private Map<String, Integer> inputUnmodifiableTreeMap;\n+\n+    private Map<String, Integer> sourceMap;\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        \/\/ Create test data with identical contents\n+        inputHashMap = new HashMap<>();\n+        inputTreeMap = new TreeMap<>();\n+        inputLinkedHashMap = new LinkedHashMap<>();\n+        inputConcurrentHashMap = new ConcurrentHashMap<>();\n+        inputWeakHashMap = new WeakHashMap<>();\n+\n+        for (int i = 0; i < mapSize; i++) {\n+            String key = \"key\" + i;\n+            Integer value = i;\n+            inputHashMap.put(key, value);\n+            inputTreeMap.put(key, value);\n+            inputLinkedHashMap.put(key, value);\n+            inputConcurrentHashMap.put(key, value);\n+            inputWeakHashMap.put(key, value);\n+        }\n+\n+        \/\/ Create wrapper maps for poisoning\n+        inputSynchronizedMap = Collections.synchronizedMap(new HashMap<>(inputHashMap));\n+        inputUnmodifiableMap = Collections.unmodifiableMap(new HashMap<>(inputHashMap));\n+        inputUnmodifiableTreeMap = Collections.unmodifiableMap(new TreeMap<>(inputTreeMap));\n+\n+        \/\/ Set source map based on inputType parameter\n+        sourceMap = switch (inputType) {\n+            case \"HashMap\" -> inputHashMap;\n+            case \"TreeMap\" -> inputTreeMap;\n+            case \"ConcurrentHashMap\" -> inputConcurrentHashMap;\n+            case \"UnmodifiableMap(HashMap)\" -> inputUnmodifiableMap;\n+            case \"UnmodifiableMap(TreeMap)\" -> inputUnmodifiableTreeMap;\n+            default -> throw new IllegalArgumentException(\"Unknown inputType: \" + inputType);\n+        };\n+\n+        if (poisonCallSites) {\n+            poisonCallSites();\n+        }\n+    }\n+\n+    private void poisonCallSites() {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Integer>[] sources = new Map[] { inputHashMap, inputTreeMap, inputLinkedHashMap,\n+                inputConcurrentHashMap, inputWeakHashMap };\n+\n+        \/\/ Poison HashMap.<init>(Map) call site\n+        for (int i = 0; i < POISON_ITERATIONS; i++) {\n+            Map<String, Integer> source = sources[i % sources.length];\n+            HashMap<String, Integer> temp = new HashMap<>(source);\n+            if (temp.size() != mapSize)\n+                throw new RuntimeException();\n+        }\n+\n+        \/\/ Poison entrySet iteration call sites\n+        for (int i = 0; i < POISON_ITERATIONS; i++) {\n+            Map<String, Integer> source = sources[i % sources.length];\n+            HashMap<String, Integer> temp = new HashMap<>(source.size());\n+            for (Map.Entry<String, Integer> entry : source.entrySet()) {\n+                temp.put(entry.getKey(), entry.getValue());\n+            }\n+            if (temp.size() != mapSize)\n+                throw new RuntimeException();\n+        }\n+\n+        \/\/ Poison UnmodifiableMap call sites\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Integer>[] umSources = new Map[]{\n+            Collections.unmodifiableMap(inputHashMap),\n+            Collections.unmodifiableMap(inputTreeMap),\n+            Collections.unmodifiableMap(inputLinkedHashMap),\n+            Collections.unmodifiableMap(inputConcurrentHashMap),\n+            Collections.unmodifiableMap(inputWeakHashMap)\n+        };\n+\n+        for (int i = 0; i < POISON_ITERATIONS; i++) {\n+            Map<String, Integer> source = umSources[i % umSources.length];\n+            HashMap<String, Integer> temp = new HashMap<>(source);\n+            if (temp.size() != mapSize)\n+                throw new RuntimeException();\n+        }\n+\n+        for (int i = 0; i < POISON_ITERATIONS; i++) {\n+            Map<String, Integer> source = umSources[i % umSources.length];\n+            HashMap<String, Integer> temp = new HashMap<>(source.size());\n+            for (Map.Entry<String, Integer> entry : source.entrySet()) {\n+                temp.put(entry.getKey(), entry.getValue());\n+            }\n+            if (temp.size() != mapSize) throw new RuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Benchmark using HashMap's built-in constructor that takes a Map parameter.\n+     * This approach suffers from polymorphic call site overhead.\n+     *\/\n+    @Benchmark\n+    public HashMap<String, Integer> hashMapConstructor() {\n+        return new HashMap<>(sourceMap);\n+    }\n+\n+    \/**\n+     * Benchmark using manual iteration over entrySet with individual put() calls.\n+     * This approach bypasses bulk operations and their polymorphic call sites.\n+     *\/\n+    \/*\n+    @Benchmark\n+    public HashMap<String, Integer> manualEntrySetLoop() {\n+        HashMap<String, Integer> result = new HashMap<>();\n+        for (Map.Entry<String, Integer> entry : sourceMap.entrySet()) {\n+            result.put(entry.getKey(), entry.getValue());\n+        }\n+        return result;\n+    }\n+    *\/\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HashMapConstructorBenchmark.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}