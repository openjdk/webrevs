{"files":[{"patch":"@@ -426,0 +426,6 @@\n+    \/*\n+     * If a similar query is ever added to javax.lang.model, use that instead.\n+     *\/\n+    public static boolean isImplicitlyDeclaredClass(Element e) {\n+        return e instanceof ClassSymbol c && c.isImplicit();\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-                } else if (!isOverridingMethod && !isSynthetic() && !isAnonymous() && !isRecordComponentOrField()) {\n+                } else if (!isOverridingMethod && !isSynthetic() && !isAnonymous() && !isRecordComponentOrField()\n+                        && !isImplicitlyDeclaredClass(env.currPath.getLeaf())) {\n@@ -1278,1 +1279,1 @@\n-            case CLASS -> true;\n+            case CLASS -> !isImplicitlyDeclaredClass(p.getLeaf());\n@@ -1283,0 +1284,9 @@\n+    \/*\n+     * If a similar query is ever added to com.sun.source.tree, use that instead.\n+     *\/\n+    private boolean isImplicitlyDeclaredClass(Tree t) {\n+        return t.getKind() == Tree.Kind.CLASS\n+                && t instanceof com.sun.tools.javac.tree.JCTree.JCClassDecl classDecl\n+                && (classDecl.mods.flags & com.sun.tools.javac.code.Flags.IMPLICIT_CLASS) != 0;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.WorkArounds;\n@@ -996,1 +997,1 @@\n-                    if (!accessFilter.checkModifier(e)) {\n+                    if (!accessFilter.checkModifier(e) && !WorkArounds.isImplicitlyDeclaredClass(e)) {\n@@ -1015,1 +1016,7 @@\n-                    return accessFilter.checkModifier(e);\n+                    if (accessFilter.checkModifier(e)) {\n+                        return true;\n+                    } else {\n+                        return WorkArounds.isImplicitlyDeclaredClass(e.getEnclosingElement())\n+                                && e.getKind() != ElementKind.CONSTRUCTOR \/* nothing interesting in that ctor *\/\n+                                && AccessLevel.of(e.getModifiers()).compareTo(AccessLevel.PACKAGE) >= 0;\n+                    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308715\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main\/othervm TestImplicitlyDeclaredClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestImplicitlyDeclaredClasses extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        new TestImplicitlyDeclaredClasses().runTests();\n+    }\n+\n+    @Test\n+    public void test(Path base) throws IOException {\n+        int i = 0;\n+        for (Method main : mainMethods())\n+            for (Method otherMethod : otherMethods()) {\n+                var methods = List.of(main, otherMethod);\n+                var index = String.valueOf(i++);\n+                var src = base.resolve(Path.of(\"src-\" + index, \"MyClass.java\"));\n+                tb.writeFile(src, methods.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\"\\n\")));\n+                \/\/ TODO: remove preview-related options once \"Implicitly Declared\n+                \/\/  Classes and Instance Main Methods\" has been standardized\n+                javadoc(\"--enable-preview\", \"--source=22\",\n+                        \"-d\", base.resolve(\"out-\" + index).toString(),\n+                        src.toString());\n+\n+                checkExit(Exit.OK);\n+                \/\/ there must be no warning on undocumented (default) constructor\n+                checkOutput(Output.OUT, false, \"\"\"\n+                        warning: use of default constructor, which does not provide a comment\"\"\");\n+                \/\/ the (default) constructor must neither be linked nor mentioned\n+                checkOutput(\"MyClass.html\", false, \"%3Cinit%3E\");\n+                checkOutput(\"MyClass.html\", false, \"Constructor\");\n+                \/\/ a method that is public, protected or declared with package\n+                \/\/ access must either be documented or, if it doesn't have a\n+                \/\/ comment, must be warned about\n+                int nWarnedMethods = 0;\n+                for (var m : methods) {\n+                    if (m.accessModifier.compareTo(Access.PACKAGE) >= 0) {\n+                        if (m.comment.isEmpty()) {\n+                            checkOutput(Output.OUT, true, \"warning: no comment\\n\" + m);\n+                            nWarnedMethods++;\n+                        } else {\n+                            checkOutput(\"MyClass.html\", true,\n+                                    \"\"\"\n+                                            <span class=\"return-type\">%s<\/span>\"\"\"\n+                                            .formatted(m.returnValue),\n+                                    \"\"\"\n+                                            <span class=\"element-name\">%s<\/span>\"\"\"\n+                                            .formatted(m.name));\n+                        }\n+                    }\n+                }\n+                \/\/ there must be no warning on uncommented implicitly declared class\n+                \/\/\n+                \/\/ Here's a non-obvious part. A warning message for an uncommented\n+                \/\/ class is the same as that of a method. Moreover, since the class\n+                \/\/ is implicit, its AST position is that of the first method.\n+                \/\/\n+                \/\/ Put differently, if the class is uncommented, the warning about\n+                \/\/ it is indistinguishable from that of the first method, if that\n+                \/\/ method is uncommented.\n+                \/\/\n+                \/\/ Here's how this check works: if an undocumented class warning\n+                \/\/ is present, then the total count of undocumented element warnings\n+                \/\/ is one greater than that of undocumented methods.\n+                \/\/\n+                \/\/ Of course, it's possible, although seemingly unlikely, that\n+                \/\/ this check passes, when it should fail: the warning for class\n+                \/\/ is generated, but the warning for the first method is not.\n+                \/\/ Numbers are equal, test passes.\n+                checking(\"uncommented class warning\");\n+                long all = Pattern.compile(\"warning: no comment\\n\")\n+                        .matcher(getOutput(Output.OUT))\n+                        .results()\n+                        .count();\n+                if (all != nWarnedMethods) {\n+                    failed(\"%d\/%d\".formatted(all, nWarnedMethods));\n+                } else {\n+                    passed(\"\");\n+                }\n+            }\n+    }\n+\n+    private Iterable<Method> mainMethods() {\n+        return generate(\n+                List.of(\"\/** main comment *\/\", \"\"),\n+                \/\/ adding PRIVATE will increase test output size and run time\n+                EnumSet.of(Access.PUBLIC, Access.PROTECTED, Access.PACKAGE),\n+                \/\/ adding final will increase test output size and run time\n+                List.of(\"static\", \"\"),\n+                List.of(\"void\"),\n+                \"main\",\n+                List.of(\"String[] args\", \"\")\n+        );\n+    }\n+\n+    private Iterable<Method> otherMethods() {\n+        return generate(\n+                List.of(\"\/** other comment *\/\", \"\"),\n+                \/\/ adding PROTECTED or PUBLIC will increase test output size and run time\n+                EnumSet.of(Access.PACKAGE, Access.PRIVATE),\n+                \/\/ adding final or static will increase test output size and run time\n+                List.of(\"\"),\n+                List.of(\"void\"),\n+                \"other\",\n+                List.of(\"\"));\n+    }\n+\n+    private Iterable<Method> generate(Iterable<String> comments,\n+                                      Iterable<Access> accessModifiers,\n+                                      Iterable<String> otherModifiers,\n+                                      Iterable<String> returnValues,\n+                                      String name,\n+                                      Iterable<String> args) {\n+        var methods = new ArrayList<Method>();\n+        for (var comment : comments)\n+            for (var accessModifier : accessModifiers)\n+                for (var otherModifier : otherModifiers)\n+                    for (var returnValue : returnValues)\n+                        for (var arg : args)\n+                            methods.add(new Method(comment, accessModifier,\n+                                    otherModifier, returnValue, name, arg));\n+        return methods;\n+    }\n+\n+    enum Access {PRIVATE, PACKAGE, PROTECTED, PUBLIC}\n+\n+    record Method(String comment,\n+                  Access accessModifier,\n+                  String otherModifier,\n+                  String returnValue,\n+                  String name,\n+                  String arg) {\n+\n+        @Override\n+        public String toString() {\n+            return Stream.of(comment, access(accessModifier), otherModifier,\n+                            returnValue, name + \"(\" + arg + \") { }\")\n+                    .map(Object::toString)\n+                    .filter(s -> !s.isEmpty())\n+                    .collect(Collectors.joining(\" \"));\n+        }\n+    }\n+\n+    private static String access(Access accessModifier) {\n+        return switch (accessModifier) {\n+            case PRIVATE -> \"private\";\n+            case PACKAGE -> \"\";\n+            case PROTECTED -> \"protected\";\n+            case PUBLIC -> \"public\";\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testImplicitlyDeclaredClasses\/TestImplicitlyDeclaredClasses.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}