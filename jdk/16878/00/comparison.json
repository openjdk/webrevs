{"files":[{"patch":"@@ -116,0 +116,10 @@\n+  \/\/ Disable support for dynamic number of GC threads. We do not let the runtime\n+  \/\/ heuristics to misjudge how many threads we need during the heavy concurrent phase\n+  \/\/ or a GC pause.\n+  if (UseDynamicNumberOfGCThreads) {\n+    if (FLAG_IS_CMDLINE(UseDynamicNumberOfGCThreads)) {\n+      warning(\"Shenandoah does not support UseDynamicNumberOfGCThreads, disabling\");\n+    }\n+    FLAG_SET_DEFAULT(UseDynamicNumberOfGCThreads, false);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2021,6 +2021,3 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      assert(nworkers <= ParallelGCThreads, \"Cannot use more than it has\");\n-    } else {\n-      \/\/ Use ParallelGCThreads inside safepoints\n-      assert(nworkers == ParallelGCThreads, \"Use ParallelGCThreads within safepoints\");\n-    }\n+    \/\/ Use ParallelGCThreads inside safepoints\n+    assert(nworkers == ParallelGCThreads, \"Use ParallelGCThreads (%u) within safepoint, not %u\",\n+           ParallelGCThreads, nworkers);\n@@ -2028,6 +2025,3 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      assert(nworkers <= ConcGCThreads, \"Cannot use more than it has\");\n-    } else {\n-      \/\/ Use ConcGCThreads outside safepoints\n-      assert(nworkers == ConcGCThreads, \"Use ConcGCThreads outside safepoints\");\n-    }\n+    \/\/ Use ConcGCThreads outside safepoints\n+    assert(nworkers == ConcGCThreads, \"Use ConcGCThreads (%u) outside safepoints, %u\",\n+           ConcGCThreads, nworkers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,130 +26,0 @@\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/workerPolicy.hpp\"\n-#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/threads.hpp\"\n-\n-uint ShenandoahWorkerPolicy::_prev_par_marking     = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_marking    = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_evac       = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_root_proc  = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_refs_proc  = 0;\n-uint ShenandoahWorkerPolicy::_prev_fullgc          = 0;\n-uint ShenandoahWorkerPolicy::_prev_degengc         = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_update_ref = 0;\n-uint ShenandoahWorkerPolicy::_prev_par_update_ref  = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_cleanup    = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_reset      = 0;\n-\n-uint ShenandoahWorkerPolicy::calc_workers_for_init_marking() {\n-  uint active_workers = (_prev_par_marking == 0) ? ParallelGCThreads : _prev_par_marking;\n-\n-  _prev_par_marking =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_par_marking;\n-}\n-\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_marking() {\n-  uint active_workers = (_prev_conc_marking == 0) ?  ConcGCThreads : _prev_conc_marking;\n-  _prev_conc_marking =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_marking;\n-}\n-\n-\/\/ Reuse the calculation result from init marking\n-uint ShenandoahWorkerPolicy::calc_workers_for_final_marking() {\n-  return _prev_par_marking;\n-}\n-\n-\/\/ Calculate workers for concurrent refs processing\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_refs_processing() {\n-  uint active_workers = (_prev_conc_refs_proc == 0) ? ConcGCThreads : _prev_conc_refs_proc;\n-  _prev_conc_refs_proc =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_refs_proc;\n-}\n-\n-\/\/ Calculate workers for concurrent root processing\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing() {\n-  uint active_workers = (_prev_conc_root_proc == 0) ? ConcGCThreads : _prev_conc_root_proc;\n-  _prev_conc_root_proc =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_root_proc;\n-}\n-\n-\/\/ Calculate workers for concurrent evacuation (concurrent GC)\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_evac() {\n-  uint active_workers = (_prev_conc_evac == 0) ? ConcGCThreads : _prev_conc_evac;\n-  _prev_conc_evac =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_evac;\n-}\n-\n-\/\/ Calculate workers for parallel fullgc\n-uint ShenandoahWorkerPolicy::calc_workers_for_fullgc() {\n-  uint active_workers = (_prev_fullgc == 0) ?  ParallelGCThreads : _prev_fullgc;\n-  _prev_fullgc =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_fullgc;\n-}\n-\n-\/\/ Calculate workers for parallel degenerated gc\n-uint ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated() {\n-  uint active_workers = (_prev_degengc == 0) ?  ParallelGCThreads : _prev_degengc;\n-  _prev_degengc =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_degengc;\n-}\n-\n-\/\/ Calculate workers for concurrent reference update\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref() {\n-  uint active_workers = (_prev_conc_update_ref == 0) ? ConcGCThreads : _prev_conc_update_ref;\n-  _prev_conc_update_ref =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_update_ref;\n-}\n-\n-\/\/ Calculate workers for parallel reference update\n-uint ShenandoahWorkerPolicy::calc_workers_for_final_update_ref() {\n-  uint active_workers = (_prev_par_update_ref == 0) ? ParallelGCThreads : _prev_par_update_ref;\n-  _prev_par_update_ref =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_par_update_ref;\n-}\n-\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_cleanup() {\n-  uint active_workers = (_prev_conc_cleanup == 0) ? ConcGCThreads : _prev_conc_cleanup;\n-  _prev_conc_cleanup =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_cleanup;\n-}\n-\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_reset() {\n-  uint active_workers = (_prev_conc_reset == 0) ? ConcGCThreads : _prev_conc_reset;\n-  _prev_conc_reset =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_reset;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":0,"deletions":130,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -31,13 +31,0 @@\n-private:\n-  static uint _prev_par_marking;\n-  static uint _prev_conc_marking;\n-  static uint _prev_conc_root_proc;\n-  static uint _prev_conc_refs_proc;\n-  static uint _prev_conc_evac;\n-  static uint _prev_fullgc;\n-  static uint _prev_degengc;\n-  static uint _prev_conc_update_ref;\n-  static uint _prev_par_update_ref;\n-  static uint _prev_conc_cleanup;\n-  static uint _prev_conc_reset;\n-\n@@ -45,35 +32,14 @@\n-  \/\/ Calculate the number of workers for initial marking\n-  static uint calc_workers_for_init_marking();\n-\n-  \/\/ Calculate the number of workers for concurrent marking\n-  static uint calc_workers_for_conc_marking();\n-\n-  \/\/ Calculate the number of workers for final marking\n-  static uint calc_workers_for_final_marking();\n-\n-  \/\/ Calculate workers for concurrent root processing\n-  static uint calc_workers_for_conc_root_processing();\n-\n-  \/\/ Calculate workers for concurrent refs processing\n-  static uint calc_workers_for_conc_refs_processing();\n-\n-  \/\/ Calculate workers for concurrent evacuation (concurrent GC)\n-  static uint calc_workers_for_conc_evac();\n-\n-  \/\/ Calculate workers for parallel full gc\n-  static uint calc_workers_for_fullgc();\n-\n-  \/\/ Calculate workers for parallel degenerated gc\n-  static uint calc_workers_for_stw_degenerated();\n-\n-  \/\/ Calculate workers for concurrent reference update\n-  static uint calc_workers_for_conc_update_ref();\n-\n-  \/\/ Calculate workers for parallel\/final reference update\n-  static uint calc_workers_for_final_update_ref();\n-\n-  \/\/ Calculate workers for concurrent cleanup\n-  static uint calc_workers_for_conc_cleanup();\n-\n-  \/\/ Calculate workers for concurrent reset\n-  static uint calc_workers_for_conc_reset();\n+  \/\/ Normal GC cycle:\n+  static uint calc_workers_for_init_marking()         { return ParallelGCThreads; }\n+  static uint calc_workers_for_conc_marking()         { return ConcGCThreads;     }\n+  static uint calc_workers_for_final_marking()        { return ParallelGCThreads; }\n+  static uint calc_workers_for_conc_refs_processing() { return ConcGCThreads;     }\n+  static uint calc_workers_for_conc_root_processing() { return ConcGCThreads;     }\n+  static uint calc_workers_for_conc_evac()            { return ConcGCThreads;     }\n+  static uint calc_workers_for_conc_update_ref()      { return ConcGCThreads;     }\n+  static uint calc_workers_for_final_update_ref()     { return ParallelGCThreads; }\n+  static uint calc_workers_for_conc_reset()           { return ConcGCThreads;     }\n+\n+  \/\/ STW GC cycles:\n+  static uint calc_workers_for_stw_degenerated()      { return ParallelGCThreads; }\n+  static uint calc_workers_for_fullgc()               { return ParallelGCThreads; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":14,"deletions":48,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -56,5 +56,0 @@\n-    if (GC.Shenandoah.isSupported()) {\n-      noneGCSupported = false;\n-      testDynamicNumberOfGCThreads(\"UseShenandoahGC\");\n-    }\n-\n@@ -62,1 +57,1 @@\n-      throw new SkippedException(\"Skipping test because none of G1\/Parallel\/Shenandoah is supported.\");\n+      throw new SkippedException(\"Skipping test because none of G1\/Parallel is supported.\");\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestDynamicNumberOfGCThreads.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}