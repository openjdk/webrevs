{"files":[{"patch":"@@ -55,0 +55,1 @@\n+import compiler.lib.template_framework.library.Expression.Nesting;\n@@ -338,1 +339,1 @@\n-                Expression expression = Expression.nestRandomly(type, Operations.PRIMITIVE_OPERATIONS, depth);\n+                Expression expression = Expression.nestRandomly(type, Operations.PRIMITIVE_OPERATIONS, depth, Nesting.EXACT);\n@@ -353,1 +354,1 @@\n-                Expression expression = Expression.nestRandomly(type, Operations.SCALAR_NUMERIC_OPERATIONS, depth);\n+                Expression expression = Expression.nestRandomly(type, Operations.SCALAR_NUMERIC_OPERATIONS, depth, Nesting.EXACT);\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -385,0 +385,17 @@\n+    \/**\n+     * {@link Nesting} defines the different ways of selecting {@link Expression}s\n+     * to nest based on their types.\n+     *\/\n+    public enum Nesting {\n+        \/**\n+         * Only nest {@Expression}s where the argument and return types match exactly\n+         * based on the implementation of {@link CodeGenerateionDataNameType#isSubtypeOf}.\n+         *\/\n+        EXACT,\n+        \/**\n+         * Only nest {@Expression}s where the return type is a subtype of the argument\n+         * type based on the implemetation of {@link CodeGenerateionDataNameType#isSubtypeOf}.\n+         *\/\n+        SUBTYPE\n+    }\n+\n@@ -394,0 +411,1 @@\n+     * @param nesting control the {@link Nesting} of the sampled {@link Expression}s.\n@@ -398,1 +416,2 @@\n-                                          int maxNumberOfUsedExpressions) {\n+                                          int maxNumberOfUsedExpressions,\n+                                          Nesting nesting) {\n@@ -409,1 +428,1 @@\n-            expression = expression.nestRandomly(expressions);\n+            expression = expression.nestRandomly(expressions, nesting);\n@@ -419,0 +438,1 @@\n+     * @param nesting control the {@link Nesting} of the sampled {@link Expression}s.\n@@ -421,1 +441,1 @@\n-    public Expression nestRandomly(List<Expression> nestingExpressions) {\n+    public Expression nestRandomly(List<Expression> nestingExpressions, Nesting nesting) {\n@@ -424,1 +444,4 @@\n-        List<Expression> filtered = nestingExpressions.stream().filter(e -> e.returnType.isSubtypeOf(argumentType)).toList();\n+        List<Expression> filtered = nestingExpressions.stream()\n+                                                      .filter(e -> e.returnType.isSubtypeOf(argumentType) &&\n+                                                                (nesting == Nesting.EXACT ? argumentType.isSubtypeOf(e.returnType) : true))\n+                                                      .toList();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Expression.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -132,0 +132,9 @@\n+            \/\/ Because of subtyping, we can sample an expression like `(float)((int)(3) \/ (int)(0))`. Floating point\n+            \/\/ division and modulo do not throw an ArithmeticException on division by zero, integer division and modulo\n+            \/\/ do. In the expression above, the division has an integer on both sides, so it is executed as an integer\n+            \/\/ division and throws an ArithmeticException even though we would expect the float division not to do so.\n+            \/\/ To prevent this issue, we provide two versions of floating point division operations: one that casts\n+            \/\/ its operands and one that expects that an ArithmeticException might be thrown when we get unlucky when\n+            \/\/ sampling subtypes.\n+            ops.add(Expression.make(type, \"((\" + type.name() + \")(\", type, \") \/ (\" + type.name() +\")(\", type, \"))\"));\n+            ops.add(Expression.make(type, \"((\" + type.name() + \")(\", type, \") % (\" + type.name() +\")(\", type, \"))\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import compiler.lib.template_framework.library.Expression.Nesting;\n@@ -177,4 +178,4 @@\n-        Expression e1e2 = e1.nestRandomly(List.of(e2));\n-        Expression e1ex = e1.nestRandomly(List.of(e3, e2, e3));\n-        Expression e1e4 = e1.nestRandomly(List.of(e3, e4, e3));\n-        Expression e1ey = e1.nestRandomly(List.of(e3, e3));\n+        Expression e1e2 = e1.nestRandomly(List.of(e2), Nesting.SUBTYPE);\n+        Expression e1ex = e1.nestRandomly(List.of(e3, e2, e3), Nesting.SUBTYPE);\n+        Expression e1e4 = e1.nestRandomly(List.of(e3, e4, e3), Nesting.SUBTYPE);\n+        Expression e1ey = e1.nestRandomly(List.of(e3, e3), Nesting.SUBTYPE);\n@@ -183,1 +184,1 @@\n-        Expression deep1 = Expression.nestRandomly(myTypeA, List.of(e1, e3), 5);\n+        Expression deep1 = Expression.nestRandomly(myTypeA, List.of(e1, e3), 5, Nesting.SUBTYPE);\n@@ -185,1 +186,1 @@\n-        Expression deep2 = Expression.nestRandomly(myTypeA, List.of(e5, e3), 5);\n+        Expression deep2 = Expression.nestRandomly(myTypeA, List.of(e5, e3), 5, Nesting.SUBTYPE);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestExpression.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"}]}