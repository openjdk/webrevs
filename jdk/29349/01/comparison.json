{"files":[{"patch":"@@ -55,0 +55,1 @@\n+import compiler.lib.template_framework.library.Expression.Nesting;\n@@ -338,1 +339,1 @@\n-                Expression expression = Expression.nestRandomly(type, Operations.PRIMITIVE_OPERATIONS, depth);\n+                Expression expression = Expression.nestRandomly(type, Operations.PRIMITIVE_OPERATIONS, depth, Nesting.EXACT);\n@@ -353,1 +354,1 @@\n-                Expression expression = Expression.nestRandomly(type, Operations.SCALAR_NUMERIC_OPERATIONS, depth);\n+                Expression expression = Expression.nestRandomly(type, Operations.SCALAR_NUMERIC_OPERATIONS, depth, Nesting.EXACT);\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -385,0 +385,17 @@\n+    \/**\n+     * {@link Nesting} defines the different ways of selecting {@link Expression}s\n+     * to nest based on their types.\n+     *\/\n+    public enum Nesting {\n+        \/**\n+         * Only nest {@Expression}s where the argument and return types match exactly\n+         * based on the implementation of {@link CodeGenerateionDataNameType#isSubtypeOf}.\n+         *\/\n+        EXACT,\n+        \/**\n+         * Only nest {@Expression}s where the return type is a subtype of the argument\n+         * type based on the implemetation of {@link CodeGenerateionDataNameType#isSubtypeOf}.\n+         *\/\n+        SUBTYPE\n+    }\n+\n@@ -394,0 +411,1 @@\n+     * @param nesting control the {@link Nesting} of the sampled {@link Expression}s.\n@@ -398,1 +416,2 @@\n-                                          int maxNumberOfUsedExpressions) {\n+                                          int maxNumberOfUsedExpressions,\n+                                          Nesting nesting) {\n@@ -409,1 +428,1 @@\n-            expression = expression.nestRandomly(expressions);\n+            expression = expression.nestRandomly(expressions, nesting);\n@@ -419,0 +438,1 @@\n+     * @param nesting control the {@link Nesting} of the sampled {@link Expression}s.\n@@ -421,1 +441,1 @@\n-    public Expression nestRandomly(List<Expression> nestingExpressions) {\n+    public Expression nestRandomly(List<Expression> nestingExpressions, Nesting nesting) {\n@@ -424,1 +444,4 @@\n-        List<Expression> filtered = nestingExpressions.stream().filter(e -> e.returnType.isSubtypeOf(argumentType)).toList();\n+        List<Expression> filtered = nestingExpressions.stream()\n+                                                      .filter(e -> e.returnType.isSubtypeOf(argumentType) &&\n+                                                                (nesting == Nesting.EXACT ? argumentType.isSubtypeOf(e.returnType) : true))\n+                                                      .toList();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Expression.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -132,2 +132,11 @@\n-            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\"));\n-            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\"));\n+            \/\/ Because of subtyping, we can sample an expression like `(float)((int)(3) \/ (int)(0))`. Floating point\n+            \/\/ division and modulo do not throw an ArithmeticException on division by zero, integer division and modulo\n+            \/\/ do. In the expression above, the division has an integer on both sides, so it is executed as an integer\n+            \/\/ division and throws an ArithmeticException even though we would expect the float division not to do so.\n+            \/\/ To prevent this issue, we provide two versions of floating point division operations: one that casts\n+            \/\/ its operands and one that expects that an ArithmeticException might be thrown when we get unlucky when\n+            \/\/ sampling subtypes.\n+            ops.add(Expression.make(type, \"((\" + type.name() + \")(\", type, \") \/ (\" + type.name() +\")(\", type, \"))\"));\n+            ops.add(Expression.make(type, \"((\" + type.name() + \")(\", type, \") % (\" + type.name() +\")(\", type, \"))\"));\n+            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n+            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,16 @@\n-        return (other instanceof PrimitiveType pt) && pt.kind == kind;\n+        \/\/ Implement other >: this according to JLS ยง4.10.1.\n+        if (other instanceof PrimitiveType pt) {\n+            if (pt.kind == Kind.BOOLEAN || kind == Kind.BOOLEAN) {\n+                \/\/ Boolean does not have a supertype and only itself as a subtype.\n+                return pt.kind == kind;\n+            }\n+            if (pt.kind == Kind.CHAR || kind == Kind.CHAR) {\n+                \/\/ Char does not have a subtype, but .\n+                \/\/ The following is correct for the subtype relation to floats, since chars are 16 bits wide and floats 32 bits or more.\n+                return pt.kind == kind || (pt.byteSize() > this.byteSize() && this.kind != Kind.BYTE);\n+            }\n+            return (pt.isFloating() && !this.isFloating()) ||  \/\/ Due to float >: long, all integers are subtypes of floating point types.\n+                   (pt.isFloating() == this.isFloating() && pt.byteSize() >= this.byteSize()); \/\/ Generally, narrower types are subtypes of wider types.\n+        }\n+\n+        return false;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n@@ -132,1 +133,2 @@\n-        \/\/ from them. There should be no cross-over between the types.\n+        \/\/ from them. Sampling exactly should not lead to any conversion and sampling\n+        \/\/ subtypes should only lead to widening conversions.\n@@ -153,0 +155,8 @@\n+        var assignmentTemplate = Template.make(\"lhsType\", (PrimitiveType lhsType) -> scope(\n+            dataNames(MUTABLE).exactOf(lhsType).sampleAndLetAs(\"lhs\"),\n+            dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(lhsType).sampleAndLetAs(\"rhs\"),\n+            \"\"\"\n+            #lhs = #rhs;\n+            \"\"\"\n+        ));\n+\n@@ -164,1 +174,1 @@\n-                \/\/ Now sample:\n+                \/\/ Sample exactly:\n@@ -168,0 +178,6 @@\n+                ),\n+                \"\"\"\n+                \/\/ Sample subtypes:\n+                \"\"\",\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(assignmentTemplate::asToken).toList()\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import compiler.lib.template_framework.library.Expression.Nesting;\n@@ -177,4 +178,4 @@\n-        Expression e1e2 = e1.nestRandomly(List.of(e2));\n-        Expression e1ex = e1.nestRandomly(List.of(e3, e2, e3));\n-        Expression e1e4 = e1.nestRandomly(List.of(e3, e4, e3));\n-        Expression e1ey = e1.nestRandomly(List.of(e3, e3));\n+        Expression e1e2 = e1.nestRandomly(List.of(e2), Nesting.SUBTYPE);\n+        Expression e1ex = e1.nestRandomly(List.of(e3, e2, e3), Nesting.SUBTYPE);\n+        Expression e1e4 = e1.nestRandomly(List.of(e3, e4, e3), Nesting.SUBTYPE);\n+        Expression e1ey = e1.nestRandomly(List.of(e3, e3), Nesting.SUBTYPE);\n@@ -183,1 +184,1 @@\n-        Expression deep1 = Expression.nestRandomly(myTypeA, List.of(e1, e3), 5);\n+        Expression deep1 = Expression.nestRandomly(myTypeA, List.of(e1, e3), 5, Nesting.SUBTYPE);\n@@ -185,1 +186,1 @@\n-        Expression deep2 = Expression.nestRandomly(myTypeA, List.of(e5, e3), 5);\n+        Expression deep2 = Expression.nestRandomly(myTypeA, List.of(e5, e3), 5, Nesting.SUBTYPE);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestExpression.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"}]}