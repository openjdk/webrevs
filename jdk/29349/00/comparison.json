{"files":[{"patch":"@@ -132,2 +132,2 @@\n-            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\"));\n-            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\"));\n+            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n+            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,16 @@\n-        return (other instanceof PrimitiveType pt) && pt.kind == kind;\n+        \/\/ Implement other >: this according to JLS ยง4.10.1.\n+        if (other instanceof PrimitiveType pt) {\n+            if (pt.kind == Kind.BOOLEAN || kind == Kind.BOOLEAN) {\n+                \/\/ Boolean does not have a supertype and only itself as a subtype.\n+                return pt.kind == kind;\n+            }\n+            if (pt.kind == Kind.CHAR || kind == Kind.CHAR) {\n+                \/\/ Char does not have a subtype, but .\n+                \/\/ The following is correct for the subtype relation to floats, since chars are 16 bits wide and floats 32 bits or more.\n+                return pt.kind == kind || (pt.byteSize() > this.byteSize() && this.kind != Kind.BYTE);\n+            }\n+            return (pt.isFloating() && !this.isFloating()) ||  \/\/ Due to float >: long, all integers are subtypes of floating point types.\n+                   (pt.isFloating() == this.isFloating() && pt.byteSize() >= this.byteSize()); \/\/ Generally, narrower types are subtypes of wider types.\n+        }\n+\n+        return false;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n@@ -132,1 +133,2 @@\n-        \/\/ from them. There should be no cross-over between the types.\n+        \/\/ from them. Sampling exactly should not lead to any conversion and sampling\n+        \/\/ subtypes should only lead to widening conversions.\n@@ -153,0 +155,8 @@\n+        var assignmentTemplate = Template.make(\"lhsType\", (PrimitiveType lhsType) -> scope(\n+            dataNames(MUTABLE).exactOf(lhsType).sampleAndLetAs(\"lhs\"),\n+            dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(lhsType).sampleAndLetAs(\"rhs\"),\n+            \"\"\"\n+            #lhs = #rhs;\n+            \"\"\"\n+        ));\n+\n@@ -164,1 +174,1 @@\n-                \/\/ Now sample:\n+                \/\/ Sample exactly:\n@@ -168,0 +178,6 @@\n+                ),\n+                \"\"\"\n+                \/\/ Sample subtypes:\n+                \"\"\",\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(assignmentTemplate::asToken).toList()\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"}]}