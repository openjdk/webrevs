{"files":[{"patch":"@@ -556,0 +556,1 @@\n+        String str;\n@@ -557,2 +558,1 @@\n-            this.value = \"\".value;\n-            this.coder = \"\".coder;\n+            str = \"\";\n@@ -560,6 +560,26 @@\n-            if (COMPACT_STRINGS) {\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n-                if (dp == length) {\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                    this.coder = LATIN1;\n-                    return;\n+            str = utf8(bytes, offset, length);\n+        } else if (charset == ISO_8859_1.INSTANCE) {\n+            str = iso88591(bytes, offset, length);\n+        } else if (charset == US_ASCII.INSTANCE) {\n+            str = ascii(bytes, offset, length);\n+        } else {\n+            str = create(charset, bytes, offset, length);\n+        }\n+        this.value = str.value;\n+        this.coder = str.coder;\n+    }\n+\n+    private static String utf8(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS) {\n+            int dp = StringCoding.countPositives(bytes, offset, length);\n+            if (dp == length) {\n+                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+            }\n+            \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n+            byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n+            int sp = dp;            \/\/ first dp bytes are already in the copy\n+            while (sp < length) {\n+                int b1 = latin1[sp++];\n+                if (b1 >= 0) {\n+                    latin1[dp++] = (byte) b1;\n+                    continue;\n@@ -567,7 +587,5 @@\n-                \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n-                byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n-                int sp = dp;            \/\/ first dp bytes are already in the copy\n-                while (sp < length) {\n-                    int b1 = latin1[sp++];\n-                    if (b1 >= 0) {\n-                        latin1[dp++] = (byte)b1;\n+                if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n+                    int b2 = latin1[sp];\n+                    if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                        latin1[dp++] = (byte) decode2(b1, b2);\n+                        sp++;\n@@ -576,12 +594,0 @@\n-                    if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = latin1[sp];\n-                        if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n-                            latin1[dp++] = (byte)decode2(b1, b2);\n-                            sp++;\n-                            continue;\n-                        }\n-                    }\n-                    \/\/ anything not a latin1, including the REPL\n-                    \/\/ we have to go with the utf16\n-                    sp--;\n-                    break;\n@@ -589,21 +595,8 @@\n-                if (sp == length) {\n-                    if (dp != latin1.length) {\n-                        latin1 = Arrays.copyOf(latin1, dp);\n-                    }\n-                    this.value = latin1;\n-                    this.coder = LATIN1;\n-                    return;\n-                }\n-                byte[] utf16 = StringUTF16.newBytesFor(length);\n-                StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n-                dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n-                if (dp != length) {\n-                    utf16 = Arrays.copyOf(utf16, dp << 1);\n-                }\n-                this.value = utf16;\n-                this.coder = UTF16;\n-            } else { \/\/ !COMPACT_STRINGS\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n-                if (dp != length) {\n-                    dst = Arrays.copyOf(dst, dp << 1);\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                sp--;\n+                break;\n+            }\n+            if (sp == length) {\n+                if (dp != latin1.length) {\n+                    latin1 = Arrays.copyOf(latin1, dp);\n@@ -611,2 +604,1 @@\n-                this.value = dst;\n-                this.coder = UTF16;\n+                return new String(latin1, LATIN1);\n@@ -614,7 +606,5 @@\n-        } else if (charset == ISO_8859_1.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                this.value = StringLatin1.inflate(bytes, offset, length);\n-                this.coder = UTF16;\n+            byte[] utf16 = StringUTF16.newBytesFor(length);\n+            StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n+            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n+            if (dp != length) {\n+                utf16 = Arrays.copyOf(utf16, dp << 1);\n@@ -622,13 +612,7 @@\n-        } else if (charset == US_ASCII.INSTANCE) {\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = 0;\n-                while (dp < length) {\n-                    int b = bytes[offset++];\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n+            return new String(utf16, UTF16);\n+        }\n+        else { \/\/ !COMPACT_STRINGS\n+            byte[] dst = StringUTF16.newBytesFor(length);\n+            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+            if (dp != length) {\n+                dst = Arrays.copyOf(dst, dp << 1);\n@@ -636,0 +620,7 @@\n+            return new String(dst, UTF16);\n+        }\n+    }\n+\n+    private static String iso88591(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n@@ -637,22 +628,3 @@\n-            \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n-            \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n-            \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n-            \/\/ gc should be able to take care of them well. But the best approach\n-            \/\/ is still not to generate them if not really necessary.\n-            \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n-            \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n-            \/\/ optimization check of (sm==null && classLoader0==null) for both.\n-            CharsetDecoder cd = charset.newDecoder();\n-            \/\/ ArrayDecoder fastpaths\n-            if (cd instanceof ArrayDecoder ad) {\n-                \/\/ ascii\n-                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                    if (COMPACT_STRINGS) {\n-                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                        this.coder = LATIN1;\n-                        return;\n-                    }\n-                    this.value = StringLatin1.inflate(bytes, offset, length);\n-                    this.coder = UTF16;\n-                    return;\n-                }\n+            return new String(StringLatin1.inflate(bytes, offset, length), UTF16);\n+        }\n+    }\n@@ -660,8 +632,13 @@\n-                \/\/ fastpath for always Latin1 decodable single byte\n-                if (COMPACT_STRINGS && ad.isLatin1Decodable()) {\n-                    byte[] dst = new byte[length];\n-                    ad.decodeToLatin1(bytes, offset, length, dst);\n-                    this.value = dst;\n-                    this.coder = LATIN1;\n-                    return;\n-                }\n+    private static String ascii(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+        } else {\n+            byte[] dst = StringUTF16.newBytesFor(length);\n+            int dp = 0;\n+            while (dp < length) {\n+                int b = bytes[offset++];\n+                StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n+            }\n+            return new String(dst, UTF16);\n+        }\n+    }\n@@ -669,5 +646,14 @@\n-                int en = scale(length, cd.maxCharsPerByte());\n-                cd.onMalformedInput(CodingErrorAction.REPLACE)\n-                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-                char[] ca = new char[en];\n-                int clen = ad.decode(bytes, offset, length, ca);\n+    private static String create(Charset charset, byte[] bytes, int offset, int length) {\n+        \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n+        \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n+        \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n+        \/\/ gc should be able to take care of them well. But the best approach\n+        \/\/ is still not to generate them if not really necessary.\n+        \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n+        \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n+        \/\/ optimization check of (sm==null && classLoader0==null) for both.\n+        CharsetDecoder cd = charset.newDecoder();\n+        \/\/ ArrayDecoder fastpaths\n+        if (cd instanceof ArrayDecoder ad) {\n+            \/\/ ascii\n+            if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n@@ -675,4 +661,1 @@\n-                    byte[] val = StringUTF16.compress(ca, 0, clen);;\n-                    this.coder = StringUTF16.coderFromArrayLen(val, clen);\n-                    this.value = val;\n-                    return;\n+                    return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n@@ -680,3 +663,8 @@\n-                coder = UTF16;\n-                value = StringUTF16.toBytes(ca, 0, clen);\n-                return;\n+                return new String(StringLatin1.inflate(bytes, offset, length), UTF16);\n+            }\n+\n+            \/\/ fastpath for always Latin1 decodable single byte\n+            if (COMPACT_STRINGS && ad.isLatin1Decodable()) {\n+                byte[] dst = new byte[length];\n+                ad.decodeToLatin1(bytes, offset, length, dst);\n+                return new String(dst, LATIN1);\n@@ -685,1 +673,0 @@\n-            \/\/ decode using CharsetDecoder\n@@ -690,7 +677,1 @@\n-            int caLen;\n-            try {\n-                caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n-            } catch (CharacterCodingException x) {\n-                \/\/ Substitution is enabled, so this shouldn't happen\n-                throw new Error(x);\n-            }\n+            int clen = ad.decode(bytes, offset, length, ca);\n@@ -698,4 +679,2 @@\n-                byte[] val = StringUTF16.compress(ca, 0, caLen);\n-                this.coder = StringUTF16.coderFromArrayLen(val, caLen);\n-                this.value = val;\n-                return;\n+                byte[] val = StringUTF16.compress(ca, 0, clen);;\n+                return new String(val, StringUTF16.coderFromArrayLen(val, clen));\n@@ -703,2 +682,12 @@\n-            coder = UTF16;\n-            value = StringUTF16.toBytes(ca, 0, caLen);\n+            return new String(StringUTF16.toBytes(ca, 0, clen), UTF16);\n+        }\n+\n+        \/\/ decode using CharsetDecoder\n+        int en = scale(length, cd.maxCharsPerByte());\n+        cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        char[] ca = new char[en];\n+        int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+        if (COMPACT_STRINGS) {\n+            byte[] val = StringUTF16.compress(ca, 0, caLen);\n+            return new String(val, StringUTF16.coderFromArrayLen(val, caLen));\n@@ -706,0 +695,1 @@\n+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n@@ -826,7 +816,1 @@\n-        int caLen;\n-        try {\n-            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n-        } catch (CharacterCodingException x) {\n-            \/\/ throw via IAE\n-            throw new IllegalArgumentException(x);\n-        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -1245,11 +1229,15 @@\n-    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n-                                            throws CharacterCodingException {\n-        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n-        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n-        CoderResult cr = cd.decode(bb, cb, true);\n-        if (!cr.isUnderflow())\n-            cr.throwException();\n-        cr = cd.flush(cb);\n-        if (!cr.isUnderflow())\n-            cr.throwException();\n-        return cb.position();\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+        try {\n+            ByteBuffer bb = ByteBuffer.wrap(src, offset, length);\n+            CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);\n+            CoderResult cr = cd.decode(bb, cb, true);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            cr = cd.flush(cb);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            return cb.position();\n+        } catch (CharacterCodingException x) {\n+            \/\/ Substitution is enabled, so this shouldn't happen\n+            throw new IllegalArgumentException(x);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":132,"deletions":144,"binary":false,"changes":276,"status":"modified"}]}