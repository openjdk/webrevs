{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.net.ProtocolException;\n@@ -42,0 +43,1 @@\n+    static final byte FIRST_CHAR = 32;\n@@ -48,0 +50,1 @@\n+    private final  boolean firstClearRequest;\n@@ -49,1 +52,1 @@\n-    Request(InputStream rawInputStream, OutputStream rawout) throws IOException {\n+    Request(InputStream rawInputStream, OutputStream rawout, boolean firstClearRequest) throws IOException {\n@@ -51,0 +54,1 @@\n+        this.firstClearRequest = firstClearRequest;\n@@ -81,0 +85,19 @@\n+\n+        \/\/ For the first request that comes on a clear connection\n+        \/\/ we will check that the first non CR\/LF char on the\n+        \/\/ request line is eligible. This should be the first char\n+        \/\/ of a method name, so it should be at least greater or equal\n+        \/\/ to 32 (FIRST_CHAR) which is the space character.\n+        \/\/ The main goal here is to fail fast if we receive 0x16 (22) which\n+        \/\/ happens to be the first byte of a TLS handshake record.\n+        \/\/ This is typically what would be received if a TLS client opened\n+        \/\/ a TLS connection on a non-TLS server.\n+        \/\/ If we receive 0x16 we should close the connection immediately as\n+        \/\/ it indicates we're receiving a ClientHello on a clear\n+        \/\/ connection, and we will never receive the expected CRLF that\n+        \/\/ terminates the first request line.\n+        \/\/ Though we could check only for 0x16, any characters < 32\n+        \/\/ (excluding CRLF) is not expected at this position in a\n+        \/\/ request line, so we can still fail here early if any of\n+        \/\/ those are detected.\n+        int offset = 0;\n@@ -92,0 +115,6 @@\n+                    if (firstClearRequest && offset == 0) {\n+                        if (c < FIRST_CHAR) {\n+                            throw new ProtocolException(\"Unexpected start of request line\");\n+                        }\n+                        offset++;\n+                    }\n@@ -99,0 +128,6 @@\n+                    if (firstClearRequest && offset == 0) {\n+                        if (c < FIRST_CHAR) {\n+                            throw new ProtocolException(\"Unexpected start of request line\");\n+                        }\n+                        offset++;\n+                    }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Request.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.net.ProtocolException;\n@@ -736,1 +737,11 @@\n-                Request req = new Request(rawin, rawout);\n+\n+                Request req;\n+                try {\n+                    req = new Request(rawin, rawout, newconnection && !https);\n+                } catch (ProtocolException pe) {\n+                    logger.log(Level.DEBUG, pe.toString());\n+                    logger.log(Level.DEBUG, \"Bad first char in request line: closing\");\n+                    reject(Code.HTTP_BAD_REQUEST, \"\", pe.getMessage());\n+                    return;\n+                }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373677\n+ * @summary Tests for verifying that a non-SSL server can detect\n+ *          when a client attempts to use SSL.\n+ * @library \/test\/lib\n+ * @run junit\/othervm ${test.main.class}\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.net.ssl.SSLException;\n+\n+import static com.sun.net.httpserver.HttpExchange.RSPBODY_EMPTY;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ClearTextServerSSL {\n+\n+    static final InetAddress LOOPBACK_ADDR = InetAddress.getLoopbackAddress();\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    static final String CTXT_PATH = \"\/ClearTextServerSSL\";\n+\n+    @BeforeAll\n+    public static void setup() {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            logger.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            logger.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        var sslContext = new SimpleSSLContext().get();\n+        var handler = new TestHandler();\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR,0), 0);\n+        server.createContext(path(\"\"), handler);\n+        server.start();\n+        try (var client = HttpClient.newBuilder()\n+                    .sslContext(sslContext)\n+                    .proxy(NO_PROXY)\n+                    .build()) {\n+            var request = HttpRequest.newBuilder()\n+                    .uri(uri(\"http\", server, path(\"\/clear\")))\n+                    .build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(200, response.statusCode());\n+            var sslRequest = HttpRequest.newBuilder()\n+                    .uri(uri(\"https\", server, path(\"\/ssl\")))\n+                    .build();\n+            Assertions.assertThrows(SSLException.class, () -> {\n+                client.send(sslRequest, HttpResponse.BodyHandlers.ofString());\n+            });\n+            try (var socket = new Socket()) {\n+                socket.connect(server.getAddress());\n+                byte[] badRequest = {\n+                        22, 'B', 'A', 'D', ' ',\n+                        '\/', ' ' ,\n+                        'H', 'T', 'T', 'P', '\/', '1', '.', '1' };\n+                socket.getOutputStream().write(badRequest);\n+                socket.getOutputStream().flush();\n+                var reader = new InputStreamReader(socket.getInputStream());\n+                var line = reader.readAllLines();\n+                Assertions.assertEquals(\"HTTP\/1.1 400 Bad Request\", line.get(0));\n+                System.out.println(\"Got expected response:\");\n+                line.stream().map(l -> \"\\t\" + l).forEach(System.out::println);\n+            }\n+\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static String path(String path) {\n+        assert CTXT_PATH.startsWith(\"\/\");\n+        assert !CTXT_PATH.endsWith(\"\/\");\n+        if (path.startsWith(\"\/\")) {\n+            return CTXT_PATH + path;\n+        } else {\n+            return CTXT_PATH + \"\/\" + path;\n+        }\n+    }\n+\n+    static URI uri(String scheme, HttpServer server, String path) throws URISyntaxException {\n+        return URIBuilder.newBuilder()\n+                .scheme(scheme)\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(path)\n+                .build();\n+    }\n+\n+    \/**\n+     * A test handler that reads any request bytes and sends\n+     * an empty 200 response\n+     *\/\n+    static class TestHandler implements HttpHandler {\n+        @java.lang.Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (var reqBody = exchange.getRequestBody()) {\n+                reqBody.readAllBytes();\n+                exchange.sendResponseHeaders(200, RSPBODY_EMPTY);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                exchange.sendResponseHeaders(500, RSPBODY_EMPTY);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ClearTextServerSSL.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}