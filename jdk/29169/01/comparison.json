{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -2333,0 +2334,18 @@\n+\n+    \/\/ Make sure the precondition of VectorCastNode::opcode holds: we can only have\n+    \/\/ unsigned casts for integral types (excluding long). VectorAPI code is not\n+    \/\/ expected to violate this at runtime, but we may compile unreachable code\n+    \/\/ where such impossible combinations arise.\n+    if (is_ucast && (!is_integral_type(elem_bt_from) || elem_bt_from == T_LONG)) {\n+      \/\/ Halt-and-catch fire here. This condition should never happen at runtime.\n+      stringStream ss;\n+      ss.print(\"impossible combination: unsigned vector cast from %s\", type2name(elem_bt_from));\n+      HaltNode* halt = new HaltNode(control(), frameptr(), ss.as_string(C->comp_arena())\n+                                                           PRODUCT_ONLY(COMMA \/*reachable*\/false));\n+      _gvn.set_type_bottom(halt);\n+      root()->add_req(halt);\n+      stop_and_kill_map();\n+      log_if_needed(\"  ** impossible combination: unsigned cast from %s\", type2name(elem_bt_from));\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags\n+ * @bug 8374889\n+ * @summary Test case that can compile unexpected code paths in VectorAPI cast intrinsification.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:-TieredCompilation -Xbatch\n+ *      -XX:StressSeed=1462975402\n+ *      -XX:+StressIncrementalInlining\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test2\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=no-stress-seed\n+ * @bug 8374889\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:-TieredCompilation -Xbatch\n+ *      -XX:+StressIncrementalInlining\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test2\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8374889\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+\n+public class TestCastShapeBadOpc {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100_000; ++i) {\n+            test1();\n+            test2();\n+        }\n+    }\n+\n+    \/\/ This code does not trigger the bug itself, but seems to be important for profiling,\n+    \/\/ so that test2 fails.\n+    public static Object test1() {\n+        LongVector v0 = LongVector.broadcast(LongVector.SPECIES_512, -15L);\n+        var v1 = (ByteVector)v0.convertShape(VectorOperators.Conversion.ofReinterpret(long.class, byte.class), ByteVector.SPECIES_128, 0);\n+        var v2 = (ByteVector)v1.castShape(ByteVector.SPECIES_256, 0);\n+        return v2;\n+    }\n+\n+    public static Object test2() {\n+        var v0 = ShortVector.broadcast(ShortVector.SPECIES_64, (short)7729);\n+        var v1 = (FloatVector)v0.reinterpretShape(FloatVector.SPECIES_64, 0);\n+        \/\/ The castShape below should take the \"C\" path in AbstractVector::convert0, but sometimes\n+        \/\/ we also compile the \"Z\" case because of profiling. This means we attempt to create\n+        \/\/ a vector cast from float -> long, but unfortunately with a UCAST (float -> long is signed).\n+        \/\/ This triggered an assert in VectorCastNode::opcode.\n+        var v2 = (LongVector)v1.castShape(LongVector.SPECIES_256, 0);\n+        return v2;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestCastShapeBadOpc.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}