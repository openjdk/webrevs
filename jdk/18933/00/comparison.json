{"files":[{"patch":"@@ -2062,9 +2062,0 @@\n-\/\/ Used to convert frequent JVM_Yield() to nops\n-bool os::dont_yield() {\n-  return DontYieldALot;\n-}\n-\n-void os::naked_yield() {\n-  sched_yield();\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1939,9 +1939,0 @@\n-\/\/ Used to convert frequent JVM_Yield() to nops\n-bool os::dont_yield() {\n-  return DontYieldALot;\n-}\n-\n-void os::naked_yield() {\n-  sched_yield();\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4313,19 +4313,0 @@\n-\/\/ Used to convert frequent JVM_Yield() to nops\n-bool os::dont_yield() {\n-  return DontYieldALot;\n-}\n-\n-\/\/ Linux CFS scheduler (since 2.6.23) does not guarantee sched_yield(2) will\n-\/\/ actually give up the CPU. Since skip buddy (v2.6.28):\n-\/\/\n-\/\/ * Sets the yielding task as skip buddy for current CPU's run queue.\n-\/\/ * Picks next from run queue, if empty, picks a skip buddy (can be the yielding task).\n-\/\/ * Clears skip buddies for this run queue (yielding task no longer a skip buddy).\n-\/\/\n-\/\/ An alternative is calling os::naked_short_nanosleep with a small number to avoid\n-\/\/ getting re-scheduled immediately.\n-\/\/\n-void os::naked_yield() {\n-  sched_yield();\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -856,0 +856,8 @@\n+\n+bool os::dont_yield() {\n+  return DontYieldALot;\n+}\n+\n+void os::naked_yield() {\n+  sched_yield();\n+}\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}