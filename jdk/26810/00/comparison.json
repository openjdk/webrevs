{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -294,1 +295,1 @@\n-                printValue(frame, null, \"\");\n+                printJavaFrame(frame, \"\");\n@@ -326,1 +327,1 @@\n-    private void printArray(Object[] array) {\n+    private void printArray(Object[] array, ValueDescriptor field) {\n@@ -331,1 +332,1 @@\n-            printValue(array[i], null, i + 1 < array.length ? \", \" : \"\");\n+            printValue(array[i], field, i + 1 < array.length ? \", \" : \"\");\n@@ -339,37 +340,9 @@\n-        if (value == null) {\n-            println(\"N\/A\" + postFix);\n-            return;\n-        }\n-        if (value instanceof RecordedObject) {\n-            if (value instanceof RecordedThread rt) {\n-                printThread(rt, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClass rc) {\n-                printClass(rc, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClassLoader rcl) {\n-                printClassLoader(rcl, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedFrame frame) {\n-                if (frame.isJavaFrame()) {\n-                    printJavaFrame((RecordedFrame) value, postFix);\n-                    return;\n-                }\n-            }\n-            if (value instanceof RecordedMethod rm) {\n-                println(formatMethod(rm));\n-                return;\n-            }\n-            if (field.getTypeName().equals(TYPE_OLD_OBJECT)) {\n-                printOldObject((RecordedObject) value);\n-                return;\n-            }\n-             print((RecordedObject) value, postFix);\n-            return;\n-        }\n-        if (value.getClass().isArray()) {\n-            printArray((Object[]) value);\n-            return;\n+        switch (value) {\n+            case null -> println(\"N\/A\" + postFix);\n+            case RecordedObject object -> printRecordedObject(object, field, postFix);\n+            case Number number -> printNumber(number, field);\n+            case String text -> println(\"\\\"\" + text + \"\\\"\");\n+            case Duration duration -> printDuration(duration);\n+            case OffsetDateTime dateTime -> printOffsetDateTime(dateTime);\n+            case Object[] array -> printArray(array, field);\n+            default -> println(value);\n@@ -377,0 +350,1 @@\n+    }\n@@ -378,29 +352,9 @@\n-        if (value instanceof Double d) {\n-            if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Float f) {\n-            if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Long l) {\n-            if (l == Long.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Integer i) {\n-            if (i == Integer.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-\n-        if (field.getContentType() != null) {\n-            if (printFormatted(field, value)) {\n-                return;\n-            }\n+    private void printRecordedObject(RecordedObject struct, ValueDescriptor field, String postFix) {\n+        switch (struct) {\n+            case RecordedThread rt -> printThread(rt, postFix);\n+            case RecordedClass rc -> printClass(rc, postFix);\n+            case RecordedClassLoader rcl -> printClassLoader(rcl, postFix);\n+            case RecordedFrame rf when rf.isJavaFrame() -> printJavaFrame(rf, postFix);\n+            case RecordedMethod rm -> println(formatMethod(rm));\n+            case RecordedObject ro when field.getTypeName().equals(TYPE_OLD_OBJECT) -> printOldObject(ro);\n+            default -> print(struct, postFix);\n@@ -408,0 +362,1 @@\n+    }\n@@ -409,3 +364,7 @@\n-        String text = String.valueOf(value);\n-        if (value instanceof String) {\n-            text = \"\\\"\" + text + \"\\\"\";\n+    private void printNumber(Number number, ValueDescriptor field) {\n+        switch (number) {\n+            case Double d when Double.isNaN(d) || d == Double.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Float f when Float.isNaN(f) || f == Float.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Long l when l == Long.MIN_VALUE -> println(\"N\/A\");\n+            case Integer i when i == Integer.MIN_VALUE -> println(\"N\/A\");\n+            default -> printFormatted(field, number);\n@@ -413,1 +372,0 @@\n-        println(text);\n@@ -549,16 +507,4 @@\n-    private boolean printFormatted(ValueDescriptor field, Object value) {\n-        if (value instanceof Duration d) {\n-            if (d.getSeconds() == Long.MIN_VALUE && d.getNano() == 0)  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (d.equals(ChronoUnit.FOREVER.getDuration())) {\n-                println(\"Forever\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(String.format(\"%.9f s\", (double) d.toNanos() \/ 1_000_000_000));\n-            } else {\n-                println(ValueFormatter.formatDuration(d));\n-            }\n-            return true;\n+    private void printOffsetDateTime(OffsetDateTime dateTime) {\n+        if (dateTime.equals(OffsetDateTime.MIN)) {\n+            println(\"N\/A\");\n+            return;\n@@ -566,11 +512,11 @@\n-        if (value instanceof OffsetDateTime odt) {\n-            if (odt.equals(OffsetDateTime.MIN))  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(TIME_FORMAT_EXACT.format(odt));\n-            } else {\n-                println(TIME_FORMAT.format(odt));\n-            }\n-            return true;\n+        if (showExact) {\n+            println(TIME_FORMAT_EXACT.format(dateTime));\n+        } else {\n+            println(TIME_FORMAT.format(dateTime));\n+        }\n+    }\n+\n+    private void printDuration(Duration duration) {\n+        if (duration.getSeconds() == Long.MIN_VALUE && duration.getNano() == 0) {\n+            println(\"N\/A\");\n+            return;\n@@ -578,4 +524,16 @@\n-        Percentage percentage = field.getAnnotation(Percentage.class);\n-        if (percentage != null) {\n-            if (value instanceof Number n) {\n-                double p = 100 * n.doubleValue();\n+        if (duration.equals(ChronoUnit.FOREVER.getDuration())) {\n+            println(\"Forever\");\n+            return;\n+        }\n+        if (showExact) {\n+            println(String.format(\"%.9f s\", (double) duration.toNanos() \/ 1_000_000_000));\n+        } else {\n+            println(ValueFormatter.formatDuration(duration));\n+        }\n+    }\n+\n+    private void printFormatted(ValueDescriptor field, Number number) {\n+        if (field.getContentType() != null) {\n+            Percentage percentage = field.getAnnotation(Percentage.class);\n+            if (percentage != null) {\n+                double p = 100 * number.doubleValue();\n@@ -587,1 +545,1 @@\n-                return true;\n+                return;\n@@ -589,10 +547,10 @@\n-        }\n-        DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n-        if (dataAmount != null && value instanceof Number number) {\n-            boolean frequency = field.getAnnotation(Frequency.class) != null;\n-            String unit = dataAmount.value();\n-            boolean bits = unit.equals(DataAmount.BITS);\n-            boolean bytes = unit.equals(DataAmount.BYTES);\n-            if (bits || bytes) {\n-                formatMemory(number.longValue(), bytes, frequency);\n-                return true;\n+            DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n+            if (dataAmount != null) {\n+                boolean frequency = field.getAnnotation(Frequency.class) != null;\n+                String unit = dataAmount.value();\n+                boolean bits = unit.equals(DataAmount.BITS);\n+                boolean bytes = unit.equals(DataAmount.BYTES);\n+                if (bits || bytes) {\n+                    printMemory(number.longValue(), bytes, frequency);\n+                    return;\n+                }\n@@ -600,5 +558,3 @@\n-        }\n-        MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n-        if (memoryAddress != null) {\n-            if (value instanceof Number n) {\n-                long d = n.longValue();\n+            MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n+            if (memoryAddress != null) {\n+                long d = number.longValue();\n@@ -606,1 +562,1 @@\n-                return true;\n+                return;\n@@ -608,6 +564,4 @@\n-        }\n-        Frequency frequency = field.getAnnotation(Frequency.class);\n-        if (frequency != null) {\n-            if (value instanceof Number) {\n-                println(value + \" Hz\");\n-                return true;\n+            Frequency frequency = field.getAnnotation(Frequency.class);\n+            if (frequency != null) {\n+                println(number + \" Hz\");\n+                return;\n@@ -616,2 +570,1 @@\n-\n-        return false;\n+        println(number);\n@@ -620,1 +573,1 @@\n-    private void formatMemory(long value, boolean bytesUnit, boolean frequency) {\n+    private void printMemory(long value, boolean bytesUnit, boolean frequency) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":83,"deletions":130,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,4 @@\n+    public final void println(Object object) {\n+        println(String.valueOf(object));\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}