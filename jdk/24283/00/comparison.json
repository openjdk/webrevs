{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,4 @@\n+        try {\n+            this.streamPos = raf.getFilePointer();\n+        } catch (IOException ignored) {\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageInputStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,4 @@\n+        try {\n+            this.streamPos = raf.getFilePointer();\n+        } catch (IOException ignored) {\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageOutputStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5043343\n+ * @summary Verify that FIIS and FIOS constructors set streamPos to RAF position\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main FileImageStreamPos\n+ * @key randomness\n+ *\/\n+\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+import java.util.Random;\n+import javax.imageio.ImageIO;\n+import javax.imageio.stream.FileImageInputStream;\n+import javax.imageio.stream.FileImageOutputStream;\n+import jdk.test.lib.RandomFactory;\n+\n+public class FileImageStreamPos {\n+    \/\/ Maximum size of random prefix\n+    private static final int BOUND = 1024;\n+\n+    \/\/ Maximum image dimensions\n+    public static final int SIZE_MIN = 512;\n+    public static final int SIZE_MAX = 1024;\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        \/\/ Create source image with random content\n+        Random random = RandomFactory.getRandom();\n+        final int w = random.nextInt(SIZE_MIN, SIZE_MAX);\n+        final int h = random.nextInt(SIZE_MIN, SIZE_MAX);\n+        BufferedImage srcImage =\n+            new BufferedImage(w, h, BufferedImage.TYPE_3BYTE_BGR);\n+        int[] rgbArray = random.ints(w*h).toArray();\n+        srcImage.setRGB(0, 0, w, h, rgbArray, 0, w);\n+\n+        \/\/ Write some random bytes followed by the image\n+        File dstFile = File.createTempFile(\"before\", \"after\", new File(\".\"));\n+        dstFile.deleteOnExit();\n+        final int offset = random.nextInt(BOUND);\n+        System.out.println(\"offset: \" + offset);\n+        try(RandomAccessFile raf = new RandomAccessFile(dstFile, \"rw\");) {\n+            byte[] b = new byte[offset];\n+            random.nextBytes(b);\n+            raf.write(b);\n+            FileImageOutputStream fios = new FileImageOutputStream(raf);\n+            if (fios.getStreamPosition() != offset)\n+                throw new RuntimeException(fios.getStreamPosition() + \" != \" +\n+                                           offset);\n+            ImageIO.write(srcImage, \"PNG\", fios);\n+        }\n+\n+        \/\/ Read the image just written and compare with the original\n+        try(RandomAccessFile raf = new RandomAccessFile(dstFile, \"r\")) {\n+            \/\/ Read the image from after then random prefix\n+            raf.skipBytes(offset);\n+            FileImageInputStream fiis = new FileImageInputStream(raf);\n+            if (fiis.getStreamPosition() != offset)\n+                throw new RuntimeException(fiis.getStreamPosition() + \" != \" +\n+                                           offset);\n+            BufferedImage dstImage = ImageIO.read(fiis);\n+\n+            \/\/ Compare the image dimensions\n+            if (dstImage.getWidth() != w)\n+                throw new RuntimeException(dstImage.getWidth() + \" != \" + w);\n+            if (dstImage.getHeight() != h)\n+                throw new RuntimeException(dstImage.getHeight() + \" != \" + h);\n+\n+            \/\/ Compare RGB pixels\n+            if (!Arrays.equals(srcImage.getRGB(0, 0, w, h, null, 0, w),\n+                               dstImage.getRGB(0, 0, w, h, null, 0, w)))\n+                throw new RuntimeException(\"Pixels are not equal\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/stream\/FileImageStreamPos.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}