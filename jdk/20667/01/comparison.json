{"files":[{"patch":"@@ -381,0 +381,32 @@\n+        \/**\n+         * Returns if this utf8 entry's content equals a substring\n+         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n+         * This check avoids a substring allocation.\n+         *\/\n+        public boolean equalsRegion(String s, int start, int end) {\n+            \/\/ start and end values trusted\n+            if (state == State.RAW)\n+                inflate();\n+            int len = charLen;\n+            if (len != end - start)\n+                return false;\n+\n+            var sv = stringValue;\n+            if (sv != null) {\n+                return sv.regionMatches(0, s, start, len);\n+            }\n+\n+            var chars = this.chars;\n+            if (chars != null) {\n+                for (int i = 0; i < len; i++)\n+                    if (chars[i] != s.charAt(start + i))\n+                        return false;\n+            } else {\n+                var bytes = this.rawBytes;\n+                for (int i = 0; i < len; i++)\n+                    if (bytes[offset + i] != s.charAt(start + i))\n+                        return false;\n+            }\n+            return true;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -40,0 +41,2 @@\n+import jdk.internal.constant.ConstantUtils;\n+\n@@ -359,0 +362,83 @@\n+    \/**\n+     * Faster checking for ClassEntry given a class or interface descriptor.\n+     * <p>\n+     * Check steps:\n+     * <ol>\n+     * <li>Compute internal name utf8 entry hash for fast utf8 lookup\n+     * <li>Check length\n+     * <li>Find class entry and check ClassDesc if available (has == fast path)\n+     * <li>Check utf8 contents (only if ClassDesc is unavailable, only happens once if matched)\n+     * <\/ol>\n+     * Postprocessing: ensure on a match, the resulting ClassEntry has ClassDesc\n+     * for faster future checking\n+     * <p>\n+     * The rationale of the fast path is that:\n+     * <ol>\n+     * <li>New String hashing is expensive, reuse if possible\n+     * <li>Substringing needs allocation, but worse it discards hashes\n+     * <li>String equality check is expensive too, go through other fast paths before\n+     *   (like identity check in ClassDesc::equals) if possible\n+     * <\/ol>\n+     *\/\n+    private AbstractPoolEntry.ClassEntryImpl classEntryForClassOrInterface(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+        int hash = AbstractPoolEntry.hashString(Util.internalNameHash(desc));\n+\n+        while (true) {\n+            EntryMap<PoolEntry> map = map();\n+            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+                PoolEntry e = map.getElementByToken(token);\n+                if (e.tag() == ClassFile.TAG_UTF8\n+                        && e instanceof AbstractPoolEntry.Utf8EntryImpl utf\n+                        && utf.length() + 2 == desc.length()) {\n+                    \/\/ now probe class entry, fast path\n+                    var ce = (AbstractPoolEntry.ClassEntryImpl) findEntry(TAG_CLASS, utf);\n+                    if (ce != null) {\n+                        var sym = ce.sym;\n+                        if (sym != null) {\n+                            if (cd.equals(sym)) {\n+                                \/\/ definite match, fully expanded class entry\n+                                return ce;\n+                            } else {\n+                                \/\/ definite mismatch\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ now: ce == null or ce.sym == null\n+                    \/\/ slow path for definite checks\n+                    if (!utf.equalsRegion(desc, 1, desc.length() - 1)) {\n+                        \/\/ definite mismatch\n+                        continue;\n+                    }\n+\n+                    \/\/ definite match of utf8\n+                    \/\/ if ce != null, it's already bound to that utf8\n+                    if (ce == null) {\n+                        \/\/ no ClassEntry bound to that utf8 yet\n+                        ce = internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, utf));\n+                    }\n+\n+                    \/\/ with the symbol expansion, future lookups\n+                    \/\/ will go to the fast path definite check with sym above\n+                    assert ce.sym == null;\n+                    ce.sym = cd;\n+                    return ce;\n+                }\n+            }\n+            if (!doneFullScan) {\n+                fullScan();\n+                continue;\n+            }\n+            break;\n+        }\n+\n+        \/\/ No suitable utf8 and class entries, create both\n+        var internalName = ConstantUtils.dropFirstAndLastChar(desc);\n+        var utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, internalName, hash));\n+        var ce = internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, utf));\n+        ce.sym = cd;\n+        return ce;\n+    }\n+\n@@ -381,0 +467,15 @@\n+    @Override\n+    public ClassEntry classEntry(ClassDesc cd) {\n+        if (cd.isClassOrInterface()) { \/\/ implicit null check\n+            return classEntryForClassOrInterface(cd);\n+        }\n+        if (cd.isArray()) {\n+            var ret = classEntry(utf8Entry(cd.descriptorString()));\n+            if (ret.sym == null) {\n+                ret.sym = cd;\n+            }\n+            return ret;\n+        }\n+        throw new IllegalArgumentException(\"Cannot be encoded as ClassEntry: \" + cd.displayName());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -324,0 +325,69 @@\n+\n+    \/**\n+     * Returns the hash code of an internal name given the class or interface L descriptor.\n+     *\/\n+    public static int internalNameHash(String desc) {\n+        if (desc.length() > 0xffff)\n+            throw new IllegalArgumentException(\"String too long (\" + desc.length() + \"): \" + desc);\n+        return (desc.hashCode() - pow31(desc.length() - 1) * 'L' - ';') * INVERSE_31;\n+    }\n+\n+    \/\/ k is at most 65536, length of Utf8 entry + 1\n+    public static int pow31(int k) {\n+        int r = 1;\n+        \/\/ calculate the power contribution from index-th octal digit\n+        \/\/ from least to most significant (right to left)\n+        \/\/ e.g. decimal 26=octal 32, power(26)=powerOctal(2,0)*powerOctal(3,1)\n+        for (int i = 0; i < SIGNIFICANT_OCTAL_DIGITS; i++) {\n+            r *= powerOctal(k & 7, i);\n+            k >>= 3;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ The inverse of 31 in Z\/2^32Z* modulo group, a * INVERSE_31 * 31 = a\n+    static final int INVERSE_31 = 0xbdef7bdf;\n+\n+    \/\/ k is at most 65536 = octal 200000, only consider 6 octal digits\n+    \/\/ Note: 31 powers repeat beyond 1 << 27, only 9 octal digits matter\n+    static final int SIGNIFICANT_OCTAL_DIGITS = 6;\n+\n+    \/\/ for base k, storage is k * log_k(N)=k\/ln(k) * ln(N)\n+    \/\/ k = 2 or 4 is better for space at the cost of more multiplications\n+    \/**\n+     * The code below is as if:\n+     * {@snippet lang=java :\n+     * int[] powers = new int[7 * SIGNIFICANT_OCTAL_DIGITS];\n+     *\n+     * for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+     *    int t = powers[powersIndex(i, 0)] = k;\n+     *    for (int j = 1; j < SIGNIFICANT_OCTAL_DIGITS; j++) {\n+     *        t *= t;\n+     *        t *= t;\n+     *        t *= t;\n+     *        powers[powersIndex(i, j)] = t;\n+     *    }\n+     * }\n+     * }\n+     * This is converted to explicit initialization to avoid bootstrap overhead.\n+     * Validated in UtilTest.\n+     *\/\n+    static final @Stable int[] powers = new int[] {\n+            0x0000001f, 0x000003c1, 0x0000745f, 0x000e1781, 0x01b4d89f, 0x34e63b41, 0x67e12cdf,\n+            0x94446f01, 0x50a9de01, 0x84304d01, 0x7dd7bc01, 0x8ca02b01, 0xff899a01, 0x25940901,\n+            0x4dbf7801, 0xe3bef001, 0xc1fe6801, 0xe87de001, 0x573d5801, 0x0e3cd001, 0x0d7c4801,\n+            0x54fbc001, 0xb9f78001, 0x2ef34001, 0xb3ef0001, 0x48eac001, 0xede68001, 0xa2e24001,\n+            0x67de0001, 0xcfbc0001, 0x379a0001, 0x9f780001, 0x07560001, 0x6f340001, 0xd7120001,\n+            0x3ef00001, 0x7de00001, 0xbcd00001, 0xfbc00001, 0x3ab00001, 0x79a00001, 0xb8900001,\n+    };\n+\n+    static int powersIndex(int digit, int index) {\n+        return (digit - 1) + index * 7;\n+    }\n+\n+    \/\/ (31 ^ digit) ^ (8 * index) = 31 ^ (digit * (8 ^ index))\n+    \/\/ digit: 0 - 7\n+    \/\/ index: 0 - SIGNIFICANT_OCTAL_DIGITS - 1\n+    private static int powerOctal(int digit, int index) {\n+        return digit == 0 ? 1 : powers[powersIndex(digit, index)];\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304031 8338406\n+ * @bug 8304031 8338406 8338546\n@@ -28,0 +28,2 @@\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -39,0 +42,4 @@\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.constant.ConstantUtils;\n@@ -41,0 +48,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -105,0 +114,50 @@\n+\n+    static Stream<ClassDesc> classOrInterfaceEntries() {\n+        return Stream.of(\n+                CD_Object, CD_Float, CD_Long, CD_String, ClassDesc.of(\"Ape\"),\n+                CD_String.nested(\"Whatever\"), CD_MethodHandles_Lookup, ClassDesc.ofInternalName(\"one\/Two\"),\n+                ClassDesc.ofDescriptor(\"La\/b\/C;\"), ConstantDescSymbolsTest.class.describeConstable().orElseThrow(),\n+                CD_Boolean, CD_ConstantBootstraps, CD_MethodHandles\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classOrInterfaceEntries\")\n+    void testConstantPoolBuilderClassOrInterfaceEntry(ClassDesc cd) {\n+        assertTrue(cd.isClassOrInterface());\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var internal = ConstantUtils.dropFirstAndLastChar(cd.descriptorString());\n+\n+        \/\/ 1. ClassDesc\n+        var ce = cp.classEntry(cd);\n+        assertSame(cd, ce.asSymbol(), \"Symbol propagation on create\");\n+\n+        \/\/ 1.1. Bare addition\n+        assertTrue(ce.name().equalsString(internal), \"Adding to bare pool\");\n+\n+        \/\/ 1.2. Lookup existing\n+        assertSame(ce, cp.classEntry(cd), \"Finding by identical CD\");\n+\n+        \/\/ 1.3. Lookup existing - equal but different ClassDesc\n+        var cd1 = ClassDesc.ofDescriptor(cd.descriptorString());\n+        assertSame(ce, cp.classEntry(cd1), \"Finding by another equal CD\");\n+\n+        \/\/ 1.4. Lookup existing - with utf8 internal name\n+        var utf8 = cp.utf8Entry(internal);\n+        assertSame(ce, cp.classEntry(utf8), \"Finding CD by UTF8\");\n+\n+        \/\/ 2. ClassEntry exists, no ClassDesc\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(utf8);\n+        var found = cp.classEntry(cd);\n+        assertSame(ce, cp.classEntry(cd), \"Finding non-CD CEs with CD\");\n+        assertSame(cd, ce.asSymbol(), \"Symbol propagation on find\");\n+\n+        \/\/ 3. Utf8Entry exists, no ClassEntry\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(cd);\n+        assertSame(utf8, ce.name(), \"Reusing existing utf8 entry\");\n+        assertSame(cd, ce.asSymbol(), \"Symbol propagation on create with utf8\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8338546\n@@ -27,0 +28,4 @@\n+ * @library java.base\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build java.base\/jdk.internal.classfile.impl.*\n@@ -30,0 +35,3 @@\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n@@ -31,0 +39,2 @@\n+import jdk.internal.classfile.impl.UtilAccess;\n+import jdk.internal.constant.ConstantUtils;\n@@ -79,0 +89,51 @@\n+\n+    @Test\n+    void testPow31() {\n+        int p = 1;\n+        \/\/ Our calculation only prepares up to 65536,\n+        \/\/ max length of CP Utf8 + 1\n+        for (int i = 0; i <= 65536; i++) {\n+            final int t = i;\n+            assertEquals(p, Util.pow31(i), () -> \"31's power to \" + t);\n+            p *= 31;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            CopyOnWriteArrayList.class,\n+            AtomicReferenceFieldUpdater.class\n+    })\n+    void testInternalNameHash(Class<?> type) {\n+        var cd = type.describeConstable().orElseThrow();\n+        assertEquals(ConstantUtils.binaryToInternal(type.getName()).hashCode(), Util.internalNameHash(cd.descriptorString()));\n+    }\n+\n+    \/\/ Ensures the initialization statement of the powers array is filling in the right values\n+    @Test\n+    void testPowersArray() {\n+        int[] powers = new int[7 * UtilAccess.significantOctalDigits()];\n+        for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+            int t = powers[UtilAccess.powersIndex(i, 0)] = k;\n+\n+            for (int j = 1; j < UtilAccess.significantOctalDigits(); j++) {\n+                t *= t;\n+                t *= t;\n+                t *= t;\n+                powers[UtilAccess.powersIndex(i, j)] = t;\n+            }\n+        }\n+\n+        assertArrayEquals(powers, UtilAccess.powersTable());\n+    }\n+\n+    \/\/\n+    @Test\n+    void testModularMultiplicativeInverse() {\n+        assertEquals(1, 31 * UtilAccess.reverse31());\n+        assertEquals(1, 31L * Integer.toUnsignedLong(UtilAccess.reverse31()) % (1L << 32));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+public final class UtilAccess {\n+    public static int significantOctalDigits() {\n+        return Util.SIGNIFICANT_OCTAL_DIGITS;\n+    }\n+\n+    public static int powersIndex(int digit, int index) {\n+        return Util.powersIndex(digit, index);\n+    }\n+\n+    public static int[] powersTable() {\n+        return Util.powers;\n+    }\n+\n+    public static int reverse31() {\n+        return Util.INVERSE_31;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/java.base\/jdk\/internal\/classfile\/impl\/UtilAccess.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.classfile.impl.Util;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.openjdk.bench.jdk.classfile.TestConstants.*;\n+\n+\/**\n+ * Tests constant pool builder lookup performance for existing entries.\n+ *\/\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n+@State(Scope.Benchmark)\n+public class ConstantPoolBuildingClassEntry {\n+    \/\/ JDK-8338546\n+    ConstantPoolBuilder builder;\n+    List<ClassDesc> classDescs;\n+    List<ClassDesc> nonIdenticalClassDescs;\n+    List<String> internalNames;\n+    int size;\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        builder = ConstantPoolBuilder.of();\n+        classDescs = List.of(\n+                CD_Byte, CD_Object, CD_Long.arrayType(), CD_String, CD_String, CD_Object, CD_Short,\n+                CD_MethodHandle, CD_MethodHandle, CD_Object, CD_Character, CD_List, CD_ArrayList,\n+                CD_List, CD_Set, CD_Integer, CD_Object.arrayType(), CD_Enum, CD_Object, CD_MethodHandles_Lookup,\n+                CD_Long, CD_Set, CD_Object, CD_Character, CD_Integer, CD_System, CD_String, CD_String,\n+                CD_CallSite, CD_Collection, CD_List, CD_Collection, CD_String\n+        );\n+        size = classDescs.size();\n+        nonIdenticalClassDescs = classDescs.stream().map(cd -> {\n+            var ret = ClassDesc.ofDescriptor(cd.descriptorString());\n+            ret.hashCode(); \/\/ pre-compute hash code for cd\n+            return ret;\n+        }).toList();\n+        internalNames = classDescs.stream().map(cd -> {\n+            \/\/ also sets up builder\n+            cd.hashCode(); \/\/ pre-computes hash code for cd\n+            var ce = builder.classEntry(cd);\n+            var ret = ce.name().stringValue();\n+            ret.hashCode(); \/\/ pre-computes hash code for stringValue\n+            return ret;\n+        }).toList();\n+    }\n+\n+    \/**\n+     * Looking up with identical ClassDesc objects. Happens in bytecode generators reusing\n+     * constant CD_Xxx.\n+     *\/\n+    @Benchmark\n+    public void identicalLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with non-identical ClassDesc objects. Happens in bytecode generators\n+     * using ad-hoc Class.describeConstable().orElseThrow() or other parsed ClassDesc.\n+     * Cannot use identity fast path compared to {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void nonIdenticalLookup(Blackhole bh) {\n+        for (var cd : nonIdenticalClassDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with internal names. Closest to ASM behavior.\n+     * Baseline for {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void internalNameLookup(Blackhole bh) {\n+        for (var name : internalNames) {\n+            bh.consume(builder.classEntry(builder.utf8Entry(name)));\n+        }\n+    }\n+\n+    \/**\n+     * The default implementation provided by {@link ConstantPoolBuilder#classEntry(ClassDesc)}.\n+     * Does substring so needs to rehash and has no caching, should be very slow.\n+     *\/\n+    @Benchmark\n+    public void oldStyleLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            var s = cd.isClassOrInterface() ? Util.toInternalName(cd) : cd.descriptorString();\n+            bh.consume(builder.classEntry(builder.utf8Entry(s)));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ConstantPoolBuildingClassEntry.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}