{"files":[{"patch":"@@ -89,4 +89,12 @@\n-    public static Utf8Entry rawUtf8EntryFromStandardAttributeName(String name) {\n-        \/\/assuming standard attribute names are all US_ASCII\n-        var raw = name.getBytes(StandardCharsets.US_ASCII);\n-        return new Utf8EntryImpl(null, 0, raw, 0, raw.length);\n+    static int hashClassFromUtf8(boolean isArray, Utf8EntryImpl content) {\n+        int hash = content.contentHash();\n+        return hashClassFromDescriptor(isArray ? hash : Util.descriptorStringHash(content.length(), hash));\n+    }\n+\n+    static int hashClassFromDescriptor(int descriptorHash) {\n+        return hash1(ClassFile.TAG_CLASS, descriptorHash);\n+    }\n+\n+    static boolean isArrayDescriptor(Utf8EntryImpl cs) {\n+        \/\/ Do not throw out-of-bounds for empty strings\n+        return !cs.isEmpty() && cs.charAt(0) == '[';\n@@ -97,0 +105,2 @@\n+        if (cp.canWriteDirect(entry.constantPool()))\n+            return entry;\n@@ -149,1 +159,1 @@\n-        private @Stable int hash;\n+        private @Stable int contentHash;\n@@ -168,1 +178,1 @@\n-            this(cpm, index, s, hashString(s.hashCode()));\n+            this(cpm, index, s, s.hashCode());\n@@ -171,1 +181,1 @@\n-        Utf8EntryImpl(ConstantPool cpm, int index, String s, int hash) {\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s, int contentHash) {\n@@ -179,1 +189,1 @@\n-            this.hash = hash;\n+            this.contentHash = contentHash;\n@@ -188,1 +198,1 @@\n-            this.hash = u.hash;\n+            this.contentHash = u.contentHash;\n@@ -239,1 +249,1 @@\n-                this.hash = hashString(hash);\n+                this.contentHash = hash;\n@@ -297,1 +307,1 @@\n-                this.hash = hashString(hash);\n+                this.contentHash = hash;\n@@ -310,2 +320,0 @@\n-            if (cp.canWriteDirect(constantPool))\n-                return this;\n@@ -319,0 +327,4 @@\n+            return hashString(contentHash());\n+        }\n+\n+        int contentHash() {\n@@ -321,1 +333,1 @@\n-            return hash;\n+            return contentHash;\n@@ -392,0 +404,32 @@\n+        \/**\n+         * Returns if this utf8 entry's content equals a substring\n+         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n+         * This check avoids a substring allocation.\n+         *\/\n+        public boolean equalsRegion(String s, int start, int end) {\n+            \/\/ start and end values trusted\n+            if (state == State.RAW)\n+                inflate();\n+            int len = charLen;\n+            if (len != end - start)\n+                return false;\n+\n+            var sv = stringValue;\n+            if (sv != null) {\n+                return sv.regionMatches(0, s, start, len);\n+            }\n+\n+            var chars = this.chars;\n+            if (chars != null) {\n+                for (int i = 0; i < len; i++)\n+                    if (chars[i] != s.charAt(start + i))\n+                        return false;\n+            } else {\n+                var bytes = this.rawBytes;\n+                for (int i = 0; i < len; i++)\n+                    if (bytes[offset + i] != s.charAt(start + i))\n+                        return false;\n+            }\n+            return true;\n+        }\n+\n@@ -400,1 +444,1 @@\n-                    if (charLen != s.length() || hash != hashString(s.hashCode()))\n+                    if (charLen != s.length() || contentHash != s.hashCode())\n@@ -409,1 +453,1 @@\n-                    if (rawLen != s.length() || hash != hashString(s.hashCode()))\n+                    if (rawLen != s.length() || contentHash != s.hashCode())\n@@ -522,1 +566,2 @@\n-        public ClassDesc sym = null;\n+        public @Stable ClassDesc sym;\n+        private @Stable int hash;\n@@ -533,0 +578,6 @@\n+        ClassEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name, int hash, ClassDesc sym) {\n+            super(cpm, ClassFile.TAG_CLASS, index, name);\n+            this.hash = hash;\n+            this.sym = sym;\n+        }\n+\n@@ -535,7 +586,1 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            } else {\n-                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n-                ret.sym = sym;\n-                return ret;\n-            }\n+            return ((SplitConstantPool) cp).cloneClassEntry(this);\n@@ -550,1 +595,7 @@\n-            return this.sym = Util.toClassDesc(asInternalName());\n+\n+            if (isArrayDescriptor(ref1)) {\n+                sym = ref1.fieldTypeSymbol(); \/\/ array, symbol already available\n+            } else {\n+                sym = ClassDesc.ofInternalName(asInternalName()); \/\/ class or interface\n+            }\n+            return this.sym = sym;\n@@ -556,4 +607,2 @@\n-            if (o instanceof ClassEntryImpl cce) {\n-                return cce.name().equals(this.name());\n-            } else if (o instanceof ClassEntry c) {\n-                return c.asSymbol().equals(this.asSymbol());\n+            if (o instanceof ClassEntryImpl other) {\n+                return equalsEntry(other);\n@@ -563,0 +612,19 @@\n+\n+        boolean equalsEntry(ClassEntryImpl other) {\n+            var tsym = this.sym;\n+            var osym = other.sym;\n+            if (tsym != null && osym != null) {\n+                return tsym.equals(osym);\n+            }\n+\n+            return ref1.equalsUtf8(other.ref1);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            var hash = this.hash;\n+            if (hash != 0)\n+                return hash;\n+\n+            return this.hash = hashClassFromUtf8(isArrayDescriptor(ref1), ref1);\n+        }\n@@ -578,1 +646,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.packageEntry(ref1);\n+            return cp.packageEntry(ref1);\n@@ -609,1 +677,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.moduleEntry(ref1);\n+            return cp.moduleEntry(ref1);\n@@ -651,3 +719,0 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            }\n@@ -718,1 +783,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.fieldRefEntry(ref1, ref2);\n+            return cp.fieldRefEntry(ref1, ref2);\n@@ -736,1 +801,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodRefEntry(ref1, ref2);\n+            return cp.methodRefEntry(ref1, ref2);\n@@ -754,1 +819,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.interfaceMethodRefEntry(ref1, ref2);\n+            return cp.interfaceMethodRefEntry(ref1, ref2);\n@@ -850,1 +915,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.invokeDynamicEntry(bootstrap(), nameAndType());\n+            return cp.invokeDynamicEntry(bootstrap(), nameAndType());\n@@ -875,1 +940,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.constantDynamicEntry(bootstrap(), nameAndType());\n+            return cp.constantDynamicEntry(bootstrap(), nameAndType());\n@@ -932,1 +997,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodHandleEntry(refKind, reference);\n+            return cp.methodHandleEntry(refKind, reference);\n@@ -972,3 +1037,0 @@\n-            if (cp.canWriteDirect(constantPool)) {\n-                return this;\n-            }\n@@ -1023,1 +1085,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.stringEntry(ref1);\n+            return cp.stringEntry(ref1);\n@@ -1066,1 +1128,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.intEntry(val);\n+            return cp.intEntry(val);\n@@ -1112,1 +1174,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.floatEntry(val);\n+            return cp.floatEntry(val);\n@@ -1162,1 +1224,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.longEntry(val);\n+            return cp.longEntry(val);\n@@ -1212,1 +1274,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.doubleEntry(val);\n+            return cp.doubleEntry(val);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":110,"deletions":48,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import jdk.internal.constant.ConstantUtils;\n+\n@@ -374,1 +376,0 @@\n-                && ce.hashCode() == hash\n@@ -401,0 +402,84 @@\n+    private AbstractPoolEntry.Utf8EntryImpl tryFindUtf8OfRegion(int hash, String target, int start, int end) {\n+        EntryMap map = map();\n+        while (true) {\n+            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+                if (e.tag() == ClassFile.TAG_UTF8\n+                        && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n+                        && ce.equalsRegion(target, start, end))\n+                    return ce;\n+            }\n+            if (!doneFullScan) {\n+                fullScan();\n+                continue;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl tryFindClassOrInterface(int hash, ClassDesc cd) {\n+        while (true) {\n+            EntryMap map = map();\n+            for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+                PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+                if (e.tag() == TAG_CLASS\n+                        && e instanceof AbstractPoolEntry.ClassEntryImpl ce) {\n+                    var esym = ce.sym;\n+\n+                    if (esym != null) {\n+                        if (cd.equals(esym)) {\n+                            return ce; \/\/ definite match\n+                        }\n+                        continue; \/\/ definite mismatch\n+                    }\n+\n+                    \/\/ no symbol available\n+                    var desc = cd.descriptorString();\n+                    if (ce.ref1.equalsRegion(desc, 1, desc.length() - 1)) {\n+                        \/\/ definite match, propagate symbol\n+                        ce.sym = cd;\n+                        return ce;\n+                    }\n+                    \/\/ definite mismatch\n+                }\n+            }\n+            if (!doneFullScan) {\n+                fullScan();\n+                continue;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl classEntryForClassOrInterface(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+\n+        int hash = AbstractPoolEntry.hashClassFromDescriptor(desc.hashCode());\n+        var ce = tryFindClassOrInterface(hash, cd);\n+        if (ce != null)\n+            return ce;\n+\n+        var utfHash = Util.internalNameHash(desc);\n+        var utf = tryFindUtf8OfRegion(AbstractPoolEntry.hashString(utfHash), desc, 1, desc.length() - 1);\n+        if (utf == null)\n+            utf = internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, ConstantUtils.dropFirstAndLastChar(desc), utfHash));\n+\n+        return internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, utf, hash, cd));\n+    }\n+\n+    private AbstractPoolEntry.ClassEntryImpl tryFindClassEntry(int hash, AbstractPoolEntry.Utf8EntryImpl utf8) {\n+        EntryMap map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = entryByIndex(map.getIndexByToken(token));\n+            if (e.tag() == ClassFile.TAG_CLASS\n+                    && e instanceof AbstractPoolEntry.ClassEntryImpl ce\n+                    && ce.ref1.equalsUtf8(utf8))\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return tryFindClassEntry(hash, utf8);\n+        }\n+        return null;\n+    }\n+\n@@ -402,1 +487,1 @@\n-    public Utf8Entry utf8Entry(ClassDesc desc) {\n+    public AbstractPoolEntry.Utf8EntryImpl utf8Entry(ClassDesc desc) {\n@@ -404,1 +489,2 @@\n-        utf8.typeSym = desc;\n+        if (utf8.typeSym == null)\n+            utf8.typeSym = desc;\n@@ -411,1 +497,2 @@\n-        utf8.typeSym = desc;\n+        if (utf8.typeSym == null)\n+            utf8.typeSym = desc;\n@@ -417,3 +504,3 @@\n-        int hash = AbstractPoolEntry.hashString(s.hashCode());\n-        var ce = tryFindUtf8(hash, s);\n-        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, hash)) : ce;\n+        int contentHash = s.hashCode();\n+        var ce = tryFindUtf8(AbstractPoolEntry.hashString(contentHash), s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, contentHash)) : ce;\n@@ -432,3 +519,31 @@\n-        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n-        var e = (AbstractPoolEntry.ClassEntryImpl) findEntry(TAG_CLASS, ne);\n-        return e == null ? internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, ne)) : e;\n+        var ne = maybeCloneUtf8Entry(nameEntry);\n+        return classEntry(ne, AbstractPoolEntry.isArrayDescriptor(ne));\n+    }\n+\n+    AbstractPoolEntry.ClassEntryImpl classEntry(AbstractPoolEntry.Utf8EntryImpl ne, boolean isArray) {\n+        int hash = AbstractPoolEntry.hashClassFromUtf8(isArray, ne);\n+        var e = tryFindClassEntry(hash, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, ne, hash,\n+                isArray && ne.typeSym instanceof ClassDesc cd ? cd : null)) : e;\n+    }\n+\n+    @Override\n+    public ClassEntry classEntry(ClassDesc cd) {\n+        if (cd.isClassOrInterface()) { \/\/ implicit null check\n+            return classEntryForClassOrInterface(cd);\n+        }\n+        if (cd.isArray()) {\n+            return classEntry(utf8Entry(cd), true);\n+        }\n+        throw new IllegalArgumentException(\"Cannot be encoded as ClassEntry: \" + cd.displayName());\n+    }\n+\n+    AbstractPoolEntry.ClassEntryImpl cloneClassEntry(AbstractPoolEntry.ClassEntryImpl e) {\n+        var ce = tryFindClassEntry(e.hashCode(), e.ref1);\n+        if (ce != null) {\n+            return ce;\n+        }\n+\n+        var utf8 = maybeCloneUtf8Entry(e.ref1); \/\/ call order matters\n+        return internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size,\n+                utf8, e.hashCode(), e.sym));\n@@ -461,6 +576,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -473,6 +584,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -485,6 +592,2 @@\n-        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n-        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n-        if (!canWriteDirect(oe.constantPool))\n-            oe = classEntry(owner.name());\n-        if (!canWriteDirect(ne.constantPool))\n-            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        var oe = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.ClassEntryImpl) owner);\n+        var ne = AbstractPoolEntry.maybeClone(this, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -509,9 +612,1 @@\n-        if (!canWriteDirect(reference.constantPool())) {\n-            reference = switch (reference.tag()) {\n-                case TAG_FIELDREF -> fieldRefEntry(reference.owner(), reference.nameAndType());\n-                case TAG_METHODREF -> methodRefEntry(reference.owner(), reference.nameAndType());\n-                case TAG_INTERFACEMETHODREF -> interfaceMethodRefEntry(reference.owner(), reference.nameAndType());\n-                default -> throw new IllegalArgumentException(String.format(\"Bad tag %d\", reference.tag()));\n-            };\n-        }\n-\n+        reference = AbstractPoolEntry.maybeClone(this, reference);\n@@ -541,2 +636,1 @@\n-        if (!canWriteDirect(nameAndType.constantPool()))\n-            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        nameAndType = AbstractPoolEntry.maybeClone(this, nameAndType);\n@@ -572,2 +666,1 @@\n-        if (!canWriteDirect(nameAndType.constantPool()))\n-            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n+        nameAndType = AbstractPoolEntry.maybeClone(this, nameAndType);\n@@ -631,2 +724,1 @@\n-        if (!canWriteDirect(methodReference.constantPool()))\n-            methodReference = methodHandleEntry(methodReference.kind(), methodReference.reference());\n+        methodReference = AbstractPoolEntry.maybeClone(this, methodReference);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":135,"deletions":43,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -340,0 +341,78 @@\n+\n+    \/**\n+     * Returns the hash code of an internal name given the class or interface L descriptor.\n+     *\/\n+    public static int internalNameHash(String desc) {\n+        if (desc.length() > 0xffff)\n+            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(desc.length())));\n+        return (desc.hashCode() - pow31(desc.length() - 1) * 'L' - ';') * INVERSE_31;\n+    }\n+\n+    \/**\n+     * Returns the hash code of a class or interface L descriptor given the internal name.\n+     *\/\n+    public static int descriptorStringHash(int length, int hash) {\n+        if (length > 0xffff)\n+            throw new IllegalArgumentException(\"String too long: \".concat(Integer.toString(length)));\n+        return 'L' * pow31(length + 1) + hash * 31 + ';';\n+    }\n+\n+    \/\/ k is at most 65536, length of Utf8 entry + 1\n+    public static int pow31(int k) {\n+        int r = 1;\n+        \/\/ calculate the power contribution from index-th octal digit\n+        \/\/ from least to most significant (right to left)\n+        \/\/ e.g. decimal 26=octal 32, power(26)=powerOctal(2,0)*powerOctal(3,1)\n+        for (int i = 0; i < SIGNIFICANT_OCTAL_DIGITS; i++) {\n+            r *= powerOctal(k & 7, i);\n+            k >>= 3;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ The inverse of 31 in Z\/2^32Z* modulo group, a * INVERSE_31 * 31 = a\n+    static final int INVERSE_31 = 0xbdef7bdf;\n+\n+    \/\/ k is at most 65536 = octal 200000, only consider 6 octal digits\n+    \/\/ Note: 31 powers repeat beyond 1 << 27, only 9 octal digits matter\n+    static final int SIGNIFICANT_OCTAL_DIGITS = 6;\n+\n+    \/\/ for base k, storage is k * log_k(N)=k\/ln(k) * ln(N)\n+    \/\/ k = 2 or 4 is better for space at the cost of more multiplications\n+    \/**\n+     * The code below is as if:\n+     * {@snippet lang=java :\n+     * int[] powers = new int[7 * SIGNIFICANT_OCTAL_DIGITS];\n+     *\n+     * for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+     *    int t = powers[powersIndex(i, 0)] = k;\n+     *    for (int j = 1; j < SIGNIFICANT_OCTAL_DIGITS; j++) {\n+     *        t *= t;\n+     *        t *= t;\n+     *        t *= t;\n+     *        powers[powersIndex(i, j)] = t;\n+     *    }\n+     * }\n+     * }\n+     * This is converted to explicit initialization to avoid bootstrap overhead.\n+     * Validated in UtilTest.\n+     *\/\n+    static final @Stable int[] powers = new int[] {\n+            0x0000001f, 0x000003c1, 0x0000745f, 0x000e1781, 0x01b4d89f, 0x34e63b41, 0x67e12cdf,\n+            0x94446f01, 0x50a9de01, 0x84304d01, 0x7dd7bc01, 0x8ca02b01, 0xff899a01, 0x25940901,\n+            0x4dbf7801, 0xe3bef001, 0xc1fe6801, 0xe87de001, 0x573d5801, 0x0e3cd001, 0x0d7c4801,\n+            0x54fbc001, 0xb9f78001, 0x2ef34001, 0xb3ef0001, 0x48eac001, 0xede68001, 0xa2e24001,\n+            0x67de0001, 0xcfbc0001, 0x379a0001, 0x9f780001, 0x07560001, 0x6f340001, 0xd7120001,\n+            0x3ef00001, 0x7de00001, 0xbcd00001, 0xfbc00001, 0x3ab00001, 0x79a00001, 0xb8900001,\n+    };\n+\n+    static int powersIndex(int digit, int index) {\n+        return (digit - 1) + index * 7;\n+    }\n+\n+    \/\/ (31 ^ digit) ^ (8 * index) = 31 ^ (digit * (8 ^ index))\n+    \/\/ digit: 0 - 7\n+    \/\/ index: 0 - SIGNIFICANT_OCTAL_DIGITS - 1\n+    private static int powerOctal(int digit, int index) {\n+        return digit == 0 ? 1 : powers[powersIndex(digit, index)];\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304031 8338406\n+ * @bug 8304031 8338406 8338546\n@@ -28,0 +28,2 @@\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -39,0 +42,4 @@\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.constant.ConstantUtils;\n@@ -41,0 +48,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -105,0 +114,54 @@\n+\n+    static Stream<ClassDesc> classOrInterfaceEntries() {\n+        return Stream.of(\n+                CD_Object, CD_Float, CD_Long, CD_String, ClassDesc.of(\"Ape\"),\n+                CD_String.nested(\"Whatever\"), CD_MethodHandles_Lookup, ClassDesc.ofInternalName(\"one\/Two\"),\n+                ClassDesc.ofDescriptor(\"La\/b\/C;\"), ConstantDescSymbolsTest.class.describeConstable().orElseThrow(),\n+                CD_Boolean, CD_ConstantBootstraps, CD_MethodHandles\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classOrInterfaceEntries\")\n+    void testConstantPoolBuilderClassOrInterfaceEntry(ClassDesc cd) {\n+        assertTrue(cd.isClassOrInterface());\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var internal = ConstantUtils.dropFirstAndLastChar(cd.descriptorString());\n+\n+        \/\/ 1. ClassDesc\n+        var ce = cp.classEntry(cd);\n+        assertSame(cd, ce.asSymbol(), \"Symbol propagation on create\");\n+\n+        \/\/ 1.1. Bare addition\n+        assertTrue(ce.name().equalsString(internal), \"Adding to bare pool\");\n+\n+        \/\/ 1.2. Lookup existing\n+        assertSame(ce, cp.classEntry(cd), \"Finding by identical CD\");\n+\n+        \/\/ 1.3. Lookup existing - equal but different ClassDesc\n+        var cd1 = ClassDesc.ofDescriptor(cd.descriptorString());\n+        assertSame(ce, cp.classEntry(cd1), \"Finding by another equal CD\");\n+\n+        \/\/ 1.3.1. Lookup existing - equal but different ClassDesc, equal but different string\n+        var cd2 = ClassDesc.ofDescriptor(\"\" + cd.descriptorString());\n+        assertSame(ce, cp.classEntry(cd2), \"Finding by another equal CD\");\n+\n+        \/\/ 1.4. Lookup existing - with utf8 internal name\n+        var utf8 = cp.utf8Entry(internal);\n+        assertSame(ce, cp.classEntry(utf8), \"Finding CD by UTF8\");\n+\n+        \/\/ 2. ClassEntry exists, no ClassDesc\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(utf8);\n+        var found = cp.classEntry(cd);\n+        assertSame(ce, found, \"Finding non-CD CEs with CD\");\n+        assertEquals(cd, ce.asSymbol(), \"Symbol propagation on find\");\n+\n+        \/\/ 3. Utf8Entry exists, no ClassEntry\n+        cp = ConstantPoolBuilder.of();\n+        utf8 = cp.utf8Entry(internal);\n+        ce = cp.classEntry(cd);\n+        assertSame(utf8, ce.name(), \"Reusing existing utf8 entry\");\n+        assertEquals(cd, ce.asSymbol(), \"Symbol propagation on create with utf8\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8338546\n@@ -27,0 +28,4 @@\n+ * @library java.base\n+ * @modules java.base\/jdk.internal.constant\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build java.base\/jdk.internal.classfile.impl.*\n@@ -29,1 +34,0 @@\n-import java.lang.classfile.ClassFile;\n@@ -32,1 +36,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -34,1 +37,3 @@\n-import java.util.BitSet;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n@@ -38,0 +43,2 @@\n+import jdk.internal.classfile.impl.UtilAccess;\n+import jdk.internal.constant.ConstantUtils;\n@@ -87,0 +94,44 @@\n+    @Test\n+    void testPow31() {\n+        int p = 1;\n+        \/\/ Our calculation only prepares up to 65536,\n+        \/\/ max length of CP Utf8 + 1\n+        for (int i = 0; i <= 65536; i++) {\n+            final int t = i;\n+            assertEquals(p, Util.pow31(i), () -> \"31's power to \" + t);\n+            p *= 31;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            CopyOnWriteArrayList.class,\n+            AtomicReferenceFieldUpdater.class\n+    })\n+    void testInternalNameHash(Class<?> type) {\n+        var cd = type.describeConstable().orElseThrow();\n+        assertEquals(ConstantUtils.binaryToInternal(type.getName()).hashCode(), Util.internalNameHash(cd.descriptorString()));\n+    }\n+\n+    \/\/ Ensures the initialization statement of the powers array is filling in the right values\n+    @Test\n+    void testPowersArray() {\n+        int[] powers = new int[7 * UtilAccess.significantOctalDigits()];\n+        for (int i = 1, k = 31; i <= 7; i++, k *= 31) {\n+            int t = powers[UtilAccess.powersIndex(i, 0)] = k;\n+\n+            for (int j = 1; j < UtilAccess.significantOctalDigits(); j++) {\n+                t *= t;\n+                t *= t;\n+                t *= t;\n+                powers[UtilAccess.powersIndex(i, j)] = t;\n+            }\n+        }\n+\n+        assertArrayEquals(powers, UtilAccess.powersTable());\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+public final class UtilAccess {\n+    public static int significantOctalDigits() {\n+        return Util.SIGNIFICANT_OCTAL_DIGITS;\n+    }\n+\n+    public static int powersIndex(int digit, int index) {\n+        return Util.powersIndex(digit, index);\n+    }\n+\n+    public static int[] powersTable() {\n+        return Util.powers;\n+    }\n+\n+    public static int reverse31() {\n+        return Util.INVERSE_31;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/java.base\/jdk\/internal\/classfile\/impl\/UtilAccess.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.openjdk.bench.jdk.classfile.TestConstants.*;\n+\n+\/**\n+ * Tests constant pool builder lookup performance for ClassEntry.\n+ * Note that ClassEntry is available only for reference types.\n+ *\/\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsAppend = {\"--enable-preview\"})\n+@State(Scope.Benchmark)\n+public class ConstantPoolBuildingClassEntry {\n+    \/\/ JDK-8338546\n+    ConstantPoolBuilder builder;\n+    List<ClassDesc> classDescs;\n+    List<ClassDesc> nonIdenticalClassDescs;\n+    List<String> internalNames;\n+    List<ClassDesc> nonDuplicateClassDescs;\n+    List<String> nonDuplicateInternalNames;\n+    int size;\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        builder = ConstantPoolBuilder.of();\n+        \/\/ Note these can only be reference types, no primitives\n+        classDescs = List.of(\n+                CD_Byte, CD_Object, CD_Long.arrayType(), CD_String, CD_String, CD_Object, CD_Short,\n+                CD_MethodHandle, CD_MethodHandle, CD_Object, CD_Character, CD_List, CD_ArrayList,\n+                CD_List, CD_Set, CD_Integer, CD_Object.arrayType(), CD_Enum, CD_Object, CD_MethodHandles_Lookup,\n+                CD_Long, CD_Set, CD_Object, CD_Character, CD_Integer, CD_System, CD_String, CD_String,\n+                CD_CallSite, CD_Collection, CD_List, CD_Collection, CD_String, CD_int.arrayType()\n+        );\n+        size = classDescs.size();\n+        nonIdenticalClassDescs = classDescs.stream().map(cd -> {\n+            var ret = ClassDesc.ofDescriptor(new String(cd.descriptorString()));\n+            ret.hashCode(); \/\/ pre-compute hash code for cd\n+            return ret;\n+        }).toList();\n+        internalNames = classDescs.stream().map(cd -> {\n+            \/\/ also sets up builder\n+            cd.hashCode(); \/\/ pre-computes hash code for cd\n+            var ce = builder.classEntry(cd);\n+            var ret = ce.name().stringValue();\n+            ret.hashCode(); \/\/ pre-computes hash code for stringValue\n+            return ret;\n+        }).toList();\n+        nonDuplicateClassDescs = List.copyOf(new LinkedHashSet<>(classDescs));\n+        nonDuplicateInternalNames = nonDuplicateClassDescs.stream().map(cd ->\n+                builder.classEntry(cd).asInternalName()).toList();\n+    }\n+\n+    \/\/ Copied from jdk.internal.classfile.impl.Util::toInternalName\n+    \/\/ to reduce internal dependencies\n+    public static String toInternalName(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+        if (desc.charAt(0) == 'L')\n+            return desc.substring(1, desc.length() - 1);\n+        throw new IllegalArgumentException(desc);\n+    }\n+\n+    \/**\n+     * Looking up with identical ClassDesc objects. Happens in bytecode generators reusing\n+     * constant CD_Xxx.\n+     *\/\n+    @Benchmark\n+    public void identicalLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with non-identical ClassDesc objects. Happens in bytecode generators\n+     * using ad-hoc Class.describeConstable().orElseThrow() or other parsed ClassDesc.\n+     * Cannot use identity fast path compared to {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void nonIdenticalLookup(Blackhole bh) {\n+        for (var cd : nonIdenticalClassDescs) {\n+            bh.consume(builder.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Looking up with internal names. Closest to ASM behavior.\n+     * Baseline for {@link #identicalLookup}.\n+     *\/\n+    @Benchmark\n+    public void internalNameLookup(Blackhole bh) {\n+        for (var name : internalNames) {\n+            bh.consume(builder.classEntry(builder.utf8Entry(name)));\n+        }\n+    }\n+\n+    \/**\n+     * The default implementation provided by {@link ConstantPoolBuilder#classEntry(ClassDesc)}.\n+     * Does substring so needs to rehash and has no caching, should be very slow.\n+     *\/\n+    @Benchmark\n+    public void oldStyleLookup(Blackhole bh) {\n+        for (var cd : classDescs) {\n+            var s = cd.isClassOrInterface() ? toInternalName(cd) : cd.descriptorString();\n+            bh.consume(builder.classEntry(builder.utf8Entry(s)));\n+        }\n+    }\n+\n+    \/**\n+     * Measures performance of creating new class entries in new constant pools with symbols.\n+     *\/\n+    @Benchmark\n+    public void freshCreationWithDescs(Blackhole bh) {\n+        var cp = ConstantPoolBuilder.of();\n+        for (var cd : nonDuplicateClassDescs) {\n+            bh.consume(cp.classEntry(cd));\n+        }\n+    }\n+\n+    \/**\n+     * Measures performance of creating new class entries in new constant pools with internal names.\n+     *\/\n+    @Benchmark\n+    public void freshCreationWithInternalNames(Blackhole bh) {\n+        var cp = ConstantPoolBuilder.of();\n+        for (var name : nonDuplicateInternalNames) {\n+            bh.consume(cp.classEntry(cp.utf8Entry(name)));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ConstantPoolBuildingClassEntry.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}