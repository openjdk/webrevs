{"files":[{"patch":"@@ -423,0 +423,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -430,1 +447,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -450,1 +466,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -459,7 +474,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -529,10 +537,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -800,0 +800,46 @@\n+\n+    @Test\n+    public void testImportModuleNoModules(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                              List<String> l;\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors = new JavacTask(tb)\n+            .options(\"--release\", \"8\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDdev\",\n+                     \"-XDrawDiagnostics\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+                \"- compiler.warn.option.obsolete.source: 8\",\n+                \"- compiler.warn.option.obsolete.target: 8\",\n+                \"- compiler.warn.option.obsolete.suppression\",\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"Test.java:2:1: compiler.err.import.module.not.found: java.base\",\n+                \"Test.java:4:5: compiler.err.cant.resolve.location: kindname.class, List, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"3 errors\",\n+                \"3 warnings\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}