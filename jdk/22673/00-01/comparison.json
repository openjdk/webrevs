{"files":[{"patch":"@@ -2379,1 +2379,1 @@\n-void MacroAssembler::cmp_mxcsr(Address mxcsr_save, Register tmp, Register rscratch) {\n+void MacroAssembler::cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch) {\n@@ -2385,0 +2385,1 @@\n+  \/\/ Mask out any pending exceptions (only check control and mask bits)\n@@ -2386,1 +2387,1 @@\n-    orl(tmp, 0x003f);  \/\/ Set exceptions bits, addr_mxcsr_std has them set for ECore\n+    orl(tmp, 0x003f);  \/\/ On Ecore, exception bits are set by default\n@@ -2388,1 +2389,1 @@\n-    andl(tmp, 0xFFC0); \/\/ Mask out any pending exceptions (only check control and mask bits)\n+    andl(tmp, 0xFFC0);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-  void cmp_mxcsr(Address mxcsr_save, Register tmp, Register rscratch = noreg);\n+  void cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-      __ cmp_mxcsr(mxcsr_save, rax, noreg);\n+      __ cmp32_mxcsr_std(mxcsr_save, rax);\n@@ -460,1 +460,0 @@\n-      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -463,1 +462,1 @@\n-      __ cmp_mxcsr(mxcsr_save, rax);\n+      __ cmp32_mxcsr_std(mxcsr_save, rax);\n@@ -468,0 +467,1 @@\n+      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -251,2 +251,1 @@\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp_mxcsr(mxcsr_save, rax, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n@@ -254,0 +253,1 @@\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -574,1 +574,1 @@\n-    __ cmp_mxcsr(mxcsr_save, rax, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,2 +116,1 @@\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp_mxcsr(mxcsr_save, rax, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n@@ -119,0 +118,1 @@\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2573,32 +2573,0 @@\n-#if defined(_M_AMD64)\n-\/\/-----------------------------------------------------------------------------\n-static bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  \/\/ handle exception caused by native method modifying control word\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n-\n-  switch (exception_code) {\n-  case EXCEPTION_FLT_DENORMAL_OPERAND:\n-  case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n-  case EXCEPTION_FLT_INEXACT_RESULT:\n-  case EXCEPTION_FLT_INVALID_OPERATION:\n-  case EXCEPTION_FLT_OVERFLOW:\n-  case EXCEPTION_FLT_STACK_CHECK:\n-  case EXCEPTION_FLT_UNDERFLOW: {\n-    PCONTEXT ctx = exceptionInfo->ContextRecord;\n-    \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n-    \/\/ See also CR 6192333\n-    \/\/\n-    jint MxCsr = INITIAL_MXCSR; \/\/ FIXME? this is `define INITIAL_MXCSR 0x1f80` in windows sdk\n-    \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n-    \/\/ because in Win64 mxcsr is not saved there\n-    if (MxCsr != ctx->MxCsr) {\n-      ctx->MxCsr = MxCsr;\n-      return true;\n-    }\n-  }\n-  }\n-\n-  return false;\n-}\n-#endif\n-\n@@ -2789,0 +2757,1 @@\n+    extern bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -163,0 +163,37 @@\n+#if defined(_M_AMD64)\n+\/\/-----------------------------------------------------------------------------\n+bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  \/\/ handle exception caused by native method modifying control word\n+  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+\n+  switch (exception_code) {\n+  case EXCEPTION_FLT_DENORMAL_OPERAND:\n+  case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n+  case EXCEPTION_FLT_INEXACT_RESULT:\n+  case EXCEPTION_FLT_INVALID_OPERATION:\n+  case EXCEPTION_FLT_OVERFLOW:\n+  case EXCEPTION_FLT_STACK_CHECK:\n+  case EXCEPTION_FLT_UNDERFLOW: {\n+    PCONTEXT ctx = exceptionInfo->ContextRecord;\n+    \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n+    \/\/ See also CR 6192333\n+    \/\/\n+    jint MxCsr = INITIAL_MXCSR; \/\/ set to 0x1f80` in winnt.h\n+    if (EnableX86ECoreOpts) {\n+      \/\/ On ECore, restore with signaling flags enabled\n+      MxCsr |= 0x3F;\n+    }\n+    \n+    \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n+    \/\/ because in Win64 mxcsr is not saved there\n+    if (MxCsr != ctx->MxCsr) {\n+      ctx->MxCsr = MxCsr;\n+      return true;\n+    }\n+  }\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}