{"files":[{"patch":"@@ -782,0 +782,4 @@\n+#ifdef _WIN64\n+  \/\/ Windows always allocates space for its register args\n+  subq(rsp,  frame::arg_reg_save_area_bytes);\n+#endif\n@@ -785,0 +789,4 @@\n+#ifdef _WIN64\n+  \/\/ restore stack pointer\n+  addq(rsp, frame::arg_reg_save_area_bytes);\n+#endif\n@@ -2379,0 +2387,16 @@\n+void MacroAssembler::cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch) {\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  assert(rscratch != noreg || always_reachable(mxcsr_std), \"missing\");\n+\n+  stmxcsr(mxcsr_save);\n+  movl(tmp, mxcsr_save);\n+  if (EnableX86ECoreOpts) {\n+    \/\/ The mxcsr_std has status bits set for performance on ECore\n+    orl(tmp, 0x003f);\n+  } else {\n+    \/\/ Mask out status bits (only check control and mask bits)\n+    andl(tmp, 0xFFC0);\n+  }\n+  cmp32(tmp, mxcsr_std, rscratch);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1138,0 +1138,1 @@\n+  void cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-const int MXCSR_MASK  = 0xFFC0;  \/\/ Mask out any pending exceptions\n@@ -178,5 +177,1 @@\n-      __ stmxcsr(mxcsr_save);\n-      __ movl(rax, mxcsr_save);\n-      __ andl(rax, MXCSR_MASK);    \/\/ Only check control and mask bits\n-      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-      __ cmp32(rax, mxcsr_std);\n+      __ cmp32_mxcsr_std(mxcsr_save, rax);\n@@ -465,1 +460,0 @@\n-      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -468,4 +462,1 @@\n-      __ stmxcsr(mxcsr_save);\n-      __ movl(rax, mxcsr_save);\n-      __ andl(rax, MXCSR_MASK);\n-      __ cmp32(rax, mxcsr_std);\n+      __ cmp32_mxcsr_std(mxcsr_save, rax);\n@@ -476,0 +467,1 @@\n+      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -251,5 +251,1 @@\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, 0xFFC0); \/\/ Mask out any pending exceptions (only check control and mask bits)\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp32(rax, mxcsr_std, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n@@ -257,0 +253,1 @@\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -577,4 +574,1 @@\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, 0xFFC0); \/\/ Mask out any pending exceptions (only check control and mask bits)\n-    __ cmp32(rax, mxcsr_std, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-constexpr int MXCSR_MASK = 0xFFC0;  \/\/ Mask out any pending exceptions\n-\n@@ -118,5 +116,1 @@\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, MXCSR_MASK);    \/\/ Only check control and mask bits\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp32(rax, mxcsr_std, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n@@ -124,0 +118,1 @@\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2573,32 +2573,0 @@\n-#if defined(_M_AMD64)\n-\/\/-----------------------------------------------------------------------------\n-static bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  \/\/ handle exception caused by native method modifying control word\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n-\n-  switch (exception_code) {\n-  case EXCEPTION_FLT_DENORMAL_OPERAND:\n-  case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n-  case EXCEPTION_FLT_INEXACT_RESULT:\n-  case EXCEPTION_FLT_INVALID_OPERATION:\n-  case EXCEPTION_FLT_OVERFLOW:\n-  case EXCEPTION_FLT_STACK_CHECK:\n-  case EXCEPTION_FLT_UNDERFLOW: {\n-    PCONTEXT ctx = exceptionInfo->ContextRecord;\n-    \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n-    \/\/ See also CR 6192333\n-    \/\/\n-    jint MxCsr = INITIAL_MXCSR;\n-    \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n-    \/\/ because in Win64 mxcsr is not saved there\n-    if (MxCsr != ctx->MxCsr) {\n-      ctx->MxCsr = MxCsr;\n-      return true;\n-    }\n-  }\n-  }\n-\n-  return false;\n-}\n-#endif\n-\n@@ -2789,0 +2757,1 @@\n+    extern bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -163,0 +163,37 @@\n+#if defined(_M_AMD64)\n+\/\/-----------------------------------------------------------------------------\n+bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  \/\/ handle exception caused by native method modifying control word\n+  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+\n+  switch (exception_code) {\n+  case EXCEPTION_FLT_DENORMAL_OPERAND:\n+  case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n+  case EXCEPTION_FLT_INEXACT_RESULT:\n+  case EXCEPTION_FLT_INVALID_OPERATION:\n+  case EXCEPTION_FLT_OVERFLOW:\n+  case EXCEPTION_FLT_STACK_CHECK:\n+  case EXCEPTION_FLT_UNDERFLOW: {\n+    PCONTEXT ctx = exceptionInfo->ContextRecord;\n+    \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n+    \/\/ See also CR 6192333\n+    \/\/\n+    jint MxCsr = INITIAL_MXCSR; \/\/ set to 0x1f80` in winnt.h\n+    if (EnableX86ECoreOpts) {\n+      \/\/ On ECore restore with status bits enabled\n+      MxCsr |= 0x3F;\n+    }\n+\n+    \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n+    \/\/ because in Win64 mxcsr is not saved there\n+    if (MxCsr != ctx->MxCsr) {\n+      ctx->MxCsr = MxCsr;\n+      return true;\n+    }\n+  }\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xcomp -XX:-TieredCompilation -XX:UseAVX=2 -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts -XX:-CheckJNICalls IndexOf\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xcomp -XX:-TieredCompilation -XX:UseAVX=2 -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts IndexOf\n","filename":"test\/jdk\/java\/lang\/String\/IndexOf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts -XX:-CheckJNICalls -XX:UseAVX=2 -Xbatch -XX:-TieredCompilation -XX:CompileCommand=dontinline,ECoreIndexOf.indexOfKernel ECoreIndexOf\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts -XX:UseAVX=2 -Xbatch -XX:-TieredCompilation -XX:CompileCommand=dontinline,ECoreIndexOf.indexOfKernel ECoreIndexOf\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/ECoreIndexOf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}