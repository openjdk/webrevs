{"files":[{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.access;\n-\n-public interface JavaAWTAccess {\n-\n-    \/\/ Returns the AppContext used for applet logging isolation, or null if\n-    \/\/ no isolation is required.\n-    \/\/ If there's no applet, or if the caller is a stand alone application,\n-    \/\/ or running in the main app context, returns null.\n-    \/\/ Otherwise, returns the AppContext of the calling applet.\n-    public Object getAppletContext();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaAWTAccess.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -62,1 +62,0 @@\n-    private static JavaAWTAccess javaAWTAccess;\n@@ -324,10 +323,0 @@\n-    public static void setJavaAWTAccess(JavaAWTAccess jaa) {\n-        javaAWTAccess = jaa;\n-    }\n-\n-    public static JavaAWTAccess getJavaAWTAccess() {\n-        \/\/ this may return null in which case calling code needs to\n-        \/\/ provision for.\n-        return javaAWTAccess;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import jdk.internal.access.JavaAWTAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -749,61 +747,0 @@\n-    \/\/ Set up JavaAWTAccess in SharedSecrets\n-    static {\n-        SharedSecrets.setJavaAWTAccess(new JavaAWTAccess() {\n-            private boolean hasRootThreadGroup(final AppContext ecx) {\n-                return ecx.threadGroup.getParent() == null;\n-            }\n-\n-            \/**\n-             * Returns the AppContext used for applet logging isolation, or null if\n-             * the default global context can be used.\n-             * If there's no applet, or if the caller is a stand alone application,\n-             * or running in the main app context, returns null.\n-             * Otherwise, returns the AppContext of the calling applet.\n-             * @return null if the global default context can be used,\n-             *         an AppContext otherwise.\n-             **\/\n-            public Object getAppletContext() {\n-                \/\/ There's no AppContext: return null.\n-                \/\/ No need to call getAppContext() if numAppContext == 0:\n-                \/\/ it means that no AppContext has been created yet, and\n-                \/\/ we don't want to trigger the creation of a main app\n-                \/\/ context since we don't need it.\n-                if (numAppContexts.get() == 0) return null;\n-\n-                AppContext ecx = null;\n-\n-                \/\/ Not sure we really need to re-check numAppContexts here.\n-                \/\/ If all applets have gone away then we could have a\n-                \/\/ numAppContexts coming back to 0. So we recheck\n-                \/\/ it here because we don't want to trigger the\n-                \/\/ creation of a main AppContext in that case.\n-                \/\/ This is probably not 100% MT-safe but should reduce\n-                \/\/ the window of opportunity in which that issue could\n-                \/\/ happen.\n-                if (numAppContexts.get() > 0) {\n-                    \/\/ Defaults to thread group caching.\n-                    \/\/ This is probably not required as we only really need\n-                    \/\/ isolation in a deployed applet environment, in which\n-                    \/\/ case ecx will not be null when we reach here\n-                    \/\/ However it helps emulate the deployed environment,\n-                    \/\/ in tests for instance.\n-                    ecx = ecx != null ? ecx : getAppContext();\n-                }\n-\n-                \/\/ getAppletContext() may be called when initializing the main\n-                \/\/ app context - in which case mainAppContext will still be\n-                \/\/ null. To work around this issue we simply use\n-                \/\/ AppContext.threadGroup.getParent() == null instead, since\n-                \/\/ mainAppContext is the only AppContext which should have\n-                \/\/ the root TG as its thread group.\n-                \/\/ See: JDK-8023258\n-                final boolean isMainAppContext = ecx == null\n-                        || mainAppContext == ecx\n-                        || mainAppContext == null && hasRootThreadGroup(ecx);\n-\n-                return isMainAppContext ? null : ecx;\n-            }\n-\n-        });\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,381 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.ThreadInfo;\n-import java.security.CodeSource;\n-import java.security.Permission;\n-import java.security.PermissionCollection;\n-import java.security.Permissions;\n-import java.security.Policy;\n-import java.security.ProtectionDomain;\n-import java.util.Enumeration;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.logging.LogManager;\n-import java.util.logging.Logger;\n-import jdk.internal.access.JavaAWTAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * @test\n- * @bug 8065991\n- * @summary check that when LogManager is initialized, a deadlock similar\n- *          to that described in 8065709 will not occur.\n- * @modules java.base\/jdk.internal.access\n- *          java.logging\n- *          java.management\n- * @run main\/othervm LogManagerAppContextDeadlock UNSECURE\n- * @run main\/othervm LogManagerAppContextDeadlock SECURE\n- *\n- * @author danielfuchs\n- *\/\n-public class LogManagerAppContextDeadlock {\n-\n-    public static final Semaphore sem = new Semaphore(0);\n-    public static final Semaphore sem2 = new Semaphore(0);\n-    public static final Semaphore sem3 = new Semaphore(-2);\n-    public static volatile boolean goOn = true;\n-    public static volatile Exception thrown;\n-\n-    \/\/ Emulate EventQueue\n-    static class FakeEventQueue {\n-        static final Logger logger = Logger.getLogger(\"foo\");\n-    }\n-\n-    \/\/ Emulate AppContext\n-    static class FakeAppContext {\n-\n-        static final AtomicInteger numAppContexts = new AtomicInteger(0);\n-        static final class FakeAppContextLock {}\n-        static final FakeAppContextLock lock = new FakeAppContextLock();\n-        static volatile FakeAppContext appContext;\n-\n-        final FakeEventQueue queue;\n-        FakeAppContext() {\n-            appContext = this;\n-            numAppContexts.incrementAndGet();\n-            \/\/ release sem2 to let Thread t2 call Logger.getLogger().\n-            sem2.release();\n-            try {\n-                \/\/ Wait until we JavaAWTAccess is called by LogManager.\n-                \/\/ Thread 2 will call Logger.getLogger() which will\n-                \/\/ trigger a call to JavaAWTAccess - which will release\n-                \/\/ sem, thus ensuring that Thread #2 is where we want it.\n-                sem.acquire();\n-                System.out.println(\"Sem acquired: Thread #2 has called JavaAWTAccess\");\n-            } catch(InterruptedException x) {\n-                Thread.interrupted();\n-            }\n-            queue = new FakeEventQueue();\n-        }\n-\n-        static FakeAppContext getAppContext() {\n-            synchronized (lock) {\n-                if (numAppContexts.get() == 0) {\n-                    return new FakeAppContext();\n-                }\n-                return appContext;\n-            }\n-        }\n-\n-        static {\n-            SharedSecrets.setJavaAWTAccess(new JavaAWTAccess() {\n-                @Override\n-                public Object getAppletContext() {\n-                    if (numAppContexts.get() == 0) return null;\n-                    \/\/ We are in JavaAWTAccess, we can release sem and let\n-                    \/\/ FakeAppContext constructor proceeed.\n-                    System.out.println(\"Releasing Sem\");\n-                    sem.release();\n-                    return getAppContext();\n-                }\n-\n-            });\n-        }\n-\n-    }\n-\n-\n-    \/\/ Test with or without a security manager\n-    public static enum TestCase {\n-        UNSECURE, SECURE;\n-        public void run() throws Exception {\n-            System.out.println(\"Running test case: \" + name());\n-            Configure.setUp(this);\n-            test(this);\n-        }\n-    }\n-\n-    public static void test(TestCase test) throws Exception {\n-        Thread t1 = new Thread() {\n-            @Override\n-            public void run() {\n-                sem3.release();\n-                System.out.println(\"FakeAppContext.getAppContext()\");\n-                FakeAppContext.getAppContext();\n-                System.out.println(\"Done: FakeAppContext.getAppContext()\");\n-            }\n-        };\n-        t1.setDaemon(true);\n-        t1.start();\n-        Thread t2 = new Thread() {\n-            public Object logger;\n-            public void run() {\n-                sem3.release();\n-                try {\n-                    \/\/ Wait until Thread1 is in FakeAppContext constructor\n-                    sem2.acquire();\n-                    System.out.println(\"Sem2 acquired: Thread #1 will be waiting to acquire Sem\");\n-                } catch (InterruptedException ie) {\n-                    Thread.interrupted();\n-                }\n-                System.out.println(\"Logger.getLogger(name).info(name)\");\n-                \/\/ stick the logger in an instance variable to prevent it\n-                \/\/ from being garbage collected before the main thread\n-                \/\/ calls LogManager.getLogger() below.\n-                logger = Logger.getLogger(test.name());\/\/.info(name);\n-                System.out.println(\"Done: Logger.getLogger(name).info(name)\");\n-            }\n-        };\n-        t2.setDaemon(true);\n-        t2.start();\n-        System.out.println(\"Should exit now...\");\n-        Thread detector = new DeadlockDetector();\n-        detector.start();\n-\n-        \/\/ Wait for the 3 threads to start\n-        sem3.acquire();\n-\n-        \/\/ Now wait for t1 & t2 to finish, or for a deadlock to be detected.\n-        while (goOn && (t1.isAlive() || t2.isAlive())) {\n-            if (t2.isAlive()) t2.join(1000);\n-            if (test == TestCase.UNSECURE && System.getSecurityManager() == null) {\n-                \/\/ if there's no security manager, AppContext.getAppContext() is\n-                \/\/ not called -  so Thread t2 will not end up calling\n-                \/\/ sem.release(). In that case we must release the semaphore here\n-                \/\/ so that t1 can proceed.\n-                if (LogManager.getLogManager().getLogger(TestCase.UNSECURE.name()) != null) {\n-                    \/\/ means Thread t2 has created the logger\n-                    sem.release();\n-                }\n-            }\n-            if (t1.isAlive()) t1.join(1000);\n-        }\n-        if (thrown != null) {\n-            throw thrown;\n-        }\n-    }\n-\n-    \/\/ Thrown by the deadlock detector\n-    static final class DeadlockException extends RuntimeException {\n-        public DeadlockException(String message) {\n-            super(message);\n-        }\n-        @Override\n-        public void printStackTrace() {\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        if (args.length == 0) {\n-            args = new String[] { \"SECURE\" };\n-        }\n-\n-        \/\/ If we don't initialize LogManager here, there will be\n-        \/\/ a deadlock.\n-        \/\/ See <https:\/\/bugs.openjdk.org\/browse\/JDK-8065709?focusedCommentId=13582038&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13582038>\n-        \/\/ for more details.\n-        Logger.getLogger(\"main\").info(\"starting...\");\n-        try {\n-            TestCase.valueOf(args[0]).run();\n-            System.out.println(\"Test \"+args[0]+\" Passed\");\n-        } catch(Throwable t) {\n-            System.err.println(\"Test \" + args[0] +\" failed: \" + t);\n-            t.printStackTrace();\n-        }\n-    }\n-\n-    \/\/ Called by the deadlock detector when a deadlock is found.\n-    static void fail(Exception x) {\n-        x.printStackTrace();\n-        if (thrown == null) {\n-            thrown = x;\n-        }\n-        goOn = false;\n-    }\n-\n-    \/\/ A thread that detect deadlocks.\n-    static final class DeadlockDetector extends Thread {\n-\n-        public DeadlockDetector() {\n-            this.setDaemon(true);\n-        }\n-\n-        @Override\n-        public void run() {\n-            sem3.release();\n-            Configure.doPrivileged(this::loop);\n-        }\n-        public void loop() {\n-            while(goOn) {\n-                try {\n-                    long[] ids = ManagementFactory.getThreadMXBean().findDeadlockedThreads();\n-                    ids = ids == null ? new long[0] : ids;\n-                    if (ids.length == 1) {\n-                        throw new RuntimeException(\"Found 1 deadlocked thread: \"+ids[0]);\n-                    } else if (ids.length > 0) {\n-                        ThreadInfo[] infos = ManagementFactory.getThreadMXBean().getThreadInfo(ids, Integer.MAX_VALUE);\n-                        System.err.println(\"Found \"+ids.length+\" deadlocked threads: \");\n-                        for (ThreadInfo inf : infos) {\n-                            System.err.println(inf);\n-                        }\n-                        throw new DeadlockException(\"Found \"+ids.length+\" deadlocked threads\");\n-                    }\n-                    Thread.sleep(100);\n-                } catch(InterruptedException | RuntimeException x) {\n-                    fail(x);\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    \/\/ A helper class to configure the security manager for the test,\n-    \/\/ and bypass it when needed.\n-    static class Configure {\n-        static Policy policy = null;\n-        static final ThreadLocal<AtomicBoolean> allowAll = new ThreadLocal<AtomicBoolean>() {\n-            @Override\n-            protected AtomicBoolean initialValue() {\n-                return  new AtomicBoolean(false);\n-            }\n-        };\n-        static void setUp(TestCase test) {\n-            switch (test) {\n-                case SECURE:\n-                    if (policy == null && System.getSecurityManager() != null) {\n-                        throw new IllegalStateException(\"SecurityManager already set\");\n-                    } else if (policy == null) {\n-                        policy = new SimplePolicy(TestCase.SECURE, allowAll);\n-                        Policy.setPolicy(policy);\n-                        System.setSecurityManager(new SecurityManager());\n-                    }\n-                    if (System.getSecurityManager() == null) {\n-                        throw new IllegalStateException(\"No SecurityManager.\");\n-                    }\n-                    if (policy == null) {\n-                        throw new IllegalStateException(\"policy not configured\");\n-                    }\n-                    break;\n-                case UNSECURE:\n-                    if (System.getSecurityManager() != null) {\n-                        throw new IllegalStateException(\"SecurityManager already set\");\n-                    }\n-                    break;\n-                default:\n-                    new InternalError(\"No such testcase: \" + test);\n-            }\n-        }\n-        static void doPrivileged(Runnable run) {\n-            allowAll.get().set(true);\n-            try {\n-                run.run();\n-            } finally {\n-                allowAll.get().set(false);\n-            }\n-        }\n-    }\n-\n-    \/\/ A Helper class to build a set of permissions.\n-    static final class PermissionsBuilder {\n-        final Permissions perms;\n-        public PermissionsBuilder() {\n-            this(new Permissions());\n-        }\n-        public PermissionsBuilder(Permissions perms) {\n-            this.perms = perms;\n-        }\n-        public PermissionsBuilder add(Permission p) {\n-            perms.add(p);\n-            return this;\n-        }\n-        public PermissionsBuilder addAll(PermissionCollection col) {\n-            if (col != null) {\n-                for (Enumeration<Permission> e = col.elements(); e.hasMoreElements(); ) {\n-                    perms.add(e.nextElement());\n-                }\n-            }\n-            return this;\n-        }\n-        public Permissions toPermissions() {\n-            final PermissionsBuilder builder = new PermissionsBuilder();\n-            builder.addAll(perms);\n-            return builder.perms;\n-        }\n-    }\n-\n-    \/\/ Policy for the test...\n-    public static class SimplePolicy extends Policy {\n-\n-        static final Policy DEFAULT_POLICY = Policy.getPolicy();\n-\n-        final Permissions permissions;\n-        final Permissions allPermissions;\n-        final ThreadLocal<AtomicBoolean> allowAll; \/\/ actually: this should be in a thread locale\n-        public SimplePolicy(TestCase test, ThreadLocal<AtomicBoolean> allowAll) {\n-            this.allowAll = allowAll;\n-            \/\/ we don't actually need any permission to create our\n-            \/\/ FileHandlers because we're passing invalid parameters\n-            \/\/ which will make the creation fail...\n-            permissions = new Permissions();\n-            permissions.add(new RuntimePermission(\"accessClassInPackage.jdk.internal.access\"));\n-\n-            \/\/ these are used for configuring the test itself...\n-            allPermissions = new Permissions();\n-            allPermissions.add(new java.security.AllPermission());\n-\n-        }\n-\n-        @Override\n-        public boolean implies(ProtectionDomain domain, Permission permission) {\n-            if (allowAll.get().get()) return allPermissions.implies(permission);\n-            return permissions.implies(permission) || DEFAULT_POLICY.implies(domain, permission);\n-        }\n-\n-        @Override\n-        public PermissionCollection getPermissions(CodeSource codesource) {\n-            return new PermissionsBuilder().addAll(allowAll.get().get()\n-                    ? allPermissions : permissions).toPermissions();\n-        }\n-\n-        @Override\n-        public PermissionCollection getPermissions(ProtectionDomain domain) {\n-            return new PermissionsBuilder().addAll(allowAll.get().get()\n-                    ? allPermissions : permissions).toPermissions();\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/logging\/LogManagerAppContextDeadlock.java","additions":0,"deletions":381,"binary":false,"changes":381,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.io.PrintStream;\n-import java.util.logging.LogManager;\n-import java.util.logging.Logger;\n-import jdk.internal.access.JavaAWTAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/*\n- * @test\n- * @bug 8025512\n- *\n- * @summary NPE with logging while launching webstart\n- *\n- * @modules java.base\/jdk.internal.access\n- *          java.logging\n- * @build TestGetLoggerNPE\n- * @run main\/othervm TestGetLoggerNPE getLogger\n- * @run main\/othervm TestGetLoggerNPE getLogManager\n- *\/\n-public class TestGetLoggerNPE {\n-    static volatile Throwable thrown = null;\n-    public static void main(String[] args) throws Exception {\n-        final String testCase = args.length == 0 ? \"getLogger\" : args[0];\n-        final JavaAWTAccessStub access = new JavaAWTAccessStub();\n-        SharedSecrets.setJavaAWTAccess(access);\n-        final ThreadGroup tg = new ThreadGroup(\"TestGroup\");\n-        Thread t = new Thread(tg, \"test\") {\n-            public void run() {\n-                try {\n-                    access.setContext(Context.ONE);\n-                    final PrintStream out = System.out;\n-                    System.setOut(null);\n-                    try {\n-                        if (\"getLogger\".equals(testCase)) {\n-                           Logger.getLogger(\"sun.plugin\");\n-                        } else {\n-                           LogManager.getLogManager();\n-                        }\n-                    } finally {\n-                        System.setOut(out);\n-                    }\n-\n-                    System.out.println(Logger.global);\n-                } catch (Throwable x) {\n-                    x.printStackTrace();\n-                    thrown = x;\n-                }\n-            }\n-        };\n-        t.start();\n-        t.join();\n-        if (thrown == null) {\n-            System.out.println(\"PASSED: \" + testCase);\n-        } else {\n-            System.err.println(\"FAILED: \" + testCase);\n-            throw new Error(\"Test failed: \" + testCase + \" - \" + thrown, thrown);\n-        }\n-\n-    }\n-\n-    static enum Context { ONE, TWO };\n-\n-    static final class JavaAWTAccessStub implements JavaAWTAccess {\n-        private static final InheritableThreadLocal<Context> context = new InheritableThreadLocal<>();\n-\n-\n-        public void setContext(Context context) {\n-            JavaAWTAccessStub.context.set(context);\n-        }\n-\n-        @Override\n-        public Object getAppletContext() {\n-            return context.get();\n-        }\n-\n-     }\n-\n-}\n","filename":"test\/jdk\/java\/util\/logging\/TestGetLoggerNPE.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,520 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.logging.LogManager;\n-import java.util.logging.Logger;\n-import jdk.internal.access.JavaAWTAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/*\n- * @test\n- * @bug 8017174 8010727 8019945\n- * @summary  NPE when using Logger.getAnonymousLogger or\n- *           LogManager.getLogManager().getLogger\n- *\n- * @modules java.base\/jdk.internal.access\n- *          java.logging\n- * @run main\/othervm TestUILoggerContext LoadingUIContext\n- * @run main\/othervm TestUILoggerContext LoadingMain\n- * @run main\/othervm TestUILoggerContext One\n- * @run main\/othervm TestUILoggerContext Two\n- * @run main\/othervm TestUILoggerContext Three\n- * @run main\/othervm TestUILoggerContext Four\n- * @run main\/othervm TestUILoggerContext Five\n- * @run main\/othervm TestUILoggerContext Six\n- * @run main\/othervm TestUILoggerContext Seven\n- * @run main\/othervm TestUILoggerContext\n- *\/\n-\n-\/\/ NOTE: We run in other VM in order to cause LogManager class to be loaded anew.\n-public class TestUILoggerContext {\n-\n-    \/\/ The bridge class initializes the logging system.\n-    \/\/ It stubs the UI context in order to simulate context changes.\n-    \/\/\n-    public static class Bridge {\n-\n-        private static class JavaAWTAccessStub implements JavaAWTAccess {\n-            boolean active = true;\n-\n-            private static class TestExc {\n-                private final Map<Object, Object> map = new HashMap<>();\n-                void put(Object key, Object v) { map.put(key, v); }\n-                Object get(Object key) { return map.get(key); }\n-                void remove(Object o) { map.remove(o); }\n-                public static TestExc exc(Object o) {\n-                    return TestExc.class.cast(o);\n-                }\n-            }\n-\n-            TestExc exc;\n-\n-            @Override\n-            public Object getAppletContext() { return active ? exc : null; }\n-        }\n-\n-        static final JavaAWTAccessStub javaAwtAccess = new JavaAWTAccessStub();\n-        public static void init() {\n-            SharedSecrets.setJavaAWTAccess(javaAwtAccess);\n-        }\n-\n-        public static void changeContext() {\n-            System.out.println(\"... Switching to a new UI context ...\");\n-            javaAwtAccess.active = true;\n-            javaAwtAccess.exc = new JavaAWTAccessStub.TestExc();\n-        }\n-\n-        public static void desactivate() {\n-            System.out.println(\"... Running with no UI context ...\");\n-            javaAwtAccess.exc = null;\n-            javaAwtAccess.active = false;\n-        }\n-\n-        public static class CustomAnonymousLogger extends Logger {\n-            public CustomAnonymousLogger() {\n-                this(\"\");\n-            }\n-            public CustomAnonymousLogger(String name) {\n-                super(null, null);\n-                System.out.println( \" LogManager: \" +LogManager.getLogManager());\n-                System.out.println( \" getLogger: \" +LogManager.getLogManager().getLogger(name));\n-                setParent(LogManager.getLogManager().getLogger(name));\n-            }\n-        }\n-\n-        public static class CustomLogger extends Logger {\n-            CustomLogger(String name) {\n-                super(name, null);\n-            }\n-        }\n-    }\n-\n-    public static enum TestCase {\n-        LoadingUIContext, LoadingMain, One, Two, Three, Four, Five, Six, Seven;\n-        public void test() {\n-            switch(this) {\n-                \/\/ When run - each of these two tests must be\n-                \/\/ run before any other tests and before each other.\n-                case LoadingUIContext: testLoadingUIContext(); break;\n-                case LoadingMain:   testLoadingMain(); break;\n-                case One:   testOne(); break;\n-                case Two:   testTwo(); break;\n-                case Three: testThree(); break;\n-                case Four:  testFour(); break;\n-                case Five:  testFive(); break;\n-                case Six:   testSix(); break;\n-                case Seven: testSeven(); break;\n-            }\n-        }\n-        public String describe() {\n-            switch(this) {\n-                case LoadingUIContext:\n-                    return \"Test that when the LogManager class is\"\n-                        + \" loaded with UI context first,\"\n-                        + \"\\n all LoggerContexts are correctly initialized\";\n-                case LoadingMain:\n-                    return \"Test that when the LogManager class is\"\n-                        + \" loaded in  the main thread first,\"\n-                        + \"\\n all LoggerContexts are correctly initialized\";\n-                case One:\n-                    return \"Test that Logger.getAnonymousLogger()\"\n-                        + \" and new CustomAnonymousLogger() don't throw NPE\";\n-                case Two:\n-                    return \"Test that Logger.getLogger(\\\"\\\")\"\n-                            + \" does not return null nor throws NPE\";\n-                case Three:\n-                    return \"Test that LogManager.getLogManager().getLogger(\\\"\\\")\"\n-                            + \" does not return null nor throws NPE\";\n-                case Four:\n-                    return \"Test that Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)\"\n-                            + \" does not return null,\\n and that\"\n-                            + \" new CustomAnonymousLogger(Logger.GLOBAL_LOGGER_NAME)\"\n-                            + \" does not throw NPE\";\n-                case Five:\n-                    return \"Test that LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME)\"\n-                            + \"\\n does not return null nor throws NPE\";\n-                case Six:\n-                    return \"Test that manager.getLogger(Logger.GLOBAL_LOGGER_NAME)\"\n-                            + \" returns null\\n when manager is not the default\"\n-                            + \" LogManager instance.\\n\"\n-                            + \"Test adding a new logger named \\\"global\\\" in that\"\n-                            + \" non default instance.\";\n-                case Seven: return \"Test that manager.getLogger(\\\"\\\")\"\n-                            + \" returns null\\n when manager is not the default\"\n-                            + \" LogManager instance.\\n\"\n-                            + \"Test adding a new logger named \\\"\\\" in that\"\n-                            + \" non default instance.\";\n-                default: return \"Undefined\";\n-            }\n-        }\n-    };\n-\n-    \/**\n-     * @param args the command line arguments\n-     *\/\n-    public static void main(String[] args) {\n-        Bridge.init();\n-        EnumSet<TestCase> tests = EnumSet.noneOf(TestCase.class);\n-        for (String arg : args) {\n-            tests.add(TestCase.valueOf(arg));\n-        }\n-        if (args.length == 0) {\n-            tests = EnumSet.complementOf(EnumSet.of(TestCase.LoadingMain));\n-        }\n-        final EnumSet<TestCase> loadingTests =\n-            EnumSet.of(TestCase.LoadingUIContext, TestCase.LoadingMain);\n-        int testrun = 0;\n-        for (TestCase test : tests) {\n-            if (loadingTests.contains(test)) {\n-                if (testrun > 0) {\n-                    throw new UnsupportedOperationException(\"Test case \"\n-                          + test + \" must be executed first!\");\n-                }\n-            }\n-            System.out.println(\"Testing \"+ test+\": \");\n-            System.out.println(test.describe());\n-            try {\n-                test.test();\n-            } catch (Exception x) {\n-               throw new Error(String.valueOf(test)\n-                   + \"failed: \"+x+\"\\n \"+\"FAILED: \"+test.describe()+\"\\n\", x);\n-            } finally {\n-                testrun++;\n-            }\n-            Bridge.changeContext();\n-            System.out.println(\"PASSED: \"+ test);\n-        }\n-    }\n-\n-    public static void testLoadingUIContext() {\n-        Bridge.changeContext();\n-\n-        Logger bar = new Bridge.CustomLogger(\"com.foo.Bar\");\n-        LogManager.getLogManager().addLogger(bar);\n-        assertNotNull(bar.getParent());\n-        testParent(bar);\n-        testParent(LogManager.getLogManager().getLogger(\"global\"));\n-        testParent(LogManager.getLogManager().getLogger(bar.getName()));\n-\n-        Bridge.desactivate();\n-\n-        Logger foo = new Bridge.CustomLogger(\"com.foo.Foo\");\n-        boolean b = LogManager.getLogManager().addLogger(foo);\n-        assertEquals(Boolean.TRUE, Boolean.valueOf(b));\n-        assertNotNull(foo.getParent());\n-        testParent(foo);\n-        testParent(LogManager.getLogManager().getLogger(\"global\"));\n-        testParent(LogManager.getLogManager().getLogger(foo.getName()));\n-    }\n-\n-    public static void testLoadingMain() {\n-        Bridge.desactivate();\n-\n-        Logger bar = new Bridge.CustomLogger(\"com.foo.Bar\");\n-        LogManager.getLogManager().addLogger(bar);\n-        assertNotNull(bar.getParent());\n-        testParent(bar);\n-        testParent(LogManager.getLogManager().getLogger(\"global\"));\n-        testParent(LogManager.getLogManager().getLogger(bar.getName()));\n-\n-        Bridge.changeContext();\n-\n-        Logger foo = new Bridge.CustomLogger(\"com.foo.Foo\");\n-        boolean b = LogManager.getLogManager().addLogger(foo);\n-        assertEquals(Boolean.TRUE, Boolean.valueOf(b));\n-        assertNotNull(foo.getParent());\n-        testParent(foo);\n-        testParent(LogManager.getLogManager().getLogger(\"global\"));\n-        testParent(LogManager.getLogManager().getLogger(foo.getName()));\n-\n-    }\n-\n-    public static void testOne() {\n-        for (int i=0; i<3 ; i++) {\n-            Logger logger1 = Logger.getAnonymousLogger();\n-            Logger logger1b = Logger.getAnonymousLogger();\n-            Bridge.changeContext();\n-            Logger logger2 = Logger.getAnonymousLogger();\n-            Logger logger2b = Logger.getAnonymousLogger();\n-            Bridge.changeContext();\n-            Logger logger3 = new Bridge.CustomAnonymousLogger();\n-            Logger logger3b = new Bridge.CustomAnonymousLogger();\n-            Bridge.changeContext();\n-            Logger logger4 = new Bridge.CustomAnonymousLogger();\n-            Logger logger4b = new Bridge.CustomAnonymousLogger();\n-        }\n-    }\n-\n-\n-    public static void testTwo() {\n-        for (int i=0; i<3 ; i++) {\n-            Logger logger1 = Logger.getLogger(\"\");\n-            Logger logger1b = Logger.getLogger(\"\");\n-            assertNotNull(logger1);\n-            assertNotNull(logger1b);\n-            assertEquals(logger1, logger1b);\n-            Bridge.changeContext();\n-            Logger logger2 = Logger.getLogger(\"\");\n-            Logger logger2b = Logger.getLogger(\"\");\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, logger2b);\n-            assertEquals(logger1, logger2);\n-        }\n-    }\n-\n-    public static void testThree() {\n-        for (int i=0; i<3 ; i++) {\n-            Logger logger1 = LogManager.getLogManager().getLogger(\"\");\n-            Logger logger1b = LogManager.getLogManager().getLogger(\"\");\n-            assertNotNull(logger1);\n-            assertNotNull(logger1b);\n-            assertEquals(logger1, logger1b);\n-            Bridge.changeContext();\n-            Logger logger2 = LogManager.getLogManager().getLogger(\"\");\n-            Logger logger2b = LogManager.getLogManager().getLogger(\"\");\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, logger2b);\n-            assertEquals(logger1, logger2);\n-        }\n-    }\n-\n-    public static void testFour() {\n-        for (int i=0; i<3 ; i++) {\n-            Logger logger1 = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger1b = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger1);\n-            assertNotNull(logger1b);\n-            assertEquals(logger1, logger1b);\n-            Bridge.changeContext();\n-\n-            Logger logger2 = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger2b = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, logger2b);\n-\n-            assertEquals(logger1, logger2);\n-\n-            Bridge.changeContext();\n-            Logger logger3 = new Bridge.CustomAnonymousLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger3b = new Bridge.CustomAnonymousLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Bridge.changeContext();\n-            Logger logger4 = new Bridge.CustomAnonymousLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger4b = new Bridge.CustomAnonymousLogger(Logger.GLOBAL_LOGGER_NAME);\n-        }\n-    }\n-\n-    public static void testFive() {\n-        for (int i=0; i<3 ; i++) {\n-            Logger logger1 = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger1b = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger1);\n-            assertNotNull(logger1b);\n-            assertEquals(logger1, logger1b);\n-\n-            Bridge.changeContext();\n-\n-            Logger logger2 = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger2b = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, logger2b);\n-\n-            assertEquals(logger1, logger2);\n-        }\n-    }\n-\n-    \/**\n-     * This test is designed to test the behavior of additional LogManager instances.\n-     * It must be noted that if the security manager is off, then calling\n-     * Bridge.changeContext() has actually no effect.\n-     * off.\n-     **\/\n-    public static void testSix() {\n-        for (int i=0; i<3 ; i++) {\n-            Bridge.desactivate();\n-            LogManager manager = new LogManager() {};\n-            Logger logger1 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger1b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNull(logger1);\n-            assertNull(logger1b);\n-            Logger global = new Bridge.CustomLogger(Logger.GLOBAL_LOGGER_NAME);\n-            manager.addLogger(global);\n-            Logger logger2 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger2b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, global);\n-            assertEquals(logger2b, global);\n-            assertNull(manager.getLogger(\"\"));\n-            assertNull(manager.getLogger(\"\"));\n-\n-            for (int j = 0; j<3; j++) {\n-                Bridge.changeContext();\n-\n-                \/\/ this is not a supported configuration:\n-                \/\/ We are in an UI context with several log managers.\n-                \/\/ We however need to check our assumptions...\n-\n-                \/\/ UI context => root logger and global logger should also be null.\n-\n-                Logger expected = global;\n-                Logger logger3 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                Logger logger3b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                assertEquals(expected, logger3);\n-                assertEquals(expected, logger3b);\n-                Logger global2 = new Bridge.CustomLogger(Logger.GLOBAL_LOGGER_NAME);\n-                manager.addLogger(global2);\n-                Logger logger4 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                Logger logger4b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                assertNotNull(logger4);\n-                assertNotNull(logger4b);\n-                expected = global;\n-                assertEquals(logger4,  expected);\n-                assertEquals(logger4b, expected);\n-\n-                Logger logger5 = manager.getLogger(\"\");\n-                Logger logger5b = manager.getLogger(\"\");\n-                Logger expectedRoot = null;\n-                assertEquals(logger5, expectedRoot);\n-                assertEquals(logger5b, expectedRoot);\n-            }\n-\n-        }\n-    }\n-\n-    \/**\n-     * This test is designed to test the behavior of additional LogManager instances.\n-     * It must be noted that if the security manager is off, then calling\n-     * Bridge.changeContext() has actually no effect.\n-     **\/\n-    public static void testSeven() {\n-        for (int i=0; i<3 ; i++) {\n-            Bridge.desactivate();\n-            LogManager manager = new LogManager() {};\n-            Logger logger1 = manager.getLogger(\"\");\n-            Logger logger1b = manager.getLogger(\"\");\n-            assertNull(logger1);\n-            assertNull(logger1b);\n-            Logger global = new Bridge.CustomLogger(Logger.GLOBAL_LOGGER_NAME);\n-            manager.addLogger(global);\n-            Logger logger2 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            Logger logger2b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-            assertNotNull(logger2);\n-            assertNotNull(logger2b);\n-            assertEquals(logger2, global);\n-            assertEquals(logger2b, global);\n-            Logger logger3 = manager.getLogger(\"\");\n-            Logger logger3b = manager.getLogger(\"\");\n-            assertNull(logger3);\n-            assertNull(logger3b);\n-            Logger root = new Bridge.CustomLogger(\"\");\n-            manager.addLogger(root);\n-            Logger logger4 = manager.getLogger(\"\");\n-            Logger logger4b = manager.getLogger(\"\");\n-            assertNotNull(logger4);\n-            assertNotNull(logger4b);\n-            assertEquals(logger4, root);\n-            assertEquals(logger4b, root);\n-\n-            for (int j = 0 ; j < 3 ; j++) {\n-                Bridge.changeContext();\n-\n-                \/\/ this is not a supported configuration:\n-                \/\/ We are in an UI context with several log managers.\n-                \/\/ We however need to check our assumptions...\n-\n-                \/\/ UI context => root logger and global logger should also be null.\n-\n-                Logger logger5 = manager.getLogger(\"\");\n-                Logger logger5b = manager.getLogger(\"\");\n-                Logger expectedRoot = root;\n-                assertEquals(logger5, expectedRoot);\n-                assertEquals(logger5b, expectedRoot);\n-\n-                assertEquals(global, manager.getLogger(Logger.GLOBAL_LOGGER_NAME));\n-\n-                Logger global2 = new Bridge.CustomLogger(Logger.GLOBAL_LOGGER_NAME);\n-                manager.addLogger(global2);\n-                Logger logger6 = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                Logger logger6b = manager.getLogger(Logger.GLOBAL_LOGGER_NAME);\n-                Logger expectedGlobal = global;\n-\n-                assertNotNull(logger6);\n-                assertNotNull(logger6b);\n-                assertEquals(logger6, expectedGlobal);\n-                assertEquals(logger6b, expectedGlobal);\n-                assertEquals(root, manager.getLogger(\"\"));\n-\n-                Logger root2 = new Bridge.CustomLogger(\"\");\n-                manager.addLogger(root2);\n-                expectedRoot = root;\n-                Logger logger7 = manager.getLogger(\"\");\n-                Logger logger7b = manager.getLogger(\"\");\n-                assertNotNull(logger7);\n-                assertNotNull(logger7b);\n-                assertEquals(logger7, expectedRoot);\n-                assertEquals(logger7b, expectedRoot);\n-            }\n-        }\n-    }\n-\n-    public static void testParent(Logger logger) {\n-        Logger l = logger;\n-        while (l.getParent() != null) {\n-            l = l.getParent();\n-        }\n-        assertEquals(\"\", l.getName());\n-    }\n-\n-    public static class TestError extends RuntimeException {\n-        public TestError(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    public static void assertNotNull(Object obj) {\n-        if (obj == null) throw new NullPointerException();\n-    }\n-\n-    public static void assertNull(Object obj) {\n-        if (obj != null) throw new TestError(\"Null expected, got \"+obj);\n-    }\n-\n-    public static void assertEquals(Object o1, Object o2) {\n-        if (o1 != o2) {\n-            throw new TestError(o1 + \" != \" + o2);\n-        }\n-    }\n-\n-    public static void assertNotEquals(Object o1, Object o2) {\n-        if (o1 == o2) {\n-            throw new TestError(o1 + \" == \" + o2);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/logging\/TestUILoggerContext.java","additions":0,"deletions":520,"binary":false,"changes":520,"status":"deleted"}]}