{"files":[{"patch":"@@ -1018,0 +1018,40 @@\n+    \/\/ Wrapper Collections\n+\n+    \/*\n+     * This segment of the file contains several groups of APIs and implementation\n+     * classes for specialized collections. These groups include, in order:\n+     *\n+     *  - Unmodifiable Wrappers\n+     *  - Synchronized Wrappers\n+     *  - Checked (dynamically typesafe) Wrappers\n+     *  - Empty Collections\n+     *  - Singleton Collections\n+     *\n+     * There are a large number of collection implementations in this file, and\n+     * for the sake of brevity, the code generally follows these style rules:\n+     *\n+     * 1. Single-line methods are often written with the implementation on the same\n+     * line as the declaration. Sometimes the braces for a group of such methods\n+     * are aligned.\n+     *\n+     * 2. The wrapper collections change the semantics of the collection interfaces,\n+     * sometimes in fundamental ways. Thus they shouldn't inherit any default methods\n+     * provided by the collection interfaces, as they might not support the right semantics.\n+     * Thus, the wrapper collections generally must override all default methods. (However,\n+     * it's permitted for a subclass of a wrapper to inherit methods from a wrapper\n+     * superclass.) Strictly speaking not every default method needs to be be overridden.\n+     * However, there is a history of bugs caused by inheriting default methods, and the\n+     * rules for when a default method must be overridden are subtle and error-prone. Thus\n+     * we've adopted the simpler, blanket rule of avoiding inheritance of all default methods.\n+     * This rule is enforced by the test test\/jdk\/java\/util\/Collections\/Wrappers.java .\n+     *\n+     * 3. Given the large number of overrides that must be present in many implementations,\n+     * the @Override annotation is generally not used. For the most part any methods that\n+     * are intended to override but are declared improperly will be detected through testing.\n+     * (The @Override annotation still occurs in several places in this file. These will be\n+     * removed over time.)\n+     *\n+     * 4. Blank lines are included somewhat inconsistently between methods in each wrapper\n+     * implementation, but they are often omitted in order to save vertical space.\n+     *\/\n+\n@@ -1361,0 +1401,10 @@\n+        public void addFirst(E e)          {throw new UnsupportedOperationException();}\n+        public void addLast(E e)           {throw new UnsupportedOperationException();}\n+        public E getFirst()                {return ss.getFirst();}\n+        public E getLast()                 {return ss.getLast();}\n+        public E removeFirst()             {throw new UnsupportedOperationException();}\n+        public E removeLast()              {throw new UnsupportedOperationException();}\n+\n+        public SortedSet<E> reversed() {\n+            return new UnmodifiableSortedSet<>(ss.reversed());\n+        }\n@@ -1442,0 +1492,7 @@\n+        public void addFirst(E e){ throw new UnsupportedOperationException(); }\n+        public void addLast(E e) { throw new UnsupportedOperationException(); }\n+        public E getFirst()                           { return ns.getFirst(); }\n+        public E getLast()                             { return ns.getLast(); }\n+        public E removeFirst()   { throw new UnsupportedOperationException(); }\n+        public E removeLast()    { throw new UnsupportedOperationException(); }\n+\n@@ -1456,0 +1513,4 @@\n+\n+        public NavigableSet<E> reversed() {\n+            return new UnmodifiableNavigableSet<>(ns.reversed());\n+        }\n@@ -1525,0 +1586,1 @@\n+\n@@ -1530,0 +1592,11 @@\n+        public void addFirst(E e) { throw new UnsupportedOperationException(); }\n+        public void addLast(E e)  { throw new UnsupportedOperationException(); }\n+        public E getFirst()       { return list.getFirst(); }\n+        public E getLast()        { return list.getLast(); }\n+        public E removeFirst()    { throw new UnsupportedOperationException(); }\n+        public E removeLast()     { throw new UnsupportedOperationException(); }\n+\n+        public List<E> reversed() {\n+            return ReverseOrderListView.of(this, false);\n+        }\n+\n@@ -2534,0 +2607,1 @@\n+\n@@ -2537,0 +2611,38 @@\n+\n+        public void addFirst(E element) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void addLast(E element) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public E getFirst() {\n+            synchronized (mutex) {\n+                return ss.getFirst();\n+            }\n+        }\n+\n+        public E getLast() {\n+            synchronized (mutex) {\n+                return ss.getLast();\n+            }\n+        }\n+\n+        public E removeFirst() {\n+            synchronized (mutex) {\n+                return ss.removeFirst();\n+            }\n+        }\n+\n+        public E removeLast() {\n+            synchronized (mutex) {\n+                return ss.removeLast();\n+            }\n+        }\n+\n+        public SortedSet<E> reversed() {\n+            synchronized (mutex) {\n+                return new SynchronizedSortedSet<>(ss.reversed(), mutex);\n+            }\n+        }\n@@ -2656,0 +2768,6 @@\n+\n+        public NavigableSet<E> reversed() {\n+            synchronized (mutex) {\n+                return new SynchronizedNavigableSet<>(ns.reversed(), mutex);\n+            }\n+        }\n@@ -3728,0 +3846,21 @@\n+        public void addFirst(E element) {\n+            throw new UnsupportedOperationException();\n+        }\n+        public void addLast(E element) {\n+            throw new UnsupportedOperationException();\n+        }\n+        public E getFirst() {\n+            return ss.getFirst();\n+        }\n+        public E getLast() {\n+            return ss.getLast();\n+        }\n+        public E removeFirst() {\n+            return ss.removeFirst();\n+        }\n+        public E removeLast() {\n+            return ss.removeLast();\n+        }\n+        public SortedSet<E> reversed() {\n+            return checkedSortedSet(ss.reversed(), type);\n+        }\n@@ -3813,0 +3952,4 @@\n+\n+        public NavigableSet<E> reversed() {\n+            return checkedNavigableSet(ns.reversed(), type);\n+        }\n@@ -3935,0 +4078,28 @@\n+\n+        public void addFirst(E element) {\n+            list.addFirst(typeCheck(element));\n+        }\n+\n+        public void addLast(E element) {\n+            list.addLast(typeCheck(element));\n+        }\n+\n+        public E getFirst() {\n+            return list.getFirst();\n+        }\n+\n+        public E getLast() {\n+            return list.getLast();\n+        }\n+\n+        public E removeFirst() {\n+            return list.removeFirst();\n+        }\n+\n+        public E removeLast() {\n+            return list.removeLast();\n+        }\n+\n+        public List<E> reversed() {\n+            return new CheckedList<>(list.reversed(), type);\n+        }\n@@ -3954,0 +4125,9 @@\n+\n+        public List<E> reversed() {\n+            var rev = list.reversed();\n+            if (rev instanceof RandomAccess) {\n+                return new CheckedRandomAccessList<>(rev, type);\n+            } else {\n+                return new CheckedList<>(rev, type);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n@@ -106,0 +111,7 @@\n+            \/\/ override default methods to quiet the java\/util\/Collections\/Wrappers test\n+            public void forEach(Consumer<? super K> action) { super.forEach(action); }\n+            public boolean removeIf(Predicate<? super K> filter) { return super.removeIf(filter); }\n+            public Stream<K> parallelStream() { return super.parallelStream(); }\n+            public Spliterator<K> spliterator() { return super.spliterator(); }\n+            public Stream<K> stream() { return super.stream(); }\n+            public <T> T[] toArray(IntFunction<T[]> generator) { return super.toArray(generator); }\n@@ -117,0 +129,7 @@\n+            \/\/ override default methods to quiet the java\/util\/Collections\/Wrappers test\n+            public void forEach(Consumer<? super V> action) { super.forEach(action); }\n+            public boolean removeIf(Predicate<? super V> filter) { return super.removeIf(filter); }\n+            public Stream<V> parallelStream() { return super.parallelStream(); }\n+            public Spliterator<V> spliterator() { return super.spliterator(); }\n+            public Stream<V> stream() { return super.stream(); }\n+            public <T> T[] toArray(IntFunction<T[]> generator) { return super.toArray(generator); }\n@@ -128,0 +147,7 @@\n+            \/\/ override default methods to quiet the java\/util\/Collections\/Wrappers test\n+            public void forEach(Consumer<? super Entry<K,V>> action) { super.forEach(action); }\n+            public boolean removeIf(Predicate<? super Entry<K,V>> filter) { return super.removeIf(filter); }\n+            public Stream<Entry<K,V>> parallelStream() { return super.parallelStream(); }\n+            public Spliterator<Entry<K,V>> spliterator() { return super.spliterator(); }\n+            public Stream<Entry<K,V>> stream() { return super.stream(); }\n+            public <T> T[] toArray(IntFunction<T[]> generator) { return super.toArray(generator); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedMapView.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Ensure Collections wrapping classes provide non-default implementations\n+ * @summary Ensures that Collections wrapper classes do not inherit default\n+ *          method implementations.\n@@ -32,0 +33,1 @@\n+import java.util.Arrays;\n@@ -34,0 +36,1 @@\n+import java.util.Formatter;\n@@ -36,0 +39,1 @@\n+import java.util.SequencedMap;\n@@ -39,0 +43,1 @@\n+import org.testng.annotations.AfterClass;\n@@ -46,1 +51,1 @@\n-    static Object[][] collections;\n+    static int inheritedCount = 0;\n@@ -48,4 +53,16 @@\n-    @DataProvider(name=\"collections\")\n-    public static Object[][] collectionCases() {\n-        if (collections != null) {\n-            return collections;\n+    @AfterClass\n+    public void printCount() {\n+        System.out.println(\">>>> Total inherited default methods = \" + inheritedCount);\n+    }\n+\n+    static void addSequencedMapViews(List<Object[]> cases, SequencedMap<?, ?> seqMap) {\n+        for (var map : List.of(seqMap, seqMap.reversed())) {\n+            cases.add(new Object[] { map.entrySet() });\n+            cases.add(new Object[] { map.keySet() });\n+            cases.add(new Object[] { map.values() });\n+            cases.add(new Object[] { map.sequencedEntrySet() });\n+            cases.add(new Object[] { map.sequencedKeySet() });\n+            cases.add(new Object[] { map.sequencedValues() });\n+            cases.add(new Object[] { map.sequencedEntrySet().reversed() });\n+            cases.add(new Object[] { map.sequencedKeySet().reversed() });\n+            cases.add(new Object[] { map.sequencedValues().reversed() });\n@@ -53,0 +70,1 @@\n+    }\n@@ -54,0 +72,2 @@\n+    @DataProvider(name=\"collections\")\n+    public static Object[][] collectionCases() {\n@@ -67,0 +87,2 @@\n+        \/\/ Unmodifiable collections\n+\n@@ -76,2 +98,2 @@\n-        \/\/ As sets from map also need to be unmodifiable, thus a wrapping\n-        \/\/ layer exist and should not have default methods\n+        \/\/ Views of unmodifiable maps\n+\n@@ -81,26 +103,7 @@\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).entrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).keySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).values() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().entrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().keySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().values() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedEntrySet().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedKeySet().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).sequencedValues().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedEntrySet().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedKeySet().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSequencedMap(seedMap).reversed().sequencedValues().reversed() });\n-        cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).entrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).keySet() });\n-        cases.add(new Object[] { Collections.unmodifiableSortedMap(seedMap).values() });\n-        cases.add(new Object[] { Collections.unmodifiableNavigableMap(seedMap).entrySet() });\n-        cases.add(new Object[] { Collections.unmodifiableNavigableMap(seedMap).keySet() });\n-        cases.add(new Object[] { Collections.unmodifiableNavigableMap(seedMap).values() });\n-\n-        \/\/ Synchronized\n+\n+        addSequencedMapViews(cases, Collections.unmodifiableSequencedMap(seedMap));\n+        addSequencedMapViews(cases, Collections.unmodifiableSortedMap(seedMap));\n+        addSequencedMapViews(cases, Collections.unmodifiableNavigableMap(seedMap));\n+\n+        \/\/ Synchronized collections\n+\n@@ -114,2 +117,2 @@\n-        \/\/ As sets from map also need to be synchronized on the map, thus a\n-        \/\/ wrapping layer exist and should not have default methods\n+        \/\/ Views of synchronized maps\n+\n@@ -119,8 +122,6 @@\n-        cases.add(new Object[] { Collections.synchronizedSortedMap(seedMap).entrySet() });\n-        cases.add(new Object[] { Collections.synchronizedSortedMap(seedMap).keySet() });\n-        cases.add(new Object[] { Collections.synchronizedSortedMap(seedMap).values() });\n-        cases.add(new Object[] { Collections.synchronizedNavigableMap(seedMap).entrySet() });\n-        cases.add(new Object[] { Collections.synchronizedNavigableMap(seedMap).keySet() });\n-        cases.add(new Object[] { Collections.synchronizedNavigableMap(seedMap).values() });\n-\n-        \/\/ Checked\n+\n+        addSequencedMapViews(cases, Collections.synchronizedSortedMap(seedMap));\n+        addSequencedMapViews(cases, Collections.synchronizedNavigableMap(seedMap));\n+\n+        \/\/ Checked collections\n+\n@@ -135,0 +136,6 @@\n+        \/\/ Omit views of checked maps for now. In general, checked maps' keySet and values views\n+        \/\/ don't have any operations that need checking and so they're simply the views from\n+        \/\/ the underlying map. The checked maps' entrySet views' only responsibilities are to\n+        \/\/ provide checked map entries. This is done by the iterator() and toArray() methods,\n+        \/\/ and most other things are inherited, including default methods.\n+\n@@ -138,2 +145,1 @@\n-        collections = cases.toArray(new Object[0][]);\n-        return collections;\n+        return cases.toArray(new Object[0][]);\n@@ -142,1 +148,8 @@\n-    static Method[] defaultMethods;\n+    @Test(dataProvider = \"collections\")\n+    public static void testNoDefaultMethodsInherited(Collection<?> c) {\n+        List<Method> inherited = Arrays.stream(c.getClass().getMethods())\n+                                       .filter(Method::isDefault)\n+                                       .toList();\n+        inheritedCount += inherited.size();\n+        assertTrue(inherited.isEmpty(), generateReport(c, inherited));\n+    }\n@@ -144,7 +157,3 @@\n-    static {\n-        List<Method> list = new ArrayList<>();\n-        Method[] methods = Collection.class.getMethods();\n-        for (Method m: methods) {\n-            if (m.isDefault()) {\n-                list.add(m);\n-            }\n+    static String generateReport(Collection<?> c, List<Method> inherited) {\n+        if (inherited.isEmpty()) {\n+            return \"\";\n@@ -152,2 +161,0 @@\n-        defaultMethods = list.toArray(new Method[0]);\n-    }\n@@ -155,9 +162,4 @@\n-    @Test(dataProvider = \"collections\")\n-    public static void testAllDefaultMethodsOverridden(Collection c) throws NoSuchMethodException {\n-        Class cls = c.getClass();\n-        var notOverridden = new ArrayList<Method>();\n-        for (Method m: defaultMethods) {\n-            Method m2 = cls.getMethod(m.getName(), m.getParameterTypes());\n-            if (m2.isDefault()) {\n-                notOverridden.add(m);\n-            }\n+        var f = new Formatter();\n+        f.format(\"%s inherits the following:%n\", c.getClass().getName());\n+        for (int i = 0; i < inherited.size(); i++) {\n+            f.format(\"  %d. %s%n\", i+1, inherited.get(i));\n@@ -165,1 +167,1 @@\n-        assertTrue(notOverridden.isEmpty(), cls.getName() + \" does not override \" + notOverridden);\n+        return f.toString();\n","filename":"test\/jdk\/java\/util\/Collections\/Wrappers.java","additions":69,"deletions":67,"binary":false,"changes":136,"status":"modified"}]}