{"files":[{"patch":"@@ -615,1 +615,0 @@\n- * cgroup cpu shares\n@@ -626,2 +625,2 @@\n- * If quotas have not been specified, return the\n- * number of active processors in the system.\n+ * If quotas have not been specified, sets the result reference to\n+ * the number of active processors in the system.\n@@ -629,2 +628,2 @@\n- * If quotas have been specified, the resulting number\n- * returned will never exceed the number of active processors.\n+ * If quotas have been specified, the number set in the result\n+ * reference will never exceed the number of active processors.\n@@ -633,1 +632,1 @@\n- *    number of CPUs\n+ *    true if there were no errors. false otherwise.\n@@ -635,2 +634,1 @@\n-int CgroupSubsystem::active_processor_count() {\n-  int quota_count = 0;\n+bool CgroupSubsystem::active_processor_count(int& value) {\n@@ -638,1 +636,1 @@\n-  int result;\n+  int result = -1;\n@@ -646,3 +644,3 @@\n-    int val = (int)cpu_limit->value();\n-    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n-    return val;\n+    value = (int)cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", value);\n+    return true;\n@@ -652,1 +650,4 @@\n-  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n+  if (!CgroupUtil::processor_count(contrl->controller(), cpu_count, result)) {\n+    return false;\n+  }\n+  assert(result > 0 && result <= cpu_count, \"must be\");\n@@ -655,0 +656,1 @@\n+  value = result;\n@@ -656,1 +658,1 @@\n-  return result;\n+  return true;\n@@ -661,1 +663,3 @@\n- * Return the limit of available memory for this process.\n+ * Return the limit of available memory for this process in the provided\n+ * physical_memory_size_type reference. If there was no limit value set in the underlying\n+ * interface files 'value_unlimited' is returned.\n@@ -664,3 +668,3 @@\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false if retrieving the value failed\n+ *    true if retrieving the value was successfull and the value was\n+ *    set in the 'value' reference.\n@@ -668,1 +672,2 @@\n-jlong CgroupSubsystem::memory_limit_in_bytes(julong upper_bound) {\n+bool CgroupSubsystem::memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) {\n@@ -672,1 +677,6 @@\n-    return memory_limit->value();\n+    value = memory_limit->value();\n+    return true;\n+  }\n+  physical_memory_size_type mem_limit = 0;\n+  if (!contrl->controller()->read_memory_limit_in_bytes(upper_bound, mem_limit)) {\n+    return false;\n@@ -674,1 +684,0 @@\n-  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(upper_bound);\n@@ -677,1 +686,2 @@\n-  return mem_limit;\n+  value = mem_limit;\n+  return true;\n@@ -722,1 +732,1 @@\n-bool CgroupController::read_number(const char* filename, julong* result) {\n+bool CgroupController::read_number(const char* filename, uint64_t& result) {\n@@ -728,1 +738,1 @@\n-  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  int matched = sscanf(buf, UINT64_FORMAT, &result);\n@@ -735,1 +745,1 @@\n-bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+bool CgroupController::read_number_handle_max(const char* filename, uint64_t& result) {\n@@ -741,2 +751,2 @@\n-  jlong val = limit_from_str(buf);\n-  if (val == OSCONTAINER_ERROR) {\n+  uint64_t val = 0;\n+  if (!limit_from_str(buf, val)) {\n@@ -745,1 +755,1 @@\n-  *result = val;\n+  result = val;\n@@ -749,1 +759,1 @@\n-bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, uint64_t& result) {\n@@ -751,1 +761,0 @@\n-  assert(result != nullptr, \"result pointer must not be null\");\n@@ -789,1 +798,1 @@\n-      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      int matched = sscanf(value_substr, UINT64_FORMAT, &result);\n@@ -800,1 +809,1 @@\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", UINT64_FORMAT,\n@@ -805,1 +814,1 @@\n-bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, uint64_t& result) {\n@@ -816,2 +825,2 @@\n-  jlong val = limit_from_str(token);\n-  if (val == OSCONTAINER_ERROR) {\n+  uint64_t val = 0;\n+  if (!limit_from_str(token, val)) {\n@@ -820,1 +829,1 @@\n-  *result = val;\n+  result = val;\n@@ -824,1 +833,1 @@\n-jlong CgroupController::limit_from_str(char* limit_str) {\n+bool CgroupController::limit_from_str(char* limit_str, uint64_t& value) {\n@@ -826,1 +835,1 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n@@ -831,1 +840,2 @@\n-    return (jlong)-1;\n+    value = value_unlimited;\n+    return true;\n@@ -833,3 +843,3 @@\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    return OSCONTAINER_ERROR;\n+  uint64_t limit;\n+  if (sscanf(limit_str, UINT64_FORMAT, &limit) != 1) {\n+    return false;\n@@ -837,1 +847,2 @@\n-  return (jlong)limit;\n+  value = limit;\n+  return true;\n@@ -841,3 +852,6 @@\n-\n-jlong CgroupSubsystem::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n+bool CgroupSubsystem::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                     physical_memory_size_type upper_swap_bound,\n+                                                     physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(upper_mem_bound,\n+                                                                           upper_swap_bound,\n+                                                                           value);\n@@ -846,2 +860,6 @@\n-jlong CgroupSubsystem::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(upper_mem_bound, upper_swap_bound);\n+bool CgroupSubsystem::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                     physical_memory_size_type upper_swap_bound,\n+                                                     physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(upper_mem_bound,\n+                                                                           upper_swap_bound,\n+                                                                           value);\n@@ -850,2 +868,3 @@\n-jlong CgroupSubsystem::memory_soft_limit_in_bytes(julong upper_bound) {\n-  return memory_controller()->controller()->memory_soft_limit_in_bytes(upper_bound);\n+bool CgroupSubsystem::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                 physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(upper_bound, value);\n@@ -854,2 +873,2 @@\n-jlong CgroupSubsystem::memory_throttle_limit_in_bytes() {\n-  return memory_controller()->controller()->memory_throttle_limit_in_bytes();\n+bool CgroupSubsystem::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_throttle_limit_in_bytes(value);\n@@ -858,2 +877,2 @@\n-jlong CgroupSubsystem::memory_usage_in_bytes() {\n-  return memory_controller()->controller()->memory_usage_in_bytes();\n+bool CgroupSubsystem::memory_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_usage_in_bytes(value);\n@@ -862,2 +881,2 @@\n-jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n-  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+bool CgroupSubsystem::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes(value);\n@@ -866,2 +885,2 @@\n-jlong CgroupSubsystem::rss_usage_in_bytes() {\n-  return memory_controller()->controller()->rss_usage_in_bytes();\n+bool CgroupSubsystem::rss_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->rss_usage_in_bytes(value);\n@@ -870,2 +889,2 @@\n-jlong CgroupSubsystem::cache_usage_in_bytes() {\n-  return memory_controller()->controller()->cache_usage_in_bytes();\n+bool CgroupSubsystem::cache_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->cache_usage_in_bytes(value);\n@@ -874,2 +893,2 @@\n-int CgroupSubsystem::cpu_quota() {\n-  return cpu_controller()->controller()->cpu_quota();\n+bool CgroupSubsystem::cpu_quota(int& value) {\n+  return cpu_controller()->controller()->cpu_quota(value);\n@@ -878,2 +897,2 @@\n-int CgroupSubsystem::cpu_period() {\n-  return cpu_controller()->controller()->cpu_period();\n+bool CgroupSubsystem::cpu_period(int& value) {\n+  return cpu_controller()->controller()->cpu_period(value);\n@@ -882,2 +901,2 @@\n-int CgroupSubsystem::cpu_shares() {\n-  return cpu_controller()->controller()->cpu_shares();\n+bool CgroupSubsystem::cpu_shares(int& value) {\n+  return cpu_controller()->controller()->cpu_shares(value);\n@@ -886,2 +905,2 @@\n-jlong CgroupSubsystem::cpu_usage_in_micros() {\n-  return cpuacct_controller()->cpu_usage_in_micros();\n+bool CgroupSubsystem::cpu_usage_in_micros(uint64_t& value) {\n+  return cpuacct_controller()->cpu_usage_in_micros(value);\n@@ -890,1 +909,1 @@\n-void CgroupSubsystem::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n+void CgroupSubsystem::print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) {\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":88,"deletions":69,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  is_ok = controller->read_number(filename, &retval);                                 \\\n+  is_ok = controller->read_number(filename, retval);                                  \\\n@@ -77,2 +77,2 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n-    return OSCONTAINER_ERROR;                                                         \\\n+    log_trace(os, container)(log_string \" failed\");                                   \\\n+    return false;                                                                     \\\n@@ -80,1 +80,2 @@\n-  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n+  log_trace(os, container)(log_string \" is: \" UINT64_FORMAT, retval);                 \\\n+  return true;                                                                        \\\n@@ -86,1 +87,1 @@\n-  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  is_ok = controller->read_number_handle_max(filename, retval);                       \\\n@@ -88,2 +89,2 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n-    return OSCONTAINER_ERROR;                                                         \\\n+    log_trace(os, container)(log_string \" failed\");                                   \\\n+    return false;                                                                     \\\n@@ -91,1 +92,6 @@\n-  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n+  if (retval == value_unlimited) {                                                    \\\n+    log_trace(os, container)(log_string \" is: unlimited\");                            \\\n+  } else {                                                                            \\\n+    log_trace(os, container)(log_string \" is: \" UINT64_FORMAT, retval);               \\\n+  }                                                                                   \\\n+  return true;                                                                        \\\n@@ -99,1 +105,1 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);                \\\n+    log_trace(os, container)(log_string \" failed\");                                       \\\n@@ -108,1 +114,1 @@\n-  is_ok = controller->read_numerical_key_value(filename, key, &retval);               \\\n+  is_ok = controller->read_numerical_key_value(filename, key, retval);                \\\n@@ -110,2 +116,2 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n-    return OSCONTAINER_ERROR;                                                         \\\n+    log_trace(os, container)(log_string \" failed\");                                   \\\n+    return false;                                                                     \\\n@@ -113,1 +119,2 @@\n-  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n+  log_trace(os, container)(log_string \" is: \" UINT64_FORMAT, retval);                 \\\n+  return true;                                                                        \\\n@@ -127,1 +134,1 @@\n-    \/* Read a numerical value as unsigned long\n+    \/* Read a numerical value as uint64_t\n@@ -130,1 +137,1 @@\n-     * the parsed value is set in the provided julong pointer.\n+     * the parsed value is set in the provided result reference.\n@@ -132,1 +139,1 @@\n-    bool read_number(const char* filename, julong* result);\n+    bool read_number(const char* filename, uint64_t& result);\n@@ -138,2 +145,3 @@\n-     * the parsed value (which might be negative) is being set in\n-     * the provided jlong pointer.\n+     * the parsed value will be set in the provided result reference.\n+     * When the value was the string 'max' then 'value_unlimited' is\n+     * being set as the value.\n@@ -141,1 +149,1 @@\n-    bool read_number_handle_max(const char* filename, jlong* result);\n+    bool read_number_handle_max(const char* filename, uint64_t& result);\n@@ -159,1 +167,1 @@\n-     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     * value of the appropriate tuple entry set in the provided result reference.\n@@ -161,1 +169,1 @@\n-    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, uint64_t& result);\n@@ -165,1 +173,1 @@\n-     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     * via the passed in result reference. Example interface file 'memory.stat'\n@@ -168,1 +176,1 @@\n-     * being set in the provided julong pointer.\n+     * being set in the provided result reference.\n@@ -170,1 +178,1 @@\n-    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+    bool read_numerical_key_value(const char* filename, const char* key, uint64_t& result);\n@@ -173,1 +181,1 @@\n-    static jlong limit_from_str(char* limit_str);\n+    static bool limit_from_str(char* limit_str, physical_memory_size_type& value);\n@@ -178,1 +186,1 @@\n-    volatile jlong _metric;\n+    volatile physical_memory_size_type _metric;\n@@ -182,1 +190,1 @@\n-      _metric = -1;\n+      _metric = value_unlimited;\n@@ -188,2 +196,2 @@\n-    jlong value() { return _metric; }\n-    void set_value(jlong value, jlong timeout) {\n+    physical_memory_size_type value() { return _metric; }\n+    void set_value(physical_memory_size_type value, jlong timeout) {\n@@ -219,3 +227,3 @@\n-    virtual int cpu_quota() = 0;\n-    virtual int cpu_period() = 0;\n-    virtual int cpu_shares() = 0;\n+    virtual bool cpu_quota(int& value) = 0;\n+    virtual bool cpu_period(int& value) = 0;\n+    virtual bool cpu_shares(int& value) = 0;\n@@ -233,1 +241,1 @@\n-    virtual jlong cpu_usage_in_micros() = 0;\n+    virtual bool cpu_usage_in_micros(uint64_t& value) = 0;\n@@ -245,10 +253,16 @@\n-    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_usage_in_bytes() = 0;\n-    virtual jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n-    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_throttle_limit_in_bytes() = 0;\n-    virtual jlong memory_max_usage_in_bytes() = 0;\n-    virtual jlong rss_usage_in_bytes() = 0;\n-    virtual jlong cache_usage_in_bytes() = 0;\n-    virtual void print_version_specific_info(outputStream* st, julong upper_mem_bound) = 0;\n+    virtual bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) = 0;\n+    virtual bool memory_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                physical_memory_size_type upper_swap_bound,\n+                                                physical_memory_size_type& value) = 0;\n+    virtual bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                physical_memory_size_type upper_swap_bound,\n+                                                physical_memory_size_type& value) = 0;\n+    virtual bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) = 0;\n+    virtual bool memory_throttle_limit_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool memory_max_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool rss_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool cache_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) = 0;\n@@ -265,2 +279,2 @@\n-    jlong memory_limit_in_bytes(julong upper_bound);\n-    int active_processor_count();\n+    bool memory_limit_in_bytes(physical_memory_size_type upper_bound, physical_memory_size_type& value);\n+    bool active_processor_count(int& value);\n@@ -268,2 +282,2 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual bool pids_max(uint64_t& value) = 0;\n+    virtual bool pids_current(uint64_t& value) = 0;\n@@ -279,15 +293,20 @@\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n-\n-    jlong cpu_usage_in_micros();\n-\n-    jlong memory_usage_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n-    jlong memory_soft_limit_in_bytes(julong upper_bound);\n-    jlong memory_throttle_limit_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound);\n+    bool cpu_quota(int& value);\n+    bool cpu_period(int& value);\n+    bool cpu_shares(int& value);\n+\n+    bool cpu_usage_in_micros(uint64_t& value);\n+\n+    bool memory_usage_in_bytes(physical_memory_size_type& value);\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& value);\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& value);\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& value);\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& value);\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& value);\n+    bool rss_usage_in_bytes(physical_memory_size_type& value);\n+    bool cache_usage_in_bytes(physical_memory_size_type& value);\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":81,"deletions":62,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -28,5 +28,11 @@\n-int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n-  assert(host_cpus > 0, \"physical host cpus must be positive\");\n-  int limit_count = host_cpus;\n-  int quota  = cpu_ctrl->cpu_quota();\n-  int period = cpu_ctrl->cpu_period();\n+bool CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int upper_bound, int& value) {\n+  assert(upper_bound > 0, \"upper bound of cpus must be positive\");\n+  int limit_count = upper_bound;\n+  int quota = -1;\n+  int period = -1;\n+  if (!cpu_ctrl->cpu_quota(quota)) {\n+    return false;\n+  }\n+  if (!cpu_ctrl->cpu_period(period)) {\n+    return false;\n+  }\n@@ -34,1 +40,1 @@\n-  int result = 0;\n+  int result = upper_bound;\n@@ -46,1 +52,1 @@\n-  result = MIN2(host_cpus, limit_count);\n+  result = MIN2(upper_bound, limit_count);\n@@ -48,1 +54,34 @@\n-  return result;\n+  value = result;\n+  return true;\n+}\n+\n+\/\/ Get an updated memory limit. The return value is strictly less than or equal to the\n+\/\/ passed in 'lowest' value.\n+physical_memory_size_type CgroupUtil::get_updated_mem_limit(CgroupMemoryController* mem,\n+                                                            physical_memory_size_type lowest,\n+                                                            physical_memory_size_type upper_bound) {\n+  assert(lowest <= upper_bound, \"invariant\");\n+  physical_memory_size_type current_limit = value_unlimited;\n+  if (mem->read_memory_limit_in_bytes(upper_bound, current_limit) && current_limit != value_unlimited) {\n+    assert(current_limit <= upper_bound, \"invariant\");\n+    if (lowest > current_limit) {\n+      return current_limit;\n+    }\n+  }\n+  return lowest;\n+}\n+\n+\/\/ Get an updated cpu limit. The return value is strictly less than or equal to the\n+\/\/ passed in 'lowest' value.\n+int CgroupUtil::get_updated_cpu_limit(CgroupCpuController* cpu,\n+                                     int lowest,\n+                                     int upper_bound) {\n+  assert(lowest > 0 && lowest <= upper_bound, \"invariant\");\n+  int cpu_limit_val = -1;\n+  if (CgroupUtil::processor_count(cpu, upper_bound, cpu_limit_val) && cpu_limit_val != upper_bound) {\n+    assert(cpu_limit_val <= upper_bound, \"invariant\");\n+    if (lowest > cpu_limit_val) {\n+      return cpu_limit_val;\n+    }\n+  }\n+  return lowest;\n@@ -54,2 +93,3 @@\n-    log_warning(os, container)(\"Cgroup memory controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n-      mem->mount_point(), mem->cgroup_path());\n+    log_warning(os, container)(\"Cgroup memory controller path at '%s' seems to have moved \"\n+                               \"to '%s'. Detected limits won't be accurate\",\n+                               mem->mount_point(), mem->cgroup_path());\n@@ -68,1 +108,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n@@ -70,3 +110,4 @@\n-  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n-  jlong lowest_limit = limit < 0 ? phys_mem : limit;\n-  julong orig_limit = ((julong)lowest_limit) != phys_mem ? lowest_limit : phys_mem;\n+  physical_memory_size_type limit = value_unlimited;\n+  physical_memory_size_type lowest_limit = phys_mem;\n+  lowest_limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+  physical_memory_size_type orig_limit = lowest_limit != phys_mem ? lowest_limit : phys_mem;\n@@ -77,2 +118,2 @@\n-    limit = mem->read_memory_limit_in_bytes(phys_mem);\n-    if (limit >= 0 && limit < lowest_limit) {\n+    limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+    if (limit < lowest_limit) {\n@@ -86,2 +127,2 @@\n-  limit = mem->read_memory_limit_in_bytes(phys_mem);\n-  if (limit >= 0 && limit < lowest_limit) {\n+  limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+  if (limit < lowest_limit) {\n@@ -92,2 +133,2 @@\n-  assert(lowest_limit >= 0, \"limit must be positive\");\n-  if ((julong)lowest_limit != orig_limit) {\n+  assert(lowest_limit <= phys_mem, \"limit must not exceed host memory\");\n+  if (lowest_limit != orig_limit) {\n@@ -99,1 +140,1 @@\n-                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             \"Lowest limit was: \" PHYS_MEM_TYPE_FORMAT,\n@@ -103,1 +144,1 @@\n-    log_trace(os, container)(\"Lowest limit was: \" JLONG_FORMAT, lowest_limit);\n+    log_trace(os, container)(\"Lowest limit was: \" PHYS_MEM_TYPE_FORMAT, lowest_limit);\n@@ -117,2 +158,3 @@\n-    log_warning(os, container)(\"Cgroup cpu controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n-      cpu->mount_point(), cpu->cgroup_path());\n+    log_warning(os, container)(\"Cgroup cpu controller path at '%s' seems to have moved \"\n+                               \"to '%s'. Detected limits won't be accurate\",\n+                               cpu->mount_point(), cpu->cgroup_path());\n@@ -132,2 +174,2 @@\n-  int cpus = CgroupUtil::processor_count(cpu, host_cpus);\n-  int lowest_limit = cpus < host_cpus ? cpus: host_cpus;\n+  int lowest_limit = host_cpus;\n+  int cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -140,1 +182,1 @@\n-    cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+    cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -149,1 +191,1 @@\n-  cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -163,2 +205,1 @@\n-                             cpu->subsystem_path(),\n-                             lowest_limit);\n+                             cpu->subsystem_path(), lowest_limit);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":71,"deletions":30,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static bool processor_count(CgroupCpuController* cpu, int upper_bound, int& value);\n@@ -41,0 +41,7 @@\n+  private:\n+    static physical_memory_size_type get_updated_mem_limit(CgroupMemoryController* m,\n+                                                           physical_memory_size_type lowest,\n+                                                           physical_memory_size_type upper_bound);\n+    static int get_updated_cpu_limit(CgroupCpuController* c,\n+                                     int lowest,\n+                                     int upper_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -127,4 +127,7 @@\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  julong use_hierarchy;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n-  return (jlong)use_hierarchy;\n+bool CgroupV1MemoryController::read_use_hierarchy_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", result);\n+}\n+\n+bool CgroupV1MemoryController::uses_mem_hierarchy() {\n+  physical_memory_size_type use_hierarchy = 0;\n+  return read_use_hierarchy_val(use_hierarchy) && use_hierarchy > 0;\n@@ -144,18 +147,29 @@\n-static inline\n-void verbose_log(julong read_mem_limit, julong upper_mem_bound) {\n-  if (log_is_enabled(Debug, os, container)) {\n-    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n-    if (mem_limit < 0 || read_mem_limit >= upper_mem_bound) {\n-      const char *reason;\n-      if (mem_limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n-      } else if (mem_limit == -1) {\n-        reason = \"unlimited\";\n-      } else {\n-        assert(read_mem_limit >= upper_mem_bound, \"Expected read value exceeding upper memory bound\");\n-        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n-        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n-        reason = \"ignored\";\n-      }\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n-                               reason, mem_limit, upper_mem_bound);\n+bool CgroupV1MemoryController::read_memory_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", result);\n+}\n+\n+bool CgroupV1MemoryController::read_hierarchical_memory_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n+                                             \"hierarchical_memory_limit\", \"Hierarchical Memory Limit\",\n+                                             result);\n+}\n+\n+bool CgroupV1MemoryController::read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type memlimit = 0;\n+  if (!read_memory_limit_val(memlimit)) {\n+    log_trace(os, container)(\"container memory limit failed, upper bound is \" PHYS_MEM_TYPE_FORMAT, upper_bound);\n+    return false;\n+  }\n+  if (memlimit >= upper_bound) {\n+    physical_memory_size_type hierlimit = 0;\n+    if (uses_mem_hierarchy() && read_hierarchical_memory_limit_val(hierlimit) &&\n+        hierlimit < upper_bound) {\n+      log_trace(os, container)(\"Memory Limit is: \" PHYS_MEM_TYPE_FORMAT, hierlimit);\n+      result = hierlimit;\n+    } else {\n+      \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+      \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+      log_trace(os, container)(\"container memory limit ignored: \" PHYS_MEM_TYPE_FORMAT\n+                               \", upper bound is \" PHYS_MEM_TYPE_FORMAT, memlimit, upper_bound);\n+      result = value_unlimited;\n@@ -163,0 +177,2 @@\n+  } else {\n+    result = memlimit;\n@@ -164,0 +180,1 @@\n+  return true;\n@@ -166,10 +183,8 @@\n-jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n-  julong memlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= upper_bound && uses_mem_hierarchy()) {\n-    CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n-                                               \"hierarchical_memory_limit\", \"Hierarchical Memory Limit\",\n-                                               memlimit);\n-  }\n-  verbose_log(memlimit, upper_bound);\n-  return (jlong)((memlimit < upper_bound) ? memlimit : -1);\n+bool CgroupV1MemoryController::read_mem_swap(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", result);\n+}\n+\n+bool CgroupV1MemoryController::read_hierarchical_mem_swap_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n+                                             \"hierarchical_memsw_limit\", \"Hierarchical Memory and Swap Limit\",\n+                                             result);\n@@ -178,1 +193,1 @@\n-\/* read_mem_swap\n+\/* memory_and_swap_limit_in_bytes\n@@ -180,3 +195,2 @@\n- * Determine the memory and swap limit metric. Returns a positive limit value strictly\n- * lower than the physical memory and swap limit iff there is a limit. Otherwise a\n- * negative value is returned indicating the determined status.\n+ * Determine the memory and swap limit metric. Sets the 'result' reference to a positive limit value or\n+ * 'value_unlimited' (for unlimited).\n@@ -185,4 +199,2 @@\n- *    * A number > 0 if the limit is available and lower than a physical upper bound.\n- *    * OSCONTAINER_ERROR if the limit cannot be retrieved (i.e. not supported) or\n- *    * -1 if there isn't any limit in place (note: includes values which exceed a physical\n- *      upper bound)\n+ *    * false if an error occurred. 'result' reference remains unchanged.\n+ *    * true if the limit value has been set in the 'result' reference\n@@ -190,7 +202,8 @@\n-jlong CgroupV1MemoryController::read_mem_swap(julong upper_memsw_bound) {\n-  julong memswlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  if (memswlimit >= upper_memsw_bound && uses_mem_hierarchy()) {\n-      CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n-                                                 \"hierarchical_memsw_limit\", \"Hierarchical Memory and Swap Limit\",\n-                                                 memswlimit);\n+bool CgroupV1MemoryController::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type total_mem_swap = upper_mem_bound + upper_swap_bound;\n+  physical_memory_size_type memory_swap = 0;\n+  bool mem_swap_read_failed = false;\n+  if (!read_mem_swap(memory_swap)) {\n+    mem_swap_read_failed = true;\n@@ -198,8 +211,14 @@\n-  verbose_log(memswlimit, upper_memsw_bound);\n-  return (jlong)((memswlimit < upper_memsw_bound) ? memswlimit : -1);\n-}\n-\n-jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_swap = read_mem_swap(upper_mem_bound + upper_swap_bound);\n-  if (memory_swap == -1) {\n-    return memory_swap;\n+  if (memory_swap >= total_mem_swap) {\n+    physical_memory_size_type hiermswlimit = 0;\n+    if (uses_mem_hierarchy() && read_hierarchical_mem_swap_val(hiermswlimit) &&\n+        hiermswlimit < total_mem_swap) {\n+      log_trace(os, container)(\"Memory and Swap Limit is: \" PHYS_MEM_TYPE_FORMAT, hiermswlimit);\n+      memory_swap = hiermswlimit;\n+    } else {\n+      memory_swap = value_unlimited;\n+    }\n+  }\n+  if (memory_swap == value_unlimited) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n+    result = value_unlimited;\n+    return true;\n@@ -207,0 +226,1 @@\n+\n@@ -210,5 +230,17 @@\n-  jlong swappiness = read_mem_swappiness();\n-  if (swappiness == 0 || memory_swap == OSCONTAINER_ERROR) {\n-    jlong memlimit = read_memory_limit_in_bytes(upper_mem_bound);\n-    if (memory_swap == OSCONTAINER_ERROR) {\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swap is not supported\", memlimit);\n+  physical_memory_size_type swappiness = 0;\n+  if (!read_mem_swappiness(swappiness)) {\n+    \/\/ assume no swap\n+    mem_swap_read_failed = true;\n+  }\n+  if (swappiness == 0 || mem_swap_read_failed) {\n+    physical_memory_size_type memlimit = value_unlimited;\n+    if (!read_memory_limit_in_bytes(upper_mem_bound, memlimit)) {\n+      return false;\n+    }\n+    if (memlimit == value_unlimited) {\n+      result = value_unlimited; \/\/ No memory limit, thus no swap limit\n+      return true;\n+    }\n+    if (mem_swap_read_failed) {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" PHYS_MEM_TYPE_FORMAT\n+                               \" because swap is not supported\", memlimit);\n@@ -216,1 +248,2 @@\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swappiness is 0\", memlimit);\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" PHYS_MEM_TYPE_FORMAT\n+                               \" because swappiness is 0\", memlimit);\n@@ -218,1 +251,2 @@\n-    return memlimit;\n+    result = memlimit;\n+    return true;\n@@ -220,1 +254,2 @@\n-  return memory_swap;\n+  result = memory_swap;\n+  return true;\n@@ -224,13 +259,16 @@\n-jlong memory_swap_usage_impl(CgroupController* ctrl) {\n-  julong memory_swap_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n-  return (jlong)memory_swap_usage;\n-}\n-\n-jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n-  jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n-  if (memory_sw_limit > 0 && memory_limit > 0) {\n-    jlong delta_swap = memory_sw_limit - memory_limit;\n-    if (delta_swap > 0) {\n-      return memory_swap_usage_impl(reader());\n+bool memory_swap_usage_impl(CgroupController* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type memory_sw_limit = value_unlimited;\n+  if (!memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound, memory_sw_limit)) {\n+    return false;\n+  }\n+  physical_memory_size_type mem_limit_val = value_unlimited;\n+  physical_memory_size_type memory_limit = value_unlimited;\n+  if (read_memory_limit_in_bytes(upper_mem_bound, mem_limit_val)) {\n+    if (mem_limit_val != value_unlimited) {\n+      memory_limit = mem_limit_val;\n@@ -239,1 +277,16 @@\n-  return memory_usage_in_bytes();\n+  if (memory_sw_limit != value_unlimited && memory_limit != value_unlimited) {\n+    if (memory_limit < memory_sw_limit) {\n+      \/\/ swap allowed and > 0\n+      physical_memory_size_type swap_usage = 0;\n+      if (!memory_swap_usage_impl(reader(), swap_usage)) {\n+        return false;\n+      }\n+      result = swap_usage;\n+      return true;\n+    }\n+  }\n+  return memory_usage_in_bytes(result);\n+}\n+\n+bool CgroupV1MemoryController::read_mem_swappiness(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", result);\n@@ -242,4 +295,2 @@\n-jlong CgroupV1MemoryController::read_mem_swappiness() {\n-  julong swappiness;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n-  return (jlong)swappiness;\n+bool CgroupV1MemoryController::memory_soft_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", result);\n@@ -248,4 +299,7 @@\n-jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n-  julong memsoftlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= upper_bound) {\n+bool CgroupV1MemoryController::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type mem_soft_limit = 0;\n+  if (!memory_soft_limit_val(mem_soft_limit)) {\n+    return false;\n+  }\n+  if (mem_soft_limit >= upper_bound) {\n@@ -253,1 +307,1 @@\n-    return (jlong)-1;\n+    result = value_unlimited;\n@@ -255,1 +309,1 @@\n-    return (jlong)memsoftlimit;\n+    result = mem_soft_limit;\n@@ -257,0 +311,1 @@\n+  return true;\n@@ -259,1 +314,1 @@\n-jlong CgroupV1MemoryController::memory_throttle_limit_in_bytes() {\n+bool CgroupV1MemoryController::memory_throttle_limit_in_bytes(physical_memory_size_type& result) {\n@@ -262,1 +317,1 @@\n-  return OSCONTAINER_ERROR; \/\/ not supported\n+  return false;\n@@ -291,1 +346,10 @@\n-\/* memory_usage_in_bytes\n+bool CgroupV1MemoryController::memory_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type memory_usage = 0;\n+  if (!memory_usage_val(memory_usage)) {\n+    return false;\n+  }\n+  result = memory_usage;\n+  return true;\n+}\n+\n+\/* memory_usage_val\n@@ -293,1 +357,1 @@\n- * Return the amount of used memory for this process.\n+ * Read the amount of used memory for this process into the passed in reference 'result'\n@@ -296,3 +360,2 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true when reading of the file was successful and 'result' was set appropriately\n+ *    false when reading of the file failed\n@@ -300,4 +363,6 @@\n-jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV1MemoryController::memory_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_max_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", result);\n@@ -308,1 +373,2 @@\n- * Return the maximum amount of used memory for this process.\n+ * Return the maximum amount of used memory for this process in the\n+ * result reference.\n@@ -311,2 +377,2 @@\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the result reference has been set\n+ *    false otherwise (e.g. on error)\n@@ -314,4 +380,7 @@\n-jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n-  julong memmaxusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n-  return (jlong)memmaxusage;\n+bool CgroupV1MemoryController::memory_max_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type memory_max_usage = 0;\n+  if (!memory_max_usage_val(memory_max_usage)) {\n+     return false;\n+  }\n+  result = memory_max_usage;\n+  return true;\n@@ -320,5 +389,5 @@\n-jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1MemoryController::rss_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type rss = 0;\n+\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", rss)) {\n+    return false;\n@@ -326,2 +395,3 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"RSS usage is: \" PHYS_MEM_TYPE_FORMAT, rss);\n+  result = rss;\n+  return true;\n@@ -330,5 +400,4 @@\n-jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1MemoryController::cache_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type cache = 0;\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", cache)) {\n+    return false;\n@@ -336,2 +405,3 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return cache;\n+  log_trace(os, container)(\"Cache usage is: \" PHYS_MEM_TYPE_FORMAT, cache);\n+  result = cache;\n+  return true;\n@@ -340,4 +410,2 @@\n-jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n-  julong kmem_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n-  return (jlong)kmem_usage;\n+bool CgroupV1MemoryController::kernel_memory_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", result);\n@@ -346,3 +414,19 @@\n-jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong upper_bound) {\n-  julong kmem_limit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+bool CgroupV1MemoryController::kernel_memory_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_usage = 0;\n+  if (!kernel_memory_usage_val(kmem_usage)) {\n+    return false;\n+  }\n+  result = kmem_usage;\n+  return true;\n+}\n+\n+bool CgroupV1MemoryController::kernel_memory_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", result);\n+}\n+\n+bool CgroupV1MemoryController::kernel_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                            physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_limit = 0;\n+  if (!kernel_memory_limit_val(kmem_limit)) {\n+    return false;\n+  }\n@@ -350,1 +434,1 @@\n-    return (jlong)-1;\n+    kmem_limit = value_unlimited;\n@@ -352,1 +436,6 @@\n-  return (jlong)kmem_limit;\n+  result = kmem_limit;\n+  return true;\n+}\n+\n+bool CgroupV1MemoryController::kernel_memory_max_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", result);\n@@ -355,4 +444,7 @@\n-jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n-  julong kmem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n-  return (jlong)kmem_max_usage;\n+bool CgroupV1MemoryController::kernel_memory_max_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_max_usage = 0;\n+  if (!kernel_memory_max_usage_val(kmem_max_usage)) {\n+    return false;\n+  }\n+  result = kmem_max_usage;\n+  return true;\n@@ -361,4 +453,16 @@\n-void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong mem_bound) {\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes(mem_bound);\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, physical_memory_size_type mem_bound) {\n+  MetricResult kmem_usage;\n+  physical_memory_size_type temp = 0;\n+  if (kernel_memory_usage_in_bytes(temp)) {\n+    kmem_usage.set_value(temp);\n+  }\n+  MetricResult kmem_limit;\n+  temp = value_unlimited;\n+  if (kernel_memory_limit_in_bytes(mem_bound, temp)) {\n+    kmem_limit.set_value(temp);\n+  }\n+  MetricResult kmem_max_usage;\n+  temp = 0;\n+  if (kernel_memory_max_usage_in_bytes(temp)) {\n+    kmem_max_usage.set_value(temp);\n+  }\n@@ -386,1 +490,2 @@\n- * process is guaranteed to run.\n+ * a process is guaranteed to run in the provided\n+ * result reference.\n@@ -389,3 +494,3 @@\n- *    quota time in microseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n+ *   true if the value was set in the result reference\n+ *   false on failure to read the number from the file\n+ *   and the result reference has not been touched.\n@@ -393,6 +498,8 @@\n-int CgroupV1CpuController::cpu_quota() {\n-  julong quota;\n-  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n-  if (!is_ok) {\n-    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1CpuController::cpu_quota(int& result) {\n+  uint64_t quota = 0;\n+\n+  \/\/ intentionally not using the macro so as to not log a\n+  \/\/ negative value as a large unsiged int\n+  if (!reader()->read_number(\"\/cpu.cfs_quota_us\", quota)) {\n+    log_trace(os, container)(\"CPU Quota failed\");\n+    return false;\n@@ -402,1 +509,1 @@\n-  int quota_int = (int)quota;\n+  int quota_int = static_cast<int>(quota);\n@@ -404,1 +511,2 @@\n-  return quota_int;\n+  result = quota_int;\n+  return true;\n@@ -407,4 +515,15 @@\n-int CgroupV1CpuController::cpu_period() {\n-  julong period;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n-  return (int)period;\n+bool CgroupV1CpuController::cpu_period_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", result);\n+}\n+\n+bool CgroupV1CpuController::cpu_period(int& result) {\n+  uint64_t period = value_unlimited;\n+  if (!cpu_period_val(period)) {\n+    return false;\n+  }\n+  result = static_cast<int>(period);\n+  return true;\n+}\n+\n+bool CgroupV1CpuController::cpu_shares_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", result);\n@@ -416,0 +535,2 @@\n+ *    - Share number (typically a number relative to 1024)\n+ *    - (2048 typically expresses 2 CPUs worth of processing)\n@@ -418,4 +539,2 @@\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on error\n+ *    true if the result has been set in the result reference\n@@ -423,6 +542,14 @@\n-int CgroupV1CpuController::cpu_shares() {\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n-  int shares_int = (int)shares;\n-  \/\/ Convert 1024 to no shares setup\n-  if (shares_int == 1024) return -1;\n+bool CgroupV1CpuController::cpu_shares(int& result) {\n+  uint64_t shares = 0;\n+  if (!cpu_shares_val(shares)) {\n+    return false;\n+  }\n+  int shares_int = static_cast<int>(shares);\n+  \/\/ Convert 1024 to no shares setup (-1)\n+  if (shares_int == 1024) {\n+    shares_int = -1;\n+  }\n+\n+  result = shares_int;\n+  return true;\n+}\n@@ -430,1 +557,2 @@\n-  return shares_int;\n+bool CgroupV1CpuacctController::cpu_usage_in_micros_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", result);\n@@ -433,3 +561,5 @@\n-jlong CgroupV1CpuacctController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", cpu_usage);\n+bool CgroupV1CpuacctController::cpu_usage_in_micros(uint64_t& result) {\n+  uint64_t cpu_usage = 0;\n+  if (!cpu_usage_in_micros_val(cpu_usage)) {\n+    return false;\n+  }\n@@ -437,1 +567,7 @@\n-  return (jlong)cpu_usage \/ 1000;\n+  result = static_cast<uint64_t>(cpu_usage \/ 1000);\n+  return true;\n+}\n+\n+static\n+bool pids_max_val(CgroupController* ctrl, uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/pids.max\", \"Maximum number of tasks\", result);\n@@ -443,0 +579,1 @@\n+ * in the passed result reference (might be value_unlimited).\n@@ -445,3 +582,2 @@\n- *    maximum number of tasks\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on error\n+ *    true when the result reference has been appropriately set\n@@ -449,5 +585,13 @@\n-jlong CgroupV1Subsystem::pids_max() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+bool CgroupV1Subsystem::pids_max(uint64_t& result) {\n+  if (_pids == nullptr) return false;\n+  uint64_t pids_val = 0;\n+  if (!pids_max_val(_pids, pids_val)) {\n+    return false;\n+  }\n+  result = pids_val;\n+  return true;\n+}\n+\n+static\n+bool pids_current_val(CgroupController* ctrl, uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/pids.current\", \"Current number of tasks\", result);\n@@ -461,2 +605,2 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the current number of tasks has been set in the result reference\n+ *    false if an error occurred\n@@ -464,5 +608,8 @@\n-jlong CgroupV1Subsystem::pids_current() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return (jlong)pids_current;\n+bool CgroupV1Subsystem::pids_current(uint64_t& result) {\n+  if (_pids == nullptr) return false;\n+  uint64_t pids_current = 0;\n+  if (!pids_current_val(_pids, pids_current)) {\n+    return false;\n+  }\n+  result = pids_current;\n+  return true;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":329,"deletions":182,"binary":false,"changes":511,"status":"modified"},{"patch":"@@ -76,0 +76,14 @@\n+    bool read_memory_limit_val(physical_memory_size_type& result);\n+    bool read_hierarchical_memory_limit_val(physical_memory_size_type& result);\n+    bool read_hierarchical_mem_swap_val(physical_memory_size_type& result);\n+    bool read_use_hierarchy_val(physical_memory_size_type& result);\n+    bool memory_usage_val(physical_memory_size_type& result);\n+    bool read_mem_swappiness(physical_memory_size_type& result);\n+    bool read_mem_swap(physical_memory_size_type& result);\n+    bool memory_soft_limit_val(physical_memory_size_type& result);\n+    bool memory_max_usage_val(physical_memory_size_type& result);\n+    bool kernel_memory_usage_val(physical_memory_size_type& result);\n+    bool kernel_memory_limit_val(physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_val(physical_memory_size_type& result);\n+    bool uses_mem_hierarchy();\n+\n@@ -80,13 +94,20 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes(julong upper_bound);\n-    jlong kernel_memory_max_usage_in_bytes();\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n+    bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& value) override;\n+    bool memory_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool rss_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool cache_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool kernel_memory_usage_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                      physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_in_bytes(physical_memory_size_type& result);\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) override;\n@@ -102,4 +123,0 @@\n-  private:\n-    jlong uses_mem_hierarchy();\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap(julong upper_memsw_bound);\n@@ -119,0 +136,2 @@\n+    bool cpu_period_val(uint64_t& result);\n+    bool cpu_shares_val(uint64_t& result);\n@@ -120,3 +139,3 @@\n-    int cpu_quota() override;\n-    int cpu_period() override;\n-    int cpu_shares() override;\n+    bool cpu_quota(int& result) override;\n+    bool cpu_period(int& result) override;\n+    bool cpu_shares(int& result) override;\n@@ -150,0 +169,1 @@\n+    bool cpu_usage_in_micros_val(uint64_t& result);\n@@ -151,1 +171,1 @@\n-    jlong cpu_usage_in_micros() override;\n+    bool cpu_usage_in_micros(uint64_t& result) override;\n@@ -183,3 +203,3 @@\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes();\n-    jlong kernel_memory_max_usage_in_bytes();\n+    bool kernel_memory_usage_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_limit_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_in_bytes(physical_memory_size_type& result);\n@@ -187,2 +207,2 @@\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n@@ -190,2 +210,2 @@\n-    jlong pids_max();\n-    jlong pids_current();\n+    bool pids_max(uint64_t& result) override;\n+    bool pids_current(uint64_t& result) override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":48,"deletions":28,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+static\n+bool read_cpu_shares_value(CgroupV2Controller* ctrl, uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/cpu.weight\", \"Raw value for CPU Shares\", value);\n+}\n+\n@@ -49,1 +54,2 @@\n- * Return the amount of cpu shares available to the process\n+ * Return the amount of cpu shares available to the process in the\n+ * 'result' reference.\n@@ -51,1 +57,0 @@\n- * return:\n@@ -54,2 +59,4 @@\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *\n+ * return:\n+ *    true if the result reference got updated\n+ *    false if there was an error\n@@ -57,4 +64,7 @@\n-int CgroupV2CpuController::cpu_shares() {\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n-  int shares_int = (int)shares;\n+bool CgroupV2CpuController::cpu_shares(int& result) {\n+  uint64_t shares = 0;\n+  bool is_ok = read_cpu_shares_value(reader(), shares);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int shares_int = static_cast<int>(shares);\n@@ -63,2 +73,3 @@\n-    log_debug(os, container)(\"CPU Shares is: %d\", -1);\n-    return -1;\n+    log_debug(os, container)(\"CPU Shares is: unlimited\");\n+    result = -1;\n+    return true;\n@@ -100,1 +111,2 @@\n-     return x;\n+     result = x;\n+     return true;\n@@ -110,1 +122,2 @@\n-  return x;\n+  result = x;\n+  return true;\n@@ -116,1 +129,1 @@\n- * process is guaranteed to run.\n+ * process is guaranteed to run in the passed in 'result' reference.\n@@ -119,3 +132,2 @@\n- *    quota time in microseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the result reference has been set\n+ *    false on error\n@@ -123,5 +135,10 @@\n-int CgroupV2CpuController::cpu_quota() {\n-  jlong quota_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2CpuController::cpu_quota(int& result) {\n+  uint64_t quota_val = 0;\n+  if (!reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, quota_val)) {\n+    return false;\n+  }\n+  int limit = -1;\n+  \/\/ The read first tuple value might be 'max' which maps\n+  \/\/ to value_unlimited. Keep that at -1;\n+  if (quota_val != value_unlimited) {\n+    limit = static_cast<int>(quota_val);\n@@ -129,1 +146,0 @@\n-  int limit = (int)quota_val;\n@@ -131,1 +147,2 @@\n-  return limit;\n+  result = limit;\n+  return true;\n@@ -165,6 +182,5 @@\n-int CgroupV2CpuController::cpu_period() {\n-  jlong period_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n-  if (!is_ok) {\n-    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2CpuController::cpu_period(int& result) {\n+  uint64_t cpu_period = 0;\n+  if (!reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, cpu_period)) {\n+    log_trace(os, container)(\"CPU Period failed\");\n+    return false;\n@@ -172,3 +188,4 @@\n-  int period = (int)period_val;\n-  log_trace(os, container)(\"CPU Period is: %d\", period);\n-  return period;\n+  int period_int = static_cast<int>(cpu_period);\n+  log_trace(os, container)(\"CPU Period is: %d\", period_int);\n+  result = period_int;\n+  return true;\n@@ -177,3 +194,2 @@\n-jlong CgroupV2CpuController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", &cpu_usage);\n+bool CgroupV2CpuController::cpu_usage_in_micros(uint64_t& value) {\n+  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", value);\n@@ -181,2 +197,2 @@\n-    log_trace(os, container)(\"CPU Usage failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+    log_trace(os, container)(\"CPU Usage failed\");\n+    return false;\n@@ -184,2 +200,2 @@\n-  log_trace(os, container)(\"CPU Usage is: \" JULONG_FORMAT, cpu_usage);\n-  return (jlong)cpu_usage;\n+  log_trace(os, container)(\"CPU Usage is: \" UINT64_FORMAT, value);\n+  return true;\n@@ -190,1 +206,2 @@\n- * Return the amount of used memory used by this cgroup and descendents\n+ * read the amount of used memory used by this cgroup and descendents\n+ * into the passed in 'value' reference.\n@@ -193,3 +210,1 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on failure, true otherwise.\n@@ -197,4 +212,2 @@\n-jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV2MemoryController::memory_usage_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", value);\n@@ -203,4 +216,3 @@\n-jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n-  jlong mem_soft_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n-  return mem_soft_limit;\n+bool CgroupV2MemoryController::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", value);\n@@ -209,4 +221,2 @@\n-jlong CgroupV2MemoryController::memory_throttle_limit_in_bytes() {\n-  jlong mem_throttle_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", mem_throttle_limit);\n-  return mem_throttle_limit;\n+bool CgroupV2MemoryController::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", value);\n@@ -215,4 +225,2 @@\n-jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n-  julong mem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", mem_max_usage);\n-  return mem_max_usage;\n+bool CgroupV2MemoryController::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", value);\n@@ -221,5 +229,3 @@\n-jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2MemoryController::rss_usage_in_bytes(physical_memory_size_type& value) {\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", value)) {\n+    return false;\n@@ -227,2 +233,2 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"RSS usage is: \" PHYS_MEM_TYPE_FORMAT, value);\n+  return true;\n@@ -231,5 +237,3 @@\n-jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2MemoryController::cache_usage_in_bytes(physical_memory_size_type& value) {\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", value)) {\n+    return false;\n@@ -237,2 +241,2 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return (jlong)cache;\n+  log_trace(os, container)(\"Cache usage is: \" PHYS_MEM_TYPE_FORMAT, value);\n+  return true;\n@@ -246,5 +250,5 @@\n-jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound,\n-                                                               julong upper_swap_bound \/* unused in cg v2 *\/) {\n-  jlong swap_limit;\n-  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n-  if (!is_ok) {\n+bool CgroupV2MemoryController::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound, \/* unused in cg v2 *\/\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type swap_limit_val = 0;\n+  if (!reader()->read_number_handle_max(\"\/memory.swap.max\", swap_limit_val)) {\n@@ -252,1 +256,1 @@\n-    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed\");\n@@ -254,1 +258,6 @@\n-    return read_memory_limit_in_bytes(upper_mem_bound);\n+    physical_memory_size_type mem_limit = value_unlimited;\n+    if (!read_memory_limit_in_bytes(upper_mem_bound, mem_limit)) {\n+      return false;\n+    }\n+    result = mem_limit;\n+    return true;\n@@ -256,5 +265,14 @@\n-  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n-  if (swap_limit >= 0) {\n-    jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n-    assert(memory_limit >= 0, \"swap limit without memory limit?\");\n-    return memory_limit + swap_limit;\n+  if (swap_limit_val == value_unlimited) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n+    result = swap_limit_val;\n+    return true;\n+  }\n+  log_trace(os, container)(\"Swap Limit is: \" PHYS_MEM_TYPE_FORMAT, swap_limit_val);\n+  physical_memory_size_type memory_limit = 0;\n+  if (read_memory_limit_in_bytes(upper_mem_bound, memory_limit)) {\n+    assert(memory_limit != value_unlimited, \"swap limit without memory limit?\");\n+    result = memory_limit + swap_limit_val;\n+    log_trace(os, container)(\"Memory and Swap Limit is: \" PHYS_MEM_TYPE_FORMAT, result);\n+    return true;\n+  } else {\n+    return false;\n@@ -262,2 +280,0 @@\n-  log_trace(os, container)(\"Memory and Swap Limit is: \" JLONG_FORMAT, swap_limit);\n-  return swap_limit;\n@@ -268,4 +284,2 @@\n-jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+bool memory_swap_current_value(CgroupV2Controller* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", result);\n@@ -274,5 +288,11 @@\n-jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_usage = memory_usage_in_bytes();\n-  if (memory_usage >= 0) {\n-      jlong swap_current = memory_swap_current_value(reader());\n-      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+bool CgroupV2MemoryController::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type memory_usage = 0;\n+  if (!memory_usage_in_bytes(memory_usage)) {\n+     return false;\n+  }\n+  physical_memory_size_type swap_current = 0;\n+  if (!memory_swap_current_value(reader(), swap_current)) {\n+    result = memory_usage; \/\/ treat as no swap usage\n+    return true;\n@@ -280,1 +300,2 @@\n-  return memory_usage; \/\/ not supported or unlimited case\n+  result = memory_usage + swap_current;\n+  return true;\n@@ -284,4 +305,2 @@\n-jlong memory_limit_value(CgroupV2Controller* ctrl) {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+bool memory_limit_value(CgroupV2Controller* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", result);\n@@ -292,1 +311,2 @@\n- * Return the limit of available memory for this process.\n+ * Calculate the limit of available memory for this process. The result will be\n+ * set in the 'result' variable if the function returns true.\n@@ -295,2 +315,2 @@\n- *    memory limit in bytes or\n- *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *    true when the limit could be read correctly.\n+ *    false in case of any error.\n@@ -298,2 +318,13 @@\n-jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n-  jlong limit = memory_limit_value(reader());\n+bool CgroupV2MemoryController::read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type limit = 0; \/\/ default unlimited\n+  if (!memory_limit_value(reader(), limit)) {\n+    log_trace(os, container)(\"container memory limit failed, using host value \" PHYS_MEM_TYPE_FORMAT,\n+                              upper_bound);\n+    return false;\n+  }\n+  bool is_unlimited = limit == value_unlimited;\n+  bool exceeds_physical_mem = false;\n+  if (!is_unlimited && limit >= upper_bound) {\n+    exceeds_physical_mem = true;\n+  }\n@@ -301,4 +332,2 @@\n-    if (limit == -1) {\n-      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n-    } else {\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    if (!is_unlimited) {\n+      log_trace(os, container)(\"Memory Limit is: \" PHYS_MEM_TYPE_FORMAT, limit);\n@@ -306,9 +335,4 @@\n-  }\n-  if (log_is_enabled(Debug, os, container)) {\n-    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n-    if (limit < 0 || read_limit >= upper_bound) {\n-      const char* reason;\n-      if (limit == -1) {\n-        reason = \"unlimited\";\n-      } else if (limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n+    if (is_unlimited || exceeds_physical_mem) {\n+      if (is_unlimited) {\n+        log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+        log_trace(os, container)(\"container memory limit unlimited, using upper bound value \" PHYS_MEM_TYPE_FORMAT, upper_bound);\n@@ -316,2 +340,2 @@\n-        assert(read_limit >= upper_bound, \"Expected mem limit to exceed upper memory bound\");\n-        reason = \"ignored\";\n+        log_trace(os, container)(\"container memory limit ignored: \" PHYS_MEM_TYPE_FORMAT \", upper bound is \" PHYS_MEM_TYPE_FORMAT,\n+                                 limit, upper_bound);\n@@ -319,2 +343,0 @@\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n-                               reason, limit, upper_bound);\n@@ -323,1 +345,2 @@\n-  return limit;\n+  result = limit;\n+  return true;\n@@ -327,4 +350,2 @@\n-jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+bool memory_swap_limit_value(CgroupV2Controller* ctrl, physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", value);\n@@ -349,4 +370,11 @@\n-void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n-  jlong swap_current = memory_swap_current_value(reader());\n-  jlong swap_limit = memory_swap_limit_value(reader());\n-\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) {\n+  MetricResult swap_current;\n+  physical_memory_size_type swap_current_val = 0;\n+  if (memory_swap_current_value(reader(), swap_current_val)) {\n+    swap_current.set_value(swap_current_val);\n+  }\n+  MetricResult swap_limit;\n+  physical_memory_size_type swap_limit_val = 0;\n+  if (memory_swap_limit_value(reader(), swap_limit_val)) {\n+    swap_limit.set_value(swap_limit_val);\n+  }\n@@ -368,1 +396,3 @@\n- * Return the maximum number of tasks available to the process\n+ * Calculate the maximum number of tasks available to the process. Set the\n+ * value in the passed in 'value' reference. The value might be 'value_unlimited' when\n+ * there is no limit.\n@@ -371,3 +401,2 @@\n- *    maximum number of tasks\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the value has been set appropriately\n+ *    false if there was an error\n@@ -375,4 +404,2 @@\n-jlong CgroupV2Subsystem::pids_max() {\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+bool CgroupV2Subsystem::pids_max(uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", value);\n@@ -383,1 +410,2 @@\n- * The number of tasks currently in the cgroup (and its descendants) of the process\n+ * The number of tasks currently in the cgroup (and its descendants) of the process. Set\n+ * in the passed in 'value' reference.\n@@ -386,2 +414,2 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    true on success\n+ *    false when there was an error\n@@ -389,4 +417,2 @@\n-jlong CgroupV2Subsystem::pids_current() {\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return pids_current;\n+bool CgroupV2Subsystem::pids_current(uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", value);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":173,"deletions":147,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -62,4 +62,4 @@\n-    int cpu_quota() override;\n-    int cpu_period() override;\n-    int cpu_shares() override;\n-    jlong cpu_usage_in_micros();\n+    bool cpu_quota(int& value) override;\n+    bool cpu_period(int& value) override;\n+    bool cpu_shares(int& value) override;\n+    bool cpu_usage_in_micros(uint64_t& value);\n@@ -90,2 +90,2 @@\n-    jlong cpu_usage_in_micros() override {\n-      return reader()->cpu_usage_in_micros();\n+    bool cpu_usage_in_micros(uint64_t& result) override {\n+      return reader()->cpu_usage_in_micros(result);\n@@ -113,0 +113,1 @@\n+\n@@ -117,10 +118,16 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n+    bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool rss_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool cache_usage_in_bytes(physical_memory_size_type& result) override;\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) override;\n@@ -163,2 +170,2 @@\n-    jlong pids_max() override;\n-    jlong pids_current() override;\n+    bool pids_max(uint64_t& result) override;\n+    bool pids_current(uint64_t& result) override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -87,2 +87,6 @@\n-    any_mem_cpu_limit_present = memory_limit_in_bytes() > 0 ||\n-                                os::Linux::active_processor_count() != active_processor_count();\n+    physical_memory_size_type mem_limit_val = value_unlimited;\n+    (void)memory_limit_in_bytes(mem_limit_val);  \/\/ discard error and use default\n+    int host_cpus = os::Linux::active_processor_count();\n+    int cpus = host_cpus;\n+    (void)active_processor_count(cpus);  \/\/ discard error and use default\n+    any_mem_cpu_limit_present = mem_limit_val != value_unlimited || host_cpus != cpus;\n@@ -106,7 +110,5 @@\n-bool OSContainer::available_memory_in_container(julong& value) {\n-  jlong mem_limit = memory_limit_in_bytes();\n-  jlong mem_usage = memory_usage_in_bytes();\n-\n-  if (mem_limit > 0 && mem_usage <= 0) {\n-    log_debug(os, container)(\"container memory usage failed: \" JLONG_FORMAT, mem_usage);\n-  }\n+bool OSContainer::memory_limit_in_bytes(physical_memory_size_type& value) {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  return cgroup_subsystem->memory_limit_in_bytes(phys_mem, value);\n+}\n@@ -114,2 +116,9 @@\n-  if (mem_limit <= 0 || mem_usage <= 0) {\n-    return false;\n+bool OSContainer::available_memory_in_bytes(physical_memory_size_type& value) {\n+  physical_memory_size_type mem_limit = value_unlimited;\n+  physical_memory_size_type mem_usage = 0;\n+  if (memory_limit_in_bytes(mem_limit) && memory_usage_in_bytes(mem_usage)) {\n+    assert(mem_usage != value_unlimited, \"invariant\");\n+    if (mem_limit != value_unlimited) {\n+      value = (mem_limit > mem_usage) ? mem_limit - mem_usage : 0;\n+      return true;\n+    }\n@@ -117,4 +126,2 @@\n-\n-  value = mem_limit > mem_usage ? static_cast<julong>(mem_limit - mem_usage) : 0;\n-\n-  return true;\n+  log_trace(os, container)(\"calculating available memory in container failed\");\n+  return false;\n@@ -123,4 +130,56 @@\n-jlong OSContainer::memory_limit_in_bytes() {\n-  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  return cgroup_subsystem->memory_limit_in_bytes(phys_mem);\n+bool OSContainer::available_swap_in_bytes(physical_memory_size_type host_free_swap,\n+                                          physical_memory_size_type& value) {\n+  physical_memory_size_type mem_limit = 0;\n+  physical_memory_size_type mem_swap_limit = 0;\n+  if (memory_limit_in_bytes(mem_limit) &&\n+      memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n+      mem_limit != value_unlimited &&\n+      mem_swap_limit != value_unlimited) {\n+    if (mem_limit >= mem_swap_limit) {\n+      value = 0; \/\/ no swap, thus no free swap\n+      return true;\n+    }\n+    physical_memory_size_type swap_limit = mem_swap_limit - mem_limit;\n+    physical_memory_size_type mem_swap_usage = 0;\n+    physical_memory_size_type mem_usage = 0;\n+    if (memory_and_swap_usage_in_bytes(mem_swap_usage) &&\n+        memory_usage_in_bytes(mem_usage)) {\n+      physical_memory_size_type swap_usage = value_unlimited;\n+      if (mem_usage > mem_swap_usage) {\n+        swap_usage = 0; \/\/ delta usage must not be negative\n+      } else {\n+        swap_usage = mem_swap_usage - mem_usage;\n+      }\n+      \/\/ free swap is based on swap limit (upper bound) and swap usage\n+      if (swap_usage >= swap_limit) {\n+        value = 0; \/\/ free swap must not be negative\n+        return true;\n+      }\n+      value = swap_limit - swap_usage;\n+      return true;\n+    }\n+  }\n+  \/\/ unlimited or not supported. Leave an appropriate trace message\n+  if (log_is_enabled(Trace, os, container)) {\n+    char mem_swap_buf[25]; \/\/ uint64_t => 20 + 1, 'unlimited' => 9 + 1; 10 < 21 < 25\n+    char mem_limit_buf[25];\n+    int num = 0;\n+    if (mem_swap_limit == value_unlimited) {\n+      num = os::snprintf(mem_swap_buf, sizeof(mem_swap_buf), \"%s\", \"unlimited\");\n+    } else {\n+      num = os::snprintf(mem_swap_buf, sizeof(mem_swap_buf), PHYS_MEM_TYPE_FORMAT, mem_swap_limit);\n+    }\n+    assert(num < 25, \"buffer too small\");\n+    mem_swap_buf[num] = '\\0';\n+    if (mem_limit == value_unlimited) {\n+      num = os::snprintf(mem_limit_buf, sizeof(mem_limit_buf), \"%s\", \"unlimited\");\n+    } else {\n+      num = os::snprintf(mem_limit_buf, sizeof(mem_limit_buf), PHYS_MEM_TYPE_FORMAT, mem_limit);\n+    }\n+    assert(num < 25, \"buffer too small\");\n+    mem_limit_buf[num] = '\\0';\n+    log_trace(os,container)(\"OSContainer::available_swap_in_bytes: container_swap_limit=%s\"\n+                            \" container_mem_limit=%s, host_free_swap: \" PHYS_MEM_TYPE_FORMAT,\n+                            mem_swap_buf, mem_limit_buf, host_free_swap);\n+  }\n+  return false;\n@@ -129,1 +188,1 @@\n-jlong OSContainer::memory_and_swap_limit_in_bytes() {\n+bool OSContainer::memory_and_swap_limit_in_bytes(physical_memory_size_type& value) {\n@@ -131,3 +190,6 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return cgroup_subsystem->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  physical_memory_size_type host_swap = 0;\n+  if (!os::Linux::host_swap(host_swap)) {\n+    return false;\n+  }\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes(phys_mem, host_swap, value);\n@@ -136,1 +198,1 @@\n-jlong OSContainer::memory_and_swap_usage_in_bytes() {\n+bool OSContainer::memory_and_swap_usage_in_bytes(physical_memory_size_type& value) {\n@@ -138,3 +200,6 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return cgroup_subsystem->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  physical_memory_size_type host_swap = 0;\n+  if (!os::Linux::host_swap(host_swap)) {\n+    return false;\n+  }\n+  return cgroup_subsystem->memory_and_swap_usage_in_bytes(phys_mem, host_swap, value);\n@@ -143,1 +208,1 @@\n-jlong OSContainer::memory_soft_limit_in_bytes() {\n+bool OSContainer::memory_soft_limit_in_bytes(physical_memory_size_type& value) {\n@@ -145,2 +210,2 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  return cgroup_subsystem->memory_soft_limit_in_bytes(phys_mem);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  return cgroup_subsystem->memory_soft_limit_in_bytes(phys_mem, value);\n@@ -149,1 +214,1 @@\n-jlong OSContainer::memory_throttle_limit_in_bytes() {\n+bool OSContainer::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n@@ -151,1 +216,1 @@\n-  return cgroup_subsystem->memory_throttle_limit_in_bytes();\n+  return cgroup_subsystem->memory_throttle_limit_in_bytes(value);\n@@ -154,1 +219,1 @@\n-jlong OSContainer::memory_usage_in_bytes() {\n+bool OSContainer::memory_usage_in_bytes(physical_memory_size_type& value) {\n@@ -156,1 +221,1 @@\n-  return cgroup_subsystem->memory_usage_in_bytes();\n+  return cgroup_subsystem->memory_usage_in_bytes(value);\n@@ -159,1 +224,1 @@\n-jlong OSContainer::memory_max_usage_in_bytes() {\n+bool OSContainer::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n@@ -161,1 +226,1 @@\n-  return cgroup_subsystem->memory_max_usage_in_bytes();\n+  return cgroup_subsystem->memory_max_usage_in_bytes(value);\n@@ -164,1 +229,1 @@\n-jlong OSContainer::rss_usage_in_bytes() {\n+bool OSContainer::rss_usage_in_bytes(physical_memory_size_type& value) {\n@@ -166,1 +231,1 @@\n-  return cgroup_subsystem->rss_usage_in_bytes();\n+  return cgroup_subsystem->rss_usage_in_bytes(value);\n@@ -169,1 +234,1 @@\n-jlong OSContainer::cache_usage_in_bytes() {\n+bool OSContainer::cache_usage_in_bytes(physical_memory_size_type& value) {\n@@ -171,1 +236,1 @@\n-  return cgroup_subsystem->cache_usage_in_bytes();\n+  return cgroup_subsystem->cache_usage_in_bytes(value);\n@@ -176,1 +241,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n@@ -190,1 +255,1 @@\n-int OSContainer::active_processor_count() {\n+bool OSContainer::active_processor_count(int& value) {\n@@ -192,1 +257,1 @@\n-  return cgroup_subsystem->active_processor_count();\n+  return cgroup_subsystem->active_processor_count(value);\n@@ -195,1 +260,1 @@\n-int OSContainer::cpu_quota() {\n+bool OSContainer::cpu_quota(int& value) {\n@@ -197,1 +262,1 @@\n-  return cgroup_subsystem->cpu_quota();\n+  return cgroup_subsystem->cpu_quota(value);\n@@ -200,1 +265,1 @@\n-int OSContainer::cpu_period() {\n+bool OSContainer::cpu_period(int& value) {\n@@ -202,1 +267,1 @@\n-  return cgroup_subsystem->cpu_period();\n+  return cgroup_subsystem->cpu_period(value);\n@@ -205,1 +270,1 @@\n-int OSContainer::cpu_shares() {\n+bool OSContainer::cpu_shares(int& value) {\n@@ -207,1 +272,1 @@\n-  return cgroup_subsystem->cpu_shares();\n+  return cgroup_subsystem->cpu_shares(value);\n@@ -210,1 +275,1 @@\n-jlong OSContainer::cpu_usage_in_micros() {\n+bool OSContainer::cpu_usage_in_micros(uint64_t& value) {\n@@ -212,1 +277,1 @@\n-  return cgroup_subsystem->cpu_usage_in_micros();\n+  return cgroup_subsystem->cpu_usage_in_micros(value);\n@@ -215,1 +280,1 @@\n-jlong OSContainer::pids_max() {\n+bool OSContainer::pids_max(uint64_t& value) {\n@@ -217,1 +282,1 @@\n-  return cgroup_subsystem->pids_max();\n+  return cgroup_subsystem->pids_max(value);\n@@ -220,1 +285,1 @@\n-jlong OSContainer::pids_current() {\n+bool OSContainer::pids_current(uint64_t& value) {\n@@ -222,1 +287,1 @@\n-  return cgroup_subsystem->pids_current();\n+  return cgroup_subsystem->pids_current(value);\n@@ -225,1 +290,1 @@\n-void OSContainer::print_container_helper(outputStream* st, jlong j, const char* metrics) {\n+void OSContainer::print_container_helper(outputStream* st, MetricResult& res, const char* metrics) {\n@@ -227,3 +292,7 @@\n-  if (j >= 0) {\n-    if (j >= 1024) {\n-      st->print_cr(UINT64_FORMAT \" k\", uint64_t(j) \/ K);\n+  if (res.success()) {\n+    if (res.value() != value_unlimited) {\n+      if (res.value() >= 1024) {\n+        st->print_cr(PHYS_MEM_TYPE_FORMAT \" k\", (physical_memory_size_type)(res.value() \/ K));\n+      } else {\n+        st->print_cr(PHYS_MEM_TYPE_FORMAT, res.value());\n+      }\n@@ -231,1 +300,1 @@\n-      st->print_cr(UINT64_FORMAT, uint64_t(j));\n+      st->print_cr(\"%s\", \"unlimited\");\n@@ -234,1 +303,2 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    \/\/ Not supported\n+    st->print_cr(\"%s\", \"unavailable\");\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":131,"deletions":61,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-#define OSCONTAINER_ERROR (-2)\n+\/\/ Some cgroup interface files define the value 'max' for unlimited.\n+\/\/ Define this constant value to indicate this value.\n+const uint64_t value_unlimited = std::numeric_limits<uint64_t>::max();\n@@ -38,0 +40,17 @@\n+\/\/ Carrier object for print_container_helper()\n+class MetricResult: public StackObj {\n+  private:\n+    static const uint64_t value_unused = 0;\n+    bool _success = false;\n+    physical_memory_size_type _value = value_unused;\n+  public:\n+    void set_value(physical_memory_size_type val) {\n+      \/\/ having a value means success\n+      _success = true;\n+      _value = val;\n+    }\n+\n+    bool success() { return _success; }\n+    physical_memory_size_type value() { return _value; }\n+};\n+\n@@ -48,1 +67,1 @@\n-  static void print_container_helper(outputStream* st, jlong j, const char* metrics);\n+  static void print_container_helper(outputStream* st, MetricResult& res, const char* metrics);\n@@ -53,12 +72,14 @@\n-  static bool available_memory_in_container(julong& value);\n-  static jlong memory_limit_in_bytes();\n-  static jlong memory_and_swap_limit_in_bytes();\n-  static jlong memory_and_swap_usage_in_bytes();\n-  static jlong memory_soft_limit_in_bytes();\n-  static jlong memory_throttle_limit_in_bytes();\n-  static jlong memory_usage_in_bytes();\n-  static jlong memory_max_usage_in_bytes();\n-  static jlong rss_usage_in_bytes();\n-  static jlong cache_usage_in_bytes();\n-\n-  static int active_processor_count();\n+  static bool available_memory_in_bytes(physical_memory_size_type& value);\n+  static bool available_swap_in_bytes(physical_memory_size_type host_free_swap,\n+                                      physical_memory_size_type& value);\n+  static bool memory_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_and_swap_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_and_swap_usage_in_bytes(physical_memory_size_type& value);\n+  static bool memory_soft_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_throttle_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_usage_in_bytes(physical_memory_size_type& value);\n+  static bool memory_max_usage_in_bytes(physical_memory_size_type& value);\n+  static bool rss_usage_in_bytes(physical_memory_size_type& value);\n+  static bool cache_usage_in_bytes(physical_memory_size_type& value);\n+\n+  static bool active_processor_count(int& value);\n@@ -69,2 +90,2 @@\n-  static int cpu_quota();\n-  static int cpu_period();\n+  static bool cpu_quota(int& value);\n+  static bool cpu_period(int& value);\n@@ -72,1 +93,1 @@\n-  static int cpu_shares();\n+  static bool cpu_shares(int& value);\n@@ -74,1 +95,1 @@\n-  static jlong cpu_usage_in_micros();\n+  static bool cpu_usage_in_micros(uint64_t& value);\n@@ -76,2 +97,2 @@\n-  static jlong pids_max();\n-  static jlong pids_current();\n+  static bool pids_max(uint64_t& value);\n+  static bool pids_current(uint64_t& value);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -217,4 +217,2 @@\n-  julong avail_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(avail_mem)) {\n-    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n-    value = static_cast<physical_memory_size_type>(avail_mem);\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(value)) {\n+    log_trace(os)(\"available container memory: \" PHYS_MEM_TYPE_FORMAT, value);\n@@ -228,1 +226,1 @@\n-  julong avail_mem = static_cast<julong>(-1L);\n+  physical_memory_size_type avail_mem = 0;\n@@ -230,0 +228,1 @@\n+  bool found_available_mem = false;\n@@ -234,1 +233,1 @@\n-      if (fscanf(fp, \"MemAvailable: \" JULONG_FORMAT \" kB\", &avail_mem) == 1) {\n+      if (fscanf(fp, \"MemAvailable: \" PHYS_MEM_TYPE_FORMAT \" kB\", &avail_mem) == 1) {\n@@ -236,0 +235,1 @@\n+        found_available_mem = true;\n@@ -241,1 +241,3 @@\n-  if (avail_mem == static_cast<julong>(-1L)) {\n+  \/\/ Only enter the free memory block if we\n+  \/\/ haven't found the available memory\n+  if (!found_available_mem) {\n@@ -246,1 +248,1 @@\n-    avail_mem = static_cast<julong>(free_mem);\n+    avail_mem = free_mem;\n@@ -248,2 +250,2 @@\n-  log_trace(os)(\"available memory: \" JULONG_FORMAT, avail_mem);\n-  value = static_cast<physical_memory_size_type>(avail_mem);\n+  log_trace(os)(\"available memory: \" PHYS_MEM_TYPE_FORMAT, avail_mem);\n+  value = avail_mem;\n@@ -254,4 +256,2 @@\n-  julong free_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(free_mem)) {\n-    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n-    value = static_cast<physical_memory_size_type>(free_mem);\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(value)) {\n+    log_trace(os)(\"free container memory: \" PHYS_MEM_TYPE_FORMAT, value);\n@@ -272,3 +272,3 @@\n-  julong free_mem = (julong)si.freeram * si.mem_unit;\n-  log_trace(os)(\"free memory: \" JULONG_FORMAT, free_mem);\n-  value = static_cast<physical_memory_size_type>(free_mem);\n+  physical_memory_size_type free_mem = (physical_memory_size_type)si.freeram * si.mem_unit;\n+  log_trace(os)(\"free memory: \" PHYS_MEM_TYPE_FORMAT, free_mem);\n+  value = free_mem;\n@@ -280,5 +280,9 @@\n-    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n-    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n-      value = static_cast<physical_memory_size_type>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n-      return true;\n+    physical_memory_size_type mem_swap_limit = value_unlimited;\n+    physical_memory_size_type memory_limit = value_unlimited;\n+    if (OSContainer::memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n+        OSContainer::memory_limit_in_bytes(memory_limit)) {\n+      if (memory_limit != value_unlimited && mem_swap_limit != value_unlimited &&\n+          mem_swap_limit >= memory_limit \/* ensure swap is >= 0 *\/) {\n+        value = mem_swap_limit - memory_limit;\n+        return true;\n+      }\n@@ -286,9 +290,2 @@\n-  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n-  struct sysinfo si;\n-  int ret = sysinfo(&si);\n-  if (ret != 0) {\n-    assert(false, \"sysinfo failed in total_swap_space(): %s\", os::strerror(errno));\n-    return false;\n-  }\n-  value = static_cast<physical_memory_size_type>(si.totalswap) * si.mem_unit;\n-  return true;\n+  } \/\/ fallback to the host swap space if the container returned unlimited\n+  return Linux::host_swap(value);\n@@ -318,18 +315,2 @@\n-    jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n-    if (mem_swap_limit >= 0 && mem_limit >= 0) {\n-      jlong delta_limit = mem_swap_limit - mem_limit;\n-      if (delta_limit <= 0) {\n-        value = 0;\n-        return true;\n-      }\n-      jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n-      jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-      if (mem_swap_usage > 0 && mem_usage > 0) {\n-        jlong delta_usage = mem_swap_usage - mem_usage;\n-        if (delta_usage >= 0) {\n-          jlong free_swap = delta_limit - delta_usage;\n-          value = free_swap >= 0 ? static_cast<physical_memory_size_type>(free_swap) : 0;\n-          return true;\n-        }\n-      }\n+    if (OSContainer::available_swap_in_bytes(host_free_swap_val, value)) {\n+      return true;\n@@ -337,4 +318,3 @@\n-    \/\/ unlimited or not supported. Fall through to return host value\n-    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" PHYS_MEM_TYPE_FORMAT,\n-                            mem_swap_limit, mem_limit, host_free_swap_val);\n+    \/\/ Fall through to use host value\n+    log_trace(os,container)(\"os::free_swap_space: containerized value unavailable\"\n+                            \" returning host value: \" PHYS_MEM_TYPE_FORMAT, host_free_swap_val);\n@@ -348,4 +328,4 @@\n-    jlong mem_limit;\n-    if ((mem_limit = OSContainer::memory_limit_in_bytes()) > 0) {\n-      log_trace(os)(\"total container memory: \" JLONG_FORMAT, mem_limit);\n-      return static_cast<physical_memory_size_type>(mem_limit);\n+    physical_memory_size_type mem_limit = value_unlimited;\n+    if (OSContainer::memory_limit_in_bytes(mem_limit) && mem_limit != value_unlimited) {\n+      log_trace(os)(\"total container memory: \" PHYS_MEM_TYPE_FORMAT, mem_limit);\n+      return mem_limit;\n@@ -511,1 +491,1 @@\n-julong os::Linux::host_swap() {\n+bool os::Linux::host_swap(physical_memory_size_type& value) {\n@@ -513,2 +493,7 @@\n-  sysinfo(&si);\n-  return (julong)(si.totalswap * si.mem_unit);\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    assert(false, \"sysinfo failed in host_swap(): %s\", os::strerror(errno));\n+    return false;\n+  }\n+  value = static_cast<physical_memory_size_type>(si.totalswap) * si.mem_unit;\n+  return true;\n@@ -2472,1 +2457,2 @@\n-  int i = OSContainer::active_processor_count();\n+  int i = -1;\n+  bool supported = OSContainer::active_processor_count(i);\n@@ -2474,1 +2460,2 @@\n-  if (i > 0) {\n+  if (supported) {\n+    assert(i > 0, \"must be\");\n@@ -2484,1 +2471,2 @@\n-  i = OSContainer::cpu_quota();\n+\n+  supported = OSContainer::cpu_quota(i);\n@@ -2486,1 +2474,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2489,1 +2477,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no quota\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no quota\");\n@@ -2492,1 +2480,1 @@\n-  i = OSContainer::cpu_period();\n+  supported = OSContainer::cpu_period(i);\n@@ -2494,1 +2482,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2497,1 +2485,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no period\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no period\");\n@@ -2500,1 +2488,1 @@\n-  i = OSContainer::cpu_shares();\n+  supported = OSContainer::cpu_shares(i);\n@@ -2502,1 +2490,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2505,1 +2493,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no shares\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no shares\");\n@@ -2508,1 +2496,2 @@\n-  jlong j = OSContainer::cpu_usage_in_micros();\n+  uint64_t j = 0;\n+  supported = OSContainer::cpu_usage_in_micros(j);\n@@ -2510,2 +2499,2 @@\n-  if (j >= 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j > 0) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2513,11 +2502,51 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"no usage\");\n-  }\n-\n-  OSContainer::print_container_helper(st, OSContainer::memory_limit_in_bytes(), \"memory_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_and_swap_limit_in_bytes(), \"memory_and_swap_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_soft_limit_in_bytes(), \"memory_soft_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_throttle_limit_in_bytes(), \"memory_throttle_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_usage_in_bytes(), \"memory_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_max_usage_in_bytes(), \"memory_max_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no usage\");\n+  }\n+\n+  MetricResult memory_limit;\n+  physical_memory_size_type val = value_unlimited;\n+  if (OSContainer::memory_limit_in_bytes(val)) {\n+    memory_limit.set_value(val);\n+  }\n+  MetricResult mem_swap_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_and_swap_limit_in_bytes(val)) {\n+    mem_swap_limit.set_value(val);\n+  }\n+  MetricResult mem_soft_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_soft_limit_in_bytes(val)) {\n+    mem_soft_limit.set_value(val);\n+  }\n+  MetricResult mem_throttle_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_throttle_limit_in_bytes(val)) {\n+    mem_throttle_limit.set_value(val);\n+  }\n+  MetricResult mem_usage;\n+  val = 0;\n+  if (OSContainer::memory_usage_in_bytes(val)) {\n+    mem_usage.set_value(val);\n+  }\n+  MetricResult mem_max_usage;\n+  val = 0;\n+  if (OSContainer::memory_max_usage_in_bytes(val)) {\n+    mem_max_usage.set_value(val);\n+  }\n+  MetricResult rss_usage;\n+  val = 0;\n+  if (OSContainer::rss_usage_in_bytes(val)) {\n+    rss_usage.set_value(val);\n+  }\n+  MetricResult cache_usage;\n+  val = 0;\n+  if (OSContainer::cache_usage_in_bytes(val)) {\n+    cache_usage.set_value(val);\n+  }\n+  OSContainer::print_container_helper(st, memory_limit, \"memory_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_swap_limit, \"memory_and_swap_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_soft_limit, \"memory_soft_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_throttle_limit, \"memory_throttle_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_usage, \"memory_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_max_usage, \"memory_max_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, rss_usage, \"rss_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, cache_usage, \"cache_usage_in_bytes\");\n@@ -2527,1 +2556,1 @@\n-  j = OSContainer::pids_max();\n+  supported = OSContainer::pids_max(j);\n@@ -2529,2 +2558,2 @@\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j != value_unlimited) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2532,1 +2561,1 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"unlimited\");\n@@ -2535,1 +2564,1 @@\n-  j = OSContainer::pids_current();\n+  supported = OSContainer::pids_current(j);\n@@ -2537,2 +2566,2 @@\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j > 0) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2540,3 +2569,1 @@\n-    if (j == OSCONTAINER_ERROR) {\n-      st->print_cr(\"not supported\");\n-    }\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no current tasks\");\n@@ -4646,1 +4673,1 @@\n-\/\/ 3. extracted from cgroup cpu subsystem (shares and quotas)\n+\/\/ 3. extracted from cgroup cpu subsystem (quotas)\n@@ -4663,3 +4690,2 @@\n-  int active_cpus;\n-  if (OSContainer::is_containerized()) {\n-    active_cpus = OSContainer::active_processor_count();\n+  int active_cpus = -1;\n+  if (OSContainer::is_containerized() && OSContainer::active_processor_count(active_cpus)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":125,"deletions":99,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-  static julong available_memory_in_container();\n-\n@@ -120,1 +118,1 @@\n-  static julong host_swap();\n+  static bool host_swap(physical_memory_size_type& value);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -424,1 +424,3 @@\n-  return os::Linux::host_swap();\n+  physical_memory_size_type host_swap = 0;\n+  (void)os::Linux::host_swap(host_swap); \/\/ Discard return value and treat as no swap\n+  return static_cast<jlong>(host_swap);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2593,1 +2593,7 @@\n-  LINUX_ONLY(return (jlong)os::Linux::host_swap();)\n+#ifdef LINUX\n+  physical_memory_size_type swap_val = 0;\n+  if (!os::Linux::host_swap(swap_val)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<jlong>(swap_val);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2210,7 +2210,1 @@\n-    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-    if (mem_usage > 0) {\n-      value = static_cast<physical_memory_size_type>(mem_usage);\n-      return true;\n-    } else {\n-      return false;\n-    }\n+    return OSContainer::memory_usage_in_bytes(value);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t x = bad;\n@@ -111,1 +111,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -117,1 +117,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -123,1 +123,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -129,1 +129,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -135,1 +135,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -153,2 +153,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t x = bad;\n@@ -157,1 +157,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -159,1 +159,1 @@\n-  EXPECT_EQ((julong)100, x);\n+  EXPECT_EQ((uint64_t)100, x);\n@@ -163,1 +163,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -165,1 +165,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((uint64_t)111, x);\n@@ -169,1 +169,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -171,1 +171,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((uint64_t)111, x);\n@@ -175,1 +175,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -177,1 +177,1 @@\n-  EXPECT_EQ((julong)133, x);\n+  EXPECT_EQ((uint64_t)133, x);\n@@ -181,1 +181,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -183,1 +183,1 @@\n-  EXPECT_EQ((julong)333, x);\n+  EXPECT_EQ((uint64_t)333, x);\n@@ -187,1 +187,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -189,1 +189,1 @@\n-  EXPECT_EQ((julong)1, x);\n+  EXPECT_EQ((uint64_t)1, x);\n@@ -198,2 +198,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t a = bad;\n@@ -201,1 +201,1 @@\n-  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  bool is_ok = null_path_controller->read_number(test_file_path, a);\n@@ -224,3 +224,3 @@\n-  constexpr julong bad = 0xBAD;\n-  julong result = bad;\n-  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, result);\n@@ -235,2 +235,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t a = bad;\n@@ -238,1 +238,1 @@\n-  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -246,1 +246,1 @@\n-  constexpr julong bad = 0xBAD;\n+  constexpr uint64_t bad = 0xBAD;\n@@ -255,2 +255,2 @@\n-  julong foo = bad;\n-  bool ok = controller->read_number(base_with_slash, &foo);\n+  uint64_t foo = bad;\n+  bool ok = controller->read_number(base_with_slash, foo);\n@@ -258,1 +258,1 @@\n-  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((uint64_t)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -261,1 +261,2 @@\n-  \/\/ them and manually cast them as needed.\n+  \/\/ them and manually cast them as needed. For example, on cgv1, the cpu.cfs_quota_us\n+  \/\/ file might be set to -1 to indicate no cpu quota setup.\n@@ -264,1 +265,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -266,1 +267,1 @@\n-  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((int)-1, (int)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -270,1 +271,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -276,1 +277,2 @@\n-  jlong result = -10;\n+  uint64_t result = 0;\n+  uint64_t unlimited = std::numeric_limits<uint64_t>::max();\n@@ -278,1 +280,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -280,1 +282,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+  EXPECT_EQ(unlimited, result) << \"'max' means unlimited (-1)\";\n@@ -282,1 +284,1 @@\n-  result = -10;\n+  result = 0;\n@@ -284,1 +286,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -286,1 +288,1 @@\n-  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+  EXPECT_EQ((uint64_t)11114, result) << \"Incorrect result\";\n@@ -288,1 +290,4 @@\n-  result = -10;\n+  result = 0;\n+  \/\/ This is a contrived test case not matching cgroup interface files\n+  \/\/ in the wild where numbers are positive. The value is deliberately\n+  \/\/ negative. Yet it should work\n@@ -290,1 +295,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -292,1 +297,1 @@\n-  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+  EXPECT_EQ((int)-51114, (int)result) << \"Incorrect result\";\n@@ -375,2 +380,2 @@\n-  jlong result = -10;\n-  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  uint64_t result = 0;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -378,1 +383,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+  EXPECT_EQ(value_unlimited, result) << \"max should be unlimited (-1)\";\n@@ -380,2 +385,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, result);\n@@ -383,1 +388,1 @@\n-  EXPECT_EQ((jlong)10000, result);\n+  EXPECT_EQ((uint64_t)10000, result);\n@@ -387,2 +392,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -390,1 +395,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((uint64_t)0, result) << \"result value should be unchanged\";\n@@ -393,2 +398,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -396,1 +401,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((uint64_t)0, result) << \"result value should be unchanged\";\n@@ -410,2 +415,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  uint64_t a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -413,1 +418,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((uint64_t)0xBAD, a) << \"Expected untouched scan value\";\n@@ -420,2 +425,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  uint64_t a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, a);\n@@ -423,1 +428,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((uint64_t)0xBAD, a) << \"Expected untouched scan value\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":70,"deletions":65,"binary":false,"changes":135,"status":"modified"}]}