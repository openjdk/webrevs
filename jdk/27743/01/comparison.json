{"files":[{"patch":"@@ -630,1 +630,2 @@\n- * returned will never exceed the number of active processors.\n+ * set in the result reference will never exceed the number\n+ * of active processors.\n@@ -633,1 +634,1 @@\n- *    number of CPUs\n+ *    true if there were no errors. false otherwise.\n@@ -635,2 +636,1 @@\n-int CgroupSubsystem::active_processor_count() {\n-  int quota_count = 0;\n+bool CgroupSubsystem::active_processor_count(int& value) {\n@@ -638,1 +638,1 @@\n-  int result;\n+  int result = -1;\n@@ -646,3 +646,3 @@\n-    int val = (int)cpu_limit->value();\n-    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n-    return val;\n+    value = (int)cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", value);\n+    return true;\n@@ -652,1 +652,4 @@\n-  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n+  if (!CgroupUtil::processor_count(contrl->controller(), cpu_count, result)) {\n+    return false;\n+  }\n+  assert(result > 0 && result <= cpu_count, \"must be\");\n@@ -655,0 +658,1 @@\n+  value = result;\n@@ -656,1 +660,1 @@\n-  return result;\n+  return true;\n@@ -661,1 +665,3 @@\n- * Return the limit of available memory for this process.\n+ * Return the limit of available memory for this process in the provided\n+ * physical_memory_size_type reference. If there was no limit value set in the underlying\n+ * interface files value_unlimited is returned.\n@@ -664,3 +670,3 @@\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false if retrieving the value failed\n+ *    true if retrieving the value was successfull and the value was\n+ *    set in the 'value' reference.\n@@ -668,1 +674,2 @@\n-jlong CgroupSubsystem::memory_limit_in_bytes(julong upper_bound) {\n+bool CgroupSubsystem::memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) {\n@@ -672,1 +679,6 @@\n-    return memory_limit->value();\n+    value = memory_limit->value();\n+    return true;\n+  }\n+  physical_memory_size_type mem_limit = 0;\n+  if (!contrl->controller()->read_memory_limit_in_bytes(upper_bound, mem_limit)) {\n+    return false;\n@@ -674,1 +686,0 @@\n-  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(upper_bound);\n@@ -677,1 +688,2 @@\n-  return mem_limit;\n+  value = mem_limit;\n+  return true;\n@@ -722,1 +734,1 @@\n-bool CgroupController::read_number(const char* filename, julong* result) {\n+bool CgroupController::read_number(const char* filename, uint64_t& result) {\n@@ -728,1 +740,1 @@\n-  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  int matched = sscanf(buf, UINT64_FORMAT, &result);\n@@ -735,1 +747,1 @@\n-bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+bool CgroupController::read_number_handle_max(const char* filename, uint64_t& result) {\n@@ -741,2 +753,2 @@\n-  jlong val = limit_from_str(buf);\n-  if (val == OSCONTAINER_ERROR) {\n+  uint64_t val = 0;\n+  if (!limit_from_str(buf, val)) {\n@@ -745,1 +757,1 @@\n-  *result = val;\n+  result = val;\n@@ -749,1 +761,1 @@\n-bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, uint64_t& result) {\n@@ -751,1 +763,0 @@\n-  assert(result != nullptr, \"result pointer must not be null\");\n@@ -789,1 +800,1 @@\n-      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      int matched = sscanf(value_substr, UINT64_FORMAT, &result);\n@@ -800,1 +811,1 @@\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", UINT64_FORMAT,\n@@ -805,1 +816,1 @@\n-bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, uint64_t& result) {\n@@ -816,2 +827,2 @@\n-  jlong val = limit_from_str(token);\n-  if (val == OSCONTAINER_ERROR) {\n+  uint64_t val = 0;\n+  if (!limit_from_str(token, val)) {\n@@ -820,1 +831,1 @@\n-  *result = val;\n+  result = val;\n@@ -824,1 +835,1 @@\n-jlong CgroupController::limit_from_str(char* limit_str) {\n+bool CgroupController::limit_from_str(char* limit_str, uint64_t& value) {\n@@ -826,1 +837,1 @@\n-    return OSCONTAINER_ERROR;\n+    return false;\n@@ -831,1 +842,2 @@\n-    return (jlong)-1;\n+    value = value_unlimited;\n+    return true;\n@@ -833,3 +845,3 @@\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    return OSCONTAINER_ERROR;\n+  uint64_t limit;\n+  if (sscanf(limit_str, UINT64_FORMAT, &limit) != 1) {\n+    return false;\n@@ -837,1 +849,2 @@\n-  return (jlong)limit;\n+  value = limit;\n+  return true;\n@@ -841,3 +854,6 @@\n-\n-jlong CgroupSubsystem::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n+bool CgroupSubsystem::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                     physical_memory_size_type upper_swap_bound,\n+                                                     physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(upper_mem_bound,\n+                                                                           upper_swap_bound,\n+                                                                           value);\n@@ -846,2 +862,6 @@\n-jlong CgroupSubsystem::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(upper_mem_bound, upper_swap_bound);\n+bool CgroupSubsystem::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                     physical_memory_size_type upper_swap_bound,\n+                                                     physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(upper_mem_bound,\n+                                                                           upper_swap_bound,\n+                                                                           value);\n@@ -850,2 +870,3 @@\n-jlong CgroupSubsystem::memory_soft_limit_in_bytes(julong upper_bound) {\n-  return memory_controller()->controller()->memory_soft_limit_in_bytes(upper_bound);\n+bool CgroupSubsystem::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                 physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(upper_bound, value);\n@@ -854,2 +875,2 @@\n-jlong CgroupSubsystem::memory_throttle_limit_in_bytes() {\n-  return memory_controller()->controller()->memory_throttle_limit_in_bytes();\n+bool CgroupSubsystem::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_throttle_limit_in_bytes(value);\n@@ -858,2 +879,2 @@\n-jlong CgroupSubsystem::memory_usage_in_bytes() {\n-  return memory_controller()->controller()->memory_usage_in_bytes();\n+bool CgroupSubsystem::memory_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_usage_in_bytes(value);\n@@ -862,2 +883,2 @@\n-jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n-  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+bool CgroupSubsystem::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes(value);\n@@ -866,2 +887,2 @@\n-jlong CgroupSubsystem::rss_usage_in_bytes() {\n-  return memory_controller()->controller()->rss_usage_in_bytes();\n+bool CgroupSubsystem::rss_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->rss_usage_in_bytes(value);\n@@ -870,2 +891,2 @@\n-jlong CgroupSubsystem::cache_usage_in_bytes() {\n-  return memory_controller()->controller()->cache_usage_in_bytes();\n+bool CgroupSubsystem::cache_usage_in_bytes(physical_memory_size_type& value) {\n+  return memory_controller()->controller()->cache_usage_in_bytes(value);\n@@ -874,2 +895,2 @@\n-int CgroupSubsystem::cpu_quota() {\n-  return cpu_controller()->controller()->cpu_quota();\n+bool CgroupSubsystem::cpu_quota(int& value) {\n+  return cpu_controller()->controller()->cpu_quota(value);\n@@ -878,2 +899,2 @@\n-int CgroupSubsystem::cpu_period() {\n-  return cpu_controller()->controller()->cpu_period();\n+bool CgroupSubsystem::cpu_period(int& value) {\n+  return cpu_controller()->controller()->cpu_period(value);\n@@ -882,2 +903,2 @@\n-int CgroupSubsystem::cpu_shares() {\n-  return cpu_controller()->controller()->cpu_shares();\n+bool CgroupSubsystem::cpu_shares(int& value) {\n+  return cpu_controller()->controller()->cpu_shares(value);\n@@ -886,2 +907,2 @@\n-jlong CgroupSubsystem::cpu_usage_in_micros() {\n-  return cpuacct_controller()->cpu_usage_in_micros();\n+bool CgroupSubsystem::cpu_usage_in_micros(uint64_t& value) {\n+  return cpuacct_controller()->cpu_usage_in_micros(value);\n@@ -890,1 +911,1 @@\n-void CgroupSubsystem::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n+void CgroupSubsystem::print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) {\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":86,"deletions":65,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  is_ok = controller->read_number(filename, &retval);                                 \\\n+  is_ok = controller->read_number(filename, retval);                                  \\\n@@ -77,2 +77,2 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n-    return OSCONTAINER_ERROR;                                                         \\\n+    log_trace(os, container)(log_string \" failed: -2\");                               \\\n+    return false;                                                                     \\\n@@ -80,1 +80,2 @@\n-  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n+  log_trace(os, container)(log_string \" is: \" UINT64_FORMAT, retval);                 \\\n+  return true;                                                                        \\\n@@ -86,1 +87,1 @@\n-  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  is_ok = controller->read_number_handle_max(filename, retval);                       \\\n@@ -88,2 +89,2 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n-    return OSCONTAINER_ERROR;                                                         \\\n+    log_trace(os, container)(log_string \" failed: -2\");                               \\\n+    return false;                                                                     \\\n@@ -91,1 +92,6 @@\n-  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n+  if (retval == value_unlimited) {                                                    \\\n+    log_trace(os, container)(log_string \" is: -1\");                                   \\\n+  } else {                                                                            \\\n+    log_trace(os, container)(log_string \" is: \" UINT64_FORMAT, retval);               \\\n+  }                                                                                   \\\n+  return true;                                                                        \\\n@@ -99,1 +105,1 @@\n-    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);                \\\n+    log_trace(os, container)(log_string \" failed: -2\");                                   \\\n@@ -116,1 +122,1 @@\n-    \/* Read a numerical value as unsigned long\n+    \/* Read a numerical value as uint64_t\n@@ -119,1 +125,1 @@\n-     * the parsed value is set in the provided julong pointer.\n+     * the parsed value is set in the provided result reference.\n@@ -121,1 +127,1 @@\n-    bool read_number(const char* filename, julong* result);\n+    bool read_number(const char* filename, uint64_t& result);\n@@ -127,2 +133,3 @@\n-     * the parsed value (which might be negative) is being set in\n-     * the provided jlong pointer.\n+     * the parsed value will be set in the provided result reference.\n+     * When the value was the string 'max' then 'value_unlimited' is\n+     * being set as the value.\n@@ -130,1 +137,1 @@\n-    bool read_number_handle_max(const char* filename, jlong* result);\n+    bool read_number_handle_max(const char* filename, uint64_t& result);\n@@ -148,1 +155,1 @@\n-     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     * value of the appropriate tuple entry set in the provided result reference.\n@@ -150,1 +157,1 @@\n-    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, uint64_t& result);\n@@ -154,1 +161,1 @@\n-     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     * via the passed in result reference. Example interface file 'memory.stat'\n@@ -157,1 +164,1 @@\n-     * being set in the provided julong pointer.\n+     * being set in the provided result reference.\n@@ -159,1 +166,1 @@\n-    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+    bool read_numerical_key_value(const char* filename, const char* key, uint64_t& result);\n@@ -162,1 +169,1 @@\n-    static jlong limit_from_str(char* limit_str);\n+    static bool limit_from_str(char* limit_str, physical_memory_size_type& value);\n@@ -167,1 +174,1 @@\n-    volatile jlong _metric;\n+    volatile physical_memory_size_type _metric;\n@@ -171,1 +178,1 @@\n-      _metric = -1;\n+      _metric = value_unlimited;\n@@ -177,2 +184,2 @@\n-    jlong value() { return _metric; }\n-    void set_value(jlong value, jlong timeout) {\n+    physical_memory_size_type value() { return _metric; }\n+    void set_value(physical_memory_size_type value, jlong timeout) {\n@@ -208,3 +215,3 @@\n-    virtual int cpu_quota() = 0;\n-    virtual int cpu_period() = 0;\n-    virtual int cpu_shares() = 0;\n+    virtual bool cpu_quota(int& value) = 0;\n+    virtual bool cpu_period(int& value) = 0;\n+    virtual bool cpu_shares(int& value) = 0;\n@@ -222,1 +229,1 @@\n-    virtual jlong cpu_usage_in_micros() = 0;\n+    virtual bool cpu_usage_in_micros(uint64_t& value) = 0;\n@@ -234,10 +241,16 @@\n-    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_usage_in_bytes() = 0;\n-    virtual jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n-    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n-    virtual jlong memory_throttle_limit_in_bytes() = 0;\n-    virtual jlong memory_max_usage_in_bytes() = 0;\n-    virtual jlong rss_usage_in_bytes() = 0;\n-    virtual jlong cache_usage_in_bytes() = 0;\n-    virtual void print_version_specific_info(outputStream* st, julong upper_mem_bound) = 0;\n+    virtual bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) = 0;\n+    virtual bool memory_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                physical_memory_size_type upper_swap_bound,\n+                                                physical_memory_size_type& value) = 0;\n+    virtual bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                physical_memory_size_type upper_swap_bound,\n+                                                physical_memory_size_type& value) = 0;\n+    virtual bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                            physical_memory_size_type& value) = 0;\n+    virtual bool memory_throttle_limit_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool memory_max_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool rss_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual bool cache_usage_in_bytes(physical_memory_size_type& value) = 0;\n+    virtual void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) = 0;\n@@ -254,2 +267,2 @@\n-    jlong memory_limit_in_bytes(julong upper_bound);\n-    int active_processor_count();\n+    bool memory_limit_in_bytes(physical_memory_size_type upper_bound, physical_memory_size_type& value);\n+    bool active_processor_count(int& value);\n@@ -257,2 +270,2 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual bool pids_max(uint64_t& value) = 0;\n+    virtual bool pids_current(uint64_t& value) = 0;\n@@ -268,3 +281,3 @@\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n+    bool cpu_quota(int& value);\n+    bool cpu_period(int& value);\n+    bool cpu_shares(int& value);\n@@ -272,1 +285,1 @@\n-    jlong cpu_usage_in_micros();\n+    bool cpu_usage_in_micros(uint64_t& value);\n@@ -274,9 +287,14 @@\n-    jlong memory_usage_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n-    jlong memory_soft_limit_in_bytes(julong upper_bound);\n-    jlong memory_throttle_limit_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound);\n+    bool memory_usage_in_bytes(physical_memory_size_type& value);\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& value);\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& value);\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& value);\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& value);\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& value);\n+    bool rss_usage_in_bytes(physical_memory_size_type& value);\n+    bool cache_usage_in_bytes(physical_memory_size_type& value);\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":74,"deletions":56,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -28,5 +28,11 @@\n-int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n-  assert(host_cpus > 0, \"physical host cpus must be positive\");\n-  int limit_count = host_cpus;\n-  int quota  = cpu_ctrl->cpu_quota();\n-  int period = cpu_ctrl->cpu_period();\n+bool CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int upper_bound, int& value) {\n+  assert(upper_bound > 0, \"upper bound of cpus must be positive\");\n+  int limit_count = upper_bound;\n+  int quota = -1;\n+  int period = -1;\n+  if (!cpu_ctrl->cpu_quota(quota)) {\n+    return false;\n+  }\n+  if (!cpu_ctrl->cpu_period(period)) {\n+    return false;\n+  }\n@@ -34,1 +40,1 @@\n-  int result = 0;\n+  int result = upper_bound;\n@@ -46,1 +52,1 @@\n-  result = MIN2(host_cpus, limit_count);\n+  result = MIN2(upper_bound, limit_count);\n@@ -48,1 +54,34 @@\n-  return result;\n+  value = result;\n+  return true;\n+}\n+\n+\/\/ Get an updated memory limit. The return value is strictly less than or equal to the\n+\/\/ passed in 'lowest' value.\n+physical_memory_size_type CgroupUtil::get_updated_mem_limit(CgroupMemoryController* mem,\n+                                                            physical_memory_size_type lowest,\n+                                                            physical_memory_size_type upper_bound) {\n+  assert(lowest <= upper_bound, \"invariant\");\n+  physical_memory_size_type current_limit = value_unlimited;\n+  if (mem->read_memory_limit_in_bytes(upper_bound, current_limit) && current_limit != value_unlimited) {\n+    assert(current_limit <= upper_bound, \"invariant\");\n+    if (lowest > current_limit) {\n+      return current_limit;\n+    }\n+  }\n+  return lowest;\n+}\n+\n+\/\/ Get an updated cpu limit. The return value is strictly less than or equal to the\n+\/\/ passed in 'lowest' value.\n+int CgroupUtil::get_updated_cpu_limit(CgroupCpuController* cpu,\n+                                     int lowest,\n+                                     int upper_bound) {\n+  assert(lowest > 0 && lowest <= upper_bound, \"invariant\");\n+  int cpu_limit_val = -1;\n+  if (CgroupUtil::processor_count(cpu, upper_bound, cpu_limit_val) && cpu_limit_val != upper_bound) {\n+    assert(cpu_limit_val <= upper_bound, \"invariant\");\n+    if (lowest > cpu_limit_val) {\n+      return cpu_limit_val;\n+    }\n+  }\n+  return lowest;\n@@ -54,2 +93,3 @@\n-    log_warning(os, container)(\"Cgroup memory controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n-      mem->mount_point(), mem->cgroup_path());\n+    log_warning(os, container)(\"Cgroup memory controller path at '%s' seems to have moved \"\n+                               \"to '%s'. Detected limits won't be accurate\",\n+                               mem->mount_point(), mem->cgroup_path());\n@@ -68,1 +108,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n@@ -70,3 +110,4 @@\n-  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n-  jlong lowest_limit = limit < 0 ? phys_mem : limit;\n-  julong orig_limit = ((julong)lowest_limit) != phys_mem ? lowest_limit : phys_mem;\n+  physical_memory_size_type limit = value_unlimited;\n+  physical_memory_size_type lowest_limit = phys_mem;\n+  lowest_limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+  physical_memory_size_type orig_limit = lowest_limit != phys_mem ? lowest_limit : phys_mem;\n@@ -77,2 +118,2 @@\n-    limit = mem->read_memory_limit_in_bytes(phys_mem);\n-    if (limit >= 0 && limit < lowest_limit) {\n+    limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+    if (limit < lowest_limit) {\n@@ -86,2 +127,2 @@\n-  limit = mem->read_memory_limit_in_bytes(phys_mem);\n-  if (limit >= 0 && limit < lowest_limit) {\n+  limit = get_updated_mem_limit(mem, lowest_limit, phys_mem);\n+  if (limit < lowest_limit) {\n@@ -92,2 +133,2 @@\n-  assert(lowest_limit >= 0, \"limit must be positive\");\n-  if ((julong)lowest_limit != orig_limit) {\n+  assert(lowest_limit <= phys_mem, \"limit must not exceed host memory\");\n+  if (lowest_limit != orig_limit) {\n@@ -99,1 +140,1 @@\n-                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             \"Lowest limit was: \" PHYS_MEM_TYPE_FORMAT,\n@@ -103,1 +144,1 @@\n-    log_trace(os, container)(\"Lowest limit was: \" JLONG_FORMAT, lowest_limit);\n+    log_trace(os, container)(\"Lowest limit was: \" PHYS_MEM_TYPE_FORMAT, lowest_limit);\n@@ -117,2 +158,3 @@\n-    log_warning(os, container)(\"Cgroup cpu controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n-      cpu->mount_point(), cpu->cgroup_path());\n+    log_warning(os, container)(\"Cgroup cpu controller path at '%s' seems to have moved \"\n+                               \"to '%s'. Detected limits won't be accurate\",\n+                               cpu->mount_point(), cpu->cgroup_path());\n@@ -132,2 +174,2 @@\n-  int cpus = CgroupUtil::processor_count(cpu, host_cpus);\n-  int lowest_limit = cpus < host_cpus ? cpus: host_cpus;\n+  int lowest_limit = host_cpus;\n+  int cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -140,1 +182,1 @@\n-    cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+    cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -149,1 +191,1 @@\n-  cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n@@ -163,2 +205,1 @@\n-                             cpu->subsystem_path(),\n-                             lowest_limit);\n+                             cpu->subsystem_path(), lowest_limit);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":71,"deletions":30,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static bool processor_count(CgroupCpuController* cpu, int upper_bound, int& value);\n@@ -41,0 +41,7 @@\n+  private:\n+    static physical_memory_size_type get_updated_mem_limit(CgroupMemoryController* m,\n+                                                           physical_memory_size_type lowest,\n+                                                           physical_memory_size_type upper_bound);\n+    static int get_updated_cpu_limit(CgroupCpuController* c,\n+                                     int lowest,\n+                                     int upper_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,20 +138,2 @@\n-static inline\n-void verbose_log(julong read_mem_limit, julong upper_mem_bound) {\n-  if (log_is_enabled(Debug, os, container)) {\n-    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n-    if (mem_limit < 0 || read_mem_limit >= upper_mem_bound) {\n-      const char *reason;\n-      if (mem_limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n-      } else if (mem_limit == -1) {\n-        reason = \"unlimited\";\n-      } else {\n-        assert(read_mem_limit >= upper_mem_bound, \"Expected read value exceeding upper memory bound\");\n-        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n-        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n-        reason = \"ignored\";\n-      }\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n-                               reason, mem_limit, upper_mem_bound);\n-    }\n-  }\n+bool CgroupV1MemoryController::read_memory_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", result);\n@@ -160,3 +142,7 @@\n-jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n-  julong memlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+bool CgroupV1MemoryController::read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type memlimit = 0;\n+  if (!read_memory_limit_val(memlimit)) {\n+    log_trace(os, container)(\"container memory limit failed, upper bound is \" PHYS_MEM_TYPE_FORMAT, upper_bound);\n+    return false;\n+  }\n@@ -164,2 +150,5 @@\n-    verbose_log(memlimit, upper_bound);\n-    return (jlong)-1;\n+    \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+    \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+    log_trace(os, container)(\"container memory limit ignored: \" PHYS_MEM_TYPE_FORMAT\n+                             \", upper bound is \" PHYS_MEM_TYPE_FORMAT, memlimit, upper_bound);\n+    result = value_unlimited;\n@@ -167,2 +156,1 @@\n-    verbose_log(memlimit, upper_bound);\n-    return (jlong)memlimit;\n+    result = memlimit;\n@@ -170,0 +158,5 @@\n+  return true;\n+}\n+\n+bool CgroupV1MemoryController::read_mem_swap(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", result);\n@@ -172,1 +165,1 @@\n-\/* read_mem_swap\n+\/* memory_and_swap_limit_in_bytes\n@@ -174,3 +167,2 @@\n- * Determine the memory and swap limit metric. Returns a positive limit value strictly\n- * lower than the physical memory and swap limit iff there is a limit. Otherwise a\n- * negative value is returned indicating the determined status.\n+ * Determine the memory and swap limit metric. Returns a positive limit value or\n+ * value_unlimited (for unlimited).\n@@ -179,4 +171,2 @@\n- *    * A number > 0 if the limit is available and lower than a physical upper bound.\n- *    * OSCONTAINER_ERROR if the limit cannot be retrieved (i.e. not supported) or\n- *    * -1 if there isn't any limit in place (note: includes values which exceed a physical\n- *      upper bound)\n+ *    * false if an error occurred\n+ *    * true if the limit value has been set in the result reference\n@@ -184,8 +174,8 @@\n-jlong CgroupV1MemoryController::read_mem_swap(julong upper_memsw_bound) {\n-  julong memswlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  if (memswlimit >= upper_memsw_bound) {\n-    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n+bool CgroupV1MemoryController::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type total_mem_swap = upper_mem_bound + upper_swap_bound;\n+  physical_memory_size_type memory_swap = 0;\n+  bool mem_swap_read_failed = false;\n+  if (!read_mem_swap(memory_swap)) {\n+    mem_swap_read_failed = true;\n@@ -193,6 +183,4 @@\n-}\n-\n-jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_swap = read_mem_swap(upper_mem_bound + upper_swap_bound);\n-  if (memory_swap == -1) {\n-    return memory_swap;\n+  if (memory_swap >= total_mem_swap) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n+    result = value_unlimited;\n+    return true;\n@@ -203,5 +191,17 @@\n-  jlong swappiness = read_mem_swappiness();\n-  if (swappiness == 0 || memory_swap == OSCONTAINER_ERROR) {\n-    jlong memlimit = read_memory_limit_in_bytes(upper_mem_bound);\n-    if (memory_swap == OSCONTAINER_ERROR) {\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swap is not supported\", memlimit);\n+  physical_memory_size_type swappiness = 0;\n+  if (!read_mem_swappiness(swappiness)) {\n+    \/\/ assume no swap\n+    mem_swap_read_failed = true;\n+  }\n+  if (swappiness == 0 || mem_swap_read_failed) {\n+    physical_memory_size_type memlimit = value_unlimited;\n+    if (!read_memory_limit_in_bytes(upper_mem_bound, memlimit)) {\n+      return false;\n+    }\n+    if (memlimit == value_unlimited) {\n+      result = value_unlimited; \/\/ No memory limit, thus no swap limit\n+      return true;\n+    }\n+    if (mem_swap_read_failed) {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" PHYS_MEM_TYPE_FORMAT\n+                               \" because swap is not supported\", memlimit);\n@@ -209,1 +209,2 @@\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swappiness is 0\", memlimit);\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" PHYS_MEM_TYPE_FORMAT\n+                               \" because swappiness is 0\", memlimit);\n@@ -211,1 +212,2 @@\n-    return memlimit;\n+    result = memlimit;\n+    return true;\n@@ -213,1 +215,2 @@\n-  return memory_swap;\n+  result = memory_swap;\n+  return true;\n@@ -217,13 +220,16 @@\n-jlong memory_swap_usage_impl(CgroupController* ctrl) {\n-  julong memory_swap_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n-  return (jlong)memory_swap_usage;\n-}\n-\n-jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n-  jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n-  if (memory_sw_limit > 0 && memory_limit > 0) {\n-    jlong delta_swap = memory_sw_limit - memory_limit;\n-    if (delta_swap > 0) {\n-      return memory_swap_usage_impl(reader());\n+bool memory_swap_usage_impl(CgroupController* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type memory_sw_limit = value_unlimited;\n+  if (!memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound, memory_sw_limit)) {\n+    return false;\n+  }\n+  physical_memory_size_type mem_limit_val = value_unlimited;\n+  physical_memory_size_type memory_limit = value_unlimited;\n+  if (read_memory_limit_in_bytes(upper_mem_bound, mem_limit_val)) {\n+    if (mem_limit_val != value_unlimited) {\n+      memory_limit = mem_limit_val;\n@@ -232,1 +238,16 @@\n-  return memory_usage_in_bytes();\n+  if (memory_sw_limit != value_unlimited && memory_limit != value_unlimited) {\n+    if (memory_limit < memory_sw_limit) {\n+      \/\/ swap allowed and > 0\n+      physical_memory_size_type swap_usage = 0;\n+      if (!memory_swap_usage_impl(reader(), swap_usage)) {\n+        return false;\n+      }\n+      result = swap_usage;\n+      return true;\n+    }\n+  }\n+  return memory_usage_in_bytes(result);\n+}\n+\n+bool CgroupV1MemoryController::read_mem_swappiness(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", result);\n@@ -235,4 +256,2 @@\n-jlong CgroupV1MemoryController::read_mem_swappiness() {\n-  julong swappiness;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n-  return (jlong)swappiness;\n+bool CgroupV1MemoryController::memory_soft_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", result);\n@@ -241,4 +260,7 @@\n-jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n-  julong memsoftlimit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= upper_bound) {\n+bool CgroupV1MemoryController::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type mem_soft_limit = 0;\n+  if (!memory_soft_limit_val(mem_soft_limit)) {\n+    return false;\n+  }\n+  if (mem_soft_limit >= upper_bound) {\n@@ -246,1 +268,1 @@\n-    return (jlong)-1;\n+    result = value_unlimited;\n@@ -248,1 +270,1 @@\n-    return (jlong)memsoftlimit;\n+    result = mem_soft_limit;\n@@ -250,0 +272,1 @@\n+  return true;\n@@ -252,1 +275,1 @@\n-jlong CgroupV1MemoryController::memory_throttle_limit_in_bytes() {\n+bool CgroupV1MemoryController::memory_throttle_limit_in_bytes(physical_memory_size_type& result) {\n@@ -255,1 +278,1 @@\n-  return OSCONTAINER_ERROR; \/\/ not supported\n+  return false;\n@@ -284,1 +307,10 @@\n-\/* memory_usage_in_bytes\n+bool CgroupV1MemoryController::memory_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type memory_usage = 0;\n+  if (!memory_usage_val(memory_usage)) {\n+    return false;\n+  }\n+  result = memory_usage;\n+  return true;\n+}\n+\n+\/* memory_usage_val\n@@ -286,1 +318,1 @@\n- * Return the amount of used memory for this process.\n+ * Read the amount of used memory for this process into the passed in reference 'result'\n@@ -289,3 +321,2 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true when reading of the file was successful and 'result' was set appropriately\n+ *    false when reading of the file failed\n@@ -293,4 +324,6 @@\n-jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV1MemoryController::memory_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", result);\n+}\n+\n+bool CgroupV1MemoryController::memory_max_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", result);\n@@ -301,1 +334,2 @@\n- * Return the maximum amount of used memory for this process.\n+ * Return the maximum amount of used memory for this process in the\n+ * result reference.\n@@ -304,2 +338,2 @@\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the result reference has been set\n+ *    false otherwise (e.g. on error)\n@@ -307,4 +341,18 @@\n-jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n-  julong memmaxusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n-  return (jlong)memmaxusage;\n+bool CgroupV1MemoryController::memory_max_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type memory_max_usage = 0;\n+  if (!memory_max_usage_val(memory_max_usage)) {\n+     return false;\n+  }\n+  result = memory_max_usage;\n+  return true;\n+}\n+\n+bool CgroupV1MemoryController::rss_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type rss = 0;\n+\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", rss)) {\n+    return false;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" PHYS_MEM_TYPE_FORMAT, rss);\n+  result = rss;\n+  return true;\n@@ -313,5 +361,4 @@\n-jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1MemoryController::cache_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type cache = 0;\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", cache)) {\n+    return false;\n@@ -319,2 +366,7 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"Cache usage is: \" PHYS_MEM_TYPE_FORMAT, cache);\n+  result = cache;\n+  return true;\n+}\n+\n+bool CgroupV1MemoryController::kernel_memory_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", result);\n@@ -323,5 +375,4 @@\n-jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1MemoryController::kernel_memory_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_usage = 0;\n+  if (!kernel_memory_usage_val(kmem_usage)) {\n+    return false;\n@@ -329,2 +380,2 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return cache;\n+  result = kmem_usage;\n+  return true;\n@@ -333,4 +384,2 @@\n-jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n-  julong kmem_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n-  return (jlong)kmem_usage;\n+bool CgroupV1MemoryController::kernel_memory_limit_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", result);\n@@ -339,3 +388,6 @@\n-jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong upper_bound) {\n-  julong kmem_limit;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+bool CgroupV1MemoryController::kernel_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                            physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_limit = 0;\n+  if (!kernel_memory_limit_val(kmem_limit)) {\n+    return false;\n+  }\n@@ -343,1 +395,1 @@\n-    return (jlong)-1;\n+    kmem_limit = value_unlimited;\n@@ -345,1 +397,2 @@\n-  return (jlong)kmem_limit;\n+  result = kmem_limit;\n+  return true;\n@@ -348,4 +401,2 @@\n-jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n-  julong kmem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n-  return (jlong)kmem_max_usage;\n+bool CgroupV1MemoryController::kernel_memory_max_usage_val(physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", result);\n@@ -354,4 +405,25 @@\n-void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong mem_bound) {\n-  jlong kmem_usage = kernel_memory_usage_in_bytes();\n-  jlong kmem_limit = kernel_memory_limit_in_bytes(mem_bound);\n-  jlong kmem_max_usage = kernel_memory_max_usage_in_bytes();\n+bool CgroupV1MemoryController::kernel_memory_max_usage_in_bytes(physical_memory_size_type& result) {\n+  physical_memory_size_type kmem_max_usage = 0;\n+  if (!kernel_memory_max_usage_val(kmem_max_usage)) {\n+    return false;\n+  }\n+  result = kmem_max_usage;\n+  return true;\n+}\n+\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, physical_memory_size_type mem_bound) {\n+  MetricResult kmem_usage;\n+  physical_memory_size_type temp = 0;\n+  if (kernel_memory_usage_in_bytes(temp)) {\n+    kmem_usage.set_value(temp);\n+  }\n+  MetricResult kmem_limit;\n+  temp = value_unlimited;\n+  if (kernel_memory_limit_in_bytes(mem_bound, temp)) {\n+    kmem_limit.set_value(temp);\n+  }\n+  MetricResult kmem_max_usage;\n+  temp = 0;\n+  if (kernel_memory_max_usage_in_bytes(temp)) {\n+    kmem_max_usage.set_value(temp);\n+  }\n@@ -379,1 +451,2 @@\n- * process is guaranteed to run.\n+ * a process is guaranteed to run in the provided\n+ * result reference.\n@@ -382,3 +455,3 @@\n- *    quota time in microseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n+ *   true if the value was set in the result reference\n+ *   false on failure to read the number from the file\n+ *   and the result reference has not been touched.\n@@ -386,6 +459,8 @@\n-int CgroupV1CpuController::cpu_quota() {\n-  julong quota;\n-  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n-  if (!is_ok) {\n-    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+bool CgroupV1CpuController::cpu_quota(int& result) {\n+  uint64_t quota = 0;\n+\n+  \/\/ intentionally not using the macro so as to not log a\n+  \/\/ negative value as a large unsiged int\n+  if (!reader()->read_number(\"\/cpu.cfs_quota_us\", quota)) {\n+    log_trace(os, container)(\"CPU Quota failed: -2\");\n+    return false;\n@@ -395,1 +470,1 @@\n-  int quota_int = (int)quota;\n+  int quota_int = static_cast<int>(quota);\n@@ -397,1 +472,2 @@\n-  return quota_int;\n+  result = quota_int;\n+  return true;\n@@ -400,4 +476,15 @@\n-int CgroupV1CpuController::cpu_period() {\n-  julong period;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n-  return (int)period;\n+bool CgroupV1CpuController::cpu_period_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", result);\n+}\n+\n+bool CgroupV1CpuController::cpu_period(int& result) {\n+  uint64_t period = value_unlimited;\n+  if (!cpu_period_val(period)) {\n+    return false;\n+  }\n+  result = static_cast<int>(period);\n+  return true;\n+}\n+\n+bool CgroupV1CpuController::cpu_shares_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", result);\n@@ -409,0 +496,2 @@\n+ *    - Share number (typically a number relative to 1024)\n+ *    - (2048 typically expresses 2 CPUs worth of processing)\n@@ -411,4 +500,2 @@\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on error\n+ *    true if the result has been set in the result reference\n@@ -416,4 +503,6 @@\n-int CgroupV1CpuController::cpu_shares() {\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n-  int shares_int = (int)shares;\n+bool CgroupV1CpuController::cpu_shares(int& result) {\n+  uint64_t shares = 0;\n+  if (!cpu_shares_val(shares)) {\n+    return false;\n+  }\n+  int shares_int = static_cast<int>(shares);\n@@ -421,1 +510,5 @@\n-  if (shares_int == 1024) return -1;\n+  if (shares_int == 1024) return false;\n+\n+  result = shares_int;\n+  return true;\n+}\n@@ -423,1 +516,2 @@\n-  return shares_int;\n+bool CgroupV1CpuacctController::cpu_usage_in_micros_val(uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", result);\n@@ -426,3 +520,5 @@\n-jlong CgroupV1CpuacctController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpuacct.usage\", \"CPU Usage\", cpu_usage);\n+bool CgroupV1CpuacctController::cpu_usage_in_micros(uint64_t& result) {\n+  uint64_t cpu_usage = 0;\n+  if (!cpu_usage_in_micros_val(cpu_usage)) {\n+    return false;\n+  }\n@@ -430,1 +526,7 @@\n-  return (jlong)cpu_usage \/ 1000;\n+  result = static_cast<uint64_t>(cpu_usage \/ 1000);\n+  return true;\n+}\n+\n+static\n+bool pids_max_val(CgroupController* ctrl, uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/pids.max\", \"Maximum number of tasks\", result);\n@@ -436,0 +538,1 @@\n+ * in the passed result reference (might be value_unlimited).\n@@ -438,3 +541,2 @@\n- *    maximum number of tasks\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on error\n+ *    true when the result reference has been appropriately set\n@@ -442,5 +544,13 @@\n-jlong CgroupV1Subsystem::pids_max() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+bool CgroupV1Subsystem::pids_max(uint64_t& result) {\n+  if (_pids == nullptr) return false;\n+  uint64_t pids_val = 0;\n+  if (!pids_max_val(_pids, pids_val)) {\n+    return false;\n+  }\n+  result = pids_val;\n+  return true;\n+}\n+\n+static\n+bool pids_current_val(CgroupController* ctrl, uint64_t& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/pids.current\", \"Current number of tasks\", result);\n@@ -454,2 +564,2 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the current number of tasks has been set in the result reference\n+ *    false if an error occurred\n@@ -457,5 +567,8 @@\n-jlong CgroupV1Subsystem::pids_current() {\n-  if (_pids == nullptr) return OSCONTAINER_ERROR;\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return (jlong)pids_current;\n+bool CgroupV1Subsystem::pids_current(uint64_t& result) {\n+  if (_pids == nullptr) return false;\n+  uint64_t pids_current = 0;\n+  if (!pids_current_val(_pids, pids_current)) {\n+    return false;\n+  }\n+  result = pids_current;\n+  return true;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":288,"deletions":175,"binary":false,"changes":463,"status":"modified"},{"patch":"@@ -76,0 +76,10 @@\n+    bool read_memory_limit_val(physical_memory_size_type& result);\n+    bool memory_usage_val(physical_memory_size_type& result);\n+    bool read_mem_swappiness(physical_memory_size_type& result);\n+    bool read_mem_swap(physical_memory_size_type& result);\n+    bool memory_soft_limit_val(physical_memory_size_type& result);\n+    bool memory_max_usage_val(physical_memory_size_type& result);\n+    bool kernel_memory_usage_val(physical_memory_size_type& result);\n+    bool kernel_memory_limit_val(physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_val(physical_memory_size_type& result);\n+\n@@ -80,13 +90,20 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes(julong upper_bound);\n-    jlong kernel_memory_max_usage_in_bytes();\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n+    bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& value) override;\n+    bool memory_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool rss_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool cache_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool kernel_memory_usage_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                      physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_in_bytes(physical_memory_size_type& result);\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) override;\n@@ -102,3 +119,0 @@\n-  private:\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap(julong upper_memsw_bound);\n@@ -118,0 +132,2 @@\n+    bool cpu_period_val(uint64_t& result);\n+    bool cpu_shares_val(uint64_t& result);\n@@ -119,3 +135,3 @@\n-    int cpu_quota() override;\n-    int cpu_period() override;\n-    int cpu_shares() override;\n+    bool cpu_quota(int& result) override;\n+    bool cpu_period(int& result) override;\n+    bool cpu_shares(int& result) override;\n@@ -149,0 +165,1 @@\n+    bool cpu_usage_in_micros_val(uint64_t& result);\n@@ -150,1 +167,1 @@\n-    jlong cpu_usage_in_micros() override;\n+    bool cpu_usage_in_micros(uint64_t& result) override;\n@@ -182,3 +199,3 @@\n-    jlong kernel_memory_usage_in_bytes();\n-    jlong kernel_memory_limit_in_bytes();\n-    jlong kernel_memory_max_usage_in_bytes();\n+    bool kernel_memory_usage_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_limit_in_bytes(physical_memory_size_type& result);\n+    bool kernel_memory_max_usage_in_bytes(physical_memory_size_type& result);\n@@ -186,2 +203,2 @@\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n@@ -189,2 +206,2 @@\n-    jlong pids_max();\n-    jlong pids_current();\n+    bool pids_max(uint64_t& result) override;\n+    bool pids_current(uint64_t& result) override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":44,"deletions":27,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -45,0 +45,5 @@\n+static\n+bool read_cpu_shares_value(CgroupV2Controller* ctrl, uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/cpu.weight\", \"Raw value for CPU Shares\", value);\n+}\n+\n@@ -47,1 +52,2 @@\n- * Return the amount of cpu shares available to the process\n+ * Return the amount of cpu shares available to the process in the\n+ * 'result' reference.\n@@ -49,1 +55,0 @@\n- * return:\n@@ -52,2 +57,4 @@\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n+ *\n+ * return:\n+ *    true if the result reference got updated\n+ *    false if there was an error\n@@ -55,4 +62,7 @@\n-int CgroupV2CpuController::cpu_shares() {\n-  julong shares;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n-  int shares_int = (int)shares;\n+bool CgroupV2CpuController::cpu_shares(int& result) {\n+  uint64_t shares = 0;\n+  bool is_ok = read_cpu_shares_value(reader(), shares);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int shares_int = static_cast<int>(shares);\n@@ -61,2 +71,3 @@\n-    log_debug(os, container)(\"CPU Shares is: %d\", -1);\n-    return -1;\n+    log_debug(os, container)(\"CPU Shares is: -1\");\n+    result = -1;\n+    return true;\n@@ -81,1 +92,2 @@\n-     return x;\n+     result = x;\n+     return true;\n@@ -91,1 +103,2 @@\n-  return x;\n+  result = x;\n+  return true;\n@@ -100,3 +113,2 @@\n- *    quota time in microseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the result reference has been set\n+ *    false on error\n@@ -104,5 +116,10 @@\n-int CgroupV2CpuController::cpu_quota() {\n-  jlong quota_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2CpuController::cpu_quota(int& result) {\n+  uint64_t quota_val = 0;\n+  if (!reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, quota_val)) {\n+    return false;\n+  }\n+  int limit = -1;\n+  \/\/ The read first tuple value might be 'max' which maps\n+  \/\/ to value_unlimited. Keep that at -1;\n+  if (quota_val != value_unlimited) {\n+    limit = static_cast<int>(quota_val);\n@@ -110,1 +127,0 @@\n-  int limit = (int)quota_val;\n@@ -112,1 +128,2 @@\n-  return limit;\n+  result = limit;\n+  return true;\n@@ -146,6 +163,5 @@\n-int CgroupV2CpuController::cpu_period() {\n-  jlong period_val;\n-  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n-  if (!is_ok) {\n-    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2CpuController::cpu_period(int& result) {\n+  uint64_t cpu_period = 0;\n+  if (!reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, cpu_period)) {\n+    log_trace(os, container)(\"CPU Period failed: -2\");\n+    return false;\n@@ -153,3 +169,4 @@\n-  int period = (int)period_val;\n-  log_trace(os, container)(\"CPU Period is: %d\", period);\n-  return period;\n+  int period_int = static_cast<int>(cpu_period);\n+  log_trace(os, container)(\"CPU Period is: %d\", period_int);\n+  result = period_int;\n+  return true;\n@@ -158,3 +175,2 @@\n-jlong CgroupV2CpuController::cpu_usage_in_micros() {\n-  julong cpu_usage;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", &cpu_usage);\n+bool CgroupV2CpuController::cpu_usage_in_micros(uint64_t& value) {\n+  bool is_ok = reader()->read_numerical_key_value(\"\/cpu.stat\", \"usage_usec\", value);\n@@ -162,2 +178,2 @@\n-    log_trace(os, container)(\"CPU Usage failed: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n+    log_trace(os, container)(\"CPU Usage failed: -2\");\n+    return false;\n@@ -165,2 +181,2 @@\n-  log_trace(os, container)(\"CPU Usage is: \" JULONG_FORMAT, cpu_usage);\n-  return (jlong)cpu_usage;\n+  log_trace(os, container)(\"CPU Usage is: \" UINT64_FORMAT, value);\n+  return true;\n@@ -171,1 +187,2 @@\n- * Return the amount of used memory used by this cgroup and descendents\n+ * read the amount of used memory used by this cgroup and descendents\n+ * into the passed in 'value' reference.\n@@ -174,3 +191,1 @@\n- *    memory usage in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    false on failure, true otherwise.\n@@ -178,4 +193,2 @@\n-jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n-  julong memusage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n-  return (jlong)memusage;\n+bool CgroupV2MemoryController::memory_usage_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", value);\n@@ -184,4 +197,3 @@\n-jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n-  jlong mem_soft_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n-  return mem_soft_limit;\n+bool CgroupV2MemoryController::memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", value);\n@@ -190,4 +202,2 @@\n-jlong CgroupV2MemoryController::memory_throttle_limit_in_bytes() {\n-  jlong mem_throttle_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", mem_throttle_limit);\n-  return mem_throttle_limit;\n+bool CgroupV2MemoryController::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.high\", \"Memory Throttle Limit\", value);\n@@ -196,4 +206,2 @@\n-jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n-  julong mem_max_usage;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", mem_max_usage);\n-  return mem_max_usage;\n+bool CgroupV2MemoryController::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.peak\", \"Maximum Memory Usage\", value);\n@@ -202,5 +210,3 @@\n-jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n-  julong rss;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2MemoryController::rss_usage_in_bytes(physical_memory_size_type& value) {\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", value)) {\n+    return false;\n@@ -208,2 +214,2 @@\n-  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n-  return (jlong)rss;\n+  log_trace(os, container)(\"RSS usage is: \" PHYS_MEM_TYPE_FORMAT, value);\n+  return true;\n@@ -212,5 +218,3 @@\n-jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n-  julong cache;\n-  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n-  if (!is_ok) {\n-    return OSCONTAINER_ERROR;\n+bool CgroupV2MemoryController::cache_usage_in_bytes(physical_memory_size_type& value) {\n+  if (!reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", value)) {\n+    return false;\n@@ -218,2 +222,2 @@\n-  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n-  return (jlong)cache;\n+  log_trace(os, container)(\"Cache usage is: \" PHYS_MEM_TYPE_FORMAT, value);\n+  return true;\n@@ -227,5 +231,5 @@\n-jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound,\n-                                                               julong upper_swap_bound \/* unused in cg v2 *\/) {\n-  jlong swap_limit;\n-  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n-  if (!is_ok) {\n+bool CgroupV2MemoryController::memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound, \/* unused in cg v2 *\/\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type swap_limit_val = 0;\n+  if (!reader()->read_number_handle_max(\"\/memory.swap.max\", swap_limit_val)) {\n@@ -233,1 +237,1 @@\n-    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed: -2\");\n@@ -235,1 +239,6 @@\n-    return read_memory_limit_in_bytes(upper_mem_bound);\n+    physical_memory_size_type mem_limit = value_unlimited;\n+    if (!read_memory_limit_in_bytes(upper_mem_bound, mem_limit)) {\n+      return false;\n+    }\n+    result = mem_limit;\n+    return true;\n@@ -237,5 +246,14 @@\n-  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n-  if (swap_limit >= 0) {\n-    jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n-    assert(memory_limit >= 0, \"swap limit without memory limit?\");\n-    return memory_limit + swap_limit;\n+  if (swap_limit_val == value_unlimited) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n+    result = swap_limit_val;\n+    return true;\n+  }\n+  log_trace(os, container)(\"Swap Limit is: \" PHYS_MEM_TYPE_FORMAT, swap_limit_val);\n+  physical_memory_size_type memory_limit = 0;\n+  if (read_memory_limit_in_bytes(upper_mem_bound, memory_limit)) {\n+    assert(memory_limit != value_unlimited, \"swap limit without memory limit?\");\n+    result = memory_limit + swap_limit_val;\n+    log_trace(os, container)(\"Memory and Swap Limit is: \" PHYS_MEM_TYPE_FORMAT, result);\n+    return true;\n+  } else {\n+    return false;\n@@ -243,2 +261,0 @@\n-  log_trace(os, container)(\"Memory and Swap Limit is: \" JLONG_FORMAT, swap_limit);\n-  return swap_limit;\n@@ -249,4 +265,2 @@\n-jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n-  julong swap_current;\n-  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n-  return (jlong)swap_current;\n+bool memory_swap_current_value(CgroupV2Controller* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", result);\n@@ -255,5 +269,11 @@\n-jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n-  jlong memory_usage = memory_usage_in_bytes();\n-  if (memory_usage >= 0) {\n-      jlong swap_current = memory_swap_current_value(reader());\n-      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+bool CgroupV2MemoryController::memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                                              physical_memory_size_type upper_swap_bound,\n+                                                              physical_memory_size_type& result) {\n+  physical_memory_size_type memory_usage = 0;\n+  if (!memory_usage_in_bytes(memory_usage)) {\n+     return false;\n+  }\n+  physical_memory_size_type swap_current = 0;\n+  if (!memory_swap_current_value(reader(), swap_current)) {\n+    result = memory_usage; \/\/ treat as no swap usage\n+    return true;\n@@ -261,1 +281,2 @@\n-  return memory_usage; \/\/ not supported or unlimited case\n+  result = memory_usage + swap_current;\n+  return true;\n@@ -265,4 +286,2 @@\n-jlong memory_limit_value(CgroupV2Controller* ctrl) {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+bool memory_limit_value(CgroupV2Controller* ctrl, physical_memory_size_type& result) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", result);\n@@ -273,1 +292,2 @@\n- * Return the limit of available memory for this process.\n+ * Calculate the limit of available memory for this process. The result will be\n+ * set in the 'result' variable if the function returns true.\n@@ -276,2 +296,2 @@\n- *    memory limit in bytes or\n- *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *    true when the limit could be read correctly.\n+ *    false in case of any error.\n@@ -279,2 +299,13 @@\n-jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n-  jlong limit = memory_limit_value(reader());\n+bool CgroupV2MemoryController::read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                                          physical_memory_size_type& result) {\n+  physical_memory_size_type limit = 0; \/\/ default unlimited\n+  if (!memory_limit_value(reader(), limit)) {\n+    log_trace(os, container)(\"container memory limit failed, using host value \" PHYS_MEM_TYPE_FORMAT,\n+                              upper_bound);\n+    return false;\n+  }\n+  bool is_unlimited = limit == value_unlimited;\n+  bool exceeds_physical_mem = false;\n+  if (!is_unlimited && limit >= upper_bound) {\n+    exceeds_physical_mem = true;\n+  }\n@@ -282,4 +313,2 @@\n-    if (limit == -1) {\n-      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n-    } else {\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    if (!is_unlimited) {\n+      log_trace(os, container)(\"Memory Limit is: \" PHYS_MEM_TYPE_FORMAT, limit);\n@@ -287,9 +316,4 @@\n-  }\n-  if (log_is_enabled(Debug, os, container)) {\n-    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n-    if (limit < 0 || read_limit >= upper_bound) {\n-      const char* reason;\n-      if (limit == -1) {\n-        reason = \"unlimited\";\n-      } else if (limit == OSCONTAINER_ERROR) {\n-        reason = \"failed\";\n+    if (is_unlimited || exceeds_physical_mem) {\n+      if (is_unlimited) {\n+        log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+        log_trace(os, container)(\"container memory limit unlimited, using upper bound value \" PHYS_MEM_TYPE_FORMAT, upper_bound);\n@@ -297,2 +321,2 @@\n-        assert(read_limit >= upper_bound, \"Expected mem limit to exceed upper memory bound\");\n-        reason = \"ignored\";\n+        log_trace(os, container)(\"container memory limit ignored: \" PHYS_MEM_TYPE_FORMAT \", upper bound is \" PHYS_MEM_TYPE_FORMAT,\n+                                 limit, upper_bound);\n@@ -300,2 +324,0 @@\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n-                               reason, limit, upper_bound);\n@@ -304,1 +326,2 @@\n-  return limit;\n+  result = limit;\n+  return true;\n@@ -308,4 +331,2 @@\n-jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n+bool memory_swap_limit_value(CgroupV2Controller* ctrl, physical_memory_size_type& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", value);\n@@ -330,4 +351,11 @@\n-void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n-  jlong swap_current = memory_swap_current_value(reader());\n-  jlong swap_limit = memory_swap_limit_value(reader());\n-\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) {\n+  MetricResult swap_current;\n+  physical_memory_size_type swap_current_val = 0;\n+  if (memory_swap_current_value(reader(), swap_current_val)) {\n+    swap_current.set_value(swap_current_val);\n+  }\n+  MetricResult swap_limit;\n+  physical_memory_size_type swap_limit_val = 0;\n+  if (memory_swap_limit_value(reader(), swap_limit_val)) {\n+    swap_limit.set_value(swap_limit_val);\n+  }\n@@ -349,1 +377,3 @@\n- * Return the maximum number of tasks available to the process\n+ * Calculate the maximum number of tasks available to the process. Set the\n+ * value in the passed in 'value' reference. The value might be -1 when\n+ * there is no limit.\n@@ -352,3 +382,2 @@\n- *    maximum number of tasks\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n+ *    true if the value has been set appropriately\n+ *    false if there was an error\n@@ -356,4 +385,2 @@\n-jlong CgroupV2Subsystem::pids_max() {\n-  jlong pids_max;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n-  return pids_max;\n+bool CgroupV2Subsystem::pids_max(uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", value);\n@@ -364,1 +391,2 @@\n- * The number of tasks currently in the cgroup (and its descendants) of the process\n+ * The number of tasks currently in the cgroup (and its descendants) of the process. Set\n+ * in the passed in 'value' reference.\n@@ -367,2 +395,2 @@\n- *    current number of tasks\n- *    OSCONTAINER_ERROR for not supported\n+ *    true on success\n+ *    false when there was an error\n@@ -370,4 +398,2 @@\n-jlong CgroupV2Subsystem::pids_current() {\n-  julong pids_current;\n-  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n-  return pids_current;\n+bool CgroupV2Subsystem::pids_current(uint64_t& value) {\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", value);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":172,"deletions":146,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -62,4 +62,4 @@\n-    int cpu_quota() override;\n-    int cpu_period() override;\n-    int cpu_shares() override;\n-    jlong cpu_usage_in_micros();\n+    bool cpu_quota(int& value) override;\n+    bool cpu_period(int& value) override;\n+    bool cpu_shares(int& value) override;\n+    bool cpu_usage_in_micros(uint64_t& value);\n@@ -90,2 +90,2 @@\n-    jlong cpu_usage_in_micros() override {\n-      return reader()->cpu_usage_in_micros();\n+    bool cpu_usage_in_micros(uint64_t& result) override {\n+      return reader()->cpu_usage_in_micros(result);\n@@ -113,0 +113,1 @@\n+\n@@ -117,10 +118,16 @@\n-    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n-    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n-    jlong memory_throttle_limit_in_bytes() override;\n-    jlong memory_usage_in_bytes() override;\n-    jlong memory_max_usage_in_bytes() override;\n-    jlong rss_usage_in_bytes() override;\n-    jlong cache_usage_in_bytes() override;\n-    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n+    bool read_memory_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_and_swap_limit_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_and_swap_usage_in_bytes(physical_memory_size_type upper_mem_bound,\n+                                        physical_memory_size_type upper_swap_bound,\n+                                        physical_memory_size_type& result) override;\n+    bool memory_soft_limit_in_bytes(physical_memory_size_type upper_bound,\n+                                    physical_memory_size_type& result) override;\n+    bool memory_throttle_limit_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool memory_max_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool rss_usage_in_bytes(physical_memory_size_type& result) override;\n+    bool cache_usage_in_bytes(physical_memory_size_type& result) override;\n+    void print_version_specific_info(outputStream* st, physical_memory_size_type upper_mem_bound) override;\n@@ -163,2 +170,2 @@\n-    jlong pids_max() override;\n-    jlong pids_current() override;\n+    bool pids_max(uint64_t& result) override;\n+    bool pids_current(uint64_t& result) override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -87,2 +87,6 @@\n-    any_mem_cpu_limit_present = memory_limit_in_bytes() > 0 ||\n-                                os::Linux::active_processor_count() != active_processor_count();\n+    physical_memory_size_type mem_limit_val = value_unlimited;\n+    (void)memory_limit_in_bytes(mem_limit_val);  \/\/ discard error and use default\n+    int host_cpus = os::Linux::active_processor_count();\n+    int cpus = host_cpus;\n+    (void)active_processor_count(cpus);  \/\/ discard error and use default\n+    any_mem_cpu_limit_present = mem_limit_val != value_unlimited || host_cpus != cpus;\n@@ -106,15 +110,4 @@\n-bool OSContainer::available_memory_in_container(julong& value) {\n-  jlong mem_limit = memory_limit_in_bytes();\n-  jlong mem_usage = memory_usage_in_bytes();\n-\n-  if (mem_limit > 0 && mem_usage <= 0) {\n-    log_debug(os, container)(\"container memory usage failed: \" JLONG_FORMAT, mem_usage);\n-  }\n-\n-  if (mem_limit <= 0 || mem_usage <= 0) {\n-    return false;\n-  }\n-\n-  value = mem_limit > mem_usage ? static_cast<julong>(mem_limit - mem_usage) : 0;\n-\n-  return true;\n+bool OSContainer::memory_limit_in_bytes(physical_memory_size_type& value) {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  return cgroup_subsystem->memory_limit_in_bytes(phys_mem, value);\n@@ -123,4 +116,12 @@\n-jlong OSContainer::memory_limit_in_bytes() {\n-  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  return cgroup_subsystem->memory_limit_in_bytes(phys_mem);\n+bool OSContainer::available_memory_in_bytes(physical_memory_size_type& value) {\n+  physical_memory_size_type mem_limit = value_unlimited;\n+  physical_memory_size_type mem_usage = 0;\n+  if (memory_limit_in_bytes(mem_limit) && memory_usage_in_bytes(mem_usage)) {\n+    assert(mem_usage != value_unlimited, \"invariant\");\n+    if (mem_limit != value_unlimited) {\n+      value = (mem_limit > mem_usage) ? mem_limit - mem_usage : 0;\n+      return true;\n+    }\n+  }\n+  log_trace(os, container)(\"calculating available memory in container failed\");\n+  return false;\n@@ -129,1 +130,1 @@\n-jlong OSContainer::memory_and_swap_limit_in_bytes() {\n+bool OSContainer::memory_and_swap_limit_in_bytes(physical_memory_size_type& value) {\n@@ -131,3 +132,6 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return cgroup_subsystem->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  physical_memory_size_type host_swap = 0;\n+  if (!os::Linux::host_swap(host_swap)) {\n+    return false;\n+  }\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes(phys_mem, host_swap, value);\n@@ -136,1 +140,1 @@\n-jlong OSContainer::memory_and_swap_usage_in_bytes() {\n+bool OSContainer::memory_and_swap_usage_in_bytes(physical_memory_size_type& value) {\n@@ -138,3 +142,6 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return cgroup_subsystem->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  physical_memory_size_type host_swap = 0;\n+  if (!os::Linux::host_swap(host_swap)) {\n+    return false;\n+  }\n+  return cgroup_subsystem->memory_and_swap_usage_in_bytes(phys_mem, host_swap, value);\n@@ -143,1 +150,1 @@\n-jlong OSContainer::memory_soft_limit_in_bytes() {\n+bool OSContainer::memory_soft_limit_in_bytes(physical_memory_size_type& value) {\n@@ -145,2 +152,2 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  return cgroup_subsystem->memory_soft_limit_in_bytes(phys_mem);\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n+  return cgroup_subsystem->memory_soft_limit_in_bytes(phys_mem, value);\n@@ -149,1 +156,1 @@\n-jlong OSContainer::memory_throttle_limit_in_bytes() {\n+bool OSContainer::memory_throttle_limit_in_bytes(physical_memory_size_type& value) {\n@@ -151,1 +158,1 @@\n-  return cgroup_subsystem->memory_throttle_limit_in_bytes();\n+  return cgroup_subsystem->memory_throttle_limit_in_bytes(value);\n@@ -154,1 +161,1 @@\n-jlong OSContainer::memory_usage_in_bytes() {\n+bool OSContainer::memory_usage_in_bytes(physical_memory_size_type& value) {\n@@ -156,1 +163,1 @@\n-  return cgroup_subsystem->memory_usage_in_bytes();\n+  return cgroup_subsystem->memory_usage_in_bytes(value);\n@@ -159,1 +166,1 @@\n-jlong OSContainer::memory_max_usage_in_bytes() {\n+bool OSContainer::memory_max_usage_in_bytes(physical_memory_size_type& value) {\n@@ -161,1 +168,1 @@\n-  return cgroup_subsystem->memory_max_usage_in_bytes();\n+  return cgroup_subsystem->memory_max_usage_in_bytes(value);\n@@ -164,1 +171,1 @@\n-jlong OSContainer::rss_usage_in_bytes() {\n+bool OSContainer::rss_usage_in_bytes(physical_memory_size_type& value) {\n@@ -166,1 +173,1 @@\n-  return cgroup_subsystem->rss_usage_in_bytes();\n+  return cgroup_subsystem->rss_usage_in_bytes(value);\n@@ -169,1 +176,1 @@\n-jlong OSContainer::cache_usage_in_bytes() {\n+bool OSContainer::cache_usage_in_bytes(physical_memory_size_type& value) {\n@@ -171,1 +178,1 @@\n-  return cgroup_subsystem->cache_usage_in_bytes();\n+  return cgroup_subsystem->cache_usage_in_bytes(value);\n@@ -176,1 +183,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  physical_memory_size_type phys_mem = os::Linux::physical_memory();\n@@ -190,1 +197,1 @@\n-int OSContainer::active_processor_count() {\n+bool OSContainer::active_processor_count(int& value) {\n@@ -192,1 +199,1 @@\n-  return cgroup_subsystem->active_processor_count();\n+  return cgroup_subsystem->active_processor_count(value);\n@@ -195,1 +202,1 @@\n-int OSContainer::cpu_quota() {\n+bool OSContainer::cpu_quota(int& value) {\n@@ -197,1 +204,1 @@\n-  return cgroup_subsystem->cpu_quota();\n+  return cgroup_subsystem->cpu_quota(value);\n@@ -200,1 +207,1 @@\n-int OSContainer::cpu_period() {\n+bool OSContainer::cpu_period(int& value) {\n@@ -202,1 +209,1 @@\n-  return cgroup_subsystem->cpu_period();\n+  return cgroup_subsystem->cpu_period(value);\n@@ -205,1 +212,1 @@\n-int OSContainer::cpu_shares() {\n+bool OSContainer::cpu_shares(int& value) {\n@@ -207,1 +214,1 @@\n-  return cgroup_subsystem->cpu_shares();\n+  return cgroup_subsystem->cpu_shares(value);\n@@ -210,1 +217,1 @@\n-jlong OSContainer::cpu_usage_in_micros() {\n+bool OSContainer::cpu_usage_in_micros(uint64_t& value) {\n@@ -212,1 +219,1 @@\n-  return cgroup_subsystem->cpu_usage_in_micros();\n+  return cgroup_subsystem->cpu_usage_in_micros(value);\n@@ -215,1 +222,1 @@\n-jlong OSContainer::pids_max() {\n+bool OSContainer::pids_max(uint64_t& value) {\n@@ -217,1 +224,1 @@\n-  return cgroup_subsystem->pids_max();\n+  return cgroup_subsystem->pids_max(value);\n@@ -220,1 +227,1 @@\n-jlong OSContainer::pids_current() {\n+bool OSContainer::pids_current(uint64_t& value) {\n@@ -222,1 +229,1 @@\n-  return cgroup_subsystem->pids_current();\n+  return cgroup_subsystem->pids_current(value);\n@@ -225,1 +232,1 @@\n-void OSContainer::print_container_helper(outputStream* st, jlong j, const char* metrics) {\n+void OSContainer::print_container_helper(outputStream* st, MetricResult& res, const char* metrics) {\n@@ -227,3 +234,7 @@\n-  if (j >= 0) {\n-    if (j >= 1024) {\n-      st->print_cr(UINT64_FORMAT \" k\", uint64_t(j) \/ K);\n+  if (res.success()) {\n+    if (res.value() != value_unlimited) {\n+      if (res.value() >= 1024) {\n+        st->print_cr(PHYS_MEM_TYPE_FORMAT \" k\", (physical_memory_size_type)(res.value() \/ K));\n+      } else {\n+        st->print_cr(PHYS_MEM_TYPE_FORMAT, res.value());\n+      }\n@@ -231,1 +242,1 @@\n-      st->print_cr(UINT64_FORMAT, uint64_t(j));\n+      st->print_cr(\"%s\", \"unlimited\");\n@@ -234,1 +245,2 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    \/\/ Not supported\n+    st->print_cr(\"%s\", \"unavailable\");\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":75,"deletions":63,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-#define OSCONTAINER_ERROR (-2)\n+\/\/ Some cgroup interface files define the value 'max' for unlimited.\n+\/\/ Define this constant value to indicate this value.\n+const uint64_t value_unlimited = std::numeric_limits<uint64_t>::max();\n@@ -38,0 +40,17 @@\n+\/\/ Carrier object for print_container_helper()\n+class MetricResult: public StackObj {\n+  private:\n+    static const uint64_t value_unused = 0;\n+    bool _success = false;\n+    physical_memory_size_type _value = value_unused;\n+  public:\n+    void set_value(physical_memory_size_type val) {\n+      \/\/ having a value means success\n+      _success = true;\n+      _value = val;\n+    }\n+\n+    bool success() { return _success; }\n+    physical_memory_size_type value() { return _value; }\n+};\n+\n@@ -48,1 +67,1 @@\n-  static void print_container_helper(outputStream* st, jlong j, const char* metrics);\n+  static void print_container_helper(outputStream* st, MetricResult& res, const char* metrics);\n@@ -53,10 +72,10 @@\n-  static bool available_memory_in_container(julong& value);\n-  static jlong memory_limit_in_bytes();\n-  static jlong memory_and_swap_limit_in_bytes();\n-  static jlong memory_and_swap_usage_in_bytes();\n-  static jlong memory_soft_limit_in_bytes();\n-  static jlong memory_throttle_limit_in_bytes();\n-  static jlong memory_usage_in_bytes();\n-  static jlong memory_max_usage_in_bytes();\n-  static jlong rss_usage_in_bytes();\n-  static jlong cache_usage_in_bytes();\n+  static bool available_memory_in_bytes(physical_memory_size_type& value);\n+  static bool memory_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_and_swap_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_and_swap_usage_in_bytes(physical_memory_size_type& value);\n+  static bool memory_soft_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_throttle_limit_in_bytes(physical_memory_size_type& value);\n+  static bool memory_usage_in_bytes(physical_memory_size_type& value);\n+  static bool memory_max_usage_in_bytes(physical_memory_size_type& value);\n+  static bool rss_usage_in_bytes(physical_memory_size_type& value);\n+  static bool cache_usage_in_bytes(physical_memory_size_type& value);\n@@ -64,1 +83,1 @@\n-  static int active_processor_count();\n+  static bool active_processor_count(int& value);\n@@ -69,2 +88,2 @@\n-  static int cpu_quota();\n-  static int cpu_period();\n+  static bool cpu_quota(int& value);\n+  static bool cpu_period(int& value);\n@@ -72,1 +91,1 @@\n-  static int cpu_shares();\n+  static bool cpu_shares(int& value);\n@@ -74,1 +93,1 @@\n-  static jlong cpu_usage_in_micros();\n+  static bool cpu_usage_in_micros(uint64_t& value);\n@@ -76,2 +95,2 @@\n-  static jlong pids_max();\n-  static jlong pids_current();\n+  static bool pids_max(uint64_t& value);\n+  static bool pids_current(uint64_t& value);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -217,4 +217,4 @@\n-  julong avail_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(avail_mem)) {\n-    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n-    value = static_cast<physical_memory_size_type>(avail_mem);\n+  physical_memory_size_type avail_mem = 0;\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(avail_mem)) {\n+    log_trace(os)(\"available container memory: \" PHYS_MEM_TYPE_FORMAT, avail_mem);\n+    value = avail_mem;\n@@ -228,1 +228,1 @@\n-  julong avail_mem = static_cast<julong>(-1L);\n+  physical_memory_size_type avail_mem = 0;\n@@ -230,0 +230,1 @@\n+  bool found_available_mem = false;\n@@ -234,1 +235,1 @@\n-      if (fscanf(fp, \"MemAvailable: \" JULONG_FORMAT \" kB\", &avail_mem) == 1) {\n+      if (fscanf(fp, \"MemAvailable: \" PHYS_MEM_TYPE_FORMAT \" kB\", &avail_mem) == 1) {\n@@ -236,0 +237,1 @@\n+        found_available_mem = true;\n@@ -241,1 +243,3 @@\n-  if (avail_mem == static_cast<julong>(-1L)) {\n+  \/\/ Only enter the free memory block if we\n+  \/\/ haven't found the available memory\n+  if (!found_available_mem) {\n@@ -246,1 +250,1 @@\n-    avail_mem = static_cast<julong>(free_mem);\n+    avail_mem = free_mem;\n@@ -248,2 +252,2 @@\n-  log_trace(os)(\"available memory: \" JULONG_FORMAT, avail_mem);\n-  value = static_cast<physical_memory_size_type>(avail_mem);\n+  log_trace(os)(\"available memory: \" PHYS_MEM_TYPE_FORMAT, avail_mem);\n+  value = avail_mem;\n@@ -254,4 +258,4 @@\n-  julong free_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(free_mem)) {\n-    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n-    value = static_cast<physical_memory_size_type>(free_mem);\n+  physical_memory_size_type free_mem = 0;\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(free_mem)) {\n+    log_trace(os)(\"free container memory: \" PHYS_MEM_TYPE_FORMAT, free_mem);\n+    value = free_mem;\n@@ -272,3 +276,3 @@\n-  julong free_mem = (julong)si.freeram * si.mem_unit;\n-  log_trace(os)(\"free memory: \" JULONG_FORMAT, free_mem);\n-  value = static_cast<physical_memory_size_type>(free_mem);\n+  physical_memory_size_type free_mem = (physical_memory_size_type)si.freeram * si.mem_unit;\n+  log_trace(os)(\"free memory: \" PHYS_MEM_TYPE_FORMAT, free_mem);\n+  value = free_mem;\n@@ -280,5 +284,9 @@\n-    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n-    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n-      value = static_cast<physical_memory_size_type>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n-      return true;\n+    physical_memory_size_type mem_swap_limit = value_unlimited;\n+    physical_memory_size_type memory_limit = value_unlimited;\n+    if (OSContainer::memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n+        OSContainer::memory_limit_in_bytes(memory_limit)) {\n+      if (memory_limit != value_unlimited && mem_swap_limit != value_unlimited &&\n+          mem_swap_limit >= memory_limit \/* ensure swap is >= 0 *\/) {\n+        value = mem_swap_limit - memory_limit;\n+        return true;\n+      }\n@@ -286,9 +294,2 @@\n-  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n-  struct sysinfo si;\n-  int ret = sysinfo(&si);\n-  if (ret != 0) {\n-    assert(false, \"sysinfo failed in total_swap_space(): %s\", os::strerror(errno));\n-    return false;\n-  }\n-  value = static_cast<physical_memory_size_type>(si.totalswap) * si.mem_unit;\n-  return true;\n+  } \/\/ fallback to the host swap space if the container returned unlimited\n+  return Linux::host_swap(value);\n@@ -318,6 +319,8 @@\n-    jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n-    if (mem_swap_limit >= 0 && mem_limit >= 0) {\n-      jlong delta_limit = mem_swap_limit - mem_limit;\n-      if (delta_limit <= 0) {\n-        value = 0;\n+    physical_memory_size_type mem_limit = 0;\n+    physical_memory_size_type mem_swap_limit = 0;\n+    if (OSContainer::memory_limit_in_bytes(mem_limit) &&\n+        OSContainer::memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n+        mem_limit != value_unlimited &&\n+        mem_swap_limit != value_unlimited) {\n+      if (mem_limit >= mem_swap_limit) {\n+        value = 0; \/\/ no swap, thus no free swap\n@@ -326,7 +329,14 @@\n-      jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n-      jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-      if (mem_swap_usage > 0 && mem_usage > 0) {\n-        jlong delta_usage = mem_swap_usage - mem_usage;\n-        if (delta_usage >= 0) {\n-          jlong free_swap = delta_limit - delta_usage;\n-          value = free_swap >= 0 ? static_cast<physical_memory_size_type>(free_swap) : 0;\n+      physical_memory_size_type swap_limit = mem_swap_limit - mem_limit;\n+      physical_memory_size_type mem_swap_usage = 0;\n+      physical_memory_size_type mem_usage = 0;\n+      if (OSContainer::memory_and_swap_usage_in_bytes(mem_swap_usage) &&\n+          OSContainer::memory_usage_in_bytes(mem_usage)) {\n+        physical_memory_size_type swap_usage = value_unlimited;\n+        if (mem_usage > mem_swap_usage) {\n+          swap_usage = 0; \/\/ delta usage must not be negative\n+        } else {\n+          swap_usage = mem_swap_usage - mem_usage;\n+        }\n+        \/\/ free swap is based on swap limit (upper bound) and swap usage\n+        if (swap_usage >= swap_limit) {\n+          value = 0; \/\/ free swap must not be negative\n@@ -335,0 +345,2 @@\n+        value = swap_limit - swap_usage;\n+        return true;\n@@ -338,3 +350,22 @@\n-    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" PHYS_MEM_TYPE_FORMAT,\n-                            mem_swap_limit, mem_limit, host_free_swap_val);\n+    if (log_is_enabled(Trace, os, container)) {\n+      char mem_swap_buf[25]; \/\/ uint64_t => 20 + 1, 'unlimited' => 9 + 1; 10 < 21 < 25\n+      char mem_limit_buf[25];\n+      int num = 0;\n+      if (mem_swap_limit == value_unlimited) {\n+        num = os::snprintf(mem_swap_buf, sizeof(mem_swap_buf), \"%s\", \"unlimited\");\n+      } else {\n+        num = os::snprintf(mem_swap_buf, sizeof(mem_swap_buf), PHYS_MEM_TYPE_FORMAT, mem_swap_limit);\n+      }\n+      assert(num < 25, \"buffer too small\");\n+      mem_swap_buf[num] = '\\0';\n+      if (mem_limit == value_unlimited) {\n+        num = os::snprintf(mem_limit_buf, sizeof(mem_limit_buf), \"%s\", \"unlimited\");\n+      } else {\n+        num = os::snprintf(mem_limit_buf, sizeof(mem_limit_buf), PHYS_MEM_TYPE_FORMAT, mem_limit);\n+      }\n+      assert(num < 25, \"buffer too small\");\n+      mem_limit_buf[num] = '\\0';\n+      log_trace(os,container)(\"os::free_swap_space: container_swap_limit=%s\"\n+                              \" container_mem_limit=%s returning host value: \" PHYS_MEM_TYPE_FORMAT,\n+                              mem_swap_buf, mem_limit_buf, host_free_swap_val);\n+    }\n@@ -348,4 +379,4 @@\n-    jlong mem_limit;\n-    if ((mem_limit = OSContainer::memory_limit_in_bytes()) > 0) {\n-      log_trace(os)(\"total container memory: \" JLONG_FORMAT, mem_limit);\n-      return static_cast<physical_memory_size_type>(mem_limit);\n+    physical_memory_size_type mem_limit = value_unlimited;\n+    if (OSContainer::memory_limit_in_bytes(mem_limit) && mem_limit != value_unlimited) {\n+      log_trace(os)(\"total container memory: \" PHYS_MEM_TYPE_FORMAT, mem_limit);\n+      return mem_limit;\n@@ -513,1 +544,1 @@\n-julong os::Linux::host_swap() {\n+bool os::Linux::host_swap(physical_memory_size_type& value) {\n@@ -515,2 +546,7 @@\n-  sysinfo(&si);\n-  return (julong)(si.totalswap * si.mem_unit);\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    assert(false, \"sysinfo failed in host_swap(): %s\", os::strerror(errno));\n+    return false;\n+  }\n+  value = static_cast<physical_memory_size_type>(si.totalswap) * si.mem_unit;\n+  return true;\n@@ -2492,1 +2528,2 @@\n-  int i = OSContainer::active_processor_count();\n+  int i = -1;\n+  bool supported = OSContainer::active_processor_count(i);\n@@ -2494,1 +2531,2 @@\n-  if (i > 0) {\n+  if (supported) {\n+    assert(i > 0, \"must be\");\n@@ -2504,1 +2542,2 @@\n-  i = OSContainer::cpu_quota();\n+\n+  supported = OSContainer::cpu_quota(i);\n@@ -2506,1 +2545,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2509,1 +2548,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no quota\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no quota\");\n@@ -2512,1 +2551,1 @@\n-  i = OSContainer::cpu_period();\n+  supported = OSContainer::cpu_period(i);\n@@ -2514,1 +2553,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2517,1 +2556,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no period\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no period\");\n@@ -2520,1 +2559,1 @@\n-  i = OSContainer::cpu_shares();\n+  supported = OSContainer::cpu_shares(i);\n@@ -2522,1 +2561,1 @@\n-  if (i > 0) {\n+  if (supported && i > 0) {\n@@ -2525,1 +2564,1 @@\n-    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no shares\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no shares\");\n@@ -2528,1 +2567,2 @@\n-  jlong j = OSContainer::cpu_usage_in_micros();\n+  uint64_t j = 0;\n+  supported = OSContainer::cpu_usage_in_micros(j);\n@@ -2530,2 +2570,2 @@\n-  if (j >= 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j > 0) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2533,11 +2573,51 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"no usage\");\n-  }\n-\n-  OSContainer::print_container_helper(st, OSContainer::memory_limit_in_bytes(), \"memory_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_and_swap_limit_in_bytes(), \"memory_and_swap_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_soft_limit_in_bytes(), \"memory_soft_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_throttle_limit_in_bytes(), \"memory_throttle_limit_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_usage_in_bytes(), \"memory_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::memory_max_usage_in_bytes(), \"memory_max_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\");\n-  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no usage\");\n+  }\n+\n+  MetricResult memory_limit;\n+  physical_memory_size_type val = value_unlimited;\n+  if (OSContainer::memory_limit_in_bytes(val)) {\n+    memory_limit.set_value(val);\n+  }\n+  MetricResult mem_swap_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_and_swap_limit_in_bytes(val)) {\n+    mem_swap_limit.set_value(val);\n+  }\n+  MetricResult mem_soft_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_soft_limit_in_bytes(val)) {\n+    mem_soft_limit.set_value(val);\n+  }\n+  MetricResult mem_throttle_limit;\n+  val = value_unlimited;\n+  if (OSContainer::memory_throttle_limit_in_bytes(val)) {\n+    mem_throttle_limit.set_value(val);\n+  }\n+  MetricResult mem_usage;\n+  val = 0;\n+  if (OSContainer::memory_usage_in_bytes(val)) {\n+    mem_usage.set_value(val);\n+  }\n+  MetricResult mem_max_usage;\n+  val = 0;\n+  if (OSContainer::memory_max_usage_in_bytes(val)) {\n+    mem_max_usage.set_value(val);\n+  }\n+  MetricResult rss_usage;\n+  val = 0;\n+  if (OSContainer::rss_usage_in_bytes(val)) {\n+    rss_usage.set_value(val);\n+  }\n+  MetricResult cache_usage;\n+  val = 0;\n+  if (OSContainer::cache_usage_in_bytes(val)) {\n+    cache_usage.set_value(val);\n+  }\n+  OSContainer::print_container_helper(st, memory_limit, \"memory_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_swap_limit, \"memory_and_swap_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_soft_limit, \"memory_soft_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_throttle_limit, \"memory_throttle_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_usage, \"memory_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, mem_max_usage, \"memory_max_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, rss_usage, \"rss_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, cache_usage, \"cache_usage_in_bytes\");\n@@ -2547,1 +2627,1 @@\n-  j = OSContainer::pids_max();\n+  supported = OSContainer::pids_max(j);\n@@ -2549,2 +2629,2 @@\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j > 0) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2552,1 +2632,1 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"unlimited\");\n@@ -2555,1 +2635,1 @@\n-  j = OSContainer::pids_current();\n+  supported = OSContainer::pids_current(j);\n@@ -2557,2 +2637,2 @@\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n+  if (supported && j > 0) {\n+    st->print_cr(UINT64_FORMAT, j);\n@@ -2560,3 +2640,1 @@\n-    if (j == OSCONTAINER_ERROR) {\n-      st->print_cr(\"not supported\");\n-    }\n+    st->print_cr(\"%s\", !supported ? \"not supported\" : \"no current tasks\");\n@@ -4765,1 +4843,1 @@\n-\/\/ 3. extracted from cgroup cpu subsystem (shares and quotas)\n+\/\/ 3. extracted from cgroup cpu subsystem (quotas)\n@@ -4782,3 +4860,2 @@\n-  int active_cpus;\n-  if (OSContainer::is_containerized()) {\n-    active_cpus = OSContainer::active_processor_count();\n+  int active_cpus = os::Linux::active_processor_count();\n+  if (OSContainer::is_containerized() && OSContainer::active_processor_count(active_cpus)) {\n@@ -4787,2 +4864,0 @@\n-  } else {\n-    active_cpus = os::Linux::active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":170,"deletions":95,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-  static julong available_memory_in_container();\n-\n@@ -120,1 +118,1 @@\n-  static julong host_swap();\n+  static bool host_swap(physical_memory_size_type& value);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -424,1 +424,3 @@\n-  return os::Linux::host_swap();\n+  physical_memory_size_type host_swap = 0;\n+  (void)os::Linux::host_swap(host_swap); \/\/ Discard return value and treat as no swap\n+  return static_cast<jlong>(host_swap);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2572,1 +2572,7 @@\n-  LINUX_ONLY(return (jlong)os::Linux::host_swap();)\n+#ifdef LINUX\n+  physical_memory_size_type swap_val = 0;\n+  if (!os::Linux::host_swap(swap_val)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<jlong>(swap_val);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2210,5 +2210,2 @@\n-    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-    if (mem_usage > 0) {\n-      value = static_cast<physical_memory_size_type>(mem_usage);\n-      return true;\n-    } else {\n+    physical_memory_size_type mem_usage = 0;\n+    if (!OSContainer::memory_usage_in_bytes(mem_usage)) {\n@@ -2217,0 +2214,2 @@\n+    value = mem_usage;\n+    return true;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t x = bad;\n@@ -111,1 +111,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -117,1 +117,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -123,1 +123,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -129,1 +129,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -135,1 +135,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -153,2 +153,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong x = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t x = bad;\n@@ -157,1 +157,1 @@\n-  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -159,1 +159,1 @@\n-  EXPECT_EQ((julong)100, x);\n+  EXPECT_EQ((uint64_t)100, x);\n@@ -163,1 +163,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -165,1 +165,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((uint64_t)111, x);\n@@ -169,1 +169,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -171,1 +171,1 @@\n-  EXPECT_EQ((julong)111, x);\n+  EXPECT_EQ((uint64_t)111, x);\n@@ -175,1 +175,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -177,1 +177,1 @@\n-  EXPECT_EQ((julong)133, x);\n+  EXPECT_EQ((uint64_t)133, x);\n@@ -181,1 +181,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -183,1 +183,1 @@\n-  EXPECT_EQ((julong)333, x);\n+  EXPECT_EQ((uint64_t)333, x);\n@@ -187,1 +187,1 @@\n-  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", x);\n@@ -189,1 +189,1 @@\n-  EXPECT_EQ((julong)1, x);\n+  EXPECT_EQ((uint64_t)1, x);\n@@ -198,2 +198,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t a = bad;\n@@ -201,1 +201,1 @@\n-  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  bool is_ok = null_path_controller->read_number(test_file_path, a);\n@@ -224,3 +224,3 @@\n-  constexpr julong bad = 0xBAD;\n-  julong result = bad;\n-  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, result);\n@@ -235,2 +235,2 @@\n-  constexpr julong bad = 0xBAD;\n-  julong a = bad;\n+  constexpr uint64_t bad = 0xBAD;\n+  uint64_t a = bad;\n@@ -238,1 +238,1 @@\n-  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -246,1 +246,1 @@\n-  constexpr julong bad = 0xBAD;\n+  constexpr uint64_t bad = 0xBAD;\n@@ -255,2 +255,2 @@\n-  julong foo = bad;\n-  bool ok = controller->read_number(base_with_slash, &foo);\n+  uint64_t foo = bad;\n+  bool ok = controller->read_number(base_with_slash, foo);\n@@ -258,1 +258,1 @@\n-  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((uint64_t)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -261,1 +261,2 @@\n-  \/\/ them and manually cast them as needed.\n+  \/\/ them and manually cast them as needed. For example, on cgv1, the cpu.cfs_quota_us\n+  \/\/ file might be set to -1 to indicate no cpu quota setup.\n@@ -264,1 +265,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -266,1 +267,1 @@\n-  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+  EXPECT_EQ((int)-1, (int)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n@@ -270,1 +271,1 @@\n-  ok = controller->read_number(base_with_slash, &foo);\n+  ok = controller->read_number(base_with_slash, foo);\n@@ -276,1 +277,2 @@\n-  jlong result = -10;\n+  uint64_t result = 0;\n+  uint64_t unlimited = std::numeric_limits<uint64_t>::max();\n@@ -278,1 +280,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -280,1 +282,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+  EXPECT_EQ(unlimited, result) << \"'max' means unlimited (-1)\";\n@@ -282,1 +284,1 @@\n-  result = -10;\n+  result = 0;\n@@ -284,1 +286,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -286,1 +288,1 @@\n-  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+  EXPECT_EQ((uint64_t)11114, result) << \"Incorrect result\";\n@@ -288,1 +290,4 @@\n-  result = -10;\n+  result = 0;\n+  \/\/ This is a contrived test case not matching cgroup interface files\n+  \/\/ in the wild where numbers are positive. The value is deliberately\n+  \/\/ negative. Yet it should work\n@@ -290,1 +295,1 @@\n-  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  ok = controller->read_number_handle_max(base_with_slash, result);\n@@ -292,1 +297,1 @@\n-  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+  EXPECT_EQ((int)-51114, (int)result) << \"Incorrect result\";\n@@ -375,2 +380,2 @@\n-  jlong result = -10;\n-  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  uint64_t result = 0;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -378,1 +383,1 @@\n-  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+  EXPECT_EQ(value_unlimited, result) << \"max should be unlimited (-1)\";\n@@ -380,2 +385,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, result);\n@@ -383,1 +388,1 @@\n-  EXPECT_EQ((jlong)10000, result);\n+  EXPECT_EQ((uint64_t)10000, result);\n@@ -387,2 +392,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -390,1 +395,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((uint64_t)0, result) << \"result value should be unchanged\";\n@@ -393,2 +398,2 @@\n-  result = -10;\n-  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  result = 0;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, result);\n@@ -396,1 +401,1 @@\n-  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+  EXPECT_EQ((uint64_t)0, result) << \"result value should be unchanged\";\n@@ -410,2 +415,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  uint64_t a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, a);\n@@ -413,1 +418,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((uint64_t)0xBAD, a) << \"Expected untouched scan value\";\n@@ -420,2 +425,2 @@\n-  julong a = 0xBAD;\n-  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  uint64_t a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, a);\n@@ -423,1 +428,1 @@\n-  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  EXPECT_EQ((uint64_t)0xBAD, a) << \"Expected untouched scan value\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":70,"deletions":65,"binary":false,"changes":135,"status":"modified"}]}