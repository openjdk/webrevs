{"files":[{"patch":"@@ -25,0 +25,1 @@\n+import java.io.IOException;\n@@ -26,0 +27,1 @@\n+import java.net.URL;\n@@ -31,0 +33,1 @@\n+import java.util.Enumeration;\n@@ -92,1 +95,1 @@\n-                        return Init.class.getResourceAsStream(cfile);\n+                        return getResourceAsStream(cfile, Init.class);\n@@ -99,0 +102,5 @@\n+            try {\n+                is.close();\n+            } catch (IOException ex) {\n+                LOG.warn(ex.getMessage());\n+            }\n@@ -171,1 +179,1 @@\n-            Document doc = XMLUtils.read(is, false);\n+            Document doc = XMLUtils.read(is, true);\n@@ -211,1 +219,1 @@\n-                            Object exArgs[] = { uri, javaClass };\n+                            Object[] exArgs = { uri, javaClass };\n@@ -229,1 +237,1 @@\n-                            Object exArgs[] = { uri, javaClass };\n+                            Object[] exArgs = { uri, javaClass };\n@@ -265,1 +273,1 @@\n-                            Object exArgs[] = { uri, javaClass };\n+                            Object[] exArgs = { uri, javaClass };\n@@ -275,1 +283,1 @@\n-\n+                    List<String> classNames = new ArrayList<>(resolverElem.length);\n@@ -287,9 +295,1 @@\n-                        try {\n-                            ResourceResolver.register(javaClass);\n-                        } catch (Throwable e) {\n-                            LOG.warn(\n-                                 \"Cannot register:\" + javaClass\n-                                 + \" perhaps some needed jars are not installed\",\n-                                 e\n-                             );\n-                        }\n+                        classNames.add(javaClass);\n@@ -297,0 +297,1 @@\n+                    ResourceResolver.registerClassNames(classNames);\n@@ -338,0 +339,147 @@\n+    \/**\n+     * Load a given resource. <p><\/p> This method will try to load the resource\n+     * using the following methods (in order):\n+     * <ul>\n+     * <li>From Thread.currentThread().getContextClassLoader()\n+     * <li>From ClassLoaderUtil.class.getClassLoader()\n+     * <li>callingClass.getClassLoader()\n+     * <\/ul>\n+     *\n+     * @param resourceName The name of the resource to load\n+     * @param callingClass The Class object of the calling object\n+     *\/\n+    public static URL getResource(String resourceName, Class<?> callingClass) {\n+        URL url = Thread.currentThread().getContextClassLoader().getResource(resourceName);\n+        if (url == null && resourceName.charAt(0) == '\/') {\n+            \/\/certain classloaders need it without the leading \/\n+            url =\n+                    Thread.currentThread().getContextClassLoader().getResource(\n+                            resourceName.substring(1)\n+                    );\n+        }\n+\n+        ClassLoader cluClassloader = Init.class.getClassLoader();\n+        if (cluClassloader == null) {\n+            cluClassloader = ClassLoader.getSystemClassLoader();\n+        }\n+        if (url == null) {\n+            url = cluClassloader.getResource(resourceName);\n+        }\n+        if (url == null && resourceName.charAt(0) == '\/') {\n+            \/\/certain classloaders need it without the leading \/\n+            url = cluClassloader.getResource(resourceName.substring(1));\n+        }\n+\n+        if (url == null) {\n+            ClassLoader cl = callingClass.getClassLoader();\n+\n+            if (cl != null) {\n+                url = cl.getResource(resourceName);\n+            }\n+        }\n+\n+        if (url == null) {\n+            url = callingClass.getResource(resourceName);\n+        }\n+\n+        if (url == null && resourceName.charAt(0) != '\/') {\n+            return getResource('\/' + resourceName, callingClass);\n+        }\n+\n+        return url;\n+    }\n+\n+    \/**\n+     * Load a given resources. <p><\/p> This method will try to load the resources\n+     * using the following methods (in order):\n+     * <ul>\n+     * <li>From Thread.currentThread().getContextClassLoader()\n+     * <li>From ClassLoaderUtil.class.getClassLoader()\n+     * <li>callingClass.getClassLoader()\n+     * <\/ul>\n+     *\n+     * @param resourceName The name of the resource to load\n+     * @param callingClass The Class object of the calling object\n+     *\/\n+    private static List<URL> getResources(String resourceName, Class<?> callingClass) {\n+        List<URL> ret = new ArrayList<>();\n+        Enumeration<URL> urls = new Enumeration<URL>() {\n+            public boolean hasMoreElements() {\n+                return false;\n+            }\n+            public URL nextElement() {\n+                return null;\n+            }\n+\n+        };\n+        try {\n+            urls = Thread.currentThread().getContextClassLoader().getResources(resourceName);\n+        } catch (IOException e) {\n+            LOG.debug(e.getMessage(), e);\n+            \/\/ignore\n+        }\n+        if (!urls.hasMoreElements() && resourceName.charAt(0) == '\/') {\n+            \/\/certain classloaders need it without the leading \/\n+            try {\n+                urls =\n+                        Thread.currentThread().getContextClassLoader().getResources(\n+                                resourceName.substring(1)\n+                        );\n+            } catch (IOException e) {\n+                LOG.debug(e.getMessage(), e);\n+                \/\/ ignore\n+            }\n+        }\n+\n+        ClassLoader cluClassloader = Init.class.getClassLoader();\n+        if (cluClassloader == null) {\n+            cluClassloader = ClassLoader.getSystemClassLoader();\n+        }\n+        if (!urls.hasMoreElements()) {\n+            try {\n+                urls = cluClassloader.getResources(resourceName);\n+            } catch (IOException e) {\n+                LOG.debug(e.getMessage(), e);\n+                \/\/ ignore\n+            }\n+        }\n+        if (!urls.hasMoreElements() && resourceName.charAt(0) == '\/') {\n+            \/\/certain classloaders need it without the leading \/\n+            try {\n+                urls = cluClassloader.getResources(resourceName.substring(1));\n+            } catch (IOException e) {\n+                LOG.debug(e.getMessage(), e);\n+                \/\/ ignore\n+            }\n+        }\n+\n+        if (!urls.hasMoreElements()) {\n+            ClassLoader cl = callingClass.getClassLoader();\n+\n+            if (cl != null) {\n+                try {\n+                    urls = cl.getResources(resourceName);\n+                } catch (IOException e) {\n+                    LOG.debug(e.getMessage(), e);\n+                    \/\/ ignore\n+                }\n+            }\n+        }\n+\n+        if (!urls.hasMoreElements()) {\n+            URL url = callingClass.getResource(resourceName);\n+            if (url != null) {\n+                ret.add(url);\n+            }\n+        }\n+        while (urls.hasMoreElements()) {\n+            ret.add(urls.nextElement());\n+        }\n+\n+\n+        if (ret.isEmpty() && resourceName != null && resourceName.charAt(0) != '\/') {\n+            return getResources('\/' + resourceName, callingClass);\n+        }\n+        return ret;\n+    }\n+\n@@ -339,0 +487,17 @@\n+    \/**\n+     * This is a convenience method to load a resource as a stream. <p><\/p> The\n+     * algorithm used to find the resource is given in getResource()\n+     *\n+     * @param resourceName The name of the resource to load\n+     * @param callingClass The Class object of the calling object\n+     *\/\n+    private static InputStream getResourceAsStream(String resourceName, Class<?> callingClass) {\n+        URL url = getResource(resourceName, callingClass);\n+\n+        try {\n+            return (url != null) ? url.openStream() : null;\n+        } catch (IOException e) {\n+            LOG.debug(e.getMessage(), e);\n+            return null;\n+        }\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/Init.java","additions":180,"deletions":15,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-    private static Map<String, Algorithm> algorithmsMap =\n-        new ConcurrentHashMap<String, Algorithm>();\n+    private static Map<String, Algorithm> algorithmsMap = new ConcurrentHashMap<>();\n@@ -185,0 +184,4 @@\n+        algorithmsMap.put(\n+             XMLSignature.ALGO_ID_SIGNATURE_RSA_PSS,\n+             new Algorithm(\"RSA\", \"RSASSA-PSS\", \"Signature\")\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/JCEMapper.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -40,1 +41,1 @@\n-public class MessageDigestAlgorithm extends Algorithm {\n+public final class MessageDigestAlgorithm extends Algorithm {\n@@ -121,5 +122,1 @@\n-        } catch (java.security.NoSuchAlgorithmException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n-\n-            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n-        } catch (NoSuchProviderException ex) {\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n@@ -172,1 +169,1 @@\n-    public byte[] digest(byte input[]) {\n+    public byte[] digest(byte[] input) {\n@@ -186,1 +183,1 @@\n-    public int digest(byte buf[], int offset, int len) throws java.security.DigestException {\n+    public int digest(byte[] buf, int offset, int len) throws java.security.DigestException {\n@@ -257,1 +254,1 @@\n-    public void update(byte buf[], int offset, int len) {\n+    public void update(byte[] buf, int offset, int len) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/MessageDigestAlgorithm.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -26,0 +28,1 @@\n+import java.security.Provider;\n@@ -57,1 +60,1 @@\n-        new ConcurrentHashMap<String, Class<? extends SignatureAlgorithmSpi>>();\n+        new ConcurrentHashMap<>();\n@@ -60,1 +63,1 @@\n-    private final SignatureAlgorithmSpi signatureAlgorithm;\n+    private final SignatureAlgorithmSpi signatureAlgorithmSpi;\n@@ -72,0 +75,8 @@\n+        this(doc, algorithmURI, null);\n+    }\n+\n+    public SignatureAlgorithm(Document doc, String algorithmURI, Provider provider) throws XMLSecurityException {\n+        this(doc, algorithmURI, provider, null);\n+    }\n+\n+    public SignatureAlgorithm(Document doc, String algorithmURI, Provider provider, AlgorithmParameterSpec parameterSpec) throws XMLSecurityException {\n@@ -75,2 +86,5 @@\n-        signatureAlgorithm = getSignatureAlgorithmSpi(algorithmURI);\n-        signatureAlgorithm.engineGetContextFromElement(getElement());\n+        signatureAlgorithmSpi = getSignatureAlgorithmSpi(algorithmURI, provider);\n+        if (parameterSpec != null) {\n+            signatureAlgorithmSpi.engineSetParameter(parameterSpec);\n+            signatureAlgorithmSpi.engineAddContextToElement(getElement());\n+        }\n@@ -89,0 +103,6 @@\n+    ) throws XMLSecurityException {\n+        this(doc, algorithmURI, hmacOutputLength, null);\n+    }\n+\n+    public SignatureAlgorithm(\n+        Document doc, String algorithmURI, int hmacOutputLength, Provider provider\n@@ -93,2 +113,1 @@\n-        signatureAlgorithm = getSignatureAlgorithmSpi(algorithmURI);\n-        signatureAlgorithm.engineGetContextFromElement(getElement());\n+        signatureAlgorithmSpi = getSignatureAlgorithmSpi(algorithmURI, provider);\n@@ -96,2 +115,2 @@\n-        signatureAlgorithm.engineSetHMACOutputLength(hmacOutputLength);\n-        ((IntegrityHmac)signatureAlgorithm).engineAddContextToElement(getElement());\n+        signatureAlgorithmSpi.engineSetHMACOutputLength(hmacOutputLength);\n+        signatureAlgorithmSpi.engineAddContextToElement(getElement());\n@@ -108,1 +127,5 @@\n-        this(element, baseURI, true);\n+        this(element, baseURI, true, null);\n+    }\n+\n+    public SignatureAlgorithm(Element element, String baseURI, Provider provider) throws XMLSecurityException {\n+        this(element, baseURI, true, provider);\n@@ -121,0 +144,6 @@\n+    ) throws XMLSecurityException {\n+        this(element, baseURI, secureValidation, null);\n+    }\n+\n+    public SignatureAlgorithm(\n+        Element element, String baseURI, boolean secureValidation, Provider provider\n@@ -132,1 +161,1 @@\n-            Object exArgs[] = { algorithmURI };\n+            Object[] exArgs = { algorithmURI };\n@@ -137,2 +166,2 @@\n-        signatureAlgorithm = getSignatureAlgorithmSpi(algorithmURI);\n-        signatureAlgorithm.engineGetContextFromElement(getElement());\n+        signatureAlgorithmSpi = getSignatureAlgorithmSpi(algorithmURI, provider);\n+        signatureAlgorithmSpi.engineGetContextFromElement(getElement());\n@@ -144,1 +173,1 @@\n-    private static SignatureAlgorithmSpi getSignatureAlgorithmSpi(String algorithmURI)\n+    private static SignatureAlgorithmSpi getSignatureAlgorithmSpi(String algorithmURI, Provider provider)\n@@ -147,2 +176,1 @@\n-            Class<? extends SignatureAlgorithmSpi> implementingClass =\n-                algorithmHash.get(algorithmURI);\n+            Class<? extends SignatureAlgorithmSpi> implementingClass = algorithmHash.get(algorithmURI);\n@@ -151,1 +179,1 @@\n-                Object exArgs[] = { algorithmURI };\n+                Object[] exArgs = { algorithmURI };\n@@ -154,5 +182,15 @@\n-            @SuppressWarnings(\"deprecation\")\n-            SignatureAlgorithmSpi tmp = implementingClass.newInstance();\n-            return tmp;\n-        }  catch (IllegalAccessException | InstantiationException | NullPointerException ex) {\n-            Object exArgs[] = { algorithmURI, ex.getMessage() };\n+\n+            if (provider != null) {\n+                try {\n+                    Constructor<? extends SignatureAlgorithmSpi> constructor = implementingClass.getConstructor(Provider.class);\n+                    return constructor.newInstance(provider);\n+\n+                } catch (NoSuchMethodException e) {\n+                    LOG.warn(\"Class \\\"{}\\\" does not have a constructor with Provider\", implementingClass);\n+                }\n+            }\n+\n+            return JavaUtils.newInstanceWithEmptyConstructor(implementingClass);\n+\n+        }  catch (IllegalAccessException | InstantiationException | InvocationTargetException | NullPointerException ex) {\n+            Object[] exArgs = { algorithmURI, ex.getMessage() };\n@@ -172,1 +210,1 @@\n-        return signatureAlgorithm.engineSign();\n+        return signatureAlgorithmSpi.engineSign();\n@@ -182,1 +220,1 @@\n-        return signatureAlgorithm.engineGetJCEAlgorithmString();\n+        return signatureAlgorithmSpi.engineGetJCEAlgorithmString();\n@@ -191,1 +229,1 @@\n-        return signatureAlgorithm.engineGetJCEProviderName();\n+        return signatureAlgorithmSpi.engineGetJCEProviderName();\n@@ -202,1 +240,1 @@\n-        signatureAlgorithm.engineUpdate(input);\n+        signatureAlgorithmSpi.engineUpdate(input);\n@@ -213,1 +251,1 @@\n-        signatureAlgorithm.engineUpdate(input);\n+        signatureAlgorithmSpi.engineUpdate(input);\n@@ -225,2 +263,2 @@\n-    public void update(byte buf[], int offset, int len) throws XMLSignatureException {\n-        signatureAlgorithm.engineUpdate(buf, offset, len);\n+    public void update(byte[] buf, int offset, int len) throws XMLSignatureException {\n+        signatureAlgorithmSpi.engineUpdate(buf, offset, len);\n@@ -237,1 +275,1 @@\n-        signatureAlgorithm.engineInitSign(signingKey);\n+        signatureAlgorithmSpi.engineInitSign(signingKey);\n@@ -250,1 +288,1 @@\n-        signatureAlgorithm.engineInitSign(signingKey, secureRandom);\n+        signatureAlgorithmSpi.engineInitSign(signingKey, secureRandom);\n@@ -264,1 +302,1 @@\n-        signatureAlgorithm.engineInitSign(signingKey, algorithmParameterSpec);\n+        signatureAlgorithmSpi.engineInitSign(signingKey, algorithmParameterSpec);\n@@ -276,1 +314,1 @@\n-        signatureAlgorithm.engineSetParameter(params);\n+        signatureAlgorithmSpi.engineSetParameter(params);\n@@ -287,1 +325,1 @@\n-        signatureAlgorithm.engineInitVerify(verificationKey);\n+        signatureAlgorithmSpi.engineInitVerify(verificationKey);\n@@ -300,1 +338,1 @@\n-        return signatureAlgorithm.engineVerify(signature);\n+        return signatureAlgorithmSpi.engineVerify(signature);\n@@ -333,1 +371,1 @@\n-            Object exArgs[] = { algorithmURI, registeredClass };\n+            Object[] exArgs = { algorithmURI, registeredClass };\n@@ -344,1 +382,1 @@\n-            Object exArgs[] = { algorithmURI, ex.getMessage() };\n+            Object[] exArgs = { algorithmURI, ex.getMessage() };\n@@ -369,1 +407,1 @@\n-            Object exArgs[] = { algorithmURI, registeredClass };\n+            Object[] exArgs = { algorithmURI, registeredClass };\n@@ -428,0 +466,3 @@\n+        algorithmHash.put(\n+            XMLSignature.ALGO_ID_SIGNATURE_RSA_PSS, SignatureBaseRSA.SignatureRSASSAPSS.class\n+        );\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/SignatureAlgorithm.java","additions":78,"deletions":37,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-import java.security.Key;\n-import java.security.SecureRandom;\n+import java.security.*;\n@@ -83,1 +82,1 @@\n-    protected abstract void engineUpdate(byte buf[], int offset, int len)\n+    protected abstract void engineUpdate(byte[] buf, int offset, int len)\n@@ -163,1 +162,4 @@\n-    protected void engineGetContextFromElement(Element element) {\n+    protected void engineGetContextFromElement(Element element) throws XMLSignatureException {\n+    }\n+\n+    protected void engineAddContextToElement(Element element) throws XMLSignatureException {\n@@ -175,1 +177,17 @@\n-    public void reset() {\n+    protected static void engineInitVerify(Key publicKey, Signature signatureAlgorithm) throws XMLSignatureException {\n+        if (!(publicKey instanceof PublicKey)) {\n+            String supplied = null;\n+            if (publicKey != null) {\n+                supplied = publicKey.getClass().getName();\n+            }\n+            String needed = PublicKey.class.getName();\n+            Object[] exArgs = { supplied, needed };\n+\n+            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n+        }\n+\n+        try {\n+            signatureAlgorithm.initVerify((PublicKey) publicKey);\n+        } catch (InvalidKeyException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n@@ -177,0 +195,25 @@\n+\n+    protected static void engineInitSign(Key privateKey, SecureRandom secureRandom, Signature signatureAlgorithm)\n+            throws XMLSignatureException {\n+        if (!(privateKey instanceof PrivateKey)) {\n+            String supplied = null;\n+            if (privateKey != null) {\n+                supplied = privateKey.getClass().getName();\n+            }\n+            String needed = PrivateKey.class.getName();\n+            Object[] exArgs = { supplied, needed };\n+\n+            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n+        }\n+\n+        try {\n+            if (secureRandom == null) {\n+                signatureAlgorithm.initSign((PrivateKey) privateKey);\n+            } else {\n+                signatureAlgorithm.initSign((PrivateKey) privateKey, secureRandom);\n+            }\n+        } catch (InvalidKeyException ex) {\n+            throw new XMLSignatureException(ex);\n+        }\n+    }\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/SignatureAlgorithmSpi.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -23,0 +23,3 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n@@ -53,1 +56,1 @@\n-    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[], int rawLen) throws IOException {\n+    public static byte[] convertASN1toXMLDSIG(byte[] asn1Bytes, int rawLen) throws IOException {\n@@ -90,1 +93,1 @@\n-        byte xmldsigBytes[] = new byte[2 * rawLen];\n+        byte[] xmldsigBytes = new byte[2 * rawLen];\n@@ -111,1 +114,1 @@\n-    public static byte[] convertXMLDSIGtoASN1(byte xmldsigBytes[]) throws IOException {\n+    public static byte[] convertXMLDSIGtoASN1(byte[] xmldsigBytes) throws IOException {\n@@ -140,1 +143,1 @@\n-        byte asn1Bytes[];\n+        byte[] asn1Bytes;\n@@ -887,3 +890,3 @@\n-        byte affineXBytes[] = stripLeadingZeros(ecPoint.getAffineX().toByteArray());\n-        byte affineYBytes[] = stripLeadingZeros(ecPoint.getAffineY().toByteArray());\n-        byte encodedBytes[] = new byte[size * 2 + 1];\n+        byte[] affineXBytes = stripLeadingZeros(ecPoint.getAffineX().toByteArray());\n+        byte[] affineYBytes = stripLeadingZeros(ecPoint.getAffineY().toByteArray());\n+        byte[] encodedBytes = new byte[size * 2 + 1];\n@@ -902,2 +905,2 @@\n-        byte affineXBytes[] = new byte[size];\n-        byte affineYBytes[] = new byte[size];\n+        byte[] affineXBytes = new byte[size];\n+        byte[] affineYBytes = new byte[size];\n@@ -920,1 +923,1 @@\n-            byte stripped[] = new byte[bytes.length - i];\n+            byte[] stripped = new byte[bytes.length - i];\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/ECDSAUtils.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.Provider;\n@@ -52,1 +53,1 @@\n-    private Mac macAlgorithm;\n+    private final Mac macAlgorithm;\n@@ -54,10 +55,2 @@\n-    \/** Field HMACOutputLength *\/\n-    private int HMACOutputLength;\n-    private boolean HMACOutputLengthSet = false;\n-\n-    \/**\n-     * Method engineGetURI\n-     *\n-     *{@inheritDoc}\n-     *\/\n-    public abstract String engineGetURI();\n+    \/** Field hmacOutputLength *\/\n+    private HMACOutputLength hmacOutputLength;\n@@ -76,0 +69,4 @@\n+        this(null);\n+    }\n+\n+    public IntegrityHmac(Provider provider) throws XMLSignatureException {\n@@ -80,1 +77,1 @@\n-            this.macAlgorithm = Mac.getInstance(algorithmID);\n+            this.macAlgorithm = (provider == null) ? Mac.getInstance(algorithmID) : Mac.getInstance(algorithmID, provider);\n@@ -100,6 +97,0 @@\n-    public void reset() {\n-        HMACOutputLength = 0;\n-        HMACOutputLengthSet = false;\n-        this.macAlgorithm.reset();\n-    }\n-\n@@ -116,1 +107,1 @@\n-            if (this.HMACOutputLengthSet && this.HMACOutputLength < getDigestLength()) {\n+            if (hmacOutputLength != null && hmacOutputLength.length < getDigestLength()) {\n@@ -143,1 +134,1 @@\n-            Object exArgs[] = { supplied, needed };\n+            Object[] exArgs = { supplied, needed };\n@@ -151,10 +142,0 @@\n-            \/\/ reinstantiate Mac object to work around bug in JDK\n-            \/\/ see: http:\/\/bugs.java.com\/view_bug.do?bug_id=4953555\n-            Mac mac = this.macAlgorithm;\n-            try {\n-                this.macAlgorithm = Mac.getInstance(macAlgorithm.getAlgorithm());\n-            } catch (Exception e) {\n-                \/\/ this shouldn't occur, but if it does, restore previous Mac\n-                LOG.debug(\"Exception when reinstantiating Mac: {}\", e);\n-                this.macAlgorithm = mac;\n-            }\n@@ -174,1 +155,1 @@\n-            if (this.HMACOutputLengthSet && this.HMACOutputLength < getDigestLength()) {\n+            if (hmacOutputLength != null && hmacOutputLength.length < getDigestLength()) {\n@@ -212,1 +193,1 @@\n-            Object exArgs[] = { supplied, needed };\n+            Object[] exArgs = { supplied, needed };\n@@ -223,3 +204,1 @@\n-        } catch (InvalidKeyException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (InvalidAlgorithmParameterException ex) {\n+        } catch (InvalidKeyException | InvalidAlgorithmParameterException ex) {\n@@ -281,1 +260,1 @@\n-    protected void engineUpdate(byte buf[], int offset, int len) throws XMLSignatureException {\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n@@ -310,1 +289,2 @@\n-     * @param HMACOutputLength\n+     * @param length\n+     * @throws XMLSignatureException\n@@ -312,3 +292,3 @@\n-    protected void engineSetHMACOutputLength(int HMACOutputLength) {\n-        this.HMACOutputLength = HMACOutputLength;\n-        this.HMACOutputLengthSet = true;\n+    @Override\n+    protected void engineSetHMACOutputLength(int length) throws XMLSignatureException {\n+        hmacOutputLength = new HMACOutputLength(length);\n@@ -321,0 +301,1 @@\n+     * @throws XMLSignatureException\n@@ -322,3 +303,2 @@\n-    protected void engineGetContextFromElement(Element element) {\n-        super.engineGetContextFromElement(element);\n-\n+    @Override\n+    protected void engineGetContextFromElement(Element element) throws XMLSignatureException {\n@@ -333,2 +313,1 @@\n-                this.HMACOutputLength = Integer.parseInt(hmacLength);\n-                this.HMACOutputLengthSet = true;\n+                this.hmacOutputLength = new HMACOutputLength(Integer.parseInt(hmacLength));\n@@ -344,1 +323,2 @@\n-    public void engineAddContextToElement(Element element) {\n+    @Override\n+    protected void engineAddContextToElement(Element element) throws XMLSignatureException {\n@@ -349,1 +329,1 @@\n-        if (this.HMACOutputLengthSet) {\n+        if (hmacOutputLength != null) {\n@@ -354,1 +334,1 @@\n-                doc.createTextNode(\"\" + this.HMACOutputLength);\n+                doc.createTextNode(\"\" + hmacOutputLength.length);\n@@ -377,0 +357,4 @@\n+        public IntegrityHmacSHA1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -382,0 +366,1 @@\n+        @Override\n@@ -386,0 +371,1 @@\n+        @Override\n@@ -405,0 +391,4 @@\n+        public IntegrityHmacSHA224(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -410,0 +400,1 @@\n+        @Override\n@@ -414,0 +405,1 @@\n+        @Override\n@@ -433,0 +425,4 @@\n+        public IntegrityHmacSHA256(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -438,0 +434,1 @@\n+        @Override\n@@ -442,0 +439,1 @@\n+        @Override\n@@ -461,0 +459,4 @@\n+        public IntegrityHmacSHA384(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -466,0 +468,1 @@\n+        @Override\n@@ -470,0 +473,1 @@\n+        @Override\n@@ -489,0 +493,4 @@\n+        public IntegrityHmacSHA512(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -494,0 +502,1 @@\n+        @Override\n@@ -498,0 +507,1 @@\n+        @Override\n@@ -517,0 +527,4 @@\n+        public IntegrityHmacRIPEMD160(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -522,0 +536,1 @@\n+        @Override\n@@ -526,0 +541,1 @@\n+        @Override\n@@ -545,0 +561,4 @@\n+        public IntegrityHmacMD5(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -550,0 +570,1 @@\n+        @Override\n@@ -554,0 +575,1 @@\n+        @Override\n@@ -558,0 +580,22 @@\n+\n+    private static class HMACOutputLength {\n+        private static final int MIN_LENGTH = 128;\n+        private static final int MAX_LENGTH = 2048;\n+        private final int length;\n+\n+        public HMACOutputLength(int length) throws XMLSignatureException {\n+            this.length = length;\n+\n+            \/\/ Test some invariants\n+            if (length < MIN_LENGTH) {\n+                LOG.debug(\"HMACOutputLength must not be less than {}\", MIN_LENGTH);\n+                Object[] exArgs = { String.valueOf(MIN_LENGTH) };\n+                throw new XMLSignatureException(\"algorithms.HMACOutputLengthMin\", exArgs);\n+            }\n+            if (length > MAX_LENGTH) {\n+                LOG.debug(\"HMACOutputLength must not be more than {}\", MAX_LENGTH);\n+                Object[] exArgs = { String.valueOf(MAX_LENGTH) };\n+                throw new XMLSignatureException(\"algorithms.HMACOutputLengthMax\", exArgs);\n+            }\n+        }\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/IntegrityHmac.java","additions":92,"deletions":48,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.security.InvalidKeyException;\n@@ -28,0 +27,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -29,2 +29,1 @@\n-import java.security.PrivateKey;\n-import java.security.PublicKey;\n+import java.security.Provider;\n@@ -40,0 +39,8 @@\n+import com.sun.org.apache.xml.internal.security.utils.Constants;\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Text;\n+\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n@@ -46,3 +53,0 @@\n-    \/** {@inheritDoc} *\/\n-    public abstract String engineGetURI();\n-\n@@ -50,1 +54,1 @@\n-    private Signature signatureAlgorithm;\n+    private final Signature signatureAlgorithm;\n@@ -58,1 +62,2 @@\n-        String algorithmID = JCEMapper.translateURItoJCEID(this.engineGetURI());\n+        this(null);\n+    }\n@@ -60,0 +65,2 @@\n+    public SignatureBaseRSA(Provider provider) throws XMLSignatureException {\n+        String algorithmID = JCEMapper.translateURItoJCEID(this.engineGetURI());\n@@ -61,1 +68,1 @@\n-        String provider = JCEMapper.getProviderId();\n+\n@@ -64,1 +71,8 @@\n-                this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+                String providerId = JCEMapper.getProviderId();\n+                if (providerId == null) {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+\n+                } else {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID, providerId);\n+                }\n+\n@@ -68,6 +82,0 @@\n-        } catch (java.security.NoSuchAlgorithmException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n-\n-            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n-        } catch (NoSuchProviderException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n@@ -75,0 +83,2 @@\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n+            Object[] exArgs = {algorithmID, ex.getLocalizedMessage()};\n@@ -100,27 +110,1 @@\n-        if (!(publicKey instanceof PublicKey)) {\n-            String supplied = null;\n-            if (publicKey != null) {\n-                supplied = publicKey.getClass().getName();\n-            }\n-            String needed = PublicKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            this.signatureAlgorithm.initVerify((PublicKey) publicKey);\n-        } catch (InvalidKeyException ex) {\n-            \/\/ reinstantiate Signature object to work around bug in JDK\n-            \/\/ see: http:\/\/bugs.java.com\/view_bug.do?bug_id=4953555\n-            Signature sig = this.signatureAlgorithm;\n-            try {\n-                this.signatureAlgorithm = Signature.getInstance(signatureAlgorithm.getAlgorithm());\n-            } catch (Exception e) {\n-                \/\/ this shouldn't occur, but if it does, restore previous\n-                \/\/ Signature\n-                LOG.debug(\"Exception when reinstantiating Signature: {}\", e);\n-                this.signatureAlgorithm = sig;\n-            }\n-            throw new XMLSignatureException(ex);\n-        }\n+        engineInitVerify(publicKey, this.signatureAlgorithm);\n@@ -141,20 +125,1 @@\n-        if (!(privateKey instanceof PrivateKey)) {\n-            String supplied = null;\n-            if (privateKey != null) {\n-                supplied = privateKey.getClass().getName();\n-            }\n-            String needed = PrivateKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            if (secureRandom == null) {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey);\n-            } else {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey, secureRandom);\n-            }\n-        } catch (InvalidKeyException ex) {\n-            throw new XMLSignatureException(ex);\n-        }\n+        engineInitSign(privateKey, secureRandom, this.signatureAlgorithm);\n@@ -187,1 +152,1 @@\n-    protected void engineUpdate(byte buf[], int offset, int len) throws XMLSignatureException {\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n@@ -232,0 +197,4 @@\n+        public SignatureRSASHA1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -233,0 +202,1 @@\n+        @Override\n@@ -252,0 +222,4 @@\n+        public SignatureRSASHA224(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -253,0 +227,1 @@\n+        @Override\n@@ -272,0 +247,4 @@\n+        public SignatureRSASHA256(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -273,0 +252,1 @@\n+        @Override\n@@ -292,0 +272,4 @@\n+        public SignatureRSASHA384(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -293,0 +277,1 @@\n+        @Override\n@@ -312,0 +297,4 @@\n+        public SignatureRSASHA512(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -313,0 +302,1 @@\n+        @Override\n@@ -332,0 +322,4 @@\n+        public SignatureRSARIPEMD160(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -333,0 +327,1 @@\n+        @Override\n@@ -352,0 +347,4 @@\n+        public SignatureRSAMD5(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -353,0 +352,1 @@\n+        @Override\n@@ -372,0 +372,4 @@\n+        public SignatureRSASHA1MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -373,0 +377,1 @@\n+        @Override\n@@ -392,0 +397,4 @@\n+        public SignatureRSASHA224MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -393,0 +402,1 @@\n+        @Override\n@@ -412,0 +422,4 @@\n+        public SignatureRSASHA256MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -413,0 +427,1 @@\n+        @Override\n@@ -432,0 +447,4 @@\n+        public SignatureRSASHA384MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -433,0 +452,1 @@\n+        @Override\n@@ -452,0 +472,4 @@\n+        public SignatureRSASHA512MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -453,0 +477,1 @@\n+        @Override\n@@ -472,0 +497,4 @@\n+        public SignatureRSASHA3_224MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -473,0 +502,1 @@\n+        @Override\n@@ -492,0 +522,4 @@\n+        public SignatureRSASHA3_256MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -493,0 +527,1 @@\n+        @Override\n@@ -512,0 +547,4 @@\n+        public SignatureRSASHA3_384MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -513,0 +552,1 @@\n+        @Override\n@@ -532,0 +572,4 @@\n+        public SignatureRSASHA3_512MGF1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -533,0 +577,1 @@\n+        @Override\n@@ -537,0 +582,141 @@\n+\n+    public static class SignatureRSASSAPSS extends SignatureBaseRSA {\n+        PSSParameterSpec pssParameterSpec;\n+\n+        public enum DigestAlgorithm {\n+            SHA256(\"SHA-256\", \"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha256\", 32),\n+            SHA384(\"SHA-384\", \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#sha384\", 48),\n+            SHA512(\"SHA-512\", \"http:\/\/www.w3.org\/2001\/04\/xmlenc#sha512\", 64);\n+\n+            private final String xmlDigestAlgorithm;\n+            private final String digestAlgorithm;\n+            private final int saltLength;\n+\n+            DigestAlgorithm(String digestAlgorithm, String xmlDigestAlgorithm, int saltLength) {\n+                this.digestAlgorithm = digestAlgorithm;\n+                this.xmlDigestAlgorithm = xmlDigestAlgorithm;\n+                this.saltLength = saltLength;\n+            }\n+\n+            public String getXmlDigestAlgorithm() {\n+                return xmlDigestAlgorithm;\n+            }\n+\n+            public String getDigestAlgorithm() {\n+                return digestAlgorithm;\n+            }\n+\n+            public int getSaltLength() {\n+                return saltLength;\n+            }\n+\n+            public static DigestAlgorithm fromXmlDigestAlgorithm(String xmlDigestAlgorithm) throws XMLSignatureException {\n+                for (DigestAlgorithm value : DigestAlgorithm.values()) {\n+                    if(value.getXmlDigestAlgorithm().equals(xmlDigestAlgorithm)) {\n+                        return value;\n+                    }\n+                }\n+                throw new XMLSignatureException();\n+            }\n+\n+            public static DigestAlgorithm fromDigestAlgorithm(String digestAlgorithm) throws XMLSignatureException {\n+                for (DigestAlgorithm value : DigestAlgorithm.values()) {\n+                    if(value.getDigestAlgorithm().equals(digestAlgorithm)) {\n+                        return value;\n+                    }\n+                }\n+                throw new XMLSignatureException();\n+\n+            }\n+\n+        }\n+\n+        public SignatureRSASSAPSS() throws XMLSignatureException {\n+            super();\n+        }\n+\n+        public SignatureRSASSAPSS(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        @Override\n+        public String engineGetURI() {\n+            return XMLSignature.ALGO_ID_SIGNATURE_RSA_PSS;\n+        }\n+\n+        @Override\n+        protected void engineAddContextToElement(Element element) throws XMLSignatureException {\n+            if (element == null) {\n+                throw new IllegalArgumentException(\"null element\");\n+            }\n+\n+            Document doc = element.getOwnerDocument();\n+            Element rsaPssParamsElement = doc.createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_RSAPSSPARAMS);\n+            rsaPssParamsElement.setAttributeNS(Constants.NamespaceSpecNS, \"xmlns:\" + \"pss\", Constants.XML_DSIG_NS_MORE_07_05);\n+\n+            Element digestMethodElement = XMLUtils.createElementInSignatureSpace(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD);\n+            digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, DigestAlgorithm.fromDigestAlgorithm(pssParameterSpec.getDigestAlgorithm()).getXmlDigestAlgorithm());\n+            XMLUtils.addReturnToElement(rsaPssParamsElement);\n+            rsaPssParamsElement.appendChild(digestMethodElement);\n+            XMLUtils.addReturnToElement(rsaPssParamsElement);\n+\n+            Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n+            Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(pssParameterSpec.getSaltLength()));\n+            saltLengthElement.appendChild(saltLengthText);\n+\n+            rsaPssParamsElement.appendChild(saltLengthElement);\n+            XMLUtils.addReturnToElement(rsaPssParamsElement);\n+\n+            Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n+            Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(pssParameterSpec.getTrailerField()));\n+            trailerFieldElement.appendChild(trailerFieldText);\n+\n+            rsaPssParamsElement.appendChild(trailerFieldElement);\n+            XMLUtils.addReturnToElement(rsaPssParamsElement);\n+\n+            XMLUtils.addReturnToElement(element);\n+            element.appendChild(rsaPssParamsElement);\n+            XMLUtils.addReturnToElement(element);\n+        }\n+\n+        @Override\n+        protected void engineGetContextFromElement(Element element) throws XMLSignatureException {\n+            if (pssParameterSpec == null) {\n+                super.engineGetContextFromElement(element);\n+                Element rsaPssParams = XMLUtils.selectNode(element.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_RSAPSSPARAMS, 0);\n+                if (rsaPssParams == null) {\n+                    throw new XMLSignatureException(\"algorithms.MissingRSAPSSParams\");\n+                }\n+\n+                Element saltLengthNode = XMLUtils.selectNode(rsaPssParams.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_SALTLENGTH, 0);\n+                Element trailerFieldNode = XMLUtils.selectNode(rsaPssParams.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_TRAILERFIELD, 0);\n+                int trailerField = 1;\n+                if (trailerFieldNode != null) {\n+                    try {\n+                        trailerField = Integer.parseInt(trailerFieldNode.getTextContent());\n+                    } catch (NumberFormatException ex) {\n+                        throw new XMLSignatureException(\"empty\", new Object[] {\"Invalid trailer field value supplied\"});\n+                    }\n+                }\n+                String xmlAlgorithm = XMLUtils.selectDsNode(rsaPssParams.getFirstChild(), Constants._TAG_DIGESTMETHOD, 0).getAttribute(Constants._ATT_ALGORITHM);\n+                DigestAlgorithm digestAlgorithm = DigestAlgorithm.fromXmlDigestAlgorithm(xmlAlgorithm);\n+                String digestAlgorithmName = digestAlgorithm.getDigestAlgorithm();\n+                int saltLength = digestAlgorithm.getSaltLength();\n+                if (saltLengthNode != null) {\n+                    try {\n+                        saltLength = Integer.parseInt(saltLengthNode.getTextContent());\n+                    } catch (NumberFormatException ex) {\n+                        throw new XMLSignatureException(\"empty\", new Object[] {\"Invalid salt length value supplied\"});\n+                    }\n+                }\n+                engineSetParameter(new PSSParameterSpec(digestAlgorithmName, \"MGF1\", new MGF1ParameterSpec(digestAlgorithmName), saltLength, trailerField));\n+            }\n+        }\n+\n+        @Override\n+        protected void engineSetParameter(AlgorithmParameterSpec params) throws XMLSignatureException {\n+            pssParameterSpec = (PSSParameterSpec) params;\n+            super.engineSetParameter(params);\n+        }\n+\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureBaseRSA.java","additions":250,"deletions":64,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.security.InvalidKeyException;\n@@ -29,2 +28,3 @@\n-import java.security.PrivateKey;\n-import java.security.PublicKey;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n@@ -53,1 +53,1 @@\n-    private Signature signatureAlgorithm;\n+    private final Signature signatureAlgorithm;\n@@ -73,0 +73,4 @@\n+        this(null);\n+    }\n+\n+    public SignatureDSA(Provider provider) throws XMLSignatureException {\n@@ -76,1 +80,0 @@\n-        String provider = JCEMapper.getProviderId();\n@@ -79,1 +82,8 @@\n-                this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+                String providerId = JCEMapper.getProviderId();\n+                if (providerId == null) {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+\n+                } else {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID, providerId);\n+                }\n+\n@@ -81,2 +91,1 @@\n-                this.signatureAlgorithm =\n-                    Signature.getInstance(algorithmID, provider);\n+                this.signatureAlgorithm = Signature.getInstance(algorithmID, provider);\n@@ -84,5 +93,3 @@\n-        } catch (java.security.NoSuchAlgorithmException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n-            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n-        } catch (java.security.NoSuchProviderException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n+\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n+            Object[] exArgs = {algorithmID, ex.getLocalizedMessage()};\n@@ -115,2 +122,1 @@\n-            byte[] jcebytes = JavaUtils.convertDsaXMLDSIGtoASN1(signature,\n-                                                                size\/8);\n+            byte[] jcebytes = JavaUtils.convertDsaXMLDSIGtoASN1(signature, size \/ 8);\n@@ -119,3 +125,1 @@\n-        } catch (SignatureException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (IOException ex) {\n+        } catch (SignatureException | IOException ex) {\n@@ -130,27 +134,1 @@\n-        if (!(publicKey instanceof PublicKey)) {\n-            String supplied = null;\n-            if (publicKey != null) {\n-                supplied = publicKey.getClass().getName();\n-            }\n-            String needed = PublicKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            this.signatureAlgorithm.initVerify((PublicKey) publicKey);\n-        } catch (InvalidKeyException ex) {\n-            \/\/ reinstantiate Signature object to work around bug in JDK\n-            \/\/ see: http:\/\/bugs.java.com\/view_bug.do?bug_id=4953555\n-            Signature sig = this.signatureAlgorithm;\n-            try {\n-                this.signatureAlgorithm = Signature.getInstance(signatureAlgorithm.getAlgorithm());\n-            } catch (Exception e) {\n-                \/\/ this shouldn't occur, but if it does, restore previous\n-                \/\/ Signature\n-                LOG.debug(\"Exception when reinstantiating Signature: {}\", e);\n-                this.signatureAlgorithm = sig;\n-            }\n-            throw new XMLSignatureException(ex);\n-        }\n+        engineInitVerify(publicKey, this.signatureAlgorithm);\n@@ -165,1 +143,1 @@\n-            byte jcebytes[] = this.signatureAlgorithm.sign();\n+            byte[] jcebytes = this.signatureAlgorithm.sign();\n@@ -167,4 +145,2 @@\n-            return JavaUtils.convertDsaASN1toXMLDSIG(jcebytes, size\/8);\n-        } catch (IOException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (SignatureException ex) {\n+            return JavaUtils.convertDsaASN1toXMLDSIG(jcebytes, size \/ 8);\n+        } catch (IOException | SignatureException ex) {\n@@ -180,20 +156,1 @@\n-        if (!(privateKey instanceof PrivateKey)) {\n-            String supplied = null;\n-            if (privateKey != null) {\n-                supplied = privateKey.getClass().getName();\n-            }\n-            String needed = PrivateKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            if (secureRandom == null) {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey);\n-            } else {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey, secureRandom);\n-            }\n-        } catch (InvalidKeyException ex) {\n-            throw new XMLSignatureException(ex);\n-        }\n+        engineInitSign(privateKey, secureRandom, this.signatureAlgorithm);\n@@ -235,1 +192,1 @@\n-    protected void engineUpdate(byte buf[], int offset, int len) throws XMLSignatureException {\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n@@ -290,0 +247,5 @@\n+        public SHA256(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n+        @Override\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureDSA.java","additions":33,"deletions":71,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -23,0 +23,3 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n@@ -26,9 +29,1 @@\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.NoSuchProviderException;\n-import java.security.PrivateKey;\n-import java.security.PublicKey;\n-import java.security.SecureRandom;\n-import java.security.Signature;\n-import java.security.SignatureException;\n+import java.security.*;\n@@ -52,5 +47,1 @@\n-    \/** {@inheritDoc} *\/\n-    public abstract String engineGetURI();\n-\n-    \/** Field algorithm *\/\n-    private Signature signatureAlgorithm;\n+    private final Signature signatureAlgorithm;\n@@ -75,1 +66,1 @@\n-    public static byte[] convertASN1toXMLDSIG(byte asn1Bytes[], int rawLen) throws IOException {\n+    public static byte[] convertASN1toXMLDSIG(byte[] asn1Bytes, int rawLen) throws IOException {\n@@ -92,1 +83,1 @@\n-    public static byte[] convertXMLDSIGtoASN1(byte xmldsigBytes[]) throws IOException {\n+    public static byte[] convertXMLDSIGtoASN1(byte[] xmldsigBytes) throws IOException {\n@@ -102,0 +93,2 @@\n+        this(null);\n+    }\n@@ -103,0 +96,1 @@\n+    public SignatureECDSA(Provider provider) throws XMLSignatureException {\n@@ -104,1 +98,0 @@\n-\n@@ -106,1 +99,1 @@\n-        String provider = JCEMapper.getProviderId();\n+\n@@ -109,1 +102,8 @@\n-                this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+                String providerId = JCEMapper.getProviderId();\n+                if (providerId == null) {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID);\n+\n+                } else {\n+                    this.signatureAlgorithm = Signature.getInstance(algorithmID, providerId);\n+                }\n+\n@@ -113,2 +113,0 @@\n-        } catch (java.security.NoSuchAlgorithmException ex) {\n-            Object[] exArgs = { algorithmID, ex.getLocalizedMessage() };\n@@ -116,2 +114,1 @@\n-            throw new XMLSignatureException(\"algorithms.NoSuchAlgorithm\", exArgs);\n-        } catch (NoSuchProviderException ex) {\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException ex) {\n@@ -119,1 +116,0 @@\n-\n@@ -144,3 +140,1 @@\n-        } catch (SignatureException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (IOException ex) {\n+        } catch (SignatureException | IOException ex) {\n@@ -153,28 +147,1 @@\n-\n-        if (!(publicKey instanceof PublicKey)) {\n-            String supplied = null;\n-            if (publicKey != null) {\n-                supplied = publicKey.getClass().getName();\n-            }\n-            String needed = PublicKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            this.signatureAlgorithm.initVerify((PublicKey) publicKey);\n-        } catch (InvalidKeyException ex) {\n-            \/\/ reinstantiate Signature object to work around bug in JDK\n-            \/\/ see: http:\/\/bugs.java.com\/view_bug.do?bug_id=4953555\n-            Signature sig = this.signatureAlgorithm;\n-            try {\n-                this.signatureAlgorithm = Signature.getInstance(signatureAlgorithm.getAlgorithm());\n-            } catch (Exception e) {\n-                \/\/ this shouldn't occur, but if it does, restore previous\n-                \/\/ Signature\n-                LOG.debug(\"Exception when reinstantiating Signature: {}\", e);\n-                this.signatureAlgorithm = sig;\n-            }\n-            throw new XMLSignatureException(ex);\n-        }\n+        engineInitVerify(publicKey, signatureAlgorithm);\n@@ -186,1 +153,1 @@\n-            byte jcebytes[] = this.signatureAlgorithm.sign();\n+            byte[] jcebytes = this.signatureAlgorithm.sign();\n@@ -188,3 +155,1 @@\n-        } catch (SignatureException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (IOException ex) {\n+        } catch (SignatureException | IOException ex) {\n@@ -198,24 +163,4 @@\n-        if (!(privateKey instanceof PrivateKey)) {\n-            String supplied = null;\n-            if (privateKey != null) {\n-                supplied = privateKey.getClass().getName();\n-            }\n-            String needed = PrivateKey.class.getName();\n-            Object exArgs[] = { supplied, needed };\n-\n-            throw new XMLSignatureException(\"algorithms.WrongKeyForThisOperation\", exArgs);\n-        }\n-\n-        try {\n-            if (privateKey instanceof ECPrivateKey) {\n-                ECPrivateKey ecKey = (ECPrivateKey)privateKey;\n-                signIntLen = (ecKey.getParams().getCurve().getField().getFieldSize() + 7) \/ 8;\n-                \/\/ If not ECPrivateKey, signIntLen remains -1\n-            }\n-            if (secureRandom == null) {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey);\n-            } else {\n-                this.signatureAlgorithm.initSign((PrivateKey) privateKey, secureRandom);\n-            }\n-        } catch (InvalidKeyException ex) {\n-            throw new XMLSignatureException(ex);\n+        if (privateKey instanceof ECPrivateKey) {\n+            ECPrivateKey ecKey = (ECPrivateKey) privateKey;\n+            signIntLen = (ecKey.getParams().getCurve().getField().getFieldSize() + 7) \/ 8;\n+            \/\/ If not ECPrivateKey, signIntLen remains -1\n@@ -223,0 +168,1 @@\n+        engineInitSign(privateKey, secureRandom, this.signatureAlgorithm);\n@@ -249,1 +195,1 @@\n-    protected void engineUpdate(byte buf[], int offset, int len) throws XMLSignatureException {\n+    protected void engineUpdate(byte[] buf, int offset, int len) throws XMLSignatureException {\n@@ -294,0 +240,4 @@\n+        public SignatureECDSASHA1(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -295,0 +245,1 @@\n+        @Override\n@@ -314,0 +265,4 @@\n+        public SignatureECDSASHA224(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -315,0 +270,1 @@\n+        @Override\n@@ -335,0 +291,4 @@\n+        public SignatureECDSASHA256(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -336,0 +296,1 @@\n+        @Override\n@@ -356,0 +317,4 @@\n+        public SignatureECDSASHA384(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -357,0 +322,1 @@\n+        @Override\n@@ -377,0 +343,4 @@\n+        public SignatureECDSASHA512(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -378,0 +348,1 @@\n+        @Override\n@@ -397,0 +368,4 @@\n+        public SignatureECDSARIPEMD160(Provider provider) throws XMLSignatureException {\n+            super(provider);\n+        }\n+\n@@ -398,0 +373,1 @@\n+        @Override\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/SignatureECDSA.java","additions":60,"deletions":84,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    public CanonicalizationException(String msgID, Object exArgs[]) {\n+    public CanonicalizationException(String msgID, Object[] exArgs) {\n@@ -92,1 +92,1 @@\n-        Exception originalException, String msgID, Object exArgs[]\n+        Exception originalException, String msgID, Object[] exArgs\n@@ -98,1 +98,1 @@\n-    public CanonicalizationException(String msgID, Object exArgs[], Exception originalException) {\n+    public CanonicalizationException(String msgID, Object[] exArgs, Exception originalException) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/CanonicalizationException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.InputStream;\n@@ -41,0 +39,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -42,2 +41,0 @@\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-import org.w3c.dom.Document;\n@@ -45,2 +42,0 @@\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.InputSource;\n@@ -51,1 +46,1 @@\n-public class Canonicalizer {\n+public final class Canonicalizer {\n@@ -100,1 +95,1 @@\n-        new ConcurrentHashMap<String, Class<? extends CanonicalizerSpi>>();\n+        new ConcurrentHashMap<>();\n@@ -103,1 +98,0 @@\n-    private boolean secureValidation;\n@@ -115,5 +109,1 @@\n-\n-            @SuppressWarnings(\"deprecation\")\n-            CanonicalizerSpi tmp = implementingClass.newInstance();\n-            canonicalizerSpi = tmp;\n-            canonicalizerSpi.reset = true;\n+            canonicalizerSpi = JavaUtils.newInstanceWithEmptyConstructor(implementingClass);\n@@ -121,1 +111,1 @@\n-            Object exArgs[] = { algorithmURI };\n+            Object[] exArgs = { algorithmURI };\n@@ -158,1 +148,1 @@\n-            Object exArgs[] = { algorithmURI, registeredClass };\n+            Object[] exArgs = { algorithmURI, registeredClass };\n@@ -184,1 +174,1 @@\n-            Object exArgs[] = { algorithmURI, registeredClass };\n+            Object[] exArgs = { algorithmURI, registeredClass };\n@@ -225,18 +215,0 @@\n-    \/**\n-     * Method getURI\n-     *\n-     * @return the URI defined for this c14n instance.\n-     *\/\n-    public final String getURI() {\n-        return canonicalizerSpi.engineGetURI();\n-    }\n-\n-    \/**\n-     * Method getIncludeComments\n-     *\n-     * @return true if the c14n respect the comments.\n-     *\/\n-    public boolean getIncludeComments() {\n-        return canonicalizerSpi.engineGetIncludeComments();\n-    }\n-\n@@ -249,1 +221,2 @@\n-     * @return the result of the canonicalization.\n+     * @param writer OutputStream to write the canonicalization result\n+     * @param secureValidation Whether secure validation is enabled\n@@ -252,2 +225,1 @@\n-     * @throws javax.xml.parsers.ParserConfigurationException\n-     * @throws org.xml.sax.SAXException\n+     * @throws XMLParserException\n@@ -255,24 +227,3 @@\n-    public byte[] canonicalize(byte[] inputBytes)\n-        throws javax.xml.parsers.ParserConfigurationException,\n-        java.io.IOException, org.xml.sax.SAXException, CanonicalizationException {\n-        Document document = null;\n-        try (InputStream bais = new ByteArrayInputStream(inputBytes)) {\n-            InputSource in = new InputSource(bais);\n-\n-            \/*\n-             * Text from the spec:\n-             *\n-             * The input octet stream MUST contain a well-formed XML document,\n-             * but the input need not be validated. However, the attribute\n-             * value normalization and entity reference resolution MUST be\n-             * performed in accordance with the behaviors of a validating\n-             * XML processor. As well, nodes for default attributes (declared\n-             * in the ATTLIST with an AttValue but not specified) are created\n-             * in each element. Thus, the declarations in the document type\n-             * declaration are used to help create the canonical form, even\n-             * though the document type declaration is not retained in the\n-             * canonical form.\n-             *\/\n-            document = XMLUtils.read(in, secureValidation);\n-        }\n-        return this.canonicalizeSubtree(document);\n+    public void canonicalize(byte[] inputBytes, OutputStream writer, boolean secureValidation)\n+        throws XMLParserException, java.io.IOException, CanonicalizationException {\n+        canonicalizerSpi.engineCanonicalize(inputBytes, writer, secureValidation);\n@@ -285,1 +236,1 @@\n-     * @return the result of the c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -289,3 +240,2 @@\n-    public byte[] canonicalizeSubtree(Node node) throws CanonicalizationException {\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return canonicalizerSpi.engineCanonicalizeSubTree(node);\n+    public void canonicalizeSubtree(Node node, OutputStream writer) throws CanonicalizationException {\n+        canonicalizerSpi.engineCanonicalizeSubTree(node, writer);\n@@ -299,1 +249,1 @@\n-     * @return the result of the c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -302,1 +252,1 @@\n-    public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces)\n+    public void canonicalizeSubtree(Node node, String inclusiveNamespaces, OutputStream writer)\n@@ -304,2 +254,1 @@\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces);\n+        canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces, writer);\n@@ -313,1 +262,1 @@\n-     * @return the result of the c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -316,1 +265,2 @@\n-    public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces, boolean propagateDefaultNamespace)\n+    public void canonicalizeSubtree(Node node, String inclusiveNamespaces,\n+                                    boolean propagateDefaultNamespace, OutputStream writer)\n@@ -318,33 +268,1 @@\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces, propagateDefaultNamespace);\n-    }\n-\n-    \/**\n-     * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated\n-     * as a list of XPath nodes, not as a list of subtrees.\n-     *\n-     * @param xpathNodeSet\n-     * @return the result of the c14n.\n-     * @throws CanonicalizationException\n-     *\/\n-    public byte[] canonicalizeXPathNodeSet(NodeList xpathNodeSet)\n-        throws CanonicalizationException {\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);\n-    }\n-\n-    \/**\n-     * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated\n-     * as a list of XPath nodes, not as a list of subtrees.\n-     *\n-     * @param xpathNodeSet\n-     * @param inclusiveNamespaces\n-     * @return the result of the c14n.\n-     * @throws CanonicalizationException\n-     *\/\n-    public byte[] canonicalizeXPathNodeSet(\n-        NodeList xpathNodeSet, String inclusiveNamespaces\n-    ) throws CanonicalizationException {\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return\n-            canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);\n+        canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces, propagateDefaultNamespace, writer);\n@@ -357,1 +275,1 @@\n-     * @return the result of the c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -360,1 +278,1 @@\n-    public byte[] canonicalizeXPathNodeSet(Set<Node> xpathNodeSet)\n+    public void canonicalizeXPathNodeSet(Set<Node> xpathNodeSet, OutputStream writer)\n@@ -362,2 +280,1 @@\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);\n+        canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, writer);\n@@ -371,1 +288,1 @@\n-     * @return the result of the c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -374,2 +291,2 @@\n-    public byte[] canonicalizeXPathNodeSet(\n-        Set<Node> xpathNodeSet, String inclusiveNamespaces\n+    public void canonicalizeXPathNodeSet(\n+        Set<Node> xpathNodeSet, String inclusiveNamespaces, OutputStream writer\n@@ -377,36 +294,1 @@\n-        canonicalizerSpi.secureValidation = secureValidation;\n-        return\n-            canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);\n-    }\n-\n-    \/**\n-     * Sets the writer where the canonicalization ends.  ByteArrayOutputStream\n-     * if none is set.\n-     * @param os\n-     *\/\n-    public void setWriter(OutputStream os) {\n-        canonicalizerSpi.setWriter(os);\n-    }\n-\n-    \/**\n-     * Returns the name of the implementing {@link CanonicalizerSpi} class\n-     *\n-     * @return the name of the implementing {@link CanonicalizerSpi} class\n-     *\/\n-    public String getImplementingCanonicalizerClass() {\n-        return canonicalizerSpi.getClass().getName();\n-    }\n-\n-    \/**\n-     * Set the canonicalizer behaviour to not reset.\n-     *\/\n-    public void notReset() {\n-        canonicalizerSpi.reset = false;\n-    }\n-\n-    public boolean isSecureValidation() {\n-        return secureValidation;\n-    }\n-\n-    public void setSecureValidation(boolean secureValidation) {\n-        this.secureValidation = secureValidation;\n+        canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces, writer);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/Canonicalizer.java","additions":30,"deletions":148,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -32,2 +33,0 @@\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.InputSource;\n@@ -41,4 +40,0 @@\n-    \/** Reset the writer after a c14n *\/\n-    protected boolean reset = false;\n-    protected boolean secureValidation;\n-\n@@ -49,1 +44,2 @@\n-     * @return the c14n bytes.\n+     * @param writer OutputStream to write the canonicalization result\n+     * @param secureValidation Whether secure validation is enabled\n@@ -51,1 +47,1 @@\n-     * @throws CanonicalizationException\n+     * @throws XMLParserException\n@@ -54,1 +50,0 @@\n-     * @throws org.xml.sax.SAXException\n@@ -56,3 +51,2 @@\n-    public byte[] engineCanonicalize(byte[] inputBytes)\n-        throws javax.xml.parsers.ParserConfigurationException, java.io.IOException,\n-        org.xml.sax.SAXException, CanonicalizationException {\n+    public void engineCanonicalize(byte[] inputBytes, OutputStream writer, boolean secureValidation)\n+        throws XMLParserException, java.io.IOException, CanonicalizationException {\n@@ -62,3 +56,1 @@\n-            InputSource in = new InputSource(bais);\n-\n-            document = XMLUtils.read(in, secureValidation);\n+            document = XMLUtils.read(bais, secureValidation);\n@@ -66,30 +58,1 @@\n-        return this.engineCanonicalizeSubTree(document);\n-    }\n-\n-    \/**\n-     * Method engineCanonicalizeXPathNodeSet\n-     *\n-     * @param xpathNodeSet\n-     * @return the c14n bytes\n-     * @throws CanonicalizationException\n-     *\/\n-    public byte[] engineCanonicalizeXPathNodeSet(NodeList xpathNodeSet)\n-        throws CanonicalizationException {\n-        return this.engineCanonicalizeXPathNodeSet(\n-            XMLUtils.convertNodelistToSet(xpathNodeSet)\n-        );\n-    }\n-\n-    \/**\n-     * Method engineCanonicalizeXPathNodeSet\n-     *\n-     * @param xpathNodeSet\n-     * @param inclusiveNamespaces\n-     * @return the c14n bytes\n-     * @throws CanonicalizationException\n-     *\/\n-    public byte[] engineCanonicalizeXPathNodeSet(NodeList xpathNodeSet, String inclusiveNamespaces)\n-        throws CanonicalizationException {\n-        return this.engineCanonicalizeXPathNodeSet(\n-            XMLUtils.convertNodelistToSet(xpathNodeSet), inclusiveNamespaces\n-        );\n+        this.engineCanonicalizeSubTree(document, writer);\n@@ -104,6 +67,0 @@\n-    \/**\n-     * Returns true if comments are included\n-     * @return true if comments are included\n-     *\/\n-    public abstract boolean engineGetIncludeComments();\n-\n@@ -114,1 +71,1 @@\n-     * @return the c14n bytes\n+     * @param writer OutputStream to write the canonicalization result\n@@ -117,1 +74,1 @@\n-    public abstract byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet)\n+    public abstract void engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, OutputStream writer)\n@@ -125,1 +82,1 @@\n-     * @return the c14n bytes\n+     * @param writer OutputStream to write the canonicalization result\n@@ -128,2 +85,2 @@\n-    public abstract byte[] engineCanonicalizeXPathNodeSet(\n-        Set<Node> xpathNodeSet, String inclusiveNamespaces\n+    public abstract void engineCanonicalizeXPathNodeSet(\n+        Set<Node> xpathNodeSet, String inclusiveNamespaces, OutputStream writer\n@@ -136,1 +93,1 @@\n-     * @return the c14n bytes\n+     * @param writer OutputStream to write the canonicalization result\n@@ -139,1 +96,1 @@\n-    public abstract byte[] engineCanonicalizeSubTree(Node rootNode)\n+    public abstract void engineCanonicalizeSubTree(Node rootNode, OutputStream writer)\n@@ -147,1 +104,1 @@\n-     * @return the c14n bytes\n+     * @param writer OutputStream to write the canonicalization result\n@@ -150,1 +107,1 @@\n-    public abstract byte[] engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces)\n+    public abstract void engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces, OutputStream writer)\n@@ -159,1 +116,1 @@\n-     * @return the c14n bytes\n+     * @param writer OutputStream to write the canonicalization result\n@@ -162,2 +119,2 @@\n-    public abstract byte[] engineCanonicalizeSubTree(\n-            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace)\n+    public abstract void engineCanonicalizeSubTree(\n+            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace, OutputStream writer)\n@@ -166,14 +123,0 @@\n-    \/**\n-     * Sets the writer where the canonicalization ends. ByteArrayOutputStream if\n-     * none is set.\n-     * @param os\n-     *\/\n-    public abstract void setWriter(OutputStream os);\n-\n-    public boolean isSecureValidation() {\n-        return secureValidation;\n-    }\n-\n-    public void setSecureValidation(boolean secureValidation) {\n-        this.secureValidation = secureValidation;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/CanonicalizerSpi.java","additions":20,"deletions":77,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public InvalidCanonicalizerException(String msgID, Object exArgs[]) {\n+    public InvalidCanonicalizerException(String msgID, Object[] exArgs) {\n@@ -84,1 +84,1 @@\n-        Exception originalException, String msgID, Object exArgs[]\n+        Exception originalException, String msgID, Object[] exArgs\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/InvalidCanonicalizerException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n@@ -27,3 +26,0 @@\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.NamedNodeMap;\n@@ -39,1 +35,0 @@\n-     *\n@@ -89,66 +84,0 @@\n-    \/**\n-     * This method throws an exception if the Attribute value contains\n-     * a relative URI.\n-     *\n-     * @param attr\n-     * @throws CanonicalizationException\n-     *\/\n-    public static void assertNotRelativeNS(Attr attr) throws CanonicalizationException {\n-        if (attr == null) {\n-            return;\n-        }\n-\n-        String nodeAttrName = attr.getNodeName();\n-        boolean definesDefaultNS = \"xmlns\".equals(nodeAttrName);\n-        boolean definesNonDefaultNS = nodeAttrName.startsWith(\"xmlns:\");\n-\n-        if ((definesDefaultNS || definesNonDefaultNS) && namespaceIsRelative(attr)) {\n-            String parentName = attr.getOwnerElement().getTagName();\n-            String attrValue = attr.getValue();\n-            Object exArgs[] = { parentName, nodeAttrName, attrValue };\n-\n-            throw new CanonicalizationException(\n-                \"c14n.Canonicalizer.RelativeNamespace\", exArgs\n-            );\n-        }\n-    }\n-\n-    \/**\n-     * This method throws a CanonicalizationException if the supplied Document\n-     * is not able to be traversed using a TreeWalker.\n-     *\n-     * @param document\n-     * @throws CanonicalizationException\n-     *\/\n-    public static void checkTraversability(Document document)\n-        throws CanonicalizationException {\n-        if (!document.isSupported(\"Traversal\", \"2.0\")) {\n-            Object exArgs[] = {document.getImplementation().getClass().getName() };\n-\n-            throw new CanonicalizationException(\n-                \"c14n.Canonicalizer.TraversalNotSupported\", exArgs\n-            );\n-        }\n-    }\n-\n-    \/**\n-     * This method throws a CanonicalizationException if the supplied Element\n-     * contains any relative namespaces.\n-     *\n-     * @param ctxNode\n-     * @throws CanonicalizationException\n-     * @see C14nHelper#assertNotRelativeNS(Attr)\n-     *\/\n-    public static void checkForRelativeNamespace(Element ctxNode)\n-        throws CanonicalizationException {\n-        if (ctxNode != null) {\n-            NamedNodeMap attributes = ctxNode.getAttributes();\n-\n-            int length = attributes.getLength();\n-            for (int i = 0; i < length; i++) {\n-                C14nHelper.assertNotRelativeNS((Attr) attributes.item(i));\n-            }\n-        } else {\n-            throw new CanonicalizationException(\"Called checkForRelativeNamespace() on null\");\n-        }\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/helper\/C14nHelper.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    public final boolean engineGetIncludeComments() {\n-        return false;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer11_OmitComments.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    public final boolean engineGetIncludeComments() {\n-        return true;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer11_WithComments.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -36,0 +34,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -44,1 +43,0 @@\n-import org.xml.sax.SAXException;\n@@ -85,1 +83,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -88,1 +86,1 @@\n-    public byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, String inclusiveNamespaces)\n+    public void engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, String inclusiveNamespaces, OutputStream writer)\n@@ -100,1 +98,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -103,1 +101,1 @@\n-    public byte[] engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces)\n+    public void engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces, OutputStream writer)\n@@ -115,1 +113,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -118,2 +116,2 @@\n-    public byte[] engineCanonicalizeSubTree(\n-            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace)\n+    public void engineCanonicalizeSubTree(\n+            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace, OutputStream writer)\n@@ -129,2 +127,2 @@\n-     * The code of this method is a copy of {@link #outputAttributes(Element,\n-     * NameSpaceSymbTable, Map<String, byte[]>)},\n+     * The code of this method is a copy of\n+     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map)},\n@@ -138,0 +136,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -142,1 +141,1 @@\n-                                           Map<String, byte[]> cache)\n+                                           Map<String, byte[]> cache, OutputStream writer)\n@@ -148,1 +147,1 @@\n-        SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);\n+        SortedSet<Attr> result = new TreeSet<>(COMPARE);\n@@ -171,1 +170,1 @@\n-                            Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };\n+                            Object[] exArgs = { element.getTagName(), NName, attribute.getNodeValue() };\n@@ -190,1 +189,0 @@\n-        OutputStream writer = getWriter();\n@@ -207,0 +205,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -211,1 +210,1 @@\n-                                    Map<String, byte[]> cache)\n+                                    Map<String, byte[]> cache, OutputStream writer)\n@@ -216,1 +215,1 @@\n-        SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);\n+        SortedSet<Attr> result = new TreeSet<>(COMPARE);\n@@ -256,1 +255,1 @@\n-                                    Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };\n+                                    Object[] exArgs = { element.getTagName(), NName, attribute.getNodeValue() };\n@@ -295,1 +294,0 @@\n-        OutputStream writer = getWriter();\n@@ -303,1 +301,1 @@\n-        throws CanonicalizationException, ParserConfigurationException, IOException, SAXException {\n+        throws XMLParserException, IOException {\n@@ -342,1 +340,1 @@\n-            if (NName == null || NName.equals(\"\")) {\n+            if (NName == null || NName.isEmpty()) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315.java","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Collections;\n@@ -31,1 +32,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -35,0 +35,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -44,1 +45,0 @@\n-import org.xml.sax.SAXException;\n@@ -66,1 +66,1 @@\n-    private SortedSet<String> inclusiveNSSet;\n+    private SortedSet<String> inclusiveNSSet = Collections.emptySortedSet();\n@@ -82,1 +82,1 @@\n-     *\n+     * @param writer OutputStream to write the canonicalization result\n@@ -85,1 +85,1 @@\n-    public byte[] engineCanonicalizeSubTree(Node rootNode)\n+    public void engineCanonicalizeSubTree(Node rootNode, OutputStream writer)\n@@ -87,1 +87,1 @@\n-        return engineCanonicalizeSubTree(rootNode, \"\", null);\n+        engineCanonicalizeSubTree(rootNode, \"\", null, writer);\n@@ -95,1 +95,1 @@\n-     *\n+     * @param writer OutputStream to write the canonicalization result\n@@ -98,2 +98,2 @@\n-    public byte[] engineCanonicalizeSubTree(\n-        Node rootNode, String inclusiveNamespaces\n+    public void engineCanonicalizeSubTree(\n+        Node rootNode, String inclusiveNamespaces, OutputStream writer\n@@ -101,1 +101,1 @@\n-        return engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null);\n+        engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null, writer);\n@@ -110,1 +110,1 @@\n-     *\n+     * @param writer OutputStream to write the canonicalization result\n@@ -113,2 +113,2 @@\n-    public byte[] engineCanonicalizeSubTree(\n-            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace\n+    public void engineCanonicalizeSubTree(\n+        Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace, OutputStream writer\n@@ -117,1 +117,1 @@\n-        return engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null);\n+        engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null, writer);\n@@ -125,1 +125,1 @@\n-     * @return the rootNode c14n.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -128,2 +128,2 @@\n-    public byte[] engineCanonicalizeSubTree(\n-        Node rootNode, String inclusiveNamespaces, Node excl\n+    public void engineCanonicalizeSubTree(\n+        Node rootNode, String inclusiveNamespaces, Node excl, OutputStream writer\n@@ -132,1 +132,1 @@\n-        return super.engineCanonicalizeSubTree(rootNode, excl);\n+        super.engineCanonicalizeSubTree(rootNode, excl, writer);\n@@ -139,1 +139,2 @@\n-     * @return the rootNode c14n.\n+     * @param writer OutputStream to write the canonicalization result\n+     * @param secureValidation Whether secure validation is enabled\n@@ -142,2 +143,2 @@\n-    public byte[] engineCanonicalize(\n-        XMLSignatureInput rootNode, String inclusiveNamespaces\n+    public void engineCanonicalize(\n+        XMLSignatureInput rootNode, String inclusiveNamespaces, OutputStream writer, boolean secureValidation\n@@ -146,1 +147,1 @@\n-        return super.engineCanonicalize(rootNode);\n+        super.engineCanonicalize(rootNode, writer, secureValidation);\n@@ -154,0 +155,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -156,2 +158,2 @@\n-    public byte[] engineCanonicalizeXPathNodeSet(\n-        Set<Node> xpathNodeSet, String inclusiveNamespaces\n+    public void engineCanonicalizeXPathNodeSet(\n+        Set<Node> xpathNodeSet, String inclusiveNamespaces, OutputStream writer\n@@ -160,1 +162,1 @@\n-        return super.engineCanonicalizeXPathNodeSet(xpathNodeSet);\n+        super.engineCanonicalizeXPathNodeSet(xpathNodeSet, writer);\n@@ -165,1 +167,1 @@\n-                                           Map<String, byte[]> cache)\n+                                           Map<String, byte[]> cache, OutputStream writer)\n@@ -168,1 +170,1 @@\n-        SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);\n+        SortedSet<Attr> result = new TreeSet<>(COMPARE);\n@@ -172,2 +174,2 @@\n-        SortedSet<String> visiblyUtilized = new TreeSet<String>();\n-        if (inclusiveNSSet != null && !inclusiveNSSet.isEmpty()) {\n+        SortedSet<String> visiblyUtilized = new TreeSet<>();\n+        if (!inclusiveNSSet.isEmpty()) {\n@@ -200,1 +202,1 @@\n-                    Object exArgs[] = {element.getTagName(), NName, attribute.getNodeValue()};\n+                    Object[] exArgs = {element.getTagName(), NName, attribute.getNodeValue()};\n@@ -230,1 +232,0 @@\n-        OutputStream writer = getWriter();\n@@ -237,3 +238,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -242,1 +240,1 @@\n-                                    Map<String, byte[]> cache)\n+                                    Map<String, byte[]> cache, OutputStream writer)\n@@ -245,1 +243,1 @@\n-        SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);\n+        SortedSet<Attr> result = new TreeSet<>(COMPARE);\n@@ -253,2 +251,2 @@\n-            visiblyUtilized = new TreeSet<String>();\n-            if (inclusiveNSSet != null && !inclusiveNSSet.isEmpty()) {\n+            visiblyUtilized = new TreeSet<>();\n+            if (!inclusiveNSSet.isEmpty()) {\n@@ -289,1 +287,1 @@\n-                                Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };\n+                                Object[] exArgs = { element.getTagName(), NName, attribute.getNodeValue() };\n@@ -300,1 +298,1 @@\n-                        Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };\n+                        Object[] exArgs = { element.getTagName(), NName, attribute.getNodeValue() };\n@@ -335,1 +333,0 @@\n-        OutputStream writer = getWriter();\n@@ -343,2 +340,1 @@\n-        throws CanonicalizationException, ParserConfigurationException,\n-               IOException, SAXException {\n+        throws XMLParserException, IOException {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315Excl.java","additions":39,"deletions":43,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-    \/** {@inheritDoc} *\/\n-    public final boolean engineGetIncludeComments() {\n-        return false;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315ExclOmitComments.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,4 +45,0 @@\n-    \/** {@inheritDoc} *\/\n-    public final boolean engineGetIncludeComments() {\n-        return true;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315ExclWithComments.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,4 +44,0 @@\n-    \/** {@inheritDoc} *\/\n-    public final boolean engineGetIncludeComments() {\n-        return false;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315OmitComments.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-    \/** {@inheritDoc} *\/\n-    public final boolean engineGetIncludeComments() {\n-        return true;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315WithComments.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -37,2 +36,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -42,0 +39,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -45,1 +43,0 @@\n-import com.sun.org.apache.xml.internal.security.utils.UnsyncByteArrayOutputStream;\n@@ -55,1 +52,0 @@\n-import org.xml.sax.SAXException;\n@@ -68,1 +64,4 @@\n-    protected static final AttrCompare COMPARE = new AttrCompare();\n+    protected static final AttrCompare COMPARE = new AttrCompare();     \/\/ thread-safe\n+    protected static final int NODE_BEFORE_DOCUMENT_ELEMENT = -1;\n+    protected static final int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT = 0;\n+    protected static final int NODE_AFTER_DOCUMENT_ELEMENT = 1;\n@@ -86,4 +85,1 @@\n-    protected static final int NODE_BEFORE_DOCUMENT_ELEMENT = -1;\n-    protected static final int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT = 0;\n-    protected static final int NODE_AFTER_DOCUMENT_ELEMENT = 1;\n-\n+    private boolean includeComments;\n@@ -92,1 +88,0 @@\n-    private boolean includeComments;\n@@ -96,2 +91,1 @@\n-     * The node to be skipped\/excluded from the DOM tree\n-     * in subtree canonicalizations.\n+     * The null xmlns definition.\n@@ -99,6 +93,0 @@\n-    private Node excludeNode;\n-    private OutputStream writer = new ByteArrayOutputStream();\n-\n-   \/**\n-    * The null xmlns definition.\n-    *\/\n@@ -112,1 +100,1 @@\n-    public CanonicalizerBase(boolean includeComments) {\n+    protected CanonicalizerBase(boolean includeComments) {\n@@ -120,0 +108,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -122,1 +111,1 @@\n-    public byte[] engineCanonicalizeSubTree(Node rootNode)\n+    public void engineCanonicalizeSubTree(Node rootNode, OutputStream writer)\n@@ -124,1 +113,1 @@\n-        return engineCanonicalizeSubTree(rootNode, (Node)null);\n+        engineCanonicalizeSubTree(rootNode, (Node)null, writer);\n@@ -131,0 +120,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -133,1 +123,1 @@\n-    public byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet)\n+    public void engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, OutputStream writer)\n@@ -136,1 +126,1 @@\n-        return engineCanonicalizeXPathNodeSetInternal(XMLUtils.getOwnerDocument(this.xpathNodeSet));\n+        engineCanonicalizeXPathNodeSetInternal(XMLUtils.getOwnerDocument(this.xpathNodeSet), writer);\n@@ -142,1 +132,3 @@\n-     * @return The canonicalize stream.\n+     * @param writer OutputStream to write the canonicalization result\n+     * @param secureValidation Whether secure validation is enabled\n+     *\n@@ -145,1 +137,1 @@\n-    public byte[] engineCanonicalize(XMLSignatureInput input) throws CanonicalizationException {\n+    public void engineCanonicalize(XMLSignatureInput input, OutputStream writer, boolean secureValidation) throws CanonicalizationException {\n@@ -151,4 +143,3 @@\n-                return engineCanonicalize(input.getBytes());\n-            }\n-            if (input.isElement()) {\n-                return engineCanonicalizeSubTree(input.getSubNode(), input.getExcludeNode());\n+                engineCanonicalize(input.getBytes(), writer, secureValidation);\n+            } else if (input.isElement()) {\n+                engineCanonicalizeSubTree(input.getSubNode(), input.getExcludeNode(), writer);\n@@ -161,1 +152,1 @@\n-                    return engineCanonicalizeXPathNodeSetInternal(input.getSubNode());\n+                    engineCanonicalizeXPathNodeSetInternal(input.getSubNode(), writer);\n@@ -163,1 +154,1 @@\n-                    return engineCanonicalizeXPathNodeSet(input.getNodeSet());\n+                    engineCanonicalizeXPathNodeSet(input.getNodeSet(), writer);\n@@ -166,6 +157,1 @@\n-            return null;\n-        } catch (ParserConfigurationException ex) {\n-            throw new CanonicalizationException(ex);\n-        } catch (IOException ex) {\n-            throw new CanonicalizationException(ex);\n-        } catch (SAXException ex) {\n+        } catch (XMLParserException | IOException ex) {\n@@ -176,11 +162,0 @@\n-    \/**\n-     * @param writer The writer to set.\n-     *\/\n-    public void setWriter(OutputStream writer) {\n-        this.writer = writer;\n-    }\n-\n-    protected OutputStream getWriter() {\n-        return writer;\n-    }\n-\n@@ -194,1 +169,1 @@\n-     * @return The canonicalize stream.\n+     * @param writer OutputStream to write the canonicalization result\n@@ -197,1 +172,1 @@\n-    protected byte[] engineCanonicalizeSubTree(Node rootNode, Node excludeNode)\n+    protected void engineCanonicalizeSubTree(Node rootNode, Node excludeNode, OutputStream writer)\n@@ -199,1 +174,0 @@\n-        this.excludeNode = excludeNode;\n@@ -208,23 +182,2 @@\n-            this.canonicalizeSubTree(rootNode, ns, rootNode, nodeLevel);\n-            this.writer.flush();\n-            if (this.writer instanceof ByteArrayOutputStream) {\n-                byte[] result = ((ByteArrayOutputStream)this.writer).toByteArray();\n-                if (reset) {\n-                    ((ByteArrayOutputStream)this.writer).reset();\n-                } else {\n-                    this.writer.close();\n-                }\n-                return result;\n-            } else if (this.writer instanceof UnsyncByteArrayOutputStream) {\n-                byte[] result = ((UnsyncByteArrayOutputStream)this.writer).toByteArray();\n-                if (reset) {\n-                    ((UnsyncByteArrayOutputStream)this.writer).reset();\n-                } else {\n-                    this.writer.close();\n-                }\n-                return result;\n-            } else {\n-                this.writer.close();\n-            }\n-            return null;\n-\n+            this.canonicalizeSubTree(rootNode, ns, rootNode, nodeLevel, excludeNode, writer);\n+            writer.flush();\n@@ -245,0 +198,3 @@\n+     * @param documentLevel\n+     * @param excludeNode\n+     * @param writer OutputStream to write the canonicalization result\n@@ -248,2 +204,3 @@\n-    protected final void canonicalizeSubTree(\n-        Node currentNode, NameSpaceSymbTable ns, Node endnode, int documentLevel\n+    private void canonicalizeSubTree(\n+        Node currentNode, NameSpaceSymbTable ns, Node endnode, int documentLevel,\n+        Node excludeNode, OutputStream writer\n@@ -256,3 +213,0 @@\n-        final OutputStream writer = this.writer;\n-        final Node excludeNode = this.excludeNode;\n-        final boolean includeComments = this.includeComments;\n@@ -303,1 +257,1 @@\n-                outputAttributesSubtree(currentElement, ns, cache);\n+                outputAttributesSubtree(currentElement, ns, cache, writer);\n@@ -350,1 +304,1 @@\n-    private byte[] engineCanonicalizeXPathNodeSetInternal(Node doc)\n+    private void engineCanonicalizeXPathNodeSetInternal(Node doc, OutputStream writer)\n@@ -353,24 +307,2 @@\n-            this.canonicalizeXPathNodeSet(doc, doc);\n-            this.writer.flush();\n-            if (this.writer instanceof ByteArrayOutputStream) {\n-                byte[] sol = ((ByteArrayOutputStream)this.writer).toByteArray();\n-                if (reset) {\n-                    ((ByteArrayOutputStream)this.writer).reset();\n-                } else {\n-                    this.writer.close();\n-                }\n-                return sol;\n-            } else if (this.writer instanceof UnsyncByteArrayOutputStream) {\n-                byte[] result = ((UnsyncByteArrayOutputStream)this.writer).toByteArray();\n-                if (reset) {\n-                    ((UnsyncByteArrayOutputStream)this.writer).reset();\n-                } else {\n-                    this.writer.close();\n-                }\n-                return result;\n-            } else {\n-                this.writer.close();\n-            }\n-            return null;\n-        } catch (UnsupportedEncodingException ex) {\n-            throw new CanonicalizationException(ex);\n+            this.canonicalizeXPathNodeSet(doc, doc, writer);\n+            writer.flush();\n@@ -388,0 +320,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -391,1 +324,1 @@\n-    protected final void canonicalizeXPathNodeSet(Node currentNode, Node endnode)\n+    private void canonicalizeXPathNodeSet(Node currentNode, Node endnode, OutputStream writer)\n@@ -425,1 +358,1 @@\n-                if (this.includeComments && isVisibleDO(currentNode, ns.getLevel()) == 1) {\n+                if (includeComments && isVisibleDO(currentNode, ns.getLevel()) == 1) {\n@@ -471,1 +404,1 @@\n-                outputAttributes(currentElement, ns, cache);\n+                outputAttributes(currentElement, ns, cache, writer);\n@@ -569,4 +502,2 @@\n-        if (this.xpathNodeSet != null && !this.xpathNodeSet.contains(currentNode)) {\n-            return false;\n-        }\n-        return true;\n+\n+        return this.xpathNodeSet == null || this.xpathNodeSet.contains(currentNode);\n@@ -595,1 +526,1 @@\n-            if (NName == null || NName.equals(\"\")) {\n+            if (NName == null || NName.isEmpty()) {\n@@ -612,1 +543,1 @@\n-    protected final void getParentNameSpaces(Element el, NameSpaceSymbTable ns)  {\n+    private void getParentNameSpaces(Element el, NameSpaceSymbTable ns)  {\n@@ -644,0 +575,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -646,1 +578,2 @@\n-    abstract void outputAttributes(Element element, NameSpaceSymbTable ns, Map<String, byte[]> cache)\n+    abstract void outputAttributes(Element element, NameSpaceSymbTable ns,\n+                                   Map<String, byte[]> cache, OutputStream writer)\n@@ -655,0 +588,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -657,1 +591,2 @@\n-    abstract void outputAttributesSubtree(Element element, NameSpaceSymbTable ns, Map<String, byte[]> cache)\n+    abstract void outputAttributesSubtree(Element element, NameSpaceSymbTable ns,\n+                                          Map<String, byte[]> cache, OutputStream writer)\n@@ -661,1 +596,1 @@\n-        throws CanonicalizationException, ParserConfigurationException, IOException, SAXException;\n+        throws XMLParserException, IOException;\n@@ -837,1 +772,1 @@\n-    protected static final void outputTextToWriter(\n+    private static final void outputTextToWriter(\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerBase.java","additions":54,"deletions":119,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -36,0 +34,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -44,1 +43,0 @@\n-import org.xml.sax.SAXException;\n@@ -70,1 +68,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -73,1 +71,1 @@\n-    public byte[] engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, String inclusiveNamespaces)\n+    public void engineCanonicalizeXPathNodeSet(Set<Node> xpathNodeSet, String inclusiveNamespaces, OutputStream writer)\n@@ -85,1 +83,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -88,1 +86,1 @@\n-    public byte[] engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces)\n+    public void engineCanonicalizeSubTree(Node rootNode, String inclusiveNamespaces, OutputStream writer)\n@@ -100,1 +98,1 @@\n-     * @return none it always fails\n+     * @param writer OutputStream to write the canonicalization result\n@@ -103,2 +101,2 @@\n-    public byte[] engineCanonicalizeSubTree(\n-            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace)\n+    public void engineCanonicalizeSubTree(\n+            Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace, OutputStream writer)\n@@ -114,2 +112,2 @@\n-     * The code of this method is a copy of {@link #outputAttributes(Element,\n-     * NameSpaceSymbTable, Map<String, byte[]>)},\n+     * The code of this method is a copy of\n+     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map)},\n@@ -123,0 +121,1 @@\n+     * @param writer OutputStream to write the canonicalization result\n@@ -127,1 +126,1 @@\n-                                           Map<String, byte[]> cache)\n+                                           Map<String, byte[]> cache, OutputStream writer)\n@@ -131,1 +130,1 @@\n-            SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);\n+            SortedSet<Attr> result = new TreeSet<>(COMPARE);\n@@ -141,1 +140,0 @@\n-            OutputStream writer = getWriter();\n@@ -151,1 +149,1 @@\n-                                    Map<String, byte[]> cache)\n+                                    Map<String, byte[]> cache, OutputStream writer)\n@@ -158,0 +156,1 @@\n+    @Override\n@@ -159,1 +158,1 @@\n-        throws CanonicalizationException, ParserConfigurationException, IOException, SAXException {\n+        throws XMLParserException, IOException {\n@@ -173,5 +172,0 @@\n-    \/** {@inheritDoc} *\/\n-    public final boolean engineGetIncludeComments() {\n-        return true;\n-    }\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerPhysical.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(NameSpaceSymbTable.class);\n+\n@@ -54,1 +57,1 @@\n-    private List<SymbMap> level;\n+    private final List<SymbMap> level = new ArrayList<>();\n@@ -61,1 +64,0 @@\n-        level = new ArrayList<>();\n@@ -63,1 +65,5 @@\n-        symb = (SymbMap) initialMap.clone();\n+        try {\n+            symb = initialMap.clone();\n+        } catch (CloneNotSupportedException e) {\n+            LOG.error(\"Error cloning the initial map\");\n+        }\n@@ -77,1 +83,1 @@\n-                n = (NameSpaceSymbEntry) n.clone();\n+                n = n.clone();\n@@ -135,1 +141,5 @@\n-            symb = (SymbMap) symb.clone();\n+            try {\n+                symb = symb.clone();\n+            } catch (CloneNotSupportedException e) {\n+                LOG.error(\"Error cloning the symbol map\");\n+            }\n@@ -158,1 +168,1 @@\n-        entry = (NameSpaceSymbEntry) entry.clone();\n+        entry = entry.clone();\n@@ -226,1 +236,1 @@\n-                ob = (NameSpaceSymbEntry) ob.clone();\n+                ob = ob.clone();\n@@ -285,1 +295,1 @@\n-    String prefix;\n+    final String prefix;\n@@ -288,1 +298,4 @@\n-    String uri;\n+    final String uri;\n+\n+    \/**The attribute to include.*\/\n+    final Attr n;\n@@ -296,3 +309,0 @@\n-    \/**The attribute to include.*\/\n-    Attr n;\n-\n@@ -307,1 +317,1 @@\n-    public Object clone() {\n+    public NameSpaceSymbEntry clone() { \/\/NOPMD\n@@ -309,1 +319,1 @@\n-            return super.clone();\n+            return (NameSpaceSymbEntry)super.clone();\n@@ -373,1 +383,1 @@\n-        String oldKeys[] = keys;\n+        String[] oldKeys = keys;\n@@ -393,7 +403,7 @@\n-    protected Object clone()  {\n-        try {\n-            SymbMap copy = (SymbMap) super.clone();\n-            copy.entries = new NameSpaceSymbEntry[entries.length];\n-            System.arraycopy(entries, 0, copy.entries, 0, entries.length);\n-            copy.keys = new String[keys.length];\n-            System.arraycopy(keys, 0, copy.keys, 0, keys.length);\n+    @Override\n+    public SymbMap clone() throws CloneNotSupportedException  {\n+        SymbMap copy = (SymbMap) super.clone();\n+        copy.entries = new NameSpaceSymbEntry[entries.length];\n+        System.arraycopy(entries, 0, copy.entries, 0, entries.length);\n+        copy.keys = new String[keys.length];\n+        System.arraycopy(keys, 0, copy.keys, 0, keys.length);\n@@ -401,5 +411,1 @@\n-            return copy;\n-        } catch (CloneNotSupportedException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n+        return copy;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/NameSpaceSymbTable.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -121,36 +121,0 @@\n-    @Deprecated\n-    public static void writeCharToUtf8(final char c, final OutputStream out) throws IOException {\n-        if (c < 0x80) {\n-            out.write(c);\n-            return;\n-        }\n-        if (c >= 0xD800 && c <= 0xDBFF || c >= 0xDC00 && c <= 0xDFFF) {\n-            \/\/No Surrogates in sun java\n-            out.write(0x3f);\n-            return;\n-        }\n-        int bias;\n-        int write;\n-        char ch;\n-        if (c > 0x07FF) {\n-            ch = (char)(c>>>12);\n-            write = 0xE0;\n-            if (ch > 0) {\n-                write |= ch & 0x0F;\n-            }\n-            out.write(write);\n-            write = 0x80;\n-            bias = 0x3F;\n-        } else {\n-            write = 0xC0;\n-            bias = 0x1F;\n-        }\n-        ch = (char)(c>>>6);\n-        if (ch > 0) {\n-            write |= ch & bias;\n-        }\n-        out.write(write);\n-        out.write(0x80 | ((c) & 0x3F));\n-\n-    }\n-\n@@ -250,1 +214,1 @@\n-                byte newResult[] = new byte[6*length];\n+                byte[] newResult = new byte[6*length];\n@@ -295,1 +259,1 @@\n-            byte newResult[] = new byte[out];\n+            byte[] newResult = new byte[out];\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/UtfHelpper.java","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    static class XmlsStackElement {\n+    private static class XmlsStackElement {\n@@ -47,1 +47,1 @@\n-        List<Attr> nodes = new ArrayList<>();\n+        final List<Attr> nodes = new ArrayList<>();\n@@ -53,2 +53,3 @@\n-    private List<XmlsStackElement> levels = new ArrayList<>();\n-    private boolean c14n11;\n+\n+    private final List<XmlsStackElement> levels = new ArrayList<>();\n+    private final boolean c14n11;\n@@ -123,1 +124,1 @@\n-                    if (n.getLocalName().equals(\"base\") && !e.rendered) {\n+                    if (\"base\".equals(n.getLocalName()) && !e.rendered) {\n@@ -136,1 +137,1 @@\n-                    if (n.getLocalName().equals(\"base\")) {\n+                    if (\"base\".equals(n.getLocalName())) {\n@@ -225,1 +226,1 @@\n-                    if (rpath.startsWith(\"\/\")) {\n+                    if (rpath.charAt(0) == '\/') {\n@@ -266,1 +267,1 @@\n-            output.append(\"\/\");\n+            output.append('\/');\n@@ -285,1 +286,1 @@\n-                if (!output.toString().equals(\"\/\")) {\n+                if (!\"\/\".equals(output.toString())) {\n@@ -295,1 +296,1 @@\n-            } else if (input.equals(\"\/.\")) {\n+            } else if (\"\/.\".equals(input)) {\n@@ -312,1 +313,1 @@\n-                    output.append(\"\/\");\n+                    output.append('\/');\n@@ -329,1 +330,1 @@\n-            } else if (input.equals(\"\/..\")) {\n+            } else if (\"\/..\".equals(input)) {\n@@ -333,1 +334,1 @@\n-                    output.append(\"\/\");\n+                    output.append('\/');\n@@ -355,1 +356,1 @@\n-            } else if (input.equals(\".\")) {\n+            } else if (\".\".equals(input)) {\n@@ -358,2 +359,2 @@\n-            } else if (input.equals(\"..\")) {\n-                if (!output.toString().equals(\"\/\")) {\n+            } else if (\"..\".equals(input)) {\n+                if (!\"\/\".equals(output.toString())) {\n@@ -395,1 +396,1 @@\n-            output.append(\"\/\");\n+            output.append('\/');\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/XmlAttrStack.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    public AlgorithmAlreadyRegisteredException(String msgID, Object exArgs[]) {\n+    public AlgorithmAlreadyRegisteredException(String msgID, Object[] exArgs) {\n@@ -81,1 +81,1 @@\n-        Exception originalException, String msgID, Object exArgs[]\n+        Exception originalException, String msgID, Object[] exArgs\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/exceptions\/AlgorithmAlreadyRegisteredException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    public Base64DecodingException(String msgID, Object exArgs[]) {\n+    public Base64DecodingException(String msgID, Object[] exArgs) {\n@@ -82,1 +82,1 @@\n-    public Base64DecodingException(Exception originalException, String msgID, Object exArgs[]) {\n+    public Base64DecodingException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/exceptions\/Base64DecodingException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- *    Object exArgs[] = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n+ *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n@@ -52,1 +52,1 @@\n- *    Object exArgs[] = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n+ *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/exceptions\/XMLSecurityException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- *    Object exArgs[] = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n+ *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n@@ -53,1 +53,1 @@\n- *    Object exArgs[] = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n+ *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n@@ -95,1 +95,1 @@\n-    public XMLSecurityRuntimeException(String msgID, Object exArgs[]) {\n+    public XMLSecurityRuntimeException(String msgID, Object[] exArgs) {\n@@ -133,1 +133,1 @@\n-    public XMLSecurityRuntimeException(String msgID, Object exArgs[], Exception originalException) {\n+    public XMLSecurityRuntimeException(String msgID, Object[] exArgs, Exception originalException) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/exceptions\/XMLSecurityRuntimeException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.keys;\n-\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-\n-public class ContentHandlerAlreadyRegisteredException extends XMLSecurityException {\n-\n-    \/**\n-     *\n-     *\/\n-    private static final long serialVersionUID = 1L;\n-\n-    \/**\n-     * Constructor ContentHandlerAlreadyRegisteredException\n-     *\n-     *\/\n-    public ContentHandlerAlreadyRegisteredException() {\n-        super();\n-    }\n-\n-    \/**\n-     * Constructor ContentHandlerAlreadyRegisteredException\n-     *\n-     * @param msgID\n-     *\/\n-    public ContentHandlerAlreadyRegisteredException(String msgID) {\n-        super(msgID);\n-    }\n-\n-    \/**\n-     * Constructor ContentHandlerAlreadyRegisteredException\n-     *\n-     * @param msgID\n-     * @param exArgs\n-     *\/\n-    public ContentHandlerAlreadyRegisteredException(String msgID, Object exArgs[]) {\n-        super(msgID, exArgs);\n-    }\n-\n-    \/**\n-     * Constructor ContentHandlerAlreadyRegisteredException\n-     *\n-     * @param originalException\n-     * @param msgID\n-     *\/\n-    public ContentHandlerAlreadyRegisteredException(Exception originalException, String msgID) {\n-        super(originalException, msgID);\n-    }\n-\n-    @Deprecated\n-    public ContentHandlerAlreadyRegisteredException(String msgID, Exception originalException) {\n-        this(originalException, msgID);\n-    }\n-\n-    \/**\n-     * Constructor ContentHandlerAlreadyRegisteredException\n-     *\n-     * @param originalException\n-     * @param msgID\n-     * @param exArgs\n-     *\/\n-    public ContentHandlerAlreadyRegisteredException(\n-        Exception originalException, String msgID, Object exArgs[]\n-    ) {\n-        super(originalException, msgID, exArgs);\n-    }\n-\n-    @Deprecated\n-    public ContentHandlerAlreadyRegisteredException(String msgID, Object[] exArgs, Exception originalException) {\n-        this(originalException, msgID, exArgs);\n-    }\n-\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/ContentHandlerAlreadyRegisteredException.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -813,1 +813,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -821,1 +820,1 @@\n-                                (Element) currentChild, uri, storage\n+                                (Element) currentChild, uri, storage, secureValidation\n@@ -844,1 +843,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -852,1 +850,1 @@\n-                                (Element) currentChild, uri, storage\n+                                (Element) currentChild, uri, storage, secureValidation\n@@ -914,1 +912,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -932,1 +929,1 @@\n-                            (Element) currentChild, uri, storage\n+                            (Element) currentChild, uri, storage, secureValidation\n@@ -960,1 +957,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -1007,1 +1003,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -1016,1 +1011,1 @@\n-                                (Element) currentChild, uri, storage\n+                                (Element) currentChild, uri, storage, secureValidation\n@@ -1040,1 +1035,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -1048,1 +1042,1 @@\n-                                (Element) currentChild, uri, storage\n+                                (Element) currentChild, uri, storage, secureValidation\n@@ -1097,1 +1091,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -1107,1 +1100,1 @@\n-                            (Element) currentChild, uri, null\n+                            (Element) currentChild, uri, null, secureValidation\n@@ -1129,1 +1122,0 @@\n-            keyResolver.setSecureValidation(secureValidation);\n@@ -1138,1 +1130,1 @@\n-                            (Element) currentChild, uri, null\n+                            (Element) currentChild, uri, null, secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/KeyInfo.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.keys;\n-\n-import java.io.PrintStream;\n-import java.security.PublicKey;\n-\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-import com.sun.org.apache.xml.internal.security.keys.content.KeyName;\n-import com.sun.org.apache.xml.internal.security.keys.content.KeyValue;\n-import com.sun.org.apache.xml.internal.security.keys.content.MgmtData;\n-import com.sun.org.apache.xml.internal.security.keys.content.X509Data;\n-\n-\/**\n- * Utility class for {@code com.sun.org.apache.xml.internal.security.keys} package.\n- *\n- *\/\n-public final class KeyUtils {\n-\n-    private KeyUtils() {\n-        \/\/ no instantiation\n-    }\n-\n-    \/**\n-     * Method prinoutKeyInfo\n-     *\n-     * @param ki\n-     * @param os\n-     * @throws XMLSecurityException\n-     *\/\n-    public static void prinoutKeyInfo(KeyInfo ki, PrintStream os)\n-        throws XMLSecurityException {\n-\n-        for (int i = 0; i < ki.lengthKeyName(); i++) {\n-            KeyName x = ki.itemKeyName(i);\n-\n-            os.println(\"KeyName(\" + i + \")=\\\"\" + x.getKeyName() + \"\\\"\");\n-        }\n-\n-        for (int i = 0; i < ki.lengthKeyValue(); i++) {\n-            KeyValue x = ki.itemKeyValue(i);\n-            PublicKey pk = x.getPublicKey();\n-\n-            os.println(\"KeyValue Nr. \" + i);\n-            os.println(pk);\n-        }\n-\n-        for (int i = 0; i < ki.lengthMgmtData(); i++) {\n-            MgmtData x = ki.itemMgmtData(i);\n-\n-            os.println(\"MgmtData(\" + i + \")=\\\"\" + x.getMgmtData() + \"\\\"\");\n-        }\n-\n-        for (int i = 0; i < ki.lengthX509Data(); i++) {\n-            X509Data x = ki.itemX509Data(i);\n-\n-            os.println(\"X509Data(\" + i + \")=\\\"\" + (x.containsCertificate()\n-                ? \"Certificate \" : \"\") + (x.containsIssuerSerial()\n-                ? \"IssuerSerial \" : \"\") + \"\\\"\");\n-        }\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/KeyUtils.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -44,1 +44,1 @@\n-    private static final String supportedKeyTypes[] = { \"RSA\", \"DSA\", \"EC\"};\n+    private static final String[] supportedKeyTypes = { \"RSA\", \"DSA\", \"EC\"};\n@@ -123,3 +123,1 @@\n-            } catch (NoSuchAlgorithmException e) { \/\/NOPMD\n-                \/\/ Do nothing, try the next type\n-            } catch (InvalidKeySpecException e) { \/\/NOPMD\n+            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) { \/\/NOPMD\n@@ -143,5 +141,2 @@\n-        } catch (NoSuchAlgorithmException e) {\n-            Object exArgs[] = { publicKey.getAlgorithm(), publicKey.getFormat(), publicKey.getClass().getName() };\n-            throw new XMLSecurityException(e, \"DEREncodedKeyValue.UnsupportedPublicKey\", exArgs);\n-        } catch (InvalidKeySpecException e) {\n-            Object exArgs[] = { publicKey.getAlgorithm(), publicKey.getFormat(), publicKey.getClass().getName() };\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            Object[] exArgs = { publicKey.getAlgorithm(), publicKey.getFormat(), publicKey.getClass().getName() };\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/DEREncodedKeyValue.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-            Object exArgs[] = { \"Elements\", Constants._TAG_X509DATA };\n+            Object[] exArgs = { \"Elements\", Constants._TAG_X509DATA };\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/X509Data.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            Object exArgs[] = { Constants._TAG_DSAKEYVALUE, key.getClass().getName() };\n+            Object[] exArgs = { Constants._TAG_DSAKEYVALUE, key.getClass().getName() };\n@@ -118,1 +118,0 @@\n-            PublicKey pk = dsaFactory.generatePublic(pkspec);\n@@ -120,4 +119,2 @@\n-            return pk;\n-        } catch (NoSuchAlgorithmException ex) {\n-            throw new XMLSecurityException(ex);\n-        } catch (InvalidKeySpecException ex) {\n+            return dsaFactory.generatePublic(pkspec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException ex) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/keyvalues\/DSAKeyValue.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-                if (uri.startsWith(\"urn:oid:\")) {\n+                if (uri != null && uri.startsWith(\"urn:oid:\")) {\n@@ -207,5 +207,1 @@\n-        } catch (NoSuchAlgorithmException ex) {\n-            throw new XMLSecurityException(ex);\n-        } catch (InvalidKeySpecException ex) {\n-            throw new XMLSecurityException(ex);\n-        } catch (MarshalException ex) {\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException | MarshalException ex) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/keyvalues\/ECKeyValue.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-            Object exArgs[] = { Constants._TAG_RSAKEYVALUE, key.getClass().getName() };\n+            Object[] exArgs = { Constants._TAG_RSAKEYVALUE, key.getClass().getName() };\n@@ -112,3 +112,1 @@\n-        } catch (NoSuchAlgorithmException ex) {\n-            throw new XMLSecurityException(ex);\n-        } catch (InvalidKeySpecException ex) {\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException ex) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/keyvalues\/RSAKeyValue.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-        byte certbytes[] = this.getCertificateBytes();\n+        byte[] certbytes = this.getCertificateBytes();\n@@ -107,8 +107,1 @@\n-            X509Certificate cert =\n-                (X509Certificate) certFact.generateCertificate(is);\n-\n-            if (cert != null) {\n-                return cert;\n-            }\n-\n-            return null;\n+            return (X509Certificate) certFact.generateCertificate(is);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/x509\/XMLX509Certificate.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                Object exArgs[] = { algorithmURI };\n-                throw new XMLSecurityException(\"XMLX509Digest.UnknownDigestAlgorithm\", exArgs);\n+            Object[] exArgs = {algorithmURI};\n+            throw new XMLSecurityException(\"XMLX509Digest.UnknownDigestAlgorithm\", exArgs);\n@@ -125,6 +125,6 @@\n-                        MessageDigest md = MessageDigest.getInstance(jcaDigestAlgorithm);\n-                        return md.digest(cert.getEncoded());\n-                } catch (Exception e) {\n-                Object exArgs[] = { jcaDigestAlgorithm };\n-                        throw new XMLSecurityException(\"XMLX509Digest.FailedDigest\", exArgs);\n-                }\n+            MessageDigest md = MessageDigest.getInstance(jcaDigestAlgorithm);\n+            return md.digest(cert.getEncoded());\n+        } catch (Exception e) {\n+            Object[] exArgs = {jcaDigestAlgorithm};\n+            throw new XMLSecurityException(\"XMLX509Digest.FailedDigest\", exArgs);\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/x509\/XMLX509Digest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-            Object exArgs[] = { cert.getVersion() };\n+            Object[] exArgs = { cert.getVersion() };\n@@ -136,1 +136,1 @@\n-        byte skidValue[] = new byte[extensionValue.length - 4];\n+        byte[] skidValue = new byte[extensionValue.length - 4];\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/content\/x509\/XMLX509SKI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.keys.keyresolver;\n-\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-\n-public class InvalidKeyResolverException extends XMLSecurityException {\n-\n-    \/**\n-     *\n-     *\/\n-    private static final long serialVersionUID = 1L;\n-\n-    \/**\n-     * Constructor InvalidKeyResolverException\n-     *\n-     *\/\n-    public InvalidKeyResolverException() {\n-        super();\n-    }\n-\n-    \/**\n-     * Constructor InvalidKeyResolverException\n-     *\n-     * @param msgID\n-     *\/\n-    public InvalidKeyResolverException(String msgID) {\n-        super(msgID);\n-    }\n-\n-    \/**\n-     * Constructor InvalidKeyResolverException\n-     *\n-     * @param msgID\n-     * @param exArgs\n-     *\/\n-    public InvalidKeyResolverException(String msgID, Object exArgs[]) {\n-        super(msgID, exArgs);\n-    }\n-\n-    \/**\n-     * Constructor InvalidKeyResolverException\n-     *\n-     * @param originalException\n-     * @param msgID\n-     *\/\n-    public InvalidKeyResolverException(Exception originalException, String msgID) {\n-        super(originalException, msgID);\n-    }\n-\n-    @Deprecated\n-    public InvalidKeyResolverException(String msgID, Exception originalException) {\n-        this(originalException, msgID);\n-    }\n-\n-    \/**\n-     * Constructor InvalidKeyResolverException\n-     *\n-     * @param originalException\n-     * @param msgID\n-     * @param exArgs\n-     *\/\n-    public InvalidKeyResolverException(Exception originalException, String msgID, Object exArgs[]) {\n-        super(originalException, msgID, exArgs);\n-    }\n-\n-    @Deprecated\n-    public InvalidKeyResolverException(String msgID, Object[] exArgs, Exception originalException) {\n-        this(originalException, msgID, exArgs);\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/InvalidKeyResolverException.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -31,0 +32,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -32,1 +34,2 @@\n-import javax.crypto.SecretKey;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n@@ -47,2 +50,0 @@\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n@@ -59,5 +60,1 @@\n-    \/** Field resolverVector *\/\n-    private static List<KeyResolver> resolverVector = new CopyOnWriteArrayList<KeyResolver>();\n-\n-    \/** Field resolverSpi *\/\n-    private final KeyResolverSpi resolverSpi;\n+    private static List<KeyResolverSpi> resolverList = new CopyOnWriteArrayList<>();\n@@ -65,8 +62,1 @@\n-    \/**\n-     * Constructor.\n-     *\n-     * @param keyResolverSpi a KeyResolverSpi instance\n-     *\/\n-    private KeyResolver(KeyResolverSpi keyResolverSpi) {\n-        resolverSpi = keyResolverSpi;\n-    }\n+    private static final AtomicBoolean defaultResolversAdded = new AtomicBoolean();\n@@ -80,1 +70,1 @@\n-        return resolverVector.size();\n+        return resolverList.size();\n@@ -89,0 +79,1 @@\n+     * @param secureValidation\n@@ -94,1 +85,1 @@\n-        Element element, String baseURI, StorageResolver storage\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -96,1 +87,1 @@\n-        for (KeyResolver resolver : resolverVector) {\n+        for (KeyResolverSpi resolver : resolverList) {\n@@ -98,4 +89,4 @@\n-                Object exArgs[] = {\n-                                   element != null\n-                                       && element.getNodeType() == Node.ELEMENT_NODE\n-                                       ? element.getTagName() : \"null\"\n+                Object[] exArgs = {\n+                        element != null\n+                                && element.getNodeType() == Node.ELEMENT_NODE\n+                                ? element.getTagName() : \"null\"\n@@ -108,1 +99,1 @@\n-            X509Certificate cert = resolver.resolveX509Certificate(element, baseURI, storage);\n+            X509Certificate cert = resolver.engineLookupResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -114,4 +105,4 @@\n-        Object exArgs[] = {\n-                           element != null && element.getNodeType() == Node.ELEMENT_NODE\n-                           ? element.getTagName() : \"null\"\n-                          };\n+        Object[] exArgs = {\n+                element != null && element.getNodeType() == Node.ELEMENT_NODE\n+                        ? element.getTagName() : \"null\"\n+        };\n@@ -128,0 +119,1 @@\n+     * @param secureValidation\n@@ -133,1 +125,1 @@\n-        Element element, String baseURI, StorageResolver storage\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -135,1 +127,1 @@\n-        for (KeyResolver resolver : resolverVector) {\n+        for (KeyResolverSpi resolver : resolverList) {\n@@ -137,4 +129,4 @@\n-                Object exArgs[] = {\n-                                   element != null\n-                                       && element.getNodeType() == Node.ELEMENT_NODE\n-                                       ? element.getTagName() : \"null\"\n+                Object[] exArgs = {\n+                        element != null\n+                                && element.getNodeType() == Node.ELEMENT_NODE\n+                                ? element.getTagName() : \"null\"\n@@ -147,1 +139,1 @@\n-            PublicKey cert = resolver.resolvePublicKey(element, baseURI, storage);\n+            PublicKey cert = resolver.engineLookupAndResolvePublicKey(element, baseURI, storage, secureValidation);\n@@ -153,4 +145,4 @@\n-        Object exArgs[] = {\n-                           element != null && element.getNodeType() == Node.ELEMENT_NODE\n-                           ? element.getTagName() : \"null\"\n-                          };\n+        Object[] exArgs = {\n+                element != null && element.getNodeType() == Node.ELEMENT_NODE\n+                        ? element.getTagName() : \"null\"\n+        };\n@@ -171,1 +163,0 @@\n-     * @param globalResolver Whether the KeyResolverSpi is a global resolver or not\n@@ -178,2 +169,3 @@\n-    public static void register(String className, boolean globalResolver)\n-        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n+    public static void register(String className) throws\n+            ClassNotFoundException, IllegalAccessException,\n+            InstantiationException, InvocationTargetException {\n@@ -181,1 +173,0 @@\n-        @SuppressWarnings(\"deprecation\")\n@@ -183,2 +174,1 @@\n-            (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();\n-        keyResolverSpi.setGlobalResolver(globalResolver);\n+            (KeyResolverSpi) JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n@@ -198,1 +188,0 @@\n-     * @param globalResolver Whether the KeyResolverSpi is a global resolver or not\n@@ -202,1 +191,1 @@\n-    public static void registerAtStart(String className, boolean globalResolver) {\n+    public static void registerAtStart(String className) {\n@@ -207,4 +196,2 @@\n-            @SuppressWarnings(\"deprecation\")\n-            KeyResolverSpi tmp = (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();\n-            keyResolverSpi = tmp;\n-            keyResolverSpi.setGlobalResolver(globalResolver);\n+            keyResolverSpi = (KeyResolverSpi) JavaUtils.newInstanceWithEmptyConstructor(\n+                    ClassLoaderUtils.loadClass(className, KeyResolver.class));\n@@ -212,5 +199,1 @@\n-        } catch (ClassNotFoundException e) {\n-            ex = e;\n-        } catch (IllegalAccessException e) {\n-            ex = e;\n-        } catch (InstantiationException e) {\n+        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\n@@ -222,1 +205,1 @@\n-            IllegalArgumentException(\"Invalid KeyResolver class name\").initCause(ex);\n+                    IllegalArgumentException(\"Invalid KeyResolver class name\").initCause(ex);\n@@ -245,1 +228,0 @@\n-        KeyResolver resolver = new KeyResolver(keyResolverSpi);\n@@ -247,1 +229,1 @@\n-            resolverVector.add(0, resolver);\n+            resolverList.add(0, keyResolverSpi);\n@@ -249,1 +231,1 @@\n-            resolverVector.add(resolver);\n+            resolverList.add(keyResolverSpi);\n@@ -270,1 +252,1 @@\n-        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n+        throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n@@ -272,1 +254,1 @@\n-        List<KeyResolver> keyResolverList = new ArrayList<>(classNames.size());\n+        List<KeyResolverSpi> keyResolverList = new ArrayList<>(classNames.size());\n@@ -274,5 +256,3 @@\n-            @SuppressWarnings(\"deprecation\")\n-            KeyResolverSpi keyResolverSpi =\n-                (KeyResolverSpi)ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();\n-            keyResolverSpi.setGlobalResolver(false);\n-            keyResolverList.add(new KeyResolver(keyResolverSpi));\n+            KeyResolverSpi keyResolverSpi = (KeyResolverSpi)JavaUtils\n+                    .newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n+            keyResolverList.add(keyResolverSpi);\n@@ -280,1 +260,1 @@\n-        resolverVector.addAll(keyResolverList);\n+        resolverList.addAll(keyResolverList);\n@@ -287,101 +267,17 @@\n-\n-        List<KeyResolver> keyResolverList = new ArrayList<>();\n-        keyResolverList.add(new KeyResolver(new RSAKeyValueResolver()));\n-        keyResolverList.add(new KeyResolver(new DSAKeyValueResolver()));\n-        keyResolverList.add(new KeyResolver(new X509CertificateResolver()));\n-        keyResolverList.add(new KeyResolver(new X509SKIResolver()));\n-        keyResolverList.add(new KeyResolver(new RetrievalMethodResolver()));\n-        keyResolverList.add(new KeyResolver(new X509SubjectNameResolver()));\n-        keyResolverList.add(new KeyResolver(new X509IssuerSerialResolver()));\n-        keyResolverList.add(new KeyResolver(new DEREncodedKeyValueResolver()));\n-        keyResolverList.add(new KeyResolver(new KeyInfoReferenceResolver()));\n-        keyResolverList.add(new KeyResolver(new X509DigestResolver()));\n-        keyResolverList.add(new KeyResolver(new ECKeyValueResolver()));\n-\n-        resolverVector.addAll(keyResolverList);\n-    }\n-\n-    \/**\n-     * Method resolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved public key from the registered from the elements\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey resolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n-        return resolverSpi.engineLookupAndResolvePublicKey(element, baseURI, storage);\n-    }\n-\n-    \/**\n-     * Method resolveX509Certificate\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved X509certificate key from the registered from the elements\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate resolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n-        return resolverSpi.engineLookupResolveX509Certificate(element, baseURI, storage);\n-    }\n-\n-    \/**\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved SecretKey key from the registered from the elements\n-     * @throws KeyResolverException\n-     *\/\n-    public SecretKey resolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n-        return resolverSpi.engineLookupAndResolveSecretKey(element, baseURI, storage);\n-    }\n-\n-    \/**\n-     * Method setProperty\n-     *\n-     * @param key\n-     * @param value\n-     *\/\n-    public void setProperty(String key, String value) {\n-        resolverSpi.engineSetProperty(key, value);\n-    }\n-\n-    \/**\n-     * Method getProperty\n-     *\n-     * @param key\n-     * @return the property set for this resolver\n-     *\/\n-    public String getProperty(String key) {\n-        return resolverSpi.engineGetProperty(key);\n-    }\n-\n-\n-    \/**\n-     * Method understandsProperty\n-     *\n-     * @param propertyToTest\n-     * @return true if the resolver understands property propertyToTest\n-     *\/\n-    public boolean understandsProperty(String propertyToTest) {\n-        return resolverSpi.understandsProperty(propertyToTest);\n-    }\n-\n-\n-    \/**\n-     * Method resolverClassName\n-     *\n-     * @return the name of the resolver.\n-     *\/\n-    public String resolverClassName() {\n-        return resolverSpi.getClass().getName();\n+        \/\/ Add a guard so that we don't repeatedly add the default resolvers\n+        if (defaultResolversAdded.compareAndSet(false, true)) {\n+            List<KeyResolverSpi> keyResolverList = new ArrayList<>();\n+            keyResolverList.add(new RSAKeyValueResolver());\n+            keyResolverList.add(new DSAKeyValueResolver());\n+            keyResolverList.add(new X509CertificateResolver());\n+            keyResolverList.add(new X509SKIResolver());\n+            keyResolverList.add(new RetrievalMethodResolver());\n+            keyResolverList.add(new X509SubjectNameResolver());\n+            keyResolverList.add(new X509IssuerSerialResolver());\n+            keyResolverList.add(new DEREncodedKeyValueResolver());\n+            keyResolverList.add(new KeyInfoReferenceResolver());\n+            keyResolverList.add(new X509DigestResolver());\n+            keyResolverList.add(new ECKeyValueResolver());\n+\n+            resolverList.addAll(keyResolverList);\n+        }\n@@ -394,2 +290,2 @@\n-        List<KeyResolver> res;\n-        Iterator<KeyResolver> it;\n+        private List<KeyResolverSpi> res;\n+        private Iterator<KeyResolverSpi> it;\n@@ -397,1 +293,1 @@\n-        public ResolverIterator(List<KeyResolver> list) {\n+        public ResolverIterator(List<KeyResolverSpi> list) {\n@@ -407,1 +303,1 @@\n-            KeyResolver resolver = it.next();\n+            KeyResolverSpi resolver = it.next();\n@@ -412,1 +308,1 @@\n-            return resolver.resolverSpi;\n+            return resolver;\n@@ -421,1 +317,1 @@\n-        return new ResolverIterator(resolverVector);\n+        return new ResolverIterator(resolverList);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/KeyResolver.java","additions":71,"deletions":175,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    public KeyResolverException(String msgID, Object exArgs[]) {\n+    public KeyResolverException(String msgID, Object[] exArgs) {\n@@ -87,1 +87,1 @@\n-    public KeyResolverException(Exception originalException, String msgID, Object exArgs[]) {\n+    public KeyResolverException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/KeyResolverException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.HashMap;\n@@ -34,1 +33,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -37,0 +35,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -40,1 +39,0 @@\n-import org.xml.sax.SAXException;\n@@ -43,1 +41,1 @@\n- * This class is an abstract class for a child KeyInfo Element.\n+ * This class is an abstract class to resolve a Key of some kind given a KeyInfo element.\n@@ -51,0 +49,2 @@\n+ *\n+ * Extensions of this class must be thread-safe.\n@@ -54,14 +54,0 @@\n-    \/** Field properties *\/\n-    protected java.util.Map<String, String> properties;\n-\n-    protected boolean globalResolver = false;\n-\n-    protected boolean secureValidation;\n-\n-    \/**\n-     * Set whether secure validation is enabled or not. The default is false.\n-     *\/\n-    public void setSecureValidation(boolean secureValidation) {\n-        this.secureValidation = secureValidation;\n-    }\n-\n@@ -76,3 +62,1 @@\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n-        throw new UnsupportedOperationException();\n-    }\n+    protected abstract boolean engineCanResolve(Element element, String baseURI, StorageResolver storage);\n@@ -86,0 +70,1 @@\n+     * @param secureValidation\n@@ -90,5 +75,3 @@\n-    public PublicKey engineResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n-        throw new UnsupportedOperationException();\n-    }\n+    protected abstract PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) throws KeyResolverException;\n@@ -102,0 +85,1 @@\n+     * @param secureValidation\n@@ -107,1 +91,1 @@\n-        Element element, String baseURI, StorageResolver storage\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -109,2 +93,1 @@\n-        KeyResolverSpi tmp = cloneIfNeeded();\n-        if (!tmp.engineCanResolve(element, baseURI, storage)) {\n+        if (!engineCanResolve(element, baseURI, storage)) {\n@@ -113,16 +96,1 @@\n-        return tmp.engineResolvePublicKey(element, baseURI, storage);\n-    }\n-\n-    private KeyResolverSpi cloneIfNeeded() throws KeyResolverException {\n-        if (globalResolver) {\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                KeyResolverSpi tmp = getClass().newInstance();\n-                return tmp;\n-            } catch (InstantiationException e) {\n-                throw new KeyResolverException(e, \"\");\n-            } catch (IllegalAccessException e) {\n-                throw new KeyResolverException(e, \"\");\n-            }\n-        }\n-        return this;\n+        return engineResolvePublicKey(element, baseURI, storage, secureValidation);\n@@ -137,0 +105,1 @@\n+     * @param secureValidation\n@@ -141,5 +110,3 @@\n-    public X509Certificate engineResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException{\n-        throw new UnsupportedOperationException();\n-    }\n+    protected abstract X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) throws KeyResolverException;\n@@ -153,0 +120,1 @@\n+     * @param secureValidation\n@@ -158,1 +126,1 @@\n-        Element element, String baseURI, StorageResolver storage\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -160,2 +128,1 @@\n-        KeyResolverSpi tmp = cloneIfNeeded();\n-        if (!tmp.engineCanResolve(element, baseURI, storage)) {\n+        if (!engineCanResolve(element, baseURI, storage)) {\n@@ -164,1 +131,1 @@\n-        return tmp.engineResolveX509Certificate(element, baseURI, storage);\n+        return engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -173,0 +140,1 @@\n+     * @param secureValidation\n@@ -177,5 +145,3 @@\n-    public SecretKey engineResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException{\n-        throw new UnsupportedOperationException();\n-    }\n+    protected abstract SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) throws KeyResolverException;\n@@ -189,0 +155,1 @@\n+     * @param secureValidation\n@@ -194,1 +161,1 @@\n-        Element element, String baseURI, StorageResolver storage\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -196,2 +163,1 @@\n-        KeyResolverSpi tmp = cloneIfNeeded();\n-        if (!tmp.engineCanResolve(element, baseURI, storage)) {\n+        if (!engineCanResolve(element, baseURI, storage)) {\n@@ -200,1 +166,1 @@\n-        return tmp.engineResolveSecretKey(element, baseURI, storage);\n+        return engineResolveSecretKey(element, baseURI, storage, secureValidation);\n@@ -204,1 +170,1 @@\n-     * Method engineLookupAndResolvePrivateKey\n+     * Method engineResolvePrivateKey\n@@ -209,0 +175,1 @@\n+     * @param secureValidation\n@@ -213,10 +180,3 @@\n-    public PrivateKey engineLookupAndResolvePrivateKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n-        \/\/ This method was added later, it has no equivalent\n-        \/\/ engineResolvePrivateKey() in the old API.\n-        \/\/ We cannot throw UnsupportedOperationException because\n-        \/\/ KeyResolverSpi implementations who don't know about\n-        \/\/ this method would stop the search too early.\n-        return null;\n-    }\n+    protected abstract PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) throws KeyResolverException;\n@@ -225,1 +185,1 @@\n-     * Method engineSetProperty\n+     * Method engineLookupAndResolvePrivateKey\n@@ -227,12 +187,5 @@\n-     * @param key\n-     * @param value\n-     *\/\n-    public void engineSetProperty(String key, String value) {\n-        if (properties == null) {\n-            properties = new HashMap<>();\n-        }\n-        properties.put(key, value);\n-    }\n-\n-    \/**\n-     * Method engineGetProperty\n+     * @param element\n+     * @param baseURI\n+     * @param storage\n+     * @param secureValidation\n+     * @return resolved PrivateKey key from the registered from the elements\n@@ -240,2 +193,1 @@\n-     * @param key\n-     * @return obtain the property appointed by key\n+     * @throws KeyResolverException\n@@ -243,2 +195,4 @@\n-    public String engineGetProperty(String key) {\n-        if (properties == null) {\n+    public PrivateKey engineLookupAndResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) throws KeyResolverException {\n+        if (!engineCanResolve(element, baseURI, storage)) {\n@@ -247,20 +201,1 @@\n-\n-        return properties.get(key);\n-    }\n-\n-    \/**\n-     * Method understandsProperty\n-     *\n-     * @param propertyToTest\n-     * @return true if understood the property\n-     *\/\n-    public boolean understandsProperty(String propertyToTest) {\n-        if (properties == null) {\n-            return false;\n-        }\n-\n-        return properties.get(propertyToTest) != null;\n-    }\n-\n-    public void setGlobalResolver(boolean globalResolver) {\n-        this.globalResolver = globalResolver;\n+        return engineResolvePrivateKey(element, baseURI, storage, secureValidation);\n@@ -269,1 +204,0 @@\n-\n@@ -281,1 +215,1 @@\n-        } catch (SAXException ex) {\n+        } catch (XMLParserException ex) {\n@@ -285,2 +219,0 @@\n-        } catch (ParserConfigurationException ex) {\n-            throw new KeyResolverException(ex);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/KeyResolverSpi.java","additions":47,"deletions":115,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -50,2 +50,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n@@ -55,2 +56,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public PublicKey engineLookupAndResolvePublicKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -58,7 +60,0 @@\n-\n-        LOG.debug(\"Can I resolve {}\", element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -75,2 +70,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public X509Certificate engineLookupResolveX509Certificate(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -81,2 +77,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public SecretKey engineLookupAndResolveSecretKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -87,2 +84,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public PrivateKey engineLookupAndResolvePrivateKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    public PrivateKey engineLookupAndResolvePrivateKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -93,1 +91,7 @@\n-\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/DEREncodedKeyValueResolver.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -41,0 +42,6 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYVALUE)\n+            || XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_DSAKEYVALUE);\n+    }\n@@ -42,10 +49,4 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -87,2 +88,11 @@\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -94,2 +104,3 @@\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/DSAKeyValueResolver.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -41,0 +42,6 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYVALUE)\n+            || XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_ECKEYVALUE);\n+    }\n@@ -42,10 +49,4 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -85,2 +86,11 @@\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -92,2 +102,3 @@\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/ECKeyValueResolver.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverContext;\n@@ -59,2 +60,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n@@ -64,2 +66,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public PublicKey engineLookupAndResolvePublicKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -67,7 +70,0 @@\n-\n-        LOG.debug(\"Can I resolve {}\", element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -75,1 +71,1 @@\n-            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage);\n+            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage, secureValidation);\n@@ -86,2 +82,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public X509Certificate engineLookupResolveX509Certificate(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -89,7 +86,0 @@\n-\n-        LOG.debug(\"Can I resolve {}\", element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -97,1 +87,1 @@\n-            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage);\n+            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage, secureValidation);\n@@ -108,2 +98,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public SecretKey engineLookupAndResolveSecretKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -112,6 +103,0 @@\n-        LOG.debug(\"Can I resolve {}\", element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -119,1 +104,1 @@\n-            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage);\n+            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage, secureValidation);\n@@ -130,2 +115,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public PrivateKey engineLookupAndResolvePrivateKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    public PrivateKey engineResolvePrivateKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -134,6 +120,0 @@\n-        LOG.debug(\"Can I resolve \" + element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -141,1 +121,1 @@\n-            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage);\n+            KeyInfo referent = resolveReferentKeyInfo(element, baseURI, storage, secureValidation);\n@@ -158,0 +138,1 @@\n+     * @param secureValidation\n@@ -161,1 +142,2 @@\n-    private KeyInfo resolveReferentKeyInfo(Element element, String baseURI, StorageResolver storage) throws XMLSecurityException {\n+    private KeyInfo resolveReferentKeyInfo(Element element, String baseURI,\n+                                           StorageResolver storage, boolean secureValidation) throws XMLSecurityException {\n@@ -169,1 +151,1 @@\n-            referentElement = obtainReferenceElement(resource);\n+            referentElement = obtainReferenceElement(resource, secureValidation);\n@@ -180,1 +162,1 @@\n-        validateReference(referentElement);\n+        validateReference(referentElement, secureValidation);\n@@ -191,0 +173,1 @@\n+     * @param secureValidation\n@@ -194,1 +177,1 @@\n-    private void validateReference(Element referentElement) throws XMLSecurityException {\n+    private void validateReference(Element referentElement, boolean secureValidation) throws XMLSecurityException {\n@@ -196,1 +179,1 @@\n-            Object exArgs[] = { new QName(referentElement.getNamespaceURI(), referentElement.getLocalName()) };\n+            Object[] exArgs = { new QName(referentElement.getNamespaceURI(), referentElement.getLocalName()) };\n@@ -225,2 +208,2 @@\n-        ResourceResolver resRes = ResourceResolver.getInstance(uri, baseURI, secureValidation);\n-        return resRes.resolve(uri, baseURI, secureValidation);\n+        ResourceResolverContext resContext = new ResourceResolverContext(uri, baseURI, secureValidation);\n+        return ResourceResolver.resolve(resContext);\n@@ -233,0 +216,1 @@\n+     * @param secureValidation\n@@ -240,1 +224,1 @@\n-    private Element obtainReferenceElement(XMLSignatureInput resource)\n+    private Element obtainReferenceElement(XMLSignatureInput resource, boolean secureValidation)\n@@ -245,1 +229,1 @@\n-        if (resource.isElement()){\n+        if (resource.isElement()) {\n@@ -252,2 +236,2 @@\n-            byte inputBytes[] = resource.getBytes();\n-            e = getDocFromBytes(inputBytes, this.secureValidation);\n+            byte[] inputBytes = resource.getBytes();\n+            e = getDocFromBytes(inputBytes, secureValidation);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/KeyInfoReferenceResolver.java","additions":35,"deletions":51,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-    private KeyStore keyStore;\n-    private char[] password;\n+    private final KeyStore keyStore;\n+    private final char[] password;\n@@ -70,15 +70,5 @@\n-    \/**\n-     * This method returns whether the KeyResolverSpi is able to perform the requested action.\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return whether the KeyResolverSpi is able to perform the requested action.\n-     *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n-        if (XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)\n-            || XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYNAME)) {\n-            return true;\n-        }\n-\n-        return false;\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)\n+            || XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYNAME);\n@@ -87,11 +77,4 @@\n-    \/**\n-     * Method engineLookupAndResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -102,10 +85,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -116,12 +93,4 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved SecretKey key or null if no {@link SecretKey} could be obtained\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public SecretKey engineResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -132,11 +101,4 @@\n-    \/**\n-     * Method engineResolvePrivateKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved PrivateKey key or null if no {@link PrivateKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PrivateKey engineLookupAndResolvePrivateKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    public PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -144,1 +106,0 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n@@ -165,1 +126,0 @@\n-        LOG.debug(\"I can't\");\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/PrivateKeyResolver.java","additions":23,"deletions":63,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -42,0 +43,6 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYVALUE)\n+            || XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RSAKEYVALUE);\n+    }\n@@ -44,2 +51,3 @@\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -80,2 +88,11 @@\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -87,2 +104,3 @@\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/RSAKeyValueResolver.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.PrivateKey;\n@@ -38,2 +39,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -48,0 +47,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -53,0 +53,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverContext;\n@@ -56,1 +57,0 @@\n-import org.xml.sax.SAXException;\n@@ -73,13 +73,5 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-           Element element, String baseURI, StorageResolver storage\n-    ) {\n-        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RETRIEVALMETHOD)) {\n-            return null;\n-        }\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RETRIEVALMETHOD);\n+    }\n@@ -87,0 +79,5 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+           Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n@@ -99,2 +96,2 @@\n-             }\n-             Element e = obtainReferenceElement(resource, secureValidation);\n+            }\n+            Element e = obtainReferenceElement(resource, secureValidation);\n@@ -102,19 +99,19 @@\n-             \/\/ Check to make sure that the reference is not to another RetrievalMethod\n-             \/\/ which points to this element\n-             if (XMLUtils.elementIsInSignatureSpace(e, Constants._TAG_RETRIEVALMETHOD)) {\n-                 if (secureValidation) {\n-                     if (LOG.isDebugEnabled()) {\n-                         String error = \"Error: It is forbidden to have one RetrievalMethod \"\n-                             + \"point to another with secure validation\";\n-                         LOG.debug(error);\n-                     }\n-                     return null;\n-                 }\n-                 RetrievalMethod rm2 = new RetrievalMethod(e, baseURI);\n-                 XMLSignatureInput resource2 = resolveInput(rm2, baseURI, secureValidation);\n-                 Element e2 = obtainReferenceElement(resource2, secureValidation);\n-                 if (e2 == element) {\n-                     LOG.debug(\"Error: Can't have RetrievalMethods pointing to each other\");\n-                     return null;\n-                 }\n-             }\n+            \/\/ Check to make sure that the reference is not to another RetrievalMethod\n+            \/\/ which points to this element\n+            if (XMLUtils.elementIsInSignatureSpace(e, Constants._TAG_RETRIEVALMETHOD)) {\n+                if (secureValidation) {\n+                    if (LOG.isDebugEnabled()) {\n+                        String error = \"Error: It is forbidden to have one RetrievalMethod \"\n+                                + \"point to another with secure validation\";\n+                        LOG.debug(error);\n+                    }\n+                    return null;\n+                }\n+                RetrievalMethod rm2 = new RetrievalMethod(e, baseURI);\n+                XMLSignatureInput resource2 = resolveInput(rm2, baseURI, secureValidation);\n+                Element e2 = obtainReferenceElement(resource2, secureValidation);\n+                if (e2 == element) {\n+                    LOG.debug(\"Error: Can't have RetrievalMethods pointing to each other\");\n+                    return null;\n+                }\n+            }\n@@ -122,1 +119,1 @@\n-             return resolveKey(e, baseURI, storage);\n+            return resolveKey(e, baseURI, storage, secureValidation);\n@@ -129,4 +126,0 @@\n-         } catch (ParserConfigurationException e) {\n-             LOG.debug(\"ParserConfigurationException\", e);\n-         } catch (SAXException e) {\n-             LOG.debug(\"SAXException\", e);\n@@ -137,13 +130,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage) {\n-        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_RETRIEVALMETHOD)) {\n-             return null;\n-        }\n-\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation) {\n@@ -180,1 +164,1 @@\n-            return resolveCertificate(e, baseURI, storage);\n+            return resolveCertificate(e, baseURI, storage, secureValidation);\n@@ -187,4 +171,0 @@\n-        } catch (ParserConfigurationException e) {\n-            LOG.debug(\"ParserConfigurationException\", e);\n-        } catch (SAXException e) {\n-            LOG.debug(\"SAXException\", e);\n@@ -204,1 +184,1 @@\n-        Element e, String baseURI, StorageResolver storage\n+        Element e, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -206,4 +186,0 @@\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Now we have a {\" + e.getNamespaceURI() + \"}\"\n-                + e.getLocalName() + \" Element\");\n-        }\n@@ -212,1 +188,5 @@\n-            return KeyResolver.getX509Certificate(e, baseURI, storage);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Now we have a {\" + e.getNamespaceURI() + \"}\"\n+                    + e.getLocalName() + \" Element\");\n+            }\n+            return KeyResolver.getX509Certificate(e, baseURI, storage, secureValidation);\n@@ -222,0 +202,1 @@\n+     * @param secureValidation\n@@ -226,1 +207,1 @@\n-        Element e, String baseURI, StorageResolver storage\n+        Element e, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -228,4 +209,0 @@\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Now we have a {\" + e.getNamespaceURI() + \"}\"\n-                + e.getLocalName() + \" Element\");\n-        }\n@@ -234,1 +211,5 @@\n-            return KeyResolver.getPublicKey(e, baseURI, storage);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Now we have a {\" + e.getNamespaceURI() + \"}\"\n+                    + e.getLocalName() + \" Element\");\n+            }\n+            return KeyResolver.getPublicKey(e, baseURI, storage, secureValidation);\n@@ -240,2 +221,1 @@\n-        throws CanonicalizationException, ParserConfigurationException,\n-        IOException, SAXException, KeyResolverException {\n+        throws CanonicalizationException, XMLParserException, IOException, KeyResolverException {\n@@ -243,1 +223,1 @@\n-        if (resource.isElement()){\n+        if (resource.isElement()) {\n@@ -250,1 +230,1 @@\n-            byte inputBytes[] = resource.getBytes();\n+            byte[] inputBytes = resource.getBytes();\n@@ -260,1 +240,1 @@\n-        byte inputBytes[] = resource.getBytes();\n+        byte[] inputBytes = resource.getBytes();\n@@ -280,2 +260,2 @@\n-        ResourceResolver resRes = ResourceResolver.getInstance(uri, baseURI, secureValidation);\n-        XMLSignatureInput resource = resRes.resolve(uri, baseURI, secureValidation);\n+        ResourceResolverContext resContext = new ResourceResolverContext(uri, baseURI, secureValidation);\n+        XMLSignatureInput resource = ResourceResolver.resolve(resContext);\n@@ -289,9 +269,12 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\/\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    public javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/RetrievalMethodResolver.java","additions":71,"deletions":88,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    private KeyStore keyStore;\n-    private char[] password;\n+    private final KeyStore keyStore;\n+    private final char[] password;\n@@ -58,9 +58,3 @@\n-    \/**\n-     * This method returns whether the KeyResolverSpi is able to perform the requested action.\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return whether the KeyResolverSpi is able to perform the requested action.\n-     *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n@@ -70,11 +64,4 @@\n-    \/**\n-     * Method engineLookupAndResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -85,10 +72,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -99,12 +80,4 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved SecretKey key or null if no {@link SecretKey} could be obtained\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public SecretKey engineResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -130,12 +103,5 @@\n-    \/**\n-     * Method engineResolvePrivateKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved PrivateKey key or null if no {@link PrivateKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PrivateKey engineLookupAndResolvePrivateKey(\n-        Element element, String baseURI, StorageResolver storage\n-    ) throws KeyResolverException {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/SecretKeyResolver.java","additions":22,"deletions":56,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-        com.sun.org.slf4j.internal.LoggerFactory.getLogger(SingleKeyResolver.class);\n@@ -43,4 +41,4 @@\n-    private String keyName;\n-    private PublicKey publicKey;\n-    private PrivateKey privateKey;\n-    private SecretKey secretKey;\n+    private final String keyName;\n+    private final PublicKey publicKey;\n+    private final PrivateKey privateKey;\n+    private final SecretKey secretKey;\n@@ -56,0 +54,2 @@\n+        privateKey = null;\n+        secretKey = null;\n@@ -66,0 +66,2 @@\n+        publicKey = null;\n+        secretKey = null;\n@@ -76,0 +78,2 @@\n+        publicKey = null;\n+        privateKey = null;\n@@ -78,9 +82,3 @@\n-    \/**\n-     * This method returns whether the KeyResolverSpi is able to perform the requested action.\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return whether the KeyResolverSpi is able to perform the requested action.\n-     *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n@@ -90,11 +88,4 @@\n-    \/**\n-     * Method engineLookupAndResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -102,4 +93,1 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n-\n-        if (publicKey != null\n-            && XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYNAME)) {\n+        if (publicKey != null) {\n@@ -112,1 +100,0 @@\n-        LOG.debug(\"I can't\");\n@@ -116,10 +103,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -130,12 +111,4 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved SecretKey key or null if no {@link SecretKey} could be obtained\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public SecretKey engineResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -143,4 +116,1 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n-\n-        if (secretKey != null\n-            && XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYNAME)) {\n+        if (secretKey != null) {\n@@ -153,1 +123,0 @@\n-        LOG.debug(\"I can't\");\n@@ -157,11 +126,4 @@\n-    \/**\n-     * Method engineResolvePrivateKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return resolved PrivateKey key or null if no {@link PrivateKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PrivateKey engineLookupAndResolvePrivateKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    public PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -169,1 +131,0 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n@@ -171,2 +132,1 @@\n-        if (privateKey != null\n-            && XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_KEYNAME)) {\n+        if (privateKey != null) {\n@@ -179,1 +139,0 @@\n-        LOG.debug(\"I can't\");\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/SingleKeyResolver.java","additions":32,"deletions":73,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -47,11 +48,10 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        return Constants.SignatureSpecNS.equals(element.getNamespaceURI());\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -61,1 +61,1 @@\n-            this.engineLookupResolveX509Certificate(element, baseURI, storage);\n+            this.engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -70,11 +70,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -90,1 +83,1 @@\n-                    return engineLookupResolveX509Certificate(el, baseURI, storage);\n+                    return engineResolveX509Certificate(el, baseURI, storage, secureValidation);\n@@ -110,9 +103,12 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\/\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/X509CertificateResolver.java","additions":29,"deletions":33,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -53,2 +54,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n@@ -67,2 +69,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public PublicKey engineLookupAndResolvePublicKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -71,1 +74,1 @@\n-        X509Certificate cert = this.engineLookupResolveX509Certificate(element, baseURI, storage);\n+        X509Certificate cert = this.engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -80,2 +83,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public X509Certificate engineLookupResolveX509Certificate(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -84,6 +88,0 @@\n-        LOG.debug(\"Can I resolve {}\", element.getTagName());\n-\n-        if (!engineCanResolve(element, baseURI, storage)) {\n-            return null;\n-        }\n-\n@@ -99,2 +97,3 @@\n-    \/** {{@inheritDoc}}. *\/\n-    public SecretKey engineLookupAndResolveSecretKey(Element element, String baseURI, StorageResolver storage)\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected SecretKey engineResolveSecretKey(Element element, String baseURI, StorageResolver storage, boolean secureValidation)\n@@ -165,1 +164,1 @@\n-            Object exArgs[] = { Constants._TAG_X509DIGEST };\n+            Object[] exArgs = { Constants._TAG_X509DIGEST };\n@@ -172,0 +171,7 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/X509DigestResolver.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -36,1 +37,0 @@\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureException;\n@@ -38,0 +38,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n@@ -45,0 +46,14 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        if (XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)) {\n+            try {\n+                X509Data x509Data = new X509Data(element, baseURI);\n+                return x509Data.containsIssuerSerial();\n+            } catch (XMLSecurityException e) {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n@@ -47,2 +62,3 @@\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -52,1 +68,1 @@\n-            this.engineLookupResolveX509Certificate(element, baseURI, storage);\n+            this.engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -62,2 +78,3 @@\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -65,1 +82,0 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n@@ -70,3 +86,0 @@\n-        } catch (XMLSignatureException ex) {\n-            LOG.debug(\"I can't\");\n-            return null;\n@@ -74,1 +87,0 @@\n-            LOG.debug(\"I can't\");\n@@ -83,1 +95,1 @@\n-                Object exArgs[] = { Constants._TAG_X509ISSUERSERIAL };\n+                Object[] exArgs = { Constants._TAG_X509ISSUERSERIAL };\n@@ -124,2 +136,11 @@\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/X509IssuerSerialResolver.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -46,11 +47,16 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)) {\n+            return false;\n+        }\n+        Element[] x509childNodes =\n+            XMLUtils.selectDsNodes(element.getFirstChild(), Constants._TAG_X509SKI);\n+\n+        return x509childNodes != null && x509childNodes.length > 0;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -60,1 +66,1 @@\n-            this.engineLookupResolveX509Certificate(element, baseURI, storage);\n+            this.engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -69,11 +75,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -81,11 +80,2 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n-        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)) {\n-            LOG.debug(\"I can't\");\n-            return null;\n-        }\n-        \/** Field _x509childObject[] *\/\n-        XMLX509SKI x509childObject[] = null;\n-\n-        Element x509childNodes[] = null;\n-        x509childNodes = XMLUtils.selectDsNodes(element.getFirstChild(), Constants._TAG_X509SKI);\n-\n+        Element[] x509childNodes =\n+            XMLUtils.selectDsNodes(element.getFirstChild(), Constants._TAG_X509SKI);\n@@ -93,1 +83,0 @@\n-            LOG.debug(\"I can't\");\n@@ -96,0 +85,1 @@\n+\n@@ -98,1 +88,1 @@\n-                Object exArgs[] = { Constants._TAG_X509SKI };\n+                Object[] exArgs = { Constants._TAG_X509SKI };\n@@ -107,1 +97,1 @@\n-            x509childObject = new XMLX509SKI[x509childNodes.length];\n+            XMLX509SKI[] x509childObject = new XMLX509SKI[x509childNodes.length];\n@@ -133,10 +123,12 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     *\/\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/X509SKIResolver.java","additions":39,"deletions":47,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.PrivateKey;\n@@ -45,0 +46,8 @@\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected boolean engineCanResolve(Element element, String baseURI, StorageResolver storage) {\n+        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)) {\n+            return false;\n+        }\n+        Element[] x509childNodes =\n+            XMLUtils.selectDsNodes(element.getFirstChild(), Constants._TAG_X509SUBJECTNAME);\n@@ -46,11 +55,7 @@\n-    \/**\n-     * Method engineResolvePublicKey\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     * @return null if no {@link PublicKey} could be obtained\n-     * @throws KeyResolverException\n-     *\/\n-    public PublicKey engineLookupAndResolvePublicKey(\n-        Element element, String baseURI, StorageResolver storage\n+        return x509childNodes != null && x509childNodes.length > 0;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PublicKey engineResolvePublicKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -60,1 +65,1 @@\n-            this.engineLookupResolveX509Certificate(element, baseURI, storage);\n+            this.engineResolveX509Certificate(element, baseURI, storage, secureValidation);\n@@ -69,11 +74,4 @@\n-    \/**\n-     * Method engineResolveX509Certificate\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     * @throws KeyResolverException\n-     *\/\n-    public X509Certificate engineLookupResolveX509Certificate(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected X509Certificate engineResolveX509Certificate(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n@@ -81,9 +79,1 @@\n-        LOG.debug(\"Can I resolve {}?\", element.getTagName());\n-        Element[] x509childNodes = null;\n-        XMLX509SubjectName x509childObject[] = null;\n-\n-        if (!XMLUtils.elementIsInSignatureSpace(element, Constants._TAG_X509DATA)) {\n-            LOG.debug(\"I can't\");\n-            return null;\n-        }\n-        x509childNodes =\n+        Element[] x509childNodes =\n@@ -91,1 +81,0 @@\n-\n@@ -93,1 +82,0 @@\n-            LOG.debug(\"I can't\");\n@@ -99,1 +87,1 @@\n-                Object exArgs[] = { Constants._TAG_X509SUBJECTNAME };\n+                Object[] exArgs = { Constants._TAG_X509SUBJECTNAME };\n@@ -108,1 +96,1 @@\n-            x509childObject = new XMLX509SubjectName[x509childNodes.length];\n+            XMLX509SubjectName[] x509childObject = new XMLX509SubjectName[x509childNodes.length];\n@@ -142,10 +130,12 @@\n-    \/**\n-     * Method engineResolveSecretKey\n-     * {@inheritDoc}\n-     * @param element\n-     * @param baseURI\n-     * @param storage\n-     *\n-     *\/\n-    public javax.crypto.SecretKey engineLookupAndResolveSecretKey(\n-        Element element, String baseURI, StorageResolver storage\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected javax.crypto.SecretKey engineResolveSecretKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n+    ) {\n+        return null;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override\n+    protected PrivateKey engineResolvePrivateKey(\n+        Element element, String baseURI, StorageResolver storage, boolean secureValidation\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/X509SubjectNameResolver.java","additions":36,"deletions":46,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private List<StorageResolverSpi> storageResolvers;\n+    private final List<StorageResolverSpi> storageResolvers = new ArrayList<>();\n@@ -50,0 +50,1 @@\n+     * @param resolver\n@@ -51,1 +52,3 @@\n-    public StorageResolver() {}\n+    public StorageResolver(StorageResolverSpi resolver) {\n+        this.add(resolver);\n+    }\n@@ -56,1 +59,1 @@\n-     * @param resolver\n+     * @param keyStore\n@@ -58,2 +61,2 @@\n-    public StorageResolver(StorageResolverSpi resolver) {\n-        this.add(resolver);\n+    public StorageResolver(KeyStore keyStore) {\n+        this.add(keyStore);\n@@ -63,1 +66,1 @@\n-     * Method addResolver\n+     * Constructor StorageResolver\n@@ -65,1 +68,1 @@\n-     * @param resolver\n+     * @param x509certificate\n@@ -67,5 +70,2 @@\n-    public void add(StorageResolverSpi resolver) {\n-        if (storageResolvers == null) {\n-            storageResolvers = new ArrayList<>();\n-        }\n-        this.storageResolvers.add(resolver);\n+    public StorageResolver(X509Certificate x509certificate) {\n+        this.add(x509certificate);\n@@ -75,1 +75,1 @@\n-     * Constructor StorageResolver\n+     * Method addResolver\n@@ -77,1 +77,1 @@\n-     * @param keyStore\n+     * @param resolver\n@@ -79,2 +79,2 @@\n-    public StorageResolver(KeyStore keyStore) {\n-        this.add(keyStore);\n+    public void add(StorageResolverSpi resolver) {\n+        this.storageResolvers.add(resolver);\n@@ -96,9 +96,0 @@\n-    \/**\n-     * Constructor StorageResolver\n-     *\n-     * @param x509certificate\n-     *\/\n-    public StorageResolver(X509Certificate x509certificate) {\n-        this.add(x509certificate);\n-    }\n-\n@@ -129,1 +120,1 @@\n-        Iterator<StorageResolverSpi> resolvers = null;\n+        private final Iterator<StorageResolverSpi> resolvers;\n@@ -132,1 +123,1 @@\n-        Iterator<Certificate> currentResolver = null;\n+        private Iterator<Certificate> currentResolver;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/storage\/StorageResolver.java","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public StorageResolverException(String msgID, Object exArgs[]) {\n+    public StorageResolverException(String msgID, Object[] exArgs) {\n@@ -88,1 +88,1 @@\n-    public StorageResolverException(Exception originalException, String msgID, Object exArgs[]) {\n+    public StorageResolverException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/storage\/StorageResolverException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,219 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.keys.storage.implementations;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateExpiredException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CertificateNotYetValidException;\n-import java.security.cert.X509Certificate;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolverException;\n-import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolverSpi;\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-\n-\/**\n- * This {@link StorageResolverSpi} makes all raw (binary) {@link X509Certificate}s\n- * which reside as files in a single directory available to the\n- * {@link com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver}.\n- *\/\n-public class CertsInFilesystemDirectoryResolver extends StorageResolverSpi {\n-\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-        com.sun.org.slf4j.internal.LoggerFactory.getLogger(\n-            CertsInFilesystemDirectoryResolver.class\n-        );\n-\n-    \/** Field merlinsCertificatesDir *\/\n-    private String merlinsCertificatesDir;\n-\n-    \/** Field certs *\/\n-    private List<X509Certificate> certs = new ArrayList<>();\n-\n-    \/**\n-     * @param directoryName\n-     * @throws StorageResolverException\n-     *\/\n-    public CertsInFilesystemDirectoryResolver(String directoryName)\n-        throws StorageResolverException {\n-        this.merlinsCertificatesDir = directoryName;\n-\n-        this.readCertsFromHarddrive();\n-    }\n-\n-    \/**\n-     * Method readCertsFromHarddrive\n-     *\n-     * @throws StorageResolverException\n-     *\/\n-    private void readCertsFromHarddrive() throws StorageResolverException {\n-\n-        File certDir = new File(this.merlinsCertificatesDir);\n-        List<String> al = new ArrayList<>();\n-        String[] names = certDir.list();\n-\n-        if (names != null) {\n-            for (int i = 0; i < names.length; i++) {\n-                String currentFileName = names[i];\n-\n-                if (currentFileName.endsWith(\".crt\")) {\n-                    al.add(names[i]);\n-                }\n-            }\n-        }\n-\n-        CertificateFactory cf = null;\n-\n-        try {\n-            cf = CertificateFactory.getInstance(\"X.509\");\n-        } catch (CertificateException ex) {\n-            throw new StorageResolverException(ex);\n-        }\n-\n-        for (int i = 0; i < al.size(); i++) {\n-            String filename = certDir.getAbsolutePath() + File.separator + al.get(i);\n-            boolean added = false;\n-            String dn = null;\n-\n-            try (InputStream inputStream = Files.newInputStream(Paths.get(filename))) {\n-                X509Certificate cert =\n-                    (X509Certificate) cf.generateCertificate(inputStream);\n-\n-                \/\/add to ArrayList\n-                cert.checkValidity();\n-                this.certs.add(cert);\n-\n-                dn = cert.getSubjectX500Principal().getName();\n-                added = true;\n-            } catch (FileNotFoundException ex) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Could not add certificate from file \" + filename, ex);\n-                }\n-            } catch (CertificateNotYetValidException ex) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Could not add certificate from file \" + filename, ex);\n-                }\n-            } catch (CertificateExpiredException ex) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Could not add certificate from file \" + filename, ex);\n-                }\n-            } catch (CertificateException ex) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Could not add certificate from file \" + filename, ex);\n-                }\n-            } catch (IOException ex) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Could not add certificate from file \" + filename, ex);\n-                }\n-            }\n-\n-            if (added) {\n-                LOG.debug(\"Added certificate: {}\", dn);\n-            }\n-        }\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    public Iterator<Certificate> getIterator() {\n-        return new FilesystemIterator(this.certs);\n-    }\n-\n-    \/**\n-     * Class FilesystemIterator\n-     *\/\n-    private static class FilesystemIterator implements Iterator<Certificate> {\n-\n-        \/** Field certs *\/\n-        private List<X509Certificate> certs;\n-\n-        \/** Field i *\/\n-        private int i;\n-\n-        \/**\n-         * Constructor FilesystemIterator\n-         *\n-         * @param certs\n-         *\/\n-        public FilesystemIterator(List<X509Certificate> certs) {\n-            this.certs = certs;\n-            this.i = 0;\n-        }\n-\n-        \/** {@inheritDoc} *\/\n-        public boolean hasNext() {\n-            return this.i < this.certs.size();\n-        }\n-\n-        \/** {@inheritDoc} *\/\n-        public Certificate next() {\n-            return this.certs.get(this.i++);\n-        }\n-\n-        \/**\n-         * Method remove\n-         *\n-         *\/\n-        public void remove() {\n-            throw new UnsupportedOperationException(\"Can't remove keys from KeyStore\");\n-        }\n-    }\n-\n-    \/**\n-     * Method main\n-     *\n-     * @param unused\n-     * @throws Exception\n-     *\/\n-    public static void main(String unused[]) throws Exception {\n-\n-        CertsInFilesystemDirectoryResolver krs =\n-            new CertsInFilesystemDirectoryResolver(\n-                \"data\/ie\/baltimore\/merlin-examples\/merlin-xmldsig-eighteen\/certs\");\n-\n-        for (Iterator<Certificate> i = krs.getIterator(); i.hasNext(); ) {\n-            X509Certificate cert = (X509Certificate) i.next();\n-            byte[] ski =\n-                com.sun.org.apache.xml.internal.security.keys.content.x509.XMLX509SKI.getSKIBytesFromCert(cert);\n-\n-            System.out.println();\n-            System.out.println(\"Base64(SKI())=                 \\\"\"\n-                               + XMLUtils.encodeToString(ski) + \"\\\"\");\n-            System.out.println(\"cert.getSerialNumber()=        \\\"\"\n-                               + cert.getSerialNumber().toString() + \"\\\"\");\n-            System.out.println(\"cert.getSubjectX500Principal().getName()= \\\"\"\n-                               + cert.getSubjectX500Principal().getName() + \"\\\"\");\n-            System.out.println(\"cert.getIssuerX500Principal().getName()=  \\\"\"\n-                               + cert.getIssuerX500Principal().getName() + \"\\\"\");\n-        }\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/storage\/implementations\/CertsInFilesystemDirectoryResolver.java","additions":0,"deletions":219,"binary":false,"changes":219,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -30,0 +32,1 @@\n+import java.util.List;\n@@ -41,0 +44,3 @@\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(KeyStoreResolver.class);\n+\n@@ -42,1 +48,1 @@\n-    private KeyStore keyStore;\n+    private final KeyStore keyStore;\n@@ -70,5 +76,1 @@\n-        \/** Field keyStore *\/\n-        KeyStore keyStore = null;\n-\n-        \/** Field aliases *\/\n-        Enumeration<String> aliases = null;\n+        private final List<Certificate> certs;\n@@ -76,2 +78,1 @@\n-        \/** Field nextCert *\/\n-        Certificate nextCert = null;\n+        private int i;\n@@ -85,0 +86,2 @@\n+\n+            List<Certificate> tmpCerts = new ArrayList<>();\n@@ -86,10 +89,6 @@\n-                this.keyStore = keyStore;\n-                this.aliases = this.keyStore.aliases();\n-            } catch (KeyStoreException ex) {\n-                \/\/ empty Enumeration\n-                this.aliases = new Enumeration<String>() {\n-                    public boolean hasMoreElements() {\n-                        return false;\n-                    }\n-                    public String nextElement() {\n-                        return null;\n+                Enumeration<String> aliases = keyStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    String alias = aliases.nextElement();\n+                    Certificate cert = keyStore.getCertificate(alias);\n+                    if (cert != null) {\n+                        tmpCerts.add(cert);\n@@ -97,1 +96,3 @@\n-                };\n+                }\n+            } catch (KeyStoreException ex) {\n+                LOG.debug(\"Error reading certificates: {}\", ex.getMessage());\n@@ -99,0 +100,3 @@\n+\n+            certs = Collections.unmodifiableList(tmpCerts);\n+            this.i = 0;\n@@ -103,5 +107,1 @@\n-            if (nextCert == null) {\n-                nextCert = findNextCert();\n-            }\n-\n-            return nextCert != null;\n+            return this.i < this.certs.size();\n@@ -112,7 +112,2 @@\n-            if (nextCert == null) {\n-                \/\/ maybe caller did not call hasNext()\n-                nextCert = findNextCert();\n-\n-                if (nextCert == null) {\n-                    throw new NoSuchElementException();\n-                }\n+            if (hasNext()) {\n+                return this.certs.get(this.i++);\n@@ -121,3 +116,1 @@\n-            Certificate ret = nextCert;\n-            nextCert = null;\n-            return ret;\n+            throw new NoSuchElementException();\n@@ -133,18 +126,0 @@\n-        \/\/ Find the next entry that contains a certificate and return it.\n-        \/\/ In particular, this skips over entries containing symmetric keys.\n-        private Certificate findNextCert() {\n-            while (this.aliases.hasMoreElements()) {\n-                String alias = this.aliases.nextElement();\n-                try {\n-                    Certificate cert = this.keyStore.getCertificate(alias);\n-                    if (cert != null) {\n-                        return cert;\n-                    }\n-                } catch (KeyStoreException ex) {\n-                    return null;\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/storage\/implementations\/KeyStoreResolver.java","additions":27,"deletions":52,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    private X509Certificate certificate;\n+    private final X509Certificate certificate;\n@@ -59,1 +59,1 @@\n-        boolean alreadyReturned = false;\n+        private boolean alreadyReturned;\n@@ -62,1 +62,1 @@\n-        X509Certificate certificate = null;\n+        private final X509Certificate certificate;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/storage\/implementations\/SingleCertificateResolver.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xml.internal.security.parser;\n+\n+import java.io.InputStream;\n+\n+import org.w3c.dom.Document;\n+\n+\/**\n+ * A interface to allow pluggable ways of parsing an InputStream into a DOM Document.\n+ *\/\n+public interface XMLParser {\n+\n+    Document parse(InputStream inputStream, boolean disallowDocTypeDeclarations) throws XMLParserException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/parser\/XMLParser.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xml.internal.security.parser;\n+\n+import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n+\n+public class XMLParserException extends XMLSecurityException {\n+    \/**\n+     *\n+     *\/\n+    private static final long serialVersionUID = 1L;\n+\n+    \/**\n+     * Constructor XMLParserException\n+     *\n+     *\/\n+    public XMLParserException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructor XMLParserException\n+     *\n+     * @param msgID\n+     *\/\n+    public XMLParserException(String msgID) {\n+        super(msgID);\n+    }\n+\n+    \/**\n+     * Constructor XMLParserException\n+     *\n+     * @param msgID\n+     * @param exArgs\n+     *\/\n+    public XMLParserException(String msgID, Object[] exArgs) {\n+        super(msgID, exArgs);\n+    }\n+\n+    \/**\n+     * Constructor XMLParserException\n+     *\n+     * @param originalException\n+     * @param msgID\n+     *\/\n+    public XMLParserException(Exception originalException, String msgID) {\n+        super(originalException, msgID);\n+    }\n+\n+    \/**\n+     * Constructor XMLParserException\n+     *\n+     * @param originalException\n+     * @param msgID\n+     * @param exArgs\n+     *\/\n+    public XMLParserException(\n+        Exception originalException, String msgID, Object[] exArgs\n+    ) {\n+        super(originalException, msgID, exArgs);\n+    }\n+\n+}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/parser\/XMLParserException.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xml.internal.security.parser;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ArrayBlockingQueue;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+import org.w3c.dom.Document;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * A default implementation of XMLParser that uses two pools of DocumentBuilders.\n+ *\/\n+public class XMLParserImpl implements XMLParser {\n+\n+    private static int parserPoolSize =\n+            AccessController.doPrivileged(\n+                    (PrivilegedAction<Integer>) () -> Integer.getInteger(\"com.sun.org.apache.xml.internal.security.parser.pool-size\", 20));\n+\n+    private static final Map<ClassLoader, Queue<DocumentBuilder>> DOCUMENT_BUILDERS =\n+            Collections.synchronizedMap(new WeakHashMap<ClassLoader, Queue<DocumentBuilder>>());\n+\n+    private static final Map<ClassLoader, Queue<DocumentBuilder>> DOCUMENT_BUILDERS_DISALLOW_DOCTYPE =\n+            Collections.synchronizedMap(new WeakHashMap<ClassLoader, Queue<DocumentBuilder>>());\n+\n+    @Override\n+    public Document parse(InputStream inputStream, boolean disallowDocTypeDeclarations) throws XMLParserException {\n+        try {\n+            ClassLoader loader = getContextClassLoader();\n+            if (loader == null) {\n+                loader = getClassLoader(XMLUtils.class);\n+            }\n+            \/\/ If the ClassLoader is null then just create a DocumentBuilder and use it\n+            if (loader == null) {\n+                DocumentBuilder documentBuilder = createDocumentBuilder(disallowDocTypeDeclarations);\n+                return documentBuilder.parse(inputStream);\n+            }\n+\n+            Queue<DocumentBuilder> queue = getDocumentBuilderQueue(disallowDocTypeDeclarations, loader);\n+            DocumentBuilder documentBuilder = getDocumentBuilder(disallowDocTypeDeclarations, queue);\n+            Document doc = documentBuilder.parse(inputStream);\n+            repoolDocumentBuilder(documentBuilder, queue);\n+            return doc;\n+        } catch (ParserConfigurationException | SAXException | IOException ex) {\n+            throw new XMLParserException(ex, \"empty\", new Object[] {\"Error parsing the inputstream\"});\n+        }\n+    }\n+\n+    private static Queue<DocumentBuilder> getDocumentBuilderQueue(boolean disallowDocTypeDeclarations, ClassLoader loader) throws ParserConfigurationException {\n+        Map<ClassLoader, Queue<DocumentBuilder>> docBuilderCache =\n+                disallowDocTypeDeclarations ? DOCUMENT_BUILDERS_DISALLOW_DOCTYPE : DOCUMENT_BUILDERS;\n+        Queue<DocumentBuilder> queue = docBuilderCache.get(loader);\n+        if (queue == null) {\n+            queue = new ArrayBlockingQueue<>(parserPoolSize);\n+            docBuilderCache.put(loader, queue);\n+        }\n+\n+        return queue;\n+    }\n+\n+    private static DocumentBuilder getDocumentBuilder(boolean disallowDocTypeDeclarations, Queue<DocumentBuilder> queue) throws ParserConfigurationException {\n+        DocumentBuilder db = queue.poll();\n+        if (db == null) {\n+            db = createDocumentBuilder(disallowDocTypeDeclarations);\n+        }\n+        return db;\n+    }\n+\n+    private static DocumentBuilder createDocumentBuilder(boolean disallowDocTypeDeclarations) throws ParserConfigurationException {\n+        DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n+        f.setNamespaceAware(true);\n+        f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n+        f.setFeature(\"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\", disallowDocTypeDeclarations);\n+        return f.newDocumentBuilder();\n+    }\n+\n+    private static void repoolDocumentBuilder(DocumentBuilder db, Queue<DocumentBuilder> queue) {\n+        if (queue != null) {\n+            db.reset();\n+            queue.offer(db);\n+        }\n+    }\n+\n+    private static ClassLoader getContextClassLoader() {\n+        final SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n+                public ClassLoader run() {\n+                    return Thread.currentThread().getContextClassLoader();\n+                }\n+            });\n+        }\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    private static ClassLoader getClassLoader(final Class<?> clazz) {\n+        final SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n+                public ClassLoader run() {\n+                    return clazz.getClassLoader();\n+                }\n+            });\n+        }\n+        return clazz.getClassLoader();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/parser\/XMLParserImpl.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -253,2 +253,2 @@\n-         <Algorithm URI=\"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#rsa-sha2224\"\r\n-                    Description=\"RSA Signature with SHA-2224 message digest\"\r\n+         <Algorithm URI=\"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#rsa-sha224\"\r\n+                    Description=\"RSA Signature with SHA-224 message digest\"\r\n@@ -329,0 +329,1 @@\n+                    RequiredKey=\"EC\"\r\n@@ -360,0 +361,1 @@\n+                    RequiredKey=\"EC\"\r\n@@ -377,0 +379,1 @@\n+                    RequiredKey=\"\"\r\n@@ -385,0 +388,1 @@\n+                    RequiredKey=\"\"\r\n@@ -392,0 +396,1 @@\n+                    RequiredKey=\"\"\r\n@@ -400,0 +405,1 @@\n+                    RequiredKey=\"\"\r\n@@ -408,0 +414,1 @@\n+                    RequiredKey=\"\"\r\n@@ -416,0 +423,1 @@\n+                    RequiredKey=\"\"\r\n@@ -424,0 +432,1 @@\n+                    RequiredKey=\"\"\r\n@@ -550,1 +559,3 @@\n-                    RequirementLevel=\"OPTIONAL\"\/>\r\n+                    RequirementLevel=\"OPTIONAL\"\r\n+                    RequiredKey=\"DH\"\r\n+                    JCEName=\"DH\"\/>\r\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/config.xml","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+algorithms.HMACOutputLengthMax = HMACOutputLength darf nicht grosser als {0} sein\r\n@@ -31,0 +32,1 @@\n+algorithms.MissingRSAPSSParams = RSAPSSParams is a required Element for http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\r\n@@ -134,0 +136,1 @@\n+signature.Verification.InvalidElement = Current Node {0} is not permitted in this location in the Signature\r\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/xmlsecurity_de.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+algorithms.HMACOutputLengthMax = HMACOutputLength must not be more than {0}\r\n@@ -31,0 +32,1 @@\n+algorithms.MissingRSAPSSParams = RSAPSSParams is a required Element for http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\r\n@@ -136,0 +138,1 @@\n+signature.Verification.InvalidElement = Current Node {0} is not permitted in this location in the Signature\r\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/xmlsecurity_en.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    public InvalidDigestValueException(String msgID, Object exArgs[]) {\n+    public InvalidDigestValueException(String msgID, Object[] exArgs) {\n@@ -87,1 +87,1 @@\n-    public InvalidDigestValueException(Exception originalException, String msgID, Object exArgs[]) {\n+    public InvalidDigestValueException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/InvalidDigestValueException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public InvalidSignatureValueException(String msgID, Object exArgs[]) {\n+    public InvalidSignatureValueException(String msgID, Object[] exArgs) {\n@@ -86,1 +86,1 @@\n-    public InvalidSignatureValueException(Exception originalException, String msgID, Object exArgs[]) {\n+    public InvalidSignatureValueException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/InvalidSignatureValueException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -41,0 +39,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -46,1 +45,0 @@\n-import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;\n@@ -53,1 +51,0 @@\n-import org.xml.sax.SAXException;\n@@ -85,1 +82,1 @@\n-    private List<ResourceResolver> perManifestResolvers;\n+    private List<ResourceResolverSpi> perManifestResolvers;\n@@ -140,1 +137,1 @@\n-            Object exArgs[] = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };\n+            Object[] exArgs = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };\n@@ -147,1 +144,1 @@\n-            Object exArgs[] = { le, referenceCount };\n+            Object[] exArgs = { le, referenceCount };\n@@ -323,2 +320,2 @@\n-        LOG.debug(\"I am {} requested to follow nested Manifests\", (followManifests\n-            ? \"\" : \"not\"));\n+        LOG.debug(\"I am {} requested to follow nested Manifests\", followManifests\n+            ? \"\" : \"not\");\n@@ -329,1 +326,1 @@\n-            Object exArgs[] = { referencesEl.length, referenceCount };\n+            Object[] exArgs = { referencesEl.length, referenceCount };\n@@ -408,3 +405,1 @@\n-                    } catch (ParserConfigurationException ex) {\n-                        throw new ReferenceNotInitializedException(ex);\n-                    } catch (SAXException ex) {\n+                    } catch (XMLParserException ex) {\n@@ -417,1 +412,1 @@\n-                Object exArgs[] = { currentRef.getURI() };\n+                Object[] exArgs = { currentRef.getURI() };\n@@ -439,1 +434,1 @@\n-            Object exArgs[] = { Integer.toString(index), Integer.toString(this.getLength()) };\n+            Object[] exArgs = { Integer.toString(index), Integer.toString(this.getLength()) };\n@@ -456,1 +451,1 @@\n-        return ((ArrayList<VerifiedReference>)verificationResults).get(index).isValid();\n+        return verificationResults.get(index).isValid();\n@@ -473,1 +468,1 @@\n-     * @param resolver {@link ResourceResolver} can provide the implementation subclass of\n+     * @param resolver {@link ResourceResolverSpi} can provide the implementation subclass of\n@@ -476,1 +471,1 @@\n-    public void addResourceResolver(ResourceResolver resolver) {\n+    public void addResourceResolver(ResourceResolverSpi resolver) {\n@@ -486,17 +481,0 @@\n-    \/**\n-     * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute\n-     * in {@code reference} element\n-     *\n-     * @param resolverSpi the implementation subclass of {@link ResourceResolverSpi} for\n-     * retrieving the resource.\n-     *\/\n-    public void addResourceResolver(ResourceResolverSpi resolverSpi) {\n-        if (resolverSpi == null) {\n-            return;\n-        }\n-        if (perManifestResolvers == null) {\n-            perManifestResolvers = new ArrayList<>();\n-        }\n-        perManifestResolvers.add(new ResourceResolver(resolverSpi));\n-    }\n-\n@@ -507,1 +485,1 @@\n-    public List<ResourceResolver> getPerManifestResolvers() {\n+    public List<ResourceResolverSpi> getPerManifestResolvers() {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/Manifest.java","additions":14,"deletions":36,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public MissingResourceFailureException(Reference reference, String msgID, Object exArgs[]) {\n+    public MissingResourceFailureException(Reference reference, String msgID, Object[] exArgs) {\n@@ -74,1 +74,1 @@\n-    public MissingResourceFailureException(String msgID, Object exArgs[], Reference reference) {\n+    public MissingResourceFailureException(String msgID, Object[] exArgs, Reference reference) {\n@@ -111,1 +111,1 @@\n-        Exception originalException, Reference reference, String msgID, Object exArgs[]\n+        Exception originalException, Reference reference, String msgID, Object[] exArgs\n@@ -120,1 +120,1 @@\n-        String msgID, Object exArgs[], Exception originalException, Reference reference\n+        String msgID, Object[] exArgs, Exception originalException, Reference reference\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/MissingResourceFailureException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -36,1 +37,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;\n@@ -53,0 +53,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverContext;\n@@ -143,0 +144,13 @@\n+    private static final Set<String> TRANSFORM_ALGORITHMS;\n+\n+    static {\n+        Set<String> algorithms = new HashSet<>();\n+        algorithms.add(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS);\n+        algorithms.add(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS);\n+        algorithms.add(Transforms.TRANSFORM_C14N_OMIT_COMMENTS);\n+        algorithms.add(Transforms.TRANSFORM_C14N_WITH_COMMENTS);\n+        algorithms.add(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);\n+        algorithms.add(Transforms.TRANSFORM_C14N11_WITH_COMMENTS);\n+        TRANSFORM_ALGORITHMS = Collections.unmodifiableSet(algorithms);\n+    }\n+\n@@ -154,1 +168,0 @@\n-     * @throws XMLSignatureException\n@@ -241,1 +254,1 @@\n-                Object exArgs[] = { transforms.getLength(), MAXIMUM_TRANSFORM_COUNT };\n+                Object[] exArgs = { transforms.getLength(), MAXIMUM_TRANSFORM_COUNT };\n@@ -249,1 +262,3 @@\n-        if (digestMethodElem == null) {\n+        if (digestMethodElem == null ||\n+            !(Constants.SignatureSpecNS.equals(digestMethodElem.getNamespaceURI())\n+                && Constants._TAG_DIGESTMETHOD.equals(digestMethodElem.getLocalName()))) {\n@@ -254,1 +269,3 @@\n-        if (digestValueElement == null) {\n+        if (digestValueElement == null ||\n+            !(Constants.SignatureSpecNS.equals(digestValueElement.getNamespaceURI())\n+                && Constants._TAG_DIGESTVALUE.equals(digestValueElement.getLocalName()))) {\n@@ -275,1 +292,1 @@\n-        if (\"\".equals(uri)) {\n+        if (uri.isEmpty()) {\n@@ -280,1 +297,1 @@\n-            Object exArgs[] = { uri };\n+            Object[] exArgs = { uri };\n@@ -342,1 +359,1 @@\n-     * Return the {@code type} atttibute of the Reference indicate whether an\n+     * Return the {@code type} attribute of the Reference indicate whether an\n@@ -362,5 +379,1 @@\n-        if (Reference.OBJECT_URI.equals(this.getType())) {\n-            return true;\n-        }\n-\n-        return false;\n+        return Reference.OBJECT_URI.equals(this.getType());\n@@ -379,5 +392,1 @@\n-        if (Reference.MANIFEST_URI.equals(this.getType())) {\n-            return true;\n-        }\n-\n-        return false;\n+        return Reference.MANIFEST_URI.equals(this.getType());\n@@ -427,5 +436,3 @@\n-            ResourceResolver resolver =\n-                ResourceResolver.getInstance(\n-                    uriAttr, this.baseURI, this.manifest.getPerManifestResolvers(), secureValidation\n-                );\n-            resolver.addProperties(this.manifest.getResolverProperties());\n+            ResourceResolverContext resolverContext =\n+                new ResourceResolverContext(uriAttr, this.baseURI,\n+                    secureValidation, this.manifest.getResolverProperties());\n@@ -433,1 +440,1 @@\n-            return resolver.resolve(uriAttr, this.baseURI, secureValidation);\n+            return ResourceResolver.resolve(this.manifest.getPerManifestResolvers(), resolverContext);\n@@ -456,8 +463,0 @@\n-        } catch (ResourceResolverException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (CanonicalizationException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (InvalidCanonicalizerException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (TransformationException ex) {\n-            throw new XMLSignatureException(ex);\n@@ -502,6 +501,1 @@\n-                    if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)\n-                        || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)\n-                        || uri.equals(Transforms.TRANSFORM_C14N_OMIT_COMMENTS)\n-                        || uri.equals(Transforms.TRANSFORM_C14N_WITH_COMMENTS)\n-                        || uri.equals(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS)\n-                        || uri.equals(Transforms.TRANSFORM_C14N11_WITH_COMMENTS)) {\n+                    if (TRANSFORM_ALGORITHMS.contains(uri)) {\n@@ -511,1 +505,1 @@\n-                    output = t.performTransform(output, null);\n+                    output = t.performTransform(output, null, secureValidation);\n@@ -517,11 +511,1 @@\n-        } catch (IOException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (ResourceResolverException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (CanonicalizationException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (InvalidCanonicalizerException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (TransformationException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (XMLSecurityException ex) {\n+        } catch (IOException | XMLSecurityException ex) {\n@@ -578,4 +562,0 @@\n-        } catch (TransformationException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (InvalidTransformException ex) {\n-            throw new XMLSignatureException(ex);\n@@ -637,1 +617,1 @@\n-                            Iterator<Node> sIterator = s.iterator();\n+                            final Iterator<Node> sIterator = s.iterator();\n@@ -702,3 +682,1 @@\n-        } catch (IOException ex) {\n-            throw new ReferenceNotInitializedException(ex);\n-        } catch (CanonicalizationException ex) {\n+        } catch (IOException | CanonicalizationException ex) {\n@@ -730,0 +708,1 @@\n+        XMLSignatureInput output = null;\n@@ -733,1 +712,1 @@\n-            XMLSignatureInput output = this.getContentsAfterTransformation(input, os);\n+            output = this.getContentsAfterTransformation(input, os);\n@@ -752,4 +731,0 @@\n-            if (output.getOctetStreamReal() != null) {\n-                output.getOctetStreamReal().close();\n-            }\n-\n@@ -760,3 +735,1 @@\n-        } catch (XMLSecurityException ex) {\n-            throw new ReferenceNotInitializedException(ex);\n-        } catch (IOException ex) {\n+        } catch (XMLSecurityException | IOException ex) {\n@@ -764,0 +737,8 @@\n+        } finally { \/\/NOPMD\n+            try {\n+                if (output != null && output.getOctetStreamReal() != null) {\n+                    output.getOctetStreamReal().close();\n+                }\n+            } catch (IOException ex) {\n+                throw new ReferenceNotInitializedException(ex);\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/Reference.java","additions":47,"deletions":66,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public ReferenceNotInitializedException(String msgID, Object exArgs[]) {\n+    public ReferenceNotInitializedException(String msgID, Object[] exArgs) {\n@@ -90,1 +90,1 @@\n-    public ReferenceNotInitializedException(Exception originalException, String msgID, Object exArgs[]) {\n+    public ReferenceNotInitializedException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/ReferenceNotInitializedException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,4 +67,3 @@\n-        int length = getLength();\n-        for (int i = 0; i < length; i++) {\n-            Element propertyElem =\n-                XMLUtils.selectDsNode(getElement(), Constants._TAG_SIGNATUREPROPERTY, i);\n+        Element[] propertyElems =\n+                XMLUtils.selectDsNodes(getFirstChild(), Constants._TAG_SIGNATUREPROPERTY);\n+        for (Element propertyElem : propertyElems) {\n@@ -85,1 +84,1 @@\n-            XMLUtils.selectDsNodes(getElement(), Constants._TAG_SIGNATUREPROPERTY);\n+            XMLUtils.selectDsNodes(getFirstChild(), Constants._TAG_SIGNATUREPROPERTY);\n@@ -101,1 +100,1 @@\n-                XMLUtils.selectDsNode(getElement(), Constants._TAG_SIGNATUREPROPERTY, i);\n+                XMLUtils.selectDsNode(getFirstChild(), Constants._TAG_SIGNATUREPROPERTY, i);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/SignatureProperties.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -29,1 +28,2 @@\n-\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -32,1 +32,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -42,0 +41,1 @@\n+\n@@ -44,2 +44,0 @@\n-import org.w3c.dom.Node;\n-import org.xml.sax.SAXException;\n@@ -56,1 +54,1 @@\n-    private SignatureAlgorithm signatureAlgorithm;\n+    private final SignatureAlgorithm signatureAlgorithm;\n@@ -91,1 +89,19 @@\n-        this(doc, signatureMethodURI, 0, canonicalizationMethodURI);\n+        this(doc, signatureMethodURI, 0, canonicalizationMethodURI, null, null);\n+    }\n+\n+    \/**\n+     * Constructs {@link SignedInfo} using given Canonicalization algorithm and\n+     * Signature algorithm.\n+     *\n+     * @param doc {@code SignedInfo} is placed in this document\n+     * @param signatureMethodURI URI representation of the Digest and\n+     *    Signature algorithm\n+     * @param canonicalizationMethodURI URI representation of the\n+     *    Canonicalization method\n+     * @param provider security provider to use\n+     * @throws XMLSecurityException\n+     *\/\n+    public SignedInfo(\n+        Document doc, String signatureMethodURI, String canonicalizationMethodURI, Provider provider\n+    ) throws XMLSecurityException {\n+        this(doc, signatureMethodURI, 0, canonicalizationMethodURI, provider, null);\n@@ -108,0 +124,21 @@\n+    ) throws XMLSecurityException {\n+        this(doc, signatureMethodURI, hMACOutputLength, canonicalizationMethodURI, null, null);\n+    }\n+\n+    \/**\n+     * Constructs {@link SignedInfo} using given Canonicalization algorithm and\n+     * Signature algorithm.\n+     *\n+     * @param doc {@code SignedInfo} is placed in this document\n+     * @param signatureMethodURI URI representation of the Digest and\n+     *    Signature algorithm\n+     * @param hMACOutputLength\n+     * @param canonicalizationMethodURI URI representation of the\n+     *    Canonicalization method\n+     * @param provider security provider to use\n+     * @param spec AlgorithmParameterSpec to use\n+     * @throws XMLSecurityException\n+     *\/\n+    public SignedInfo(\n+        Document doc, String signatureMethodURI,\n+        int hMACOutputLength, String canonicalizationMethodURI, Provider provider, AlgorithmParameterSpec spec\n@@ -120,1 +157,1 @@\n-                new SignatureAlgorithm(getDocument(), signatureMethodURI, hMACOutputLength);\n+                new SignatureAlgorithm(getDocument(), signatureMethodURI, hMACOutputLength, provider);\n@@ -122,1 +159,1 @@\n-            this.signatureAlgorithm = new SignatureAlgorithm(getDocument(), signatureMethodURI);\n+            this.signatureAlgorithm = new SignatureAlgorithm(getDocument(), signatureMethodURI, provider, spec);\n@@ -138,0 +175,6 @@\n+    ) throws XMLSecurityException {\n+        this(doc, signatureMethodElem, canonicalizationMethodElem, null);\n+    }\n+\n+    public SignedInfo(\n+        Document doc, Element signatureMethodElem, Element canonicalizationMethodElem, Provider provider\n@@ -146,1 +189,1 @@\n-            new SignatureAlgorithm(signatureMethodElem, null);\n+            new SignatureAlgorithm(signatureMethodElem, null, provider);\n@@ -166,1 +209,1 @@\n-        this(element, baseURI, true);\n+        this(element, baseURI, true, null);\n@@ -184,2 +227,20 @@\n-        \/\/ Parse the Reference children and Id attribute in the Manifest\n-        super(reparseSignedInfoElem(element, secureValidation), baseURI, secureValidation);\n+        this(element, baseURI, secureValidation, null);\n+    }\n+\n+    \/**\n+     * Build a {@link SignedInfo} from an {@link Element}\n+     *\n+     * @param element {@code SignedInfo}\n+     * @param baseURI the URI of the resource where the XML instance was stored\n+     * @param secureValidation whether secure validation is enabled or not\n+     * @param provider security provider to use\n+     * @throws XMLSecurityException\n+     * @see <A HREF=\"http:\/\/lists.w3.org\/Archives\/Public\/w3c-ietf-xmldsig\/2001OctDec\/0033.html\">\n+     * Question<\/A>\n+     * @see <A HREF=\"http:\/\/lists.w3.org\/Archives\/Public\/w3c-ietf-xmldsig\/2001OctDec\/0054.html\">\n+     * Answer<\/A>\n+     *\/\n+    public SignedInfo(\n+        Element element, String baseURI, boolean secureValidation, Provider provider\n+    ) throws XMLSecurityException {\n+        super(element, baseURI, secureValidation);\n@@ -188,4 +249,6 @@\n-        signatureMethod = XMLUtils.getNextElement(c14nMethod.getNextSibling());\n-        this.signatureAlgorithm =\n-            new SignatureAlgorithm(signatureMethod, this.getBaseURI(), secureValidation);\n-    }\n+        if (c14nMethod == null ||\n+            !(Constants.SignatureSpecNS.equals(c14nMethod.getNamespaceURI())\n+                && Constants._TAG_CANONICALIZATIONMETHOD.equals(c14nMethod.getLocalName()))) {\n+            Object[] exArgs = { Constants._TAG_CANONICALIZATIONMETHOD, Constants._TAG_SIGNEDINFO };\n+            throw new XMLSignatureException(\"xml.WrongContent\", exArgs);\n+        }\n@@ -193,39 +256,6 @@\n-    private static Element reparseSignedInfoElem(Element element, boolean secureValidation)\n-        throws XMLSecurityException {\n-        \/*\n-         * If a custom canonicalizationMethod is used, canonicalize\n-         * ds:SignedInfo, reparse it into a new document\n-         * and replace the original not-canonicalized ds:SignedInfo by\n-         * the re-parsed canonicalized one.\n-         *\/\n-        Element c14nMethod = XMLUtils.getNextElement(element.getFirstChild());\n-        String c14nMethodURI =\n-            c14nMethod.getAttributeNS(null, Constants._ATT_ALGORITHM);\n-        if (!(c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS) ||\n-            c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS) ||\n-            c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N_EXCL_OMIT_COMMENTS) ||\n-            c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N_EXCL_WITH_COMMENTS) ||\n-            c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N11_OMIT_COMMENTS) ||\n-            c14nMethodURI.equals(Canonicalizer.ALGO_ID_C14N11_WITH_COMMENTS))) {\n-            \/\/ the c14n is not a secure one and can rewrite the URIs or like\n-            \/\/ so reparse the SignedInfo to be sure\n-            try {\n-                Canonicalizer c14nizer =\n-                    Canonicalizer.getInstance(c14nMethodURI);\n-                c14nizer.setSecureValidation(secureValidation);\n-\n-                byte[] c14nizedBytes = c14nizer.canonicalizeSubtree(element);\n-                try (InputStream is = new ByteArrayInputStream(c14nizedBytes)) {\n-                    Document newdoc = XMLUtils.read(is, secureValidation);\n-                    Node imported = element.getOwnerDocument().importNode(\n-                            newdoc.getDocumentElement(), true);\n-                    element.getParentNode().replaceChild(imported, element);\n-                    return (Element) imported;\n-                }\n-            } catch (ParserConfigurationException ex) {\n-                throw new XMLSecurityException(ex);\n-            } catch (IOException ex) {\n-                throw new XMLSecurityException(ex);\n-            } catch (SAXException ex) {\n-                throw new XMLSecurityException(ex);\n-            }\n+        signatureMethod = XMLUtils.getNextElement(c14nMethod.getNextSibling());\n+        if (signatureMethod == null ||\n+            !(Constants.SignatureSpecNS.equals(signatureMethod.getNamespaceURI())\n+                && Constants._TAG_SIGNATUREMETHOD.equals(signatureMethod.getLocalName()))) {\n+            Object[] exArgs = { Constants._TAG_SIGNATUREMETHOD, Constants._TAG_SIGNEDINFO };\n+            throw new XMLSignatureException(\"xml.WrongContent\", exArgs);\n@@ -233,1 +263,3 @@\n-        return element;\n+\n+        this.signatureAlgorithm =\n+            new SignatureAlgorithm(signatureMethod, this.getBaseURI(), secureValidation, provider);\n@@ -268,0 +300,1 @@\n+     * @throws IOException\n@@ -270,1 +303,1 @@\n-        throws CanonicalizationException, InvalidCanonicalizerException, XMLSecurityException {\n+        throws CanonicalizationException, InvalidCanonicalizerException, XMLSecurityException, IOException {\n@@ -274,1 +307,0 @@\n-            c14nizer.setSecureValidation(isSecureValidation());\n@@ -277,4 +309,7 @@\n-            if (inclusiveNamespaces == null) {\n-                this.c14nizedBytes = c14nizer.canonicalizeSubtree(getElement());\n-            } else {\n-                this.c14nizedBytes = c14nizer.canonicalizeSubtree(getElement(), inclusiveNamespaces);\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n+                if (inclusiveNamespaces == null) {\n+                    c14nizer.canonicalizeSubtree(getElement(), baos);\n+                } else {\n+                    c14nizer.canonicalizeSubtree(getElement(), inclusiveNamespaces, baos);\n+                }\n+                this.c14nizedBytes = baos.toByteArray();\n@@ -300,2 +335,0 @@\n-            c14nizer.setSecureValidation(isSecureValidation());\n-            c14nizer.setWriter(os);\n@@ -305,1 +338,1 @@\n-                c14nizer.canonicalizeSubtree(getElement());\n+                c14nizer.canonicalizeSubtree(getElement(), os);\n@@ -307,1 +340,1 @@\n-                c14nizer.canonicalizeSubtree(getElement(), inclusiveNamespaces);\n+                c14nizer.canonicalizeSubtree(getElement(), inclusiveNamespaces, os);\n@@ -377,2 +410,2 @@\n-        if (!(c14nMethodURI.equals(\"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#\") ||\n-            c14nMethodURI.equals(\"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#WithComments\"))) {\n+        if (!(\"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#\".equals(c14nMethodURI) ||\n+            \"http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n#WithComments\".equals(c14nMethodURI))) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/SignedInfo.java","additions":103,"deletions":70,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.Provider;\n@@ -30,0 +31,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -34,1 +36,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n@@ -36,1 +37,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;\n@@ -47,1 +47,0 @@\n-import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;\n@@ -205,0 +204,4 @@\n+    \/** Signature - Optional RSASSA-PSS *\/\n+    public static final String ALGO_ID_SIGNATURE_RSA_PSS =\n+            Constants.XML_DSIG_NS_MORE_07_05 + \"rsa-pss\";\n+\n@@ -209,1 +212,1 @@\n-    private SignedInfo signedInfo;\n+    private final SignedInfo signedInfo;\n@@ -241,1 +244,19 @@\n-        this(doc, baseURI, signatureMethodURI, 0, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);\n+        this(doc, baseURI, signatureMethodURI, 0, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS, null, null);\n+    }\n+\n+    \/**\n+     * This creates a new {@code ds:Signature} Element and adds an empty\n+     * {@code ds:SignedInfo}.\n+     * The {@code ds:SignedInfo} is initialized with the specified Signature\n+     * algorithm and Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS which is REQUIRED\n+     * by the spec. This method's main use is for creating a new signature.\n+     *\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n+     * @param signatureMethodURI signature algorithm to use.\n+     * @param provider security provider to use.\n+     * @throws XMLSecurityException\n+     *\/\n+    public XMLSignature(Document doc, String baseURI, String signatureMethodURI, Provider provider)\n+        throws XMLSecurityException {\n+        this(doc, baseURI, signatureMethodURI, 0, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS, provider, null);\n@@ -247,2 +268,2 @@\n-     * @param doc\n-     * @param baseURI\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n@@ -257,1 +278,1 @@\n-            Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS\n+            Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS, null, null\n@@ -264,2 +285,20 @@\n-     * @param doc\n-     * @param baseURI\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n+     * @param signatureMethodURI the Signature method to be used.\n+     * @param hmacOutputLength\n+     * @param provider security provider to use.\n+     * @throws XMLSecurityException\n+     *\/\n+    public XMLSignature(Document doc, String baseURI, String signatureMethodURI,\n+                        int hmacOutputLength, Provider provider) throws XMLSecurityException {\n+        this(\n+            doc, baseURI, signatureMethodURI, hmacOutputLength,\n+            Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS, provider, null\n+        );\n+    }\n+\n+    \/**\n+     * Constructor XMLSignature\n+     *\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n@@ -267,2 +306,1 @@\n-     * @param canonicalizationMethodURI the canonicalization algorithm to be\n-     * used to c14nize the SignedInfo element.\n+     * @param canonicalizationMethodURI the canonicalization algorithm to be used to c14nize the SignedInfo element.\n@@ -277,1 +315,1 @@\n-        this(doc, baseURI, signatureMethodURI, 0, canonicalizationMethodURI);\n+        this(doc, baseURI, signatureMethodURI, 0, canonicalizationMethodURI, null, null);\n@@ -283,3 +321,23 @@\n-     * @param doc\n-     * @param baseURI\n-     * @param signatureMethodURI\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n+     * @param signatureMethodURI the Signature method to be used.\n+     * @param canonicalizationMethodURI the canonicalization algorithm to be used to c14nize the SignedInfo element.\n+     * @param provider security provider to use.\n+     * @throws XMLSecurityException\n+     *\/\n+    public XMLSignature(\n+        Document doc,\n+        String baseURI,\n+        String signatureMethodURI,\n+        String canonicalizationMethodURI,\n+        Provider provider\n+    ) throws XMLSecurityException {\n+        this(doc, baseURI, signatureMethodURI, 0, canonicalizationMethodURI, provider, null);\n+    }\n+\n+    \/**\n+     * Constructor XMLSignature\n+     *\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n+     * @param signatureMethodURI the Signature method to be used.\n@@ -287,1 +345,1 @@\n-     * @param canonicalizationMethodURI\n+     * @param canonicalizationMethodURI the canonicalization algorithm to be used to c14nize the SignedInfo element.\n@@ -296,0 +354,24 @@\n+    ) throws XMLSecurityException {\n+        this(doc, baseURI, signatureMethodURI, hmacOutputLength, canonicalizationMethodURI, null, null);\n+    }\n+\n+    \/**\n+     * Constructor XMLSignature\n+     *\n+     * @param doc Document in which the signature will be appended after creation.\n+     * @param baseURI URI to be used as context for all relative URIs.\n+     * @param signatureMethodURI the Signature method to be used.\n+     * @param hmacOutputLength\n+     * @param canonicalizationMethodURI the canonicalization algorithm to be used to c14nize the SignedInfo element.\n+     * @param provider security provider to use.\n+     * @param spec\n+     * @throws XMLSecurityException\n+     *\/\n+    public XMLSignature(\n+        Document doc,\n+        String baseURI,\n+        String signatureMethodURI,\n+        int hmacOutputLength,\n+        String canonicalizationMethodURI,\n+        Provider provider,\n+        AlgorithmParameterSpec spec\n@@ -314,1 +396,1 @@\n-                getDocument(), signatureMethodURI, hmacOutputLength, canonicalizationMethodURI\n+                getDocument(), signatureMethodURI, hmacOutputLength, canonicalizationMethodURI, provider, spec\n@@ -332,2 +414,2 @@\n-     * @param SignatureMethodElem\n-     * @param CanonicalizationMethodElem\n+     * @param signatureMethodElem\n+     * @param canonicalizationMethodElem\n@@ -339,2 +421,12 @@\n-        Element SignatureMethodElem,\n-        Element CanonicalizationMethodElem\n+        Element signatureMethodElem,\n+        Element canonicalizationMethodElem\n+    ) throws XMLSecurityException {\n+        this(doc, baseURI, signatureMethodElem, canonicalizationMethodElem, null);\n+    }\n+\n+    public XMLSignature(\n+        Document doc,\n+        String baseURI,\n+        Element signatureMethodElem,\n+        Element canonicalizationMethodElem,\n+        Provider provider\n@@ -358,1 +450,1 @@\n-            new SignedInfo(getDocument(), SignatureMethodElem, CanonicalizationMethodElem);\n+            new SignedInfo(getDocument(), signatureMethodElem, canonicalizationMethodElem, provider);\n@@ -382,1 +474,16 @@\n-        this(element, baseURI, true);\n+        this(element, baseURI, true, null);\n+    }\n+\n+    \/**\n+     * This will parse the element and construct the Java Objects.\n+     * That will allow a user to validate the signature.\n+     *\n+     * @param element ds:Signature element that contains the whole signature\n+     * @param baseURI URI to be prepended to all relative URIs\n+     * @param provider security provider to use\n+     * @throws XMLSecurityException\n+     * @throws XMLSignatureException if the signature is badly formatted\n+     *\/\n+    public XMLSignature(Element element, String baseURI, Provider provider)\n+        throws XMLSignatureException, XMLSecurityException {\n+        this(element, baseURI, true, provider);\n@@ -396,0 +503,16 @@\n+        throws XMLSignatureException, XMLSecurityException {\n+        this(element, baseURI, secureValidation, null);\n+    }\n+\n+    \/**\n+     * This will parse the element and construct the Java Objects.\n+     * That will allow a user to validate the signature.\n+     *\n+     * @param element ds:Signature element that contains the whole signature\n+     * @param baseURI URI to be prepended to all relative URIs\n+     * @param secureValidation whether secure secureValidation is enabled or not\n+     * @param provider security provider to use\n+     * @throws XMLSecurityException\n+     * @throws XMLSignatureException if the signature is badly formatted\n+     *\/\n+    public XMLSignature(Element element, String baseURI, boolean secureValidation, Provider provider)\n@@ -399,0 +522,6 @@\n+        if (!(Constants.SignatureSpecNS.equals(element.getNamespaceURI())\n+            && Constants._TAG_SIGNATURE.equals(element.getLocalName()))) {\n+            Object[] exArgs = { element.getLocalName() };\n+            throw new XMLSignatureException(\"signature.Verification.InvalidElement\", exArgs);\n+        }\n+\n@@ -403,2 +532,4 @@\n-        if (signedInfoElem == null) {\n-            Object exArgs[] = { Constants._TAG_SIGNEDINFO, Constants._TAG_SIGNATURE };\n+        if (signedInfoElem == null ||\n+            !(Constants.SignatureSpecNS.equals(signedInfoElem.getNamespaceURI())\n+                && Constants._TAG_SIGNEDINFO.equals(signedInfoElem.getLocalName()))) {\n+            Object[] exArgs = { Constants._TAG_SIGNEDINFO, Constants._TAG_SIGNATURE };\n@@ -409,1 +540,1 @@\n-        this.signedInfo = new SignedInfo(signedInfoElem, baseURI, secureValidation);\n+        this.signedInfo = new SignedInfo(signedInfoElem, baseURI, secureValidation, provider);\n@@ -418,2 +549,4 @@\n-        if (signatureValueElement == null) {\n-            Object exArgs[] = { Constants._TAG_SIGNATUREVALUE, Constants._TAG_SIGNATURE };\n+        if (signatureValueElement == null ||\n+            !(Constants.SignatureSpecNS.equals(signatureValueElement.getNamespaceURI())\n+                && Constants._TAG_SIGNATUREVALUE.equals(signatureValueElement.getLocalName()))) {\n+            Object[] exArgs = { Constants._TAG_SIGNATUREVALUE, Constants._TAG_SIGNATURE };\n@@ -432,0 +565,1 @@\n+        Element objectElem = null;\n@@ -437,0 +571,4 @@\n+            objectElem = XMLUtils.getNextElement(keyInfoElem.getNextSibling());\n+        } else {\n+            \/\/ If we have no KeyInfo\n+            objectElem = keyInfoElem;\n@@ -440,2 +578,0 @@\n-        Element objectElem =\n-            XMLUtils.getNextElement(signatureValueElement.getNextSibling());\n@@ -443,0 +579,7 @@\n+            \/\/ Make sure it actually is an Object\n+            if (!(Constants.SignatureSpecNS.equals(objectElem.getNamespaceURI())\n+                && Constants._TAG_OBJECT.equals(objectElem.getLocalName()))) {\n+                Object[] exArgs = { objectElem.getLocalName() };\n+                throw new XMLSignatureException(\"signature.Verification.InvalidElement\", exArgs);\n+            }\n+\n@@ -655,7 +798,1 @@\n-        } catch (CanonicalizationException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (InvalidCanonicalizerException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (XMLSecurityException ex) {\n-            throw new XMLSignatureException(ex);\n-        } catch (IOException ex) {\n+        } catch (XMLSecurityException | IOException ex) {\n@@ -666,9 +803,0 @@\n-    \/**\n-     * Adds a {@link ResourceResolver} to enable the retrieval of resources.\n-     *\n-     * @param resolver\n-     *\/\n-    public void addResourceResolver(ResourceResolver resolver) {\n-        this.getSignedInfo().addResourceResolver(resolver);\n-    }\n-\n@@ -703,1 +831,1 @@\n-        Object exArgs[] = { \"Didn't get a certificate\" };\n+        Object[] exArgs = { \"Didn't get a certificate\" };\n@@ -721,1 +849,1 @@\n-            Object exArgs[] = { \"Didn't get a key\" };\n+            Object[] exArgs = { \"Didn't get a key\" };\n@@ -736,1 +864,0 @@\n-            LOG.debug(\"jceSigProvider = {}\", sa.getJCEProviderName());\n@@ -739,1 +866,1 @@\n-            byte sigBytes[] = null;\n+            byte[] sigBytes = null;\n@@ -744,0 +871,1 @@\n+                LOG.debug(\"jceSigProvider = {}\", sa.getJCEProviderName());\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignature.java","additions":179,"deletions":51,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    public XMLSignatureException(String msgID, Object exArgs[]) {\n+    public XMLSignatureException(String msgID, Object[] exArgs) {\n@@ -92,1 +92,1 @@\n-    public XMLSignatureException(Exception originalException, String msgID, Object exArgs[]) {\n+    public XMLSignatureException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -36,2 +35,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -43,0 +40,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -47,1 +45,0 @@\n-import org.xml.sax.SAXException;\n@@ -194,1 +191,1 @@\n-     * @throws SAXException\n+     * @throws XMLParserException\n@@ -196,2 +193,0 @@\n-     * @throws ParserConfigurationException\n-     * @throws CanonicalizationException\n@@ -199,2 +194,1 @@\n-    public Set<Node> getNodeSet() throws CanonicalizationException, ParserConfigurationException,\n-        IOException, SAXException {\n+    public Set<Node> getNodeSet() throws XMLParserException, IOException {\n@@ -218,1 +212,1 @@\n-     * @throws SAXException\n+     * @throws XMLParserException\n@@ -220,2 +214,0 @@\n-     * @throws ParserConfigurationException\n-     * @throws CanonicalizationException\n@@ -223,2 +215,1 @@\n-    public Set<Node> getNodeSet(boolean circumvent) throws ParserConfigurationException,\n-        IOException, SAXException, CanonicalizationException {\n+    public Set<Node> getNodeSet(boolean circumvent) throws XMLParserException, IOException {\n@@ -232,1 +223,1 @@\n-            inputNodeSet = new LinkedHashSet<Node>();\n+            inputNodeSet = new LinkedHashSet<>();\n@@ -237,1 +228,1 @@\n-            Set<Node> result = new LinkedHashSet<Node>();\n+            Set<Node> result = new LinkedHashSet<>();\n@@ -288,2 +279,7 @@\n-        Canonicalizer20010315OmitComments c14nizer = new Canonicalizer20010315OmitComments();\n-        bytes = c14nizer.engineCanonicalize(this);\n+        if (isOctetStream() || isElement() || isNodeSet()) {\n+            Canonicalizer20010315OmitComments c14nizer = new Canonicalizer20010315OmitComments();\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n+                c14nizer.engineCanonicalize(this, baos, secureValidation);\n+                bytes = baos.toByteArray();\n+            }\n+        }\n@@ -336,1 +332,1 @@\n-     * @return true is the object has been set up with an octet stream\n+     * @return true if the object has been set up with an octet stream\n@@ -344,1 +340,1 @@\n-     * @return\n+     * @return true if the object has been set up with a pre-calculated digest.\n@@ -410,1 +406,3 @@\n-            return \"XMLSignatureInput\/OctetStream\/\" + getBytes().length\n+            byte[] bytes = getBytes();\n+            return \"XMLSignatureInput\/OctetStream\/\"\n+                   + (bytes != null ? bytes.length : 0)\n@@ -412,3 +410,1 @@\n-        } catch (IOException iex) {\n-            return \"XMLSignatureInput\/OctetStream\/\/\" + getSourceURI();\n-        } catch (CanonicalizationException cex) {\n+        } catch (IOException | CanonicalizationException ex) {\n@@ -506,2 +502,1 @@\n-            c14nizer.setWriter(diOs);\n-            c14nizer.engineCanonicalize(this);\n+            c14nizer.engineCanonicalize(this, diOs, secureValidation);\n@@ -574,2 +569,1 @@\n-    void convertToNodes() throws CanonicalizationException,\n-        ParserConfigurationException, IOException, SAXException {\n+    private void convertToNodes() throws XMLParserException, IOException {\n@@ -580,15 +574,0 @@\n-        } catch (SAXException ex) {\n-            byte[] result = null;\n-            \/\/ if a not-wellformed nodeset exists, put a container around it...\n-            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n-\n-                baos.write(\"<container>\".getBytes(StandardCharsets.UTF_8));\n-                baos.write(this.getBytes());\n-                baos.write(\"<\/container>\".getBytes(StandardCharsets.UTF_8));\n-\n-                result = baos.toByteArray();\n-            }\n-            try (InputStream is = new ByteArrayInputStream(result)) {\n-                Document document = XMLUtils.read(is, secureValidation);\n-                this.subNode = document.getDocumentElement().getFirstChild().getFirstChild();\n-            }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureInput.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        + \"<title>Caninical XML node set<\/title>\\n\"\n+        + \"<title>Canonical XML node set<\/title>\\n\"\n@@ -298,1 +298,1 @@\n-            Object attrs3[] = attrs2;\n+            Object[] attrs3 = attrs2;\n@@ -519,3 +519,1 @@\n-                switch (c) {\n-\n-                case 0x0D:\n+                if (c == 0x0D) {\n@@ -523,3 +521,1 @@\n-                    break;\n-\n-                default:\n+                } else {\n@@ -527,1 +523,0 @@\n-                    break;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureInputDebugger.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/reference\/ReferenceData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/reference\/ReferenceNodeSetData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/reference\/ReferenceOctetStreamData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +127,1 @@\n-         * @param the previous sibling node\n+         * @param prevSibling the previous sibling node\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/reference\/ReferenceSubTreeData.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public InvalidTransformException(String msgId, Object exArgs[]) {\n+    public InvalidTransformException(String msgId, Object[] exArgs) {\n@@ -86,1 +86,1 @@\n-    public InvalidTransformException(Exception originalException, String msgId, Object exArgs[]) {\n+    public InvalidTransformException(Exception originalException, String msgId, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/InvalidTransformException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -75,2 +76,1 @@\n-    private static Map<String, Class<? extends TransformSpi>> transformSpiHash =\n-        new ConcurrentHashMap<String, Class<? extends TransformSpi>>();\n+    private static Map<String, TransformSpi> transformSpiHash = new ConcurrentHashMap<>();\n@@ -79,1 +79,0 @@\n-    private boolean secureValidation;\n@@ -109,1 +108,2 @@\n-        HelperNodeList contextNodes = null;\n+        setLocalAttribute(Constants._ATT_ALGORITHM, algorithmURI);\n+        transformSpi = initializeTransform(algorithmURI);\n@@ -112,1 +112,1 @@\n-            contextNodes = new HelperNodeList();\n+            HelperNodeList contextNodes = new HelperNodeList();\n@@ -117,1 +117,0 @@\n-        }\n@@ -119,1 +118,7 @@\n-        transformSpi = initializeTransform(algorithmURI, contextNodes);\n+            int length = contextNodes.getLength();\n+            for (int i = 0; i < length; i++) {\n+                appendSelf(contextNodes.item(i).cloneNode(true));\n+            }\n+\n+            LOG.debug(\"The NodeList is {}\", contextNodes);\n+        }\n@@ -134,1 +139,11 @@\n-        transformSpi = initializeTransform(algorithmURI, contextNodes);\n+        setLocalAttribute(Constants._ATT_ALGORITHM, algorithmURI);\n+        transformSpi = initializeTransform(algorithmURI);\n+\n+        if (contextNodes != null) {\n+            int length = contextNodes.getLength();\n+            for (int i = 0; i < length; i++) {\n+                appendSelf(contextNodes.item(i).cloneNode(true));\n+            }\n+\n+            LOG.debug(\"The NodeList is {}\", contextNodes);\n+        }\n@@ -152,1 +167,1 @@\n-            Object exArgs[] = { Constants._ATT_ALGORITHM, Constants._TAG_TRANSFORM };\n+            Object[] exArgs = { Constants._ATT_ALGORITHM, Constants._TAG_TRANSFORM };\n@@ -156,20 +171,1 @@\n-        Class<? extends TransformSpi> transformSpiClass = transformSpiHash.get(algorithmURI);\n-        if (transformSpiClass == null) {\n-            Object exArgs[] = { algorithmURI };\n-            throw new InvalidTransformException(\"signature.Transform.UnknownTransform\", exArgs);\n-        }\n-        try {\n-            @SuppressWarnings(\"deprecation\")\n-            TransformSpi tmp = transformSpiClass.newInstance();\n-            transformSpi = tmp;\n-        } catch (InstantiationException ex) {\n-            Object exArgs[] = { algorithmURI };\n-            throw new InvalidTransformException(\n-                ex, \"signature.Transform.UnknownTransform\", exArgs\n-            );\n-        } catch (IllegalAccessException ex) {\n-            Object exArgs[] = { algorithmURI };\n-            throw new InvalidTransformException(\n-                ex, \"signature.Transform.UnknownTransform\", exArgs\n-            );\n-        }\n+        transformSpi = initializeTransform(algorithmURI);\n@@ -186,0 +182,2 @@\n+     * @throws ClassNotFoundException if the implementing Class cannot be found\n+     * @throws InvalidTransformException if the implementing Class cannot be instantiated\n@@ -195,1 +193,1 @@\n-        Class<? extends TransformSpi> transformSpi = transformSpiHash.get(algorithmURI);\n+        TransformSpi transformSpi = transformSpiHash.get(algorithmURI);\n@@ -197,1 +195,1 @@\n-            Object exArgs[] = { algorithmURI, transformSpi };\n+            Object[] exArgs = { algorithmURI, transformSpi };\n@@ -203,1 +201,8 @@\n-        transformSpiHash.put(algorithmURI, transformSpiClass);\n+        try {\n+            transformSpiHash.put(algorithmURI, JavaUtils.newInstanceWithEmptyConstructor(transformSpiClass));\n+        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n+            Object[] exArgs = { algorithmURI };\n+            throw new InvalidTransformException(\n+                ex, \"signature.Transform.UnknownTransform\", exArgs\n+            );\n+        }\n@@ -214,0 +219,1 @@\n+     * @throws InvalidTransformException if the implementing Class cannot be instantiated\n@@ -218,1 +224,1 @@\n-        throws AlgorithmAlreadyRegisteredException {\n+        throws AlgorithmAlreadyRegisteredException, InvalidTransformException {\n@@ -221,1 +227,1 @@\n-        Class<? extends TransformSpi> transformSpi = transformSpiHash.get(algorithmURI);\n+        TransformSpi transformSpi = transformSpiHash.get(algorithmURI);\n@@ -223,1 +229,1 @@\n-            Object exArgs[] = { algorithmURI, transformSpi };\n+            Object[] exArgs = { algorithmURI, transformSpi };\n@@ -226,1 +232,8 @@\n-        transformSpiHash.put(algorithmURI, implementingClass);\n+        try {\n+            transformSpiHash.put(algorithmURI, JavaUtils.newInstanceWithEmptyConstructor(implementingClass));\n+        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n+            Object[] exArgs = { algorithmURI };\n+            throw new InvalidTransformException(\n+                ex, \"signature.Transform.UnknownTransform\", exArgs\n+            );\n+        }\n@@ -234,1 +247,1 @@\n-            Transforms.TRANSFORM_BASE64_DECODE, TransformBase64Decode.class\n+            Transforms.TRANSFORM_BASE64_DECODE, new TransformBase64Decode()\n@@ -237,1 +250,1 @@\n-            Transforms.TRANSFORM_C14N_OMIT_COMMENTS, TransformC14N.class\n+            Transforms.TRANSFORM_C14N_OMIT_COMMENTS, new TransformC14N()\n@@ -240,1 +253,1 @@\n-            Transforms.TRANSFORM_C14N_WITH_COMMENTS, TransformC14NWithComments.class\n+            Transforms.TRANSFORM_C14N_WITH_COMMENTS, new TransformC14NWithComments()\n@@ -243,1 +256,1 @@\n-            Transforms.TRANSFORM_C14N11_OMIT_COMMENTS, TransformC14N11.class\n+            Transforms.TRANSFORM_C14N11_OMIT_COMMENTS, new TransformC14N11()\n@@ -246,1 +259,1 @@\n-            Transforms.TRANSFORM_C14N11_WITH_COMMENTS, TransformC14N11_WithComments.class\n+            Transforms.TRANSFORM_C14N11_WITH_COMMENTS, new TransformC14N11_WithComments()\n@@ -249,1 +262,1 @@\n-            Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS, TransformC14NExclusive.class\n+            Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS, new TransformC14NExclusive()\n@@ -252,1 +265,1 @@\n-            Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS, TransformC14NExclusiveWithComments.class\n+            Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS, new TransformC14NExclusiveWithComments()\n@@ -255,1 +268,1 @@\n-            Transforms.TRANSFORM_XPATH, TransformXPath.class\n+            Transforms.TRANSFORM_XPATH, new TransformXPath()\n@@ -258,1 +271,1 @@\n-            Transforms.TRANSFORM_ENVELOPED_SIGNATURE, TransformEnvelopedSignature.class\n+            Transforms.TRANSFORM_ENVELOPED_SIGNATURE, new TransformEnvelopedSignature()\n@@ -261,1 +274,1 @@\n-            Transforms.TRANSFORM_XSLT, TransformXSLT.class\n+            Transforms.TRANSFORM_XSLT, new TransformXSLT()\n@@ -264,1 +277,1 @@\n-            Transforms.TRANSFORM_XPATH2FILTER, TransformXPath2Filter.class\n+            Transforms.TRANSFORM_XPATH2FILTER, new TransformXPath2Filter()\n@@ -282,0 +295,1 @@\n+     * @param secureValidation Whether secure validation is enabled\n@@ -289,1 +303,1 @@\n-    public XMLSignatureInput performTransform(XMLSignatureInput input)\n+    public XMLSignatureInput performTransform(XMLSignatureInput input, boolean secureValidation)\n@@ -292,1 +306,1 @@\n-        return performTransform(input, null);\n+        return performTransform(input, null, secureValidation);\n@@ -301,0 +315,1 @@\n+     * @param secureValidation Whether secure validation is enabled\n@@ -309,1 +324,1 @@\n-        XMLSignatureInput input, OutputStream os\n+        XMLSignatureInput input, OutputStream os, boolean secureValidation\n@@ -315,2 +330,1 @@\n-            transformSpi.secureValidation = secureValidation;\n-            result = transformSpi.enginePerformTransform(input, os, this);\n+            result = transformSpi.enginePerformTransform(input, os, getElement(), baseURI, secureValidation);\n@@ -318,1 +332,1 @@\n-            Object exArgs[] = { this.getURI(), \"ParserConfigurationException\" };\n+            Object[] exArgs = { this.getURI(), \"ParserConfigurationException\" };\n@@ -322,1 +336,1 @@\n-            Object exArgs[] = { this.getURI(), \"SAXException\" };\n+            Object[] exArgs = { this.getURI(), \"SAXException\" };\n@@ -338,1 +352,1 @@\n-    private TransformSpi initializeTransform(String algorithmURI, NodeList contextNodes)\n+    private TransformSpi initializeTransform(String algorithmURI)\n@@ -341,5 +355,3 @@\n-        setLocalAttribute(Constants._ATT_ALGORITHM, algorithmURI);\n-\n-        Class<? extends TransformSpi> transformSpiClass = transformSpiHash.get(algorithmURI);\n-        if (transformSpiClass == null) {\n-            Object exArgs[] = { algorithmURI };\n+        TransformSpi newTransformSpi = transformSpiHash.get(algorithmURI);\n+        if (newTransformSpi == null) {\n+            Object[] exArgs = { algorithmURI };\n@@ -348,16 +360,0 @@\n-        TransformSpi newTransformSpi = null;\n-        try {\n-            @SuppressWarnings(\"deprecation\")\n-            TransformSpi tmp = transformSpiClass.newInstance();\n-            newTransformSpi = tmp;\n-        } catch (InstantiationException ex) {\n-            Object exArgs[] = { algorithmURI };\n-            throw new InvalidTransformException(\n-                ex, \"signature.Transform.UnknownTransform\", exArgs\n-            );\n-        } catch (IllegalAccessException ex) {\n-            Object exArgs[] = { algorithmURI };\n-            throw new InvalidTransformException(\n-                ex, \"signature.Transform.UnknownTransform\", exArgs\n-            );\n-        }\n@@ -366,9 +362,0 @@\n-        LOG.debug(\"The NodeList is {}\", contextNodes);\n-\n-        \/\/ give it to the current document\n-        if (contextNodes != null) {\n-            int length = contextNodes.getLength();\n-            for (int i = 0; i < length; i++) {\n-                appendSelf(contextNodes.item(i).cloneNode(true));\n-            }\n-        }\n@@ -378,8 +365,0 @@\n-    public boolean isSecureValidation() {\n-        return secureValidation;\n-    }\n-\n-    public void setSecureValidation(boolean secureValidation) {\n-        this.secureValidation = secureValidation;\n-    }\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/Transform.java","additions":72,"deletions":93,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import org.w3c.dom.Element;\n@@ -37,1 +38,1 @@\n- * {@link #enginePerformTransform(XMLSignatureInput, Transform)} method.\n+ * {@link #enginePerformTransform(XMLSignatureInput, OutputStream, Element, String, boolean)} method.\n@@ -39,0 +40,1 @@\n+ * Extensions of this class must be thread-safe.\n@@ -42,1 +44,0 @@\n-    protected boolean secureValidation;\n@@ -49,1 +50,3 @@\n-     * @param transformObject the Transform object\n+     * @param transformElement the Transform element\n+     * @param baseURI The baseURI\n+     * @param secureValidation Whether secure validation is enabled\n@@ -58,2 +61,3 @@\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+    protected abstract XMLSignatureInput enginePerformTransform(\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -61,45 +65,1 @@\n-        TransformationException, ParserConfigurationException, SAXException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/**\n-     * The mega method which MUST be implemented by the Transformation Algorithm.\n-     * In order to be compatible with preexisting Transform implementations,\n-     * by default this implementation invokes the deprecated, thread-unsafe\n-     * methods. Subclasses should override this with a thread-safe\n-     * implementation.\n-     *\n-     * @param input {@link XMLSignatureInput} as the input of transformation\n-     * @param transformObject the Transform object\n-     * @return {@link XMLSignatureInput} as the result of transformation\n-     * @throws CanonicalizationException\n-     * @throws IOException\n-     * @throws InvalidCanonicalizerException\n-     * @throws ParserConfigurationException\n-     * @throws SAXException\n-     * @throws TransformationException\n-     *\/\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, Transform transformObject\n-    ) throws IOException, CanonicalizationException, InvalidCanonicalizerException,\n-        TransformationException, ParserConfigurationException, SAXException {\n-        return enginePerformTransform(input, null, transformObject);\n-    }\n-\n-    \/**\n-     * The mega method which MUST be implemented by the Transformation Algorithm.\n-     * @param input {@link XMLSignatureInput} as the input of transformation\n-     * @return {@link XMLSignatureInput} as the result of transformation\n-     * @throws CanonicalizationException\n-     * @throws IOException\n-     * @throws InvalidCanonicalizerException\n-     * @throws ParserConfigurationException\n-     * @throws SAXException\n-     * @throws TransformationException\n-     *\/\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input\n-    ) throws IOException, CanonicalizationException, InvalidCanonicalizerException,\n-        TransformationException, ParserConfigurationException, SAXException {\n-        return enginePerformTransform(input, null);\n-    }\n+        TransformationException, ParserConfigurationException, SAXException;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/TransformSpi.java","additions":10,"deletions":50,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public TransformationException(String msgID, Object exArgs[]) {\n+    public TransformationException(String msgID, Object[] exArgs) {\n@@ -89,1 +89,1 @@\n-    public TransformationException(Exception originalException, String msgID, Object exArgs[]) {\n+    public TransformationException(Exception originalException, String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/TransformationException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    private Element[] transforms;\n+    private Element[] transformsElement;\n@@ -144,1 +144,1 @@\n-            Object exArgs[] = { Constants._TAG_TRANSFORM, Constants._TAG_TRANSFORMS };\n+            Object[] exArgs = { Constants._TAG_TRANSFORM, Constants._TAG_TRANSFORMS };\n@@ -265,1 +265,1 @@\n-                xmlSignatureInput = t.performTransform(xmlSignatureInput);\n+                xmlSignatureInput = t.performTransform(xmlSignatureInput, secureValidation);\n@@ -271,1 +271,1 @@\n-                xmlSignatureInput = t.performTransform(xmlSignatureInput, os);\n+                xmlSignatureInput = t.performTransform(xmlSignatureInput, os, secureValidation);\n@@ -275,5 +275,1 @@\n-        } catch (IOException ex) {\n-            throw new TransformationException(ex);\n-        } catch (CanonicalizationException ex) {\n-            throw new TransformationException(ex);\n-        } catch (InvalidCanonicalizerException ex) {\n+        } catch (IOException | CanonicalizationException | InvalidCanonicalizerException ex) {\n@@ -287,1 +283,1 @@\n-            Object exArgs[] = { uri };\n+            Object[] exArgs = { uri };\n@@ -293,1 +289,0 @@\n-        transform.setSecureValidation(secureValidation);\n@@ -303,1 +298,1 @@\n-        return transforms.length;\n+        return transformsElement.length;\n@@ -317,1 +312,1 @@\n-            return new Transform(transforms[i], this.baseURI);\n+            return new Transform(transformsElement[i], this.baseURI);\n@@ -324,2 +319,2 @@\n-        if (transforms == null) {\n-            transforms = XMLUtils.selectDsNodes(getFirstChild(), \"Transform\");\n+        if (transformsElement == null) {\n+            transformsElement = XMLUtils.selectDsNodes(getFirstChild(), \"Transform\");\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/Transforms.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    public void fixupVariables(List<QName> vars, int globalsSize) {\n+    public void fixupVariables(List<QName> vars, int globalsSize) { \/\/NOPMD\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/FuncHere.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n-\n@@ -32,1 +30,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -37,1 +34,0 @@\n-import org.w3c.dom.Document;\n@@ -41,1 +37,0 @@\n-import org.xml.sax.SAXException;\n@@ -71,4 +66,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_BASE64_DECODE;\n-\n@@ -76,2 +67,0 @@\n-     * Method engineGetURI\n-     *\n@@ -80,0 +69,1 @@\n+    @Override\n@@ -81,1 +71,1 @@\n-        return TransformBase64Decode.implementedTransformURI;\n+        return Transforms.TRANSFORM_BASE64_DECODE;\n@@ -85,4 +75,0 @@\n-     * Method enginePerformTransform\n-     *\n-     * @param input\n-     * @return {@link XMLSignatureInput} as the result of transformation\n@@ -90,3 +76,0 @@\n-     * @throws CanonicalizationException\n-     * @throws IOException\n-     * @throws TransformationException\n@@ -94,0 +77,1 @@\n+    @Override\n@@ -95,7 +79,2 @@\n-        XMLSignatureInput input, Transform transformObject\n-    ) throws IOException, CanonicalizationException, TransformationException {\n-        return enginePerformTransform(input, null, transformObject);\n-    }\n-\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -122,3 +101,1 @@\n-        }\n-\n-        if (input.isOctetStream() || input.isNodeSet()) {\n+        } else if (input.isOctetStream() || input.isNodeSet()) {\n@@ -146,18 +123,1 @@\n-        try {\n-            \/\/Exceptional case there is current not text case testing this(Before it was a\n-            \/\/a common case).\n-            Document doc =\n-                XMLUtils.read(input.getOctetStream(), secureValidation);\n-\n-            Element rootNode = doc.getDocumentElement();\n-            StringBuilder sb = new StringBuilder();\n-            traverseElement(rootNode, sb);\n-            byte[] decodedBytes = XMLUtils.decode(sb.toString());\n-            XMLSignatureInput output = new XMLSignatureInput(decodedBytes);\n-            output.setSecureValidation(secureValidation);\n-            return output;\n-        } catch (ParserConfigurationException e) {\n-            throw new TransformationException(e, \"c14n.Canonicalizer.Exception\");\n-        } catch (SAXException e) {\n-            throw new TransformationException(e, \"SAX exception\");\n-        }\n+        throw new TransformationException(\"empty\", new Object[] {\"Unrecognized XMLSignatureInput state\"});\n@@ -166,1 +126,1 @@\n-    void traverseElement(Element node, StringBuilder sb) {\n+    private void traverseElement(Element node, StringBuilder sb) {\n@@ -169,2 +129,1 @@\n-            switch (sibling.getNodeType()) {\n-            case Node.ELEMENT_NODE:\n+            if (Node.ELEMENT_NODE == sibling.getNodeType()) {\n@@ -172,2 +131,1 @@\n-                break;\n-            case Node.TEXT_NODE:\n+            } else if (Node.TEXT_NODE == sibling.getNodeType()) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformBase64Decode.java","additions":10,"deletions":52,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n@@ -28,0 +30,1 @@\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315;\n@@ -30,1 +33,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -33,0 +35,1 @@\n+import org.w3c.dom.Element;\n@@ -41,4 +44,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_C14N_OMIT_COMMENTS;\n-\n@@ -48,0 +47,1 @@\n+    @Override\n@@ -49,1 +49,1 @@\n-        return TransformC14N.implementedTransformURI;\n+        return Transforms.TRANSFORM_C14N_OMIT_COMMENTS;\n@@ -52,0 +52,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -53,1 +57,2 @@\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -55,10 +60,17 @@\n-        Canonicalizer20010315OmitComments c14n = new Canonicalizer20010315OmitComments();\n-        c14n.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            c14n.setWriter(os);\n-        }\n-        byte[] result = null;\n-        result = c14n.engineCanonicalize(input);\n-        XMLSignatureInput output = new XMLSignatureInput(result);\n-        output.setSecureValidation(secureValidation);\n-        if (os != null) {\n+\n+        Canonicalizer20010315 c14n = getCanonicalizer();\n+\n+        if (os == null) {\n+            try (ByteArrayOutputStream writer = new ByteArrayOutputStream()) {\n+                c14n.engineCanonicalize(input, writer, secureValidation);\n+                writer.flush();\n+                XMLSignatureInput output = new XMLSignatureInput(writer.toByteArray());\n+                output.setSecureValidation(secureValidation);\n+                return output;\n+            } catch (IOException ex) {\n+                throw new CanonicalizationException(\"empty\", new Object[] {ex.getMessage()});\n+            }\n+        } else {\n+            c14n.engineCanonicalize(input, os, secureValidation);\n+            XMLSignatureInput output = new XMLSignatureInput((byte[])null);\n+            output.setSecureValidation(secureValidation);\n@@ -66,0 +78,1 @@\n+            return output;\n@@ -67,1 +80,4 @@\n-        return output;\n+    }\n+\n+    protected Canonicalizer20010315 getCanonicalizer() {\n+        return new Canonicalizer20010315OmitComments();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14N.java","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.io.OutputStream;\n-\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n@@ -29,3 +26,1 @@\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315;\n@@ -37,1 +32,0 @@\n- *\n@@ -39,1 +33,1 @@\n-public class TransformC14N11 extends TransformSpi {\n+public class TransformC14N11 extends TransformC14N {\n@@ -41,0 +35,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -45,16 +43,6 @@\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transform\n-    ) throws CanonicalizationException {\n-        Canonicalizer11_OmitComments c14n = new Canonicalizer11_OmitComments();\n-        c14n.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            c14n.setWriter(os);\n-        }\n-        byte[] result = null;\n-        result = c14n.engineCanonicalize(input);\n-        XMLSignatureInput output = new XMLSignatureInput(result);\n-        output.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            output.setOutputStream(os);\n-        }\n-        return output;\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    protected Canonicalizer20010315 getCanonicalizer() {\n+        return new Canonicalizer11_OmitComments();\n@@ -62,0 +50,1 @@\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14N11.java","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.io.OutputStream;\n-\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n@@ -29,3 +26,1 @@\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315;\n@@ -39,1 +34,1 @@\n-public class TransformC14N11_WithComments extends TransformSpi {\n+public class TransformC14N11_WithComments extends TransformC14N {\n@@ -41,0 +36,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -45,18 +44,6 @@\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transform\n-    ) throws CanonicalizationException {\n-\n-        Canonicalizer11_WithComments c14n = new Canonicalizer11_WithComments();\n-        c14n.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            c14n.setWriter(os);\n-        }\n-\n-        byte[] result = null;\n-        result = c14n.engineCanonicalize(input);\n-        XMLSignatureInput output = new XMLSignatureInput(result);\n-        output.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            output.setOutputStream(os);\n-        }\n-        return output;\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    protected Canonicalizer20010315 getCanonicalizer() {\n+        return new Canonicalizer11_WithComments();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14N11_WithComments.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n@@ -28,0 +30,1 @@\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315Excl;\n@@ -31,1 +34,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -37,0 +39,1 @@\n+import org.w3c.dom.Node;\n@@ -44,4 +47,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS;\n-\n@@ -49,2 +48,0 @@\n-     * Method engineGetURI\n-     *\n@@ -53,0 +50,1 @@\n+    @Override\n@@ -54,1 +52,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS;\n@@ -57,0 +55,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -58,1 +60,2 @@\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -63,1 +66,1 @@\n-            if (transformObject.length(\n+            if (length(transformElement,\n@@ -69,1 +72,1 @@\n-                        transformObject.getElement().getFirstChild(),\n+                        transformElement.getFirstChild(),\n@@ -77,1 +80,1 @@\n-                        inclusiveElement, transformObject.getBaseURI()).getInclusiveNamespaces();\n+                        inclusiveElement, baseURI).getInclusiveNamespaces();\n@@ -80,7 +83,1 @@\n-            Canonicalizer20010315ExclOmitComments c14n =\n-                new Canonicalizer20010315ExclOmitComments();\n-            c14n.setSecureValidation(secureValidation);\n-            if (os != null) {\n-                c14n.setWriter(os);\n-            }\n-            byte[] result = c14n.engineCanonicalize(input, inclusiveNamespaces);\n+            Canonicalizer20010315Excl c14n = getCanonicalizer();\n@@ -88,3 +85,14 @@\n-            XMLSignatureInput output = new XMLSignatureInput(result);\n-            output.setSecureValidation(secureValidation);\n-            if (os != null) {\n+            if (os == null) {\n+                try (ByteArrayOutputStream writer = new ByteArrayOutputStream()) {\n+                    c14n.engineCanonicalize(input, inclusiveNamespaces, writer, secureValidation);\n+                    writer.flush();\n+                    XMLSignatureInput output = new XMLSignatureInput(writer.toByteArray());\n+                    output.setSecureValidation(secureValidation);\n+                    return output;\n+                } catch (IOException ex) {\n+                    throw new CanonicalizationException(\"empty\", new Object[] {ex.getMessage()});\n+                }\n+            } else {\n+                c14n.engineCanonicalize(input, inclusiveNamespaces, os, secureValidation);\n+                XMLSignatureInput output = new XMLSignatureInput((byte[])null);\n+                output.setSecureValidation(secureValidation);\n@@ -92,0 +100,1 @@\n+                return output;\n@@ -93,1 +102,0 @@\n-            return output;\n@@ -98,0 +106,24 @@\n+\n+    protected Canonicalizer20010315Excl getCanonicalizer() {\n+        return new Canonicalizer20010315ExclOmitComments();\n+    }\n+\n+    \/**\n+     * Method length\n+     *\n+     * @param namespace\n+     * @param localname\n+     * @return the number of elements {namespace}:localname under this element\n+     *\/\n+    private int length(Element element, String namespace, String localname) {\n+        int number = 0;\n+        Node sibling = element.getFirstChild();\n+        while (sibling != null) {\n+            if (localname.equals(sibling.getLocalName())\n+                && namespace.equals(sibling.getNamespaceURI())) {\n+                number++;\n+            }\n+            sibling = sibling.getNextSibling();\n+        }\n+        return number;\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14NExclusive.java","additions":55,"deletions":23,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n-import java.io.OutputStream;\n-\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315Excl;\n@@ -29,4 +27,0 @@\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;\n@@ -34,3 +28,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-import org.w3c.dom.Element;\n@@ -43,5 +34,1 @@\n-public class TransformC14NExclusiveWithComments extends TransformSpi {\n-\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS;\n+public class TransformC14NExclusiveWithComments extends TransformC14NExclusive {\n@@ -50,3 +37,1 @@\n-     * Method engineGetURI\n-     *{@inheritDoc}\n-     *\n+     * {@inheritDoc}\n@@ -54,0 +39,1 @@\n+    @Override\n@@ -55,1 +41,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS;\n@@ -58,38 +44,3 @@\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n-    ) throws CanonicalizationException {\n-        try {\n-            String inclusiveNamespaces = null;\n-\n-            if (transformObject.length(\n-                InclusiveNamespaces.ExclusiveCanonicalizationNamespace,\n-                InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES) == 1\n-            ) {\n-                Element inclusiveElement =\n-                    XMLUtils.selectNode(\n-                        transformObject.getElement().getFirstChild(),\n-                        InclusiveNamespaces.ExclusiveCanonicalizationNamespace,\n-                        InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES,\n-                        0\n-                    );\n-\n-                inclusiveNamespaces =\n-                    new InclusiveNamespaces(\n-                        inclusiveElement, transformObject.getBaseURI()\n-                    ).getInclusiveNamespaces();\n-            }\n-\n-            Canonicalizer20010315ExclWithComments c14n =\n-                new Canonicalizer20010315ExclWithComments();\n-            c14n.setSecureValidation(secureValidation);\n-            if (os != null) {\n-                c14n.setWriter(os);\n-            }\n-            byte[] result = c14n.engineCanonicalize(input, inclusiveNamespaces);\n-            XMLSignatureInput output = new XMLSignatureInput(result);\n-            output.setSecureValidation(secureValidation);\n-\n-            return output;\n-        } catch (XMLSecurityException ex) {\n-            throw new CanonicalizationException(ex);\n-        }\n+    @Override\n+    protected Canonicalizer20010315Excl getCanonicalizer() {\n+        return new Canonicalizer20010315ExclWithComments();\n@@ -97,0 +48,1 @@\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14NExclusiveWithComments.java","additions":9,"deletions":57,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n-import java.io.OutputStream;\n-\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n+import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315;\n@@ -29,3 +27,0 @@\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;\n@@ -37,1 +32,0 @@\n- *\n@@ -39,5 +33,1 @@\n-public class TransformC14NWithComments extends TransformSpi {\n-\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_C14N_WITH_COMMENTS;\n+public class TransformC14NWithComments extends TransformC14N {\n@@ -45,1 +35,4 @@\n-    \/** {@inheritDoc} *\/\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -47,1 +40,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_C14N_WITH_COMMENTS;\n@@ -50,19 +43,6 @@\n-    \/** {@inheritDoc} *\/\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n-    ) throws CanonicalizationException {\n-\n-        Canonicalizer20010315WithComments c14n = new Canonicalizer20010315WithComments();\n-        c14n.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            c14n.setWriter(os);\n-        }\n-\n-        byte[] result = null;\n-        result = c14n.engineCanonicalize(input);\n-        XMLSignatureInput output = new XMLSignatureInput(result);\n-        output.setSecureValidation(secureValidation);\n-        if (os != null) {\n-            output.setOutputStream(os);\n-        }\n-        return output;\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    protected Canonicalizer20010315 getCanonicalizer() {\n+        return new Canonicalizer20010315WithComments();\n@@ -70,0 +50,1 @@\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14NWithComments.java","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -45,4 +44,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_ENVELOPED_SIGNATURE;\n-\n@@ -50,2 +45,0 @@\n-     * Method engineGetURI\n-     *\n@@ -54,0 +47,1 @@\n+    @Override\n@@ -55,1 +49,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_ENVELOPED_SIGNATURE;\n@@ -61,0 +55,1 @@\n+    @Override\n@@ -62,1 +57,2 @@\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -76,3 +72,1 @@\n-        Node signatureElement = transformObject.getElement();\n-\n-        signatureElement = searchSignatureElement(signatureElement);\n+        Node signatureElement = searchSignatureElement(transformElement);\n@@ -117,1 +111,1 @@\n-        Node exclude;\n+        private final Node exclude;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformEnvelopedSignature.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -55,3 +54,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI = Transforms.TRANSFORM_XPATH;\n-\n@@ -59,2 +55,0 @@\n-     * Method engineGetURI\n-     *\n@@ -63,0 +57,1 @@\n+    @Override\n@@ -64,1 +59,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_XPATH;\n@@ -68,1 +63,0 @@\n-     * Method enginePerformTransform\n@@ -70,3 +64,0 @@\n-     * @param input\n-     *\n-     * @throws TransformationException\n@@ -74,0 +65,1 @@\n+    @Override\n@@ -75,1 +67,2 @@\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -91,1 +84,1 @@\n-                    transformObject.getElement().getFirstChild(), Constants._TAG_XPATH, 0);\n+                    transformElement.getFirstChild(), Constants._TAG_XPATH, 0);\n@@ -94,1 +87,1 @@\n-                Object exArgs[] = { \"ds:XPath\", \"Transform\" };\n+                Object[] exArgs = { \"ds:XPath\", \"Transform\" };\n@@ -107,1 +100,1 @@\n-            XPathFactory xpathFactory = XPathFactory.newInstance();\n+            XPathFactory xpathFactory = getXPathFactory();\n@@ -117,0 +110,4 @@\n+    protected XPathFactory getXPathFactory() {\n+        return XPathFactory.newInstance();\n+    }\n+\n@@ -125,1 +122,1 @@\n-    static class XPathNodeFilter implements NodeFilter {\n+    private static class XPathNodeFilter implements NodeFilter {\n@@ -127,4 +124,4 @@\n-        XPathAPI xPathAPI;\n-        Node xpathnode;\n-        Element xpathElement;\n-        String str;\n+        private final XPathAPI xPathAPI;\n+        private final Node xpathnode;\n+        private final Element xpathElement;\n+        private final String str;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -35,2 +34,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n-import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;\n@@ -40,1 +37,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -53,1 +49,0 @@\n-import org.xml.sax.SAXException;\n@@ -62,4 +57,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_XPATH2FILTER;\n-\n@@ -67,2 +58,0 @@\n-     * Method engineGetURI\n-     *\n@@ -71,0 +60,1 @@\n+    @Override\n@@ -72,1 +62,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_XPATH2FILTER;\n@@ -76,1 +66,0 @@\n-     * Method enginePerformTransform\n@@ -78,3 +67,0 @@\n-     * @param input\n-     *\n-     * @throws TransformationException\n@@ -82,0 +68,1 @@\n+    @Override\n@@ -83,1 +70,2 @@\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n+        XMLSignatureInput input, OutputStream os, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -92,1 +80,1 @@\n-                    transformObject.getElement().getFirstChild(),\n+                    transformElement.getFirstChild(),\n@@ -97,1 +85,1 @@\n-                Object exArgs[] = { Transforms.TRANSFORM_XPATH2FILTER, \"XPath\" };\n+                Object[] exArgs = { Transforms.TRANSFORM_XPATH2FILTER, \"XPath\" };\n@@ -109,0 +97,1 @@\n+            XPathFactory xpathFactory = XPathFactory.newInstance();\n@@ -118,1 +107,0 @@\n-                XPathFactory xpathFactory = XPathFactory.newInstance();\n@@ -141,15 +129,1 @@\n-        } catch (TransformerException ex) {\n-            throw new TransformationException(ex);\n-        } catch (DOMException ex) {\n-            throw new TransformationException(ex);\n-        } catch (CanonicalizationException ex) {\n-            throw new TransformationException(ex);\n-        } catch (InvalidCanonicalizerException ex) {\n-            throw new TransformationException(ex);\n-        } catch (XMLSecurityException ex) {\n-            throw new TransformationException(ex);\n-        } catch (SAXException ex) {\n-            throw new TransformationException(ex);\n-        } catch (IOException ex) {\n-            throw new TransformationException(ex);\n-        } catch (ParserConfigurationException ex) {\n+        } catch (TransformerException | DOMException | XMLSecurityException | IOException ex) {\n@@ -163,9 +137,9 @@\n-    boolean hasUnionFilter;\n-    boolean hasSubtractFilter;\n-    boolean hasIntersectFilter;\n-    Set<Node> unionNodes;\n-    Set<Node> subtractNodes;\n-    Set<Node> intersectNodes;\n-    int inSubtract = -1;\n-    int inIntersect = -1;\n-    int inUnion = -1;\n+    private final boolean hasUnionFilter;\n+    private final boolean hasSubtractFilter;\n+    private final boolean hasIntersectFilter;\n+    private final Set<Node> unionNodes;\n+    private final Set<Node> subtractNodes;\n+    private final Set<Node> intersectNodes;\n+    private int inSubtract = -1;\n+    private int inIntersect = -1;\n+    private int inUnion = -1;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath2Filter.java","additions":18,"deletions":44,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.transforms.implementations;\n-\n-import java.io.OutputStream;\n-\n-import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformationException;\n-import com.sun.org.apache.xml.internal.security.transforms.Transforms;\n-\n-\/**\n- * Class TransformXPointer\n- *\n- *\/\n-public class TransformXPointer extends TransformSpi {\n-\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_XPOINTER;\n-\n-\n-    \/** {@inheritDoc} *\/\n-    protected String engineGetURI() {\n-        return implementedTransformURI;\n-    }\n-\n-    \/**\n-     * Method enginePerformTransform\n-     *\n-     * @param input\n-     * @return  {@link XMLSignatureInput} as the result of transformation\n-     * @throws TransformationException\n-     *\/\n-    protected XMLSignatureInput enginePerformTransform(\n-        XMLSignatureInput input, OutputStream os, Transform transformObject\n-    ) throws TransformationException {\n-\n-        Object exArgs[] = { implementedTransformURI };\n-\n-        throw new TransformationException(\"signature.Transform.NotYetImplemented\", exArgs);\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPointer.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-import javax.xml.transform.TransformerConfigurationException;\n@@ -43,1 +42,0 @@\n-import com.sun.org.apache.xml.internal.security.transforms.Transform;\n@@ -59,4 +57,0 @@\n-    \/** Field implementedTransformURI *\/\n-    public static final String implementedTransformURI =\n-        Transforms.TRANSFORM_XSLT;\n-\n@@ -71,2 +65,0 @@\n-     * Method engineGetURI\n-     *\n@@ -75,0 +67,1 @@\n+    @Override\n@@ -76,1 +69,1 @@\n-        return implementedTransformURI;\n+        return Transforms.TRANSFORM_XSLT;\n@@ -79,0 +72,4 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n@@ -80,1 +77,2 @@\n-        XMLSignatureInput input, OutputStream baos, Transform transformObject\n+        XMLSignatureInput input, OutputStream baos, Element transformElement,\n+        String baseURI, boolean secureValidation\n@@ -83,2 +81,0 @@\n-            Element transformElement = transformObject.getElement();\n-\n@@ -92,1 +88,1 @@\n-                Object exArgs[] = { \"xslt:stylesheet\", \"Transform\" };\n+                Object[] exArgs = { \"xslt:stylesheet\", \"Transform\" };\n@@ -100,0 +96,8 @@\n+            if (secureValidation) {\n+                try {\n+                    tFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+                    tFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n+                } catch (IllegalArgumentException ex) {\n+                    \/\/ ignore\n+                }\n+            }\n@@ -162,5 +166,1 @@\n-        } catch (XMLSecurityException ex) {\n-            throw new TransformationException(ex);\n-        } catch (TransformerConfigurationException ex) {\n-            throw new TransformationException(ex);\n-        } catch (TransformerException ex) {\n+        } catch (XMLSecurityException | TransformerException ex) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXSLT.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            prefixList = new TreeSet<String>(prefixes);\n+            prefixList = new TreeSet<>(prefixes);\n@@ -88,1 +88,1 @@\n-                sb.append(\" \");\n+                sb.append(' ');\n@@ -134,1 +134,1 @@\n-        SortedSet<String> prefixes = new TreeSet<String>();\n+        SortedSet<String> prefixes = new TreeSet<>();\n@@ -142,1 +142,1 @@\n-            if (prefix.equals(\"#default\")) {\n+            if (\"#default\".equals(prefix)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/params\/InclusiveNamespaces.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-public class XPath2FilterContainer extends ElementProxy implements TransformParam {\n+public final class XPath2FilterContainer extends ElementProxy implements TransformParam {\n@@ -112,1 +112,1 @@\n-            Object exArgs[] = { XPath2FilterContainer._ATT_FILTER, filterStr,\n+            Object[] exArgs = { XPath2FilterContainer._ATT_FILTER, filterStr,\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/params\/XPath2FilterContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,242 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.transforms.params;\n-\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformParam;\n-import com.sun.org.apache.xml.internal.security.utils.ElementProxy;\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-\n-\/**\n- * Implements the parameters for the <A\n- * HREF=\"http:\/\/www.w3.org\/TR\/xmldsig-filter2\/\">XPath Filter v2.0<\/A>.\n- *\n- * @see <A HREF=\"http:\/\/www.w3.org\/TR\/xmldsig-filter2\/\">XPath Filter v2.0 (TR)<\/A>\n- *\/\n-public class XPath2FilterContainer04 extends ElementProxy implements TransformParam {\n-\n-    \/** Field _ATT_FILTER *\/\n-    private static final String _ATT_FILTER = \"Filter\";\n-\n-    \/** Field _ATT_FILTER_VALUE_INTERSECT *\/\n-    private static final String _ATT_FILTER_VALUE_INTERSECT = \"intersect\";\n-\n-    \/** Field _ATT_FILTER_VALUE_SUBTRACT *\/\n-    private static final String _ATT_FILTER_VALUE_SUBTRACT = \"subtract\";\n-\n-    \/** Field _ATT_FILTER_VALUE_UNION *\/\n-    private static final String _ATT_FILTER_VALUE_UNION = \"union\";\n-\n-    \/** Field _TAG_XPATH2 *\/\n-    public static final String _TAG_XPATH2 = \"XPath\";\n-\n-    \/** Field XPathFiler2NS *\/\n-    public static final String XPathFilter2NS =\n-        \"http:\/\/www.w3.org\/2002\/04\/xmldsig-filter2\";\n-\n-    \/**\n-     * Constructor XPath2FilterContainer04\n-     *\n-     *\/\n-    private XPath2FilterContainer04() {\n-\n-        \/\/ no instantiation\n-    }\n-\n-    \/**\n-     * Constructor XPath2FilterContainer04\n-     *\n-     * @param doc\n-     * @param xpath2filter\n-     * @param filterType\n-     *\/\n-    private XPath2FilterContainer04(Document doc, String xpath2filter, String filterType) {\n-        super(doc);\n-\n-        setLocalAttribute(XPath2FilterContainer04._ATT_FILTER, filterType);\n-\n-        if (xpath2filter.length() > 2\n-            && !Character.isWhitespace(xpath2filter.charAt(0))) {\n-            addReturnToSelf();\n-            appendSelf(createText(xpath2filter));\n-            addReturnToSelf();\n-        } else {\n-            appendSelf(createText(xpath2filter));\n-        }\n-    }\n-\n-    \/**\n-     * Constructor XPath2FilterContainer04\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @throws XMLSecurityException\n-     *\/\n-    private XPath2FilterContainer04(Element element, String baseURI)\n-        throws XMLSecurityException {\n-\n-        super(element, baseURI);\n-\n-        String filterStr = getLocalAttribute(XPath2FilterContainer04._ATT_FILTER);\n-\n-        if (!filterStr.equals(XPath2FilterContainer04._ATT_FILTER_VALUE_INTERSECT)\n-            && !filterStr.equals(XPath2FilterContainer04._ATT_FILTER_VALUE_SUBTRACT)\n-            && !filterStr.equals(XPath2FilterContainer04._ATT_FILTER_VALUE_UNION)) {\n-            Object exArgs[] = { XPath2FilterContainer04._ATT_FILTER, filterStr,\n-                                XPath2FilterContainer04._ATT_FILTER_VALUE_INTERSECT\n-                                + \", \"\n-                                + XPath2FilterContainer04._ATT_FILTER_VALUE_SUBTRACT\n-                                + \" or \"\n-                                + XPath2FilterContainer04._ATT_FILTER_VALUE_UNION };\n-\n-            throw new XMLSecurityException(\"attributeValueIllegal\", exArgs);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new XPath2FilterContainer04 with the filter type \"intersect\".\n-     *\n-     * @param doc\n-     * @param xpath2filter\n-     * @return the instance\n-     *\/\n-    public static XPath2FilterContainer04 newInstanceIntersect(\n-        Document doc, String xpath2filter\n-    ) {\n-        return new XPath2FilterContainer04(\n-            doc, xpath2filter, XPath2FilterContainer04._ATT_FILTER_VALUE_INTERSECT);\n-    }\n-\n-    \/**\n-     * Creates a new XPath2FilterContainer04 with the filter type \"subtract\".\n-     *\n-     * @param doc\n-     * @param xpath2filter\n-     * @return the instance\n-     *\/\n-    public static XPath2FilterContainer04 newInstanceSubtract(\n-        Document doc, String xpath2filter\n-    ) {\n-        return new XPath2FilterContainer04(\n-            doc, xpath2filter, XPath2FilterContainer04._ATT_FILTER_VALUE_SUBTRACT);\n-    }\n-\n-    \/**\n-     * Creates a new XPath2FilterContainer04 with the filter type \"union\".\n-     *\n-     * @param doc\n-     * @param xpath2filter\n-     * @return the instance\n-     *\/\n-    public static XPath2FilterContainer04 newInstanceUnion(\n-        Document doc, String xpath2filter\n-    ) {\n-        return new XPath2FilterContainer04(\n-            doc, xpath2filter, XPath2FilterContainer04._ATT_FILTER_VALUE_UNION);\n-    }\n-\n-    \/**\n-     * Creates a XPath2FilterContainer04 from an existing Element; needed for verification.\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @return the instance\n-     *\n-     * @throws XMLSecurityException\n-     *\/\n-    public static XPath2FilterContainer04 newInstance(\n-        Element element, String baseURI\n-    ) throws XMLSecurityException {\n-        return new XPath2FilterContainer04(element, baseURI);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the {@code Filter} attribute has value \"intersect\".\n-     *\n-     * @return {@code true} if the {@code Filter} attribute has value \"intersect\".\n-     *\/\n-    public boolean isIntersect() {\n-        return getLocalAttribute(XPath2FilterContainer04._ATT_FILTER\n-        ).equals(XPath2FilterContainer04._ATT_FILTER_VALUE_INTERSECT);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the {@code Filter} attribute has value \"subtract\".\n-     *\n-     * @return {@code true} if the {@code Filter} attribute has value \"subtract\".\n-     *\/\n-    public boolean isSubtract() {\n-        return getLocalAttribute(XPath2FilterContainer04._ATT_FILTER\n-        ).equals(XPath2FilterContainer04._ATT_FILTER_VALUE_SUBTRACT);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the {@code Filter} attribute has value \"union\".\n-     *\n-     * @return {@code true} if the {@code Filter} attribute has value \"union\".\n-     *\/\n-    public boolean isUnion() {\n-        return getLocalAttribute(XPath2FilterContainer04._ATT_FILTER\n-        ).equals(XPath2FilterContainer04._ATT_FILTER_VALUE_UNION);\n-    }\n-\n-    \/**\n-     * Returns the XPath 2 Filter String\n-     *\n-     * @return the XPath 2 Filter String\n-     *\/\n-    public String getXPathFilterStr() {\n-        return this.getTextFromTextChild();\n-    }\n-\n-    \/**\n-     * Returns the first Text node which contains information from the XPath 2\n-     * Filter String. We must use this stupid hook to enable the here() function\n-     * to work.\n-     *\n-     * @return the first Text node which contains information from the XPath 2 Filter String\n-     *\/\n-    public Node getXPathFilterTextNode() {\n-        Node childNode = getElement().getFirstChild();\n-        while (childNode != null) {\n-            if (childNode.getNodeType() == Node.TEXT_NODE) {\n-                return childNode;\n-            }\n-            childNode = childNode.getNextSibling();\n-        }\n-\n-        return null;\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    public final String getBaseLocalName() {\n-        return XPath2FilterContainer04._TAG_XPATH2;\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    public final String getBaseNamespace() {\n-        return XPath2FilterContainer04.XPathFilter2NS;\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/params\/XPath2FilterContainer04.java","additions":0,"deletions":242,"binary":false,"changes":242,"status":"deleted"},{"patch":"@@ -1,323 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.transforms.params;\n-\n-\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;\n-import com.sun.org.apache.xml.internal.security.transforms.TransformParam;\n-import com.sun.org.apache.xml.internal.security.utils.ElementProxy;\n-import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.Text;\n-\n-\/**\n- * Implements the parameters for a custom Transform which has a better performance\n- * than the xfilter2.\n- *\n- *\/\n-public class XPathFilterCHGPContainer extends ElementProxy implements TransformParam {\n-\n-    public static final String TRANSFORM_XPATHFILTERCHGP =\n-        \"http:\/\/www.nue.et-inf.uni-siegen.de\/~geuer-pollmann\/#xpathFilter\";\n-\n-    \/** Field _ATT_FILTER_VALUE_INTERSECT *\/\n-    private static final String _TAG_INCLUDE_BUT_SEARCH = \"IncludeButSearch\";\n-\n-    \/** Field _ATT_FILTER_VALUE_SUBTRACT *\/\n-    private static final String _TAG_EXCLUDE_BUT_SEARCH = \"ExcludeButSearch\";\n-\n-    \/** Field _ATT_FILTER_VALUE_UNION *\/\n-    private static final String _TAG_EXCLUDE = \"Exclude\";\n-\n-    \/** Field _TAG_XPATHCHGP *\/\n-    public static final String _TAG_XPATHCHGP = \"XPathAlternative\";\n-\n-    \/** Field _ATT_INCLUDESLASH *\/\n-    public static final String _ATT_INCLUDESLASH = \"IncludeSlashPolicy\";\n-\n-    \/** Field IncludeSlash           *\/\n-    public static final boolean IncludeSlash = true;\n-\n-    \/** Field ExcludeSlash           *\/\n-    public static final boolean ExcludeSlash = false;\n-\n-    \/**\n-     * Constructor XPathFilterCHGPContainer\n-     *\n-     *\/\n-    private XPathFilterCHGPContainer() {\n-        \/\/ no instantiation\n-    }\n-\n-    \/**\n-     * Constructor XPathFilterCHGPContainer\n-     *\n-     * @param doc\n-     * @param includeSlashPolicy\n-     * @param includeButSearch\n-     * @param excludeButSearch\n-     * @param exclude\n-     *\/\n-    private XPathFilterCHGPContainer(\n-        Document doc, boolean includeSlashPolicy, String includeButSearch,\n-        String excludeButSearch, String exclude\n-    ) {\n-        super(doc);\n-\n-        if (includeSlashPolicy) {\n-            setLocalAttribute(XPathFilterCHGPContainer._ATT_INCLUDESLASH, \"true\");\n-        } else {\n-            setLocalAttribute(XPathFilterCHGPContainer._ATT_INCLUDESLASH, \"false\");\n-        }\n-\n-        if (includeButSearch != null && includeButSearch.trim().length() > 0) {\n-            Element includeButSearchElem =\n-                ElementProxy.createElementForFamily(\n-                    doc, this.getBaseNamespace(), XPathFilterCHGPContainer._TAG_INCLUDE_BUT_SEARCH\n-                );\n-\n-            includeButSearchElem.appendChild(\n-                createText(indentXPathText(includeButSearch))\n-            );\n-            addReturnToSelf();\n-            appendSelf(includeButSearchElem);\n-        }\n-\n-        if (excludeButSearch != null && excludeButSearch.trim().length() > 0) {\n-            Element excludeButSearchElem =\n-                ElementProxy.createElementForFamily(\n-                    doc, this.getBaseNamespace(), XPathFilterCHGPContainer._TAG_EXCLUDE_BUT_SEARCH\n-                );\n-\n-            excludeButSearchElem.appendChild(\n-                createText(indentXPathText(excludeButSearch)));\n-\n-            addReturnToSelf();\n-            appendSelf(excludeButSearchElem);\n-        }\n-\n-        if (exclude != null && exclude.trim().length() > 0) {\n-            Element excludeElem =\n-                ElementProxy.createElementForFamily(\n-                   doc, this.getBaseNamespace(), XPathFilterCHGPContainer._TAG_EXCLUDE);\n-\n-            excludeElem.appendChild(createText(indentXPathText(exclude)));\n-            addReturnToSelf();\n-            appendSelf(excludeElem);\n-        }\n-\n-        addReturnToSelf();\n-    }\n-\n-    \/**\n-     * Method indentXPathText\n-     *\n-     * @param xp\n-     * @return the string with enters\n-     *\/\n-    static String indentXPathText(String xp) {\n-        if (xp.length() > 2 && !Character.isWhitespace(xp.charAt(0))) {\n-            return \"\\n\" + xp + \"\\n\";\n-        }\n-        return xp;\n-    }\n-\n-    \/**\n-     * Constructor XPathFilterCHGPContainer\n-     *\n-     * @param element\n-     * @param baseURI\n-     * @throws XMLSecurityException\n-     *\/\n-    private XPathFilterCHGPContainer(Element element, String baseURI)\n-        throws XMLSecurityException {\n-        super(element, baseURI);\n-    }\n-\n-    \/**\n-     * Creates a new XPathFilterCHGPContainer; needed for generation.\n-     *\n-     * @param doc\n-     * @param includeSlashPolicy\n-     * @param includeButSearch\n-     * @param excludeButSearch\n-     * @param exclude\n-     * @return the created object\n-     *\/\n-    public static XPathFilterCHGPContainer getInstance(\n-        Document doc, boolean includeSlashPolicy, String includeButSearch,\n-        String excludeButSearch, String exclude\n-    ) {\n-        return new XPathFilterCHGPContainer(\n-            doc, includeSlashPolicy, includeButSearch, excludeButSearch, exclude);\n-    }\n-\n-    \/**\n-     * Creates a XPathFilterCHGPContainer from an existing Element; needed for verification.\n-     *\n-     * @param element\n-     * @param baseURI\n-     *\n-     * @throws XMLSecurityException\n-     * @return the created object.\n-     *\/\n-    public static XPathFilterCHGPContainer getInstance(\n-        Element element, String baseURI\n-    ) throws XMLSecurityException {\n-        return new XPathFilterCHGPContainer(element, baseURI);\n-    }\n-\n-    \/**\n-     * Method getXStr\n-     *\n-     * @param type\n-     * @return The Xstr\n-     *\/\n-    private String getXStr(String type) {\n-        if (this.length(this.getBaseNamespace(), type) != 1) {\n-            return \"\";\n-        }\n-\n-        Element xElem =\n-            XMLUtils.selectNode(\n-                getElement().getFirstChild(), this.getBaseNamespace(), type, 0\n-            );\n-\n-        return XMLUtils.getFullTextChildrenFromNode(xElem);\n-    }\n-\n-    \/**\n-     * Method getIncludeButSearch\n-     *\n-     * @return the string\n-     *\/\n-    public String getIncludeButSearch() {\n-        return this.getXStr(XPathFilterCHGPContainer._TAG_INCLUDE_BUT_SEARCH);\n-    }\n-\n-    \/**\n-     * Method getExcludeButSearch\n-     *\n-     * @return the string\n-     *\/\n-    public String getExcludeButSearch() {\n-        return this.getXStr(XPathFilterCHGPContainer._TAG_EXCLUDE_BUT_SEARCH);\n-    }\n-\n-    \/**\n-     * Method getExclude\n-     *\n-     * @return the string\n-     *\/\n-    public String getExclude() {\n-        return this.getXStr(XPathFilterCHGPContainer._TAG_EXCLUDE);\n-    }\n-\n-    \/**\n-     * Method getIncludeSlashPolicy\n-     *\n-     * @return the string\n-     *\/\n-    public boolean getIncludeSlashPolicy() {\n-        return getLocalAttribute(XPathFilterCHGPContainer._ATT_INCLUDESLASH).equals(\"true\");\n-    }\n-\n-    \/**\n-     * Returns the first Text node which contains information from the XPath\n-     * Filter String. We must use this stupid hook to enable the here() function\n-     * to work.\n-     *\n-     * $todo$ I dunno whether this crashes: <XPath> he<!-- comment -->re()\/ds:Signature[1]<\/XPath>\n-     * @param type\n-     * @return the first Text node which contains information from the XPath 2 Filter String\n-     *\/\n-    private Node getHereContextNode(String type) {\n-\n-        if (this.length(this.getBaseNamespace(), type) != 1) {\n-            return null;\n-        }\n-\n-        return selectNodeText(\n-            getFirstChild(), this.getBaseNamespace(), type, 0\n-        );\n-    }\n-\n-    private static Text selectNodeText(Node sibling, String uri, String nodeName, int number) {\n-        Node n = XMLUtils.selectNode(sibling, uri, nodeName, number);\n-        if (n == null) {\n-            return null;\n-        }\n-        n = n.getFirstChild();\n-        while (n != null && n.getNodeType() != Node.TEXT_NODE) {\n-            n = n.getNextSibling();\n-        }\n-        return (Text)n;\n-    }\n-\n-    \/**\n-     * Method getHereContextNodeIncludeButSearch\n-     *\n-     * @return the string\n-     *\/\n-    public Node getHereContextNodeIncludeButSearch() {\n-        return this.getHereContextNode(XPathFilterCHGPContainer._TAG_INCLUDE_BUT_SEARCH);\n-    }\n-\n-    \/**\n-     * Method getHereContextNodeExcludeButSearch\n-     *\n-     * @return the string\n-     *\/\n-    public Node getHereContextNodeExcludeButSearch() {\n-        return this.getHereContextNode(XPathFilterCHGPContainer._TAG_EXCLUDE_BUT_SEARCH);\n-    }\n-\n-    \/**\n-     * Method getHereContextNodeExclude\n-     *\n-     * @return the string\n-     *\/\n-    public Node getHereContextNodeExclude() {\n-        return this.getHereContextNode(XPathFilterCHGPContainer._TAG_EXCLUDE);\n-    }\n-\n-    \/**\n-     * Method getBaseLocalName\n-     *\n-     * {@inheritDoc}\n-     *\/\n-    public final String getBaseLocalName() {\n-        return XPathFilterCHGPContainer._TAG_XPATHCHGP;\n-    }\n-\n-    \/**\n-     * Method getBaseNamespace\n-     *\n-     * {@inheritDoc}\n-     *\/\n-    public final String getBaseNamespace() {\n-        return TRANSFORM_XPATHFILTERCHGP;\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/params\/XPathFilterCHGPContainer.java","additions":0,"deletions":323,"binary":false,"changes":323,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-public class Base64 {\n+public final class Base64 {\n@@ -214,1 +214,1 @@\n-     * @param base64str Base 64 encoded string.\n+     * @param text Base 64 encoded text.\n@@ -380,1 +380,1 @@\n-        long fewerThan24bits = lengthDataBits % ((long) TWENTYFOURBITGROUP);\n+        long fewerThan24bits = lengthDataBits % (TWENTYFOURBITGROUP);\n@@ -385,1 +385,1 @@\n-        char encodedData[] = null;\n+        char[] encodedData = null;\n@@ -516,1 +516,1 @@\n-        byte decodedData[] = null;\n+        byte[] decodedData = null;\n@@ -631,1 +631,1 @@\n-        \/\/byte decodedData[] = null;\n+        \/\/byte[] decodedData = null;\n@@ -698,1 +698,1 @@\n-        \/\/byte decodedData[] = null;\n+        \/\/byte[] decodedData = null;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/Base64.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+ *\n+ * This class and methods in this class are package private. The class is\n+ * duplicated to multiple packages.\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/ClassLoaderUtils.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,0 +141,9 @@\n+    \/** Tag of Element RSAPSSParams **\/\n+    public static final String _TAG_RSAPSSPARAMS = \"RSAPSSParams\";\n+\n+    \/** Tag of Element SaltLength **\/\n+    public static final String _TAG_SALTLENGTH = \"SaltLength\";\n+\n+    \/** Tag of Element TrailerField **\/\n+    public static final String _TAG_TRAILERFIELD = \"TrailerField\";\n+\n@@ -252,1 +261,1 @@\n-    \/** Tag of Element PGPKeyPacket **\/\n+    \/** Tag of Element DEREncodedKeyValue **\/\n@@ -255,1 +264,1 @@\n-    \/** Tag of Element PGPKeyPacket **\/\n+    \/** Tag of Element KeyInfoReference **\/\n@@ -258,1 +267,1 @@\n-    \/** Tag of Element PGPKeyPacket **\/\n+    \/** Tag of Element X509Digest **\/\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/Constants.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.util.HashMap;\n@@ -27,2 +26,1 @@\n-import java.util.Map;\n-import java.util.Map.Entry;\n+import java.util.Objects;\n@@ -32,3 +30,0 @@\n-import org.w3c.dom.Attr;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.NamedNodeMap;\n@@ -37,0 +32,7 @@\n+import static javax.xml.XMLConstants.DEFAULT_NS_PREFIX;\n+import static javax.xml.XMLConstants.NULL_NS_URI;\n+import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE;\n+import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n+import static javax.xml.XMLConstants.XML_NS_PREFIX;\n+import static javax.xml.XMLConstants.XML_NS_URI;\n+\n@@ -38,0 +40,34 @@\n+ * This class adapts the {@link Node} namespace\/prefix lookup API to that of {@link NamespaceContext}.\n+ * There are some differences:\n+ * <table>\n+ *     <tr>\n+ *         <th>Function<\/th>\n+ *         <th>{@link NamespaceContext} API<\/th>\n+ *         <th>{@link Node} API<\/th>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <td>Look up the prefix for a given namespace URI.<\/td>\n+ *         <td>{@link NamespaceContext#getPrefix(String)}<\/td>\n+ *         <td>{@link Node#lookupPrefix(String)}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <td>Look up all the prefixes for a given namespace URI.<\/td>\n+ *         <td>{@link NamespaceContext#getPrefixes(String)}<\/td>\n+ *         <td>\/<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <td>Look up the namespace URI for a given prefix.<\/td>\n+ *         <td>{@link NamespaceContext#getNamespaceURI(String)}<\/td>\n+ *         <td>{@link Node#lookupNamespaceURI(String)}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <td>The default prefix.<\/td>\n+ *         <td>{@link javax.xml.XMLConstants#DEFAULT_NS_PREFIX}<\/td>\n+ *         <td>{@code null}<\/td>\n+ *     <\/tr>\n+ *     <tr>\n+ *         <td>The default namespace URI.<\/td>\n+ *         <td>{@link javax.xml.XMLConstants#NULL_NS_URI}<\/td>\n+ *         <td>{@code null}<\/td>\n+ *     <\/tr>\n+ * <\/table>\n@@ -41,1 +77,1 @@\n-    private Map<String, String> namespaceMap = new HashMap<>();\n+    private Node context;\n@@ -43,2 +79,2 @@\n-    public DOMNamespaceContext(Node contextNode) {\n-        addNamespaces(contextNode);\n+    public DOMNamespaceContext(Node context) {\n+        setContext(context);\n@@ -47,2 +83,2 @@\n-    public String getNamespaceURI(String arg0) {\n-        return namespaceMap.get(arg0);\n+    public void setContext(Node context) {\n+        this.context = context;\n@@ -51,4 +87,11 @@\n-    public String getPrefix(String arg0) {\n-        for (Entry<String, String> entry : namespaceMap.entrySet()) {\n-            if (entry.getValue().equals(arg0)) {\n-                return entry.getKey();\n+    public String getNamespaceURI(String prefix) {\n+        if (prefix == null) {\n+            throw new IllegalArgumentException(\"prefix is null\");\n+        }\n+        if (prefix.equals(DEFAULT_NS_PREFIX)) {\n+            prefix = null;\n+        }\n+        if (context != null) {\n+            String namespaceURI = context.lookupNamespaceURI(prefix);\n+            if (namespaceURI != null) {\n+                return namespaceURI;\n@@ -57,5 +100,8 @@\n-        return null;\n-    }\n-\n-    public Iterator<String> getPrefixes(String arg0) {\n-        return namespaceMap.keySet().iterator();\n+        if (prefix == null) {\n+            return NULL_NS_URI;\n+        } else if (prefix.equals(XML_NS_PREFIX)) {\n+            return XML_NS_URI;\n+        } else if (prefix.equals(XMLNS_ATTRIBUTE)) {\n+            return XMLNS_ATTRIBUTE_NS_URI;\n+        }\n+        return NULL_NS_URI;\n@@ -64,3 +110,6 @@\n-    private void addNamespaces(Node element) {\n-        if (element.getParentNode() != null) {\n-            addNamespaces(element.getParentNode());\n+    public String getPrefix(String namespaceURI) {\n+        if (namespaceURI == null) {\n+            throw new IllegalArgumentException(\"namespace URI is null\");\n+        }\n+        if (namespaceURI.equals(NULL_NS_URI)) {\n+            namespaceURI = null;\n@@ -68,8 +117,11 @@\n-        if (element instanceof Element) {\n-            Element el = (Element)element;\n-            NamedNodeMap map = el.getAttributes();\n-            for (int x = 0; x < map.getLength(); x++) {\n-                Attr attr = (Attr)map.item(x);\n-                if (\"xmlns\".equals(attr.getPrefix())) {\n-                    namespaceMap.put(attr.getLocalName(), attr.getValue());\n-                }\n+        if (context != null) {\n+            String prefix = context.lookupPrefix(namespaceURI);\n+            if (prefix != null) {\n+                return prefix;\n+            } else if (Objects.equals(context.lookupNamespaceURI(null), namespaceURI)) {\n+                \/\/ context.lookupPrefix(namespaceURI) returns null when a namespace URI is unbound but also when it is\n+                \/\/ bound to the default prefix.\n+                \/\/ To distinguish the case of an unbound namespace URI from a bound one to the default prefix,\n+                \/\/ we look up the namespace URI for the default prefix (null) and if it matches, we return the default\n+                \/\/ prefix.\n+                return DEFAULT_NS_PREFIX;\n@@ -78,0 +130,15 @@\n+        if (namespaceURI == null) {\n+            return context.lookupNamespaceURI(null) != null ? null : DEFAULT_NS_PREFIX;\n+        } else if (namespaceURI.equals(XML_NS_URI)) {\n+            return XML_NS_PREFIX;\n+        } else if (namespaceURI.equals(XMLNS_ATTRIBUTE_NS_URI)) {\n+            return XMLNS_ATTRIBUTE;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\/\n+    public Iterator<String> getPrefixes(String namespaceURI) {\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/DOMNamespaceContext.java","additions":98,"deletions":31,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private static Map<String, String> prefixMappings = new ConcurrentHashMap<String, String>();\n+    private static Map<String, String> prefixMappings = new ConcurrentHashMap<>();\n@@ -213,1 +213,1 @@\n-        return this.wrappedDoc.createTextNode(text);\n+        return getDocument().createTextNode(text);\n@@ -252,1 +252,1 @@\n-            Object exArgs[] = { actualNamespaceUri + \":\" + actualLocalName,\n+            Object[] exArgs = { actualNamespaceUri + \":\" + actualLocalName,\n@@ -293,9 +293,1 @@\n-            Element el = XMLUtils.createElementInSignatureSpace(getDocument(), localname);\n-            Text text = getDocument().createTextNode(XMLUtils.encodeToString(bytes));\n-\n-            el.appendChild(text);\n-\n-            appendSelf(el);\n-            if (!XMLUtils.ignoreLineBreaks()) {\n-                appendSelf(createText(\"\\n\"));\n-            }\n+            addTextElement(XMLUtils.encodeToString(bytes), localname);\n@@ -462,1 +454,1 @@\n-                Object exArgs[] = { ns, getElement().getAttributeNS(null, ns) };\n+                Object[] exArgs = { ns, getElement().getAttributeNS(null, ns) };\n@@ -492,1 +484,1 @@\n-                Object exArgs[] = { prefix, namespace, storedPrefix };\n+                Object[] exArgs = { prefix, namespace, storedPrefix };\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/ElementProxy.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,89 @@\n+    \/\/ Attributes that exist in XML Signature in the same way\n+    \/** Tag of Attr Algorithm **\/\n+    public static final String _ATT_ALGORITHM = Constants._ATT_ALGORITHM;\n+\n+    \/** Tag of Attr Id**\/\n+    public static final String _ATT_ID = Constants._ATT_ID;\n+\n+    \/** Tag of Attr Target **\/\n+    public static final String _ATT_TARGET = Constants._ATT_TARGET;\n+\n+    \/** Tag of Attr Type **\/\n+    public static final String _ATT_TYPE = Constants._ATT_TYPE;\n+\n+    \/** Tag of Attr URI **\/\n+    public static final String _ATT_URI = Constants._ATT_URI;\n+\n+    \/\/ Attributes new in XML Encryption\n+    \/** Tag of Attr encoding **\/\n+    public static final String _ATT_ENCODING = \"Encoding\";\n+\n+    \/** Tag of Attr recipient **\/\n+    public static final String _ATT_RECIPIENT = \"Recipient\";\n+\n+    \/** Tag of Attr mimetype **\/\n+    public static final String _ATT_MIMETYPE = \"MimeType\";\n+\n+    \/** Tag of Element CarriedKeyName **\/\n+    public static final String _TAG_CARRIEDKEYNAME = \"CarriedKeyName\";\n+\n+    \/** Tag of Element CipherData **\/\n+    public static final String _TAG_CIPHERDATA = \"CipherData\";\n+\n+    \/** Tag of Element CipherReference **\/\n+    public static final String _TAG_CIPHERREFERENCE = \"CipherReference\";\n+\n+    \/** Tag of Element CipherValue **\/\n+    public static final String _TAG_CIPHERVALUE = \"CipherValue\";\n+\n+    \/** Tag of Element DataReference **\/\n+    public static final String _TAG_DATAREFERENCE = \"DataReference\";\n+\n+    \/** Tag of Element EncryptedData **\/\n+    public static final String _TAG_ENCRYPTEDDATA = \"EncryptedData\";\n+\n+    \/** Tag of Element EncryptedKey **\/\n+    public static final String _TAG_ENCRYPTEDKEY = \"EncryptedKey\";\n+\n+    \/** Tag of Element EncryptionMethod **\/\n+    public static final String _TAG_ENCRYPTIONMETHOD = \"EncryptionMethod\";\n+\n+    \/** Tag of Element EncryptionProperties **\/\n+    public static final String _TAG_ENCRYPTIONPROPERTIES = \"EncryptionProperties\";\n+\n+    \/** Tag of Element EncryptionProperty **\/\n+    public static final String _TAG_ENCRYPTIONPROPERTY = \"EncryptionProperty\";\n+\n+    \/** Tag of Element KeyReference **\/\n+    public static final String _TAG_KEYREFERENCE = \"KeyReference\";\n+\n+    \/** Tag of Element KeySize **\/\n+    public static final String _TAG_KEYSIZE = \"KeySize\";\n+\n+    \/** Tag of Element OAEPparams **\/\n+    public static final String _TAG_OAEPPARAMS = \"OAEPparams\";\n+\n+    \/** Tag of Element MGF **\/\n+    public static final String _TAG_MGF = \"MGF\";\n+\n+    \/** Tag of Element ReferenceList **\/\n+    public static final String _TAG_REFERENCELIST = \"ReferenceList\";\n+\n+    \/** Tag of Element Transforms **\/\n+    public static final String _TAG_TRANSFORMS = \"Transforms\";\n+\n+    \/** Tag of Element AgreementMethod **\/\n+    public static final String _TAG_AGREEMENTMETHOD = \"AgreementMethod\";\n+\n+    \/** Tag of Element KA-Nonce **\/\n+    public static final String _TAG_KA_NONCE = \"KA-Nonce\";\n+\n+    \/** Tag of Element OriginatorKeyInfo **\/\n+    public static final String _TAG_ORIGINATORKEYINFO = \"OriginatorKeyInfo\";\n+\n+    \/** Tag of Element RecipientKeyInfo **\/\n+    public static final String _TAG_RECIPIENTKEYINFO = \"RecipientKeyInfo\";\n+\n+    \/** Field ENCRYPTIONSPECIFICATION_URL *\/\n+    public static final String ENCRYPTIONSPECIFICATION_URL =\n+        \"http:\/\/www.w3.org\/TR\/2001\/WD-xmlenc-core-20010626\/\";\n@@ -33,0 +122,145 @@\n+    \/**\n+     * The namespace of the XML Encryption 1.1 specification\n+     *\/\n+    public static final String EncryptionSpec11NS =\n+        \"http:\/\/www.w3.org\/2009\/xmlenc11#\";\n+\n+    \/** URI for content*\/\n+    public static final String TYPE_CONTENT = EncryptionSpecNS + \"Content\";\n+\n+    \/** URI for element*\/\n+    public static final String TYPE_ELEMENT = EncryptionSpecNS + \"Element\";\n+\n+    \/** URI for mediatype*\/\n+    public static final String TYPE_MEDIATYPE =\n+        \"http:\/\/www.isi.edu\/in-notes\/iana\/assignments\/media-types\/\";\n+\n+    \/** Block Encryption - REQUIRED TRIPLEDES *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_TRIPLEDES =\n+        EncryptionConstants.EncryptionSpecNS + \"tripledes-cbc\";\n+\n+    \/** Block Encryption - REQUIRED AES-128 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES128 =\n+        EncryptionConstants.EncryptionSpecNS + \"aes128-cbc\";\n+\n+    \/** Block Encryption - REQUIRED AES-256 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES256 =\n+        EncryptionConstants.EncryptionSpecNS + \"aes256-cbc\";\n+\n+    \/** Block Encryption - OPTIONAL AES-192 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES192 =\n+        EncryptionConstants.EncryptionSpecNS + \"aes192-cbc\";\n+\n+    \/** Block Encryption - OPTIONAL AES-128-GCM *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES128_GCM =\n+        \"http:\/\/www.w3.org\/2009\/xmlenc11#aes128-gcm\";\n+\n+    \/** Block Encryption - OPTIONAL AES-192-GCM *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES192_GCM =\n+        \"http:\/\/www.w3.org\/2009\/xmlenc11#aes192-gcm\";\n+\n+    \/** Block Encryption - OPTIONAL AES-256-GCM *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_AES256_GCM =\n+        \"http:\/\/www.w3.org\/2009\/xmlenc11#aes256-gcm\";\n+\n+    \/** Block Encryption - OPTIONAL SEED-128 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_SEED128 =\n+        \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#seed128-cbc\";\n+\n+    \/** Block Encryption - OPTIONAL CAMELLIA-128 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_CAMELLIA128 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#camellia128-cbc\";\n+\n+    \/** Block Encryption - OPTIONAL CAMELLIA-128 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_CAMELLIA192 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#camellia192-cbc\";\n+\n+    \/** Block Encryption - OPTIONAL CAMELLIA-128 *\/\n+    public static final String ALGO_ID_BLOCKCIPHER_CAMELLIA256 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#camellia256-cbc\";\n+\n+    \/** Key Transport - REQUIRED RSA-v1.5*\/\n+    public static final String ALGO_ID_KEYTRANSPORT_RSA15 =\n+        EncryptionConstants.EncryptionSpecNS + \"rsa-1_5\";\n+\n+    \/** Key Transport - REQUIRED RSA-OAEP *\/\n+    public static final String ALGO_ID_KEYTRANSPORT_RSAOAEP =\n+        EncryptionConstants.EncryptionSpecNS + \"rsa-oaep-mgf1p\";\n+\n+    \/** Key Transport - OPTIONAL RSA-OAEP_11 *\/\n+    public static final String ALGO_ID_KEYTRANSPORT_RSAOAEP_11 =\n+        EncryptionConstants.EncryptionSpec11NS + \"rsa-oaep\";\n+\n+    \/** Key Agreement - OPTIONAL Diffie-Hellman *\/\n+    public static final String ALGO_ID_KEYAGREEMENT_DH =\n+        EncryptionConstants.EncryptionSpecNS + \"dh\";\n+\n+    \/** Symmetric Key Wrap - REQUIRED TRIPLEDES KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_TRIPLEDES =\n+        EncryptionConstants.EncryptionSpecNS + \"kw-tripledes\";\n+\n+    \/** Symmetric Key Wrap - REQUIRED AES-128 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_AES128 =\n+        EncryptionConstants.EncryptionSpecNS + \"kw-aes128\";\n+\n+    \/** Symmetric Key Wrap - REQUIRED AES-256 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_AES256 =\n+        EncryptionConstants.EncryptionSpecNS + \"kw-aes256\";\n+\n+    \/** Symmetric Key Wrap - OPTIONAL AES-192 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_AES192 =\n+        EncryptionConstants.EncryptionSpecNS + \"kw-aes192\";\n+\n+    \/** Symmetric Key Wrap - OPTIONAL CAMELLIA-128 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_CAMELLIA128 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#kw-camellia128\";\n+\n+    \/** Symmetric Key Wrap - OPTIONAL CAMELLIA-192 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_CAMELLIA192 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#kw-camellia192\";\n+\n+    \/** Symmetric Key Wrap - OPTIONAL CAMELLIA-256 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_CAMELLIA256 =\n+        \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#kw-camellia256\";\n+\n+    \/** Symmetric Key Wrap - OPTIONAL SEED-128 KeyWrap *\/\n+    public static final String ALGO_ID_KEYWRAP_SEED128 =\n+        \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#kw-seed128\";\n+\n+    \/** Message Authentication - RECOMMENDED XML Digital Signature *\/\n+    public static final String ALGO_ID_AUTHENTICATION_XMLSIGNATURE =\n+        \"http:\/\/www.w3.org\/TR\/2001\/CR-xmldsig-core-20010419\/\";\n+\n+    \/** Canonicalization - OPTIONAL Canonical XML with Comments *\/\n+    public static final String ALGO_ID_C14N_WITHCOMMENTS =\n+        \"http:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315#WithComments\";\n+\n+    \/** Canonicalization - OPTIONAL Canonical XML (omits comments) *\/\n+    public static final String ALGO_ID_C14N_OMITCOMMENTS =\n+        \"http:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315\";\n+\n+    \/** Encoding - REQUIRED base64 *\/\n+    public static final String ALGO_ID_ENCODING_BASE64 =\n+        \"http:\/\/www.w3.org\/2000\/09\/xmldsig#base64\";\n+\n+    \/** MGF1 with SHA-1 *\/\n+    public static final String MGF1_SHA1 =\n+        EncryptionConstants.EncryptionSpec11NS + \"mgf1sha1\";\n+\n+    \/** MGF1 with SHA-224 *\/\n+    public static final String MGF1_SHA224 =\n+        EncryptionConstants.EncryptionSpec11NS + \"mgf1sha224\";\n+\n+    \/** MGF1 with SHA-256 *\/\n+    public static final String MGF1_SHA256 =\n+        EncryptionConstants.EncryptionSpec11NS + \"mgf1sha256\";\n+\n+    \/** MGF1 with SHA-384 *\/\n+    public static final String MGF1_SHA384 =\n+        EncryptionConstants.EncryptionSpec11NS + \"mgf1sha384\";\n+\n+    \/** MGF1 with SHA-512 *\/\n+    public static final String MGF1_SHA512 =\n+        EncryptionConstants.EncryptionSpec11NS + \"mgf1sha512\";\n+\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/EncryptionConstants.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -36,3 +36,2 @@\n-    \/** Field nodes *\/\n-    List<Node> nodes = new ArrayList<>();\n-    boolean allNodesMustHaveSameParent = false;\n+    private final List<Node> nodes = new ArrayList<>();\n+    private final boolean allNodesMustHaveSameParent;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/HelperNodeList.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class I18n {\n+public final class I18n {\n@@ -114,1 +114,1 @@\n-            Object exArgs[] = { originalException.getMessage() };\n+            Object[] exArgs = { originalException.getMessage() };\n@@ -136,1 +136,1 @@\n-    public static String getExceptionMessage(String msgID, Object exArgs[]) {\n+    public static String getExceptionMessage(String msgID, Object[] exArgs) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/I18n.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class IdResolver {\n+public final class IdResolver {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/IdResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class JDKXPathAPI implements XPathAPI {\n+class JDKXPathAPI implements XPathAPI {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/JDKXPathAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -60,1 +61,1 @@\n-        byte refBytes[] = null;\n+        byte[] refBytes = null;\n@@ -64,1 +65,1 @@\n-            byte buf[] = new byte[1024];\n+            byte[] buf = new byte[1024];\n@@ -107,1 +108,1 @@\n-            byte buf[] = new byte[4 * 1024];\n+            byte[] buf = new byte[4 * 1024];\n@@ -225,0 +226,19 @@\n+\n+    \/**\n+     * Creates a new instance of this class with the empty constructor.\n+     *\n+     * @param clazz the class\n+     * @param <T> the type of the class\n+     * @return the new instance\n+     * @throws InstantiationException\n+     * @throws IllegalAccessException\n+     *\/\n+    public static <T> T newInstanceWithEmptyConstructor(Class<T> clazz)\n+            throws InstantiationException, IllegalAccessException, InvocationTargetException {\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (NoSuchMethodException e) {\n+            throw (InstantiationException)\n+                    new InstantiationException(clazz.getName()).initCause(e);\n+        }\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/JavaUtils.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        if (dn == null || dn.equals(\"\")) {\n+        if (dn == null || dn.isEmpty()) {\n@@ -91,1 +91,1 @@\n-                    sb.append(parseRDN(DN.substring(i, k).trim(), toXml)).append(\",\");\n+                    sb.append(parseRDN(DN.substring(i, k).trim(), toXml)).append(',');\n@@ -124,1 +124,1 @@\n-                sb.append(parseATAV(trim(str.substring(i, k)), toXml)).append(\"+\");\n+                sb.append(parseATAV(trim(str.substring(i, k)), toXml)).append('+');\n@@ -213,1 +213,1 @@\n-            if (value.startsWith(\"#\")) {\n+            if (value.length() > 0 && value.charAt(0) == '#') {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/RFC2253Parser.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        byte result[] = new byte[pos];\n+        byte[] result = new byte[pos];\n@@ -114,1 +114,1 @@\n-        byte newBuf[] = new byte[newSize];\n+        byte[] newBuf = new byte[newSize];\n@@ -119,1 +119,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/UnsyncByteArrayOutputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.utils;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingDeque;\n-\n-\/**\n- * Abstract base class for pooling objects.  The two public methods are\n- * {@link #getObject()} and ({@link #repool(Object)}.  Objects are held through\n- * weak references so even objects that are not repooled are subject to garbage collection.\n- *\n- * Subclasses must implement the abstract {@link #createObject()}.\n- * <p>\n- *\n- * Internally, the pool is stored in a java.util.concurrent.LinkedBlockingDeque\n- * instance.\n- *\n- * @deprecated This class is no longer in use in Santuario 2.1.4\n- *\/\n-@Deprecated\n-public abstract class WeakObjectPool<T, E extends Throwable> {\n-\n-    private static final Integer MARKER_VALUE = Integer.MAX_VALUE;\/\/once here rather than auto-box it?\n-\n-    \/** created, available objects to be checked out to clients *\/\n-    private final BlockingQueue<WeakReference<T>> available;\n-\n-    \/**\n-     * Synchronized, identity map of loaned out objects (WeakHashMap);\n-     * use to ensure we repool only object originating from here\n-     * and do it once.\n-     *\/\n-    private final Map<T, Integer> onLoan;\n-\n-    \/**\n-     * The lone constructor.\n-     *\/\n-    protected WeakObjectPool() {\n-        \/\/alternative implementations: ArrayBlockingQueue has a fixed size\n-        \/\/  PriorityBlockingQueue: requires a dummy comparator; less memory but more overhead\n-        available = new LinkedBlockingDeque<WeakReference<T>>();\n-        this.onLoan = Collections.synchronizedMap(new WeakHashMap<T, Integer>());\n-    }\n-\n-    \/**\n-     * Called whenever a new pool object is desired; subclasses must implement.\n-     *\n-     * @return object of the type desired by the subclass\n-     * @throws E Throwable's subclass\n-     *\/\n-    protected abstract T createObject() throws E;\n-\n-\n-    \/**\n-     * Subclasses can subclass to return a more specific type.\n-     *\n-     * @return an object from the pool; will block until an object is available\n-     * @throws E\n-     *\/\n-    public T getObject() throws E {\n-        WeakReference<T> ref;\n-        T retValue = null;\n-        do {\n-            \/\/remove any stale entries as well\n-            ref = available.poll();\n-        } while (ref != null && (retValue = ref.get()) == null);\n-\n-        if (retValue == null) {\n-            \/\/empty pool; create & add new one\n-            retValue = createObject();\n-        }\n-        onLoan.put(retValue, MARKER_VALUE);\n-        return retValue;\n-    }\n-\n-\n-    \/**\n-     * Adds the given object to the pool, provided that the object\n-     * was created by this pool.\n-     *\n-     * @param obj the object to return to the pool\n-     * @return whether the object was successfully added as available\n-     *\/\n-    public boolean repool(T obj) {\n-        if (obj != null && onLoan.containsKey(obj)) {\n-            \/\/synchronize to protect against a caller returning the same object again...\n-            synchronized (obj) {\n-                \/\/...and check to see that it was removed\n-                if (onLoan.remove(obj) != null) {\n-                    return available.offer(new WeakReference<T>(obj));\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/WeakObjectPool.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -33,1 +34,0 @@\n-import java.util.Collections;\n@@ -35,1 +35,0 @@\n-import java.util.Iterator;\n@@ -37,2 +36,0 @@\n-import java.util.Map;\n-import java.util.Queue;\n@@ -40,6 +37,1 @@\n-import java.util.WeakHashMap;\n-import java.util.concurrent.ArrayBlockingQueue;\n-\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n+import java.util.stream.Collectors;\n@@ -50,0 +42,3 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParser;\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserImpl;\n@@ -57,2 +52,0 @@\n-import org.xml.sax.InputSource;\n-import org.xml.sax.SAXException;\n@@ -67,5 +60,20 @@\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\"));\n-    private static int parserPoolSize =\n-        AccessController.doPrivileged(\n-            (PrivilegedAction<Integer>) () -> Integer.getInteger(\"com.sun.org.apache.xml.internal.security.parser.pool-size\", 20));\n+            AccessController.doPrivileged(\n+                    (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\"));\n+\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+            com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);\n+\n+    private static XMLParser xmlParserImpl =\n+            AccessController.doPrivileged(\n+                    (PrivilegedAction<XMLParser>) () -> {\n+                        String xmlParserClass = System.getProperty(\"com.sun.org.apache.xml.internal.security.XMLParser\");\n+                        if (xmlParserClass != null) {\n+                            try {\n+                                return (XMLParser) JavaUtils.newInstanceWithEmptyConstructor(\n+                                        ClassLoaderUtils.loadClass(xmlParserClass, XMLUtils.class));\n+                            } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\n+                                LOG.error(\"Error instantiating XMLParser. Falling back to XMLParserImpl\");\n+                            }\n+                        }\n+                        return new XMLParserImpl();\n+                    });\n@@ -78,9 +86,0 @@\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-        com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);\n-\n-    private static final Map<ClassLoader, Queue<DocumentBuilder>> DOCUMENT_BUILDERS =\n-        Collections.synchronizedMap(new WeakHashMap<ClassLoader, Queue<DocumentBuilder>>());\n-\n-    private static final Map<ClassLoader, Queue<DocumentBuilder>> DOCUMENT_BUILDERS_DISALLOW_DOCTYPE =\n-        Collections.synchronizedMap(new WeakHashMap<ClassLoader, Queue<DocumentBuilder>>());\n-\n@@ -204,0 +203,1 @@\n+\n@@ -229,9 +229,3 @@\n-            os.write(Canonicalizer.getInstance(\n-                Canonicalizer.ALGO_ID_C14N_PHYSICAL).canonicalizeSubtree(contextNode)\n-            );\n-        } catch (IOException ex) {\n-            LOG.debug(ex.getMessage(), ex);\n-        }\n-        catch (InvalidCanonicalizerException ex) {\n-            LOG.debug(ex.getMessage(), ex);\n-        } catch (CanonicalizationException ex) {\n+            Canonicalizer.getInstance(\n+                Canonicalizer.ALGO_ID_C14N_PHYSICAL).canonicalizeSubtree(contextNode, os);\n+        } catch (IOException | InvalidCanonicalizerException | CanonicalizationException ex) {\n@@ -257,10 +251,3 @@\n-            os.write(Canonicalizer.getInstance(\n-                Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode)\n-            );\n-        } catch (IOException ex) {\n-            LOG.debug(ex.getMessage(), ex);\n-            \/\/ throw new RuntimeException(ex.getMessage());\n-        } catch (InvalidCanonicalizerException ex) {\n-            LOG.debug(ex.getMessage(), ex);\n-            \/\/ throw new RuntimeException(ex.getMessage());\n-        } catch (CanonicalizationException ex) {\n+            Canonicalizer.getInstance(\n+                Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode, os);\n+        } catch (InvalidCanonicalizerException | CanonicalizationException ex) {\n@@ -272,5 +259,0 @@\n-    @Deprecated\n-    public static String getFullTextChildrenFromElement(Element element) {\n-        return getFullTextChildrenFromNode(element);\n-    }\n-\n@@ -333,0 +315,42 @@\n+    \/**\n+     * Creates an Element in the XML Encryption specification namespace.\n+     *\n+     * @param doc the factory Document\n+     * @param elementName the local name of the Element\n+     * @return the Element\n+     *\/\n+    public static Element createElementInEncryptionSpace(Document doc, String elementName) {\n+        if (doc == null) {\n+            throw new RuntimeException(\"Document is null\");\n+        }\n+\n+        if (xencPrefix == null || xencPrefix.length() == 0) {\n+            return doc.createElementNS(EncryptionConstants.EncryptionSpecNS, elementName);\n+        }\n+        return\n+            doc.createElementNS(\n+                EncryptionConstants.EncryptionSpecNS, xencPrefix + \":\" + elementName\n+            );\n+    }\n+\n+    \/**\n+     * Creates an Element in the XML Encryption 1.1 specification namespace.\n+     *\n+     * @param doc the factory Document\n+     * @param elementName the local name of the Element\n+     * @return the Element\n+     *\/\n+    public static Element createElementInEncryption11Space(Document doc, String elementName) {\n+        if (doc == null) {\n+            throw new RuntimeException(\"Document is null\");\n+        }\n+\n+        if (xenc11Prefix == null || xenc11Prefix.length() == 0) {\n+            return doc.createElementNS(EncryptionConstants.EncryptionSpec11NS, elementName);\n+        }\n+        return\n+            doc.createElementNS(\n+                EncryptionConstants.EncryptionSpec11NS, xenc11Prefix + \":\" + elementName\n+            );\n+    }\n+\n@@ -369,0 +393,34 @@\n+    \/**\n+     * Returns true if the element is in XML Encryption namespace and the local\n+     * name equals the supplied one.\n+     *\n+     * @param element\n+     * @param localName\n+     * @return true if the element is in XML Encryption namespace and the local name\n+     * equals the supplied one\n+     *\/\n+    public static boolean elementIsInEncryptionSpace(Element element, String localName) {\n+        if (element == null){\n+            return false;\n+        }\n+        return EncryptionConstants.EncryptionSpecNS.equals(element.getNamespaceURI())\n+            && element.getLocalName().equals(localName);\n+    }\n+\n+    \/**\n+     * Returns true if the element is in XML Encryption 1.1 namespace and the local\n+     * name equals the supplied one.\n+     *\n+     * @param element\n+     * @param localName\n+     * @return true if the element is in XML Encryption 1.1 namespace and the local name\n+     * equals the supplied one\n+     *\/\n+    public static boolean elementIsInEncryption11Space(Element element, String localName) {\n+        if (element == null){\n+            return false;\n+        }\n+        return EncryptionConstants.EncryptionSpec11NS.equals(element.getNamespaceURI())\n+            && element.getLocalName().equals(localName);\n+    }\n+\n@@ -422,20 +480,0 @@\n-    \/**\n-     * Method createDSctx\n-     *\n-     * @param doc\n-     * @param prefix\n-     * @param namespace\n-     * @return the element.\n-     *\/\n-    public static Element createDSctx(Document doc, String prefix, String namespace) {\n-        if (prefix == null || prefix.trim().length() == 0) {\n-            throw new IllegalArgumentException(\"You must supply a prefix\");\n-        }\n-\n-        Element ctx = doc.createElementNS(null, \"namespaceContext\");\n-\n-        ctx.setAttributeNS(Constants.NamespaceSpecNS, \"xmlns:\" + prefix.trim(), namespace);\n-\n-        return ctx;\n-    }\n-\n@@ -609,1 +647,1 @@\n-                if (number == 0){\n+                if (number == 0) {\n@@ -629,1 +667,1 @@\n-                if (number == 0){\n+                if (number == 0) {\n@@ -645,45 +683,10 @@\n-    public static Text selectDsNodeText(Node sibling, String nodeName, int number) {\n-        Node n = selectDsNode(sibling, nodeName, number);\n-        if (n == null) {\n-            return null;\n-        }\n-        n = n.getFirstChild();\n-        while (n != null && n.getNodeType() != Node.TEXT_NODE) {\n-            n = n.getNextSibling();\n-        }\n-        return (Text)n;\n-    }\n-\n-    \/**\n-     * @param sibling\n-     * @param nodeName\n-     * @param number\n-     * @return nodes with the constrain\n-     *\/\n-    public static Text selectDs11NodeText(Node sibling, String nodeName, int number) {\n-        Node n = selectDs11Node(sibling, nodeName, number);\n-        if (n == null) {\n-            return null;\n-        }\n-        n = n.getFirstChild();\n-        while (n != null && n.getNodeType() != Node.TEXT_NODE) {\n-            n = n.getNextSibling();\n-        }\n-        return (Text)n;\n-    }\n-\n-    \/**\n-     * @param sibling\n-     * @param uri\n-     * @param nodeName\n-     * @param number\n-     * @return nodes with the constrain\n-     *\/\n-    public static Text selectNodeText(Node sibling, String uri, String nodeName, int number) {\n-        Node n = selectNode(sibling, uri, nodeName, number);\n-        if (n == null) {\n-            return null;\n-        }\n-        n = n.getFirstChild();\n-        while (n != null && n.getNodeType() != Node.TEXT_NODE) {\n-            n = n.getNextSibling();\n+    public static Element selectXencNode(Node sibling, String nodeName, int number) {\n+        while (sibling != null) {\n+            if (EncryptionConstants.EncryptionSpecNS.equals(sibling.getNamespaceURI())\n+                && sibling.getLocalName().equals(nodeName)) {\n+                if (number == 0){\n+                    return (Element)sibling;\n+                }\n+                number--;\n+            }\n+            sibling = sibling.getNextSibling();\n@@ -691,1 +694,1 @@\n-        return (Text)n;\n+        return null;\n@@ -757,11 +760,2 @@\n-        Set<Node> resultSet = new HashSet<>();\n-        Iterator<Node> iterator = inputSet.iterator();\n-\n-        while (iterator.hasNext()) {\n-            Node inputNode = iterator.next();\n-\n-            if (!XMLUtils.isDescendantOrSelf(signatureElement, inputNode)) {\n-                resultSet.add(inputNode);\n-            }\n-        }\n-        return resultSet;\n+        return inputSet.stream().filter((inputNode) ->\n+                !XMLUtils.isDescendantOrSelf(signatureElement, inputNode)).collect(Collectors.toSet());\n@@ -836,19 +830,0 @@\n-    \/**\n-     * Returns the attribute value for the attribute with the specified name.\n-     * Returns null if there is no such attribute, or\n-     * the empty string if the attribute value is empty.\n-     *\n-     * <p>This works around a limitation of the DOM\n-     * {@code Element.getAttributeNode} method, which does not distinguish\n-     * between an unspecified attribute and an attribute with a value of\n-     * \"\" (it returns \"\" for both cases).\n-     *\n-     * @param elem the element containing the attribute\n-     * @param name the name of the attribute\n-     * @return the attribute value (may be null if unspecified)\n-     *\/\n-    public static String getAttributeValue(Element elem, String name) {\n-        Attr attr = elem.getAttributeNodeNS(null, name);\n-        return (attr == null) ? null : attr.getValue();\n-    }\n-\n@@ -978,113 +953,3 @@\n-    public static Document newDocument() throws ParserConfigurationException {\n-        ClassLoader loader = getContextClassLoader();\n-        if (loader == null) {\n-            loader = getClassLoader(XMLUtils.class);\n-        }\n-        \/\/ If the ClassLoader is null then just create a DocumentBuilder and use it\n-        if (loader == null) {\n-            DocumentBuilder documentBuilder = buildDocumentBuilder(true);\n-            return documentBuilder.newDocument();\n-        }\n-\n-        Queue<DocumentBuilder> queue = getDocumentBuilderQueue(true, loader);\n-        DocumentBuilder documentBuilder = getDocumentBuilder(true, queue);\n-        Document doc = documentBuilder.newDocument();\n-        repoolDocumentBuilder(documentBuilder, queue);\n-        return doc;\n-    }\n-\n-    public static Document read(InputStream inputStream) throws ParserConfigurationException, SAXException, IOException {\n-        return read(inputStream, true);\n-    }\n-\n-    public static Document read(InputStream inputStream, boolean disAllowDocTypeDeclarations) throws ParserConfigurationException, SAXException, IOException {\n-        ClassLoader loader = getContextClassLoader();\n-        if (loader == null) {\n-            loader = getClassLoader(XMLUtils.class);\n-        }\n-        \/\/ If the ClassLoader is null then just create a DocumentBuilder and use it\n-        if (loader == null) {\n-            DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);\n-            return documentBuilder.parse(inputStream);\n-        }\n-\n-        Queue<DocumentBuilder> queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);\n-        DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);\n-        Document doc = documentBuilder.parse(inputStream);\n-        repoolDocumentBuilder(documentBuilder, queue);\n-        return doc;\n-    }\n-\n-    public static Document read(String uri, boolean disAllowDocTypeDeclarations)\n-        throws ParserConfigurationException, SAXException, IOException {\n-        ClassLoader loader = getContextClassLoader();\n-        if (loader == null) {\n-            loader = getClassLoader(XMLUtils.class);\n-        }\n-        \/\/ If the ClassLoader is null then just create a DocumentBuilder and use it\n-        if (loader == null) {\n-            DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);\n-            return documentBuilder.parse(uri);\n-        }\n-\n-        Queue<DocumentBuilder> queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);\n-        DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);\n-        Document doc = documentBuilder.parse(uri);\n-        repoolDocumentBuilder(documentBuilder, queue);\n-        return doc;\n-    }\n-\n-    public static Document read(InputSource inputSource) throws ParserConfigurationException, SAXException, IOException {\n-        return read(inputSource, true);\n-    }\n-\n-    public static Document read(InputSource inputSource, boolean disAllowDocTypeDeclarations)\n-        throws ParserConfigurationException, SAXException, IOException {\n-        ClassLoader loader = getContextClassLoader();\n-        if (loader == null) {\n-            loader = getClassLoader(XMLUtils.class);\n-        }\n-        \/\/ If the ClassLoader is null then just create a DocumentBuilder and use it\n-        if (loader == null) {\n-            DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);\n-            return documentBuilder.parse(inputSource);\n-        }\n-\n-        Queue<DocumentBuilder> queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);\n-        DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);\n-        Document doc = documentBuilder.parse(inputSource);\n-        repoolDocumentBuilder(documentBuilder, queue);\n-        return doc;\n-    }\n-\n-    \/**\n-     * @deprecated Use XMLUtils.read instead to directly read a document.\n-     *\/\n-    @Deprecated\n-    public static DocumentBuilder createDocumentBuilder(boolean validating) throws ParserConfigurationException {\n-        return createDocumentBuilder(validating, true);\n-    }\n-\n-    \/**\n-     * @deprecated Use XMLUtils.read instead to directly read a document.\n-     *\/\n-    @Deprecated\n-    public static DocumentBuilder createDocumentBuilder(\n-        boolean validating, boolean disAllowDocTypeDeclarations\n-    ) throws ParserConfigurationException {\n-        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\n-        dfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\n-        if (disAllowDocTypeDeclarations) {\n-            dfactory.setFeature(\"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\", true);\n-        }\n-        dfactory.setValidating(validating);\n-        dfactory.setNamespaceAware(true);\n-        return dfactory.newDocumentBuilder();\n-    }\n-\n-    \/**\n-     * @deprecated This method has no effect in Santuario 2.1.4\n-     *\/\n-    @Deprecated\n-    public static boolean repoolDocumentBuilder(DocumentBuilder db) {\n-        return true;\n+    public static Document read(InputStream inputStream, boolean disallowDocTypeDeclarations) throws XMLParserException {\n+        \/\/ Delegate to XMLParser implementation\n+        return xmlParserImpl.parse(inputStream, disallowDocTypeDeclarations);\n@@ -1138,34 +1003,0 @@\n-    private static Queue<DocumentBuilder> getDocumentBuilderQueue(boolean disAllowDocTypeDeclarations, ClassLoader loader) throws ParserConfigurationException {\n-        Map<ClassLoader, Queue<DocumentBuilder>> docBuilderCache =\n-            disAllowDocTypeDeclarations ? DOCUMENT_BUILDERS_DISALLOW_DOCTYPE : DOCUMENT_BUILDERS;\n-        Queue<DocumentBuilder> queue = docBuilderCache.get(loader);\n-        if (queue == null) {\n-            queue = new ArrayBlockingQueue<>(parserPoolSize);\n-            docBuilderCache.put(loader, queue);\n-        }\n-\n-        return queue;\n-    }\n-\n-    private static DocumentBuilder getDocumentBuilder(boolean disAllowDocTypeDeclarations, Queue<DocumentBuilder> queue) throws ParserConfigurationException {\n-        DocumentBuilder db = queue.poll();\n-        if (db == null) {\n-            db = buildDocumentBuilder(disAllowDocTypeDeclarations);\n-        }\n-        return db;\n-    }\n-\n-    private static DocumentBuilder buildDocumentBuilder(boolean disAllowDocTypeDeclarations) throws ParserConfigurationException {\n-        DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n-        f.setNamespaceAware(true);\n-        f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n-        f.setFeature(\"http:\/\/apache.org\/xml\/features\/disallow-doctype-decl\", disAllowDocTypeDeclarations);\n-        return f.newDocumentBuilder();\n-    }\n-\n-    private static void repoolDocumentBuilder(DocumentBuilder db, Queue<DocumentBuilder> queue) {\n-        if (queue != null) {\n-            db.reset();\n-            queue.offer(db);\n-        }\n-    }\n@@ -1173,23 +1004,0 @@\n-    private static ClassLoader getContextClassLoader() {\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                    return Thread.currentThread().getContextClassLoader();\n-                }\n-            });\n-        }\n-        return Thread.currentThread().getContextClassLoader();\n-    }\n-\n-    private static ClassLoader getClassLoader(final Class<?> clazz) {\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                public ClassLoader run() {\n-                    return clazz.getClassLoader();\n-                }\n-            });\n-        }\n-        return clazz.getClassLoader();\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/XMLUtils.java","additions":126,"deletions":318,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    private static boolean xalanInstalled;\n+    private static final boolean xalanInstalled;\n@@ -35,0 +35,1 @@\n+        boolean installed = false;\n@@ -39,1 +40,1 @@\n-                xalanInstalled = true;\n+                installed = true;\n@@ -44,4 +45,1 @@\n-    }\n-\n-    protected static synchronized boolean isXalanInstalled() {\n-        return xalanInstalled;\n+        xalanInstalled = installed;\n@@ -54,3 +52,0 @@\n-        if (!isXalanInstalled()) {\n-            return new JDKXPathFactory();\n-        }\n@@ -58,1 +53,1 @@\n-        if (XalanXPathAPI.isInstalled()) {\n+        if (xalanInstalled && XalanXPathAPI.isInstalled()) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/XPathFactory.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-public class XalanXPathAPI implements XPathAPI {\n+class XalanXPathAPI implements XPathAPI {\n@@ -114,1 +114,1 @@\n-    public static synchronized boolean isInstalled() {\n+    public static boolean isInstalled() {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/XalanXPathAPI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -27,1 +28,2 @@\n-import java.util.Map;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -35,1 +37,0 @@\n-import org.w3c.dom.Attr;\n@@ -49,1 +50,1 @@\n-    private static final List<ResourceResolver> resolverList = new ArrayList<>();\n+    private static final List<ResourceResolverSpi> resolverList = new CopyOnWriteArrayList<>();\n@@ -51,2 +52,1 @@\n-    \/** Field resolverSpi *\/\n-    private final ResourceResolverSpi resolverSpi;\n+    private static final AtomicBoolean defaultResolversAdded = new AtomicBoolean();\n@@ -55,125 +55,1 @@\n-     * Constructor ResourceResolver\n-     *\n-     * @param resourceResolver\n-     *\/\n-    public ResourceResolver(ResourceResolverSpi resourceResolver) {\n-        this.resolverSpi = resourceResolver;\n-    }\n-\n-    \/**\n-     * Method getInstance\n-     *\n-     * @param uriAttr\n-     * @param baseURI\n-     * @param secureValidation\n-     * @return the instance\n-     *\n-     * @throws ResourceResolverException\n-     *\/\n-    public static final ResourceResolver getInstance(\n-        Attr uriAttr, String baseURI, boolean secureValidation\n-    ) throws ResourceResolverException {\n-        ResourceResolverContext context = new ResourceResolverContext(uriAttr, baseURI, secureValidation);\n-        return internalGetInstance(context);\n-    }\n-\n-    private static <N> ResourceResolver internalGetInstance(ResourceResolverContext context)\n-            throws ResourceResolverException {\n-        synchronized (resolverList) {\n-            for (ResourceResolver resolver : resolverList) {\n-                ResourceResolver resolverTmp = resolver;\n-                if (!resolver.resolverSpi.engineIsThreadSafe()) {\n-                    try {\n-                        @SuppressWarnings(\"deprecation\")\n-                        ResourceResolver tmp =\n-                            new ResourceResolver(resolver.resolverSpi.getClass().newInstance());\n-                        resolverTmp = tmp;\n-                    } catch (InstantiationException e) {\n-                        throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, \"\");\n-                    } catch (IllegalAccessException e) {\n-                        throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, \"\");\n-                    }\n-                }\n-\n-                LOG.debug(\"check resolvability by class {}\", resolverTmp.getClass().getName());\n-\n-                if (resolverTmp.canResolve(context)) {\n-                    \/\/ Check to see whether the Resolver is allowed\n-                    if (context.secureValidation\n-                        && (resolverTmp.resolverSpi instanceof ResolverLocalFilesystem\n-                            || resolverTmp.resolverSpi instanceof ResolverDirectHTTP)) {\n-                        Object exArgs[] = { resolverTmp.resolverSpi.getClass().getName() };\n-                        throw new ResourceResolverException(\n-                            \"signature.Reference.ForbiddenResolver\", exArgs, context.uriToResolve, context.baseUri\n-                        );\n-                    }\n-                    return resolverTmp;\n-                }\n-            }\n-        }\n-\n-        Object exArgs[] = { context.uriToResolve != null\n-                ? context.uriToResolve : \"null\", context.baseUri };\n-\n-        throw new ResourceResolverException(\"utils.resolver.noClass\", exArgs, context.uriToResolve, context.baseUri);\n-    }\n-\n-    \/**\n-     * Method getInstance\n-     *\n-     * @param uri\n-     * @param baseURI\n-     * @param individualResolvers\n-     * @return the instance\n-     *\n-     * @throws ResourceResolverException\n-     *\/\n-    public static ResourceResolver getInstance(\n-        Attr uri, String baseURI, List<ResourceResolver> individualResolvers\n-    ) throws ResourceResolverException {\n-        return getInstance(uri, baseURI, individualResolvers, true);\n-    }\n-\n-    \/**\n-     * Method getInstance\n-     *\n-     * @param uri\n-     * @param baseURI\n-     * @param individualResolvers\n-     * @param secureValidation\n-     * @return the instance\n-     *\n-     * @throws ResourceResolverException\n-     *\/\n-    public static ResourceResolver getInstance(\n-        Attr uri, String baseURI, List<ResourceResolver> individualResolvers, boolean secureValidation\n-    ) throws ResourceResolverException {\n-        LOG.debug(\n-            \"I was asked to create a ResourceResolver and got {}\",\n-            (individualResolvers == null ? 0 : individualResolvers.size())\n-        );\n-\n-        ResourceResolverContext context = new ResourceResolverContext(uri, baseURI, secureValidation);\n-\n-        \/\/ first check the individual Resolvers\n-        if (individualResolvers != null) {\n-            for (int i = 0; i < individualResolvers.size(); i++) {\n-                ResourceResolver resolver = individualResolvers.get(i);\n-\n-                if (resolver != null) {\n-                    String currentClass = resolver.resolverSpi.getClass().getName();\n-                    LOG.debug(\"check resolvability by class {}\", currentClass);\n-\n-                    if (resolver.canResolve(context)) {\n-                        return resolver;\n-                    }\n-                }\n-            }\n-        }\n-\n-        return internalGetInstance(context);\n-    }\n-\n-    \/**\n-     * Registers a ResourceResolverSpi class. This method LOGs a warning if\n-     * the class cannot be registered.\n+     * Registers a ResourceResolverSpi class.\n@@ -182,0 +58,3 @@\n+     * @throws InstantiationException\n+     * @throws IllegalAccessException\n+     * @throws ClassNotFoundException\n@@ -186,1 +65,1 @@\n-    public static void register(String className) {\n+    public static void register(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n@@ -188,8 +67,4 @@\n-        try {\n-            Class<ResourceResolverSpi> resourceResolverClass =\n-                (Class<ResourceResolverSpi>)\n-                ClassLoaderUtils.loadClass(className, ResourceResolver.class);\n-            register(resourceResolverClass, false);\n-        } catch (ClassNotFoundException e) {\n-            LOG.warn(\"Error loading resolver \" + className + \" disabling it\");\n-        }\n+        Class<ResourceResolverSpi> resourceResolverClass =\n+            (Class<ResourceResolverSpi>)\n+            ClassLoaderUtils.loadClass(className, ResourceResolver.class);\n+        register(JavaUtils.newInstanceWithEmptyConstructor(resourceResolverClass), false);\n@@ -199,2 +74,1 @@\n-     * Registers a ResourceResolverSpi class at the beginning of the provider\n-     * list. This method LOGs a warning if the class cannot be registered.\n+     * Registers a ResourceResolverSpi class at the beginning of the provider list.\n@@ -203,0 +77,3 @@\n+     * @throws InstantiationException\n+     * @throws IllegalAccessException\n+     * @throws ClassNotFoundException\n@@ -207,1 +84,1 @@\n-    public static void registerAtStart(String className) {\n+    public static void registerAtStart(String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n@@ -209,8 +86,4 @@\n-        try {\n-            Class<ResourceResolverSpi> resourceResolverClass =\n-                (Class<ResourceResolverSpi>)\n-                ClassLoaderUtils.loadClass(className, ResourceResolver.class);\n-            register(resourceResolverClass, true);\n-        } catch (ClassNotFoundException e) {\n-            LOG.warn(\"Error loading resolver \" + className + \" disabling it\");\n-        }\n+        Class<ResourceResolverSpi> resourceResolverClass =\n+            (Class<ResourceResolverSpi>)\n+            ClassLoaderUtils.loadClass(className, ResourceResolver.class);\n+        register(JavaUtils.newInstanceWithEmptyConstructor(resourceResolverClass), true);\n@@ -220,3 +93,2 @@\n-     * Registers a ResourceResolverSpi class. This method LOGs a warning if the class\n-     * cannot be registered.\n-     * @param className\n+     * Registers a ResourceResolverSpi instance.\n+     * @param resourceResolverSpi\n@@ -227,1 +99,1 @@\n-    public static void register(Class<? extends ResourceResolverSpi> className, boolean start) {\n+    public static void register(ResourceResolverSpi resourceResolverSpi, boolean start) {\n@@ -229,8 +101,4 @@\n-        try {\n-            @SuppressWarnings(\"deprecation\")\n-            ResourceResolverSpi resourceResolverSpi = className.newInstance();\n-            register(resourceResolverSpi, start);\n-        } catch (IllegalAccessException e) {\n-            LOG.warn(\"Error loading resolver \" + className + \" disabling it\");\n-        } catch (InstantiationException e) {\n-            LOG.warn(\"Error loading resolver \" + className + \" disabling it\");\n+        if (start) {\n+            resolverList.add(0, resourceResolverSpi);\n+        } else {\n+            resolverList.add(resourceResolverSpi);\n@@ -238,0 +106,1 @@\n+        LOG.debug(\"Registered resolver: {}\", resourceResolverSpi.toString());\n@@ -241,4 +110,6 @@\n-     * Registers a ResourceResolverSpi instance. This method LOGs a warning if the class\n-     * cannot be registered.\n-     * @param resourceResolverSpi\n-     * @param start\n+     * Registers a list of ResourceResolverSpi classes.\n+     *\n+     * @param classNames\n+     * @throws InstantiationException\n+     * @throws IllegalAccessException\n+     * @throws ClassNotFoundException\n@@ -246,1 +117,1 @@\n-     *    caller does not have permission to register a resource resolver\n+     *    caller does not have permission to register the key resolver\n@@ -248,1 +119,2 @@\n-    public static void register(ResourceResolverSpi resourceResolverSpi, boolean start) {\n+    public static void registerClassNames(List<String> classNames)\n+        throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {\n@@ -250,6 +122,6 @@\n-        synchronized(resolverList) {\n-            if (start) {\n-                resolverList.add(0, new ResourceResolver(resourceResolverSpi));\n-            } else {\n-                resolverList.add(new ResourceResolver(resourceResolverSpi));\n-            }\n+\n+        List<ResourceResolverSpi> resourceResolversToAdd = new ArrayList<>(classNames.size());\n+        for (String className : classNames) {\n+            ResourceResolverSpi resourceResolverSpi = (ResourceResolverSpi)JavaUtils\n+                    .newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, ResourceResolver.class));\n+            resourceResolversToAdd.add(resourceResolverSpi);\n@@ -257,1 +129,1 @@\n-        LOG.debug(\"Registered resolver: {}\", resourceResolverSpi.toString());\n+        resolverList.addAll(resourceResolversToAdd);\n@@ -264,5 +136,9 @@\n-        synchronized(resolverList) {\n-            resolverList.add(new ResourceResolver(new ResolverFragment()));\n-            resolverList.add(new ResourceResolver(new ResolverLocalFilesystem()));\n-            resolverList.add(new ResourceResolver(new ResolverXPointer()));\n-            resolverList.add(new ResourceResolver(new ResolverDirectHTTP()));\n+        \/\/ Add a guard so that we don't repeatedly add the default resolvers\n+        if (defaultResolversAdded.compareAndSet(false, true)) {\n+            List<ResourceResolverSpi> resourceResolversToAdd = new ArrayList<>();\n+            resourceResolversToAdd.add(new ResolverFragment());\n+            resourceResolversToAdd.add(new ResolverLocalFilesystem());\n+            resourceResolversToAdd.add(new ResolverXPointer());\n+            resourceResolversToAdd.add(new ResolverDirectHTTP());\n+\n+            resolverList.addAll(resourceResolversToAdd);\n@@ -275,2 +151,1 @@\n-     * @param uri\n-     * @param baseURI\n+     * @param context\n@@ -281,1 +156,1 @@\n-    public XMLSignatureInput resolve(Attr uri, String baseURI, boolean secureValidation)\n+    public static XMLSignatureInput resolve(ResourceResolverContext context)\n@@ -283,3 +158,16 @@\n-        ResourceResolverContext context = new ResourceResolverContext(uri, baseURI, secureValidation);\n-        return resolverSpi.engineResolveURI(context);\n-    }\n+        for (ResourceResolverSpi resolver : resolverList) {\n+            LOG.debug(\"check resolvability by class {}\", resolver.getClass().getName());\n+\n+            if (resolver.engineCanResolveURI(context)) {\n+                \/\/ Check to see whether the Resolver is allowed\n+                if (context.secureValidation\n+                    && (resolver instanceof ResolverLocalFilesystem\n+                        || resolver instanceof ResolverDirectHTTP)) {\n+                    Object[] exArgs = { resolver.getClass().getName() };\n+                    throw new ResourceResolverException(\n+                        \"signature.Reference.ForbiddenResolver\", exArgs, context.uriToResolve, context.baseUri\n+                    );\n+                }\n+                return resolver.engineResolveURI(context);\n+            }\n+        }\n@@ -287,9 +175,2 @@\n-    \/**\n-     * Method setProperty\n-     *\n-     * @param key\n-     * @param value\n-     *\/\n-    public void setProperty(String key, String value) {\n-        resolverSpi.engineSetProperty(key, value);\n-    }\n+        Object[] exArgs = { context.uriToResolve != null\n+                ? context.uriToResolve : \"null\", context.baseUri };\n@@ -297,8 +178,1 @@\n-    \/**\n-     * Method getProperty\n-     *\n-     * @param key\n-     * @return the value of the property\n-     *\/\n-    public String getProperty(String key) {\n-        return resolverSpi.engineGetProperty(key);\n+        throw new ResourceResolverException(\"utils.resolver.noClass\", exArgs, context.uriToResolve, context.baseUri);\n@@ -308,1 +182,1 @@\n-     * Method addProperties\n+     * Method resolve\n@@ -310,8 +184,3 @@\n-     * @param properties\n-     *\/\n-    public void addProperties(Map<String, String> properties) {\n-        resolverSpi.engineAddProperies(properties);\n-    }\n-\n-    \/**\n-     * Method getPropertyKeys\n+     * @param individualResolvers\n+     * @param context\n+     * @return the resource\n@@ -319,1 +188,1 @@\n-     * @return all property keys.\n+     * @throws ResourceResolverException\n@@ -321,3 +190,7 @@\n-    public String[] getPropertyKeys() {\n-        return resolverSpi.engineGetPropertyKeys();\n-    }\n+    public static XMLSignatureInput resolve(\n+        List<ResourceResolverSpi> individualResolvers, ResourceResolverContext context\n+    ) throws ResourceResolverException {\n+        LOG.debug(\n+            \"I was asked to create a ResourceResolver and got {}\",\n+            individualResolvers == null ? 0 : individualResolvers.size()\n+        );\n@@ -325,9 +198,5 @@\n-    \/**\n-     * Method understandsProperty\n-     *\n-     * @param propertyToTest\n-     * @return true if the resolver understands the property\n-     *\/\n-    public boolean understandsProperty(String propertyToTest) {\n-        return resolverSpi.understandsProperty(propertyToTest);\n-    }\n+        \/\/ first check the individual Resolvers\n+        if (individualResolvers != null) {\n+            for (ResourceResolverSpi resolver : individualResolvers) {\n+                String currentClass = resolver.getClass().getName();\n+                LOG.debug(\"check resolvability by class {}\", currentClass);\n@@ -335,9 +204,7 @@\n-    \/**\n-     * Method canResolve\n-     *\n-     * @param uri\n-     * @param baseURI\n-     * @return true if it can resolve the uri\n-     *\/\n-    private boolean canResolve(ResourceResolverContext context) {\n-        return this.resolverSpi.engineCanResolveURI(context);\n+                if (resolver.engineCanResolveURI(context)) {\n+                    return resolver.engineResolveURI(context);\n+                }\n+            }\n+        }\n+\n+        return resolve(context);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolver.java","additions":101,"deletions":234,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.Collections;\n+import java.util.Map;\n+\n@@ -29,6 +32,1 @@\n-    public ResourceResolverContext(Attr attr, String baseUri, boolean secureValidation) {\n-        this.attr = attr;\n-        this.baseUri = baseUri;\n-        this.secureValidation = secureValidation;\n-        this.uriToResolve = attr != null ? attr.getValue() : null;\n-    }\n+    private final Map<String, String> properties;\n@@ -43,0 +41,17 @@\n+\n+    public ResourceResolverContext(Attr attr, String baseUri, boolean secureValidation) {\n+        this(attr, baseUri, secureValidation, Collections.emptyMap());\n+    }\n+\n+    public ResourceResolverContext(Attr attr, String baseUri, boolean secureValidation, Map<String, String> properties) {\n+        this.attr = attr;\n+        this.baseUri = baseUri;\n+        this.secureValidation = secureValidation;\n+        this.uriToResolve = attr != null ? attr.getValue() : null;\n+        this.properties = Collections.unmodifiableMap(properties != null ? properties : Collections.emptyMap());\n+    }\n+\n+    public Map<String, String> getProperties() {\n+        return properties;\n+    }\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolverContext.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public ResourceResolverException(String msgID, Object exArgs[], String uri,\n+    public ResourceResolverException(String msgID, Object[] exArgs, String uri,\n@@ -102,1 +102,1 @@\n-                                     String baseURI, String msgID, Object exArgs[]) {\n+                                     String baseURI, String msgID, Object[] exArgs) {\n@@ -110,1 +110,1 @@\n-    public ResourceResolverException(String msgID, Object exArgs[],\n+    public ResourceResolverException(String msgID, Object[] exArgs,\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolverException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n-\n@@ -33,0 +30,1 @@\n+ * Extensions of this class must be thread-safe.\n@@ -36,6 +34,0 @@\n-    private static final com.sun.org.slf4j.internal.Logger LOG =\n-        com.sun.org.slf4j.internal.LoggerFactory.getLogger(ResourceResolverSpi.class);\n-\n-    \/** Field properties *\/\n-    protected Map<String, String> properties;\n-\n@@ -53,49 +45,0 @@\n-    \/**\n-     * Method engineSetProperty\n-     *\n-     * @param key\n-     * @param value\n-     *\/\n-    public void engineSetProperty(String key, String value) {\n-        if (properties == null) {\n-            properties = new HashMap<>();\n-        }\n-        properties.put(key, value);\n-    }\n-\n-    \/**\n-     * Method engineGetProperty\n-     *\n-     * @param key\n-     * @return the value of the property\n-     *\/\n-    public String engineGetProperty(String key) {\n-        if (properties == null) {\n-            return null;\n-        }\n-        return properties.get(key);\n-    }\n-\n-    \/**\n-     *\n-     * @param newProperties\n-     *\/\n-    public void engineAddProperies(Map<String, String> newProperties) {\n-        if (newProperties != null && !newProperties.isEmpty()) {\n-            if (properties == null) {\n-                properties = new HashMap<>();\n-            }\n-            properties.putAll(newProperties);\n-        }\n-    }\n-\n-    \/**\n-     * Tells if the implementation does can be reused by several threads safely.\n-     * It normally means that the implementation does not have any member, or there is\n-     * member change between engineCanResolve and engineResolve invocations. Or it maintains all\n-     * member info in ThreadLocal methods.\n-     *\/\n-    public boolean engineIsThreadSafe() {\n-        return false;\n-    }\n-\n@@ -111,74 +54,0 @@\n-    \/**\n-     * Method engineGetPropertyKeys\n-     *\n-     * @return the property keys\n-     *\/\n-    public String[] engineGetPropertyKeys() {\n-        return new String[0];\n-    }\n-\n-    \/**\n-     * Method understandsProperty\n-     *\n-     * @param propertyToTest\n-     * @return true if understands the property\n-     *\/\n-    public boolean understandsProperty(String propertyToTest) {\n-        String[] understood = this.engineGetPropertyKeys();\n-\n-        if (understood != null) {\n-            for (String str : understood) {\n-                if (str.equals(propertyToTest)) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-\n-    \/**\n-     * Fixes a platform dependent filename to standard URI form.\n-     *\n-     * @param str The string to fix.\n-     *\n-     * @return Returns the fixed URI string.\n-     *\/\n-    public static String fixURI(String str) {\n-\n-        \/\/ handle platform dependent strings\n-        str = str.replace(java.io.File.separatorChar, '\/');\n-\n-        if (str.length() >= 4) {\n-\n-            \/\/ str =~ \/^\\W:\\\/([^\/])\/ # to speak perl ;-))\n-            char ch0 = Character.toUpperCase(str.charAt(0));\n-            char ch1 = str.charAt(1);\n-            char ch2 = str.charAt(2);\n-            char ch3 = str.charAt(3);\n-            boolean isDosFilename = 'A' <= ch0 && ch0 <= 'Z'\n-                && ch1 == ':' && ch2 == '\/'\n-                && ch3 != '\/';\n-\n-            if (isDosFilename) {\n-                LOG.debug(\"Found DOS filename: {}\", str);\n-            }\n-        }\n-\n-        \/\/ Windows fix\n-        if (str.length() >= 2) {\n-            char ch1 = str.charAt(1);\n-\n-            if (ch1 == ':') {\n-                char ch0 = Character.toUpperCase(str.charAt(0));\n-\n-                if ('A' <= ch0 && ch0 <= 'Z') {\n-                    str = \"\/\" + str;\n-                }\n-            }\n-        }\n-\n-        \/\/ done\n-        return str;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolverSpi.java","additions":1,"deletions":132,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.FileNotFoundException;\n@@ -28,1 +27,0 @@\n-import java.io.InputStream;\n@@ -30,0 +28,1 @@\n+import java.nio.file.Path;\n@@ -34,0 +33,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverException;\n@@ -40,6 +40,1 @@\n-    private InputStream inStream;\n-\n-    @Override\n-    public boolean engineIsThreadSafe() {\n-        return true;\n-    }\n+    private final Path resourcePath;\n@@ -49,1 +44,0 @@\n-     * @throws FileNotFoundException\n@@ -52,2 +46,2 @@\n-    public ResolverAnonymous(String filename) throws FileNotFoundException, IOException {\n-        inStream = Files.newInputStream(Paths.get(filename));\n+    public ResolverAnonymous(String filename) throws IOException {\n+        this(Paths.get(filename));\n@@ -57,1 +51,1 @@\n-     * @param is\n+     * @param resourcePath\n@@ -59,2 +53,2 @@\n-    public ResolverAnonymous(InputStream is) {\n-        inStream = is;\n+    public ResolverAnonymous(Path resourcePath) {\n+        this.resourcePath = resourcePath;\n@@ -65,4 +59,8 @@\n-    public XMLSignatureInput engineResolveURI(ResourceResolverContext context) {\n-        XMLSignatureInput input = new XMLSignatureInput(inStream);\n-        input.setSecureValidation(context.secureValidation);\n-        return input;\n+    public XMLSignatureInput engineResolveURI(ResourceResolverContext context) throws ResourceResolverException {\n+        try {\n+            XMLSignatureInput input = new XMLSignatureInput(Files.newInputStream(resourcePath));\n+            input.setSecureValidation(context.secureValidation);\n+            return input;\n+        } catch (IOException e) {\n+            throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, \"generic.EmptyMessage\");\n+        }\n@@ -76,4 +74,1 @@\n-        if (context.uriToResolve == null) {\n-            return true;\n-        }\n-        return false;\n+        return context.uriToResolve == null;\n@@ -82,4 +77,0 @@\n-    \/** {@inheritDoc} *\/\n-    public String[] engineGetPropertyKeys() {\n-        return new String[0];\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverAnonymous.java","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.net.MalformedURLException;\n@@ -36,0 +35,2 @@\n+import java.util.Collections;\n+import java.util.Map;\n@@ -69,1 +70,1 @@\n-    private static final String properties[] = {\n+    private static final String[] properties = {\n@@ -93,3 +94,9 @@\n-    @Override\n-    public boolean engineIsThreadSafe() {\n-        return true;\n+    private final Map<String, String> resolverProperties;\n+\n+    public ResolverDirectHTTP() {\n+        resolverProperties = Collections.emptyMap();\n+    }\n+\n+    public ResolverDirectHTTP(Map<String, String> resolverProperties) {\n+        this.resolverProperties =\n+            Collections.unmodifiableMap(resolverProperties != null ? resolverProperties : Collections.emptyMap());\n@@ -109,1 +116,1 @@\n-            URLConnection urlConnection = openConnection(url);\n+            URLConnection urlConnection = openConnection(url, context);\n@@ -117,1 +124,1 @@\n-                    engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpBasicUser]);\n+                    getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpBasicUser]);\n@@ -119,1 +126,1 @@\n-                    engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpBasicPass]);\n+                    getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpBasicPass]);\n@@ -122,1 +129,1 @@\n-                    urlConnection = openConnection(url);\n+                    urlConnection = openConnection(url, context);\n@@ -156,1 +163,1 @@\n-        } catch (URISyntaxException ex) {\n+        } catch (URISyntaxException | IOException | IllegalArgumentException ex) {\n@@ -158,6 +165,0 @@\n-        } catch (MalformedURLException ex) {\n-            throw new ResourceResolverException(ex, context.uriToResolve, context.baseUri, \"generic.EmptyMessage\");\n-        } catch (IOException ex) {\n-            throw new ResourceResolverException(ex, context.uriToResolve, context.baseUri, \"generic.EmptyMessage\");\n-        } catch (IllegalArgumentException e) {\n-            throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, \"generic.EmptyMessage\");\n@@ -167,1 +168,1 @@\n-    private URLConnection openConnection(URL url) throws IOException {\n+    private URLConnection openConnection(URL url, ResourceResolverContext context) throws IOException {\n@@ -170,1 +171,1 @@\n-                engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyHost]);\n+            getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyHost]);\n@@ -172,1 +173,1 @@\n-                engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyPort]);\n+            getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyPort]);\n@@ -174,1 +175,1 @@\n-                engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyUser]);\n+            getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyUser]);\n@@ -176,1 +177,1 @@\n-                engineGetProperty(ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyPass]);\n+            getProperty(context, ResolverDirectHTTP.properties[ResolverDirectHTTP.HttpProxyPass]);\n@@ -213,1 +214,1 @@\n-        if (context.uriToResolve.equals(\"\") || context.uriToResolve.charAt(0) == '#') {\n+        if (context.uriToResolve.isEmpty() || context.uriToResolve.charAt(0) == '#') {\n@@ -231,7 +232,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    public String[] engineGetPropertyKeys() {\n-        return ResolverDirectHTTP.properties.clone();\n-    }\n-\n@@ -248,3 +242,1 @@\n-            URI uriNewNoFrag =\n-                new URI(newUri.getScheme(), newUri.getSchemeSpecificPart(), null);\n-            return uriNewNoFrag;\n+            return new URI(newUri.getScheme(), newUri.getSchemeSpecificPart(), null);\n@@ -255,0 +247,10 @@\n+    private String getProperty(ResourceResolverContext context, String propertyName) {\n+        \/\/ First check the properties defined on this Resolver.\n+        if (resolverProperties.containsKey(propertyName)) {\n+            return resolverProperties.get(propertyName);\n+        }\n+\n+        \/\/ Otherwise defer to the passed in properties\n+        return context.getProperties().get(propertyName);\n+    }\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverDirectHTTP.java","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -46,5 +46,0 @@\n-    @Override\n-    public boolean engineIsThreadSafe() {\n-        return true;\n-    }\n-\n@@ -61,1 +56,1 @@\n-        if (context.uriToResolve.equals(\"\")) {\n+        if (context.uriToResolve.isEmpty()) {\n@@ -81,1 +76,1 @@\n-                Object exArgs[] = { id };\n+                Object[] exArgs = { id };\n@@ -89,1 +84,1 @@\n-                    Object exArgs[] = { id };\n+                    Object[] exArgs = { id };\n@@ -124,1 +119,1 @@\n-        if (context.uriToResolve.equals(\"\") ||\n+        if (context.uriToResolve.isEmpty() ||\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverFragment.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,5 +46,0 @@\n-    @Override\n-    public boolean engineIsThreadSafe() {\n-        return true;\n-    }\n-\n@@ -118,1 +113,1 @@\n-        if (context.uriToResolve.equals(\"\") || context.uriToResolve.charAt(0) == '#' ||\n+        if (context.uriToResolve.isEmpty() || context.uriToResolve.charAt(0) == '#' ||\n@@ -149,3 +144,1 @@\n-            URI uriNewNoFrag =\n-                new URI(newUri.getScheme(), newUri.getSchemeSpecificPart(), null);\n-            return uriNewNoFrag;\n+            return new URI(newUri.getScheme(), newUri.getSchemeSpecificPart(), null);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverLocalFilesystem.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -56,5 +56,0 @@\n-    @Override\n-    public boolean engineIsThreadSafe() {\n-        return true;\n-    }\n-\n@@ -80,1 +75,1 @@\n-                    Object exArgs[] = { id };\n+                    Object[] exArgs = { id };\n@@ -88,1 +83,1 @@\n-                Object exArgs[] = { id };\n+                Object[] exArgs = { id };\n@@ -113,8 +108,1 @@\n-        if (context.uriToResolve == null) {\n-            return false;\n-        }\n-        if (isXPointerSlash(context.uriToResolve) || isXPointerId(context.uriToResolve)) {\n-            return true;\n-        }\n-\n-        return false;\n+        return isXPointerSlash(context.uriToResolve) || isXPointerId(context.uriToResolve);\n@@ -130,5 +118,1 @@\n-        if (uri.equals(\"#xpointer(\/)\")) {\n-            return true;\n-        }\n-\n-        return false;\n+        return \"#xpointer(\/)\".equals(uri);\n@@ -144,1 +128,1 @@\n-        if (uri.startsWith(XP) && uri.endsWith(\"))\")) {\n+        if (uri != null && uri.startsWith(XP) && uri.endsWith(\"))\")) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverXPointer.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+    public void warn(String s, Object... o) {\n+        log0(Level.WARNING, s, o);\n+    }\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/slf4j\/internal\/Logger.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DigesterOutputStream.java, v 1.5 2005\/12\/20 20:02:39 mullan Exp $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/DigesterOutputStream.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: SignerOutputStream.java, v 1.2 2005\/09\/15 14:29:02 mullan Exp $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/SignerOutputStream.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: ApacheCanonicalizer.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +57,1 @@\n-    protected Canonicalizer apacheCanonicalizer;\n+    protected Canonicalizer canonicalizer;\n@@ -117,1 +114,1 @@\n-        if (apacheCanonicalizer == null) {\n+        if (canonicalizer == null) {\n@@ -119,3 +116,1 @@\n-                apacheCanonicalizer = Canonicalizer.getInstance(getAlgorithm());\n-                boolean secVal = Utils.secureValidation(xc);\n-                apacheCanonicalizer.setSecureValidation(secVal);\n+                canonicalizer = Canonicalizer.getInstance(getAlgorithm());\n@@ -130,6 +125,2 @@\n-        if (os != null) {\n-            apacheCanonicalizer.setWriter(os);\n-        } else {\n-            apacheCanonicalizer.setWriter(new ByteArrayOutputStream());\n-        }\n-\n+        boolean isByteArrayOutputStream = os == null;\n+        OutputStream writer = isByteArrayOutputStream ? new ByteArrayOutputStream() : os;\n@@ -137,0 +128,1 @@\n+            boolean secVal = Utils.secureValidation(xc);\n@@ -143,3 +135,2 @@\n-                        return new OctetStreamData(new ByteArrayInputStream\n-                            (apacheCanonicalizer.canonicalizeSubtree\n-                                (in.getSubNode(), inclusiveNamespaces)));\n+                        canonicalizer.canonicalizeSubtree(in.getSubNode(), inclusiveNamespaces, writer);\n+                        return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -147,3 +138,2 @@\n-                        return new OctetStreamData(new ByteArrayInputStream\n-                            (apacheCanonicalizer.canonicalizeSubtree\n-                                (in.getSubNode())));\n+                        canonicalizer.canonicalizeSubtree(in.getSubNode(), writer);\n+                        return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -154,3 +144,2 @@\n-                    return new OctetStreamData(new ByteArrayInputStream(\n-                        apacheCanonicalizer.canonicalize(\n-                            Utils.readBytesFromStream(in.getOctetStream()))));\n+                    canonicalizer.canonicalize(Utils.readBytesFromStream(in.getOctetStream()), writer, secVal);\n+                    return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -161,3 +150,2 @@\n-                    return new OctetStreamData(new ByteArrayInputStream\n-                        (apacheCanonicalizer.canonicalizeSubtree\n-                         (subTree.getRoot(), inclusiveNamespaces)));\n+                    canonicalizer.canonicalizeSubtree(subTree.getRoot(), inclusiveNamespaces, writer);\n+                    return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -165,3 +153,2 @@\n-                    return new OctetStreamData(new ByteArrayInputStream\n-                        (apacheCanonicalizer.canonicalizeSubtree\n-                         (subTree.getRoot())));\n+                    canonicalizer.canonicalizeSubtree(subTree.getRoot(), writer);\n+                    return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -175,4 +162,2 @@\n-                return new OctetStreamData(new ByteArrayInputStream(\n-                    apacheCanonicalizer.canonicalize(\n-                        Utils.readBytesFromStream(\n-                        ((OctetStreamData)data).getOctetStream()))));\n+                canonicalizer.canonicalize(Utils.readBytesFromStream(((OctetStreamData)data).getOctetStream()), writer, secVal);\n+                return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -180,0 +165,1 @@\n+\n@@ -181,3 +167,2 @@\n-                return new OctetStreamData(new ByteArrayInputStream(\n-                    apacheCanonicalizer.canonicalizeXPathNodeSet\n-                        (nodeSet, inclusiveNamespaces)));\n+                canonicalizer.canonicalizeXPathNodeSet(nodeSet, inclusiveNamespaces, writer);\n+                return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -185,2 +170,2 @@\n-                return new OctetStreamData(new ByteArrayInputStream(\n-                    apacheCanonicalizer.canonicalizeXPathNodeSet(nodeSet)));\n+                canonicalizer.canonicalizeXPathNodeSet(nodeSet, writer);\n+                return new OctetStreamData(new ByteArrayInputStream(getC14nBytes(writer, isByteArrayOutputStream)));\n@@ -193,0 +178,7 @@\n+    private byte[] getC14nBytes(OutputStream outputStream, boolean isByteArrayOutputStream) {    \/\/ NOPMD - preserving previous behavior here\n+        if (isByteArrayOutputStream) {\n+            return ((ByteArrayOutputStream)outputStream).toByteArray();\n+        }\n+        return null;\n+    }\n+\n@@ -212,2 +204,0 @@\n-                boolean secVal = Utils.secureValidation(xc);\n-                apacheTransform.setSecureValidation(secVal);\n@@ -251,1 +241,1 @@\n-            in = apacheTransform.performTransform(in, os);\n+            in = apacheTransform.performTransform(in, os, secVal);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheCanonicalizer.java","additions":32,"deletions":42,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: ApacheData.java 1788465 2017-03-24 15:10:51Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: ApacheNodeSetData.java 1496478 2013-06-25 14:01:16Z mullan $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +72,1 @@\n-        Set<Node> inputSet = new LinkedHashSet<Node>();\n+        Set<Node> inputSet = new LinkedHashSet<>();\n@@ -78,1 +75,1 @@\n-        Set<Node> nodeSet = new LinkedHashSet<Node>();\n+        Set<Node> nodeSet = new LinkedHashSet<>();\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheNodeSetData.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: ApacheOctetStreamData.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +30,0 @@\n-import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;\n@@ -42,1 +38,1 @@\n-        throws CanonicalizationException, IOException\n+        throws IOException\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheOctetStreamData.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: ApacheTransform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +57,1 @@\n-    private Transform apacheTransform;\n+    private Transform transform;\n@@ -134,1 +131,1 @@\n-        if (apacheTransform == null) {\n+        if (transform == null) {\n@@ -136,1 +133,1 @@\n-                apacheTransform =\n+                transform =\n@@ -138,3 +135,1 @@\n-                apacheTransform.setElement(transformElem, xc.getBaseURI());\n-                boolean secVal = Utils.secureValidation(xc);\n-                apacheTransform.setSecureValidation(secVal);\n+                transform.setElement(transformElem, xc.getBaseURI());\n@@ -188,1 +183,1 @@\n-                in = apacheTransform.performTransform(in, os);\n+                in = transform.performTransform(in, os, secVal);\n@@ -193,1 +188,1 @@\n-                in = apacheTransform.performTransform(in);\n+                in = transform.performTransform(in, secVal);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheTransform.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMBase64Transform.java 1788465 2017-03-24 15:10:51Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMBase64Transform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,3 +66,1 @@\n-                    apacheCanonicalizer = Canonicalizer.getInstance(C14N_11);\n-                    boolean secVal = Utils.secureValidation(xc);\n-                    apacheCanonicalizer.setSecureValidation(secVal);\n+                    canonicalizer = Canonicalizer.getInstance(C14N_11);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMCanonicalXMLC14N11Method.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMCanonicalXMLC14NMethod.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +62,1 @@\n-                    apacheCanonicalizer = Canonicalizer.getInstance\n+                    canonicalizer = Canonicalizer.getInstance\n@@ -67,2 +64,0 @@\n-                    boolean secVal = Utils.secureValidation(xc);\n-                    apacheCanonicalizer.setSecureValidation(secVal);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMCanonicalXMLC14NMethod.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMCanonicalizationMethod.java 1788465 2017-03-24 15:10:51Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +32,3 @@\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -48,0 +48,13 @@\n+    private static final Set<String> C14N_ALGORITHMS;\n+\n+    static {\n+        Set<String> algorithms = new HashSet<>();\n+        algorithms.add(CanonicalizationMethod.INCLUSIVE);\n+        algorithms.add(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS);\n+        algorithms.add(CanonicalizationMethod.EXCLUSIVE);\n+        algorithms.add(CanonicalizationMethod.EXCLUSIVE_WITH_COMMENTS);\n+        algorithms.add(DOMCanonicalXMLC14N11Method.C14N_11);\n+        algorithms.add(DOMCanonicalXMLC14N11Method.C14N_11_WITH_COMMENTS);\n+        C14N_ALGORITHMS = Collections.unmodifiableSet(algorithms);\n+    }\n+\n@@ -131,1 +144,1 @@\n-        return isInclusiveC14Nalg(alg) || isExclusiveC14Nalg(alg) || isC14N11alg(alg);\n+        return alg != null && C14N_ALGORITHMS.contains(alg);\n@@ -134,9 +147,0 @@\n-    private static boolean isInclusiveC14Nalg(String alg) {\n-        return alg.equals(CanonicalizationMethod.INCLUSIVE)\n-            || alg.equals(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS);\n-    }\n-\n-    private static boolean isExclusiveC14Nalg(String alg) {\n-        return alg.equals(CanonicalizationMethod.EXCLUSIVE)\n-            || alg.equals(CanonicalizationMethod.EXCLUSIVE_WITH_COMMENTS);\n-    }\n@@ -144,4 +148,0 @@\n-    private static boolean isC14N11alg(String alg) {\n-        return alg.equals(DOMCanonicalXMLC14N11Method.C14N_11)\n-            || alg.equals(DOMCanonicalXMLC14N11Method.C14N_11_WITH_COMMENTS);\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMCanonicalizationMethod.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMCryptoBinary.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMDigestMethod.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +229,1 @@\n-     * @param the namespace prefix to use\n+     * @param prefix the namespace prefix to use\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMDigestMethod.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMEnvelopedTransform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMEnvelopedTransform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMExcC14NMethod.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +128,1 @@\n-                prefixListAttr.append(\" \");\n+                prefixListAttr.append(' ');\n@@ -153,1 +150,1 @@\n-                    apacheCanonicalizer = Canonicalizer.getInstance\n+                    canonicalizer = Canonicalizer.getInstance\n@@ -155,2 +152,0 @@\n-                    boolean secVal = Utils.secureValidation(xc);\n-                    apacheCanonicalizer.setSecureValidation(secVal);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMExcC14NMethod.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMHMACSignatureMethod.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +38,1 @@\n+import java.security.Provider;\n@@ -56,0 +54,2 @@\n+    private static final String DOM_SIGNATURE_PROVIDER = \"org.jcp.xml.dsig.internal.dom.MacProvider\";\n+\n@@ -162,1 +162,4 @@\n-                hmac = Mac.getInstance(getJCAAlgorithm());\n+                Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n+                hmac = (p == null)\n+                    ? Mac.getInstance(getJCAAlgorithm())\n+                    : Mac.getInstance(getJCAAlgorithm(), p);\n@@ -189,1 +192,4 @@\n-                hmac = Mac.getInstance(getJCAAlgorithm());\n+                Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n+                hmac = (p == null)\n+                    ? Mac.getInstance(getJCAAlgorithm())\n+                    : Mac.getInstance(getJCAAlgorithm(), p);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMHMACSignatureMethod.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMKeyInfo.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMKeyInfo.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMKeyInfoFactory.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMKeyInfoFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMKeyName.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMKeyName.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMKeyValue.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +93,1 @@\n-        if (kvtElem.getLocalName().equals(\"DSAKeyValue\") && XMLSignature.XMLNS.equals(namespace)) {\n+        if (\"DSAKeyValue\".equals(kvtElem.getLocalName()) && XMLSignature.XMLNS.equals(namespace)) {\n@@ -98,1 +95,1 @@\n-        } else if (kvtElem.getLocalName().equals(\"RSAKeyValue\") && XMLSignature.XMLNS.equals(namespace)) {\n+        } else if (\"RSAKeyValue\".equals(kvtElem.getLocalName()) && XMLSignature.XMLNS.equals(namespace)) {\n@@ -100,1 +97,1 @@\n-        } else if (kvtElem.getLocalName().equals(\"ECKeyValue\") && XMLDSIG_11_XMLNS.equals(namespace)) {\n+        } else if (\"ECKeyValue\".equals(kvtElem.getLocalName()) && XMLDSIG_11_XMLNS.equals(namespace)) {\n@@ -313,1 +310,1 @@\n-            if (curElem.getLocalName().equals(\"P\") && XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {\n+            if (\"P\".equals(curElem.getLocalName()) && XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {\n@@ -321,1 +318,1 @@\n-                && curElem.getLocalName().equals(\"G\") && XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {\n+                && \"G\".equals(curElem.getLocalName()) && XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {\n@@ -330,1 +327,1 @@\n-            \/\/if (curElem != null && curElem.getLocalName().equals(\"J\")) {\n+            \/\/if (curElem != null && \"J\".equals(curElem.getLocalName())) {\n@@ -472,1 +469,1 @@\n-            if (curve.getCurve().getField().getFieldSize() == fieldSize\n+            return curve.getCurve().getField().getFieldSize() == fieldSize\n@@ -476,5 +473,1 @@\n-                && curve.getCofactor() == params.getCofactor()) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n+                && curve.getCofactor() == params.getCofactor();\n@@ -503,1 +496,1 @@\n-            String qname = prefix == null || prefix.length() == 0\n+            String qname = (prefix == null || prefix.length() == 0)\n@@ -533,1 +526,1 @@\n-            if (curElem.getLocalName().equals(\"ECParameters\")\n+            if (\"ECParameters\".equals(curElem.getLocalName())\n@@ -537,1 +530,1 @@\n-            } else if (curElem.getLocalName().equals(\"NamedCurve\")\n+            } else if (\"NamedCurve\".equals(curElem.getLocalName())\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMKeyValue.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMManifest.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMManifest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMPGPData.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMPGPData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+\/*\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+package org.jcp.xml.dsig.internal.dom;\n+\n+import javax.xml.crypto.*;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec;\n+\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.MGF1ParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Text;\n+import org.jcp.xml.dsig.internal.SignerOutputStream;\n+import com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA.SignatureRSASSAPSS.DigestAlgorithm;\n+import com.sun.org.apache.xml.internal.security.utils.Constants;\n+import com.sun.org.apache.xml.internal.security.utils.XMLUtils;\n+\n+\/**\n+ * DOM-based abstract implementation of SignatureMethod for RSA-PSS.\n+ *\n+ *\/\n+public abstract class DOMRSAPSSSignatureMethod extends AbstractDOMSignatureMethod {\n+\n+    private static final String DOM_SIGNATURE_PROVIDER = \"org.jcp.xml.dsig.internal.dom.SignatureProvider\";\n+\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+        com.sun.org.slf4j.internal.LoggerFactory.getLogger(DOMRSAPSSSignatureMethod.class);\n+\n+    private final SignatureMethodParameterSpec params;\n+    private Signature signature;\n+\n+    \/\/ see RFC 6931 for these algorithm definitions\n+    static final String RSA_PSS =\n+        \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss\";\n+\n+    private int trailerField = 1;\n+    private int saltLength = 32;\n+    private String digestName = \"SHA-256\";\n+\n+    \/**\n+     * Creates a {@code DOMSignatureMethod}.\n+     *\n+     * @param params the algorithm-specific params (may be {@code null})\n+     * @throws InvalidAlgorithmParameterException if the parameters are not\n+     *    appropriate for this signature method\n+     *\/\n+    DOMRSAPSSSignatureMethod(AlgorithmParameterSpec params)\n+        throws InvalidAlgorithmParameterException\n+    {\n+        if (params != null &&\n+            !(params instanceof SignatureMethodParameterSpec)) {\n+            throw new InvalidAlgorithmParameterException\n+                (\"params must be of type SignatureMethodParameterSpec\");\n+        }\n+        if (params == null) {\n+            params = getDefaultParameterSpec();\n+        }\n+        checkParams((SignatureMethodParameterSpec)params);\n+        this.params = (SignatureMethodParameterSpec)params;\n+    }\n+\n+    \/**\n+     * Creates a {@code DOMSignatureMethod} from an element. This ctor\n+     * invokes the {@link #unmarshalParams unmarshalParams} method to\n+     * unmarshal any algorithm-specific input parameters.\n+     *\n+     * @param smElem a SignatureMethod element\n+     *\/\n+    DOMRSAPSSSignatureMethod(Element smElem) throws MarshalException {\n+        Element paramsElem = DOMUtils.getFirstChildElement(smElem);\n+        if (paramsElem != null) {\n+            params = unmarshalParams(paramsElem);\n+        } else {\n+            params = getDefaultParameterSpec();\n+        }\n+        try {\n+            checkParams(params);\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            throw new MarshalException(iape);\n+        }\n+    }\n+\n+    @Override\n+    void checkParams(SignatureMethodParameterSpec params)\n+        throws InvalidAlgorithmParameterException\n+    {\n+        if (params != null) {\n+            if (!(params instanceof RSAPSSParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException\n+                    (\"params must be of type RSAPSSParameterSpec\");\n+            }\n+\n+            if (((RSAPSSParameterSpec)params).getTrailerField() > 0) {\n+                trailerField = ((RSAPSSParameterSpec)params).getTrailerField();\n+                LOG.debug(\"Setting trailerField from RSAPSSParameterSpec to: {}\", trailerField);\n+            }\n+            if (((RSAPSSParameterSpec)params).getSaltLength() > 0) {\n+                saltLength = ((RSAPSSParameterSpec)params).getSaltLength();\n+                LOG.debug(\"Setting saltLength from RSAPSSParameterSpec to: {}\", saltLength);\n+            }\n+            if (((RSAPSSParameterSpec)params).getDigestName() != null) {\n+                digestName = ((RSAPSSParameterSpec)params).getDigestName();\n+                LOG.debug(\"Setting digestName from RSAPSSParameterSpec to: {}\", digestName);\n+            }\n+        }\n+    }\n+\n+    public final AlgorithmParameterSpec getParameterSpec() {\n+        return params;\n+    }\n+\n+    void marshalParams(Element parent, String prefix)\n+        throws MarshalException\n+    {\n+        Document ownerDoc = DOMUtils.getOwnerDocument(parent);\n+\n+        Element rsaPssParamsElement = ownerDoc.createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_RSAPSSPARAMS);\n+        rsaPssParamsElement.setAttributeNS(Constants.NamespaceSpecNS, \"xmlns:\" + \"pss\", Constants.XML_DSIG_NS_MORE_07_05);\n+\n+        Element digestMethodElement = DOMUtils.createElement(rsaPssParamsElement.getOwnerDocument(), Constants._TAG_DIGESTMETHOD,\n+                                                             XMLSignature.XMLNS, prefix);\n+        try {\n+            digestMethodElement.setAttributeNS(null, Constants._ATT_ALGORITHM, DigestAlgorithm.fromDigestAlgorithm(digestName).getXmlDigestAlgorithm());\n+        } catch (DOMException | com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+            throw new MarshalException(\"Invalid digest name supplied: \" + digestName);\n+        }\n+        rsaPssParamsElement.appendChild(digestMethodElement);\n+\n+        Element saltLengthElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_SALTLENGTH);\n+        Text saltLengthText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(saltLength));\n+        saltLengthElement.appendChild(saltLengthText);\n+\n+        rsaPssParamsElement.appendChild(saltLengthElement);\n+\n+        Element trailerFieldElement = rsaPssParamsElement.getOwnerDocument().createElementNS(Constants.XML_DSIG_NS_MORE_07_05, \"pss\" + \":\" + Constants._TAG_TRAILERFIELD);\n+        Text trailerFieldText = rsaPssParamsElement.getOwnerDocument().createTextNode(String.valueOf(trailerField));\n+        trailerFieldElement.appendChild(trailerFieldText);\n+\n+        rsaPssParamsElement.appendChild(trailerFieldElement);\n+\n+        parent.appendChild(rsaPssParamsElement);\n+    }\n+\n+    SignatureMethodParameterSpec unmarshalParams(Element paramsElem)\n+        throws MarshalException\n+    {\n+        if (paramsElem != null) {\n+            Element saltLengthNode = XMLUtils.selectNode(paramsElem.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_SALTLENGTH, 0);\n+            Element trailerFieldNode = XMLUtils.selectNode(paramsElem.getFirstChild(), Constants.XML_DSIG_NS_MORE_07_05, Constants._TAG_TRAILERFIELD, 0);\n+            int trailerField = 1;\n+            if (trailerFieldNode != null) {\n+                try {\n+                    trailerField = Integer.parseInt(trailerFieldNode.getTextContent());\n+                } catch (NumberFormatException ex) {\n+                    throw new MarshalException(\"Invalid trailer field supplied: \" + trailerFieldNode.getTextContent());\n+                }\n+            }\n+            String xmlAlgorithm = XMLUtils.selectDsNode(paramsElem.getFirstChild(), Constants._TAG_DIGESTMETHOD, 0).getAttribute(Constants._ATT_ALGORITHM);\n+            DigestAlgorithm digestAlgorithm;\n+            try {\n+                digestAlgorithm = DigestAlgorithm.fromXmlDigestAlgorithm(xmlAlgorithm);\n+            } catch (com.sun.org.apache.xml.internal.security.signature.XMLSignatureException e) {\n+                throw new MarshalException(\"Invalid digest algorithm supplied: \" + xmlAlgorithm);\n+            }\n+            String digestName = digestAlgorithm.getDigestAlgorithm();\n+\n+            RSAPSSParameterSpec params = new RSAPSSParameterSpec();\n+            params.setTrailerField(trailerField);\n+            try {\n+                int saltLength = saltLengthNode == null ? digestAlgorithm.getSaltLength() : Integer.parseInt(saltLengthNode.getTextContent());\n+                params.setSaltLength(saltLength);\n+            } catch (NumberFormatException ex) {\n+                throw new MarshalException(\"Invalid salt length supplied: \" + saltLengthNode.getTextContent());\n+            }\n+            params.setDigestName(digestName);\n+            return params;\n+        }\n+        return getDefaultParameterSpec();\n+    }\n+\n+    boolean verify(Key key, SignedInfo si, byte[] sig,\n+                   XMLValidateContext context)\n+        throws InvalidKeyException, SignatureException, XMLSignatureException\n+    {\n+        if (key == null || si == null || sig == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (!(key instanceof PublicKey)) {\n+            throw new InvalidKeyException(\"key must be PublicKey\");\n+        }\n+        if (signature == null) {\n+            try {\n+                Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n+                signature = (p == null)\n+                    ? Signature.getInstance(getJCAAlgorithm())\n+                    : Signature.getInstance(getJCAAlgorithm(), p);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                throw new XMLSignatureException(nsae);\n+            }\n+        }\n+        signature.initVerify((PublicKey)key);\n+        try {\n+            signature.setParameter(new PSSParameterSpec(digestName, \"MGF1\", new MGF1ParameterSpec(digestName), saltLength, trailerField));\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new XMLSignatureException(e);\n+        }\n+        LOG.debug(\"Signature provider: {}\", signature.getProvider());\n+        LOG.debug(\"Verifying with key: {}\", key);\n+        LOG.debug(\"JCA Algorithm: {}\", getJCAAlgorithm());\n+        LOG.debug(\"Signature Bytes length: {}\", sig.length);\n+\n+        try (SignerOutputStream outputStream = new SignerOutputStream(signature)) {\n+            ((DOMSignedInfo)si).canonicalize(context, outputStream);\n+\n+            return signature.verify(sig);\n+        } catch (IOException ioe) {\n+            throw new XMLSignatureException(ioe);\n+        }\n+    }\n+\n+    byte[] sign(Key key, SignedInfo si, XMLSignContext context)\n+        throws InvalidKeyException, XMLSignatureException\n+    {\n+        if (key == null || si == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if (!(key instanceof PrivateKey)) {\n+            throw new InvalidKeyException(\"key must be PrivateKey\");\n+        }\n+        if (signature == null) {\n+            try {\n+                Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n+                signature = (p == null)\n+                    ? Signature.getInstance(getJCAAlgorithm())\n+                    : Signature.getInstance(getJCAAlgorithm(), p);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                throw new XMLSignatureException(nsae);\n+            }\n+        }\n+        signature.initSign((PrivateKey)key);\n+        try {\n+            signature.setParameter(new PSSParameterSpec(digestName, \"MGF1\", new MGF1ParameterSpec(digestName), saltLength, trailerField));\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new XMLSignatureException(e);\n+        }\n+        LOG.debug(\"Signature provider: {}\", signature.getProvider());\n+        LOG.debug(\"Signing with key: {}\", key);\n+        LOG.debug(\"JCA Algorithm: {}\", getJCAAlgorithm());\n+\n+        try (SignerOutputStream outputStream = new SignerOutputStream(signature)) {\n+            ((DOMSignedInfo)si).canonicalize(context, outputStream);\n+\n+            return signature.sign();\n+        } catch (SignatureException | IOException e) {\n+            throw new XMLSignatureException(e);\n+        }\n+    }\n+\n+    @Override\n+    boolean paramsEqual(AlgorithmParameterSpec spec) {\n+        return getParameterSpec().equals(spec);\n+    }\n+\n+    private SignatureMethodParameterSpec getDefaultParameterSpec() {\n+        RSAPSSParameterSpec params = new RSAPSSParameterSpec();\n+        params.setTrailerField(trailerField);\n+        params.setSaltLength(saltLength);\n+        params.setDigestName(digestName);\n+        return params;\n+    }\n+\n+    static final class RSAPSS extends DOMRSAPSSSignatureMethod {\n+        RSAPSS(AlgorithmParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            super(params);\n+        }\n+        RSAPSS(Element dmElem) throws MarshalException {\n+            super(dmElem);\n+        }\n+        @Override\n+        public String getAlgorithm() {\n+            return RSA_PSS;\n+        }\n+        @Override\n+        String getJCAAlgorithm() {\n+            return \"RSASSA-PSS\";\n+        }\n+        @Override\n+        Type getAlgorithmType() {\n+            return Type.RSA;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMRSAPSSSignatureMethod.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-\/*\n- * $Id: DOMReference.java 1854026 2019-02-21 09:30:01Z coheigea $\n- *\/\n@@ -168,1 +165,1 @@\n-        if (uri != null && !uri.equals(\"\")) {\n+        if (uri != null && !uri.isEmpty()) {\n@@ -199,1 +196,1 @@\n-        if (nextSibling.getLocalName().equals(\"Transforms\")\n+        if (\"Transforms\".equals(nextSibling.getLocalName())\n@@ -226,1 +223,1 @@\n-        if (!nextSibling.getLocalName().equals(\"DigestMethod\")\n+        if (!\"DigestMethod\".equals(nextSibling.getLocalName())\n@@ -451,0 +448,1 @@\n+        XMLSignatureInput xi = null;\n@@ -462,1 +460,0 @@\n-                XMLSignatureInput xi;\n@@ -542,0 +539,4 @@\n+            } else {\n+                LOG.warn(\"The input bytes to the digest operation are null. \" +\n+                   \"This may be due to a problem with the Reference URI \" +\n+                   \"or its Transforms.\");\n@@ -548,9 +549,2 @@\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new XMLSignatureException(e);\n-        } catch (TransformException e) {\n-            throw new XMLSignatureException(e);\n-        } catch (MarshalException e) {\n-            throw new XMLSignatureException(e);\n-        } catch (IOException e) {\n-            throw new XMLSignatureException(e);\n-        } catch (com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException e) {\n+        } catch (NoSuchAlgorithmException | TransformException | MarshalException\n+                | IOException | com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException e) {\n@@ -558,1 +552,8 @@\n-        } finally {\n+        } finally { \/\/NOPMD\n+            if (xi != null && xi.getOctetStreamReal() != null) {\n+                try {\n+                    xi.getOctetStreamReal().close();\n+                } catch (IOException e) {\n+                    throw new XMLSignatureException(e);\n+                }\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMReference.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-\/*\n- * $Id: DOMRetrievalMethod.java 1862080 2019-06-25 16:50:17Z coheigea $\n- *\/\n@@ -115,1 +112,1 @@\n-        if (!uri.equals(\"\")) {\n+        if (!uri.isEmpty()) {\n@@ -282,1 +279,1 @@\n-            if (kiElem.getLocalName().equals(\"X509Data\")\n+            if (\"X509Data\".equals(kiElem.getLocalName())\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMRetrievalMethod.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/*\n- * $Id: DOMSignatureMethod.java 1854026 2019-02-21 09:30:01Z coheigea $\n- *\/\n@@ -56,0 +53,2 @@\n+    private static final String DOM_SIGNATURE_PROVIDER = \"org.jcp.xml.dsig.internal.dom.SignatureProvider\";\n+\n@@ -192,0 +191,2 @@\n+        } else if (alg.equals(DOMRSAPSSSignatureMethod.RSA_PSS)) {\n+            return new DOMRSAPSSSignatureMethod.RSAPSS(smElem);\n@@ -262,2 +263,1 @@\n-            Provider p = (Provider) context.getProperty\n-                    (\"org.jcp.xml.dsig.internal.dom.SignatureProvider\");\n+            Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n@@ -328,2 +328,1 @@\n-            Provider p = (Provider)context.getProperty\n-                    (\"org.jcp.xml.dsig.internal.dom.SignatureProvider\");\n+            Provider p = (Provider)context.getProperty(DOM_SIGNATURE_PROVIDER);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureMethod.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMSignatureProperties.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureProperties.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMSignatureProperty.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +169,1 @@\n-        return equalsContent(ospContent) &&\n+        return equalsContent(content, ospContent) &&\n@@ -188,26 +185,0 @@\n-    private boolean equalsContent(List<XMLStructure> otherContent) {\n-        int osize = otherContent.size();\n-        if (content.size() != osize) {\n-            return false;\n-        }\n-        for (int i = 0; i < osize; i++) {\n-            XMLStructure oxs = otherContent.get(i);\n-            XMLStructure xs = content.get(i);\n-            if (oxs instanceof javax.xml.crypto.dom.DOMStructure) {\n-                if (!(xs instanceof javax.xml.crypto.dom.DOMStructure)) {\n-                    return false;\n-                }\n-                Node onode = ((javax.xml.crypto.dom.DOMStructure)oxs).getNode();\n-                Node node = ((javax.xml.crypto.dom.DOMStructure)xs).getNode();\n-                if (!DOMUtils.nodesEqual(node, onode)) {\n-                    return false;\n-                }\n-            } else {\n-                if (!(xs.equals(oxs))) {\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        return true;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignatureProperty.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMSignedInfo.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSignedInfo.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMStructure.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +33,2 @@\n+import java.util.List;\n+\n@@ -52,0 +51,27 @@\n+\n+    protected boolean equalsContent(List<XMLStructure> content, List<XMLStructure> otherContent) {\n+        int size = content.size();\n+        if (size != otherContent.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < size; i++) {\n+            XMLStructure oxs = otherContent.get(i);\n+            XMLStructure xs = content.get(i);\n+            if (oxs instanceof javax.xml.crypto.dom.DOMStructure) {\n+                if (!(xs instanceof javax.xml.crypto.dom.DOMStructure)) {\n+                    return false;\n+                }\n+                Node otherNode = ((javax.xml.crypto.dom.DOMStructure)oxs).getNode();\n+                Node node = ((javax.xml.crypto.dom.DOMStructure)xs).getNode();\n+                if (!DOMUtils.nodesEqual(node, otherNode)) {\n+                    return false;\n+                }\n+            } else {\n+                if (!(xs.equals(oxs))) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMStructure.java","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id$\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +128,1 @@\n-         * @param the previous sibling node\n+         * @param prevSibling the previous sibling node\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMSubTreeData.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMTransform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +207,1 @@\n-     * @param sc the {@code XMLCryptoContext} containing\n+     * @param xc the {@code XMLCryptoContext} containing\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMTransform.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMURIDereferencer.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +35,1 @@\n+import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverContext;\n@@ -124,3 +122,2 @@\n-            ResourceResolver apacheResolver =\n-                ResourceResolver.getInstance(uriAttr, baseURI, false);\n-            XMLSignatureInput in = apacheResolver.resolve(uriAttr, baseURI, false);\n+            ResourceResolverContext resContext = new ResourceResolverContext(uriAttr, baseURI, false);\n+            XMLSignatureInput in = ResourceResolver.resolve(resContext);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMURIDereferencer.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMUtils.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +28,0 @@\n-import java.util.*;\n@@ -33,0 +29,13 @@\n+import java.util.List;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.XMLCryptoContext;\n+import javax.xml.crypto.XMLStructure;\n+import javax.xml.crypto.dsig.XMLSignature;\n+import javax.xml.crypto.dsig.spec.ExcC14NParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilterParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathType;\n+import javax.xml.crypto.dsig.spec.XSLTTransformParameterSpec;\n+\n@@ -37,6 +46,0 @@\n-import org.w3c.dom.NodeList;\n-\n-import javax.xml.XMLConstants;\n-import javax.xml.crypto.*;\n-import javax.xml.crypto.dsig.*;\n-import javax.xml.crypto.dsig.spec.*;\n@@ -95,1 +98,1 @@\n-        String qName = prefix == null || prefix.length() == 0\n+        String qName = (prefix == null || prefix.length() == 0)\n@@ -150,17 +153,0 @@\n-    \/**\n-     * Returns the first child element of the specified node and checks that\n-     * the local name is equal to {@code localName}.\n-     *\n-     * @param node the node\n-     * @return the first child element of the specified node\n-     * @throws NullPointerException if {@code node == null}\n-     * @throws MarshalException if no such element or the local name is not\n-     *    equal to {@code localName}\n-     *\/\n-    @Deprecated\n-    public static Element getFirstChildElement(Node node, String localName)\n-        throws MarshalException\n-    {\n-        return verifyElement(getFirstChildElement(node), localName);\n-    }\n-\n@@ -184,14 +170,0 @@\n-    private static Element verifyElement(Element elem, String localName)\n-        throws MarshalException\n-    {\n-        if (elem == null) {\n-            throw new MarshalException(\"Missing \" + localName + \" element\");\n-        }\n-        String name = elem.getLocalName();\n-        if (!name.equals(localName)) {\n-            throw new MarshalException(\"Invalid element name: \" +\n-                                       name + \", expected \" + localName);\n-        }\n-        return elem;\n-    }\n-\n@@ -248,17 +220,0 @@\n-    \/**\n-     * Returns the next sibling element of the specified node and checks that\n-     * the local name is equal to {@code localName}.\n-     *\n-     * @param node the node\n-     * @return the next sibling element of the specified node\n-     * @throws NullPointerException if {@code node == null}\n-     * @throws MarshalException if no such element or the local name is not\n-     * equal to {@code localName}\n-     *\/\n-    @Deprecated\n-    public static Element getNextSiblingElement(Node node, String localName)\n-        throws MarshalException\n-    {\n-        return verifyElement(getNextSiblingElement(node), localName);\n-    }\n-\n@@ -323,38 +278,0 @@\n-    \/**\n-     * Returns a Set of {@code Node}s, backed by the specified\n-     * {@code NodeList}.\n-     *\n-     * @param nl the NodeList\n-     * @return a Set of Nodes\n-     *\/\n-    public static Set<Node> nodeSet(NodeList nl) {\n-        return new NodeSet(nl);\n-    }\n-\n-    static class NodeSet extends AbstractSet<Node> {\n-        private NodeList nl;\n-        public NodeSet(NodeList nl) {\n-            this.nl = nl;\n-        }\n-\n-        public int size() { return nl.getLength(); }\n-        public Iterator<Node> iterator() {\n-            return new Iterator<Node>() {\n-                private int index;\n-\n-                public void remove() {\n-                    throw new UnsupportedOperationException();\n-                }\n-                public Node next() {\n-                    if (!hasNext()) {\n-                        throw new NoSuchElementException();\n-                    }\n-                    return nl.item(index++);\n-                }\n-                public boolean hasNext() {\n-                    return index < nl.getLength();\n-                }\n-            };\n-        }\n-    }\n-\n@@ -404,1 +321,1 @@\n-     * Compares 2 nodes for equality. Implementation is not complete.\n+     * Compares 2 nodes for equality.\n@@ -407,8 +324,1 @@\n-        if (thisNode == otherNode) {\n-            return true;\n-        }\n-        if (thisNode.getNodeType() != otherNode.getNodeType()) {\n-            return false;\n-        }\n-        \/\/ FIXME - test content, etc\n-        return true;\n+        return thisNode.isEqualNode(otherNode);\n@@ -513,2 +423,1 @@\n-        final short nodeType = node.getNodeType();\n-        if (nodeType == Node.ATTRIBUTE_NODE) {\n+        if (Node.ATTRIBUTE_NODE == node.getNodeType()) {\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMUtils.java","additions":18,"deletions":109,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMX509Data.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +30,10 @@\n-import java.security.cert.*;\n-import java.util.*;\n+import java.security.cert.CRLException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n@@ -66,1 +71,1 @@\n-     *    or {@link javax.xml.dsig.XMLStructure}\n+     *    or {@link javax.xml.crypto.XMLStructure}\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMX509Data.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMX509IssuerSerial.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMX509IssuerSerial.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMXMLObject.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +169,1 @@\n-        Element objElem = objectElem != null ? objectElem : null;\n+        Element objElem = objectElem;\n@@ -219,1 +216,1 @@\n-                equalsContent(oxo.getContent());\n+                equalsContent(content, oxo.getContent());\n@@ -239,25 +236,0 @@\n-    private boolean equalsContent(List<XMLStructure> otherContent) {\n-        if (content.size() != otherContent.size()) {\n-            return false;\n-        }\n-        for (int i = 0, osize = otherContent.size(); i < osize; i++) {\n-            XMLStructure oxs = otherContent.get(i);\n-            XMLStructure xs = content.get(i);\n-            if (oxs instanceof javax.xml.crypto.dom.DOMStructure) {\n-                if (!(xs instanceof javax.xml.crypto.dom.DOMStructure)) {\n-                    return false;\n-                }\n-                Node onode = ((javax.xml.crypto.dom.DOMStructure)oxs).getNode();\n-                Node node = ((javax.xml.crypto.dom.DOMStructure)xs).getNode();\n-                if (!DOMUtils.nodesEqual(node, onode)) {\n-                    return false;\n-                }\n-            } else {\n-                if (!(xs.equals(oxs))) {\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        return true;\n-    }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXMLObject.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-\/*\n- * $Id: DOMXMLSignature.java 1854026 2019-02-21 09:30:01Z coheigea $\n- *\/\n@@ -154,1 +151,1 @@\n-        if (nextSibling != null && nextSibling.getLocalName().equals(\"KeyInfo\")\n+        if (nextSibling != null && \"KeyInfo\".equals(nextSibling.getLocalName())\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXMLSignature.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMXMLSignatureFactory.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,0 +273,2 @@\n+        } else if (algorithm.equals(DOMRSAPSSSignatureMethod.RSA_PSS)) {\n+            return new DOMRSAPSSSignatureMethod.RSAPSS(params);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXMLSignatureFactory.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,4 +31,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMXPathFilter2Transform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +35,0 @@\n-import javax.xml.crypto.*;\n-import javax.xml.crypto.dsig.*;\n-import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.crypto.dsig.spec.XPathType;\n-import javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec;\n@@ -49,0 +41,9 @@\n+\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.XMLCryptoContext;\n+import javax.xml.crypto.XMLStructure;\n+import javax.xml.crypto.dsig.Transform;\n+import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathType;\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXPathFilter2Transform.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMXPathTransform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +28,0 @@\n-import javax.xml.crypto.*;\n-import javax.xml.crypto.dsig.*;\n-import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n-import javax.xml.crypto.dsig.spec.XPathFilterParameterSpec;\n@@ -39,0 +32,8 @@\n+\n+import javax.xml.crypto.MarshalException;\n+import javax.xml.crypto.XMLCryptoContext;\n+import javax.xml.crypto.XMLStructure;\n+import javax.xml.crypto.dsig.XMLSignature;\n+import javax.xml.crypto.dsig.spec.TransformParameterSpec;\n+import javax.xml.crypto.dsig.spec.XPathFilterParameterSpec;\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXPathTransform.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: DOMXSLTTransform.java 1854026 2019-02-21 09:30:01Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMXSLTTransform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package org.jcp.xml.dsig.internal.dom;\n+\n+import javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec;\n+\n+public class RSAPSSParameterSpec implements SignatureMethodParameterSpec {\n+\n+    private int trailerField;\n+    private int saltLength;\n+    private String digestName;\n+\n+    public int getTrailerField() {\n+        return trailerField;\n+    }\n+    public void setTrailerField(int trailerField) {\n+        this.trailerField = trailerField;\n+    }\n+    public int getSaltLength() {\n+        return saltLength;\n+    }\n+    public void setSaltLength(int saltLength) {\n+        this.saltLength = saltLength;\n+    }\n+    public String getDigestName() {\n+        return digestName;\n+    }\n+    public void setDigestName(String digestName) {\n+        this.digestName = digestName;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((digestName == null) ? 0 : digestName.hashCode());\n+        result = prime * result + saltLength;\n+        result = prime * result + trailerField;\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        RSAPSSParameterSpec other = (RSAPSSParameterSpec)obj;\n+        if (digestName == null) {\n+            if (other.digestName != null)\n+                return false;\n+        } else if (!digestName.equals(other.digestName))\n+            return false;\n+        if (saltLength != other.saltLength)\n+            return false;\n+        return trailerField == other.trailerField;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/RSAPSSParameterSpec.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -24,4 +24,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: Utils.java 1788465 2017-03-24 15:10:51Z coheigea $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +94,1 @@\n-        if (id != null && id.startsWith(\"xpointer(id(\")) {\n+        if (id.startsWith(\"xpointer(id(\")) {\n@@ -121,1 +118,1 @@\n-        return value != null && value.booleanValue();\n+        return value != null && value;\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,4 +31,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- *\/\n-\/*\n- * $Id: XMLDSigRI.java 1833618 2018-06-15 17:36:20Z mullan $\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +74,1 @@\n-                (aliases == null? null : Arrays.asList(aliases)), null);\n+                aliases == null ? null : Arrays.asList(aliases), null);\n@@ -81,1 +78,1 @@\n-            String[] aliases, HashMap<String, String> attrs) {\n+            String[] aliases, Map<String, String> attrs) {\n@@ -83,1 +80,1 @@\n-                  (aliases == null? null : Arrays.asList(aliases)), attrs);\n+                  aliases == null ? null : Arrays.asList(aliases), attrs);\n@@ -97,2 +94,2 @@\n-                if (type.equals(\"XMLSignatureFactory\")) {\n-                    if (algo.equals(\"DOM\")) {\n+                if (\"XMLSignatureFactory\".equals(type)) {\n+                    if (\"DOM\".equals(algo)) {\n@@ -101,2 +98,2 @@\n-                } else if (type.equals(\"KeyInfoFactory\")) {\n-                    if (algo.equals(\"DOM\")) {\n+                } else if (\"KeyInfoFactory\".equals(type)) {\n+                    if (\"DOM\".equals(algo)) {\n@@ -105,1 +102,1 @@\n-                } else if (type.equals(\"TransformService\")) {\n+                } else if (\"TransformService\".equals(type)) {\n@@ -109,2 +106,2 @@\n-                    } else if (algo.equals(\"http:\/\/www.w3.org\/2006\/12\/xml-c14n11\") ||\n-                        algo.equals(\"http:\/\/www.w3.org\/2006\/12\/xml-c14n11#WithComments\")) {\n+                    } else if (\"http:\/\/www.w3.org\/2006\/12\/xml-c14n11\".equals(algo) ||\n+                        \"http:\/\/www.w3.org\/2006\/12\/xml-c14n11#WithComments\".equals(algo)) {\n@@ -138,1 +135,1 @@\n-        \/\/ Apache Santuario XML Security for Java, version 2.1.4\n+        \/\/ Apache Santuario XML Security for Java, version 2.2.1\n@@ -144,1 +141,1 @@\n-                HashMap<String, String> MECH_TYPE = new HashMap<>();\n+                Map<String, String> MECH_TYPE = new HashMap<>();\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/XMLDSigRI.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Santuario v2.1.4\n+## Apache Santuario v2.2.1\n@@ -7,1 +7,1 @@\n-  Copyright 1999-2019 The Apache Software Foundation\n+  Copyright 1999-2021 The Apache Software Foundation\n","filename":"src\/java.xml.crypto\/share\/legal\/santuario.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+        try {\n@@ -89,1 +90,0 @@\n-        try {\n@@ -113,0 +113,1 @@\n+        try {\n@@ -116,1 +117,0 @@\n-        try {\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/TruncateHMAC.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *          java.xml.crypto\/com.sun.org.apache.xml.internal.security.signature\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/ClassLoaderTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;\n@@ -26,0 +27,3 @@\n+import org.w3c.dom.Element;\n+\n+import java.io.OutputStream;\n@@ -32,1 +36,1 @@\n-    public MyTransform() {\n+    static {\n@@ -41,0 +45,7 @@\n+    @Override\n+    protected XMLSignatureInput enginePerformTransform(\n+            XMLSignatureInput input, OutputStream os, Element transformElement,\n+            String baseURI, boolean secureValidation) {\n+        return null;\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/MyTransform.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}