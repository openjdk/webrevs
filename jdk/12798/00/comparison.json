{"files":[{"patch":"@@ -296,1 +296,1 @@\n-void BitMap::at_put(idx_t offset, bool value) {\n+void BitMap::at_put(idx_t bit, bool value) {\n@@ -298,1 +298,1 @@\n-    set_bit(offset);\n+    set_bit(bit);\n@@ -300,1 +300,1 @@\n-    clear_bit(offset);\n+    clear_bit(bit);\n@@ -323,1 +323,1 @@\n-void BitMap::at_put_range(idx_t beg_offset, idx_t end_offset, bool value) {\n+void BitMap::at_put_range(idx_t beg, idx_t end, bool value) {\n@@ -325,1 +325,1 @@\n-    set_range(beg_offset, end_offset);\n+    set_range(beg, end);\n@@ -327,1 +327,1 @@\n-    clear_range(beg_offset, end_offset);\n+    clear_range(beg, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-  bm_word_t  map(idx_t word) const { return _map[word]; }\n@@ -138,0 +137,5 @@\n+  \/\/ Get a word and flip its bits according to flip.\n+  bm_word_t flipped_word(idx_t word, bm_word_t flip) const {\n+    return _map[word] ^ flip;\n+  }\n+\n@@ -215,2 +219,2 @@\n-  void at_put(idx_t index, bool value);\n-  bool par_at_put(idx_t index, bool value);\n+  void at_put(idx_t bit, bool value);\n+  bool par_at_put(idx_t bit, bool value);\n@@ -271,2 +275,2 @@\n-  idx_t get_next_one_offset(idx_t offset) const {\n-    return get_next_one_offset(offset, size());\n+  idx_t get_next_one_offset(idx_t beg) const {\n+    return get_next_one_offset(beg, size());\n@@ -274,2 +278,2 @@\n-  idx_t get_next_zero_offset(idx_t offset) const {\n-    return get_next_zero_offset(offset, size());\n+  idx_t get_next_zero_offset(idx_t beg) const {\n+    return get_next_zero_offset(beg, size());\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-inline bool BitMap::par_at(idx_t index, atomic_memory_order memory_order) const {\n-  verify_index(index);\n+inline bool BitMap::par_at(idx_t bit, atomic_memory_order memory_order) const {\n+  verify_index(bit);\n@@ -61,2 +61,2 @@\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  return (load_word_ordered(addr, memory_order) & bit_mask(index)) != 0;\n+  const volatile bm_word_t* const addr = word_addr(bit);\n+  return (load_word_ordered(addr, memory_order) & bit_mask(bit)) != 0;\n@@ -169,1 +169,1 @@\n-inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {\n+inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t beg, idx_t end) const {\n@@ -171,2 +171,2 @@\n-  verify_range(l_index, r_index);\n-  assert(!aligned_right || is_aligned(r_index, BitsPerWord), \"r_index not aligned\");\n+  verify_range(beg, end);\n+  assert(!aligned_right || is_aligned(end, BitsPerWord), \"end not aligned\");\n@@ -183,1 +183,1 @@\n-  \/\/ However, callers often have a comparison with r_index, and\n+  \/\/ However, callers often have a comparison with end, and\n@@ -186,1 +186,1 @@\n-  \/\/ r_index or a value dominated by a comparison with r_index.\n+  \/\/ end or a value dominated by a comparison with end.\n@@ -191,4 +191,4 @@\n-  if (l_index < r_index) {\n-    \/\/ Get the word containing l_index, and shift out low bits.\n-    idx_t index = to_words_align_down(l_index);\n-    bm_word_t cword = (map(index) ^ flip) >> bit_in_word(l_index);\n+  if (beg < end) {\n+    \/\/ Get the word containing beg, and shift out low bits.\n+    idx_t word_index = to_words_align_down(beg);\n+    bm_word_t cword = flipped_word(word_index, flip) >> bit_in_word(beg);\n@@ -203,1 +203,1 @@\n-      return l_index;\n+      return beg;\n@@ -206,3 +206,3 @@\n-      idx_t result = l_index + count_trailing_zeros(cword);\n-      if (aligned_right || (result < r_index)) return result;\n-      \/\/ Result is beyond range bound; return r_index.\n+      idx_t result = beg + count_trailing_zeros(cword);\n+      if (aligned_right || (result < end)) return result;\n+      \/\/ Result is beyond range bound; return end.\n@@ -211,6 +211,6 @@\n-      \/\/ aligned up r_index for a non-zero flipped word.\n-      idx_t limit = aligned_right\n-        ? to_words_align_down(r_index) \/\/ Minuscule savings when aligned.\n-        : to_words_align_up(r_index);\n-      while (++index < limit) {\n-        cword = map(index) ^ flip;\n+      \/\/ aligned up end for a non-zero flipped word.\n+      idx_t word_limit = aligned_right\n+        ? to_words_align_down(end) \/\/ Minuscule savings when aligned.\n+        : to_words_align_up(end);\n+      while (++word_index < word_limit) {\n+        cword = flipped_word(word_index, flip);\n@@ -218,4 +218,4 @@\n-          idx_t result = bit_index(index) + count_trailing_zeros(cword);\n-          if (aligned_right || (result < r_index)) return result;\n-          \/\/ Result is beyond range bound; return r_index.\n-          assert((index + 1) == limit, \"invariant\");\n+          idx_t result = bit_index(word_index) + count_trailing_zeros(cword);\n+          if (aligned_right || (result < end)) return result;\n+          \/\/ Result is beyond range bound; return end.\n+          assert((word_index + 1) == word_limit, \"invariant\");\n@@ -225,1 +225,1 @@\n-      \/\/ No bits in range; return r_index.\n+      \/\/ No bits in range; return end.\n@@ -228,1 +228,1 @@\n-  return r_index;\n+  return end;\n@@ -232,2 +232,2 @@\n-BitMap::get_next_one_offset(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_ones_flip, false>(l_offset, r_offset);\n+BitMap::get_next_one_offset(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_ones_flip, false>(beg, end);\n@@ -237,2 +237,2 @@\n-BitMap::get_next_zero_offset(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_zeros_flip, false>(l_offset, r_offset);\n+BitMap::get_next_zero_offset(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_zeros_flip, false>(beg, end);\n@@ -242,2 +242,2 @@\n-BitMap::get_next_one_offset_aligned_right(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_ones_flip, true>(l_offset, r_offset);\n+BitMap::get_next_one_offset_aligned_right(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_ones_flip, true>(beg, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"}]}