{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"jfr\/recorder\/service\/jfrRecorderService.hpp\"\n@@ -46,0 +47,1 @@\n+\n@@ -156,1 +158,1 @@\n-void Jfr::on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown, bool halt) {\n+void Jfr::on_vm_shutdown(bool exception_handler \/* false *\/, bool halt \/* false *\/, bool oom \/* false *\/) {\n@@ -158,1 +160,1 @@\n-    JfrEmergencyDump::on_vm_shutdown(emit_old_object_samples, emit_event_shutdown);\n+    JfrEmergencyDump::on_vm_shutdown(exception_handler, oom);\n@@ -176,0 +178,6 @@\n+void Jfr::on_report_java_out_of_memory() {\n+  if (CrashOnOutOfMemoryError && JfrRecorder::is_recording()) {\n+    JfrRecorderService::emit_leakprofiler_events_on_oom();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  static void on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown, bool halt = false);\n+  static void on_vm_shutdown(bool exception_handler = false, bool halt = false, bool oom = false);\n@@ -82,0 +82,1 @@\n+  static void on_report_java_out_of_memory();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,2 +367,1 @@\n-  JfrRecorderService service;\n-  service.emit_leakprofiler_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n+  JfrRecorderService::emit_leakprofiler_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -463,9 +465,0 @@\n-#ifdef ASSERT\n-  Mutex* owned_lock = thread->owned_locks();\n-  while (owned_lock != nullptr) {\n-    Mutex* next = owned_lock->next();\n-    owned_lock->unlock();\n-    owned_lock = next;\n-  }\n-#endif \/\/ ASSERT\n-\n@@ -553,5 +546,2 @@\n-static void post_events(bool emit_old_object_samples, bool emit_event_shutdown, Thread* thread) {\n-  if (emit_old_object_samples) {\n-    LeakProfiler::emit_events(max_jlong, false, false);\n-  }\n-  if (emit_event_shutdown) {\n+static void post_events(bool exception_handler, bool oom, Thread * thread) {\n+  if (exception_handler) {\n@@ -559,1 +549,1 @@\n-    e.set_reason(\"VM Error\");\n+    e.set_reason(oom ? \"CrashOnOutOfMemoryError\" : \"VM Error\");\n@@ -563,1 +553,1 @@\n-  event.set_reason(emit_old_object_samples ? \"Out of Memory\" : \"Crash\");\n+  event.set_reason(exception_handler && oom ? \"CrashOnOutOfMemoryError\" : exception_handler ? \"Crash\" : \"Out of Memory\");\n@@ -597,1 +587,1 @@\n-void JfrEmergencyDump::on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown) {\n+void JfrEmergencyDump::on_vm_shutdown(bool exception_handler, bool oom) {\n@@ -601,0 +591,1 @@\n+\n@@ -603,0 +594,5 @@\n+\n+  \/\/ Ensure a JavaThread is _thread_in_vm when we make this call\n+  JavaThreadInVMAndNative jtivm(thread);\n+  post_events(exception_handler, oom, thread);\n+\n@@ -604,1 +600,6 @@\n-    log_info(jfr, system)(\"The Watcher thread crashed so no jfr emergency dump will be generated.\");\n+    \/\/ We cannot attempt an emergency dump using the Watcher thread\n+    \/\/ because we rely on the WatcherThread task \"is_error_reported()\",\n+    \/\/ to exit the VM after a hardcoded timeout, should the relatively\n+    \/\/ risky operation of an emergency dump fail (deadlock, livelock).\n+    log_warning(jfr, system)\n+      (\"The Watcher thread crashed so no jfr emergency dump will be generated.\");\n@@ -607,2 +608,12 @@\n-  \/\/ Ensure a JavaThread is _thread_in_vm when we make this call\n-  JavaThreadInVMAndNative jtivm(thread);\n+\n+  if (thread->is_VM_thread()) {\n+    const VM_Operation* const operation = VMThread::vm_operation();\n+    if (operation != nullptr && operation->type() == VM_Operation::VMOp_JFROldObject) {\n+      \/\/ We will not be able to issue a rotation because the rotation lock\n+      \/\/ is held by the JFR Recorder Thread that issued the VM_Operation.\n+      log_warning(jfr, system)\n+        (\"The VM Thread crashed as part of emitting leak profiler events so no jfr emergency dump will be generated.\");\n+      return;\n+    }\n+  }\n+\n@@ -610,1 +621,0 @@\n-  post_events(emit_old_object_samples, emit_event_shutdown, thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static void on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown);\n+  static void on_vm_shutdown(bool exception_handler, bool oom);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-                             (MSGBIT(MSG_FLUSHPOINT))        \\\n+                             (MSGBIT(MSG_FLUSHPOINT))      | \\\n+                             (MSGBIT(MSG_EMIT_LEAKP_REFCHAINS)) \\\n@@ -168,1 +169,1 @@\n-  JfrMsg_lock->notify();\n+  JfrMsg_lock->notify_all();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+  MSG_EMIT_LEAKP_REFCHAINS,\n@@ -54,6 +55,7 @@\n- *  MSG_CLONE_IN_MEMORY (0) ; MSGBIT(MSG_CLONE_IN_MEMORY) == (1 << 0) == 0x1\n- *  MSG_START(1)            ; MSGBIT(MSG_START) == (1 << 0x1) == 0x2\n- *  MSG_STOP (2)            ; MSGBIT(MSG_STOP) == (1 << 0x2) == 0x4\n- *  MSG_ROTATE (3)          ; MSGBIT(MSG_ROTATE) == (1 << 0x3) == 0x8\n- *  MSG_VM_ERROR (8)        ; MSGBIT(MSG_VM_ERROR) == (1 << 0x8) == 0x100\n- *  MSG_FLUSHPOINT (9)     ; MSGBIT(MSG_FLUSHPOINT) == (1 << 0x9) == 0x200\n+ *  MSG_CLONE_IN_MEMORY (0)      ; MSGBIT(MSG_CLONE_IN_MEMORY) == (1 << 0) == 0x1\n+ *  MSG_START(1)                 ; MSGBIT(MSG_START) == (1 << 0x1) == 0x2\n+ *  MSG_STOP (2)                 ; MSGBIT(MSG_STOP) == (1 << 0x2) == 0x4\n+ *  MSG_ROTATE (3)               ; MSGBIT(MSG_ROTATE) == (1 << 0x3) == 0x8\n+ *  MSG_VM_ERROR (8)             ; MSGBIT(MSG_VM_ERROR) == (1 << 0x8) == 0x100\n+ *  MSG_FLUSHPOINT (9)           ; MSGBIT(MSG_FLUSHPOINT) == (1 << 0x9) == 0x200\n+ *  MSG_EMIT_LEAKP_REFCHAINS (10); MSGBIT(MSG_EMIT_LEAKP_REFCHAINS) == (1 << 0xa) == 0x400\n@@ -63,4 +65,4 @@\n- *  MSG_FULLBUFFER (4)      ; MSGBIT(MSG_FULLBUFFER) == (1 << 0x4) == 0x10\n- *  MSG_CHECKPOINT (5)      ; MSGBIT(CHECKPOINT) == (1 << 0x5) == 0x20\n- *  MSG_WAKEUP (6)          ; MSGBIT(WAKEUP) == (1 << 0x6) == 0x40\n- *  MSG_SHUTDOWN (7)        ; MSGBIT(MSG_SHUTDOWN) == (1 << 0x7) == 0x80\n+ *  MSG_FULLBUFFER (4)           ; MSGBIT(MSG_FULLBUFFER) == (1 << 0x4) == 0x10\n+ *  MSG_CHECKPOINT (5)           ; MSGBIT(CHECKPOINT) == (1 << 0x5) == 0x20\n+ *  MSG_WAKEUP (6)               ; MSGBIT(WAKEUP) == (1 << 0x6) == 0x40\n+ *  MSG_SHUTDOWN (7)             ; MSGBIT(MSG_SHUTDOWN) == (1 << 0x7) == 0x80\n@@ -71,0 +73,1 @@\n+  friend class JfrRecorderService;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -394,0 +395,1 @@\n+  _post_box(JfrPostBox::instance()),\n@@ -673,5 +675,48 @@\n-void JfrRecorderService::emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(JavaThread::current()));\n-  \/\/ Take the rotation lock to exclude flush() during event emits. This is because event emit\n-  \/\/ also creates a number checkpoint events. Those checkpoint events require a future typeset checkpoint\n-  \/\/ event for completeness, i.e. to be generated before being flushed to a segment.\n+\/\/ LeakProfiler event serialization support.\n+\n+struct JfrLeakProfilerEmitRequest {\n+  int64_t cutoff_ticks;\n+  bool emit_all;\n+  bool skip_bfs;\n+  bool oom;\n+};\n+\n+typedef GrowableArrayCHeap<JfrLeakProfilerEmitRequest, mtTracing> JfrLeakProfilerEmitRequestQueue;\n+static JfrLeakProfilerEmitRequestQueue* _queue = nullptr;\n+constexpr const static int64_t _no_path_to_gc_roots = 0;\n+static bool _oom_emit_request_posted = false;\n+static bool _oom_emit_request_delivered = false;\n+\n+static inline bool exclude_paths_to_gc_roots(int64_t cutoff_ticks) {\n+  return cutoff_ticks <= _no_path_to_gc_roots;\n+}\n+\n+static void enqueue(const JfrLeakProfilerEmitRequest& request) {\n+  assert(JfrRotationLock::is_owner(), \"invariant\");\n+  if (_queue == nullptr) {\n+    _queue = new JfrLeakProfilerEmitRequestQueue(4);\n+  }\n+  assert(_queue != nullptr, \"invariant\");\n+  assert(!_oom_emit_request_posted, \"invariant\");\n+  if (request.oom) {\n+    _oom_emit_request_posted = true;\n+  }\n+  _queue->append(request);\n+}\n+\n+static JfrLeakProfilerEmitRequest dequeue() {\n+  assert(JfrRotationLock::is_owner(), \"invariant\");\n+  assert(_queue != nullptr, \"invariant\");\n+  assert(_queue->is_nonempty(), \"invariant\");\n+  const JfrLeakProfilerEmitRequest& request = _queue->first();\n+  _queue->remove_at(0);\n+  return request;\n+}\n+\n+\/\/ This version of emit excludes path-to-gc-roots, i.e. it skips reference chains.\n+static void emit_leakprofiler_events(bool emit_all, bool skip_bfs, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  \/\/ Take the rotation lock to exclude flush() during event emits. This is because the event emit operation\n+  \/\/ also creates a number of checkpoint events. Those checkpoint events require a future typeset checkpoint\n+  \/\/ event for completeness, i.e., to be generated before being flushed to a segment.\n@@ -679,1 +724,1 @@\n-  \/\/ and serializes all event emit checkpoint events to the same segment.\n+  \/\/ and serializes all checkpoint events to the same segment.\n@@ -681,0 +726,87 @@\n+  \/\/ Take the rotation lock before the thread transition, to avoid blocking safepoints.\n+  if (_oom_emit_request_posted) {\n+    \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+    \/\/ is pending or has already been completed. We are about to crash at any time now.\n+    assert(CrashOnOutOfMemoryError, \"invariant\");\n+    return;\n+  }\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+  ThreadInVMfromNative transition(jt);\n+  \/\/ Since we are not requesting path-to-gc-roots, i.e., reference chains, we need not issue a VM_Operation.\n+  \/\/ Therefore, we can let the requesting thread process the request directly, since it already holds the requisite lock.\n+  LeakProfiler::emit_events(_no_path_to_gc_roots, emit_all, skip_bfs);\n+}\n+\n+void JfrRecorderService::transition_and_post_leakprofiler_emit_msg(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  assert(!JfrRotationLock::is_owner(), \"invariant\");\n+  \/\/ Transition to _thread_in_VM and post a synchronous message to the JFR Recorder Thread\n+  \/\/ for it to process our enqueued request, which includes paths-to-gc-roots, i.e., reference chains.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+  ThreadInVMfromNative transition(jt);\n+  _post_box.post(MSG_EMIT_LEAKP_REFCHAINS);\n+}\n+\n+\/\/ This version of emit includes path-to-gc-roots, i.e., it includes in the request traversing of reference chains.\n+\/\/ Traversing reference chains is performed as part of a VM_Operation, and we initiate it from the JFR Recorder Thread.\n+\/\/ Because multiple threads can concurrently report_on_java_out_of_memory(), having them all post a synchronous JFR msg,\n+\/\/ they rendezvous at a safepoint in a convenient state, ThreadBlockInVM. This mechanism prevents any thread from racing past\n+\/\/ this point and begin executing VMError::report_and_die(), until at least one oom request has been delivered.\n+void JfrRecorderService::emit_leakprofiler_events_paths_to_gc_roots(int64_t cutoff_ticks,\n+                                                                    bool emit_all,\n+                                                                    bool skip_bfs,\n+                                                                    bool oom,\n+                                                                    JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  assert(!exclude_paths_to_gc_roots(cutoff_ticks), \"invariant\");\n+\n+  {\n+    JfrRotationLock lock;\n+    \/\/ Take the rotation lock to read and post a request for the JFR Recorder Thread.\n+    if (_oom_emit_request_posted) {\n+      if (!oom) {\n+        \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+        \/\/ is pending or has already been completed. We are about to crash at any time now.\n+        assert(CrashOnOutOfMemoryError, \"invariant\");\n+        return;\n+      }\n+    } else {\n+      assert(!_oom_emit_request_posted, \"invariant\");\n+      JfrLeakProfilerEmitRequest request = { cutoff_ticks, emit_all, skip_bfs, oom };\n+      enqueue(request);\n+    }\n+  }\n+  JfrRecorderService service;\n+  service.transition_and_post_leakprofiler_emit_msg(jt);\n+}\n+\n+\/\/ Leakprofiler serialization request, the jdk.jfr.internal.JVM.emitOldObjectSamples() Java entry point.\n+void JfrRecorderService::emit_leakprofiler_events(int64_t cutoff_ticks,\n+                                                  bool emit_all,\n+                                                  bool skip_bfs) {\n+  JavaThread* const jt = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  if (exclude_paths_to_gc_roots(cutoff_ticks)) {\n+    ::emit_leakprofiler_events(emit_all, skip_bfs, jt);\n+    return;\n+  }\n+  emit_leakprofiler_events_paths_to_gc_roots(cutoff_ticks, emit_all, skip_bfs, \/* oom *\/ false, jt);\n+}\n+\n+\/\/ Leakprofiler serialization request, the report_on_java_out_of_memory VM entry point.\n+void JfrRecorderService::emit_leakprofiler_events_on_oom() {\n+  assert(CrashOnOutOfMemoryError, \"invariant\");\n+  if (EventOldObjectSample::is_enabled()) {\n+    JavaThread* const jt = JavaThread::current();\n+    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt);)\n+    ThreadToNativeFromVM transition(jt);\n+    emit_leakprofiler_events_paths_to_gc_roots(max_jlong, false, false, \/* oom *\/ true, jt);\n+  }\n+}\n+\n+\/\/ The worker routine for the JFR Recorder Thread when processing MSG_EMIT_LEAKP_REFCHAINS messages.\n+void JfrRecorderService::emit_leakprofiler_events() {\n+  JavaThread* const jt = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n@@ -682,4 +814,30 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n-  ThreadInVMfromNative transition(current_thread);\n-  LeakProfiler::emit_events(cutoff_ticks, emit_all, skip_bfs);\n+  JfrRotationLock lock;\n+  if (_oom_emit_request_delivered) {\n+    \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+    \/\/ has already been completed. We are about to crash at any time now.\n+    assert(_oom_emit_request_posted, \"invariant\");\n+    assert(CrashOnOutOfMemoryError, \"invariant\");\n+    return;\n+  }\n+\n+  assert(_queue->is_nonempty(), \"invariant\");\n+\n+  {\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+    ThreadInVMfromNative transition(jt);\n+    while (_queue->is_nonempty()) {\n+      const JfrLeakProfilerEmitRequest& request = dequeue();\n+      LeakProfiler::emit_events(request.cutoff_ticks, request.emit_all, request.skip_bfs);\n+      if (_oom_emit_request_posted && request.oom) {\n+        assert(CrashOnOutOfMemoryError, \"invariant\");\n+        _oom_emit_request_delivered = true;\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/\/ If processing involved an out-of-memory request, issue an immediate flush operation.\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  if (_chunkwriter.is_valid() && _oom_emit_request_delivered) {\n+    invoke_flush();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":169,"deletions":11,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+class JavaThread;\n@@ -32,0 +33,1 @@\n+class JfrPostBox;\n@@ -38,0 +40,1 @@\n+  friend class Jfr;\n@@ -43,0 +46,1 @@\n+  JfrPostBox& _post_box;\n@@ -67,0 +71,8 @@\n+  void transition_and_post_leakprofiler_emit_msg(JavaThread* jt);\n+\n+  static void emit_leakprofiler_events_on_oom();\n+  static void emit_leakprofiler_events_paths_to_gc_roots(int64_t cutoff_ticks,\n+                                                         bool emit_all,\n+                                                         bool skip_bfs,\n+                                                         bool oom,\n+                                                         JavaThread* jt);\n@@ -75,1 +87,2 @@\n-  void emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs);\n+  void emit_leakprofiler_events();\n+\n@@ -77,0 +90,3 @@\n+  static void emit_leakprofiler_events(int64_t cutoff_ticks,\n+                                       bool emit_all,\n+                                       bool skip_bfs);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  #define LEAKPROFILER_REFCHAINS (msgs & MSGBIT(MSG_EMIT_LEAKP_REFCHAINS))\n@@ -73,0 +74,3 @@\n+        if (LEAKPROFILER_REFCHAINS) {\n+          service.emit_leakprofiler_events();\n+        }\n@@ -101,1 +105,1 @@\n-  #undef SCAVENGE\n+  #undef LEAKPROFILER_REFCHAINS\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -468,4 +468,1 @@\n-  \/\/ 2nd argument (emit_event_shutdown) should be set to false\n-  \/\/ because EventShutdown would be emitted at Threads::destroy_vm().\n-  \/\/ (one of the callers of before_exit())\n-  JFR_ONLY(Jfr::on_vm_shutdown(true, false, halt);)\n+  JFR_ONLY(Jfr::on_vm_shutdown(false, halt);)\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -265,0 +268,2 @@\n+  JFR_ONLY(Jfr::on_report_java_out_of_memory();)\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1901,1 +1901,1 @@\n-  JFR_ONLY(Jfr::on_vm_shutdown(static_cast<VMErrorType>(_id) == OOM_JAVA_HEAP_FATAL, true);)\n+  JFR_ONLY(Jfr::on_vm_shutdown(true, false, static_cast<VMErrorType>(_id) == OOM_JAVA_HEAP_FATAL);)\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -752,1 +752,0 @@\n-jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java             8371014 aix-ppc64,linux-ppc64le\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,2 +101,2 @@\n-                    Asserts.assertEquals(\"VM Error\", shutdownReason.get());\n-                    Asserts.assertEquals(\"Out of Memory\", dumpReason.get());\n+                    Asserts.assertEquals(\"CrashOnOutOfMemoryError\", shutdownReason.get());\n+                    Asserts.assertEquals(\"CrashOnOutOfMemoryError\", dumpReason.get());\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}