{"files":[{"patch":"@@ -1824,0 +1824,93 @@\n+\n+    \/**\n+     * Appends {@code count} copies of the character {@code c} to this sequence.\n+     * <p>\n+     * The length of this sequence increases by {@code count}.\n+     *\n+     * @param c      character to append\n+     * @param count  number of times to copy\n+     *\n+     * @return  a reference to this object.\n+     *\n+     * @since 21\n+     * @throws IllegalArgumentException  if {@code count} is less than zero\n+     * @throws IndexOutOfBoundsException  if the result overflows the buffer\n+     *\/\n+    public AbstractStringBuilder repeat(char c, int count) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"count is less than zero: \" + count);\n+        } else if (count == 0) {\n+            return this;\n+        }\n+        ensureCapacityInternal(this.count + count);\n+        int index = this.count;\n+        int limit = index + count;\n+        boolean isLatin1 = isLatin1();\n+        if (isLatin1 && StringLatin1.canEncode(c)) {\n+            while (index < limit) {\n+                value[index++] = (byte)c;\n+            }\n+        } else {\n+            if (isLatin1) {\n+                inflate();\n+            }\n+            while (index < limit) {\n+                StringUTF16.putCharSB(value, index++, c);\n+            }\n+        }\n+        this.count = limit;\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends {@code count} copies of the specified {@code CharSequence} {@code cs}\n+     * to this sequence.\n+     * <p>\n+     * The length of this sequence increases by {@code count} times the\n+     * {@code CharSequence} length.\n+     *\n+     * @param cs     a {@code CharSequence}\n+     * @param count  number of times to copy\n+     *\n+     * @return  a reference to this object.\n+     *\n+     * @since 21\n+     * @throws IllegalArgumentException  if {@code count} is less than zero\n+     * @throws IndexOutOfBoundsException  if the result overflows the buffer\n+     *\/\n+    public AbstractStringBuilder repeat(CharSequence cs, int count) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"count is less than zero: \" + count);\n+        } else if (count == 0) {\n+            return this;\n+        } else if (count == 1) {\n+            return append(cs);\n+        }\n+        if (cs == null) {\n+            cs = \"null\";\n+        }\n+        int length = cs.length();\n+        if (length == 0) {\n+            return this;\n+        } else if (length == 1) {\n+            return repeat(cs.charAt(0), count);\n+        }\n+        int offset = this.count;\n+        int valueLength = length << coder;\n+        if ((Integer.MAX_VALUE - offset) \/ count < valueLength) {\n+            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n+        }\n+        int total = count * length;\n+        int limit = offset + total;\n+        ensureCapacityInternal(limit);\n+        if (cs instanceof String str) {\n+            putStringAt(offset, str);\n+        } else  if (cs instanceof AbstractStringBuilder asb) {\n+            append(asb);\n+        } else {\n+            appendChars(cs, 0, length);\n+        }\n+        String.repeatCopyRest(value, offset << coder, total << coder, length << coder);\n+        this.count = limit;\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -4456,1 +4456,22 @@\n-        int copied = len;\n+        repeatCopyRest(multiple, 0, limit, len);\n+        return new String(multiple, coder);\n+    }\n+\n+    \/**\n+     * Used to perform copying after the initial insertion. Copying is optimized\n+     * by using power of two duplication. First pass duplicates original copy,\n+     * second pass then duplicates the original and the copy yielding four copies,\n+     * third pass duplicates four copies yielding eight copies, and so on.\n+     * Finally, the remainder is filled in with prior copies.\n+     *\n+     * @implNote The technique used here is significantly faster than hand-rolled\n+     * loops or special casing small numbers due to the intensive optimization\n+     * done by intrinsic {@code System.arraycopy}.\n+     *\n+     * @param buffer    destination buffer\n+     * @param offset    offset in the destination buffer\n+     * @param limit     total replicated including what is already in the buffer\n+     * @param copied    number of bytes that have already in the buffer\n+     *\/\n+    static void repeatCopyRest(byte[] buffer, int offset, int limit, int copied) {\n+        \/\/ Initial copy is in the buffer.\n@@ -4458,1 +4479,2 @@\n-            System.arraycopy(multiple, 0, multiple, copied, copied);\n+            \/\/ Power of two duplicate.\n+            System.arraycopy(buffer, offset, buffer, offset + copied, copied);\n@@ -4460,2 +4482,2 @@\n-        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n-        return new String(multiple, coder);\n+        \/\/ Duplicate remainder.\n+        System.arraycopy(buffer, offset, buffer, offset + copied, limit - copied);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -711,0 +711,22 @@\n+    \/**\n+     * @since 21\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    @Override\n+    public synchronized StringBuffer repeat(char c, int count) {\n+        super.repeat(c, count);\n+        return this;\n+    }\n+\n+    \/**\n+     * @since 21\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    @Override\n+    public synchronized StringBuffer repeat(CharSequence cs, int count) {\n+        super.repeat(cs, count);\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringBuffer.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -449,0 +449,22 @@\n+    \/**\n+     * @since 21\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    @Override\n+    public StringBuilder repeat(char c, int count) {\n+        super.repeat(c, count);\n+        return this;\n+    }\n+\n+    \/**\n+     * @since 21\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    @Override\n+    public StringBuilder repeat(CharSequence cs, int count) {\n+        super.repeat(cs, count);\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringBuilder.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8302323\n+ * @summary Test StringBuilder.repeat sanity tests\n+ * @run testng\/othervm -XX:-CompactStrings Repeat\n+ * @run testng\/othervm -XX:+CompactStrings Repeat\n+ *\/\n+@Test\n+public class Repeat {\n+    private static class MyChars implements CharSequence {\n+        private static final char[] DATA = new char[] { 'a', 'b', 'c' };\n+\n+        @Override\n+        public int length() {\n+            return DATA.length;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            return DATA[index];\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int start, int end) {\n+            return new String(Arrays.copyOfRange(DATA, start, end));\n+        }\n+    }\n+\n+    private static final MyChars MYCHARS = new MyChars();\n+\n+    public void sanity() {\n+        StringBuilder sb = new StringBuilder();\n+        \/\/ prime the StringBuilder\n+        sb.append(\"repeat\");\n+\n+        \/\/ single character Latin1\n+        sb.repeat('1', 0);\n+        sb.repeat('2', 1);\n+        sb.repeat('3', 5);\n+\n+        \/\/ single string Latin1 (optimized)\n+        sb.repeat(\"1\", 0);\n+        sb.repeat(\"2\", 1);\n+        sb.repeat(\"3\", 5);\n+\n+        \/\/ multi string Latin1\n+        sb.repeat(\"-1\", 0);\n+        sb.repeat(\"-2\", 1);\n+        sb.repeat(\"-3\", 5);\n+\n+        \/\/ single character UTF16\n+        sb.repeat('\\u2460', 0);\n+        sb.repeat('\\u2461', 1);\n+        sb.repeat('\\u2462', 5);\n+\n+        \/\/ single string UTF16 (optimized)\n+        sb.repeat(\"\\u2460\", 0);\n+        sb.repeat(\"\\u2461\", 1);\n+        sb.repeat(\"\\u2462\", 5);\n+\n+        \/\/ multi string UTF16\n+\n+        sb.repeat(\"-\\u2460\", 0);\n+        sb.repeat(\"-\\u2461\", 1);\n+        sb.repeat(\"-\\u2462\", 5);\n+\n+        \/\/ CharSequence\n+        sb.repeat(MYCHARS, 3);\n+\n+        \/\/ null\n+        sb.repeat((String)null, 0);\n+        sb.repeat((String)null, 1);\n+        sb.repeat((String)null, 5);\n+        sb.repeat((CharSequence)null, 0);\n+        sb.repeat((CharSequence)null, 1);\n+        sb.repeat((CharSequence)null, 5);\n+\n+\n+        String expected = \"repeat233333233333-2-3-3-3-3-3\\u2461\\u2462\\u2462\\u2462\\u2462\\u2462\\u2461\\u2462\\u2462\\u2462\\u2462\\u2462-\\u2461-\\u2462-\\u2462-\\u2462-\\u2462-\\u2462abcabcabc\" +\n+                          \"nullnullnullnullnullnullnullnullnullnullnullnull\";\n+        assertEquals(expected, sb.toString());\n+    }\n+\n+    public void exceptions() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        try {\n+            sb.repeat(' ', Integer.MAX_VALUE);\n+            throw new RuntimeException(\"No OutOfMemoryError thrown\");\n+        } catch (OutOfMemoryError | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+        try {\n+            sb.repeat(\"    \", Integer.MAX_VALUE);\n+            throw new RuntimeException(\"No OutOfMemoryError thrown\");\n+        } catch (OutOfMemoryError | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+        try {\n+            sb.repeat(MYCHARS, Integer.MAX_VALUE);\n+            throw new RuntimeException(\"No OutOfMemoryError thrown\");\n+        } catch (OutOfMemoryError | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+        try {\n+            sb.repeat(' ', -1);\n+            throw new RuntimeException(\"No IllegalArgumentException thrown\");\n+        } catch (IllegalArgumentException | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+        try {\n+            sb.repeat(\"abc\", -1);\n+            throw new RuntimeException(\"No IllegalArgumentException thrown\");\n+        } catch (IllegalArgumentException | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+        try {\n+            sb.repeat(MYCHARS, -1);\n+            throw new RuntimeException(\"No IllegalArgumentException thrown\");\n+        } catch (IllegalArgumentException | IndexOutOfBoundsException ex) {\n+            \/\/ Okay\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/Repeat.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}