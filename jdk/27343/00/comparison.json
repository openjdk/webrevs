{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -109,1 +108,1 @@\n-            sharedSecret = ka.generateSecret(\"TlsPremasterSecret\");\n+            sharedSecret = ka.generateSecret(\"Generic\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+                new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n@@ -216,4 +217,1 @@\n-            \/\/ Some vendors, e.g. NSS, trim off the leading 0x00 byte(s) from\n-            \/\/ the generated secret. Thus, we need to check the secret length\n-            \/\/ and trim\/pad it so the returned value has the same length as\n-            \/\/ the modulus size\n+            \/\/ We configured the expected secret length, but check just in case.\n@@ -223,8 +221,1 @@\n-                if (secret.length > secretLen) {\n-                    \/\/ Shouldn't happen; but check just in case\n-                    throw new ProviderException(\"generated secret is out-of-range\");\n-                }\n-                byte[] newSecret = new byte[secretLen];\n-                System.arraycopy(secret, 0, newSecret, secretLen - secret.length,\n-                    secret.length);\n-                return newSecret;\n+                throw new ProviderException(\"generated secret is out-of-range\");\n@@ -324,4 +315,14 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n-            };\n+            CK_ATTRIBUTE[] attributes;\n+            if (\"TlsPremasterSecret\".equalsIgnoreCase(algorithm)) {\n+                attributes = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+                };\n+            } else {\n+                \/\/ keep the leading zeroes\n+                attributes = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n+                };\n+            }\n@@ -340,13 +341,0 @@\n-            if (\"RAW\".equals(key.getFormat())\n-                    && algorithm.equalsIgnoreCase(\"TlsPremasterSecret\")) {\n-                \/\/ Workaround for Solaris bug 6318543.\n-                \/\/ Strip leading zeroes ourselves if possible (key not sensitive).\n-                \/\/ This should be removed once the Solaris fix is available\n-                \/\/ as here we always retrieve the CKA_VALUE even for tokens\n-                \/\/ that do not have that bug.\n-                byte[] keyBytes = key.getEncoded();\n-                byte[] newBytes = KeyUtil.trimZeroes(keyBytes);\n-                if (keyBytes != newBytes) {\n-                    key = new SecretKeySpec(newBytes, algorithm);\n-                }\n-            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":17,"deletions":29,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618\n+ * @bug 8014618 8189441 8328046\n@@ -91,0 +91,20 @@\n+        \/\/ generate generic shared secret\n+        aliceKeyAgree.init(alicePrivKey);\n+        aliceKeyAgree.doPhase(bobPubKey, true);\n+        byte[] genericSecret =\n+            aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n+        System.out.println(\"generic secret:\\n\" + HEX_FORMATTER.formatHex(genericSecret));\n+\n+        \/\/ verify that leading zero is present\n+        if (genericSecret.length != 256) {\n+            throw new Exception(\"Unexpected generic secret length\");\n+        }\n+        if (genericSecret[0] != 0) {\n+            throw new Exception(\"First byte is not zero as expected\");\n+        }\n+        for (int i = 0; i < genericSecret.length; i++) {\n+            if (genericSecret[i] != sharedSecret[i]) {\n+                throw new Exception(\"Shared secrets differ\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestLeadingZeroes.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618\n+ * @bug 8014618 8189441 8328046\n@@ -90,0 +90,20 @@\n+        \/\/ generate generic shared secret\n+        aliceKeyAgree.init(alicePrivKey);\n+        aliceKeyAgree.doPhase(bobPubKey, true);\n+        byte[] genericSecret =\n+                aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n+        System.out.println(\"generic secret:\\n\" + HEX.formatHex(genericSecret));\n+\n+        \/\/ verify that leading zero is present\n+        if (genericSecret.length != 128) {\n+            throw new Exception(\"Unexpected generic secret length\");\n+        }\n+        if (genericSecret[0] != 0) {\n+            throw new Exception(\"First byte is not zero as expected\");\n+        }\n+        for (int i = 0; i < genericSecret.length; i++) {\n+            if (genericSecret[i] != sharedSecret[i]) {\n+                throw new Exception(\"Shared secrets differ\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"}]}