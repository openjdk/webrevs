{"files":[{"patch":"@@ -203,1 +203,0 @@\n-                new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n@@ -217,1 +216,4 @@\n-            \/\/ We configured the expected secret length, but check just in case.\n+            \/\/ Some vendors, e.g. NSS, trim off the leading 0x00 byte(s) from\n+            \/\/ the generated secret. Thus, we need to check the secret length\n+            \/\/ and trim\/pad it so the returned value has the same length as\n+            \/\/ the modulus size\n@@ -221,1 +223,8 @@\n-                throw new ProviderException(\"generated secret is out-of-range\");\n+                if (secret.length > secretLen) {\n+                    \/\/ Shouldn't happen; but check just in case\n+                    throw new ProviderException(\"generated secret is out-of-range\");\n+                }\n+                byte[] newSecret = new byte[secretLen];\n+                System.arraycopy(secret, 0, newSecret, secretLen - secret.length,\n+                    secret.length);\n+                return newSecret;\n@@ -315,14 +324,4 @@\n-            CK_ATTRIBUTE[] attributes;\n-            if (\"TlsPremasterSecret\".equalsIgnoreCase(algorithm)) {\n-                attributes = new CK_ATTRIBUTE[]{\n-                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n-                };\n-            } else {\n-                \/\/ keep the leading zeroes\n-                attributes = new CK_ATTRIBUTE[]{\n-                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n-                        new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n-                };\n-            }\n+            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+                new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+            };\n@@ -341,0 +340,13 @@\n+            if (\"RAW\".equals(key.getFormat())\n+                    && algorithm.equalsIgnoreCase(\"TlsPremasterSecret\")) {\n+                \/\/ Workaround for Solaris bug 6318543.\n+                \/\/ Strip leading zeroes ourselves if possible (key not sensitive).\n+                \/\/ This should be removed once the Solaris fix is available\n+                \/\/ as here we always retrieve the CKA_VALUE even for tokens\n+                \/\/ that do not have that bug.\n+                byte[] keyBytes = key.getEncoded();\n+                byte[] newBytes = KeyUtil.trimZeroes(keyBytes);\n+                if (keyBytes != newBytes) {\n+                    key = new SecretKeySpec(newBytes, algorithm);\n+                }\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618 8189441 8328046\n+ * @bug 8014618\n@@ -91,20 +91,0 @@\n-        \/\/ generate generic shared secret\n-        aliceKeyAgree.init(alicePrivKey);\n-        aliceKeyAgree.doPhase(bobPubKey, true);\n-        byte[] genericSecret =\n-            aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n-        System.out.println(\"generic secret:\\n\" + HEX_FORMATTER.formatHex(genericSecret));\n-\n-        \/\/ verify that leading zero is present\n-        if (genericSecret.length != 256) {\n-            throw new Exception(\"Unexpected generic secret length\");\n-        }\n-        if (genericSecret[0] != 0) {\n-            throw new Exception(\"First byte is not zero as expected\");\n-        }\n-        for (int i = 0; i < genericSecret.length; i++) {\n-            if (genericSecret[i] != sharedSecret[i]) {\n-                throw new Exception(\"Shared secrets differ\");\n-            }\n-        }\n-\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestLeadingZeroes.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618 8189441 8328046\n+ * @bug 8014618\n@@ -90,20 +90,0 @@\n-        \/\/ generate generic shared secret\n-        aliceKeyAgree.init(alicePrivKey);\n-        aliceKeyAgree.doPhase(bobPubKey, true);\n-        byte[] genericSecret =\n-                aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n-        System.out.println(\"generic secret:\\n\" + HEX.formatHex(genericSecret));\n-\n-        \/\/ verify that leading zero is present\n-        if (genericSecret.length != 128) {\n-            throw new Exception(\"Unexpected generic secret length\");\n-        }\n-        if (genericSecret[0] != 0) {\n-            throw new Exception(\"First byte is not zero as expected\");\n-        }\n-        for (int i = 0; i < genericSecret.length; i++) {\n-            if (genericSecret[i] != sharedSecret[i]) {\n-                throw new Exception(\"Shared secrets differ\");\n-            }\n-        }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"}]}