{"files":[{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotArtifactFinder.hpp\"\n+#include \"cds\/aotClassInitializer.hpp\"\n+#include \"cds\/dumpTimeClassInfo.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\/\/ All the classes that should be included in the AOT cache (in at least the \"allocated\" state)\n+static GrowableArrayCHeap<Klass*, mtClassShared>* _all_cached_classes = nullptr;\n+\n+\/\/ This is a stack that tracks all the AOT-inited classes that are waiting to be passed\n+\/\/ to HeapShared::copy_and_rescan_aot_inited_mirror().\n+static GrowableArrayCHeap<InstanceKlass*, mtClassShared>* _pending_aot_inited_classes = nullptr;\n+\n+static const int TABLE_SIZE = 15889; \/\/ prime number\n+using ClassesTable = ResourceHashtable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+static ClassesTable* _seen_classes;       \/\/ all classes that have been seen by AOTArtifactFinder\n+static ClassesTable* _aot_inited_classes; \/\/ all classes that need to be AOT-initialized.\n+\n+void AOTArtifactFinder::initialize() {\n+  _all_cached_classes = new GrowableArrayCHeap<Klass*, mtClassShared>();\n+  _pending_aot_inited_classes = new GrowableArrayCHeap<InstanceKlass*, mtClassShared>();\n+  _seen_classes = new (mtClass)ClassesTable();\n+  _aot_inited_classes = new (mtClass)ClassesTable();\n+}\n+\n+void AOTArtifactFinder::dispose() {\n+  delete _all_cached_classes;\n+  delete _seen_classes;\n+  delete _aot_inited_classes;\n+  delete _pending_aot_inited_classes;\n+  _all_cached_classes = nullptr;\n+  _seen_classes = nullptr;\n+  _aot_inited_classes = nullptr;\n+  _pending_aot_inited_classes = nullptr;\n+}\n+\n+\/\/ Find all Klasses and oops that should be included in the AOT cache. See aotArtifactFinder.hpp\n+void AOTArtifactFinder::find_artifacts() {\n+  \/\/ Some classes might have been marked as excluded as a side effect of running\n+  \/\/ AOTConstantPoolResolver. Make sure we check all the remaining ones.\n+  \/\/\n+  \/\/ Note, if a class is not excluded, it does NOT mean it will be automatically included\n+  \/\/ into the AOT cache -- that will be decided by the code below.\n+  SystemDictionaryShared::finish_exclusion_checks();\n+\n+  start_scanning_for_oops();\n+\n+  \/\/ Add the primitive array classes\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (is_java_primitive(bt)) {\n+      add_cached_type_array_class(Universe::typeArrayKlass(bt));\n+    }\n+  }\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Add the mirrors that aren't associated with a Klass\n+  \/\/    - primitive mirrors (E.g., \"int.class\" in Java code)\n+  \/\/    - mirror of fillerArrayKlass\n+  if (CDSConfig::is_dumping_heap()) {\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      BasicType bt = (BasicType)i;\n+      if (!is_reference_type(bt)) {\n+        oop orig_mirror = Universe::java_mirror(bt);\n+        oop scratch_mirror = HeapShared::scratch_java_mirror(bt);\n+        HeapShared::scan_java_mirror(orig_mirror);\n+        log_trace(cds, heap, mirror)(\n+            \"Archived %s mirror object from \" PTR_FORMAT,\n+            type2name(bt), p2i(scratch_mirror));\n+        Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(scratch_mirror));\n+      }\n+    }\n+\n+    \/\/ Universe::fillerArrayKlass() isn't in the class hierarchy, so handle it specially.\n+    HeapShared::scan_java_mirror(Universe::fillerArrayKlass()->java_mirror());\n+  }\n+#endif\n+\n+  \/\/ Add all the InstanceKlasses (and their array classes) that are always included.\n+  SystemDictionaryShared::dumptime_table()->iterate_all_live_classes([&] (InstanceKlass* ik, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      bool add = false;\n+      if (!ik->is_hidden()) {\n+        \/\/ All non-hidden classes are always included into the AOT cache\n+        add = true;\n+      } else {\n+        if (!CDSConfig::is_dumping_invokedynamic()) {\n+          \/\/ Legacy support of lambda proxies -- these are always included into the AOT cache\n+          if (SystemDictionaryShared::is_registered_lambda_proxy_class(ik)) {\n+            add = true;\n+          }\n+        } else {\n+          assert(!SystemDictionaryShared::is_registered_lambda_proxy_class(ik),\n+                 \"registered lambda proxies are only for legacy lambda proxy support\");\n+        }\n+      }\n+\n+      if (add) {\n+        add_cached_instance_class(ik);\n+        if (AOTClassInitializer::can_archive_initialized_mirror(ik)) {\n+          add_aot_inited_class(ik);\n+        }\n+      }\n+    }\n+  });\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Keep scanning until we discover no more class that need to be AOT-initialized.\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    while (_pending_aot_inited_classes->length() > 0) {\n+      InstanceKlass* ik = _pending_aot_inited_classes->pop();\n+      HeapShared::copy_and_rescan_aot_inited_mirror(ik);\n+    }\n+  }\n+#endif\n+\n+  \/\/ Exclude all the (hidden) classes that have not been discovered by the code above.\n+  SystemDictionaryShared::dumptime_table()->iterate_all_live_classes([&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded() && _seen_classes->get(k) == nullptr) {\n+      info.set_excluded();\n+      assert(k->is_hidden(), \"must be\");\n+      if (log_is_enabled(Info, cds)) {\n+        ResourceMark rm;\n+        log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+      }\n+    }\n+  });\n+\n+  end_scanning_for_oops();\n+}\n+\n+void AOTArtifactFinder::start_scanning_for_oops() {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    HeapShared::start_scanning_for_oops();\n+  }\n+#endif\n+}\n+\n+void AOTArtifactFinder::end_scanning_for_oops() {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    HeapShared::end_scanning_for_oops();\n+  }\n+#endif\n+}\n+\n+void AOTArtifactFinder::add_aot_inited_class(InstanceKlass* ik) {\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    assert(ik->is_initialized(), \"must be\");\n+    add_cached_instance_class(ik);\n+\n+    bool created;\n+    _aot_inited_classes->put_if_absent(ik, &created);\n+    if (created) {\n+      _pending_aot_inited_classes->push(ik);\n+\n+      InstanceKlass* s = ik->java_super();\n+      if (s != nullptr) {\n+        add_aot_inited_class(s);\n+      }\n+\n+      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+      int len = interfaces->length();\n+      for (int i = 0; i < len; i++) {\n+        InstanceKlass* intf = interfaces->at(i);\n+        if (intf->is_initialized()) {\n+          add_aot_inited_class(intf);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void AOTArtifactFinder::add_cached_instance_class(InstanceKlass* ik) {\n+  bool created;\n+  _seen_classes->put_if_absent(ik, &created);\n+  if (created) {\n+    _all_cached_classes->append(ik);\n+    scan_oops_in_instance_class(ik);\n+    if (ik->is_hidden() && CDSConfig::is_initing_classes_at_dump_time()) {\n+      bool succeed = AOTClassLinker::try_add_candidate(ik);\n+      guarantee(succeed, \"All cached hidden classes must be aot-linkable\");\n+      add_aot_inited_class(ik);\n+    }\n+  }\n+}\n+\n+void AOTArtifactFinder::add_cached_type_array_class(TypeArrayKlass* tak) {\n+  bool created;\n+  _seen_classes->put_if_absent(tak, &created);\n+  if (created) {\n+    _all_cached_classes->append(tak);\n+    scan_oops_in_array_class(tak);\n+  }\n+}\n+\n+void AOTArtifactFinder::add_cached_class(Klass* k) {\n+  if (k->is_typeArray_klass()) {\n+    add_cached_type_array_class(TypeArrayKlass::cast(k));\n+  } else if (k->is_objArray_klass()) {\n+    add_cached_class(ObjArrayKlass::cast(k)->element_klass());\n+  } else {\n+    add_cached_instance_class(InstanceKlass::cast(k));\n+  }\n+}\n+\n+void AOTArtifactFinder::scan_oops_in_instance_class(InstanceKlass* ik) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    HeapShared::scan_java_class(ik);\n+    scan_oops_in_array_class(ik->array_klasses());\n+  }\n+#endif\n+}\n+\n+void AOTArtifactFinder::scan_oops_in_array_class(ArrayKlass* ak) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_dumping_heap()) {\n+    while (ak != nullptr) {\n+      HeapShared::scan_java_class(ak);\n+      ak = ak->array_klass_or_null();\n+    }\n+  }\n+#endif\n+}\n+\n+void AOTArtifactFinder::all_cached_classes_do(MetaspaceClosure* it) {\n+  for (int i = 0; i < _all_cached_classes->length(); i++) {\n+    it->push(_all_cached_classes->adr_at(i));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTARTIFACTFINDER_HPP\n+#define SHARE_CDS_AOTARTIFACTFINDER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class ArrayKlass;\n+class InstanceKlass;\n+class MetaspaceClosure;\n+class TypeArrayKlass;\n+\n+\/\/ AOTArtifactFinder finds (the roots of) all artifacts that should be included in the AOT cache. These include:\n+\/\/   [1] C++ Klasses\n+\/\/   [2] Java heap objects\n+\/\/ It also decides what Klasses must be cached in aot-initialized state.\n+\/\/\n+\/\/ ArchiveBuilder uses [1] as roots to scan for all MetaspaceObjs that need to be cached.\n+\/\/ ArchiveHeapWriter uses [2] to create an image of the archived heap.\n+\/\/\n+\/\/ [1] is stored in _all_cached_classes in aotArtifactFinder.cpp.\n+\/\/ [2] is stored in HeapShared::archived_object_cache().\n+\/\/\n+\/\/ Although many Klasses and heap objects are created in the assembly phase, we only store a subset of them into\n+\/\/ the AOT cache. For example:\n+\/\/     - Klasses that fail verification are excluded\n+\/\/     - Many Klasses are stored in non-initialized state, so any initialized static fields in their\n+\/\/       java mirrors must be cleared.\n+\/\/     - To conserve space, we exclude any hidden classes that are not referenced.\n+\/\/\n+\/\/ The discovery of [1] and [2] is interdependent, and is done inside AOTArtifactFinder::find()\n+\/\/     - We first add a set of roots that must be included in the AOT cache\n+\/\/       - mirrors of primitive classes (e.g., int.class in Java source code).\n+\/\/       - primitive array classes\n+\/\/       - non hidden classes\n+\/\/       - registered lambda proxy classes\n+\/\/    - Whenever a class is added, we scan its constant pool. This will discover references\n+\/\/      to hidden classes. All such hidden classes are added.\n+\/\/    - As classes and heap objects are discovered, we find out what classes must be AOT-initialized\n+\/\/       - If we discover at least one instance of class X, then class X is AOT-initialized (** Note1).\n+\/\/       - If AOTClassInitializer::can_archive_initialized_mirror(X) is true, then X is AOT-initialized.\n+\/\/    - For each AOT-initialized class, we scan all the static fields in its java mirror. This will in\n+\/\/      turn discover more Klasses and java heap objects.\n+\/\/    - The scanning continues until we reach a steady state.\n+\/\/\n+\/\/ Note1: See TODO comments in HeapShared::archive_object() for exceptions to this rule.\n+\/\/\n+\/\/ Note2: The scanning of Java objects is done in heapShared.cpp. Please see calls into the HeapShared class\n+\/\/        from AOTArtifactFinder.\n+\n+class AOTArtifactFinder : AllStatic {\n+  static void start_scanning_for_oops();\n+  static void end_scanning_for_oops();\n+  static void scan_oops_in_instance_class(InstanceKlass* ik);\n+  static void scan_oops_in_array_class(ArrayKlass* ak);\n+  static void add_cached_type_array_class(TypeArrayKlass* tak);\n+  static void add_cached_instance_class(InstanceKlass* ik);\n+public:\n+  static void initialize();\n+  static void find_artifacts();\n+  static void add_cached_class(Klass* k);\n+  static void add_aot_inited_class(InstanceKlass* ik);\n+  static void all_cached_classes_do(MetaspaceClosure* it);\n+  static void dispose();\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTARTIFACTFINDER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.hpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -106,8 +106,0 @@\n-  if (ik->is_hidden()) {\n-    return HeapShared::is_archivable_hidden_klass(ik);\n-  }\n-\n-  if (ik->is_enum_subclass()) {\n-    return true;\n-  }\n-\n@@ -120,1 +112,1 @@\n-  \/\/ HeapShared::find_all_aot_initialized_classes() finds the classes of all\n+  \/\/ AOTArtifactFinder::find_artifacts() finds the classes of all\n@@ -124,1 +116,1 @@\n-  \/\/ at runtime.\n+  \/\/ at runtime. See aotArtifactFinder.hpp for more info.\n@@ -271,3 +263,1 @@\n-      \/\/ above we selected all enums; we must include their super as well\n-      {\"java\/lang\/Enum\"},\n-     {nullptr}\n+      {nullptr}\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -149,3 +149,0 @@\n-    if (!SystemDictionaryShared::should_hidden_class_be_archived(ik)) {\n-      return false;\n-    }\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -198,0 +199,2 @@\n+\n+  AOTArtifactFinder::dispose();\n@@ -235,1 +238,0 @@\n-        assert(SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass::cast(klass)), \"must be\");\n@@ -257,0 +259,4 @@\n+\n+  AOTArtifactFinder::initialize();\n+  AOTArtifactFinder::find_artifacts();\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -326,0 +327,4 @@\n+\n+    if (java_lang_Module::is_instance(src_obj)) {\n+      Modules::check_archived_module_oop(src_obj);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,2 +75,3 @@\n-  \/\/   HeapShared::archive_objects() recursively searches for the oops that need to be\n-  \/\/   stored into the CDS archive. These are entered into HeapShared::archived_object_cache().\n+  \/\/   Between HeapShared::start_scanning_for_oops() and HeapShared::end_scanning_for_oops(),\n+  \/\/   we recursively search for the oops that need to be stored into the CDS archive.\n+  \/\/   These are entered into HeapShared::archived_object_cache().\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n@@ -76,1 +75,0 @@\n-  ArchiveBuilder::get_buffered_klass(ik)->set_has_archived_enum_objs();\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,0 +261,2 @@\n+\/\/ This function is called once for every archived heap object. Warn if this object is referenced by\n+\/\/ a static field of a class that's not aot-initialized.\n@@ -264,0 +266,6 @@\n+  if (java_lang_String::is_instance(orig_obj) && HeapShared::is_dumped_interned_string(orig_obj)) {\n+    \/\/ It's quite often for static fields to have interned strings. These are most likely not\n+    \/\/ problematic (and are hard to filter). So we will ignore them.\n+    return true; \/* keep on iterating *\/\n+  }\n+\n@@ -266,9 +274,0 @@\n-    if (value.orig_referrer() == nullptr && java_lang_String::is_instance(orig_obj)) {\n-      \/\/ This string object is not referenced by any of the archived object graphs. It's archived\n-      \/\/ only because it's in the interned string table. So we are not in a condition that\n-      \/\/ should be flagged by CDSHeapVerifier.\n-      return true; \/* keep on iterating *\/\n-    }\n-    if (info->_holder->is_hidden()) {\n-      return true;\n-    }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  bool                         _is_required_hidden_class;\n-  bool                         _has_scanned_constant_pool;\n@@ -126,1 +124,1 @@\n-  bool                         _is_archived_lambda_proxy;\n+  bool                         _is_registered_lambda_proxy;\n@@ -139,1 +137,1 @@\n-    _is_archived_lambda_proxy = false;\n+    _is_registered_lambda_proxy = false;\n@@ -141,2 +139,0 @@\n-    _is_required_hidden_class = false;\n-    _has_scanned_constant_pool = false;\n@@ -220,5 +216,0 @@\n-  bool is_required_hidden_class() const             { return _is_required_hidden_class; }\n-  void set_is_required_hidden_class()               { _is_required_hidden_class = true; }\n-  bool has_scanned_constant_pool() const            { return _has_scanned_constant_pool; }\n-  void set_has_scanned_constant_pool()              { _has_scanned_constant_pool = true; }\n-\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -115,1 +116,0 @@\n-    SystemDictionaryShared::find_all_archivable_classes();\n@@ -181,0 +181,1 @@\n+    AOTArtifactFinder::all_cached_classes_do(it);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -223,1 +224,3 @@\n-\n+  if (obj != nullptr) {\n+    assert(has_been_archived(obj), \"must be\");\n+  }\n@@ -293,1 +296,1 @@\n-bool HeapShared::archive_object(oop obj) {\n+bool HeapShared::archive_object(oop obj, KlassSubGraphInfo* subgraph_info) {\n@@ -314,0 +317,30 @@\n+    Klass* k = obj->klass();\n+    if (k->is_instance_klass()) {\n+      \/\/ Whenever we see a non-array Java object of type X, we mark X to be aot-initialized.\n+      \/\/ This ensures that during the production run, whenever Java code seens a cached object\n+      \/\/ of type X, we know that X is already initialized. (see TODO comment below ...)\n+\n+      if (InstanceKlass::cast(k)->is_enum_subclass()) {\n+        \/\/ We can't rerun <clinit> of enum classes (see cdsEnumKlass.cpp) so\n+        \/\/ we must store them as AOT-initialized.\n+        AOTArtifactFinder::add_aot_inited_class(InstanceKlass::cast(k));\n+      } else if (subgraph_info == _dump_time_special_subgraph) {\n+        \/\/ TODO: we do this only for the special subgraph for now. Extending this to\n+        \/\/ other subgraphs would require more refactoring of the core library (such as\n+        \/\/ move some initialization logic into runtimeSetup()).\n+        \/\/\n+        \/\/ For the other subgraphs, we have a weaker mechanism to ensure that\n+        \/\/ all classes in a subgraph are initialized before the subgraph is programmatically\n+        \/\/ returned from jdk.internal.misc.CDS::initializeFromArchive().\n+        \/\/ See HeapShared::initialize_from_archived_subgraph().\n+        AOTArtifactFinder::add_aot_inited_class(InstanceKlass::cast(k));\n+      }\n+\n+      if (java_lang_Class::is_instance(obj)) {\n+        Klass* mirror_k = java_lang_Class::as_Klass(obj);\n+        if (mirror_k != nullptr) {\n+          AOTArtifactFinder::add_cached_class(mirror_k);\n+        }\n+      }\n+    }\n+\n@@ -331,4 +364,0 @@\n-    if (java_lang_Module::is_instance(obj) && Modules::check_archived_module_oop(obj)) {\n-      Modules::update_oops_in_archived_module(obj, append_root(obj));\n-    }\n-\n@@ -370,1 +399,3 @@\n-  _scratch_references_table->set_oop(src, dest);\n+  if (SystemDictionaryShared::is_builtin_loader(src->pool_holder()->class_loader_data())) {\n+    _scratch_references_table->set_oop(src, dest);\n+  }\n@@ -469,4 +500,0 @@\n-void HeapShared::copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m) {\n-  assert(orig_k->is_instance_klass(), \"sanity\");\n-  InstanceKlass* ik = InstanceKlass::cast(orig_k);\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n@@ -474,0 +501,8 @@\n+void HeapShared::copy_and_rescan_aot_inited_mirror(InstanceKlass* ik) {\n+  ik->set_has_aot_initialized_mirror();\n+  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n+    ik->set_is_runtime_setup_required();\n+  }\n+\n+  oop orig_mirror = ik->java_mirror();\n+  oop m = scratch_java_mirror(ik);\n@@ -484,1 +519,13 @@\n-        m->obj_field_put(offset, orig_mirror->obj_field(offset));\n+        {\n+          oop field_obj = orig_mirror->obj_field(offset);\n+          if (offset == java_lang_Class::reflection_data_offset()) {\n+            \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n+            \/\/ to null and it will be recreated at runtime.\n+            field_obj = nullptr;\n+          }\n+          m->obj_field_put(offset, field_obj);\n+          if (field_obj != nullptr) {\n+            bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, field_obj);\n+            assert(success, \"sanity\");\n+          }\n+        }\n@@ -517,5 +564,6 @@\n-  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n-\n-  \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n-  \/\/ to null and it will be recreated at runtime.\n-  java_lang_Class::set_reflection_data(m, nullptr);\n+  oop class_data = java_lang_Class::class_data(orig_mirror);\n+  java_lang_Class::set_class_data(m, class_data);\n+  if (class_data != nullptr) {\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, class_data);\n+    assert(success, \"sanity\");\n+  }\n@@ -525,2 +573,3 @@\n-    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s\", nfields, ik->external_name(),\n-                         ik->is_hidden() ? \" (hidden)\" : \"\");\n+    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n+                         ik->is_hidden() ? \" (hidden)\" : \"\",\n+                         ik->is_enum_subclass() ? \" (enum)\" : \"\");\n@@ -549,4 +598,1 @@\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n-  if (buffered_ik->is_shared_boot_class() ||\n-      buffered_ik->is_shared_platform_class() ||\n-      buffered_ik->is_shared_app_class()) {\n+  if (SystemDictionaryShared::is_builtin_loader(src_ik->class_loader_data())) {\n@@ -561,60 +607,0 @@\n-void HeapShared::archive_java_mirrors() {\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    BasicType bt = (BasicType)i;\n-    if (!is_reference_type(bt)) {\n-      oop orig_mirror = Universe::java_mirror(bt);\n-      oop m = _scratch_basic_type_mirrors[i].resolve();\n-      assert(m != nullptr, \"sanity\");\n-      copy_java_mirror_hashcode(orig_mirror, m);\n-      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n-      assert(success, \"sanity\");\n-\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT,\n-        type2name(bt), p2i(m));\n-\n-      Universe::set_archived_basic_type_mirror_index(bt, append_root(m));\n-    }\n-  }\n-\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != nullptr, \"sanity\");\n-\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* orig_k = klasses->at(i);\n-    oop orig_mirror = orig_k->java_mirror();\n-    oop m = scratch_java_mirror(orig_k);\n-    if (m != nullptr) {\n-      copy_java_mirror_hashcode(orig_mirror, m);\n-    }\n-  }\n-\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* orig_k = klasses->at(i);\n-    oop orig_mirror = orig_k->java_mirror();\n-    oop m = scratch_java_mirror(orig_k);\n-    if (m != nullptr) {\n-      Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n-      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n-      guarantee(success, \"scratch mirrors must point to only archivable objects\");\n-      buffered_k->set_archived_java_mirror(append_root(m));\n-      ResourceMark rm;\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT,\n-        buffered_k->external_name(), p2i(m));\n-\n-      \/\/ archive the resolved_referenes array\n-      if (buffered_k->is_instance_klass()) {\n-        InstanceKlass* ik = InstanceKlass::cast(buffered_k);\n-        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n-        if (rr != nullptr) {\n-          bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n-          assert(success, \"must be\");\n-          int root_index = append_root(rr);\n-          ik->constants()->cache()->set_archived_references(root_index);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -622,1 +608,1 @@\n-  oop shared_strings_array = StringTable::init_shared_table(_dumped_interned_strings);\n+  oop shared_strings_array = StringTable::init_shared_strings_array(_dumped_interned_strings);\n@@ -659,109 +645,3 @@\n-void HeapShared::start_finding_required_hidden_classes() {\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    return;\n-  }\n-  NoSafepointVerifier nsv;\n-\n-  init_seen_objects_table();\n-\n-  \/\/ We first scan the objects that are known to be archived (from the archive_subgraph\n-  \/\/ tables)\n-  find_required_hidden_classes_helper(archive_subgraph_entry_fields);\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    find_required_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n-  }\n-\n-  \/\/ Later, SystemDictionaryShared::find_all_archivable_classes_impl() will start\n-  \/\/ scanning the constant pools of all classes that it decides to archive.\n-}\n-\n-void HeapShared::end_finding_required_hidden_classes() {\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    return;\n-  }\n-  NoSafepointVerifier nsv;\n-\n-  delete_seen_objects_table();\n-}\n-\n-void HeapShared::find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n-  if (!CDSConfig::is_dumping_heap()) {\n-    return;\n-  }\n-  for (int i = 0; fields[i].valid(); i++) {\n-    ArchivableStaticFieldInfo* f = &fields[i];\n-    InstanceKlass* k = f->klass;\n-    oop m = k->java_mirror();\n-    oop o = m->obj_field(f->offset);\n-    if (o != nullptr) {\n-      find_required_hidden_classes_in_object(o);\n-    }\n-  }\n-}\n-\n-class HeapShared::FindRequiredHiddenClassesOopClosure: public BasicOopIterateClosure {\n-  GrowableArray<oop> _stack;\n-  template <class T> void do_oop_work(T *p) {\n-    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n-    oop o = RawAccess<>::oop_load(p);\n-    if (o != nullptr) {\n-      _stack.append(o);\n-    }\n-  }\n-\n- public:\n-\n-  void do_oop(narrowOop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n-  void do_oop(      oop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n-\n-  FindRequiredHiddenClassesOopClosure(oop o) {\n-    _stack.append(o);\n-  }\n-  oop pop() {\n-    if (_stack.length() == 0) {\n-      return nullptr;\n-    } else {\n-      return _stack.pop();\n-    }\n-  }\n-};\n-\n-static void mark_required_if_hidden_class(Klass* k) {\n-  if (k != nullptr && k->is_instance_klass()) {\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->is_hidden()) {\n-      SystemDictionaryShared::mark_required_hidden_class(ik);\n-    }\n-  }\n-}\n-\n-\n-void HeapShared::find_required_hidden_classes_in_object(oop root) {\n-  ResourceMark rm;\n-  FindRequiredHiddenClassesOopClosure c(root);\n-  oop o;\n-  while ((o = c.pop()) != nullptr) {\n-    if (!has_been_seen_during_subgraph_recording(o)) {\n-      set_has_been_seen_during_subgraph_recording(o);\n-\n-      \/\/ Mark the klass of this object\n-      mark_required_if_hidden_class(o->klass());\n-\n-      \/\/ For special objects, mark the klass that they contain information about.\n-      \/\/ - a Class that refers to an hidden class\n-      \/\/ - a ResolvedMethodName that refers to a method declared in a hidden class\n-      if (java_lang_Class::is_instance(o)) {\n-        mark_required_if_hidden_class(java_lang_Class::as_Klass(o));\n-      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n-        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n-        if (m != nullptr) {\n-          mark_required_if_hidden_class(m->method_holder());\n-        }\n-      }\n-\n-      o->oop_iterate(&c);\n-    }\n-  }\n-}\n-\n-void HeapShared::archive_objects(ArchiveHeapInfo *heap_info) {\n+\/\/ Between start_scanning_for_oops() and end_scanning_for_oops(), we discover all Java heap objects that\n+\/\/ should be stored in the AOT cache. The scanning is coordinated by AOTArtifactFinder.\n+void HeapShared::start_scanning_for_oops() {\n@@ -785,1 +665,0 @@\n-    copy_objects();\n@@ -787,2 +666,1 @@\n-    CDSHeapVerifier::verify();\n-    check_special_subgraph_classes();\n+    archive_subgraphs();\n@@ -791,4 +669,0 @@\n-  ArchiveHeapWriter::write(_pending_roots, heap_info);\n-}\n-\n-void HeapShared::copy_interned_strings() {\n@@ -796,0 +670,2 @@\n+  Universe::archive_exception_instances();\n+}\n@@ -797,11 +673,2 @@\n-  auto copier = [&] (oop s, bool value_ignored) {\n-    assert(s != nullptr, \"sanity\");\n-    assert(!ArchiveHeapWriter::is_string_too_large_to_archive(s), \"large strings must have been filtered\");\n-    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, s);\n-    assert(success, \"must be\");\n-    \/\/ Prevent string deduplication from changing the value field to\n-    \/\/ something not in the archive.\n-    java_lang_String::set_deduplication_forbidden(s);\n-  };\n-  _dumped_interned_strings->iterate_all(copier);\n-\n+void HeapShared::end_scanning_for_oops() {\n+  archive_strings();\n@@ -811,4 +678,1 @@\n-void HeapShared::copy_special_subgraph() {\n-  copy_interned_strings();\n-\n-  init_seen_objects_table();\n+void HeapShared::write_heap(ArchiveHeapInfo *heap_info) {\n@@ -816,3 +680,3 @@\n-    archive_java_mirrors();\n-    archive_strings();\n-    Universe::archive_exception_instances();\n+    NoSafepointVerifier nsv;\n+    CDSHeapVerifier::verify();\n+    check_special_subgraph_classes();\n@@ -820,1 +684,6 @@\n-  delete_seen_objects_table();\n+\n+  StringTable::write_shared_table(_dumped_interned_strings);\n+  ArchiveHeapWriter::write(_pending_roots, heap_info);\n+\n+  ArchiveBuilder::OtherROAllocMark mark;\n+  write_subgraph_info_table();\n@@ -823,7 +692,19 @@\n-void HeapShared::prepare_resolved_references() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* src_k = klasses->at(i);\n-    if (src_k->is_instance_klass()) {\n-      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n-      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+void HeapShared::scan_java_mirror(oop orig_mirror) {\n+  oop m = scratch_java_mirror(orig_mirror);\n+  if (m != nullptr) { \/\/ nullptr if for custom class loader\n+    copy_java_mirror_hashcode(orig_mirror, m);\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n+    assert(success, \"sanity\");\n+  }\n+}\n+\n+void HeapShared::scan_java_class(Klass* orig_k) {\n+  scan_java_mirror(orig_k->java_mirror());\n+\n+  if (orig_k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+    orig_ik->constants()->prepare_resolved_references_for_archiving();\n+    objArrayOop rr = get_archived_resolved_references(orig_ik);\n+    if (rr != nullptr) {\n+      bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n+      assert(success, \"must be\");\n@@ -831,0 +712,2 @@\n+\n+    orig_ik->constants()->add_dumped_interned_strings();\n@@ -834,1 +717,1 @@\n-void HeapShared::copy_objects() {\n+void HeapShared::archive_subgraphs() {\n@@ -837,4 +720,0 @@\n-  prepare_resolved_references();\n-  find_all_aot_initialized_classes();\n-  copy_special_subgraph();\n-\n@@ -851,192 +730,0 @@\n-\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n-\/\/ that are reachable from a given root.\n-class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n-  bool _made_progress;\n-\n-  template <class T> void check(T *p) {\n-    oop obj = HeapAccess<>::oop_load(p);\n-    if (!java_lang_Class::is_instance(obj)) {\n-      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n-      \/\/ the object graph, .... TODO more info\n-      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n-    }\n-  }\n-\n-public:\n-  AOTInitializedClassScanner() : _made_progress(false) {}\n-  void do_oop(narrowOop *p) { check(p); }\n-  void do_oop(      oop *p) { check(p); }\n-  bool made_progress() { return _made_progress; }\n-};\n-\n-\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n-\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n-\/\/ <buffered_ik>.\n-\/\/\n-\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n-\/\/ <intf> has not declared any default methods.\n-\/\/\n-\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n-\/\/ a safepoint.\n-\/\/\n-\/\/ Returns true if one or more classes have been newly marked.\n-static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n-  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n-\n-  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n-    return false;\n-  }\n-\n-  bool made_progress = false;\n-  if (buffered_ik->is_initialized()) {\n-    if (log_is_enabled(Info, cds, init)) {\n-      ResourceMark rm;\n-      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n-    }\n-\n-    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n-\n-    \/\/ If we get here with a \"wild\" user class, which may have\n-    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n-    \/\/ filtering logic upstream needs to detect APP classes and not mark\n-    \/\/ them for aot-init in the first place, but this will be the final\n-    \/\/ firewall.\n-\n-#ifndef PRODUCT\n-    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n-    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n-    if (ArchiveHeapTestClass == nullptr)\n-#endif\n-    {\n-      if (!src_ik->in_javabase_module()) {\n-        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n-        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n-        if (buffered_ik->is_interface()) {\n-          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n-          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n-                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n-        } else {\n-          \/\/ \"normal\" classes\n-          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n-                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n-        }\n-      }\n-    }\n-\n-    buffered_ik->set_has_aot_initialized_mirror();\n-    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n-      buffered_ik->set_is_runtime_setup_required();\n-    }\n-    made_progress = true;\n-\n-    InstanceKlass* super = buffered_ik->java_super();\n-    if (super != nullptr) {\n-      mark_for_aot_initialization(super);\n-    }\n-\n-    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      InstanceKlass* intf = interfaces->at(i);\n-      mark_for_aot_initialization(intf);\n-      if (!intf->is_initialized()) {\n-        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n-        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n-      }\n-    }\n-  }\n-\n-  return made_progress;\n-}\n-\n-void HeapShared::find_all_aot_initialized_classes() {\n-  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n-    return;\n-  }\n-\n-  init_seen_objects_table();\n-  find_all_aot_initialized_classes_helper();\n-  delete_seen_objects_table();\n-}\n-\n-\/\/ Recursively find all class that should be aot-initialized:\n-\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n-\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n-void HeapShared::find_all_aot_initialized_classes_helper() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != nullptr, \"sanity\");\n-\n-  \/\/ First scan all resolved constant pools references.\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* src_k = klasses->at(i);\n-    if (src_k->is_instance_klass()) {\n-      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n-      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n-      objArrayOop rr = get_archived_resolved_references(src_ik);\n-      if (rr != nullptr) {\n-        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n-        for (int i = 0; i < scratch_rr->length(); i++) {\n-          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n-        }\n-      }\n-\n-      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n-      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n-        mark_for_aot_initialization(buffered_ik);\n-      }\n-    }\n-  }\n-\n-  \/\/ These objects also belong to the special subgraph\n-  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n-  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n-\n-  bool made_progress;\n-  do {\n-    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n-    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n-    \/\/ mark more classes. Keep iterating until no more progress can be made.\n-    made_progress = false;\n-    for (int i = 0; i < klasses->length(); i++) {\n-      Klass* orig_k = klasses->at(i);\n-      if (orig_k->is_instance_klass()) {\n-        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n-        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n-          oop orig_mirror = orig_ik->java_mirror();\n-          oop scratch_mirror = scratch_java_mirror(orig_k);\n-          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n-            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n-            \/\/ are not archived).\n-            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n-            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n-          }\n-        }\n-      }\n-    }\n-  } while (made_progress);\n-}\n-\n-bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n-  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n-    return false;\n-  }\n-  set_has_been_seen_during_subgraph_recording(obj);\n-\n-  bool made_progress = false;\n-  Klass* k = obj->klass();\n-  if (k->is_instance_klass()) {\n-    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n-    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n-    made_progress = mark_for_aot_initialization(buffered_ik);\n-  }\n-\n-  AOTInitializedClassScanner scanner;\n-  obj->oop_iterate(&scanner);\n-  made_progress |= scanner.made_progress();\n-  return made_progress;\n-}\n-\n@@ -1055,1 +742,0 @@\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n@@ -1057,1 +743,1 @@\n-    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(buffered_k, is_full_module_graph),\n+    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(k, is_full_module_graph),\n@@ -1085,1 +771,0 @@\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n@@ -1092,3 +777,1 @@\n-  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_k), \"must be a shared class\");\n-\n-  if (_k == buffered_k) {\n+  if (_k == orig_k) {\n@@ -1100,1 +783,2 @@\n-  if (buffered_k->is_instance_klass()) {\n+  if (orig_k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(orig_k);\n@@ -1102,2 +786,2 @@\n-      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n-             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+      assert(ik->class_loader() == nullptr ||\n+             HeapShared::is_lambda_proxy_klass(ik),\n@@ -1106,2 +790,1 @@\n-      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-             \"must be boot class\");\n+      assert(ik->class_loader() == nullptr, \"must be boot class\");\n@@ -1117,4 +800,0 @@\n-    if (buffered_k->has_aot_initialized_mirror()) {\n-      \/\/ No need to add to the runtime-init list.\n-      return;\n-    }\n@@ -1122,2 +801,2 @@\n-  } else if (buffered_k->is_objArray_klass()) {\n-    Klass* abk = ObjArrayKlass::cast(buffered_k)->bottom_klass();\n+  } else if (orig_k->is_objArray_klass()) {\n+    Klass* abk = ObjArrayKlass::cast(orig_k)->bottom_klass();\n@@ -1129,1 +808,1 @@\n-    if (buffered_k == Universe::objectArrayKlass()) {\n+    if (orig_k == Universe::objectArrayKlass()) {\n@@ -1135,1 +814,1 @@\n-    assert(buffered_k->is_typeArray_klass(), \"must be\");\n+    assert(orig_k->is_typeArray_klass(), \"must be\");\n@@ -1141,1 +820,1 @@\n-    if (!_subgraph_object_klasses->contains(buffered_k)) {\n+    if (!_subgraph_object_klasses->contains(orig_k)) {\n@@ -1147,1 +826,1 @@\n-  _subgraph_object_klasses->append_if_missing(buffered_k);\n+  _subgraph_object_klasses->append_if_missing(orig_k);\n@@ -1203,1 +882,1 @@\n-  _k = info->klass();\n+  _k = ArchiveBuilder::get_buffered_klass(info->klass());\n@@ -1236,6 +915,16 @@\n-  \/\/ the Klasses of the objects in the sub-graphs\n-  GrowableArray<Klass*>* subgraph_object_klasses = info->subgraph_object_klasses();\n-  if (subgraph_object_klasses != nullptr) {\n-    int num_subgraphs_klasses = subgraph_object_klasses->length();\n-    _subgraph_object_klasses =\n-      ArchiveBuilder::new_ro_array<Klass*>(num_subgraphs_klasses);\n+  \/\/ <recorded_klasses> has the Klasses of all the objects that are referenced by this subgraph.\n+  \/\/ Copy those that need to be explicitly initialized into <_subgraph_object_klasses>.\n+  GrowableArray<Klass*>* recorded_klasses = info->subgraph_object_klasses();\n+  if (recorded_klasses != nullptr) {\n+    \/\/ AOT-inited classes are automatically marked as \"initialized\" during bootstrap. When\n+    \/\/ programmatically loading a subgraph, we only need to explicitly initialize the classes\n+    \/\/ that are not aot-inited.\n+    int num_to_copy = 0;\n+    for (int i = 0; i < recorded_klasses->length(); i++) {\n+      Klass* subgraph_k = ArchiveBuilder::get_buffered_klass(recorded_klasses->at(i));\n+      if (!subgraph_k->has_aot_initialized_mirror()) {\n+        num_to_copy ++;\n+      }\n+    }\n+\n+    _subgraph_object_klasses = ArchiveBuilder::new_ro_array<Klass*>(num_to_copy);\n@@ -1243,2 +932,5 @@\n-    for (int i = 0; i < num_subgraphs_klasses; i++) {\n-      Klass* subgraph_k = subgraph_object_klasses->at(i);\n+    for (int i = 0, n = 0; i < recorded_klasses->length(); i++) {\n+      Klass* subgraph_k = ArchiveBuilder::get_buffered_klass(recorded_klasses->at(i));\n+      if (subgraph_k->has_aot_initialized_mirror()) {\n+        continue;\n+      }\n@@ -1253,1 +945,1 @@\n-          owner_name, i, subgraph_k->external_name());\n+          owner_name, n, subgraph_k->external_name());\n@@ -1255,2 +947,3 @@\n-      _subgraph_object_klasses->at_put(i, subgraph_k);\n-      ArchivePtrMarker::mark_pointer(_subgraph_object_klasses->adr_at(i));\n+      _subgraph_object_klasses->at_put(n, subgraph_k);\n+      ArchivePtrMarker::mark_pointer(_subgraph_object_klasses->adr_at(n));\n+      n++;\n@@ -1834,1 +1527,1 @@\n-    if (!archive_object(orig_obj)) {\n+    if (!archive_object(orig_obj, subgraph_info)) {\n@@ -2014,1 +1707,1 @@\n-      Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+      Symbol* name = subgraph_k->name();\n@@ -2340,0 +2033,3 @@\n+    \/\/ Prevent string deduplication from changing the value field to\n+    \/\/ something not in the archive.\n+    java_lang_String::set_deduplication_forbidden(string);\n@@ -2344,0 +2040,4 @@\n+bool HeapShared::is_dumped_interned_string(oop o) {\n+  return _dumped_interned_strings->get(o) != nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":158,"deletions":458,"binary":false,"changes":616,"status":"modified"},{"patch":"@@ -174,5 +174,0 @@\n-  \/\/ Look for all hidden classes that are referenced by archived objects.\n-  static void start_finding_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n-  static void find_required_hidden_classes_in_object(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void end_finding_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n-\n@@ -263,3 +258,0 @@\n-  class FindRequiredHiddenClassesOopClosure;\n-  static void find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]);\n-\n@@ -347,3 +339,1 @@\n-  static bool archive_object(oop obj);\n-  static void copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m);\n-  static void copy_interned_strings();\n+  static bool archive_object(oop obj, KlassSubGraphInfo* subgraph_info);\n@@ -372,1 +362,0 @@\n-  static void archive_java_mirrors();\n@@ -374,6 +363,1 @@\n-  static void copy_special_subgraph();\n-\n-  class AOTInitializedClassScanner;\n-  static void find_all_aot_initialized_classes();\n-  static void find_all_aot_initialized_classes_helper();\n-  static bool scan_for_aot_initialized_classes(oop obj);\n+  static void archive_subgraphs();\n@@ -396,2 +380,1 @@\n-  static void archive_objects(ArchiveHeapInfo* heap_info);\n-  static void copy_objects();\n+  static void write_heap(ArchiveHeapInfo* heap_info);\n@@ -404,0 +387,1 @@\n+  static bool is_dumped_interned_string(oop o);\n@@ -473,0 +457,7 @@\n+\n+  \/\/ Used by AOTArtifactFinder\n+  static void start_scanning_for_oops();\n+  static void end_scanning_for_oops();\n+  static void scan_java_class(Klass* k);\n+  static void scan_java_mirror(oop orig_mirror);\n+  static void copy_and_rescan_aot_inited_mirror(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -124,1 +125,1 @@\n-\/\/ The heap region is populated by HeapShared::archive_objects.\n+\/\/ The heap region is written by HeapShared::write_heap().\n@@ -546,0 +547,1 @@\n+    AOTArtifactFinder::all_cached_classes_do(it);\n@@ -619,1 +621,9 @@\n-  SystemDictionaryShared::find_all_archivable_classes();\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (HeapShared::can_write() && _extra_interned_strings != nullptr) {\n+    for (int i = 0; i < _extra_interned_strings->length(); i ++) {\n+      OopHandle string = _extra_interned_strings->at(i);\n+      HeapShared::add_to_dumped_interned_strings(string.resolve());\n+    }\n+  }\n+#endif\n@@ -631,3 +641,0 @@\n-  dump_java_heap_objects(_builder.klasses());\n-  dump_shared_symbol_table(_builder.symbols());\n-\n@@ -638,0 +645,3 @@\n+  dump_java_heap_objects(_builder.klasses());\n+  dump_shared_symbol_table(_builder.symbols());\n+\n@@ -1003,1 +1013,1 @@\n-  if(!HeapShared::can_write()) {\n+  if (!HeapShared::can_write()) {\n@@ -1011,19 +1021,1 @@\n-  \/\/ Find all the interned strings that should be dumped.\n-  int i;\n-  for (i = 0; i < klasses->length(); i++) {\n-    Klass* k = klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      ik->constants()->add_dumped_interned_strings();\n-    }\n-  }\n-  if (_extra_interned_strings != nullptr) {\n-    for (i = 0; i < _extra_interned_strings->length(); i ++) {\n-      OopHandle string = _extra_interned_strings->at(i);\n-      HeapShared::add_to_dumped_interned_strings(string.resolve());\n-    }\n-  }\n-\n-  HeapShared::archive_objects(&_heap_info);\n-  ArchiveBuilder::OtherROAllocMark mark;\n-  HeapShared::write_subgraph_info_table();\n+  HeapShared::write_heap(&_heap_info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-template<class E> class GrowableArray;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  static int component_mirror_offset() { return _component_mirror_offset; }\n@@ -328,2 +329,1 @@\n-\n-  static int component_mirror_offset() { return _component_mirror_offset; }\n+  static int reflection_data_offset() { return _reflectionData_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -403,1 +403,6 @@\n-  archived_entry->_archived_module_index = -1;\n+\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    archived_entry->_archived_module_index = HeapShared::append_root(module());\n+  } else {\n+    archived_entry->_archived_module_index = -1;\n+  }\n@@ -412,0 +417,8 @@\n+  assert(archived_entry->shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n+  \/\/ Clear handles and restore at run time. Handles cannot be archived.\n+  OopHandle null_handle;\n+  archived_entry->_module = null_handle;\n+\n+  \/\/ For verify_archived_module_entries()\n+  DEBUG_ONLY(_num_inited_module_entries++);\n+\n@@ -492,16 +505,0 @@\n-void ModuleEntry::update_oops_in_archived_module(int root_oop_index) {\n-  assert(CDSConfig::is_dumping_full_module_graph(), \"sanity\");\n-  assert(_archived_module_index == -1, \"must be set exactly once\");\n-  assert(root_oop_index >= 0, \"sanity\");\n-\n-  _archived_module_index = root_oop_index;\n-\n-  assert(shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n-  \/\/ Clear handles and restore at run time. Handles cannot be archived.\n-  OopHandle null_handle;\n-  _module = null_handle;\n-\n-  \/\/ For verify_archived_module_entries()\n-  DEBUG_ONLY(_num_inited_module_entries++);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -486,3 +486,1 @@\n-\/\/\n-\/\/ Returns true iff the oop has an archived ModuleEntry.\n-bool Modules::check_archived_module_oop(oop orig_module_obj) {\n+void Modules::check_archived_module_oop(oop orig_module_obj) {\n@@ -501,1 +499,0 @@\n-    return false;\n@@ -519,1 +516,0 @@\n-      return true;\n@@ -541,1 +537,0 @@\n-      return false;\n@@ -546,13 +541,0 @@\n-void Modules::update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index) {\n-  \/\/ This java.lang.Module oop must have an archived ModuleEntry\n-  assert(check_archived_module_oop(orig_module_obj) == true, \"sanity\");\n-\n-  \/\/ We remember the oop inside the ModuleEntry::_archived_module_index. At runtime, we use\n-  \/\/ this index to reinitialize the ModuleEntry inside ModuleEntry::restore_archived_oops().\n-  \/\/\n-  \/\/ ModuleEntry::verify_archived_module_entries(), called below, ensures that every archived\n-  \/\/ ModuleEntry has been assigned an _archived_module_index.\n-  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n-  ModuleEntry::get_archived_entry(orig_module_ent)->update_oops_in_archived_module(archived_module_root_index);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,1 @@\n-  static bool check_archived_module_oop(oop orig_module_obj) NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  static void update_oops_in_archived_module(oop orig_module_obj, int archived_module_root_index)\n-                                             NOT_CDS_JAVA_HEAP_RETURN;\n+  static void check_archived_module_oop(oop orig_module_obj) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-oop StringTable::init_shared_table(const DumpedInternedStrings* dumped_interned_strings) {\n+oop StringTable::init_shared_strings_array(const DumpedInternedStrings* dumped_interned_strings) {\n@@ -1021,3 +1021,0 @@\n-  _shared_table.reset();\n-  CompactHashtableWriter writer((int)_items_count, ArchiveBuilder::string_stats());\n-\n@@ -1026,3 +1023,0 @@\n-    unsigned int hash = java_lang_String::hash_code(string);\n-    writer.add(hash, index);\n-\n@@ -1048,2 +1042,0 @@\n-  writer.dump(&_shared_table, \"string\");\n-\n@@ -1053,0 +1045,15 @@\n+void StringTable::write_shared_table(const DumpedInternedStrings* dumped_interned_strings) {\n+  _shared_table.reset();\n+  CompactHashtableWriter writer((int)_items_count, ArchiveBuilder::string_stats());\n+\n+  int index = 0;\n+  auto copy_into_shared_table = [&] (oop string, bool value_ignored) {\n+    unsigned int hash = java_lang_String::hash_code(string);\n+    writer.add(hash, index);\n+    index ++;\n+  };\n+  dumped_interned_strings->iterate_all(copy_into_shared_table);\n+\n+  writer.dump(&_shared_table, \"string\");\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-  static oop init_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop init_shared_strings_array(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static void write_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,9 +208,0 @@\n-void SystemDictionaryShared::mark_required_hidden_class(InstanceKlass* k) {\n-  assert(k->is_hidden(), \"sanity\");\n-  DumpTimeClassInfo* info = _dumptime_table->get(k);\n-  ResourceMark rm;\n-  if (info != nullptr) {\n-    info->set_is_required_hidden_class();\n-  }\n-}\n-\n@@ -259,1 +250,5 @@\n-  return (info != nullptr) ? info->_is_archived_lambda_proxy : false;\n+  bool result = (info != nullptr) ? info->_is_registered_lambda_proxy : false;\n+  if (result) {\n+    assert(!CDSConfig::is_dumping_invokedynamic(), \"only used in legacy lambda proxy support\");\n+  }\n+  return result;\n@@ -265,1 +260,1 @@\n-    info->_is_archived_lambda_proxy = false;\n+    info->_is_registered_lambda_proxy = false;\n@@ -343,5 +338,0 @@\n-  if (k->is_hidden() && !should_hidden_class_be_archived(k)) {\n-    log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n-    return true;\n-  }\n-\n@@ -604,3 +594,1 @@\n-      if (CDSConfig::is_dumping_invokedynamic()) {\n-        assert(should_hidden_class_be_archived(k), \"unexpected hidden class %s\", name);\n-      } else {\n+      if (!CDSConfig::is_dumping_invokedynamic()) {\n@@ -660,23 +648,0 @@\n-void SystemDictionaryShared::scan_constant_pool(InstanceKlass* k) {\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n-    k->constants()->find_required_hidden_classes();\n-  }\n-}\n-\n-bool SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass* k) {\n-  assert(k->is_hidden(), \"sanity\");\n-  if (is_registered_lambda_proxy_class(k)) {\n-    return true;\n-  }\n-\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n-    DumpTimeClassInfo* info = _dumptime_table->get(k);\n-    if (info != nullptr && info->is_required_hidden_class()) {\n-      guarantee(HeapShared::is_archivable_hidden_klass(k), \"required hidden class must be archivable\");\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-}\n-\n@@ -732,18 +697,1 @@\n-void SystemDictionaryShared::find_all_archivable_classes() {\n-  HeapShared::start_finding_required_hidden_classes();\n-  find_all_archivable_classes_impl();\n-  HeapShared::end_finding_required_hidden_classes();\n-}\n-\n-\/\/ Iterate over all the classes in _dumptime_table, marking the ones that must be\n-\/\/ excluded from the archive. Those that are not excluded will be archivable.\n-\/\/\n-\/\/ (a) Non-hidden classes are easy. They are only check by the rules in\n-\/\/     SystemDictionaryShared::check_for_exclusion().\n-\/\/ (b) For hidden classes, we only archive those that are required (i.e., they are\n-\/\/     referenced by Java objects (such as CallSites) that are reachable from\n-\/\/     ConstantPools). This needs help from HeapShared.\n-void SystemDictionaryShared::find_all_archivable_classes_impl() {\n-  assert(!class_loading_may_happen(), \"class loading must be disabled\");\n-  assert_lock_strong(DumpTimeTable_lock);\n-\n+void SystemDictionaryShared::finish_exclusion_checks() {\n@@ -759,1 +707,3 @@\n-  ResourceMark rm;\n+  _dumptime_table->iterate_all_live_classes([&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    SystemDictionaryShared::check_for_exclusion(k, &info);\n+  });\n@@ -761,48 +711,0 @@\n-  \/\/ First, scan all non-hidden classes\n-  auto check_non_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-    if (!k->is_hidden()) {\n-      SystemDictionaryShared::check_for_exclusion(k, &info);\n-      if (!info.is_excluded() && !info.has_scanned_constant_pool()) {\n-        scan_constant_pool(k);\n-        info.set_has_scanned_constant_pool();\n-      }\n-    }\n-  };\n-  _dumptime_table->iterate_all_live_classes(check_non_hidden);\n-\n-  \/\/ Then, scan all the hidden classes that have been marked as required to\n-  \/\/ discover more hidden classes. Stop when we cannot make progress anymore.\n-  bool made_progress;\n-  do {\n-    made_progress = false;\n-    auto check_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-      if (k->is_hidden() && should_hidden_class_be_archived(k)) {\n-        SystemDictionaryShared::check_for_exclusion(k, &info);\n-        if (info.is_excluded()) {\n-          guarantee(!info.is_required_hidden_class(), \"A required hidden class cannot be marked as excluded\");\n-        } else if (!info.has_scanned_constant_pool()) {\n-          scan_constant_pool(k);\n-          info.set_has_scanned_constant_pool();\n-          \/\/ The CP entries in k *MAY* refer to other hidden classes, so scan\n-          \/\/ every hidden class again.\n-          made_progress = true;\n-        }\n-      }\n-    };\n-    _dumptime_table->iterate_all_live_classes(check_hidden);\n-  } while (made_progress);\n-\n-  \/\/ Now, all hidden classes that have not yet been scanned must be marked as excluded\n-  auto exclude_remaining_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-    if (k->is_hidden()) {\n-      SystemDictionaryShared::check_for_exclusion(k, &info);\n-      if (CDSConfig::is_dumping_invokedynamic()) {\n-        if (should_hidden_class_be_archived(k)) {\n-          guarantee(!info.is_excluded(), \"Must be\");\n-        } else {\n-          guarantee(info.is_excluded(), \"Must be\");\n-        }\n-      }\n-    }\n-  };\n-  _dumptime_table->iterate_all_live_classes(exclude_remaining_hidden);\n@@ -810,1 +712,0 @@\n-\n@@ -939,3 +840,3 @@\n-    \/\/ Set _is_archived_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n-    \/\/ won't be excluded during dumping of shared archive. See ExcludeDumpTimeSharedClasses.\n-    info->_is_archived_lambda_proxy = true;\n+    \/\/ Set _is_registered_lambda_proxy in DumpTimeClassInfo so that the lambda_ik\n+    \/\/ won't be excluded during dumping of shared archive.\n+    info->_is_registered_lambda_proxy = true;\n@@ -1344,7 +1245,0 @@\n-    \/\/\n-    \/\/ The following check has been moved to SystemDictionaryShared::find_all_archivable_classes(), which\n-    \/\/ happens before the classes are copied.\n-    \/\/\n-    \/\/ if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses->at(0))) {\n-    \/\/  return true;\n-    \/\/}\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":14,"deletions":120,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-  friend class ExcludeDumpTimeSharedClasses;\n@@ -191,1 +190,0 @@\n-  static void find_all_archivable_classes_impl();\n@@ -198,1 +196,0 @@\n-  static bool is_registered_lambda_proxy_class(InstanceKlass* ik);\n@@ -203,1 +200,0 @@\n-  static void scan_constant_pool(InstanceKlass* k);\n@@ -207,2 +203,1 @@\n-  static bool should_hidden_class_be_archived(InstanceKlass* k);\n-  static void mark_required_hidden_class(InstanceKlass* k);\n+  static bool is_registered_lambda_proxy_class(InstanceKlass* ik);\n@@ -294,1 +289,3 @@\n-  static void find_all_archivable_classes();\n+  static void finish_exclusion_checks();\n+  static DumpTimeSharedClassTable* dumptime_table() { return _dumptime_table; }\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -335,2 +335,1 @@\n-  if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||\n-        ik->is_shared_app_class())) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n@@ -348,2 +347,1 @@\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+    iterate_archivable_resolved_references([&](int rr_index) {\n@@ -353,1 +351,1 @@\n-    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(src_cp);\n+    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(this);\n@@ -381,26 +379,0 @@\n-void ConstantPool::find_required_hidden_classes() {\n-  if (_cache == nullptr) {\n-    return;\n-  }\n-\n-  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-  if (loader_data == nullptr) {\n-    \/\/ These are custom loader classes from the preimage\n-    return;\n-  }\n-\n-  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n-    \/\/ Archiving resolved references for classes from non-builtin loaders\n-    \/\/ is not yet supported.\n-    return;\n-  }\n-\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    iterate_archivable_resolved_references([&](int rr_index) {\n-      oop obj = rr->obj_at(rr_index);\n-      HeapShared::find_required_hidden_classes_in_object(obj);\n-    });\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -687,1 +687,0 @@\n-  void find_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -412,0 +412,11 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  _archived_references_index = -1;\n+  if (CDSConfig::is_dumping_heap()) {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+    oop rr = HeapShared::scratch_resolved_references(src_cp);\n+    if (rr != nullptr) {\n+      _archived_references_index = HeapShared::append_root(rr);\n+    }\n+  }\n+#endif\n@@ -613,5 +624,0 @@\n-\n-void ConstantPoolCache::set_archived_references(int root_index) {\n-  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n-  _archived_references_index = root_index;\n-}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-  void set_archived_references(int root_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -820,0 +820,13 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  _archived_mirror_index = -1;\n+  if (CDSConfig::is_dumping_heap()) {\n+    Klass* src_k = ArchiveBuilder::current()->get_source_addr(this);\n+    oop orig_mirror = src_k->java_mirror();\n+    oop scratch_mirror = HeapShared::scratch_java_mirror(orig_mirror);\n+    if (scratch_mirror != nullptr) {\n+      _archived_mirror_index = HeapShared::append_root(scratch_mirror);\n+    }\n+  }\n+#endif\n+\n@@ -903,6 +916,0 @@\n-\n-\/\/ No GC barrier\n-void Klass::set_archived_java_mirror(int mirror_index) {\n-  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n-  _archived_mirror_index = mirror_index;\n-}\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -284,1 +284,0 @@\n-  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}