{"files":[{"patch":"@@ -206,1 +206,1 @@\n-        return method0(\"POST\", requireNonNull(body));\n+        return method0(\"POST\", requireNonNull(body, \"BodyPublisher must be non-null\"));\n@@ -221,1 +221,1 @@\n-        return method0(\"PUT\", requireNonNull(body));\n+        return method0(\"PUT\", requireNonNull(body, \"BodyPublisher must be non-null\"));\n@@ -226,1 +226,1 @@\n-        requireNonNull(method);\n+        requireNonNull(method, \"HTTP method must be non-null\");\n@@ -237,1 +237,1 @@\n-        return method0(method, requireNonNull(body));\n+        return method0(method, requireNonNull(body, \"BodyPublisher must be non-null\"));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestBuilderImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,431 +58,467 @@\n-    static final URI uri = URI.create(\"http:\/\/foo.com\/\");\n-    static final Class<NullPointerException> NPE = NullPointerException.class;\n-    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n-    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n-    static final Class<NumberFormatException> NFE = NumberFormatException.class;\n-    static final Class<UnsupportedOperationException> UOE = UnsupportedOperationException.class;\n-\n-    @Test\n-    public void testDefaults() {\n-        List<HttpRequest.Builder> builders = List.of(newBuilder().uri(uri),\n-                                                     newBuilder(uri),\n-                                                     newBuilder().copy().uri(uri),\n-                                                     newBuilder(uri).copy());\n-        for (HttpRequest.Builder builder : builders) {\n-            assertFalse(builder.build().expectContinue());\n-            assertEquals(builder.build().method(), \"GET\");\n-            assertFalse(builder.build().bodyPublisher().isPresent());\n-            assertFalse(builder.build().version().isPresent());\n-            assertFalse(builder.build().timeout().isPresent());\n-            assertTrue(builder.build().headers() != null);\n-            assertEquals(builder.build().headers().map().size(), 0);\n-        }\n-    }\n-\n-    @Test\n-    public void testNull() {\n-        HttpRequest.Builder builder = newBuilder();\n-\n-        assertThrows(NPE, () -> newBuilder(null).build());\n-        assertThrows(NPE, () -> newBuilder(uri).uri(null).build());\n-        assertThrows(NPE, () -> builder.uri(null));\n-        assertThrows(NPE, () -> builder.version(null));\n-        assertThrows(NPE, () -> builder.header(null, null));\n-        assertThrows(NPE, () -> builder.header(\"name\", null));\n-        assertThrows(NPE, () -> builder.header(null, \"value\"));\n-        assertThrows(NPE, () -> builder.headers(null));\n-        assertThrows(NPE, () -> builder.headers(new String[] { null, null }));\n-        assertThrows(NPE, () -> builder.headers(new String[] { \"name\", null }));\n-        assertThrows(NPE, () -> builder.headers(new String[] { null, \"value\" }));\n-        assertThrows(NPE, () -> builder.method(null, null));\n-        assertThrows(NPE, () -> builder.method(\"GET\", null));\n-        assertThrows(NPE, () -> builder.method(\"POST\", null));\n-        assertThrows(NPE, () -> builder.method(\"PUT\", null));\n-        assertThrows(NPE, () -> builder.method(\"DELETE\", null));\n-        assertThrows(NPE, () -> builder.setHeader(null, null));\n-        assertThrows(NPE, () -> builder.setHeader(\"name\", null));\n-        assertThrows(NPE, () -> builder.setHeader(null, \"value\"));\n-        assertThrows(NPE, () -> builder.setOption(null, null));\n-        assertThrows(NPE, () -> builder.setOption((HttpOption<Http3DiscoveryMode>) null, ANY));\n-        assertThrows(NPE, () -> builder.timeout(null));\n-        assertThrows(NPE, () -> builder.POST(null));\n-        assertThrows(NPE, () -> builder.PUT(null));\n-    }\n-\n-    @Test\n-    public void testURI() {\n-        assertThrows(ISE, () -> newBuilder().build());\n-        List<URI> uris = List.of(\n-                URI.create(\"ws:\/\/foo.com\"),\n-                URI.create(\"wss:\/\/foo.com\"),\n-                URI.create(\"ftp:\/\/foo.com\"),\n-                URI.create(\"mailto:a@b.com\"),\n-                URI.create(\"scheme:example.com\"),\n-                URI.create(\"scheme:example.com\"),\n-                URI.create(\"scheme:example.com\/path\"),\n-                URI.create(\"path\"),\n-                URI.create(\"\/path\")\n-        );\n-        for (URI u : uris) {\n-            assertThrows(IAE, () -> newBuilder(u));\n-            assertThrows(IAE, () -> newBuilder().uri(u));\n-        }\n-\n-        assertEquals(newBuilder(uri).build().uri(), uri);\n-        assertEquals(newBuilder().uri(uri).build().uri(), uri);\n-        URI https = URI.create(\"https:\/\/foo.com\");\n-        assertEquals(newBuilder(https).build().uri(), https);\n-        assertEquals(newBuilder().uri(https).build().uri(), https);\n-    }\n-\n-    @Test\n-    public void testMethod() {\n-        HttpRequest request = newBuilder(uri).build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).GET().build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).POST(BodyPublishers.ofString(\"\")).GET().build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).PUT(BodyPublishers.ofString(\"\")).GET().build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).DELETE().GET().build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).POST(BodyPublishers.ofString(\"\")).build();\n-        assertEquals(request.method(), \"POST\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).PUT(BodyPublishers.ofString(\"\")).build();\n-        assertEquals(request.method(), \"PUT\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).DELETE().build();\n-        assertEquals(request.method(), \"DELETE\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).HEAD().build();\n-        assertEquals(request.method(), \"HEAD\");\n-        assertFalse(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).GET().POST(BodyPublishers.ofString(\"\")).build();\n-        assertEquals(request.method(), \"POST\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).GET().PUT(BodyPublishers.ofString(\"\")).build();\n-        assertEquals(request.method(), \"PUT\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).GET().DELETE().build();\n-        assertEquals(request.method(), \"DELETE\");\n-        assertTrue(!request.bodyPublisher().isPresent());\n-\n-        \/\/ CONNECT is disallowed in the implementation, since it is used for\n-        \/\/ tunneling, and is handled separately for security checks.\n-        assertThrows(IAE, () -> newBuilder(uri).method(\"CONNECT\", BodyPublishers.noBody()).build());\n-\n-        request = newBuilder(uri).method(\"GET\", BodyPublishers.noBody()).build();\n-        assertEquals(request.method(), \"GET\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-\n-        request = newBuilder(uri).method(\"POST\", BodyPublishers.ofString(\"\")).build();\n-        assertEquals(request.method(), \"POST\");\n-        assertTrue(request.bodyPublisher().isPresent());\n-    }\n-\n-    @Test\n-    public void testHeaders() {\n-        HttpRequest.Builder builder = newBuilder(uri);\n-\n-        String[] empty = new String[0];\n-        assertThrows(IAE, () -> builder.headers(empty).build());\n-        assertThrows(IAE, () -> builder.headers(\"1\").build());\n-        assertThrows(IAE, () -> builder.headers(\"1\", \"2\", \"3\").build());\n-        assertThrows(IAE, () -> builder.headers(\"1\", \"2\", \"3\", \"4\", \"5\").build());\n-        assertEquals(builder.build().headers().map().size(),0);\n-\n-        List<HttpRequest> requests = List.of(\n-                \/\/ same header built from different combinations of the API\n-                newBuilder(uri).header(\"A\", \"B\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\").build(),\n-                newBuilder(uri).header(\"A\", \"F\").setHeader(\"A\", \"B\").build(),\n-                newBuilder(uri).headers(\"A\", \"F\").setHeader(\"A\", \"B\").build()\n-        );\n-\n-        for (HttpRequest r : requests) {\n-            assertEquals(r.headers().map().size(), 1);\n-            assertTrue(r.headers().firstValue(\"A\").isPresent());\n-            assertTrue(r.headers().firstValue(\"a\").isPresent());\n-            assertEquals(r.headers().firstValue(\"A\").get(), \"B\");\n-            assertEquals(r.headers().allValues(\"A\"), List.of(\"B\"));\n-            assertEquals(r.headers().allValues(\"C\").size(), 0);\n-            assertEquals(r.headers().map().get(\"A\"), List.of(\"B\"));\n-            assertThrows(NFE, () -> r.headers().firstValueAsLong(\"A\"));\n-            assertFalse(r.headers().firstValue(\"C\").isPresent());\n-            \/\/ a non-exhaustive list of mutators\n-            assertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n-            assertThrows(UOE, () -> r.headers().map().remove(\"A\"));\n-            assertThrows(UOE, () -> r.headers().map().remove(\"A\", \"B\"));\n-            assertThrows(UOE, () -> r.headers().map().clear());\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").remove(1));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").add(\"Z\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").addAll(List.of(\"Z\")));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").add(1, \"Z\"));\n-        }\n-\n-        requests = List.of(\n-                \/\/ same headers built from different combinations of the API\n-                newBuilder(uri).header(\"A\", \"B\")\n-                               .header(\"C\", \"D\").build(),\n-                newBuilder(uri).header(\"A\", \"B\")\n-                               .headers(\"C\", \"D\").build(),\n-                newBuilder(uri).header(\"A\", \"B\")\n-                               .setHeader(\"C\", \"D\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\")\n-                               .headers(\"C\", \"D\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\")\n-                               .header(\"C\", \"D\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\")\n-                               .setHeader(\"C\", \"D\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\")\n-                               .setHeader(\"C\", \"D\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\")\n-                               .header(\"C\", \"D\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\")\n-                               .headers(\"C\", \"D\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\", \"C\", \"D\").build()\n-        );\n-\n-        for (HttpRequest r : requests) {\n-            assertEquals(r.headers().map().size(), 2);\n-            assertTrue(r.headers().firstValue(\"A\").isPresent());\n-            assertEquals(r.headers().firstValue(\"A\").get(), \"B\");\n-            assertEquals(r.headers().allValues(\"A\"), List.of(\"B\"));\n-            assertTrue(r.headers().firstValue(\"C\").isPresent());\n-            assertEquals(r.headers().firstValue(\"C\").get(), \"D\");\n-            assertEquals(r.headers().allValues(\"C\"), List.of(\"D\"));\n-            assertEquals(r.headers().map().get(\"C\"), List.of(\"D\"));\n-            assertThrows(NFE, () -> r.headers().firstValueAsLong(\"C\"));\n-            assertFalse(r.headers().firstValue(\"E\").isPresent());\n-            \/\/ a smaller non-exhaustive list of mutators\n-            assertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n-            assertThrows(UOE, () -> r.headers().map().remove(\"C\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n-            assertThrows(UOE, () -> r.headers().allValues(\"C\").add(\"Z\"));\n-        }\n-\n-        requests = List.of(\n-                \/\/ same multi-value headers built from different combinations of the API\n-                newBuilder(uri).header(\"A\", \"B\")\n-                               .header(\"A\", \"C\").build(),\n-                newBuilder(uri).header(\"A\", \"B\")\n-                               .headers(\"A\", \"C\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\")\n-                               .headers(\"A\", \"C\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\")\n-                               .header(\"A\", \"C\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\")\n-                               .header(\"A\", \"C\").build(),\n-                newBuilder(uri).setHeader(\"A\", \"B\")\n-                               .headers(\"A\", \"C\").build(),\n-                newBuilder(uri).header(\"A\", \"D\")\n-                               .setHeader(\"A\", \"B\")\n-                               .headers(\"A\", \"C\").build(),\n-                newBuilder(uri).headers(\"A\", \"B\", \"A\", \"C\").build()\n-        );\n-\n-        for (HttpRequest r : requests) {\n-            assertEquals(r.headers().map().size(), 1);\n-            assertTrue(r.headers().firstValue(\"A\").isPresent());\n-            assertTrue(r.headers().allValues(\"A\").containsAll(List.of(\"B\", \"C\")));\n-            assertEquals(r.headers().allValues(\"C\").size(), 0);\n-            assertEquals(r.headers().map().get(\"A\"), List.of(\"B\", \"C\"));\n-            assertThrows(NFE, () -> r.headers().firstValueAsLong(\"A\"));\n-            assertFalse(r.headers().firstValue(\"C\").isPresent());\n-            \/\/ a non-exhaustive list of mutators\n-            assertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n-            assertThrows(UOE, () -> r.headers().map().remove(\"A\"));\n-            assertThrows(UOE, () -> r.headers().map().remove(\"A\", \"B\"));\n-            assertThrows(UOE, () -> r.headers().map().clear());\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").remove(1));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").add(\"Z\"));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").addAll(List.of(\"Z\")));\n-            assertThrows(UOE, () -> r.headers().allValues(\"A\").add(1, \"Z\"));\n-        }\n-\n-        \/\/ case-insensitivity\n-        requests = List.of(\n-                newBuilder(uri)\n-                        .header(\"Accept-Encoding\", \"gzip, deflate\").build(),\n-                newBuilder(uri)\n-                        .header(\"accept-encoding\", \"gzip, deflate\").build(),\n-                newBuilder(uri)\n-                        .header(\"AccePt-EncodINg\", \"gzip, deflate\").build(),\n-                newBuilder(uri)\n-                        .header(\"AcCEpt-EncoDIng\", \"gzip, deflate\").build()\n-        );\n-        for (HttpRequest r : requests) {\n-            for (String name : List.of(\"Accept-Encoding\", \"accept-encoding\",\n-                                       \"aCCept-EnCODing\", \"accepT-encodinG\")) {\n-                assertTrue(r.headers().firstValue(name).isPresent());\n-                assertTrue(r.headers().allValues(name).contains(\"gzip, deflate\"));\n-                assertEquals(r.headers().firstValue(name).get(), \"gzip, deflate\");\n-                assertEquals(r.headers().allValues(name).size(), 1);\n-                assertEquals(r.headers().map().size(), 1);\n-                assertEquals(r.headers().map().get(name).size(), 1);\n-                assertEquals(r.headers().map().get(name).get(0), \"gzip, deflate\");\n-            }\n-        }\n-    }\n-\n-    \/\/ headers that are allowed now, but weren't before\n-    private static final Set<String> FORMERLY_RESTRICTED = Set.of(\"referer\", \"origin\",\n-            \"OriGin\", \"Referer\", \"Date\", \"via\", \"WarnIng\");\n-\n-    @Test\n-    public void testFormerlyRestricted()  throws URISyntaxException {\n-        URI uri = new URI(\"http:\/\/localhost:80\/test\/\");\n-        URI otherURI = new URI(\"http:\/\/www.foo.com\/test\/\");\n-        for (String header : FORMERLY_RESTRICTED) {\n-            HttpRequest req = HttpRequest.newBuilder(uri)\n-                .header(header, otherURI.toString())\n-                .GET()\n-                .build();\n-        }\n-    }\n-\n-    private static final Set<String> RESTRICTED = Set.of(\"connection\", \"content-length\",\n-            \"expect\", \"host\", \"upgrade\", \"Connection\", \"Content-Length\",\n-            \"eXpect\", \"hosT\", \"upgradE\", \"CONNection\", \"CONTENT-LENGTH\",\n-            \"EXPECT\", \"Host\", \"Upgrade\");\n-\n-    interface WithHeader {\n-        HttpRequest.Builder withHeader(HttpRequest.Builder builder, String name, String value);\n-    }\n-\n-    @Test\n-    public void testRestricted()  throws URISyntaxException {\n-        URI uri = new URI(\"http:\/\/localhost:80\/test\/\");\n-        Map<String, WithHeader> lambdas = Map.of(\n-                \"Builder::header\",    HttpRequest.Builder::header,\n-                \"Builder::headers\",   (b, n, v) -> b.headers(n,v),\n-                \"Builder::setHeader\", HttpRequest.Builder::setHeader\n-                );\n-        for (Map.Entry<String, WithHeader> e : lambdas.entrySet()) {\n-            System.out.println(\"Testing restricted headers with \" + e.getKey());\n-            WithHeader f = e.getValue();\n-            for (String name : RESTRICTED) {\n-                String value = name + \"-value\";\n-                HttpRequest req = f.withHeader(HttpRequest.newBuilder(uri)\n-                        .GET(), \"x-\" + name, value).build();\n-                String v = req.headers().firstValue(\"x-\" + name).orElseThrow(\n-                        () -> new RuntimeException(\"header x-\" + name + \" not set\"));\n-                assertEquals(v, value);\n-                try {\n-                    f.withHeader(HttpRequest.newBuilder(uri)\n-                            .GET(), name, value).build();\n-                    throw new RuntimeException(\"Expected IAE not thrown for \" + name);\n-                } catch (IllegalArgumentException x) {\n-                    System.out.println(\"Got expected IAE for \" + name + \": \" + x);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    @Test\n-    public void testCopy() {\n-        HttpRequest.Builder builder = newBuilder(uri).expectContinue(true)\n-                                                     .header(\"A\", \"B\")\n-                                                     .POST(BodyPublishers.ofString(\"\"))\n-                                                     .timeout(ofSeconds(30))\n-                                                     .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY)\n-                                                     .version(HTTP_1_1);\n-        HttpRequest.Builder copy = builder.copy();\n-        assertTrue(builder != copy);\n-\n-        \/\/ modify the original builder before building from the copy\n-        builder.GET().timeout(ofSeconds(5)).version(HTTP_2).setHeader(\"A\", \"C\");\n-\n-        HttpRequest copyRequest = copy.build();\n-        assertEquals(copyRequest.uri(), uri);\n-        assertEquals(copyRequest.expectContinue(), true);\n-        assertEquals(copyRequest.headers().map().get(\"A\"), List.of(\"B\"));\n-        assertEquals(copyRequest.method(), \"POST\");\n-        assertEquals(copyRequest.bodyPublisher().isPresent(), true);\n-        assertEquals(copyRequest.timeout().get(), ofSeconds(30));\n-        assertTrue(copyRequest.version().isPresent());\n-        assertEquals(copyRequest.version().get(), HTTP_1_1);\n-        assertTrue(copyRequest.getOption(H3_DISCOVERY).isPresent());\n-        assertEquals(copyRequest.getOption(H3_DISCOVERY).get(), HTTP_3_URI_ONLY);\n-\n-        \/\/ lazy set URI ( maybe builder as a template )\n-        copyRequest = newBuilder().copy().uri(uri).build();\n-        assertEquals(copyRequest.uri(), uri);\n-\n-        builder = newBuilder().header(\"C\", \"D\");\n-        copy = builder.copy();\n-        copy.uri(uri);\n-        copyRequest = copy.build();\n-        assertEquals(copyRequest.uri(), uri);\n-        assertEquals(copyRequest.headers().firstValue(\"C\").get(), \"D\");\n-    }\n-\n-    @Test\n-    public void testTimeout() {\n-        HttpRequest.Builder builder = newBuilder(uri);\n-        assertThrows(IAE, () -> builder.timeout(ZERO));\n-        assertThrows(IAE, () -> builder.timeout(ofSeconds(0)));\n-        assertThrows(IAE, () -> builder.timeout(ofSeconds(-1)));\n-        assertThrows(IAE, () -> builder.timeout(ofNanos(-100)));\n-        assertEquals(builder.timeout(ofNanos(15)).build().timeout().get(), ofNanos(15));\n-        assertEquals(builder.timeout(ofSeconds(50)).build().timeout().get(), ofSeconds(50));\n-        assertEquals(builder.timeout(ofMinutes(30)).build().timeout().get(), ofMinutes(30));\n-    }\n-\n-    @Test\n-    public void testExpect() {\n-        HttpRequest.Builder builder = newBuilder(uri);\n-        assertEquals(builder.build().expectContinue(), false);\n-        assertEquals(builder.expectContinue(true).build().expectContinue(), true);\n-        assertEquals(builder.expectContinue(false).build().expectContinue(), false);\n-        assertEquals(builder.expectContinue(true).build().expectContinue(), true);\n-    }\n-\n-    @Test\n-    public void testEquals() {\n-        assertNotEquals(newBuilder(URI.create(\"http:\/\/foo.com\")),\n-                        newBuilder(URI.create(\"http:\/\/bar.com\")));\n-\n-        HttpRequest.Builder builder = newBuilder(uri);\n-        assertEquals(builder.build(), builder.build());\n-        assertEquals(builder.build(), newBuilder(uri).build());\n-\n-        builder.POST(BodyPublishers.noBody());\n-        assertEquals(builder.build(), builder.build());\n-        assertEquals(builder.build(), newBuilder(uri).POST(BodyPublishers.noBody()).build());\n-        assertEquals(builder.build(), newBuilder(uri).POST(BodyPublishers.ofString(\"\")).build());\n-        assertNotEquals(builder.build(), newBuilder(uri).build());\n-        assertNotEquals(builder.build(), newBuilder(uri).GET().build());\n-        assertNotEquals(builder.build(), newBuilder(uri).PUT(BodyPublishers.noBody()).build());\n-\n-        builder = newBuilder(uri).header(\"x\", \"y\");\n-        assertEquals(builder.build(), builder.build());\n-        assertEquals(builder.build(), newBuilder(uri).header(\"x\", \"y\").build());\n-        assertNotEquals(builder.build(), newBuilder(uri).header(\"x\", \"Z\").build());\n-        assertNotEquals(builder.build(), newBuilder(uri).header(\"z\", \"y\").build());\n-    }\n+\tstatic final URI uri = URI.create(\"http:\/\/foo.com\/\");\n+\tstatic final Class<NullPointerException> NPE = NullPointerException.class;\n+\tstatic final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+\tstatic final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\tstatic final Class<NumberFormatException> NFE = NumberFormatException.class;\n+\tstatic final Class<UnsupportedOperationException> UOE = UnsupportedOperationException.class;\n+\n+\t@Test\n+\tpublic void testDefaults() {\n+\t\tList<HttpRequest.Builder> builders = List.of(newBuilder().uri(uri),\n+\t\t\tnewBuilder(uri),\n+\t\t\tnewBuilder().copy().uri(uri),\n+\t\t\tnewBuilder(uri).copy());\n+\t\tfor (HttpRequest.Builder builder : builders) {\n+\t\t\tassertFalse(builder.build().expectContinue());\n+\t\t\tassertEquals(builder.build().method(), \"GET\");\n+\t\t\tassertFalse(builder.build().bodyPublisher().isPresent());\n+\t\t\tassertFalse(builder.build().version().isPresent());\n+\t\t\tassertFalse(builder.build().timeout().isPresent());\n+\t\t\tassertTrue(builder.build().headers() != null);\n+\t\t\tassertEquals(builder.build().headers().map().size(), 0);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNull() {\n+\t\tHttpRequest.Builder builder = newBuilder();\n+\n+\t\tassertThrows(NPE, () -> newBuilder(null).build());\n+\t\tassertThrows(NPE, () -> newBuilder(uri).uri(null).build());\n+\t\tassertThrows(NPE, () -> builder.uri(null));\n+\t\tassertThrows(NPE, () -> builder.version(null));\n+\t\tassertThrows(NPE, () -> builder.header(null, null));\n+\t\tassertThrows(NPE, () -> builder.header(\"name\", null));\n+\t\tassertThrows(NPE, () -> builder.header(null, \"value\"));\n+\t\tassertThrows(NPE, () -> builder.headers(null));\n+\t\tassertThrows(NPE, () -> builder.headers(new String[] {null, null}));\n+\t\tassertThrows(NPE, () -> builder.headers(new String[] {\"name\", null}));\n+\t\tassertThrows(NPE, () -> builder.headers(new String[] {null, \"value\"}));\n+\t\tassertThrows(NPE, () -> builder.method(null, null));\n+\t\tassertThrows(NPE, () -> builder.method(\"GET\", null));\n+\t\tassertThrows(NPE, () -> builder.method(\"POST\", null));\n+\t\tassertThrows(NPE, () -> builder.method(\"PUT\", null));\n+\t\tassertThrows(NPE, () -> builder.method(\"DELETE\", null));\n+\t\tassertThrows(NPE, () -> builder.setHeader(null, null));\n+\t\tassertThrows(NPE, () -> builder.setHeader(\"name\", null));\n+\t\tassertThrows(NPE, () -> builder.setHeader(null, \"value\"));\n+\t\tassertThrows(NPE, () -> builder.setOption(null, null));\n+\t\tassertThrows(NPE, () -> builder.setOption((HttpOption<Http3DiscoveryMode>)null, ANY));\n+\t\tassertThrows(NPE, () -> builder.timeout(null));\n+\t\tassertThrows(NPE, () -> builder.POST(null));\n+\t\tassertThrows(NPE, () -> builder.PUT(null));\n+\t}\n+\n+\t@Test\n+\tpublic void testURI() {\n+\t\tassertThrows(ISE, () -> newBuilder().build());\n+\t\tList<URI> uris = List.of(\n+\t\t\tURI.create(\"ws:\/\/foo.com\"),\n+\t\t\tURI.create(\"wss:\/\/foo.com\"),\n+\t\t\tURI.create(\"ftp:\/\/foo.com\"),\n+\t\t\tURI.create(\"mailto:a@b.com\"),\n+\t\t\tURI.create(\"scheme:example.com\"),\n+\t\t\tURI.create(\"scheme:example.com\"),\n+\t\t\tURI.create(\"scheme:example.com\/path\"),\n+\t\t\tURI.create(\"path\"),\n+\t\t\tURI.create(\"\/path\")\n+\t\t);\n+\t\tfor (URI u : uris) {\n+\t\t\tassertThrows(IAE, () -> newBuilder(u));\n+\t\t\tassertThrows(IAE, () -> newBuilder().uri(u));\n+\t\t}\n+\n+\t\tassertEquals(newBuilder(uri).build().uri(), uri);\n+\t\tassertEquals(newBuilder().uri(uri).build().uri(), uri);\n+\t\tURI https = URI.create(\"https:\/\/foo.com\");\n+\t\tassertEquals(newBuilder(https).build().uri(), https);\n+\t\tassertEquals(newBuilder().uri(https).build().uri(), https);\n+\t}\n+\n+\t@Test\n+\tpublic void testMethod() {\n+\t\tHttpRequest request = newBuilder(uri).build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).GET().build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).POST(BodyPublishers.ofString(\"\")).GET().build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).PUT(BodyPublishers.ofString(\"\")).GET().build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).DELETE().GET().build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).POST(BodyPublishers.ofString(\"\")).build();\n+\t\tassertEquals(request.method(), \"POST\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).PUT(BodyPublishers.ofString(\"\")).build();\n+\t\tassertEquals(request.method(), \"PUT\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).DELETE().build();\n+\t\tassertEquals(request.method(), \"DELETE\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).HEAD().build();\n+\t\tassertEquals(request.method(), \"HEAD\");\n+\t\tassertFalse(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).GET().POST(BodyPublishers.ofString(\"\")).build();\n+\t\tassertEquals(request.method(), \"POST\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).GET().PUT(BodyPublishers.ofString(\"\")).build();\n+\t\tassertEquals(request.method(), \"PUT\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).GET().DELETE().build();\n+\t\tassertEquals(request.method(), \"DELETE\");\n+\t\tassertTrue(!request.bodyPublisher().isPresent());\n+\n+\t\t\/\/ CONNECT is disallowed in the implementation, since it is used for\n+\t\t\/\/ tunneling, and is handled separately for security checks.\n+\t\tassertThrows(IAE, () -> newBuilder(uri).method(\"CONNECT\", BodyPublishers.noBody()).build());\n+\n+\t\trequest = newBuilder(uri).method(\"GET\", BodyPublishers.noBody()).build();\n+\t\tassertEquals(request.method(), \"GET\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\n+\t\trequest = newBuilder(uri).method(\"POST\", BodyPublishers.ofString(\"\")).build();\n+\t\tassertEquals(request.method(), \"POST\");\n+\t\tassertTrue(request.bodyPublisher().isPresent());\n+\t}\n+\n+\t@Test\n+\tpublic void testHeaders() {\n+\t\tHttpRequest.Builder builder = newBuilder(uri);\n+\n+\t\tString[] empty = new String[0];\n+\t\tassertThrows(IAE, () -> builder.headers(empty).build());\n+\t\tassertThrows(IAE, () -> builder.headers(\"1\").build());\n+\t\tassertThrows(IAE, () -> builder.headers(\"1\", \"2\", \"3\").build());\n+\t\tassertThrows(IAE, () -> builder.headers(\"1\", \"2\", \"3\", \"4\", \"5\").build());\n+\t\tassertEquals(builder.build().headers().map().size(), 0);\n+\n+\t\tList<HttpRequest> requests = List.of(\n+\t\t\t\/\/ same header built from different combinations of the API\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\").build(),\n+\t\t\tnewBuilder(uri).header(\"A\", \"F\").setHeader(\"A\", \"B\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"F\").setHeader(\"A\", \"B\").build()\n+\t\t);\n+\n+\t\tfor (HttpRequest r : requests) {\n+\t\t\tassertEquals(r.headers().map().size(), 1);\n+\t\t\tassertTrue(r.headers().firstValue(\"A\").isPresent());\n+\t\t\tassertTrue(r.headers().firstValue(\"a\").isPresent());\n+\t\t\tassertEquals(r.headers().firstValue(\"A\").get(), \"B\");\n+\t\t\tassertEquals(r.headers().allValues(\"A\"), List.of(\"B\"));\n+\t\t\tassertEquals(r.headers().allValues(\"C\").size(), 0);\n+\t\t\tassertEquals(r.headers().map().get(\"A\"), List.of(\"B\"));\n+\t\t\tassertThrows(NFE, () -> r.headers().firstValueAsLong(\"A\"));\n+\t\t\tassertFalse(r.headers().firstValue(\"C\").isPresent());\n+\t\t\t\/\/ a non-exhaustive list of mutators\n+\t\t\tassertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().remove(\"A\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().remove(\"A\", \"B\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().clear());\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").remove(1));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").add(\"Z\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").addAll(List.of(\"Z\")));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").add(1, \"Z\"));\n+\t\t}\n+\n+\t\trequests = List.of(\n+\t\t\t\/\/ same headers built from different combinations of the API\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\")\n+\t\t\t\t.header(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\")\n+\t\t\t\t.headers(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\")\n+\t\t\t\t.setHeader(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\")\n+\t\t\t\t.headers(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\")\n+\t\t\t\t.header(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\")\n+\t\t\t\t.setHeader(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\")\n+\t\t\t\t.setHeader(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\")\n+\t\t\t\t.header(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\")\n+\t\t\t\t.headers(\"C\", \"D\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\", \"C\", \"D\").build()\n+\t\t);\n+\n+\t\tfor (HttpRequest r : requests) {\n+\t\t\tassertEquals(r.headers().map().size(), 2);\n+\t\t\tassertTrue(r.headers().firstValue(\"A\").isPresent());\n+\t\t\tassertEquals(r.headers().firstValue(\"A\").get(), \"B\");\n+\t\t\tassertEquals(r.headers().allValues(\"A\"), List.of(\"B\"));\n+\t\t\tassertTrue(r.headers().firstValue(\"C\").isPresent());\n+\t\t\tassertEquals(r.headers().firstValue(\"C\").get(), \"D\");\n+\t\t\tassertEquals(r.headers().allValues(\"C\"), List.of(\"D\"));\n+\t\t\tassertEquals(r.headers().map().get(\"C\"), List.of(\"D\"));\n+\t\t\tassertThrows(NFE, () -> r.headers().firstValueAsLong(\"C\"));\n+\t\t\tassertFalse(r.headers().firstValue(\"E\").isPresent());\n+\t\t\t\/\/ a smaller non-exhaustive list of mutators\n+\t\t\tassertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().remove(\"C\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"C\").add(\"Z\"));\n+\t\t}\n+\n+\t\trequests = List.of(\n+\t\t\t\/\/ same multi-value headers built from different combinations of the API\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\")\n+\t\t\t\t.header(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).header(\"A\", \"B\")\n+\t\t\t\t.headers(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\")\n+\t\t\t\t.headers(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\")\n+\t\t\t\t.header(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\")\n+\t\t\t\t.header(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).setHeader(\"A\", \"B\")\n+\t\t\t\t.headers(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).header(\"A\", \"D\")\n+\t\t\t\t.setHeader(\"A\", \"B\")\n+\t\t\t\t.headers(\"A\", \"C\").build(),\n+\t\t\tnewBuilder(uri).headers(\"A\", \"B\", \"A\", \"C\").build()\n+\t\t);\n+\n+\t\tfor (HttpRequest r : requests) {\n+\t\t\tassertEquals(r.headers().map().size(), 1);\n+\t\t\tassertTrue(r.headers().firstValue(\"A\").isPresent());\n+\t\t\tassertTrue(r.headers().allValues(\"A\").containsAll(List.of(\"B\", \"C\")));\n+\t\t\tassertEquals(r.headers().allValues(\"C\").size(), 0);\n+\t\t\tassertEquals(r.headers().map().get(\"A\"), List.of(\"B\", \"C\"));\n+\t\t\tassertThrows(NFE, () -> r.headers().firstValueAsLong(\"A\"));\n+\t\t\tassertFalse(r.headers().firstValue(\"C\").isPresent());\n+\t\t\t\/\/ a non-exhaustive list of mutators\n+\t\t\tassertThrows(UOE, () -> r.headers().map().put(\"Z\", List.of(\"Z\")));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().remove(\"A\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().remove(\"A\", \"B\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().map().clear());\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").remove(\"B\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").remove(1));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").clear());\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").add(\"Z\"));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").addAll(List.of(\"Z\")));\n+\t\t\tassertThrows(UOE, () -> r.headers().allValues(\"A\").add(1, \"Z\"));\n+\t\t}\n+\n+\t\t\/\/ case-insensitivity\n+\t\trequests = List.of(\n+\t\t\tnewBuilder(uri)\n+\t\t\t\t.header(\"Accept-Encoding\", \"gzip, deflate\").build(),\n+\t\t\tnewBuilder(uri)\n+\t\t\t\t.header(\"accept-encoding\", \"gzip, deflate\").build(),\n+\t\t\tnewBuilder(uri)\n+\t\t\t\t.header(\"AccePt-EncodINg\", \"gzip, deflate\").build(),\n+\t\t\tnewBuilder(uri)\n+\t\t\t\t.header(\"AcCEpt-EncoDIng\", \"gzip, deflate\").build()\n+\t\t);\n+\t\tfor (HttpRequest r : requests) {\n+\t\t\tfor (String name : List.of(\"Accept-Encoding\", \"accept-encoding\",\n+\t\t\t\t\"aCCept-EnCODing\", \"accepT-encodinG\")) {\n+\t\t\t\tassertTrue(r.headers().firstValue(name).isPresent());\n+\t\t\t\tassertTrue(r.headers().allValues(name).contains(\"gzip, deflate\"));\n+\t\t\t\tassertEquals(r.headers().firstValue(name).get(), \"gzip, deflate\");\n+\t\t\t\tassertEquals(r.headers().allValues(name).size(), 1);\n+\t\t\t\tassertEquals(r.headers().map().size(), 1);\n+\t\t\t\tassertEquals(r.headers().map().get(name).size(), 1);\n+\t\t\t\tassertEquals(r.headers().map().get(name).get(0), \"gzip, deflate\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t\/\/ headers that are allowed now, but weren't before\n+\tprivate static final Set<String> FORMERLY_RESTRICTED = Set.of(\"referer\", \"origin\",\n+\t\t\"OriGin\", \"Referer\", \"Date\", \"via\", \"WarnIng\");\n+\n+\t@Test\n+\tpublic void testFormerlyRestricted() throws URISyntaxException {\n+\t\tURI uri = new URI(\"http:\/\/localhost:80\/test\/\");\n+\t\tURI otherURI = new URI(\"http:\/\/www.foo.com\/test\/\");\n+\t\tfor (String header : FORMERLY_RESTRICTED) {\n+\t\t\tHttpRequest req = HttpRequest.newBuilder(uri)\n+\t\t\t\t.header(header, otherURI.toString())\n+\t\t\t\t.GET()\n+\t\t\t\t.build();\n+\t\t}\n+\t}\n+\n+\tprivate static final Set<String> RESTRICTED = Set.of(\"connection\", \"content-length\",\n+\t\t\"expect\", \"host\", \"upgrade\", \"Connection\", \"Content-Length\",\n+\t\t\"eXpect\", \"hosT\", \"upgradE\", \"CONNection\", \"CONTENT-LENGTH\",\n+\t\t\"EXPECT\", \"Host\", \"Upgrade\");\n+\n+\tinterface WithHeader {\n+\t\tHttpRequest.Builder withHeader(HttpRequest.Builder builder, String name, String value);\n+\t}\n+\n+\t@Test\n+\tpublic void testRestricted() throws URISyntaxException {\n+\t\tURI uri = new URI(\"http:\/\/localhost:80\/test\/\");\n+\t\tMap<String, WithHeader> lambdas = Map.of(\n+\t\t\t\"Builder::header\", HttpRequest.Builder::header,\n+\t\t\t\"Builder::headers\", (b, n, v) -> b.headers(n, v),\n+\t\t\t\"Builder::setHeader\", HttpRequest.Builder::setHeader\n+\t\t);\n+\t\tfor (Map.Entry<String, WithHeader> e : lambdas.entrySet()) {\n+\t\t\tSystem.out.println(\"Testing restricted headers with \" + e.getKey());\n+\t\t\tWithHeader f = e.getValue();\n+\t\t\tfor (String name : RESTRICTED) {\n+\t\t\t\tString value = name + \"-value\";\n+\t\t\t\tHttpRequest req = f.withHeader(HttpRequest.newBuilder(uri)\n+\t\t\t\t\t.GET(), \"x-\" + name, value).build();\n+\t\t\t\tString v = req.headers().firstValue(\"x-\" + name).orElseThrow(\n+\t\t\t\t\t() -> new RuntimeException(\"header x-\" + name + \" not set\"));\n+\t\t\t\tassertEquals(v, value);\n+\t\t\t\ttry {\n+\t\t\t\t\tf.withHeader(HttpRequest.newBuilder(uri)\n+\t\t\t\t\t\t.GET(), name, value).build();\n+\t\t\t\t\tthrow new RuntimeException(\"Expected IAE not thrown for \" + name);\n+\t\t\t\t} catch (IllegalArgumentException x) {\n+\t\t\t\t\tSystem.out.println(\"Got expected IAE for \" + name + \": \" + x);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testCopy() {\n+\t\tHttpRequest.Builder builder = newBuilder(uri).expectContinue(true)\n+\t\t\t.header(\"A\", \"B\")\n+\t\t\t.POST(BodyPublishers.ofString(\"\"))\n+\t\t\t.timeout(ofSeconds(30))\n+\t\t\t.setOption(H3_DISCOVERY, HTTP_3_URI_ONLY)\n+\t\t\t.version(HTTP_1_1);\n+\t\tHttpRequest.Builder copy = builder.copy();\n+\t\tassertTrue(builder != copy);\n+\n+\t\t\/\/ modify the original builder before building from the copy\n+\t\tbuilder.GET().timeout(ofSeconds(5)).version(HTTP_2).setHeader(\"A\", \"C\");\n+\n+\t\tHttpRequest copyRequest = copy.build();\n+\t\tassertEquals(copyRequest.uri(), uri);\n+\t\tassertEquals(copyRequest.expectContinue(), true);\n+\t\tassertEquals(copyRequest.headers().map().get(\"A\"), List.of(\"B\"));\n+\t\tassertEquals(copyRequest.method(), \"POST\");\n+\t\tassertEquals(copyRequest.bodyPublisher().isPresent(), true);\n+\t\tassertEquals(copyRequest.timeout().get(), ofSeconds(30));\n+\t\tassertTrue(copyRequest.version().isPresent());\n+\t\tassertEquals(copyRequest.version().get(), HTTP_1_1);\n+\t\tassertTrue(copyRequest.getOption(H3_DISCOVERY).isPresent());\n+\t\tassertEquals(copyRequest.getOption(H3_DISCOVERY).get(), HTTP_3_URI_ONLY);\n+\n+\t\t\/\/ lazy set URI ( maybe builder as a template )\n+\t\tcopyRequest = newBuilder().copy().uri(uri).build();\n+\t\tassertEquals(copyRequest.uri(), uri);\n+\n+\t\tbuilder = newBuilder().header(\"C\", \"D\");\n+\t\tcopy = builder.copy();\n+\t\tcopy.uri(uri);\n+\t\tcopyRequest = copy.build();\n+\t\tassertEquals(copyRequest.uri(), uri);\n+\t\tassertEquals(copyRequest.headers().firstValue(\"C\").get(), \"D\");\n+\t}\n+\n+\t@Test\n+\tpublic void testTimeout() {\n+\t\tHttpRequest.Builder builder = newBuilder(uri);\n+\t\tassertThrows(IAE, () -> builder.timeout(ZERO));\n+\t\tassertThrows(IAE, () -> builder.timeout(ofSeconds(0)));\n+\t\tassertThrows(IAE, () -> builder.timeout(ofSeconds(-1)));\n+\t\tassertThrows(IAE, () -> builder.timeout(ofNanos(-100)));\n+\t\tassertEquals(builder.timeout(ofNanos(15)).build().timeout().get(), ofNanos(15));\n+\t\tassertEquals(builder.timeout(ofSeconds(50)).build().timeout().get(), ofSeconds(50));\n+\t\tassertEquals(builder.timeout(ofMinutes(30)).build().timeout().get(), ofMinutes(30));\n+\t}\n+\n+\t@Test\n+\tpublic void testExpect() {\n+\t\tHttpRequest.Builder builder = newBuilder(uri);\n+\t\tassertEquals(builder.build().expectContinue(), false);\n+\t\tassertEquals(builder.expectContinue(true).build().expectContinue(), true);\n+\t\tassertEquals(builder.expectContinue(false).build().expectContinue(), false);\n+\t\tassertEquals(builder.expectContinue(true).build().expectContinue(), true);\n+\t}\n+\n+\t@Test\n+\tpublic void testEquals() {\n+\t\tassertNotEquals(newBuilder(URI.create(\"http:\/\/foo.com\")),\n+\t\t\tnewBuilder(URI.create(\"http:\/\/bar.com\")));\n+\n+\t\tHttpRequest.Builder builder = newBuilder(uri);\n+\t\tassertEquals(builder.build(), builder.build());\n+\t\tassertEquals(builder.build(), newBuilder(uri).build());\n+\n+\t\tbuilder.POST(BodyPublishers.noBody());\n+\t\tassertEquals(builder.build(), builder.build());\n+\t\tassertEquals(builder.build(), newBuilder(uri).POST(BodyPublishers.noBody()).build());\n+\t\tassertEquals(builder.build(), newBuilder(uri).POST(BodyPublishers.ofString(\"\")).build());\n+\t\tassertNotEquals(builder.build(), newBuilder(uri).build());\n+\t\tassertNotEquals(builder.build(), newBuilder(uri).GET().build());\n+\t\tassertNotEquals(builder.build(), newBuilder(uri).PUT(BodyPublishers.noBody()).build());\n+\n+\t\tbuilder = newBuilder(uri).header(\"x\", \"y\");\n+\t\tassertEquals(builder.build(), builder.build());\n+\t\tassertEquals(builder.build(), newBuilder(uri).header(\"x\", \"y\").build());\n+\t\tassertNotEquals(builder.build(), newBuilder(uri).header(\"x\", \"Z\").build());\n+\t\tassertNotEquals(builder.build(), newBuilder(uri).header(\"z\", \"y\").build());\n+\t}\n+\n+\t@Test\n+\tpublic void testNullMessages() {\n+\t\tHttpRequest.Builder builder = HttpRequest.newBuilder();\n+\n+\t\ttry {\n+\t\t\tbuilder.method(null, null);\n+\t\t\tfail(\"builder.method(null, null) should have thrown NullPointerException\");\n+\t\t} catch (NullPointerException e) {\n+\t\t\tassertTrue(e.getMessage().contains(\"HTTP method\"),\n+\t\t\t\t\"Expected exception message to contain 'HTTP method', but got: \" + e.getMessage());\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tbuilder.POST(null);\n+\t\t\tfail(\"builder.POST(null) should have thrown NullPointerException\");\n+\t\t} catch (NullPointerException e) {\n+\t\t\tassertTrue(e.getMessage().contains(\"BodyPublisher\"),\n+\t\t\t\t\"Expected exception message to contain 'BodyPublisher', but got: \" + e.getMessage());\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tbuilder.PUT(null);\n+\t\t\tfail(\"builder.PUT(null) should have thrown NullPointerException\");\n+\t\t} catch (NullPointerException e) {\n+\t\t\tassertTrue(e.getMessage().contains(\"BodyPublisher\"),\n+\t\t\t\t\"Expected exception message to contain 'BodyPublisher', but got: \" + e.getMessage());\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tbuilder.method(\"PATCH\", null);\n+\t\t\tfail(\"builder.method(\\\"PATCH\\\", null) should have thrown NullPointerException\");\n+\t\t} catch (NullPointerException e) {\n+\t\t\tassertTrue(e.getMessage().contains(\"BodyPublisher\"),\n+\t\t\t\t\"Expected exception message to contain 'BodyPublisher', but got: \" + e.getMessage());\n+\t\t}\n+\t}\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBuilderTest.java","additions":467,"deletions":431,"binary":false,"changes":898,"status":"modified"}]}