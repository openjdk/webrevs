{"files":[{"patch":"@@ -106,10 +106,0 @@\n-\/\/ Provides conversion between a CounterValues encoding of a pair of counters\n-\/\/ and the individual counters, using union-based type punning.\n-union PartialArrayStateManager::CounterState {\n-  CounterValues _values;\n-  struct { Counter _constructed; Counter _destructed; } _cd;\n-  CounterState(CounterValues values) : _values(values) {}\n-  CounterState(Counter constructed, Counter destructed)\n-    : _cd({constructed, destructed}) {}\n-};\n-\n@@ -119,4 +109,3 @@\n-    _counters(CounterState(0, 0)._values)\n-{\n-  assert(max_allocators <= std::numeric_limits<Counter>::max(), \"must be\");\n-}\n+    _registered_allocators(0),\n+    _released_allocators(0)\n+{}\n@@ -129,10 +118,0 @@\n-PartialArrayStateManager::CounterValues\n-PartialArrayStateManager::increment_counters(Counter constructed,\n-                                             Counter destructed) {\n-  \/\/ Verify the two Counters in State are encompassed by the Values.\n-  static_assert(sizeof(CounterValues) == sizeof(CounterState), \"must be\");\n-  return Atomic::fetch_then_add(&_counters,\n-                                CounterState(constructed, destructed)._values,\n-                                memory_order_relaxed);\n-}\n-\n@@ -140,5 +119,3 @@\n-  CounterState state = increment_counters(1, 0);\n-  assert(state._cd._destructed == 0, \"not in allocating phase\");\n-  assert(state._cd._constructed  < _max_allocators,\n-         \"exceeded configured maximum number of allocators\");\n-  return ::new (&_arenas[state._cd._constructed]) Arena(mtGC);\n+  uint idx = Atomic::fetch_then_add(&_registered_allocators, 1u, memory_order_relaxed);\n+  assert(idx < _max_allocators, \"exceeded configured max number of allocators\");\n+  return ::new (&_arenas[idx]) Arena(mtGC);\n@@ -149,2 +126,2 @@\n-  CounterState state = increment_counters(0, 1);\n-  assert(state._cd._destructed < state._cd._constructed, \"too many releases\");\n+  uint old = Atomic::fetch_then_add(&_released_allocators, 1u, memory_order_relaxed);\n+  assert(old < Atomic::load(&_registered_allocators), \"too many releases\");\n@@ -155,2 +132,2 @@\n-  CounterState state = Atomic::load(&_counters);\n-  assert(state._cd._constructed == state._cd._destructed,\n+  uint count = Atomic::load(&_registered_allocators);\n+  assert(count == Atomic::load(&_released_allocators),\n@@ -158,1 +135,0 @@\n-  uint count = state._cd._constructed;\n@@ -162,1 +138,2 @@\n-  Atomic::store(&_counters, CounterState(0, 0)._values);\n+  Atomic::store(&_registered_allocators, 0u);\n+  DEBUG_ONLY(Atomic::store(&_released_allocators, 0u);)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":12,"deletions":35,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -178,31 +178,5 @@\n-  \/\/ CounterValues is an integral type large enough to encode a pair of\n-  \/\/ allocator counters as a single unit for atomic manipulation.\n-  using CounterValues = LP64_ONLY(uint64_t) NOT_LP64(uint32_t);\n-  using Counter = LP64_ONLY(uint32_t) NOT_LP64(uint16_t);\n-\n-  union CounterState;\n-\n-  \/\/ A pair of Counters, packaged as an atomic unit.  One counter is the\n-  \/\/ number of constructed allocators and one is the number of destructed\n-  \/\/ allocators. The counters are atomic to permit concurrent construction,\n-  \/\/ and to permit concurrent destruction.  They are an atomic unit to detect\n-  \/\/ and reject mixing the two phases, without concern for questions of\n-  \/\/ ordering that might arise if they were separate atomic values.\n-  \/\/\n-  \/\/ The constructed count is used to track how many allocators, and so how\n-  \/\/ many arenas, are active.  Construction of an allocator increments this\n-  \/\/ count.  The destructed count is (debug-only) used to track how many\n-  \/\/ allocators are no longer active.  Destruction of an allocator increments\n-  \/\/ this count.\n-  \/\/\n-  \/\/ The constructed count must not exceed the configured limit on the number\n-  \/\/ of allocators.  It is used by reset() to determine how many arenas have\n-  \/\/ been constructed.  reset() clears the counters.\n-  \/\/\n-  \/\/ In a debug build, the pair is used to assert usage according to the\n-  \/\/ phase.  We're in the allocating phase if the destructed count is zero.\n-  \/\/ If it's non-zero then we're in the releasing phase. The destructed count\n-  \/\/ must never exceed the constructed count.  reset() is not permitted when\n-  \/\/ destructed < constructed.\n-  volatile CounterValues _counters;\n-  CounterValues increment_counters(Counter constructed, Counter destructed);\n+  \/\/ The number of allocators that have been registered\/released.\n+  \/\/ Atomic to support concurrent registration, and concurrent release.\n+  \/\/ Phasing restriction forbids registration concurrent with release.\n+  volatile uint _registered_allocators;\n+  DEBUG_ONLY(volatile uint _released_allocators;)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"}]}