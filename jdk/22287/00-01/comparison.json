{"files":[{"patch":"@@ -119,5 +119,7 @@\n-auto PartialArrayStateManager::counter(CounterState state, uint pos)\n-  -> CounterState\n-{\n-  static_assert(CounterBits <= BitsPerInt, \"must be\");\n-  return (state >> pos) & CounterMask;\n+uint PartialArrayStateManager::counter(CounterState state, uint pos) {\n+  static_assert(CounterMask <= UINT_MAX, \"must be\");\n+  return static_cast<uint>((state >> pos) & CounterMask);\n+}\n+\n+uint PartialArrayStateManager::constructed_count(CounterState state) {\n+  return counter(state, ConstructedShift);\n@@ -127,3 +129,2 @@\n-bool PartialArrayStateManager::is_allocating_phase(CounterState state) {\n-  \/\/ Allocating if active == used.  Releasing if active < used.\n-  return counter(state, UsedShift) == counter(state, ActiveShift);\n+uint PartialArrayStateManager::destructed_count(CounterState state) {\n+  return counter(state, DestructedShift);\n@@ -134,3 +135,3 @@\n-  CounterState state = Atomic::fetch_then_add(&_counters, Increment, memory_order_relaxed);\n-  assert(is_allocating_phase(state), \"not in allocating phase\");\n-  assert(counter(state, ActiveShift) <= _num_allocators,\n+  CounterState state = Atomic::fetch_then_add(&_counters, IncrementConstructed, memory_order_relaxed);\n+  assert(destructed_count(state) == 0, \"not in allocating phase\");\n+  assert(constructed_count(state) < _num_allocators,\n@@ -138,1 +139,1 @@\n-  CounterState id = counter(state, ActiveShift);\n+  uint id = constructed_count(state);\n@@ -142,0 +143,1 @@\n+#ifdef ASSERT\n@@ -143,4 +145,2 @@\n-  CounterState state = Atomic::sub(&_counters, Decrement, memory_order_relaxed);\n-  \/\/ Don't have fetch_then_sub, so can't check for zero old value directly.\n-  \/\/ counter value == CounterMask after sub => underflow.\n-  assert(counter(state, ActiveShift) < CounterMask, \"too many releases\");\n+  CounterState state = Atomic::fetch_then_add(&_counters, IncrementDestructed, memory_order_relaxed);\n+  assert(destructed_count(state) < constructed_count(state), \"too many releases\");\n@@ -148,0 +148,1 @@\n+#endif \/\/ ASSERT\n@@ -151,2 +152,3 @@\n-  assert(counter(state, ActiveShift) == 0, \"some allocators still active\");\n-  uint count = checked_cast<uint>(counter(state, UsedShift));\n+  assert(constructed_count(state) == destructed_count(state),\n+         \"some allocators still active\");\n+  uint count = constructed_count(state);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  using CounterState = uintptr_t;\n+  using CounterState = uintx;\n@@ -183,2 +183,2 @@\n-  \/\/ - high half: allocators created\n-  \/\/ - low half: active allocators (created - deleted)\n+  \/\/ - low half: allocators constructed\n+  \/\/ - high half: allocators destructed (debug only)\n@@ -192,3 +192,1 @@\n-  \/\/ Counter fields are in the high\/low half, excluding the high bit of that\n-  \/\/ half, to allow space for over\/underflow detection.  A counter must fit\n-  \/\/ in a uint.\n+  \/\/ Counter fields are in the high\/low half.  A counter must fit in a uint.\n@@ -196,1 +194,1 @@\n-  static const uint CounterBits = MIN2((uint)BitsPerInt, (CounterStateBits \/ 2)) - 1;\n+  static const uint CounterBits = MIN2((uint)BitsPerInt, (CounterStateBits \/ 2));\n@@ -199,2 +197,1 @@\n-  static const uint UsedShift = CounterStateBits \/ 2;\n-  static const uint ActiveShift = 0;\n+  static uint counter(CounterState state, uint pos);\n@@ -202,1 +199,3 @@\n-  static CounterState counter(CounterState state, uint pos);\n+  static const uint ConstructedShift = 0;\n+  static const CounterState IncrementConstructed = OneState << ConstructedShift;\n+  static uint constructed_count(CounterState state);\n@@ -204,7 +203,5 @@\n-  \/\/ When creating a new allocator, increment both active and used together.\n-  static const CounterState Increment = (OneState << UsedShift) | (OneState << ActiveShift);\n-  \/\/ When releasing an allocator, decrement only active, leaving used at high\n-  \/\/ water value.\n-  static const CounterState Decrement = (OneState << ActiveShift);\n-\n-  DEBUG_ONLY(static bool is_allocating_phase(CounterState state);)\n+#ifdef ASSERT\n+  static const uint DestructedShift = CounterStateBits \/ 2;\n+  static const CounterState IncrementDestructed = OneState << DestructedShift;\n+  static uint destructed_count(CounterState state);\n+#endif \/\/ ASSERT\n@@ -214,1 +211,1 @@\n-  void release_allocator();\n+  void release_allocator() NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"}]}