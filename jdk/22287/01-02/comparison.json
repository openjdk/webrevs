{"files":[{"patch":"@@ -106,4 +106,14 @@\n-PartialArrayStateManager::PartialArrayStateManager(uint num_allocators)\n-  : _arenas(NEW_C_HEAP_ARRAY(Arena, num_allocators, mtGC)),\n-    _num_allocators(num_allocators),\n-    _counters(ZeroState)\n+\/\/ Provides conversion between a CounterValues encoding of a pair of counters\n+\/\/ and the individual counters, using union-based type punning.\n+union PartialArrayStateManager::CounterState {\n+  CounterValues _values;\n+  struct { Counter _constructed; Counter _destructed; } _cd;\n+  CounterState(CounterValues values) : _values(values) {}\n+  CounterState(Counter constructed, Counter destructed)\n+    : _cd({constructed, destructed}) {}\n+};\n+\n+PartialArrayStateManager::PartialArrayStateManager(uint max_allocators)\n+  : _arenas(NEW_C_HEAP_ARRAY(Arena, max_allocators, mtGC)),\n+    _max_allocators(max_allocators),\n+    _counters(CounterState(0, 0)._values)\n@@ -111,1 +121,1 @@\n-  assert(num_allocators <= CounterMask, \"requested number of allocaters exceeds max\");\n+  assert(max_allocators <= std::numeric_limits<Counter>::max(), \"must be\");\n@@ -119,7 +129,8 @@\n-uint PartialArrayStateManager::counter(CounterState state, uint pos) {\n-  static_assert(CounterMask <= UINT_MAX, \"must be\");\n-  return static_cast<uint>((state >> pos) & CounterMask);\n-}\n-\n-uint PartialArrayStateManager::constructed_count(CounterState state) {\n-  return counter(state, ConstructedShift);\n+PartialArrayStateManager::CounterValues\n+PartialArrayStateManager::increment_counters(Counter constructed,\n+                                             Counter destructed) {\n+  \/\/ Verify the two Counters in State are encompassed by the Values.\n+  static_assert(sizeof(CounterValues) == sizeof(CounterState), \"must be\");\n+  return Atomic::fetch_then_add(&_counters,\n+                                CounterState(constructed, destructed)._values,\n+                                memory_order_relaxed);\n@@ -128,6 +139,0 @@\n-#ifdef ASSERT\n-uint PartialArrayStateManager::destructed_count(CounterState state) {\n-  return counter(state, DestructedShift);\n-}\n-#endif \/\/ ASSERT\n-\n@@ -135,6 +140,5 @@\n-  CounterState state = Atomic::fetch_then_add(&_counters, IncrementConstructed, memory_order_relaxed);\n-  assert(destructed_count(state) == 0, \"not in allocating phase\");\n-  assert(constructed_count(state) < _num_allocators,\n-         \"exceeded configured number of allocators\");\n-  uint id = constructed_count(state);\n-  return ::new (&_arenas[id]) Arena(mtGC);\n+  CounterState state = increment_counters(1, 0);\n+  assert(state._cd._destructed == 0, \"not in allocating phase\");\n+  assert(state._cd._constructed  < _max_allocators,\n+         \"exceeded configured maximum number of allocators\");\n+  return ::new (&_arenas[state._cd._constructed]) Arena(mtGC);\n@@ -145,2 +149,2 @@\n-  CounterState state = Atomic::fetch_then_add(&_counters, IncrementDestructed, memory_order_relaxed);\n-  assert(destructed_count(state) < constructed_count(state), \"too many releases\");\n+  CounterState state = increment_counters(0, 1);\n+  assert(state._cd._destructed < state._cd._constructed, \"too many releases\");\n@@ -152,1 +156,1 @@\n-  assert(constructed_count(state) == destructed_count(state),\n+  assert(state._cd._constructed == state._cd._destructed,\n@@ -154,1 +158,1 @@\n-  uint count = constructed_count(state);\n+  uint count = state._cd._constructed;\n@@ -158,1 +162,1 @@\n-  Atomic::store(&_counters, ZeroState);\n+  Atomic::store(&_counters, CounterState(0, 0)._values);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-\/\/ this manager have been destroyed.  During this phase, new allocators man not\n+\/\/ this manager have been destroyed.  During this phase, new allocators may not\n@@ -176,32 +176,33 @@\n-  uint _num_allocators;\n-\n-  \/\/ Integral type large enough to encode a pair of allocator counters as a\n-  \/\/ single unit for atomic manipulation.\n-  using CounterState = uintx;\n-\n-  \/\/ Encodes 2 values, in an atomic unit.\n-  \/\/ - low half: allocators constructed\n-  \/\/ - high half: allocators destructed (debug only)\n-  volatile CounterState _counters;\n-\n-  static const uint CounterStateBits = sizeof(CounterState) * BitsPerByte;\n-\n-  static const CounterState ZeroState = 0;\n-  static const CounterState OneState = 1;\n-\n-  \/\/ Counter fields are in the high\/low half.  A counter must fit in a uint.\n-  static_assert((CounterStateBits & 1) == 0, \"must be even\");\n-  static const uint CounterBits = MIN2((uint)BitsPerInt, (CounterStateBits \/ 2));\n-  static const CounterState CounterMask = (OneState << CounterBits) - OneState;\n-\n-  static uint counter(CounterState state, uint pos);\n-\n-  static const uint ConstructedShift = 0;\n-  static const CounterState IncrementConstructed = OneState << ConstructedShift;\n-  static uint constructed_count(CounterState state);\n-\n-#ifdef ASSERT\n-  static const uint DestructedShift = CounterStateBits \/ 2;\n-  static const CounterState IncrementDestructed = OneState << DestructedShift;\n-  static uint destructed_count(CounterState state);\n-#endif \/\/ ASSERT\n+  uint _max_allocators;\n+\n+  \/\/ CounterValues is an integral type large enough to encode a pair of\n+  \/\/ allocator counters as a single unit for atomic manipulation.\n+  using CounterValues = LP64_ONLY(uint64_t) NOT_LP64(uint32_t);\n+  using Counter = LP64_ONLY(uint32_t) NOT_LP64(uint16_t);\n+\n+  union CounterState;\n+\n+  \/\/ A pair of Counters, packaged as an atomic unit.  One counter is the\n+  \/\/ number of constructed allocators and one is the number of destructed\n+  \/\/ allocators. The counters are atomic to permit concurrent construction,\n+  \/\/ and to permit concurrent destruction.  They are an atomic unit to detect\n+  \/\/ and reject mixing the two phases, without concern for questions of\n+  \/\/ ordering that might arise if they were separate atomic values.\n+  \/\/\n+  \/\/ The constructed count is used to track how many allocators, and so how\n+  \/\/ many arenas, are active.  Construction of an allocator increments this\n+  \/\/ count.  The destructed count is (debug-only) used to track how many\n+  \/\/ allocators are no longer active.  Destruction of an allocator increments\n+  \/\/ this count.\n+  \/\/\n+  \/\/ The constructed count must not exceed the configured limit on the number\n+  \/\/ of allocators.  It is used by reset() to determine how many arenas have\n+  \/\/ been constructed.  reset() clears the counters.\n+  \/\/\n+  \/\/ In a debug build, the pair is used to assert usage according to the\n+  \/\/ phase.  We're in the allocating phase if the destructed count is zero.\n+  \/\/ If it's non-zero then we're in the releasing phase. The destructed count\n+  \/\/ must never exceed the constructed count.  reset() is not permitted when\n+  \/\/ destructed < constructed.\n+  volatile CounterValues _counters;\n+  CounterValues increment_counters(Counter constructed, Counter destructed);\n@@ -214,1 +215,1 @@\n-  explicit PartialArrayStateManager(uint num_allocators);\n+  explicit PartialArrayStateManager(uint max_allocators);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":35,"deletions":34,"binary":false,"changes":69,"status":"modified"}]}