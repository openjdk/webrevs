{"files":[{"patch":"@@ -89,0 +89,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -1168,0 +1169,1 @@\n+  _partial_array_state_manager(nullptr),\n@@ -1201,0 +1203,2 @@\n+  _partial_array_state_manager = new PartialArrayStateManager(n_queues);\n+\n@@ -1202,0 +1206,1 @@\n+}\n@@ -1203,1 +1208,2 @@\n-  guarantee(_task_queues != nullptr, \"task_queues allocation failure.\");\n+PartialArrayStateManager* G1CollectedHeap::partial_array_state_manager() const {\n+  return _partial_array_state_manager;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+class PartialArrayStateManager;\n@@ -810,2 +811,3 @@\n-  \/\/ The parallel task queues\n-  G1ScannerTasksQueueSet *_task_queues;\n+  \/\/ Reusable parallel task queues and partial array manager.\n+  G1ScannerTasksQueueSet* _task_queues;\n+  PartialArrayStateManager* _partial_array_state_manager;\n@@ -877,0 +879,2 @@\n+  PartialArrayStateManager* partial_array_state_manager() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  _gc_par_phases[ResetPartialArrayStateManager] = new WorkerDataArray<double>(\"ResetPartialArrayStateManager\", \"Reset Partial Array State Manager (ms):\", max_gc_threads);\n@@ -520,0 +521,1 @@\n+  trace_phase(_gc_par_phases[ResetPartialArrayStateManager]);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    ResetPartialArrayStateManager,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                                           G1EvacFailureRegions* evac_failure_regions,\n-                                           PartialArrayStateAllocator* pas_allocator)\n+                                           G1EvacFailureRegions* evac_failure_regions)\n@@ -84,1 +83,1 @@\n-    _partial_array_state_allocator(pas_allocator),\n+    _partial_array_state_allocator(g1h->partial_array_state_manager()),\n@@ -257,1 +256,1 @@\n-  _partial_array_state_allocator->release(_worker_id, state);\n+  _partial_array_state_allocator.release(state);\n@@ -280,5 +279,4 @@\n-      _partial_array_state_allocator->allocate(_worker_id,\n-                                               from_obj, to_obj,\n-                                               step._index,\n-                                               array_length,\n-                                               step._ncreate);\n+      _partial_array_state_allocator.allocate(from_obj, to_obj,\n+                                              step._index,\n+                                              array_length,\n+                                              step._ncreate);\n@@ -604,2 +602,1 @@\n-                               _evac_failure_regions,\n-                               &_partial_array_state_allocator);\n+                               _evac_failure_regions);\n@@ -735,2 +732,1 @@\n-    _evac_failure_regions(evac_failure_regions),\n-    _partial_array_state_allocator(num_workers)\n+    _evac_failure_regions(evac_failure_regions)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  PartialArrayStateAllocator* _partial_array_state_allocator;\n+  PartialArrayStateAllocator _partial_array_state_allocator;\n@@ -127,2 +127,1 @@\n-                       G1EvacFailureRegions* evac_failure_regions,\n-                       PartialArrayStateAllocator* partial_array_state_allocator);\n+                       G1EvacFailureRegions* evac_failure_regions);\n@@ -250,1 +249,0 @@\n-  PartialArrayStateAllocator _partial_array_state_allocator;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -947,0 +948,19 @@\n+class G1PostEvacuateCollectionSetCleanupTask2::ResetPartialArrayStateManagerTask\n+  : public G1AbstractSubTask\n+{\n+public:\n+  ResetPartialArrayStateManagerTask()\n+    : G1AbstractSubTask(G1GCPhaseTimes::ResetPartialArrayStateManager)\n+  {}\n+\n+  double worker_cost() const override {\n+    return AlmostNoWork;\n+  }\n+\n+  void do_work(uint worker_id) override {\n+    \/\/ This must be in phase2 cleanup, after phase1 has destroyed all of the\n+    \/\/ associated allocators.\n+    G1CollectedHeap::heap()->partial_array_state_manager()->reset();\n+  }\n+};\n+\n@@ -958,0 +978,1 @@\n+  add_serial_task(new ResetPartialArrayStateManagerTask());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\/\/ - Reset the reusable PartialArrayStateManager.\n@@ -71,0 +72,1 @@\n+  class ResetPartialArrayStateManagerTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n+PartialArrayStateManager*      PSPromotionManager::_partial_array_state_manager = nullptr;\n@@ -64,0 +64,4 @@\n+  assert(_partial_array_state_manager == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_manager\n+    = new PartialArrayStateManager(promotion_manager_num);\n+\n@@ -69,5 +73,1 @@\n-  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n-  _partial_array_state_allocator\n-    = new PartialArrayStateAllocator(ParallelGCThreads);\n-\n-  _stack_array_depth = new PSScannerTasksQueueSet(ParallelGCThreads);\n+  _stack_array_depth = new PSScannerTasksQueueSet(promotion_manager_num);\n@@ -78,1 +78,0 @@\n-    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -190,1 +189,2 @@\n-  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_state_allocator(_partial_array_state_manager),\n+    _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n@@ -201,3 +201,0 @@\n-  \/\/ Initialize to a bad value; fixed by initialize().\n-  _partial_array_state_allocator_index = UINT_MAX;\n-\n@@ -320,1 +317,1 @@\n-  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+  _partial_array_state_allocator.release(state);\n@@ -334,5 +331,4 @@\n-      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n-                                               old_obj, new_obj,\n-                                               step._index,\n-                                               array_length,\n-                                               step._ncreate);\n+      _partial_array_state_allocator.allocate(old_obj, new_obj,\n+                                              step._index,\n+                                              array_length,\n+                                              step._ncreate);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -53,2 +54,0 @@\n-class PartialArrayState;\n-class PartialArrayStateAllocator;\n@@ -91,1 +90,2 @@\n-  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+  static PartialArrayStateManager*    _partial_array_state_manager;\n+  PartialArrayStateAllocator          _partial_array_state_allocator;\n@@ -93,1 +93,0 @@\n-  uint                                _partial_array_state_allocator_index;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,7 +55,1 @@\n-class PartialArrayStateAllocator::Impl : public CHeapObj<mtGC> {\n-  struct FreeListEntry;\n-\n-  Arena* _arenas;\n-  FreeListEntry** _free_lists;\n-  uint _num_workers;\n-\n+class PartialArrayStateAllocator::FreeListEntry {\n@@ -63,13 +57,0 @@\n-  Impl(uint num_workers);\n-  ~Impl();\n-\n-  NONCOPYABLE(Impl);\n-\n-  PartialArrayState* allocate(uint worker_id,\n-                              oop src, oop dst,\n-                              size_t index, size_t length,\n-                              size_t initial_refcount);\n-  void release(uint worker_id, PartialArrayState* state);\n-};\n-\n-struct PartialArrayStateAllocator::Impl::FreeListEntry {\n@@ -84,10 +65,5 @@\n-PartialArrayStateAllocator::Impl::Impl(uint num_workers)\n-  : _arenas(NEW_C_HEAP_ARRAY(Arena, num_workers, mtGC)),\n-    _free_lists(NEW_C_HEAP_ARRAY(FreeListEntry*, num_workers, mtGC)),\n-    _num_workers(num_workers)\n-{\n-  for (uint i = 0; i < _num_workers; ++i) {\n-    ::new (&_arenas[i]) Arena(mtGC);\n-    _free_lists[i] = nullptr;\n-  }\n-}\n+PartialArrayStateAllocator::PartialArrayStateAllocator(PartialArrayStateManager* manager)\n+  : _manager(manager),\n+    _free_list(),\n+    _arena(manager->register_allocator())\n+{}\n@@ -95,2 +71,2 @@\n-PartialArrayStateAllocator::Impl::~Impl() {\n-  \/\/ We don't need to clean up the free lists.  Deallocating the entries\n+PartialArrayStateAllocator::~PartialArrayStateAllocator() {\n+  \/\/ We don't need to clean up the free list.  Deallocating the entries\n@@ -98,6 +74,3 @@\n-  \/\/ to the arena destructor to release the memory.\n-  FREE_C_HEAP_ARRAY(FreeListEntry*, _free_lists);\n-  for (uint i = 0; i < _num_workers; ++i) {\n-    _arenas[i].~Arena();\n-  }\n-  FREE_C_HEAP_ARRAY(Arena*, _arenas);\n+  \/\/ to the manager to release the memory.\n+  \/\/ Inform the manager that an allocator is no longer in use.\n+  _manager->release_allocator();\n@@ -106,5 +79,4 @@\n-PartialArrayState* PartialArrayStateAllocator::Impl::allocate(uint worker_id,\n-                                                              oop src, oop dst,\n-                                                              size_t index,\n-                                                              size_t length,\n-                                                              size_t initial_refcount) {\n+PartialArrayState* PartialArrayStateAllocator::allocate(oop src, oop dst,\n+                                                        size_t index,\n+                                                        size_t length,\n+                                                        size_t initial_refcount) {\n@@ -112,1 +84,1 @@\n-  FreeListEntry* head = _free_lists[worker_id];\n+  FreeListEntry* head = _free_list;\n@@ -114,1 +86,1 @@\n-    p = NEW_ARENA_OBJ(&_arenas[worker_id], PartialArrayState);\n+    p = NEW_ARENA_OBJ(_arena, PartialArrayState);\n@@ -116,1 +88,1 @@\n-    _free_lists[worker_id] = head->_next;\n+    _free_list = head->_next;\n@@ -123,1 +95,1 @@\n-void PartialArrayStateAllocator::Impl::release(uint worker_id, PartialArrayState* state) {\n+void PartialArrayStateAllocator::release(PartialArrayState* state) {\n@@ -129,2 +101,3 @@\n-    state->~PartialArrayState();\n-    _free_lists[worker_id] = ::new (state) FreeListEntry(_free_lists[worker_id]);\n+    \/\/ Don't need to call destructor; can't if not destructible.\n+    static_assert(!std::is_destructible<PartialArrayState>::value, \"expected\");\n+    _free_list = ::new (state) FreeListEntry(_free_list);\n@@ -134,2 +107,5 @@\n-PartialArrayStateAllocator::PartialArrayStateAllocator(uint num_workers)\n-  : _impl(new Impl(num_workers))\n+PartialArrayStateManager::PartialArrayStateManager(uint max_allocators)\n+  : _arenas(NEW_C_HEAP_ARRAY(Arena, max_allocators, mtGC)),\n+    _max_allocators(max_allocators),\n+    _registered_allocators(0)\n+    DEBUG_ONLY(COMMA _released_allocators(0))\n@@ -138,2 +114,3 @@\n-PartialArrayStateAllocator::~PartialArrayStateAllocator() {\n-  delete _impl;\n+PartialArrayStateManager::~PartialArrayStateManager() {\n+  reset();\n+  FREE_C_HEAP_ARRAY(Arena, _arenas);\n@@ -142,6 +119,4 @@\n-PartialArrayState* PartialArrayStateAllocator::allocate(uint worker_id,\n-                                                        oop src, oop dst,\n-                                                        size_t index,\n-                                                        size_t length,\n-                                                        size_t initial_refcount) {\n-  return _impl->allocate(worker_id, src, dst, index, length, initial_refcount);\n+Arena* PartialArrayStateManager::register_allocator() {\n+  uint idx = Atomic::fetch_then_add(&_registered_allocators, 1u, memory_order_relaxed);\n+  assert(idx < _max_allocators, \"exceeded configured max number of allocators\");\n+  return ::new (&_arenas[idx]) Arena(mtGC);\n@@ -150,2 +125,4 @@\n-void PartialArrayStateAllocator::release(uint worker_id, PartialArrayState* state) {\n-  _impl->release(worker_id, state);\n+#ifdef ASSERT\n+void PartialArrayStateManager::release_allocator() {\n+  uint old = Atomic::fetch_then_add(&_released_allocators, 1u, memory_order_relaxed);\n+  assert(old < Atomic::load(&_registered_allocators), \"too many releases\");\n@@ -153,0 +130,1 @@\n+#endif \/\/ ASSERT\n@@ -154,0 +132,10 @@\n+void PartialArrayStateManager::reset() {\n+  uint count = Atomic::load(&_registered_allocators);\n+  assert(count == Atomic::load(&_released_allocators),\n+         \"some allocators still active\");\n+  for (uint i = 0; i < count; ++i) {\n+    _arenas[i].~Arena();\n+  }\n+  Atomic::store(&_registered_allocators, 0u);\n+  DEBUG_ONLY(Atomic::store(&_released_allocators, 0u);)\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":49,"deletions":61,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class Arena;\n@@ -34,0 +35,1 @@\n+class PartialArrayStateManager;\n@@ -55,2 +57,2 @@\n-\/\/ reference count reaches zero the state should be released to the allocator\n-\/\/ for later reuse.\n+\/\/ reference count reaches zero the state is released to the allocator for\n+\/\/ later reuse.\n@@ -69,1 +71,4 @@\n-  ~PartialArrayState() = default;\n+\n+public:\n+  \/\/ Deleted to require management by allocator object.\n+  ~PartialArrayState() = delete;\n@@ -73,1 +78,0 @@\n-public:\n@@ -94,8 +98,8 @@\n-\/\/ States are initially allocated from a set of arenas owned by the allocator.\n-\/\/ This allows the entire set of allocated states to be discarded without the\n-\/\/ need to keep track of or find them under some circumstances.  For example,\n-\/\/ if G1 concurrent marking is aborted and needs to restart because of a full\n-\/\/ marking queue, the queue doesn't need to be searched for tasks referring to\n-\/\/ states to allow releasing them.  Instead the queue contents can just be\n-\/\/ discarded, and the memory for the no longer referenced states will\n-\/\/ eventually be reclaimed when the arenas are reset.\n+\/\/ States are initially arena allocated from the manager, using a per-thread\n+\/\/ allocator.  This allows the entire set of allocated states to be discarded\n+\/\/ without the need to keep track of or find them under some circumstances.\n+\/\/ For example, if G1 concurrent marking is aborted and needs to restart\n+\/\/ because of a full marking queue, the queue doesn't need to be searched for\n+\/\/ tasks referring to states to allow releasing them.  Instead the queue\n+\/\/ contents can just be discarded, and the memory for the no longer referenced\n+\/\/ states will eventually be reclaimed when the arena is reset.\n@@ -103,2 +107,4 @@\n-\/\/ A set of free-lists is placed in front of the arena allocators.  This\n-\/\/ causes the maximum number of allocated states to be based on the number of\n+\/\/ The allocators each provide a free-list of states.  When a state is\n+\/\/ released and its reference count has reached zero, it is added to the\n+\/\/ allocator's free-list, for use by future allocation requests.  This causes\n+\/\/ the maximum number of allocated states to be based on the number of\n@@ -106,2 +112,1 @@\n-\/\/ processed.  The use of free-list allocators is the reason for reference\n-\/\/ counting states.\n+\/\/ processed.\n@@ -109,4 +114,1 @@\n-\/\/ The arena and free-list to use for an allocation operation is designated by\n-\/\/ the worker_id used in the operation.  This avoids locking and such on those\n-\/\/ data structures, at the cost of possibly doing more total arena allocation\n-\/\/ that would be needed with a single shared arena and free-list.\n+\/\/ An allocator object is not thread-safe.\n@@ -114,2 +116,5 @@\n-  class Impl;\n-  Impl* _impl;\n+  class FreeListEntry;\n+\n+  PartialArrayStateManager* _manager;\n+  FreeListEntry* _free_list;\n+  Arena* _arena;                \/\/ Obtained from _manager.\n@@ -118,1 +123,1 @@\n-  PartialArrayStateAllocator(uint num_workers);\n+  explicit PartialArrayStateAllocator(PartialArrayStateManager* manager);\n@@ -124,3 +129,2 @@\n-  \/\/ arena associated with worker_id.\n-  PartialArrayState* allocate(uint worker_id,\n-                              oop src, oop dst,\n+  \/\/ from the associated manager.\n+  PartialArrayState* allocate(oop src, oop dst,\n@@ -134,1 +138,64 @@\n-  void release(uint worker_id, PartialArrayState* state);\n+  void release(PartialArrayState* state);\n+};\n+\n+\/\/ This class provides memory management for PartialArrayStates.\n+\/\/\n+\/\/ States are allocated using an allocator object. Those allocators in turn\n+\/\/ may request memory for a state from their associated manager. The manager\n+\/\/ is responsible for obtaining and releasing memory used for states by the\n+\/\/ associated allocators.\n+\/\/\n+\/\/ A state may be allocated by one allocator, but end up on the free-list of a\n+\/\/ different allocator.  This can happen because a task referring to the state\n+\/\/ may be stolen from the queue where it was initially added.  This is permitted\n+\/\/ because a state's memory won't be reclaimed until all of the allocators\n+\/\/ associated with the manager that is ultimately providing the memory have\n+\/\/ been deleted and the manager is reset.\n+\/\/\n+\/\/ A manager is used in two distinct and non-overlapping phases.\n+\/\/\n+\/\/ - allocating: This is the initial phase.  During this phase, new allocators\n+\/\/ may be created, and allocators may request memory from the manager.\n+\/\/\n+\/\/ - releasing: When an allocator is destroyed the manager transitions to this\n+\/\/ phase.  It remains in this phase until all extent allocators associated with\n+\/\/ this manager have been destroyed.  During this phase, new allocators may not\n+\/\/ be created, nor may extent allocators request memory from this manager.\n+\/\/\n+\/\/ Once all the associated allocators have been destroyed the releasing phase\n+\/\/ ends and the manager may be reset or deleted.  Resetting transitions back\n+\/\/ to the allocating phase.\n+class PartialArrayStateManager : public CHeapObj<mtGC> {\n+  friend class PartialArrayStateAllocator;\n+\n+  \/\/ Use an arena for each allocator, for thread-safe concurrent allocation by\n+  \/\/ different allocators.\n+  Arena* _arenas;\n+\n+  \/\/ Limit on the number of allocators this manager supports.\n+  uint _max_allocators;\n+\n+  \/\/ The number of allocators that have been registered\/released.\n+  \/\/ Atomic to support concurrent registration, and concurrent release.\n+  \/\/ Phasing restriction forbids registration concurrent with release.\n+  volatile uint _registered_allocators;\n+  DEBUG_ONLY(volatile uint _released_allocators;)\n+\n+  \/\/ These are all for sole use of the befriended allocator class.\n+  Arena* register_allocator();\n+  void release_allocator() NOT_DEBUG_RETURN;\n+\n+public:\n+  explicit PartialArrayStateManager(uint max_allocators);\n+\n+  \/\/ Release the memory that has been requested by allocators associated with\n+  \/\/ this manager.\n+  \/\/ precondition: all associated allocators have been deleted.\n+  ~PartialArrayStateManager();\n+\n+  NONCOPYABLE(PartialArrayStateManager);\n+\n+  \/\/ Recycle the memory that has been requested by allocators associated with\n+  \/\/ this manager.\n+  \/\/ precondition: all associated allocators have been deleted.\n+  void reset();\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":94,"deletions":27,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+        new LogMessageWithLevel(\"Reset Partial Array State Manager \\\\(ms\\\\)\", Level.TRACE),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+            \"ResetPartialArrayStateManager\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}