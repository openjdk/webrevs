{"files":[{"patch":"@@ -209,1 +209,5 @@\n-                        minContext.dupTo(resultInfo.checkContext.inferenceContext());\n+                        InferenceContext duppedTo = resultInfo.checkContext.inferenceContext();\n+                        minContext.dupTo(duppedTo);\n+                        if (minContext != inferenceContext) {\n+                            duppedTo.supplementaryIC = inferenceContext;\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -50,0 +51,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -52,0 +54,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -54,0 +57,1 @@\n+import com.sun.tools.javac.util.RichDiagnosticFormatter;\n@@ -56,0 +60,7 @@\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Kinds.kindName;\n+import static com.sun.tools.javac.code.TypeTag.CLASS;\n+import static com.sun.tools.javac.code.TypeTag.ERROR;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.code.TypeTag.TYPEVAR;\n+\n@@ -86,0 +97,8 @@\n+    \/* when an inference context (IC) is minimized, the minimized inference context (MIC) contains a\n+     * proper subset of IC's inference vars (IC_IV). In other words there will be at least one inference variable T\n+     * that belongs to IC_IV which doesn't belong to MIC_IV. We need the field below to, among other things,\n+     * check for set membership for cases where the minimized context or any other context derived from it\n+     * needs to deal with an inference variable that has been eliminated from IC_IV while minimizing it\n+     *\/\n+    InferenceContext supplementaryIC;\n+\n@@ -246,1 +265,66 @@\n-        return types.subst(t, inferencevars, instTypes());\n+        Type result = types.subst(t, inferencevars, instTypes());\n+        InferenceContext next = supplementaryIC;\n+        \/\/ stop as soon as there are no more supplementary inference context or\n+        \/\/ no more type variables to be instantiated\n+        if (next != null) {\n+            HasTypeVars hasTypeVars = new HasTypeVars();\n+            while (next != null && hasTypeVars.visit(result)) {\n+                result = next.asInstType(result);\n+                next = next.supplementaryIC;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static class HasTypeVars extends Types.UnaryVisitor<Boolean> {\n+        public Boolean visit(List<Type> ts) {\n+            for (Type t : ts)\n+                if (visit(t)) {\n+                    return true;\n+                }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitForAll(Type.ForAll t, Void ignored) {\n+            return visit(t.tvars) || visit(t.qtype);\n+        }\n+\n+        @Override\n+        public Boolean visitMethodType(Type.MethodType t, Void ignored) {\n+            return visit(t.argtypes) || visit(t.restype);\n+        }\n+\n+        @Override\n+        public Boolean visitErrorType(Type.ErrorType t, Void ignored) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitArrayType(ArrayType t, Void ignored) {\n+            return visit(t.elemtype);\n+        }\n+\n+        @Override\n+        public Boolean visitWildcardType(WildcardType t, Void ignored) {\n+            return visit(t.type);\n+        }\n+\n+        public Boolean visitType(Type t, Void ignored) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitCapturedType(Type.CapturedType t, Void ignored) {\n+            return visit(t.wildcard) || visit(t.lower) || visit(t.getUpperBound());\n+        }\n+\n+        @Override\n+        public Boolean visitClassType(ClassType t, Void ignored) {\n+            return visit(t.getTypeArguments()) || visit(t.getEnclosingType());\n+        }\n+\n+        @Override\n+        public Boolean visitTypeVar(TypeVar t, Void ignored) {\n+            return true;\n+        }\n@@ -261,1 +345,17 @@\n-        freeTypeListeners.put(ftl, freeVarsIn(types));\n+        List<Type> myFreeVars = freeVarsIn(types);\n+        if (supplementaryIC == null) {\n+            freeTypeListeners.put(ftl, myFreeVars);\n+        } else {\n+            InferenceContext icToAddListenerTo = this;\n+            InferenceContext currentIC = this;\n+            List<Type> varsToAdd = myFreeVars;\n+            while (currentIC != null && currentIC.supplementaryIC != null) {\n+                List<Type> suppFreeVars = currentIC.supplementaryIC.freeVarsIn(types);\n+                if (suppFreeVars.size() > varsToAdd.size()) {\n+                    varsToAdd = suppFreeVars;\n+                    icToAddListenerTo = currentIC.supplementaryIC;\n+                }\n+                currentIC = currentIC.supplementaryIC;\n+            }\n+            icToAddListenerTo.freeTypeListeners.put(ftl, varsToAdd);\n+        }\n@@ -554,2 +654,12 @@\n-        return \"Inference vars: \" + inferencevars + '\\n' +\n-               \"Undet vars: \" + undetvars;\n+        String result = \"Inference vars: \" + inferencevars + '\\n' +\n+               \"Undet vars: \" + undetvars + '\\n';\n+        \/*\n+        \/\/ keep it for debugging\n+        if (!freeTypeListeners.isEmpty()) {\n+            result += \"Free Listeners:\\n\";\n+            for (Map.Entry<FreeTypeListener, List<Type>> entry : freeTypeListeners.entrySet()) {\n+                result += \"    \" + entry.getKey().toString() + \"  vars: \" + entry.getValue() + '\\n';\n+            }\n+        }\n+        *\/\n+        return result;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":114,"deletions":4,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325859\n+ * @summary potential information loss during type inference\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ *\/\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+public class SupplementaryInferenceContextTest {\n+    static String result;\n+    public static void main(String... args) {\n+        runT(() -> supplyNull(Integer.valueOf(1)));\n+        Assert.check(result.equals(\"class java.lang.Integer\"));\n+    }\n+\n+    static <R, X> R supplyNull(X... varargs) {\n+        result = varargs.getClass().getComponentType().toString();\n+        System.err.println(\"result is =\" + result);\n+        return null;\n+    }\n+\n+    static <T> void runT(Runnable runnable) { runnable.run(); }\n+}\n","filename":"test\/langtools\/tools\/javac\/inference_context_min\/SupplementaryInferenceContextTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"}]}