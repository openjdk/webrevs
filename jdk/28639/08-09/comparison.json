{"files":[{"patch":"@@ -75,1 +75,1 @@\n-        Object run();\n+        Object run(int i);\n@@ -80,14 +80,1 @@\n-    int[] aI;\n-    int[] rI1;\n-    int[] rI2;\n-    int[] rI3;\n-    int[] rI4;\n-    int eI;\n-\n-    float[] aF;\n-    float[] bF;\n-\n-    byte[] aB;\n-\n-    int[] oopsX4;\n-    int[] memX4;\n+    VectorAlgorithmsImpl.Data d;\n@@ -104,9 +91,0 @@\n-        \/\/ IMPORTANT:\n-        \/\/   If you want to use some array but do NOT modify it: just use it.\n-        \/\/   If you want to use it and DO want to modify it: clone it. This\n-        \/\/   ensures that each test gets a separate copy, and that when we\n-        \/\/   capture the modified arrays they are different for every method\n-        \/\/   and run.\n-        \/\/   An alternative to cloning is to use different return arrays for\n-        \/\/   different implementations of the same group, e.g. rI1, rI2, ...\n-\n@@ -114,3 +92,3 @@\n-        testGroups.get(\"fillI\").put(\"fillI_loop\",      () -> { return fillI_loop(rI1); });\n-        testGroups.get(\"fillI\").put(\"fillI_VectorAPI\", () -> { return fillI_VectorAPI(rI1); });\n-        testGroups.get(\"fillI\").put(\"fillI_Arrays\",    () -> { return fillI_Arrays(rI1); });\n+        testGroups.get(\"fillI\").put(\"fillI_loop\",      i -> { return fillI_loop(d.rI1); });\n+        testGroups.get(\"fillI\").put(\"fillI_VectorAPI\", i -> { return fillI_VectorAPI(d.rI1); });\n+        testGroups.get(\"fillI\").put(\"fillI_Arrays\",    i -> { return fillI_Arrays(d.rI1); });\n@@ -119,2 +97,2 @@\n-        testGroups.get(\"iotaI\").put(\"iotaI_loop\",      () -> { return iotaI_loop(rI1); });\n-        testGroups.get(\"iotaI\").put(\"iotaI_VectorAPI\", () -> { return iotaI_VectorAPI(rI1); });\n+        testGroups.get(\"iotaI\").put(\"iotaI_loop\",      i -> { return iotaI_loop(d.rI1); });\n+        testGroups.get(\"iotaI\").put(\"iotaI_VectorAPI\", i -> { return iotaI_VectorAPI(d.rI1); });\n@@ -123,3 +101,3 @@\n-        testGroups.get(\"copyI\").put(\"copyI_loop\",             () -> { return copyI_loop(aI, rI1); });\n-        testGroups.get(\"copyI\").put(\"copyI_VectorAPI\",        () -> { return copyI_VectorAPI(aI, rI1); });\n-        testGroups.get(\"copyI\").put(\"copyI_System_arraycopy\", () -> { return copyI_System_arraycopy(aI, rI1); });\n+        testGroups.get(\"copyI\").put(\"copyI_loop\",             i -> { return copyI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"copyI\").put(\"copyI_VectorAPI\",        i -> { return copyI_VectorAPI(d.aI, d.rI1); });\n+        testGroups.get(\"copyI\").put(\"copyI_System_arraycopy\", i -> { return copyI_System_arraycopy(d.aI, d.rI1); });\n@@ -128,2 +106,2 @@\n-        testGroups.get(\"mapI\").put(\"mapI_loop\",      () -> { return mapI_loop(aI, rI1); });\n-        testGroups.get(\"mapI\").put(\"mapI_VectorAPI\", () -> { return mapI_VectorAPI(aI, rI1); });\n+        testGroups.get(\"mapI\").put(\"mapI_loop\",      i -> { return mapI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"mapI\").put(\"mapI_VectorAPI\", i -> { return mapI_VectorAPI(d.aI, d.rI1); });\n@@ -132,4 +110,4 @@\n-        testGroups.get(\"reduceAddI\").put(\"reduceAddI_loop\",                           () -> { return reduceAddI_loop(aI); });\n-        testGroups.get(\"reduceAddI\").put(\"reduceAddI_reassociate\",                    () -> { return reduceAddI_reassociate(aI); });\n-        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_naive\",                () -> { return reduceAddI_VectorAPI_naive(aI); });\n-        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_reduction_after_loop\", () -> { return reduceAddI_VectorAPI_reduction_after_loop(aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_loop\",                           i -> { return reduceAddI_loop(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_reassociate\",                    i -> { return reduceAddI_reassociate(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_naive\",                i -> { return reduceAddI_VectorAPI_naive(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_reduction_after_loop\", i -> { return reduceAddI_VectorAPI_reduction_after_loop(d.aI); });\n@@ -138,3 +116,3 @@\n-        testGroups.get(\"dotProductF\").put(\"dotProductF_loop\",                           () -> { return dotProductF_loop(aF, bF); });\n-        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_naive\",                () -> { return dotProductF_VectorAPI_naive(aF, bF); });\n-        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_reduction_after_loop\", () -> { return dotProductF_VectorAPI_reduction_after_loop(aF, bF); });\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_loop\",                           i -> { return dotProductF_loop(d.aF, d.bF); });\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_naive\",                i -> { return dotProductF_VectorAPI_naive(d.aF, d.bF); });\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_reduction_after_loop\", i -> { return dotProductF_VectorAPI_reduction_after_loop(d.aF, d.bF); });\n@@ -143,4 +121,4 @@\n-        testGroups.get(\"hashCodeB\").put(\"hashCodeB_loop\",         () -> { return hashCodeB_loop(aB); });\n-        testGroups.get(\"hashCodeB\").put(\"hashCodeB_Arrays\",       () -> { return hashCodeB_Arrays(aB); });\n-        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v1\", () -> { return hashCodeB_VectorAPI_v1(aB); });\n-        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v2\", () -> { return hashCodeB_VectorAPI_v2(aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_loop\",         i -> { return hashCodeB_loop(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_Arrays\",       i -> { return hashCodeB_Arrays(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v1\", i -> { return hashCodeB_VectorAPI_v1(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v2\", i -> { return hashCodeB_VectorAPI_v2(d.aB); });\n@@ -149,3 +127,3 @@\n-        testGroups.get(\"scanAddI\").put(\"scanAddI_loop\",                      () -> { return scanAddI_loop(aI, rI1); });\n-        testGroups.get(\"scanAddI\").put(\"scanAddI_loop_reassociate\",          () -> { return scanAddI_loop_reassociate(aI, rI2); });\n-        testGroups.get(\"scanAddI\").put(\"scanAddI_VectorAPI_permute_add\",     () -> { return scanAddI_VectorAPI_permute_add(aI, rI4); });\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_loop\",                      i -> { return scanAddI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_loop_reassociate\",          i -> { return scanAddI_loop_reassociate(d.aI, d.rI2); });\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_VectorAPI_permute_add\",     i -> { return scanAddI_VectorAPI_permute_add(d.aI, d.rI4); });\n@@ -154,2 +132,2 @@\n-        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_loop\",      () -> { return findMinIndexI_loop(aI); });\n-        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_VectorAPI\", () -> { return findMinIndexI_VectorAPI(aI); });\n+        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_loop\",      i -> { return findMinIndexI_loop(d.aI); });\n+        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_VectorAPI\", i -> { return findMinIndexI_VectorAPI(d.aI); });\n@@ -158,2 +136,2 @@\n-        testGroups.get(\"findI\").put(\"findI_loop\",      () -> { return findI_loop(aI, eI); });\n-        testGroups.get(\"findI\").put(\"findI_VectorAPI\", () -> { return findI_VectorAPI(aI, eI); });\n+        testGroups.get(\"findI\").put(\"findI_loop\",      i -> { return findI_loop(d.aI, d.eI[i]); });\n+        testGroups.get(\"findI\").put(\"findI_VectorAPI\", i -> { return findI_VectorAPI(d.aI, d.eI[i]); });\n@@ -162,2 +140,2 @@\n-        testGroups.get(\"reverseI\").put(\"reverseI_loop\",      () -> { return reverseI_loop(aI, rI1); });\n-        testGroups.get(\"reverseI\").put(\"reverseI_VectorAPI\", () -> { return reverseI_VectorAPI(aI, rI2); });\n+        testGroups.get(\"reverseI\").put(\"reverseI_loop\",      i -> { return reverseI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"reverseI\").put(\"reverseI_VectorAPI\", i -> { return reverseI_VectorAPI(d.aI, d.rI2); });\n@@ -166,2 +144,2 @@\n-        testGroups.get(\"filterI\").put(\"filterI_loop\",      () -> { return filterI_loop(aI, rI1, eI); });\n-        testGroups.get(\"filterI\").put(\"filterI_VectorAPI\", () -> { return filterI_VectorAPI(aI, rI2, eI); });\n+        testGroups.get(\"filterI\").put(\"filterI_loop\",      i -> { return filterI_loop(d.aI, d.rI1, d.eI[i]); });\n+        testGroups.get(\"filterI\").put(\"filterI_VectorAPI\", i -> { return filterI_VectorAPI(d.aI, d.rI2, d.eI[i]); });\n@@ -170,2 +148,2 @@\n-        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_loop\",      () -> { return reduceAddIFieldsX4_loop(oopsX4, memX4); });\n-        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_VectorAPI\", () -> { return reduceAddIFieldsX4_VectorAPI(oopsX4, memX4); });\n+        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_loop\",      i -> { return reduceAddIFieldsX4_loop(d.oopsX4, d.memX4); });\n+        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_VectorAPI\", i -> { return reduceAddIFieldsX4_VectorAPI(d.oopsX4, d.memX4); });\n@@ -215,34 +193,3 @@\n-            aI = new int[size];\n-            G.fill(INT_GEN, aI);\n-            \/\/ Pick some random element. Most of the time it is in aI, sometimes not.\n-            eI = (RANDOM.nextInt(10) == 0) ? RANDOM.nextInt() : aI[RANDOM.nextInt(size)];\n-            \/\/for (int i = 0; i < aI.length; i++) { aI[i] = i; }\n-            rI1 = new int[size];\n-            rI2 = new int[size];\n-            rI3 = new int[size];\n-            rI4 = new int[size];\n-\n-            \/\/ X4 oop setup.\n-            oopsX4 = new int[size];\n-            int numX4 = 10_000;\n-            for (int i = 0; i < size; i++) {\n-                \/\/ assign either a zero=null, or assign a random oop.\n-                oopsX4[i] = (RANDOM.nextInt(10) == 0) ? 0 : RANDOM.nextInt(numX4) * 4;\n-            }\n-            \/\/ Just fill the whole array with random values.\n-            \/\/ The relevant field is only at every \"4 * i + 3\" though.\n-            memX4 = new int[4 * numX4];\n-            for (int i = 0; i < 4 * numX4; i++) {\n-                memX4[i] = RANDOM.nextInt();\n-            }\n-\n-            \/\/ float inputs. To avoid rounding issues, only use small integers.\n-            aF = new float[size];\n-            bF = new float[size];\n-            for (int i = 0; i < size; i++) {\n-                aF[i] = RANDOM.nextInt(32) - 16;\n-                bF[i] = RANDOM.nextInt(32) - 16;\n-            }\n-\n-            aB = new byte[size];\n-            RANDOM.nextBytes(aB);\n+            int seed = RANDOM.nextInt();\n+            int numXObjects = 10_000;\n+            d = new VectorAlgorithmsImpl.Data(size, seed, numXObjects);\n@@ -259,1 +206,1 @@\n-                    Object result = test.run();\n+                    Object result = test.run(iter);\n@@ -389,1 +336,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(a);\n@@ -460,1 +407,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(a);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java","additions":42,"deletions":95,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Random;\n@@ -41,0 +42,79 @@\n+    \/\/ This class stores the input and output arrays.\n+    \/\/ The constructor sets up all the data.\n+    \/\/\n+    \/\/ IMPORTANT:\n+    \/\/   If you want to use some array but do NOT modify it: just use it.\n+    \/\/   If you want to use it and DO want to modify it: clone it. This\n+    \/\/   ensures that each test gets a separate copy, and that when we\n+    \/\/   capture the modified arrays they are different for every method\n+    \/\/   and run.\n+    \/\/   An alternative to cloning is to use different return arrays for\n+    \/\/   different implementations of the same group, e.g. rI1, rI2, ...\n+    \/\/\n+    public static class Data {\n+        public int[] aI;\n+        public int[] rI1;\n+        public int[] rI2;\n+        public int[] rI3;\n+        public int[] rI4;\n+        public int[] eI;\n+        \/\/ The test has to use the same index into eI for all implementations. But in the\n+        \/\/ benchmark, we'd like to use random indices, so we use the index to advance through\n+        \/\/ the array.\n+        public int eI_idx = 0;\n+\n+        public float[] aF;\n+        public float[] bF;\n+\n+        public byte[] aB;\n+\n+        public int[] oopsX4;\n+        public int[] memX4;\n+\n+        public Data(int size, int seed, int numX4Objects) {\n+            Random random = new Random(seed);\n+\n+            \/\/ int: one input array and multiple output arrays so different implementations can\n+            \/\/ store their results to different arrays.\n+            aI = new int[size];\n+            rI1 = new int[size];\n+            rI2 = new int[size];\n+            rI3 = new int[size];\n+            rI4 = new int[size];\n+            Arrays.setAll(aI, i -> random.nextInt());\n+\n+            \/\/ Populate with some random values from aI, and some totally random values.\n+            eI = new int[0x10000];\n+            for (int i = 0; i < eI.length; i++) {\n+                eI[i] = (random.nextInt(10) == 0) ? random.nextInt() : aI[random.nextInt(size)];\n+            }\n+\n+            \/\/ X4 oop setup.\n+            \/\/ oopsX4 holds \"addresses\" (i.e. indices), that point to the 16-byte objects in memX4.\n+            oopsX4 = new int[size];\n+            memX4 = new int[numX4Objects * 4];\n+            for (int i = 0; i < size; i++) {\n+                \/\/ assign either a zero=null, or assign a random oop.\n+                oopsX4[i] = (random.nextInt(10) == 0) ? 0 : random.nextInt(numX4Objects) * 4;\n+            }\n+            \/\/ Just fill the whole array with random values.\n+            \/\/ The relevant field is only at every \"4 * i + 3\" though.\n+            memX4 = new int[4 * numX4Objects];\n+            for (int i = 0; i < memX4.length; i++) {\n+                memX4[i] = random.nextInt();\n+            }\n+\n+            \/\/ float inputs. To avoid rounding issues, only use small integers.\n+            aF = new float[size];\n+            bF = new float[size];\n+            for (int i = 0; i < size; i++) {\n+                aF[i] = random.nextInt(32) - 16;\n+                bF[i] = random.nextInt(32) - 16;\n+            }\n+\n+            \/\/ byte: just random data.\n+            aB = new byte[size];\n+            random.nextBytes(aB);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Random;\n@@ -53,3 +52,3 @@\n-@Warmup(iterations = 20, time = 100, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 50, time = 100, timeUnit = TimeUnit.MILLISECONDS)\n-@Fork(value = 1, jvmArgs = {\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl::*\"})\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(value = 5, jvmArgs = {\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl*::*\"})\n@@ -66,14 +65,1 @@\n-    public static Random RANDOM;\n-    public static int[] aI;\n-    public static int[] rI;\n-\n-    public static int[] eI;\n-    public static int idx = 0;\n-\n-    public static int[] oopsX4;\n-    public static int[] memX4;\n-\n-    public static float[] aF;\n-    public static float[] bF;\n-\n-    byte[] aB;\n+    VectorAlgorithmsImpl.Data d;\n@@ -83,40 +69,1 @@\n-        RANDOM = new Random(SEED);\n-\n-        aI = new int[SIZE];\n-        rI = new int[SIZE];\n-\n-        eI = new int[0x10000];\n-\n-        oopsX4 = new int[SIZE];\n-        memX4 = new int[NUM_X_OBJECTS * 4];\n-\n-        aF = new float[SIZE];\n-        bF = new float[SIZE];\n-\n-        aB = new byte[SIZE];\n-        RANDOM.nextBytes(aB);\n-    }\n-\n-    @Setup(Level.Iteration)\n-    public void resetInputs() {\n-        Arrays.setAll(aI, i -> RANDOM.nextInt());\n-\n-        \/\/ Populate with some random values from aI, and some totally random values.\n-        for (int i = 0; i < eI.length; i++) {\n-            eI[i] = (RANDOM.nextInt(10) == 0) ? RANDOM.nextInt() : aI[RANDOM.nextInt(SIZE)];\n-        }\n-\n-        for (int i = 0; i < oopsX4.length; i++) {\n-            \/\/ assign either a zero=null, or assign a random oop.\n-            oopsX4[i] = (RANDOM.nextInt(10) == 0) ? 0 : RANDOM.nextInt(NUM_X_OBJECTS) * 4;\n-        }\n-        \/\/ Just fill the whole array with random values.\n-        \/\/ The relevant field is only at every \"4 * i + 3\" though.\n-        for (int i = 0; i < memX4.length; i++) {\n-            memX4[i] = RANDOM.nextInt();\n-        }\n-\n-        for (int i = 0; i < aF.length; i++) {\n-            aF[i] = RANDOM.nextFloat();\n-            bF[i] = RANDOM.nextFloat();\n-        }\n+        d = new VectorAlgorithmsImpl.Data(SIZE, SEED, NUM_X_OBJECTS);\n@@ -131,1 +78,1 @@\n-        return VectorAlgorithmsImpl.fillI_loop(rI);\n+        return VectorAlgorithmsImpl.fillI_loop(d.rI1);\n@@ -136,1 +83,1 @@\n-        return VectorAlgorithmsImpl.fillI_VectorAPI(rI);\n+        return VectorAlgorithmsImpl.fillI_VectorAPI(d.rI1);\n@@ -141,1 +88,1 @@\n-        return VectorAlgorithmsImpl.fillI_Arrays(rI);\n+        return VectorAlgorithmsImpl.fillI_Arrays(d.rI1);\n@@ -146,1 +93,1 @@\n-        return VectorAlgorithmsImpl.iotaI_loop(rI);\n+        return VectorAlgorithmsImpl.iotaI_loop(d.rI1);\n@@ -151,1 +98,1 @@\n-        return VectorAlgorithmsImpl.iotaI_VectorAPI(rI);\n+        return VectorAlgorithmsImpl.iotaI_VectorAPI(d.rI1);\n@@ -156,1 +103,1 @@\n-        return VectorAlgorithmsImpl.copyI_loop(aI, rI);\n+        return VectorAlgorithmsImpl.copyI_loop(d.aI, d.rI1);\n@@ -161,1 +108,1 @@\n-        return VectorAlgorithmsImpl.copyI_VectorAPI(aI, rI);\n+        return VectorAlgorithmsImpl.copyI_VectorAPI(d.aI, d.rI1);\n@@ -166,1 +113,1 @@\n-        return VectorAlgorithmsImpl.copyI_System_arraycopy(aI, rI);\n+        return VectorAlgorithmsImpl.copyI_System_arraycopy(d.aI, d.rI1);\n@@ -171,1 +118,1 @@\n-        return VectorAlgorithmsImpl.mapI_loop(aI, rI);\n+        return VectorAlgorithmsImpl.mapI_loop(d.aI, d.rI1);\n@@ -176,1 +123,1 @@\n-        return VectorAlgorithmsImpl.mapI_VectorAPI(aI, rI);\n+        return VectorAlgorithmsImpl.mapI_VectorAPI(d.aI, d.rI1);\n@@ -181,1 +128,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_loop(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_loop(d.aI);\n@@ -186,1 +133,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_reassociate(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_reassociate(d.aI);\n@@ -191,1 +138,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(d.aI);\n@@ -196,1 +143,1 @@\n-        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(aI);\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(d.aI);\n@@ -201,1 +148,1 @@\n-        return VectorAlgorithmsImpl.dotProductF_loop(aF, bF);\n+        return VectorAlgorithmsImpl.dotProductF_loop(d.aF, d.bF);\n@@ -206,1 +153,1 @@\n-        return VectorAlgorithmsImpl.dotProductF_VectorAPI_naive(aF, bF);\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_naive(d.aF, d.bF);\n@@ -211,1 +158,1 @@\n-        return VectorAlgorithmsImpl.dotProductF_VectorAPI_reduction_after_loop(aF, bF);\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_reduction_after_loop(d.aF, d.bF);\n@@ -216,1 +163,1 @@\n-        return VectorAlgorithmsImpl.hashCodeB_loop(aB);\n+        return VectorAlgorithmsImpl.hashCodeB_loop(d.aB);\n@@ -221,1 +168,1 @@\n-        return VectorAlgorithmsImpl.hashCodeB_Arrays(aB);\n+        return VectorAlgorithmsImpl.hashCodeB_Arrays(d.aB);\n@@ -226,1 +173,1 @@\n-        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(aB);\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(d.aB);\n@@ -231,1 +178,1 @@\n-        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(aB);\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(d.aB);\n@@ -236,1 +183,1 @@\n-        return VectorAlgorithmsImpl.scanAddI_loop(aI, rI);\n+        return VectorAlgorithmsImpl.scanAddI_loop(d.aI, d.rI1);\n@@ -241,1 +188,1 @@\n-        return VectorAlgorithmsImpl.scanAddI_loop_reassociate(aI, rI);\n+        return VectorAlgorithmsImpl.scanAddI_loop_reassociate(d.aI, d.rI1);\n@@ -246,1 +193,1 @@\n-        return VectorAlgorithmsImpl.scanAddI_VectorAPI_permute_add(aI, rI);\n+        return VectorAlgorithmsImpl.scanAddI_VectorAPI_permute_add(d.aI, d.rI1);\n@@ -251,1 +198,1 @@\n-        return VectorAlgorithmsImpl.findMinIndexI_loop(aI);\n+        return VectorAlgorithmsImpl.findMinIndexI_loop(d.aI);\n@@ -256,1 +203,1 @@\n-        return VectorAlgorithmsImpl.findMinIndexI_VectorAPI(aI);\n+        return VectorAlgorithmsImpl.findMinIndexI_VectorAPI(d.aI);\n@@ -264,3 +211,3 @@\n-        idx = (idx + 1) & 0xffff;\n-        int e = eI[idx];\n-        return VectorAlgorithmsImpl.findI_loop(aI, e);\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.findI_loop(d.aI, e);\n@@ -271,3 +218,3 @@\n-        idx = (idx + 1) & 0xffff;\n-        int e = eI[idx];\n-        return VectorAlgorithmsImpl.findI_VectorAPI(aI, e);\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.findI_VectorAPI(d.aI, e);\n@@ -278,1 +225,1 @@\n-        return VectorAlgorithmsImpl.reverseI_loop(aI, rI);\n+        return VectorAlgorithmsImpl.reverseI_loop(d.aI, d.rI1);\n@@ -283,1 +230,1 @@\n-        return VectorAlgorithmsImpl.reverseI_VectorAPI(aI, rI);\n+        return VectorAlgorithmsImpl.reverseI_VectorAPI(d.aI, d.rI1);\n@@ -291,3 +238,3 @@\n-        idx = (idx + 1) & 0xffff;\n-        int e = eI[idx];\n-        return VectorAlgorithmsImpl.filterI_loop(aI, rI, e);\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.filterI_loop(d.aI, d.rI1, e);\n@@ -298,3 +245,3 @@\n-        idx = (idx + 1) & 0xffff;\n-        int e = eI[idx];\n-        return VectorAlgorithmsImpl.filterI_VectorAPI(aI, rI, e);\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.filterI_VectorAPI(d.aI, d.rI1, e);\n@@ -305,1 +252,1 @@\n-        return VectorAlgorithmsImpl.reduceAddIFieldsX4_loop(oopsX4, memX4);\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_loop(d.oopsX4, d.memX4);\n@@ -310,1 +257,1 @@\n-        return VectorAlgorithmsImpl.reduceAddIFieldsX4_VectorAPI(oopsX4, memX4);\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_VectorAPI(d.oopsX4, d.memX4);\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java","additions":47,"deletions":100,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Random;\n@@ -41,0 +42,79 @@\n+    \/\/ This class stores the input and output arrays.\n+    \/\/ The constructor sets up all the data.\n+    \/\/\n+    \/\/ IMPORTANT:\n+    \/\/   If you want to use some array but do NOT modify it: just use it.\n+    \/\/   If you want to use it and DO want to modify it: clone it. This\n+    \/\/   ensures that each test gets a separate copy, and that when we\n+    \/\/   capture the modified arrays they are different for every method\n+    \/\/   and run.\n+    \/\/   An alternative to cloning is to use different return arrays for\n+    \/\/   different implementations of the same group, e.g. rI1, rI2, ...\n+    \/\/\n+    public static class Data {\n+        public int[] aI;\n+        public int[] rI1;\n+        public int[] rI2;\n+        public int[] rI3;\n+        public int[] rI4;\n+        public int[] eI;\n+        \/\/ The test has to use the same index into eI for all implementations. But in the\n+        \/\/ benchmark, we'd like to use random indices, so we use the index to advance through\n+        \/\/ the array.\n+        public int eI_idx = 0;\n+\n+        public float[] aF;\n+        public float[] bF;\n+\n+        public byte[] aB;\n+\n+        public int[] oopsX4;\n+        public int[] memX4;\n+\n+        public Data(int size, int seed, int numX4Objects) {\n+            Random random = new Random(seed);\n+\n+            \/\/ int: one input array and multiple output arrays so different implementations can\n+            \/\/ store their results to different arrays.\n+            aI = new int[size];\n+            rI1 = new int[size];\n+            rI2 = new int[size];\n+            rI3 = new int[size];\n+            rI4 = new int[size];\n+            Arrays.setAll(aI, i -> random.nextInt());\n+\n+            \/\/ Populate with some random values from aI, and some totally random values.\n+            eI = new int[0x10000];\n+            for (int i = 0; i < eI.length; i++) {\n+                eI[i] = (random.nextInt(10) == 0) ? random.nextInt() : aI[random.nextInt(size)];\n+            }\n+\n+            \/\/ X4 oop setup.\n+            \/\/ oopsX4 holds \"addresses\" (i.e. indices), that point to the 16-byte objects in memX4.\n+            oopsX4 = new int[size];\n+            memX4 = new int[numX4Objects * 4];\n+            for (int i = 0; i < size; i++) {\n+                \/\/ assign either a zero=null, or assign a random oop.\n+                oopsX4[i] = (random.nextInt(10) == 0) ? 0 : random.nextInt(numX4Objects) * 4;\n+            }\n+            \/\/ Just fill the whole array with random values.\n+            \/\/ The relevant field is only at every \"4 * i + 3\" though.\n+            memX4 = new int[4 * numX4Objects];\n+            for (int i = 0; i < memX4.length; i++) {\n+                memX4[i] = random.nextInt();\n+            }\n+\n+            \/\/ float inputs. To avoid rounding issues, only use small integers.\n+            aF = new float[size];\n+            bF = new float[size];\n+            for (int i = 0; i < size; i++) {\n+                aF[i] = random.nextInt(32) - 16;\n+                bF[i] = random.nextInt(32) - 16;\n+            }\n+\n+            \/\/ byte: just random data.\n+            aB = new byte[size];\n+            random.nextBytes(aB);\n+        }\n+    }\n+\n@@ -236,2 +316,1 @@\n-    \/\/\n-    \/\/ h(i) = 31 * h(i-1) + a[i]\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n@@ -239,3 +318,3 @@\n-    \/\/ h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n-    \/\/          -----------   ------------------------------------------------\n-    \/\/          scalar        vector: notice the powers of 31 in reverse\n+    \/\/   h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/            -----------   ------------------------------------------------\n+    \/\/            scalar        vector: notice the powers of 31 in reverse\n@@ -265,1 +344,0 @@\n-        var vnext = IntVector.broadcast(SPECIES_I256, next);\n@@ -274,1 +352,1 @@\n-            vresult = vresult.mul(vnext).add(vi);\n+            vresult = vresult.mul(next).add(vi);\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java","additions":85,"deletions":7,"binary":false,"changes":92,"status":"modified"}]}