{"files":[{"patch":"@@ -97,1 +97,2 @@\n-        framework.addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl::*\");\n+        framework.addFlags(\"--add-modules=jdk.incubator.vector\",\n+                           \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl*::*\");\n@@ -150,0 +151,1 @@\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v2\", () -> { return hashCodeB_VectorAPI_v2(aB); });\n@@ -198,0 +200,1 @@\n+                 \"hashCodeB_VectorAPI_v2\",\n@@ -437,1 +440,0 @@\n-                  IRNode.MUL_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n@@ -439,0 +441,1 @@\n+                  IRNode.MUL_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n@@ -446,0 +449,10 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,    \"> 0\",\n+                  IRNode.MUL_VI,           \"> 0\",\n+                  IRNode.ADD_VI,           \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(a);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -236,2 +236,1 @@\n-    \/\/\n-    \/\/ h(i) = 31 * h(i-1) + a[i]\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n@@ -239,3 +238,3 @@\n-    \/\/ h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n-    \/\/          -----------   ------------------------------------------------\n-    \/\/          scalar        vector: notice the powers of 31 in reverse\n+    \/\/   h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/            -----------   ------------------------------------------------\n+    \/\/            scalar        vector: notice the powers of 31 in reverse\n@@ -265,1 +264,0 @@\n-        var vnext = IntVector.broadcast(SPECIES_I256, next);\n@@ -274,1 +272,1 @@\n-            vresult = vresult.mul(vnext).add(vi);\n+            vresult = vresult.mul(next).add(vi);\n@@ -284,0 +282,112 @@\n+    \/\/ This second approach follows the idea from this blog post by Otmar Ertl:\n+    \/\/ https:\/\/www.dynatrace.com\/news\/blog\/java-arrays-hashcode-byte-efficiency-techniques\/\n+    \/\/\n+    \/\/ I simplified the algorithm a little, so that it is a bit closer\n+    \/\/ to the solution \"v1\" above.\n+    \/\/\n+    \/\/ The major issue with \"v1\" is that we cannot load a full vector of bytes,\n+    \/\/ because of the cast to ints. So we can only fill 1\/4 of the maximal\n+    \/\/ vector size. The trick here is to do an unrolling of factor 4, from:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ to:\n+    \/\/   h(i+4) = h(i) * 31^4 + a[i + 1] * 31^3\n+    \/\/                        + a[i + 2] * 31^2\n+    \/\/                        + a[i + 3] * 31^1\n+    \/\/                        + a[i + 4] * 31^0\n+    \/\/ The goal is now to compute this value for 4 bytes within a 4 byte\n+    \/\/ lane of the vector. One concern is that we start with byte values,\n+    \/\/ but need to do int-multiplication with powers of 31. If we instead\n+    \/\/ did a byte-multiplication, we could get overflows that we would not\n+    \/\/ have had in the int-multiplication.\n+    \/\/ One trick that helps with chaning the size of the lanes from byte\n+    \/\/ to short to int is doing all operations with unsigned integers. That\n+    \/\/ way, we can zero-extend instead of sign-bit extend. The first step\n+    \/\/ is thus to convert the bytes into unsigned values. Since byte is in\n+    \/\/ range [-128..128), doing \"a[i+j] + 128\" makes it a positive value,\n+    \/\/ allowing for unsigned multiplication.\n+    \/\/ h(i+4) = h(i) * 31^4 +   a[i + 1]              * 31^3\n+    \/\/                      +   a[i + 2]              * 31^2\n+    \/\/                      +   a[i + 3]              * 31^1\n+    \/\/                      +   a[i + 4]              * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128 - 128) * 31^3\n+    \/\/                      +  (a[i + 2] + 128 - 128) * 31^2\n+    \/\/                      +  (a[i + 3] + 128 - 128) * 31^1\n+    \/\/                      +  (a[i + 4] + 128 - 128) * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128      ) * 31^3\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      +  (a[i + 3] + 128      ) * 31^1\n+    \/\/                      +  (a[i + 4] + 128      ) * 31^0\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/        = h(i) * 31^4 + ((a[i + 1] + 128) * 31\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      + ((a[i + 3] + 128) * 31\n+    \/\/                      +  (a[i + 4] + 128      )\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/\n+    \/\/ Getting from the signed a[i] value to unsigned with +128, we can\n+    \/\/ just xor with 0x80=128. Any numbers there in range [-128..0) are\n+    \/\/ now in range [0..128). And any numbers that were in range [0..128)\n+    \/\/ are now in unsigned range [128..255). What a neat trick!\n+    \/\/\n+    \/\/ We then apply a byte->short transition where we crunch 2 bytes\n+    \/\/ into one short, applying a multiplication with 31 to one of the\n+    \/\/ two bytes. This multiplication cannot overflow in a short.\n+    \/\/ then we apply a short->int transition where we crunch 2 shorts\n+    \/\/ into one int, applying a multiplication with 31^2 to one of the\n+    \/\/ two shorts. This multiplication cannot overflow in an int.\n+    \/\/\n+    public static int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return HashCodeB_VectorAPI_V2.compute(a);\n+    }\n+\n+    private static class HashCodeB_VectorAPI_V2 {\n+        private static final int L = Math.min(ByteVector.SPECIES_PREFERRED.length(),\n+                                              IntVector.SPECIES_PREFERRED.length() * 4);\n+        private static final VectorShape SHAPE = VectorShape.forBitSize(8 * L);\n+        private static final VectorSpecies<Byte>    SPECIES_B = SHAPE.withLanes(byte.class);\n+        private static final VectorSpecies<Integer> SPECIES_I = SHAPE.withLanes(int.class);\n+\n+        private static int[] REVERSE_POWERS_OF_31_STEP_4 = new int[L \/ 4 + 1];\n+        static {\n+            int p = 1;\n+            int step = 31 * 31 * 31 * 31; \/\/ step by 4\n+            for (int i = REVERSE_POWERS_OF_31_STEP_4.length - 1; i >= 0; i--) {\n+                REVERSE_POWERS_OF_31_STEP_4[i] = p;\n+                p *= step;\n+            }\n+        }\n+\n+        public static int compute(byte[] a) {\n+            int result = 1; \/\/ initialValue\n+            int next = REVERSE_POWERS_OF_31_STEP_4[0]; \/\/ 31^L\n+            var vcoef = IntVector.fromArray(SPECIES_I, REVERSE_POWERS_OF_31_STEP_4, 1); \/\/ W\n+            var vresult = IntVector.zero(SPECIES_I);\n+            int i;\n+            for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+                var vb = ByteVector.fromArray(SPECIES_B, a, i);\n+                \/\/ Add 128 to each byte.\n+                var vs = vb.lanewise(VectorOperators.XOR, (byte)0x80)\n+                           .reinterpretAsShorts();\n+                \/\/ Each short lane contains 2 bytes, crunch them.\n+                var vi = vs.and((short)0xff) \/\/ lower byte\n+                           .mul((short)31)\n+                           .add(vs.lanewise(VectorOperators.LSHR, 8)) \/\/ upper byte\n+                           .reinterpretAsInts();\n+                \/\/ Each int contains 2 shorts, crunch them.\n+                var v  = vi.and(0xffff) \/\/ lower short\n+                           .mul(31 * 31)\n+                           .add(vi.lanewise(VectorOperators.LSHR, 16)); \/\/ upper short\n+                \/\/ Add the correction for the 128 additions above.\n+                v = v.add(-128 * (31*31*31 + 31*31 + 31 + 1));\n+                \/\/ Every element of v now contains a crunched int-package of 4 bytes.\n+                result *= next;\n+                vresult = vresult.mul(next).add(v);\n+            }\n+            result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+            for (; i < a.length; i++) {\n+                result = 31 * result + a[i];\n+            }\n+            return result;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java","additions":117,"deletions":7,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -229,0 +229,5 @@\n+    @Benchmark\n+    public int hashCodeB_VectorAPI_v2() {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(aB);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -284,0 +284,112 @@\n+    \/\/ This second approach follows the idea from this blog post by Otmar Ertl:\n+    \/\/ https:\/\/www.dynatrace.com\/news\/blog\/java-arrays-hashcode-byte-efficiency-techniques\/\n+    \/\/\n+    \/\/ I simplified the algorithm a little, so that it is a bit closer\n+    \/\/ to the solution \"v1\" above.\n+    \/\/\n+    \/\/ The major issue with \"v1\" is that we cannot load a full vector of bytes,\n+    \/\/ because of the cast to ints. So we can only fill 1\/4 of the maximal\n+    \/\/ vector size. The trick here is to do an unrolling of factor 4, from:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ to:\n+    \/\/   h(i+4) = h(i) * 31^4 + a[i + 1] * 31^3\n+    \/\/                        + a[i + 2] * 31^2\n+    \/\/                        + a[i + 3] * 31^1\n+    \/\/                        + a[i + 4] * 31^0\n+    \/\/ The goal is now to compute this value for 4 bytes within a 4 byte\n+    \/\/ lane of the vector. One concern is that we start with byte values,\n+    \/\/ but need to do int-multiplication with powers of 31. If we instead\n+    \/\/ did a byte-multiplication, we could get overflows that we would not\n+    \/\/ have had in the int-multiplication.\n+    \/\/ One trick that helps with chaning the size of the lanes from byte\n+    \/\/ to short to int is doing all operations with unsigned integers. That\n+    \/\/ way, we can zero-extend instead of sign-bit extend. The first step\n+    \/\/ is thus to convert the bytes into unsigned values. Since byte is in\n+    \/\/ range [-128..128), doing \"a[i+j] + 128\" makes it a positive value,\n+    \/\/ allowing for unsigned multiplication.\n+    \/\/ h(i+4) = h(i) * 31^4 +   a[i + 1]              * 31^3\n+    \/\/                      +   a[i + 2]              * 31^2\n+    \/\/                      +   a[i + 3]              * 31^1\n+    \/\/                      +   a[i + 4]              * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128 - 128) * 31^3\n+    \/\/                      +  (a[i + 2] + 128 - 128) * 31^2\n+    \/\/                      +  (a[i + 3] + 128 - 128) * 31^1\n+    \/\/                      +  (a[i + 4] + 128 - 128) * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128      ) * 31^3\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      +  (a[i + 3] + 128      ) * 31^1\n+    \/\/                      +  (a[i + 4] + 128      ) * 31^0\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/        = h(i) * 31^4 + ((a[i + 1] + 128) * 31\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      + ((a[i + 3] + 128) * 31\n+    \/\/                      +  (a[i + 4] + 128      )\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/\n+    \/\/ Getting from the signed a[i] value to unsigned with +128, we can\n+    \/\/ just xor with 0x80=128. Any numbers there in range [-128..0) are\n+    \/\/ now in range [0..128). And any numbers that were in range [0..128)\n+    \/\/ are now in unsigned range [128..255). What a neat trick!\n+    \/\/\n+    \/\/ We then apply a byte->short transition where we crunch 2 bytes\n+    \/\/ into one short, applying a multiplication with 31 to one of the\n+    \/\/ two bytes. This multiplication cannot overflow in a short.\n+    \/\/ then we apply a short->int transition where we crunch 2 shorts\n+    \/\/ into one int, applying a multiplication with 31^2 to one of the\n+    \/\/ two shorts. This multiplication cannot overflow in an int.\n+    \/\/\n+    public static int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return HashCodeB_VectorAPI_V2.compute(a);\n+    }\n+\n+    private static class HashCodeB_VectorAPI_V2 {\n+        private static final int L = Math.min(ByteVector.SPECIES_PREFERRED.length(),\n+                                              IntVector.SPECIES_PREFERRED.length() * 4);\n+        private static final VectorShape SHAPE = VectorShape.forBitSize(8 * L);\n+        private static final VectorSpecies<Byte>    SPECIES_B = SHAPE.withLanes(byte.class);\n+        private static final VectorSpecies<Integer> SPECIES_I = SHAPE.withLanes(int.class);\n+\n+        private static int[] REVERSE_POWERS_OF_31_STEP_4 = new int[L \/ 4 + 1];\n+        static {\n+            int p = 1;\n+            int step = 31 * 31 * 31 * 31; \/\/ step by 4\n+            for (int i = REVERSE_POWERS_OF_31_STEP_4.length - 1; i >= 0; i--) {\n+                REVERSE_POWERS_OF_31_STEP_4[i] = p;\n+                p *= step;\n+            }\n+        }\n+\n+        public static int compute(byte[] a) {\n+            int result = 1; \/\/ initialValue\n+            int next = REVERSE_POWERS_OF_31_STEP_4[0]; \/\/ 31^L\n+            var vcoef = IntVector.fromArray(SPECIES_I, REVERSE_POWERS_OF_31_STEP_4, 1); \/\/ W\n+            var vresult = IntVector.zero(SPECIES_I);\n+            int i;\n+            for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+                var vb = ByteVector.fromArray(SPECIES_B, a, i);\n+                \/\/ Add 128 to each byte.\n+                var vs = vb.lanewise(VectorOperators.XOR, (byte)0x80)\n+                           .reinterpretAsShorts();\n+                \/\/ Each short lane contains 2 bytes, crunch them.\n+                var vi = vs.and((short)0xff) \/\/ lower byte\n+                           .mul((short)31)\n+                           .add(vs.lanewise(VectorOperators.LSHR, 8)) \/\/ upper byte\n+                           .reinterpretAsInts();\n+                \/\/ Each int contains 2 shorts, crunch them.\n+                var v  = vi.and(0xffff) \/\/ lower short\n+                           .mul(31 * 31)\n+                           .add(vi.lanewise(VectorOperators.LSHR, 16)); \/\/ upper short\n+                \/\/ Add the correction for the 128 additions above.\n+                v = v.add(-128 * (31*31*31 + 31*31 + 31 + 1));\n+                \/\/ Every element of v now contains a crunched int-package of 4 bytes.\n+                result *= next;\n+                vresult = vresult.mul(next).add(v);\n+            }\n+            result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+            for (; i < a.length; i++) {\n+                result = 31 * result + a[i];\n+            }\n+            return result;\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"}]}