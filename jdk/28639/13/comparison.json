{"files":[{"patch":"@@ -0,0 +1,555 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8373026\n+ * @summary Test auto vectorization and Vector API with some vector\n+ *          algorithms. Related benchmark: VectorAlgorithms.java\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=noSuperWord\n+ * @bug 8373026\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ * @run driver ${test.main.class} -XX:-UseSuperWord\n+ *\/\n+\n+\/*\n+ * @test id=noOptimizeFill\n+ * @bug 8373026\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ * @run driver ${test.main.class} -XX:-OptimizeFill\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+import static compiler.lib.generators.Generators.G;\n+import compiler.lib.verify.*;\n+\n+\/**\n+ * The goal of this benchmark is to show the power of auto vectorization\n+ * and the Vector API.\n+ *\n+ * Please only modify this benchark in synchronization with the JMH benchmark:\n+ *   micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java\n+ *\/\n+public class TestVectorAlgorithms {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final RestrictableGenerator<Integer> INT_GEN = Generators.G.ints();\n+\n+    interface TestFunction {\n+        Object run(int i);\n+    }\n+\n+    Map<String, Map<String, TestFunction>> testGroups = new HashMap<String, Map<String, TestFunction>>();\n+\n+    VectorAlgorithmsImpl.Data d;\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"--add-modules=jdk.incubator.vector\",\n+                           \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl*::*\");\n+        framework.addFlags(args);\n+        framework.start();\n+    }\n+\n+    public TestVectorAlgorithms () {\n+        testGroups.put(\"fillI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"fillI\").put(\"fillI_loop\",      i -> { return fillI_loop(d.rI1); });\n+        testGroups.get(\"fillI\").put(\"fillI_VectorAPI\", i -> { return fillI_VectorAPI(d.rI2); });\n+        testGroups.get(\"fillI\").put(\"fillI_Arrays\",    i -> { return fillI_Arrays(d.rI3); });\n+\n+        testGroups.put(\"iotaI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"iotaI\").put(\"iotaI_loop\",      i -> { return iotaI_loop(d.rI1); });\n+        testGroups.get(\"iotaI\").put(\"iotaI_VectorAPI\", i -> { return iotaI_VectorAPI(d.rI2); });\n+\n+        testGroups.put(\"copyI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"copyI\").put(\"copyI_loop\",             i -> { return copyI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"copyI\").put(\"copyI_VectorAPI\",        i -> { return copyI_VectorAPI(d.aI, d.rI2); });\n+        testGroups.get(\"copyI\").put(\"copyI_System_arraycopy\", i -> { return copyI_System_arraycopy(d.aI, d.rI3); });\n+\n+        testGroups.put(\"mapI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"mapI\").put(\"mapI_loop\",      i -> { return mapI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"mapI\").put(\"mapI_VectorAPI\", i -> { return mapI_VectorAPI(d.aI, d.rI2); });\n+\n+        testGroups.put(\"reduceAddI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_loop\",                           i -> { return reduceAddI_loop(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_reassociate\",                    i -> { return reduceAddI_reassociate(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_naive\",                i -> { return reduceAddI_VectorAPI_naive(d.aI); });\n+        testGroups.get(\"reduceAddI\").put(\"reduceAddI_VectorAPI_reduction_after_loop\", i -> { return reduceAddI_VectorAPI_reduction_after_loop(d.aI); });\n+\n+        testGroups.put(\"dotProductF\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_loop\",                           i -> { return dotProductF_loop(d.aF, d.bF); });\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_naive\",                i -> { return dotProductF_VectorAPI_naive(d.aF, d.bF); });\n+        testGroups.get(\"dotProductF\").put(\"dotProductF_VectorAPI_reduction_after_loop\", i -> { return dotProductF_VectorAPI_reduction_after_loop(d.aF, d.bF); });\n+\n+        testGroups.put(\"hashCodeB\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_loop\",         i -> { return hashCodeB_loop(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_Arrays\",       i -> { return hashCodeB_Arrays(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v1\", i -> { return hashCodeB_VectorAPI_v1(d.aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v2\", i -> { return hashCodeB_VectorAPI_v2(d.aB); });\n+\n+        testGroups.put(\"scanAddI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_loop\",                      i -> { return scanAddI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_loop_reassociate\",          i -> { return scanAddI_loop_reassociate(d.aI, d.rI2); });\n+        testGroups.get(\"scanAddI\").put(\"scanAddI_VectorAPI_permute_add\",     i -> { return scanAddI_VectorAPI_permute_add(d.aI, d.rI4); });\n+\n+        testGroups.put(\"findMinIndexI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_loop\",      i -> { return findMinIndexI_loop(d.aI); });\n+        testGroups.get(\"findMinIndexI\").put(\"findMinIndexI_VectorAPI\", i -> { return findMinIndexI_VectorAPI(d.aI); });\n+\n+        testGroups.put(\"findI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"findI\").put(\"findI_loop\",      i -> { return findI_loop(d.aI, d.eI[i]); });\n+        testGroups.get(\"findI\").put(\"findI_VectorAPI\", i -> { return findI_VectorAPI(d.aI, d.eI[i]); });\n+\n+        testGroups.put(\"reverseI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"reverseI\").put(\"reverseI_loop\",      i -> { return reverseI_loop(d.aI, d.rI1); });\n+        testGroups.get(\"reverseI\").put(\"reverseI_VectorAPI\", i -> { return reverseI_VectorAPI(d.aI, d.rI2); });\n+\n+        testGroups.put(\"filterI\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"filterI\").put(\"filterI_loop\",      i -> { return filterI_loop(d.aI, d.rI1, d.eI[i]); });\n+        testGroups.get(\"filterI\").put(\"filterI_VectorAPI\", i -> { return filterI_VectorAPI(d.aI, d.rI2, d.eI[i]); });\n+\n+        testGroups.put(\"reduceAddIFieldsX4\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_loop\",      i -> { return reduceAddIFieldsX4_loop(d.oopsX4, d.memX4); });\n+        testGroups.get(\"reduceAddIFieldsX4\").put(\"reduceAddIFieldsX4_VectorAPI\", i -> { return reduceAddIFieldsX4_VectorAPI(d.oopsX4, d.memX4); });\n+\n+        testGroups.put(\"lowerCaseB\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_loop\",         i -> { return lowerCaseB_loop(d.strB, d.rB1); });\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_VectorAPI_v1\", i -> { return lowerCaseB_VectorAPI_v1(d.strB, d.rB2); });\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_VectorAPI_v2\", i -> { return lowerCaseB_VectorAPI_v2(d.strB, d.rB3); });\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"fillI_loop\",\n+                 \"fillI_VectorAPI\",\n+                 \"fillI_Arrays\",\n+                 \"iotaI_loop\",\n+                 \"iotaI_VectorAPI\",\n+                 \"copyI_loop\",\n+                 \"copyI_VectorAPI\",\n+                 \"copyI_System_arraycopy\",\n+                 \"mapI_loop\",\n+                 \"mapI_VectorAPI\",\n+                 \"reduceAddI_loop\",\n+                 \"reduceAddI_reassociate\",\n+                 \"reduceAddI_VectorAPI_naive\",\n+                 \"reduceAddI_VectorAPI_reduction_after_loop\",\n+                 \"dotProductF_loop\",\n+                 \"dotProductF_VectorAPI_naive\",\n+                 \"dotProductF_VectorAPI_reduction_after_loop\",\n+                 \"hashCodeB_loop\",\n+                 \"hashCodeB_Arrays\",\n+                 \"hashCodeB_VectorAPI_v1\",\n+                 \"hashCodeB_VectorAPI_v2\",\n+                 \"scanAddI_loop\",\n+                 \"scanAddI_loop_reassociate\",\n+                 \"scanAddI_VectorAPI_permute_add\",\n+                 \"findMinIndexI_loop\",\n+                 \"findMinIndexI_VectorAPI\",\n+                 \"findI_loop\",\n+                 \"findI_VectorAPI\",\n+                 \"reverseI_loop\",\n+                 \"reverseI_VectorAPI\",\n+                 \"filterI_loop\",\n+                 \"filterI_VectorAPI\",\n+                 \"reduceAddIFieldsX4_loop\",\n+                 \"reduceAddIFieldsX4_VectorAPI\",\n+                 \"lowerCaseB_loop\",\n+                 \"lowerCaseB_VectorAPI_v1\",\n+                 \"lowerCaseB_VectorAPI_v2\"})\n+    public void runTests(RunInfo info) {\n+        \/\/ Repeat many times, so that we also have multiple iterations for post-warmup to potentially recompile\n+        int iters = info.isWarmUp() ? 1 : 20;\n+        for (int iter = 0; iter < iters; iter++) {\n+            \/\/ Set up random inputs, random size is important to stress tails.\n+            int size = 100_000 + RANDOM.nextInt(10_000);\n+            int seed = RANDOM.nextInt();\n+            int numXObjects = 10_000;\n+            d = new VectorAlgorithmsImpl.Data(size, seed, numXObjects);\n+\n+            \/\/ Run all tests\n+            for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+                String group_name = group_entry.getKey();\n+                Map<String, TestFunction> group = group_entry.getValue();\n+                Object gold = null;\n+                String gold_name = \"NONE\";\n+                for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                    String name = entry.getKey();\n+                    TestFunction test = entry.getValue();\n+                    Object result = test.run(iter);\n+                    if (gold == null) {\n+                        gold = result;\n+                        gold_name = name;\n+                    } else {\n+                        try {\n+                            Verify.checkEQ(gold, result);\n+                        } catch (VerifyException e) {\n+                            throw new RuntimeException(\"Verify.checkEQ failed for group \" + group_name +\n+                                                       \", gold \" + gold_name + \", test \" + name, e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,  \"= 1\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfAnd = {\"UseSuperWord\", \"true\", \"OptimizeFill\", \"false\"})\n+    @IR(counts = {\".*CallLeafNoFP.*jint_fill.*\", \"= 1\"},\n+        phase = CompilePhase.BEFORE_MATCHING,\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"})\n+    \/\/ By default, the fill intrinsic \"jint_fill\" is used, but we can disable\n+    \/\/ the detection of the fill loop, and then we auto vectorize.\n+    public Object fillI_loop(int[] r) {\n+        return VectorAlgorithmsImpl.fillI_loop(r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,  \"= 1\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object fillI_VectorAPI(int[] r) {\n+        return VectorAlgorithmsImpl.fillI_VectorAPI(r);\n+    }\n+\n+    @Test\n+    \/\/ Arrays.fill is not necessarily inlined, so we can't check\n+    \/\/ for vectors in the IR.\n+    public Object fillI_Arrays(int[] r) {\n+        return VectorAlgorithmsImpl.fillI_Arrays(r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.POPULATE_INDEX, \"> 0\",\n+                  IRNode.STORE_VECTOR,   \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    \/\/ Note: the Vector API example below can also vectorize for AVX,\n+    \/\/       because it does not use a PopulateIndex.\n+    public Object iotaI_loop(int[] r) {\n+        return VectorAlgorithmsImpl.iotaI_loop(r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI,       \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object iotaI_VectorAPI(int[] r) {\n+        return VectorAlgorithmsImpl.iotaI_VectorAPI(r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    public Object copyI_loop(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.copyI_loop(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object copyI_VectorAPI(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.copyI_VectorAPI(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {\".*CallLeafNoFP.*jint_disjoint_arraycopy.*\", \"= 1\"},\n+        phase = CompilePhase.BEFORE_MATCHING,\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object copyI_System_arraycopy(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.copyI_System_arraycopy(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.MUL_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    public Object mapI_loop(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.mapI_loop(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.MUL_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object mapI_VectorAPI(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.mapI_VectorAPI(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\",\n+                  IRNode.ADD_VI,           \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    public int reduceAddI_loop(int[] a) {\n+        return VectorAlgorithmsImpl.reduceAddI_loop(a);\n+    }\n+\n+    @Test\n+    public int reduceAddI_reassociate(int[] a) {\n+        return VectorAlgorithmsImpl.reduceAddI_reassociate(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\"}, \/\/ reduceLanes inside loop\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public int reduceAddI_VectorAPI_naive(int[] a) {\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F,   \"> 0\",\n+                  IRNode.ADD_REDUCTION_V, \"> 0\",\n+                  IRNode.MUL_VF,          \"> 0\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    \/\/ See also TestReduction.floatAddDotProduct\n+    public float dotProductF_loop(float[] a, float[] b) {\n+        return VectorAlgorithmsImpl.dotProductF_loop(a, b);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F,   \"> 0\",\n+                  IRNode.ADD_REDUCTION_V, \"> 0\",\n+                  IRNode.MUL_VF,          \"> 0\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    public float dotProductF_VectorAPI_naive(float[] a, float[] b) {\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_naive(a, b);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F,   \"> 0\",\n+                  IRNode.ADD_REDUCTION_V, \"> 0\",\n+                  IRNode.MUL_VF,          \"> 0\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIf = {\"UseSuperWord\", \"true\"})\n+    public float dotProductF_VectorAPI_reduction_after_loop(float[] a, float[] b) {\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_reduction_after_loop(a, b);\n+    }\n+\n+    @Test\n+    public int hashCodeB_loop(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_loop(a);\n+    }\n+\n+    @Test\n+    public int hashCodeB_Arrays(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_Arrays(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,    IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.VECTOR_CAST_B2I,  IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.MUL_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI,                       \"> 0\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public int hashCodeB_VectorAPI_v1(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,    \"> 0\",\n+                  IRNode.MUL_VI,           \"> 0\",\n+                  IRNode.ADD_VI,           \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\",\n+                  IRNode.ADD_VI,           \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public int reduceAddI_VectorAPI_reduction_after_loop(int[] a) {\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public Object scanAddI_loop(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.scanAddI_loop(a, r);\n+    }\n+\n+    @Test\n+    public Object scanAddI_loop_reassociate(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.scanAddI_loop_reassociate(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    \"> 0\",\n+                  IRNode.REARRANGE_VI,     \"> 0\",\n+                  IRNode.AND_VI,           \"> 0\",\n+                  IRNode.ADD_VI,           \"> 0\",\n+                  IRNode.STORE_VECTOR,     \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public Object scanAddI_VectorAPI_permute_add(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.scanAddI_VectorAPI_permute_add(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public int findMinIndexI_loop(int[] a) {\n+        return VectorAlgorithmsImpl.findMinIndexI_loop(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   \"> 0\",\n+                  IRNode.VECTOR_MASK_CMP, \"> 0\",\n+                  IRNode.VECTOR_BLEND_I,  \"> 0\",\n+                  IRNode.MIN_REDUCTION_V, \"> 0\",\n+                  IRNode.ADD_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public int findMinIndexI_VectorAPI(int[] a) {\n+        return VectorAlgorithmsImpl.findMinIndexI_VectorAPI(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public int findI_loop(int[] a, int e) {\n+        return VectorAlgorithmsImpl.findI_loop(a, e);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   \"> 0\",\n+                  IRNode.VECTOR_MASK_CMP, \"> 0\",\n+                  IRNode.VECTOR_TEST,     \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public int findI_VectorAPI(int[] a, int e) {\n+        return VectorAlgorithmsImpl.findI_VectorAPI(a, e);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public Object reverseI_loop(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.reverseI_loop(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    \"> 0\",\n+                  IRNode.REARRANGE_VI,     \"> 0\",\n+                  IRNode.AND_VI,           \"> 0\",\n+                  IRNode.STORE_VECTOR,     \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object reverseI_VectorAPI(int[] a, int[] r) {\n+        return VectorAlgorithmsImpl.reverseI_VectorAPI(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"})\n+    public Object filterI_loop(int[] a, int[] r, int threshold) {\n+        return VectorAlgorithmsImpl.filterI_loop(a, r, threshold);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,       \"> 0\",\n+                  IRNode.VECTOR_MASK_CMP,     \"> 0\",\n+                  IRNode.VECTOR_TEST,         \"> 0\",\n+                  IRNode.COMPRESS_VI,         \"> 0\",\n+                  IRNode.STORE_VECTOR_MASKED, \"> 0\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public Object filterI_VectorAPI(int[] a, int[] r, int threshold) {\n+        return VectorAlgorithmsImpl.filterI_VectorAPI(a, r, threshold);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public int reduceAddIFieldsX4_loop(int[] oops, int[] mem) {\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_loop(oops, mem);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,             \"> 0\",\n+                  IRNode.VECTOR_MASK_CMP,           \"> 0\",\n+                  IRNode.VECTOR_TEST,               \"> 0\",\n+                  IRNode.LOAD_VECTOR_GATHER_MASKED, \"> 0\",\n+                  IRNode.OR_V_MASK,                 \"> 0\",\n+                  IRNode.ADD_VI,                    \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI,          \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public int reduceAddIFieldsX4_VectorAPI(int[] oops, int[] mem) {\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_VectorAPI(oops, mem);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_loop(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v1(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v2(a, r);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java","additions":555,"deletions":0,"binary":false,"changes":555,"status":"added"},{"patch":"@@ -0,0 +1,774 @@\n+\/*\n+ *  Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * The code below is supposed to be an exact copy of:\n+ *   micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java\n+ *\/\n+public class VectorAlgorithmsImpl {\n+    private static final VectorSpecies<Integer> SPECIES_I    = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> SPECIES_I512 = IntVector.SPECIES_512;\n+    private static final VectorSpecies<Integer> SPECIES_I256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Byte> SPECIES_B       = ByteVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> SPECIES_B64     = ByteVector.SPECIES_64;\n+    private static final VectorSpecies<Float> SPECIES_F      = FloatVector.SPECIES_PREFERRED;\n+\n+    \/\/ This class stores the input and output arrays.\n+    \/\/ The constructor sets up all the data.\n+    \/\/\n+    \/\/ IMPORTANT:\n+    \/\/   If you want to use some array but do NOT modify it: just use it.\n+    \/\/   If you want to use it and DO want to modify it: clone it. This\n+    \/\/   ensures that each test gets a separate copy, and that when we\n+    \/\/   capture the modified arrays they are different for every method\n+    \/\/   and run.\n+    \/\/   An alternative to cloning is to use different return arrays for\n+    \/\/   different implementations of the same group, e.g. rI1, rI2, ...\n+    \/\/\n+    public static class Data {\n+        public int[] aI;\n+        public int[] rI1;\n+        public int[] rI2;\n+        public int[] rI3;\n+        public int[] rI4;\n+        public int[] eI;\n+        \/\/ The test has to use the same index into eI for all implementations. But in the\n+        \/\/ benchmark, we'd like to use random indices, so we use the index to advance through\n+        \/\/ the array.\n+        public int eI_idx = 0;\n+\n+        public float[] aF;\n+        public float[] bF;\n+\n+        public byte[] aB;\n+        public byte[] strB;\n+        public byte[] rB1;\n+        public byte[] rB2;\n+        public byte[] rB3;\n+\n+        public int[] oopsX4;\n+        public int[] memX4;\n+\n+        public Data(int size, int seed, int numX4Objects) {\n+            Random random = new Random(seed);\n+\n+            \/\/ int: one input array and multiple output arrays so different implementations can\n+            \/\/ store their results to different arrays.\n+            aI = new int[size];\n+            rI1 = new int[size];\n+            rI2 = new int[size];\n+            rI3 = new int[size];\n+            rI4 = new int[size];\n+            Arrays.setAll(aI, i -> random.nextInt());\n+\n+            \/\/ Populate with some random values from aI, and some totally random values.\n+            eI = new int[0x10000];\n+            for (int i = 0; i < eI.length; i++) {\n+                eI[i] = (random.nextInt(10) == 0) ? random.nextInt() : aI[random.nextInt(size)];\n+            }\n+\n+            \/\/ X4 oop setup.\n+            \/\/ oopsX4 holds \"addresses\" (i.e. indices), that point to the 16-byte objects in memX4.\n+            oopsX4 = new int[size];\n+            memX4 = new int[numX4Objects * 4];\n+            for (int i = 0; i < size; i++) {\n+                \/\/ assign either a zero=null, or assign a random oop.\n+                oopsX4[i] = (random.nextInt(10) == 0) ? 0 : random.nextInt(numX4Objects) * 4;\n+            }\n+            \/\/ Just fill the whole array with random values.\n+            \/\/ The relevant field is only at every \"4 * i + 3\" though.\n+            memX4 = new int[4 * numX4Objects];\n+            for (int i = 0; i < memX4.length; i++) {\n+                memX4[i] = random.nextInt();\n+            }\n+\n+            \/\/ float inputs. To avoid rounding issues, only use small integers.\n+            aF = new float[size];\n+            bF = new float[size];\n+            for (int i = 0; i < size; i++) {\n+                aF[i] = random.nextInt(32) - 16;\n+                bF[i] = random.nextInt(32) - 16;\n+            }\n+\n+            \/\/ byte: just random data.\n+            aB = new byte[size];\n+            strB = new byte[size];\n+            rB1 = new byte[size];\n+            rB2 = new byte[size];\n+            rB3 = new byte[size];\n+            random.nextBytes(aB);\n+            random.nextBytes(strB); \/\/ TODO: special data!\n+        }\n+    }\n+\n+    public static Object fillI_loop(int[] r) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object fillI_Arrays(int[] r) {\n+        Arrays.fill(r, 42);\n+        return r;\n+    }\n+\n+    public static Object fillI_VectorAPI(int[] r) {\n+        var v = IntVector.broadcast(SPECIES_I, 42);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object iotaI_loop(int[] r) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = i;\n+        }\n+        return r;\n+    }\n+\n+    public static Object iotaI_VectorAPI(int[] r) {\n+        var iota = IntVector.broadcast(SPECIES_I, 0).addIndex(1);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            iota.intoArray(r, i);\n+            iota = iota.add(SPECIES_I.length());\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = i;\n+        }\n+        return r;\n+    }\n+\n+    public static Object copyI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object copyI_System_arraycopy(int[] a, int[] r) {\n+        System.arraycopy(a, 0, r, 0, a.length);\n+        return r;\n+    }\n+\n+    public static Object copyI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object mapI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = a[i] * 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object mapI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v = v.mul(42);\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = a[i] * 42;\n+        }\n+        return r;\n+    }\n+\n+    public static int reduceAddI_loop(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Relying on simple reduction loop should vectorize since JDK26.\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_reassociate(int[] a) {\n+        int sum = 0;\n+        int i;\n+        for (i = 0; i < a.length - 3; i += 4) {\n+            \/\/ Unroll 4x, reassociate inside.\n+            sum += a[i] + a[i + 1] + a[i + 2] + a[i + 3];\n+        }\n+        for (; i < a.length; i++) {\n+            \/\/ Tail\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_VectorAPI_naive(int[] a) {\n+        var sum = 0;\n+        int i;\n+        for (i = 0; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            \/\/ reduceLanes in loop is better than scalar performance, but still\n+            \/\/ relatively slow.\n+            sum += v.reduceLanes(VectorOperators.ADD);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_VectorAPI_reduction_after_loop(int[] a) {\n+        var acc = IntVector.broadcast(SPECIES_I, 0);\n+        int i;\n+        for (i = 0; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            \/\/ Element-wide addition into a vector of partial sums is much faster.\n+            \/\/ Now, we only need to do a reduceLanes after the loop.\n+            \/\/ This works because int-addition is associative and commutative.\n+            acc = acc.add(v);\n+        }\n+        int sum = acc.reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_loop(float[] a, float[] b) {\n+        float sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_VectorAPI_naive(float[] a, float[] b) {\n+        float sum = 0;\n+        int i;\n+        for (i = 0; i < SPECIES_F.loopBound(a.length); i += SPECIES_F.length()) {\n+            var va = FloatVector.fromArray(SPECIES_F, a, i);\n+            var vb = FloatVector.fromArray(SPECIES_F, b, i);\n+            sum += va.mul(vb).reduceLanes(VectorOperators.ADD);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_VectorAPI_reduction_after_loop(float[] a, float[] b) {\n+        var sums = FloatVector.broadcast(SPECIES_F, 0.0f);\n+        int i;\n+        for (i = 0; i < SPECIES_F.loopBound(a.length); i += SPECIES_F.length()) {\n+            var va = FloatVector.fromArray(SPECIES_F, a, i);\n+            var vb = FloatVector.fromArray(SPECIES_F, b, i);\n+            sums = sums.add(va.mul(vb));\n+        }\n+        float sum = sums.reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int hashCodeB_loop(byte[] a) {\n+        int h = 1;\n+        for (int i = 0; i < a.length; i++) {\n+            h = 31 * h + a[i];\n+        }\n+        return h;\n+    }\n+\n+    public static int hashCodeB_Arrays(byte[] a) {\n+        return Arrays.hashCode(a);\n+    }\n+\n+    \/\/ Simplified intrinsic code from C2_MacroAssembler::arrays_hashcode in c2_MacroAssembler_x86.cpp\n+    \/\/\n+    \/\/ Ideas that may help understand the code:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ \"unroll\" by factor of L=8:\n+    \/\/   h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/            -----------   ------------------------------------------------\n+    \/\/            scalar        vector: notice the powers of 31 in reverse\n+    \/\/\n+    \/\/ We notice that we can load a[i+1 .. i+8], then element-wise multiply with\n+    \/\/ the vector of reversed powers-of-31, and then do reduceLanes(ADD).\n+    \/\/ But we can do even better: By looking at multiple such 8-unrolled iterations.\n+    \/\/ Instead of applying the \"next\" factor of \"31^8\" to the reduced scalar, we can\n+    \/\/ already apply it element-wise. That allows us to move the reduction out\n+    \/\/ of the loop.\n+    \/\/\n+    \/\/ Note: the intrinsic additionally unrolls the loop by a factor of 4,\n+    \/\/       but we want to keep thins simple for demonstration purposes.\n+    \/\/\n+    private static int[] REVERSE_POWERS_OF_31 = new int[9];\n+    static {\n+        int p = 1;\n+        for (int i = REVERSE_POWERS_OF_31.length - 1; i >= 0; i--) {\n+            REVERSE_POWERS_OF_31[i] = p;\n+            p *= 31;\n+        }\n+    }\n+    public static int hashCodeB_VectorAPI_v1(byte[] a) {\n+        int result = 1; \/\/ initialValue\n+        var vresult = IntVector.zero(SPECIES_I256);\n+        int next = REVERSE_POWERS_OF_31[0]; \/\/ 31^L\n+        var vcoef = IntVector.fromArray(SPECIES_I256, REVERSE_POWERS_OF_31, 1); \/\/ powers of 2 in reverse\n+        int i;\n+        for (i = 0; i < SPECIES_B64.loopBound(a.length); i += SPECIES_B64.length()) {\n+            \/\/ scalar part: result *= 31^L\n+            result *= next;\n+            \/\/ vector part: element-wise apply the next factor and add in the new values.\n+            var vb = ByteVector.fromArray(SPECIES_B64, a, i);\n+            var vi = vb.castShape(SPECIES_I256, 0);\n+            vresult = vresult.mul(next).add(vi);\n+        }\n+        \/\/ reduce the partial hashes in the elements, using the reverse list of powers of 2.\n+        result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    \/\/ This second approach follows the idea from this blog post by Otmar Ertl:\n+    \/\/ https:\/\/www.dynatrace.com\/news\/blog\/java-arrays-hashcode-byte-efficiency-techniques\/\n+    \/\/\n+    \/\/ I simplified the algorithm a little, so that it is a bit closer\n+    \/\/ to the solution \"v1\" above.\n+    \/\/\n+    \/\/ The major issue with \"v1\" is that we cannot load a full vector of bytes,\n+    \/\/ because of the cast to ints. So we can only fill 1\/4 of the maximal\n+    \/\/ vector size. The trick here is to do an unrolling of factor 4, from:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ to:\n+    \/\/   h(i+4) = h(i) * 31^4 + a[i + 1] * 31^3\n+    \/\/                        + a[i + 2] * 31^2\n+    \/\/                        + a[i + 3] * 31^1\n+    \/\/                        + a[i + 4] * 31^0\n+    \/\/ The goal is now to compute this value for 4 bytes within a 4 byte\n+    \/\/ lane of the vector. One concern is that we start with byte values,\n+    \/\/ but need to do int-multiplication with powers of 31. If we instead\n+    \/\/ did a byte-multiplication, we could get overflows that we would not\n+    \/\/ have had in the int-multiplication.\n+    \/\/ One trick that helps with chaning the size of the lanes from byte\n+    \/\/ to short to int is doing all operations with unsigned integers. That\n+    \/\/ way, we can zero-extend instead of sign-bit extend. The first step\n+    \/\/ is thus to convert the bytes into unsigned values. Since byte is in\n+    \/\/ range [-128..128), doing \"a[i+j] + 128\" makes it a positive value,\n+    \/\/ allowing for unsigned multiplication.\n+    \/\/ h(i+4) = h(i) * 31^4 +   a[i + 1]              * 31^3\n+    \/\/                      +   a[i + 2]              * 31^2\n+    \/\/                      +   a[i + 3]              * 31^1\n+    \/\/                      +   a[i + 4]              * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128 - 128) * 31^3\n+    \/\/                      +  (a[i + 2] + 128 - 128) * 31^2\n+    \/\/                      +  (a[i + 3] + 128 - 128) * 31^1\n+    \/\/                      +  (a[i + 4] + 128 - 128) * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128      ) * 31^3\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      +  (a[i + 3] + 128      ) * 31^1\n+    \/\/                      +  (a[i + 4] + 128      ) * 31^0\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/        = h(i) * 31^4 + ((a[i + 1] + 128) * 31\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      + ((a[i + 3] + 128) * 31\n+    \/\/                      +  (a[i + 4] + 128      )\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/\n+    \/\/ Getting from the signed a[i] value to unsigned with +128, we can\n+    \/\/ just xor with 0x80=128. Any numbers there in range [-128..0) are\n+    \/\/ now in range [0..128). And any numbers that were in range [0..128)\n+    \/\/ are now in unsigned range [128..255). What a neat trick!\n+    \/\/\n+    \/\/ We then apply a byte->short transition where we crunch 2 bytes\n+    \/\/ into one short, applying a multiplication with 31 to one of the\n+    \/\/ two bytes. This multiplication cannot overflow in a short.\n+    \/\/ then we apply a short->int transition where we crunch 2 shorts\n+    \/\/ into one int, applying a multiplication with 31^2 to one of the\n+    \/\/ two shorts. This multiplication cannot overflow in an int.\n+    \/\/\n+    public static int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return HashCodeB_VectorAPI_V2.compute(a);\n+    }\n+\n+    private static class HashCodeB_VectorAPI_V2 {\n+        private static final int L = Math.min(ByteVector.SPECIES_PREFERRED.length(),\n+                                              IntVector.SPECIES_PREFERRED.length() * 4);\n+        private static final VectorShape SHAPE = VectorShape.forBitSize(8 * L);\n+        private static final VectorSpecies<Byte>    SPECIES_B = SHAPE.withLanes(byte.class);\n+        private static final VectorSpecies<Integer> SPECIES_I = SHAPE.withLanes(int.class);\n+\n+        private static int[] REVERSE_POWERS_OF_31_STEP_4 = new int[L \/ 4 + 1];\n+        static {\n+            int p = 1;\n+            int step = 31 * 31 * 31 * 31; \/\/ step by 4\n+            for (int i = REVERSE_POWERS_OF_31_STEP_4.length - 1; i >= 0; i--) {\n+                REVERSE_POWERS_OF_31_STEP_4[i] = p;\n+                p *= step;\n+            }\n+        }\n+\n+        public static int compute(byte[] a) {\n+            int result = 1; \/\/ initialValue\n+            int next = REVERSE_POWERS_OF_31_STEP_4[0]; \/\/ 31^L\n+            var vcoef = IntVector.fromArray(SPECIES_I, REVERSE_POWERS_OF_31_STEP_4, 1); \/\/ W\n+            var vresult = IntVector.zero(SPECIES_I);\n+            int i;\n+            for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+                var vb = ByteVector.fromArray(SPECIES_B, a, i);\n+                \/\/ Add 128 to each byte.\n+                var vs = vb.lanewise(VectorOperators.XOR, (byte)0x80)\n+                           .reinterpretAsShorts();\n+                \/\/ Each short lane contains 2 bytes, crunch them.\n+                var vi = vs.and((short)0xff) \/\/ lower byte\n+                           .mul((short)31)\n+                           .add(vs.lanewise(VectorOperators.LSHR, 8)) \/\/ upper byte\n+                           .reinterpretAsInts();\n+                \/\/ Each int contains 2 shorts, crunch them.\n+                var v  = vi.and(0xffff) \/\/ lower short\n+                           .mul(31 * 31)\n+                           .add(vi.lanewise(VectorOperators.LSHR, 16)); \/\/ upper short\n+                \/\/ Add the correction for the 128 additions above.\n+                v = v.add(-128 * (31*31*31 + 31*31 + 31 + 1));\n+                \/\/ Every element of v now contains a crunched int-package of 4 bytes.\n+                result *= next;\n+                vresult = vresult.mul(next).add(v);\n+            }\n+            result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+            for (; i < a.length; i++) {\n+                result = 31 * result + a[i];\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static Object scanAddI_loop(int[] a, int[] r) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static Object scanAddI_loop_reassociate(int[] a, int[] r) {\n+        int sum = 0;\n+        int i = 0;\n+        for (; i < a.length - 3; i += 4) {\n+            \/\/ We cut the latency by a factor of 4, but increase the number of additions.\n+            int old_sum = sum;\n+            int v0 = a[i + 0];\n+            int v1 = a[i + 1];\n+            int v2 = a[i + 2];\n+            int v3 = a[i + 3];\n+            int v01 = v0 + v1;\n+            int v23 = v2 + v3;\n+            int v0123 = v01 + v23;\n+            sum += v0123;\n+            r[i + 0] = old_sum + v0;\n+            r[i + 1] = old_sum + v01;\n+            r[i + 2] = old_sum + v01 + v2;\n+            r[i + 3] = old_sum + v0123;\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static Object scanAddI_VectorAPI_permute_add(int[] a, int[] r) {\n+        \/\/ Using Naive Parallel Algorithm: Hills and Steele\n+        int sum = 0;\n+        int xx = 0; \/\/ masked later anyway\n+        var shf1 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14}, 0);\n+        var shf2 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13}, 0);\n+        var shf3 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx, xx, xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11}, 0);\n+        var shf4 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx, xx, xx, xx, xx, xx, xx,  0,  1,  2,  3,  4,  5,  6,  7}, 0);\n+        var mask1 = VectorMask.fromLong(SPECIES_I512, 0b1111111111111110);\n+        var mask2 = VectorMask.fromLong(SPECIES_I512, 0b1111111111111100);\n+        var mask3 = VectorMask.fromLong(SPECIES_I512, 0b1111111111110000);\n+        var mask4 = VectorMask.fromLong(SPECIES_I512, 0b1111111100000000);\n+        int i = 0;\n+        for (; i < SPECIES_I512.loopBound(a.length); i += SPECIES_I512.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I512, a, i);\n+            v = v.add(v.rearrange(shf1), mask1);\n+            v = v.add(v.rearrange(shf2), mask2);\n+            v = v.add(v.rearrange(shf3), mask3);\n+            v = v.add(v.rearrange(shf4), mask4);\n+            v = v.add(sum);\n+            v.intoArray(r, i);\n+            sum = v.lane(SPECIES_I512.length() - 1);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static int findMinIndexI_loop(int[] a) {\n+        int min = a[0];\n+        int index = 0;\n+        for (int i = 1; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai < min) {\n+                min = ai;\n+                index = i;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    public static int findMinIndexI_VectorAPI(int[] a) {\n+        \/\/ Main approach: have partial results in mins and idxs.\n+        var mins = IntVector.broadcast(SPECIES_I, a[0]);\n+        var idxs = IntVector.broadcast(SPECIES_I, 0);\n+        var iota = IntVector.broadcast(SPECIES_I, 0).addIndex(1);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.LT, mins);\n+            mins = mins.blend(v, mask);\n+            idxs = idxs.blend(iota, mask);\n+            iota = iota.add(SPECIES_I.length());\n+        }\n+        \/\/ Reduce the vectors down\n+        int min = mins.reduceLanes(VectorOperators.MIN);\n+        var not_min_mask = mins.compare(VectorOperators.NE, min);\n+        int index = idxs.blend(a.length, not_min_mask).reduceLanes(VectorOperators.MIN);\n+        \/\/ Tail loop\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai < min) {\n+                min = ai;\n+                index = i;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    public static int findI_loop(int[] a, int e) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai == e) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int findI_VectorAPI(int[] a, int e) {\n+        var es = IntVector.broadcast(SPECIES_I, e);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.EQ, es);\n+            if (mask.anyTrue()) {\n+                return i + mask.firstTrue();\n+            }\n+        }\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai == e) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static Object reverseI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[a.length - i - 1] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    private static final VectorShuffle<Integer> REVERSE_SHUFFLE_I = SPECIES_I.iotaShuffle(SPECIES_I.length()-1, -1, true);\n+\n+    public static Object reverseI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v = v.rearrange(REVERSE_SHUFFLE_I);\n+            v.intoArray(r, r.length - SPECIES_I.length() - i);\n+        }\n+        for (; i < a.length; i++) {\n+            r[a.length - i - 1] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object filterI_loop(int[] a, int[] r, int threshold) {\n+        int j = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai >= threshold) {\n+                r[j++] = ai;\n+            }\n+        }\n+        \/\/ Just force the resulting length onto the same array.\n+        r[r.length - 1] = j;\n+        return r;\n+    }\n+\n+    public static Object filterI_VectorAPI(int[] a, int[] r, int threshold) {\n+        var thresholds = IntVector.broadcast(SPECIES_I, threshold);\n+        int j = 0;\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.GE, thresholds);\n+            v = v.compress(mask);\n+            int trueCount = mask.trueCount();\n+            var prefixMask = mask.compress();\n+            v.intoArray(r, j, prefixMask);\n+            j += trueCount;\n+        }\n+\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai >= threshold) {\n+                r[j++] = ai;\n+            }\n+        }\n+        \/\/ Just force the resulting length onto the same array.\n+        r[r.length - 1] = j;\n+        return r;\n+    }\n+\n+    \/\/ X4: ints simulate 4-byte oops.\n+    \/\/ oops: if non-zero (= non-null), every entry simpulates a 4-byte oop, pointing into mem.\n+    \/\/ mem: an int array that simulates the memory.\n+    \/\/\n+    \/\/ Task: Find all non-null oops, and dereference them, get the relevant field.\n+    \/\/       Objects have 16 bytes, and the relevant field is at bytes 12-16.\n+    \/\/       That maps to 4 ints, and the relevant field is the 4th element of 4.\n+    \/\/       Sum up all the field values.\n+    public static int reduceAddIFieldsX4_loop(int[] oops, int[] mem) {\n+        int sum = 0;\n+        for (int i = 0; i < oops.length; i++) {\n+            int oop = oops[i];\n+            if (oop != 0) {\n+                int fieldValue = mem[oop + 3]; \/\/ oop+12\n+                sum += fieldValue;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddIFieldsX4_VectorAPI(int[] oops, int[] mem) {\n+        var acc = IntVector.broadcast(SPECIES_I, 0);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(oops.length); i += SPECIES_I.length()) {\n+            var oopv = IntVector.fromArray(SPECIES_I, oops, i);\n+            var mask = oopv.compare(VectorOperators.NE, \/* null *\/0);\n+            \/\/ We are lucky today: we need to access mem[oop + 3]\n+            var fieldValues = IntVector.fromArray(SPECIES_I, mem, 3, oops, i, mask);\n+            acc = acc.add(fieldValues);\n+        }\n+        int sum = acc.reduceLanes(VectorOperators.ADD);\n+        for (; i < oops.length; i++) {\n+            int oop = oops[i];\n+            if (oop != 0) {\n+                int fieldValue = mem[oop + 3]; \/\/ oop+12\n+                sum += fieldValue;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ The lowerCase example demonstrates a lane-wise control-flow diamond.\n+    public static Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A'); \/\/ c += 32\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Control-flow diamonds can easily be simulated by \"if-conversion\", i.e.\n+    \/\/ by using masked operations. An alternative would be to use blend.\n+    public static Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            var maskA = vc.compare(VectorOperators.GE, (byte)'A');\n+            var maskZ = vc.compare(VectorOperators.LE, (byte)'Z');\n+            var mask = maskA.and(maskZ);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    public static Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            \/\/ We can convert the range 65..90 (represents ascii A..Z) into a range 0..25.\n+            \/\/ This allows us to only use a single unsigned comparison.\n+            var vt = vc.add((byte)-'A');\n+            var mask = vt.compare(VectorOperators.ULE, (byte)25);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java","additions":774,"deletions":0,"binary":false,"changes":774,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ *  Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * The goal of this benchmark is to show the power of auto vectorization\n+ * and the Vector API.\n+ *\n+ * Please only modify this benchark in synchronization with the IR test:\n+ *   test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java\n+ *\n+ * You may want to play with the following VM flags:\n+ *  - Disable auto vectorization:\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:AutoVectorizationOverrideProfitability=0\n+ *  - Smaller vector size:\n+ *      -XX:MaxVectorSize=16\n+ *  - Disable fill loop detection, so we don't use intrinsic but auto vectorization:\n+ *      -XX:-OptimizeFill\n+ *  - Lilliput can also have an effect, because it can change alignment and have\n+ *    an impact on which exact intrinsic is chosen (e.g. fill and copy):\n+ *      -XX:+UseCompactObjectHeaders\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(value = 5, jvmArgs = {\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,*VectorAlgorithmsImpl*::*\"})\n+public class VectorAlgorithms {\n+    @Param({\"640000\"})\n+    public int SIZE;\n+\n+    @Param({\"10000\"})\n+    public int NUM_X_OBJECTS;\n+\n+    @Param({\"0\"})\n+    public int SEED;\n+\n+    VectorAlgorithmsImpl.Data d;\n+\n+    @Setup\n+    public void init() {\n+        d = new VectorAlgorithmsImpl.Data(SIZE, SEED, NUM_X_OBJECTS);\n+    }\n+\n+    \/\/ ------------------------------------------------------------------------------------------\n+    \/\/               Benchmarks just forward arguments and returns.\n+    \/\/ ------------------------------------------------------------------------------------------\n+\n+    @Benchmark\n+    public Object fillI_loop() {\n+        return VectorAlgorithmsImpl.fillI_loop(d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object fillI_VectorAPI() {\n+        return VectorAlgorithmsImpl.fillI_VectorAPI(d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object fillI_Arrays() {\n+        return VectorAlgorithmsImpl.fillI_Arrays(d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object iotaI_loop() {\n+        return VectorAlgorithmsImpl.iotaI_loop(d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object iotaI_VectorAPI() {\n+        return VectorAlgorithmsImpl.iotaI_VectorAPI(d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object copyI_loop() {\n+        return VectorAlgorithmsImpl.copyI_loop(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object copyI_VectorAPI() {\n+        return VectorAlgorithmsImpl.copyI_VectorAPI(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object copyI_System_arraycopy() {\n+        return VectorAlgorithmsImpl.copyI_System_arraycopy(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object mapI_loop() {\n+        return VectorAlgorithmsImpl.mapI_loop(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object mapI_VectorAPI() {\n+        return VectorAlgorithmsImpl.mapI_VectorAPI(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddI_loop() {\n+        return VectorAlgorithmsImpl.reduceAddI_loop(d.aI);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddI_reassociate() {\n+        return VectorAlgorithmsImpl.reduceAddI_reassociate(d.aI);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddI_VectorAPI_naive() {\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_naive(d.aI);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddI_VectorAPI_reduction_after_loop() {\n+        return VectorAlgorithmsImpl.reduceAddI_VectorAPI_reduction_after_loop(d.aI);\n+    }\n+\n+    @Benchmark\n+    public float dotProductF_loop() {\n+        return VectorAlgorithmsImpl.dotProductF_loop(d.aF, d.bF);\n+    }\n+\n+    @Benchmark\n+    public float dotProductF_VectorAPI_naive() {\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_naive(d.aF, d.bF);\n+    }\n+\n+    @Benchmark\n+    public float dotProductF_VectorAPI_reduction_after_loop() {\n+        return VectorAlgorithmsImpl.dotProductF_VectorAPI_reduction_after_loop(d.aF, d.bF);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_loop() {\n+        return VectorAlgorithmsImpl.hashCodeB_loop(d.aB);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_Arrays() {\n+        return VectorAlgorithmsImpl.hashCodeB_Arrays(d.aB);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_VectorAPI_v1() {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(d.aB);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_VectorAPI_v2() {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v2(d.aB);\n+    }\n+\n+    @Benchmark\n+    public Object scanAddI_loop() {\n+        return VectorAlgorithmsImpl.scanAddI_loop(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object scanAddI_loop_reassociate() {\n+        return VectorAlgorithmsImpl.scanAddI_loop_reassociate(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object scanAddI_VectorAPI_permute_add() {\n+        return VectorAlgorithmsImpl.scanAddI_VectorAPI_permute_add(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public int findMinIndexI_loop() {\n+        return VectorAlgorithmsImpl.findMinIndexI_loop(d.aI);\n+    }\n+\n+    @Benchmark\n+    public int findMinIndexI_VectorAPI() {\n+        return VectorAlgorithmsImpl.findMinIndexI_VectorAPI(d.aI);\n+    }\n+\n+    @Benchmark\n+    public int findI_loop() {\n+        \/\/ Every invocation should have a different value for e, so that\n+        \/\/ we don't get branch-prediction that is too good. And also so\n+        \/\/ that the position where we exit is more evenly distributed.\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.findI_loop(d.aI, e);\n+    }\n+\n+    @Benchmark\n+    public int findI_VectorAPI() {\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.findI_VectorAPI(d.aI, e);\n+    }\n+\n+    @Benchmark\n+    public Object reverseI_loop() {\n+        return VectorAlgorithmsImpl.reverseI_loop(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object reverseI_VectorAPI() {\n+        return VectorAlgorithmsImpl.reverseI_VectorAPI(d.aI, d.rI1);\n+    }\n+\n+    @Benchmark\n+    public Object filterI_loop() {\n+        \/\/ Every invocation should have a different value for e, so that\n+        \/\/ we don't get branch-prediction that is too good. And also so\n+        \/\/ That the length of the resulting data is more evenly distributed.\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.filterI_loop(d.aI, d.rI1, e);\n+    }\n+\n+    @Benchmark\n+    public Object filterI_VectorAPI() {\n+        d.eI_idx = (d.eI_idx + 1) & 0xffff;\n+        int e = d.eI[d.eI_idx];\n+        return VectorAlgorithmsImpl.filterI_VectorAPI(d.aI, d.rI1, e);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddIFieldsX4_loop() {\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_loop(d.oopsX4, d.memX4);\n+    }\n+\n+    @Benchmark\n+    public int reduceAddIFieldsX4_VectorAPI() {\n+        return VectorAlgorithmsImpl.reduceAddIFieldsX4_VectorAPI(d.oopsX4, d.memX4);\n+    }\n+\n+    @Benchmark\n+    public Object lowerCaseB_loop() {\n+        return VectorAlgorithmsImpl.lowerCaseB_loop(d.strB, d.rB1);\n+    }\n+\n+    @Benchmark\n+    public Object lowerCaseB_VectorAPI_v1() {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v1(d.strB, d.rB1);\n+    }\n+\n+    @Benchmark\n+    public Object lowerCaseB_VectorAPI_v2() {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v2(d.strB, d.rB1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,775 @@\n+\/*\n+ *  Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * The code below is supposed to be an exact copy of:\n+ *   test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java\n+ *\/\n+public class VectorAlgorithmsImpl {\n+    private static final VectorSpecies<Integer> SPECIES_I    = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> SPECIES_I512 = IntVector.SPECIES_512;\n+    private static final VectorSpecies<Integer> SPECIES_I256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Byte> SPECIES_B       = ByteVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> SPECIES_B64     = ByteVector.SPECIES_64;\n+    private static final VectorSpecies<Float> SPECIES_F      = FloatVector.SPECIES_PREFERRED;\n+\n+    \/\/ This class stores the input and output arrays.\n+    \/\/ The constructor sets up all the data.\n+    \/\/\n+    \/\/ IMPORTANT:\n+    \/\/   If you want to use some array but do NOT modify it: just use it.\n+    \/\/   If you want to use it and DO want to modify it: clone it. This\n+    \/\/   ensures that each test gets a separate copy, and that when we\n+    \/\/   capture the modified arrays they are different for every method\n+    \/\/   and run.\n+    \/\/   An alternative to cloning is to use different return arrays for\n+    \/\/   different implementations of the same group, e.g. rI1, rI2, ...\n+    \/\/\n+    public static class Data {\n+        public int[] aI;\n+        public int[] rI1;\n+        public int[] rI2;\n+        public int[] rI3;\n+        public int[] rI4;\n+        public int[] eI;\n+        \/\/ The test has to use the same index into eI for all implementations. But in the\n+        \/\/ benchmark, we'd like to use random indices, so we use the index to advance through\n+        \/\/ the array.\n+        public int eI_idx = 0;\n+\n+        public float[] aF;\n+        public float[] bF;\n+\n+        public byte[] aB;\n+        public byte[] strB;\n+        public byte[] rB1;\n+        public byte[] rB2;\n+        public byte[] rB3;\n+\n+        public int[] oopsX4;\n+        public int[] memX4;\n+\n+        public Data(int size, int seed, int numX4Objects) {\n+            Random random = new Random(seed);\n+\n+            \/\/ int: one input array and multiple output arrays so different implementations can\n+            \/\/ store their results to different arrays.\n+            aI = new int[size];\n+            rI1 = new int[size];\n+            rI2 = new int[size];\n+            rI3 = new int[size];\n+            rI4 = new int[size];\n+            Arrays.setAll(aI, i -> random.nextInt());\n+\n+            \/\/ Populate with some random values from aI, and some totally random values.\n+            eI = new int[0x10000];\n+            for (int i = 0; i < eI.length; i++) {\n+                eI[i] = (random.nextInt(10) == 0) ? random.nextInt() : aI[random.nextInt(size)];\n+            }\n+\n+            \/\/ X4 oop setup.\n+            \/\/ oopsX4 holds \"addresses\" (i.e. indices), that point to the 16-byte objects in memX4.\n+            oopsX4 = new int[size];\n+            memX4 = new int[numX4Objects * 4];\n+            for (int i = 0; i < size; i++) {\n+                \/\/ assign either a zero=null, or assign a random oop.\n+                oopsX4[i] = (random.nextInt(10) == 0) ? 0 : random.nextInt(numX4Objects) * 4;\n+            }\n+            \/\/ Just fill the whole array with random values.\n+            \/\/ The relevant field is only at every \"4 * i + 3\" though.\n+            memX4 = new int[4 * numX4Objects];\n+            for (int i = 0; i < memX4.length; i++) {\n+                memX4[i] = random.nextInt();\n+            }\n+\n+            \/\/ float inputs. To avoid rounding issues, only use small integers.\n+            aF = new float[size];\n+            bF = new float[size];\n+            for (int i = 0; i < size; i++) {\n+                aF[i] = random.nextInt(32) - 16;\n+                bF[i] = random.nextInt(32) - 16;\n+            }\n+\n+            \/\/ byte: just random data.\n+            aB = new byte[size];\n+            strB = new byte[size];\n+            rB1 = new byte[size];\n+            rB2 = new byte[size];\n+            rB3 = new byte[size];\n+            random.nextBytes(aB);\n+            random.nextBytes(strB); \/\/ TODO: special data!\n+        }\n+    }\n+\n+    public static Object fillI_loop(int[] r) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object fillI_Arrays(int[] r) {\n+        Arrays.fill(r, 42);\n+        return r;\n+    }\n+\n+    public static Object fillI_VectorAPI(int[] r) {\n+        var v = IntVector.broadcast(SPECIES_I, 42);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object iotaI_loop(int[] r) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = i;\n+        }\n+        return r;\n+    }\n+\n+    public static Object iotaI_VectorAPI(int[] r) {\n+        var iota = IntVector.broadcast(SPECIES_I, 0).addIndex(1);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            iota.intoArray(r, i);\n+            iota = iota.add(SPECIES_I.length());\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = i;\n+        }\n+        return r;\n+    }\n+\n+    public static Object copyI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object copyI_System_arraycopy(int[] a, int[] r) {\n+        System.arraycopy(a, 0, r, 0, a.length);\n+        return r;\n+    }\n+\n+    public static Object copyI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object mapI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = a[i] * 42;\n+        }\n+        return r;\n+    }\n+\n+    public static Object mapI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(r.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v = v.mul(42);\n+            v.intoArray(r, i);\n+        }\n+        for (; i < r.length; i++) {\n+            r[i] = a[i] * 42;\n+        }\n+        return r;\n+    }\n+\n+    public static int reduceAddI_loop(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Relying on simple reduction loop should vectorize since JDK26.\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_reassociate(int[] a) {\n+        int sum = 0;\n+        int i;\n+        for (i = 0; i < a.length - 3; i += 4) {\n+            \/\/ Unroll 4x, reassociate inside.\n+            sum += a[i] + a[i + 1] + a[i + 2] + a[i + 3];\n+        }\n+        for (; i < a.length; i++) {\n+            \/\/ Tail\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_VectorAPI_naive(int[] a) {\n+        var sum = 0;\n+        int i;\n+        for (i = 0; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            \/\/ reduceLanes in loop is better than scalar performance, but still\n+            \/\/ relatively slow.\n+            sum += v.reduceLanes(VectorOperators.ADD);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddI_VectorAPI_reduction_after_loop(int[] a) {\n+        var acc = IntVector.broadcast(SPECIES_I, 0);\n+        int i;\n+        for (i = 0; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            \/\/ Element-wide addition into a vector of partial sums is much faster.\n+            \/\/ Now, we only need to do a reduceLanes after the loop.\n+            \/\/ This works because int-addition is associative and commutative.\n+            acc = acc.add(v);\n+        }\n+        int sum = acc.reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_loop(float[] a, float[] b) {\n+        float sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_VectorAPI_naive(float[] a, float[] b) {\n+        float sum = 0;\n+        int i;\n+        for (i = 0; i < SPECIES_F.loopBound(a.length); i += SPECIES_F.length()) {\n+            var va = FloatVector.fromArray(SPECIES_F, a, i);\n+            var vb = FloatVector.fromArray(SPECIES_F, b, i);\n+            sum += va.mul(vb).reduceLanes(VectorOperators.ADD);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static float dotProductF_VectorAPI_reduction_after_loop(float[] a, float[] b) {\n+        var sums = FloatVector.broadcast(SPECIES_F, 0.0f);\n+        int i;\n+        for (i = 0; i < SPECIES_F.loopBound(a.length); i += SPECIES_F.length()) {\n+            var va = FloatVector.fromArray(SPECIES_F, a, i);\n+            var vb = FloatVector.fromArray(SPECIES_F, b, i);\n+            sums = sums.add(va.mul(vb));\n+        }\n+        float sum = sums.reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            sum += a[i] * b[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static int hashCodeB_loop(byte[] a) {\n+        int h = 1;\n+        for (int i = 0; i < a.length; i++) {\n+            h = 31 * h + a[i];\n+        }\n+        return h;\n+    }\n+\n+    public static int hashCodeB_Arrays(byte[] a) {\n+        return Arrays.hashCode(a);\n+    }\n+\n+    \/\/ Simplified intrinsic code from C2_MacroAssembler::arrays_hashcode in c2_MacroAssembler_x86.cpp\n+    \/\/\n+    \/\/ Ideas that may help understand the code:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ \"unroll\" by factor of L=8:\n+    \/\/   h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/            -----------   ------------------------------------------------\n+    \/\/            scalar        vector: notice the powers of 31 in reverse\n+    \/\/\n+    \/\/ We notice that we can load a[i+1 .. i+8], then element-wise multiply with\n+    \/\/ the vector of reversed powers-of-31, and then do reduceLanes(ADD).\n+    \/\/ But we can do even better: By looking at multiple such 8-unrolled iterations.\n+    \/\/ Instead of applying the \"next\" factor of \"31^8\" to the reduced scalar, we can\n+    \/\/ already apply it element-wise. That allows us to move the reduction out\n+    \/\/ of the loop.\n+    \/\/\n+    \/\/ Note: the intrinsic additionally unrolls the loop by a factor of 4,\n+    \/\/       but we want to keep thins simple for demonstration purposes.\n+    \/\/\n+    private static int[] REVERSE_POWERS_OF_31 = new int[9];\n+    static {\n+        int p = 1;\n+        for (int i = REVERSE_POWERS_OF_31.length - 1; i >= 0; i--) {\n+            REVERSE_POWERS_OF_31[i] = p;\n+            p *= 31;\n+        }\n+    }\n+    public static int hashCodeB_VectorAPI_v1(byte[] a) {\n+        int result = 1; \/\/ initialValue\n+        var vresult = IntVector.zero(SPECIES_I256);\n+        int next = REVERSE_POWERS_OF_31[0]; \/\/ 31^L\n+        var vcoef = IntVector.fromArray(SPECIES_I256, REVERSE_POWERS_OF_31, 1); \/\/ powers of 2 in reverse\n+        int i;\n+        for (i = 0; i < SPECIES_B64.loopBound(a.length); i += SPECIES_B64.length()) {\n+            \/\/ scalar part: result *= 31^L\n+            result *= next;\n+            \/\/ vector part: element-wise apply the next factor and add in the new values.\n+            var vb = ByteVector.fromArray(SPECIES_B64, a, i);\n+            var vi = vb.castShape(SPECIES_I256, 0);\n+            vresult = vresult.mul(next).add(vi);\n+        }\n+        \/\/ reduce the partial hashes in the elements, using the reverse list of powers of 2.\n+        result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    \/\/ This second approach follows the idea from this blog post by Otmar Ertl:\n+    \/\/ https:\/\/www.dynatrace.com\/news\/blog\/java-arrays-hashcode-byte-efficiency-techniques\/\n+    \/\/\n+    \/\/ I simplified the algorithm a little, so that it is a bit closer\n+    \/\/ to the solution \"v1\" above.\n+    \/\/\n+    \/\/ The major issue with \"v1\" is that we cannot load a full vector of bytes,\n+    \/\/ because of the cast to ints. So we can only fill 1\/4 of the maximal\n+    \/\/ vector size. The trick here is to do an unrolling of factor 4, from:\n+    \/\/   h(i) = 31 * h(i-1) + a[i]\n+    \/\/ to:\n+    \/\/   h(i+4) = h(i) * 31^4 + a[i + 1] * 31^3\n+    \/\/                        + a[i + 2] * 31^2\n+    \/\/                        + a[i + 3] * 31^1\n+    \/\/                        + a[i + 4] * 31^0\n+    \/\/ The goal is now to compute this value for 4 bytes within a 4 byte\n+    \/\/ lane of the vector. One concern is that we start with byte values,\n+    \/\/ but need to do int-multiplication with powers of 31. If we instead\n+    \/\/ did a byte-multiplication, we could get overflows that we would not\n+    \/\/ have had in the int-multiplication.\n+    \/\/ One trick that helps with chaning the size of the lanes from byte\n+    \/\/ to short to int is doing all operations with unsigned integers. That\n+    \/\/ way, we can zero-extend instead of sign-bit extend. The first step\n+    \/\/ is thus to convert the bytes into unsigned values. Since byte is in\n+    \/\/ range [-128..128), doing \"a[i+j] + 128\" makes it a positive value,\n+    \/\/ allowing for unsigned multiplication.\n+    \/\/ h(i+4) = h(i) * 31^4 +   a[i + 1]              * 31^3\n+    \/\/                      +   a[i + 2]              * 31^2\n+    \/\/                      +   a[i + 3]              * 31^1\n+    \/\/                      +   a[i + 4]              * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128 - 128) * 31^3\n+    \/\/                      +  (a[i + 2] + 128 - 128) * 31^2\n+    \/\/                      +  (a[i + 3] + 128 - 128) * 31^1\n+    \/\/                      +  (a[i + 4] + 128 - 128) * 31^0\n+    \/\/        = h(i) * 31^4 +  (a[i + 1] + 128      ) * 31^3\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      +  (a[i + 3] + 128      ) * 31^1\n+    \/\/                      +  (a[i + 4] + 128      ) * 31^0\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/        = h(i) * 31^4 + ((a[i + 1] + 128) * 31\n+    \/\/                      +  (a[i + 2] + 128      ) * 31^2\n+    \/\/                      + ((a[i + 3] + 128) * 31\n+    \/\/                      +  (a[i + 4] + 128      )\n+    \/\/                      +  -128 * (31^3 + 31^2 + 31^1 + 1)\n+    \/\/\n+    \/\/ Getting from the signed a[i] value to unsigned with +128, we can\n+    \/\/ just xor with 0x80=128. Any numbers there in range [-128..0) are\n+    \/\/ now in range [0..128). And any numbers that were in range [0..128)\n+    \/\/ are now in unsigned range [128..255). What a neat trick!\n+    \/\/\n+    \/\/ We then apply a byte->short transition where we crunch 2 bytes\n+    \/\/ into one short, applying a multiplication with 31 to one of the\n+    \/\/ two bytes. This multiplication cannot overflow in a short.\n+    \/\/ then we apply a short->int transition where we crunch 2 shorts\n+    \/\/ into one int, applying a multiplication with 31^2 to one of the\n+    \/\/ two shorts. This multiplication cannot overflow in an int.\n+    \/\/\n+    public static int hashCodeB_VectorAPI_v2(byte[] a) {\n+        return HashCodeB_VectorAPI_V2.compute(a);\n+    }\n+\n+    private static class HashCodeB_VectorAPI_V2 {\n+        private static final int L = Math.min(ByteVector.SPECIES_PREFERRED.length(),\n+                                              IntVector.SPECIES_PREFERRED.length() * 4);\n+        private static final VectorShape SHAPE = VectorShape.forBitSize(8 * L);\n+        private static final VectorSpecies<Byte>    SPECIES_B = SHAPE.withLanes(byte.class);\n+        private static final VectorSpecies<Integer> SPECIES_I = SHAPE.withLanes(int.class);\n+\n+        private static int[] REVERSE_POWERS_OF_31_STEP_4 = new int[L \/ 4 + 1];\n+        static {\n+            int p = 1;\n+            int step = 31 * 31 * 31 * 31; \/\/ step by 4\n+            for (int i = REVERSE_POWERS_OF_31_STEP_4.length - 1; i >= 0; i--) {\n+                REVERSE_POWERS_OF_31_STEP_4[i] = p;\n+                p *= step;\n+            }\n+        }\n+\n+        public static int compute(byte[] a) {\n+            int result = 1; \/\/ initialValue\n+            int next = REVERSE_POWERS_OF_31_STEP_4[0]; \/\/ 31^L\n+            var vcoef = IntVector.fromArray(SPECIES_I, REVERSE_POWERS_OF_31_STEP_4, 1); \/\/ W\n+            var vresult = IntVector.zero(SPECIES_I);\n+            int i;\n+            for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+                var vb = ByteVector.fromArray(SPECIES_B, a, i);\n+                \/\/ Add 128 to each byte.\n+                var vs = vb.lanewise(VectorOperators.XOR, (byte)0x80)\n+                           .reinterpretAsShorts();\n+                \/\/ Each short lane contains 2 bytes, crunch them.\n+                var vi = vs.and((short)0xff) \/\/ lower byte\n+                           .mul((short)31)\n+                           .add(vs.lanewise(VectorOperators.LSHR, 8)) \/\/ upper byte\n+                           .reinterpretAsInts();\n+                \/\/ Each int contains 2 shorts, crunch them.\n+                var v  = vi.and(0xffff) \/\/ lower short\n+                           .mul(31 * 31)\n+                           .add(vi.lanewise(VectorOperators.LSHR, 16)); \/\/ upper short\n+                \/\/ Add the correction for the 128 additions above.\n+                v = v.add(-128 * (31*31*31 + 31*31 + 31 + 1));\n+                \/\/ Every element of v now contains a crunched int-package of 4 bytes.\n+                result *= next;\n+                vresult = vresult.mul(next).add(v);\n+            }\n+            result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+            for (; i < a.length; i++) {\n+                result = 31 * result + a[i];\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static Object scanAddI_loop(int[] a, int[] r) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static Object scanAddI_loop_reassociate(int[] a, int[] r) {\n+        int sum = 0;\n+        int i = 0;\n+        for (; i < a.length - 3; i += 4) {\n+            \/\/ We cut the latency by a factor of 4, but increase the number of additions.\n+            int old_sum = sum;\n+            int v0 = a[i + 0];\n+            int v1 = a[i + 1];\n+            int v2 = a[i + 2];\n+            int v3 = a[i + 3];\n+            int v01 = v0 + v1;\n+            int v23 = v2 + v3;\n+            int v0123 = v01 + v23;\n+            sum += v0123;\n+            r[i + 0] = old_sum + v0;\n+            r[i + 1] = old_sum + v01;\n+            r[i + 2] = old_sum + v01 + v2;\n+            r[i + 3] = old_sum + v0123;\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static Object scanAddI_VectorAPI_permute_add(int[] a, int[] r) {\n+        \/\/ Using Naive Parallel Algorithm: Hills and Steele\n+        int sum = 0;\n+        int xx = 0; \/\/ masked later anyway\n+        var shf1 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14}, 0);\n+        var shf2 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13}, 0);\n+        var shf3 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx, xx, xx,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11}, 0);\n+        var shf4 = VectorShuffle.fromArray(SPECIES_I512, new int[]{xx, xx, xx, xx, xx, xx, xx, xx,  0,  1,  2,  3,  4,  5,  6,  7}, 0);\n+        var mask1 = VectorMask.fromLong(SPECIES_I512, 0b1111111111111110);\n+        var mask2 = VectorMask.fromLong(SPECIES_I512, 0b1111111111111100);\n+        var mask3 = VectorMask.fromLong(SPECIES_I512, 0b1111111111110000);\n+        var mask4 = VectorMask.fromLong(SPECIES_I512, 0b1111111100000000);\n+        int i = 0;\n+        for (; i < SPECIES_I512.loopBound(a.length); i += SPECIES_I512.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I512, a, i);\n+            v = v.add(v.rearrange(shf1), mask1);\n+            v = v.add(v.rearrange(shf2), mask2);\n+            v = v.add(v.rearrange(shf3), mask3);\n+            v = v.add(v.rearrange(shf4), mask4);\n+            v = v.add(sum);\n+            v.intoArray(r, i);\n+            sum = v.lane(SPECIES_I512.length() - 1);\n+        }\n+        for (; i < a.length; i++) {\n+            sum += a[i];\n+            r[i] = sum;\n+        }\n+        return r;\n+    }\n+\n+    public static int findMinIndexI_loop(int[] a) {\n+        int min = a[0];\n+        int index = 0;\n+        for (int i = 1; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai < min) {\n+                min = ai;\n+                index = i;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    public static int findMinIndexI_VectorAPI(int[] a) {\n+        \/\/ Main approach: have partial results in mins and idxs.\n+        var mins = IntVector.broadcast(SPECIES_I, a[0]);\n+        var idxs = IntVector.broadcast(SPECIES_I, 0);\n+        var iota = IntVector.broadcast(SPECIES_I, 0).addIndex(1);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.LT, mins);\n+            mins = mins.blend(v, mask);\n+            idxs = idxs.blend(iota, mask);\n+            iota = iota.add(SPECIES_I.length());\n+        }\n+        \/\/ Reduce the vectors down\n+        int min = mins.reduceLanes(VectorOperators.MIN);\n+        var not_min_mask = mins.compare(VectorOperators.NE, min);\n+        int index = idxs.blend(a.length, not_min_mask).reduceLanes(VectorOperators.MIN);\n+        \/\/ Tail loop\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai < min) {\n+                min = ai;\n+                index = i;\n+            }\n+        }\n+        return index;\n+    }\n+\n+    public static int findI_loop(int[] a, int e) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai == e) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int findI_VectorAPI(int[] a, int e) {\n+        var es = IntVector.broadcast(SPECIES_I, e);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.EQ, es);\n+            if (mask.anyTrue()) {\n+                return i + mask.firstTrue();\n+            }\n+        }\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai == e) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static Object reverseI_loop(int[] a, int[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            r[a.length - i - 1] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    private static final VectorShuffle<Integer> REVERSE_SHUFFLE_I = SPECIES_I.iotaShuffle(SPECIES_I.length()-1, -1, true);\n+\n+    public static Object reverseI_VectorAPI(int[] a, int[] r) {\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            v = v.rearrange(REVERSE_SHUFFLE_I);\n+            v.intoArray(r, r.length - SPECIES_I.length() - i);\n+        }\n+        for (; i < a.length; i++) {\n+            r[a.length - i - 1] = a[i];\n+        }\n+        return r;\n+    }\n+\n+    public static Object filterI_loop(int[] a, int[] r, int threshold) {\n+        int j = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai >= threshold) {\n+                r[j++] = ai;\n+            }\n+        }\n+        \/\/ Just force the resulting length onto the same array.\n+        r[r.length - 1] = j;\n+        return r;\n+    }\n+\n+    public static Object filterI_VectorAPI(int[] a, int[] r, int threshold) {\n+        var thresholds = IntVector.broadcast(SPECIES_I, threshold);\n+        int j = 0;\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(a.length); i += SPECIES_I.length()) {\n+            IntVector v = IntVector.fromArray(SPECIES_I, a, i);\n+            var mask = v.compare(VectorOperators.GE, thresholds);\n+            v = v.compress(mask);\n+            int trueCount = mask.trueCount();\n+            var prefixMask = mask.compress();\n+            v.intoArray(r, j, prefixMask);\n+            j += trueCount;\n+        }\n+\n+        for (; i < a.length; i++) {\n+            int ai = a[i];\n+            if (ai >= threshold) {\n+                r[j++] = ai;\n+            }\n+        }\n+        \/\/ Just force the resulting length onto the same array.\n+        r[r.length - 1] = j;\n+        return r;\n+    }\n+\n+    \/\/ X4: ints simulate 4-byte oops.\n+    \/\/ oops: if non-zero (= non-null), every entry simpulates a 4-byte oop, pointing into mem.\n+    \/\/ mem: an int array that simulates the memory.\n+    \/\/\n+    \/\/ Task: Find all non-null oops, and dereference them, get the relevant field.\n+    \/\/       Objects have 16 bytes, and the relevant field is at bytes 12-16.\n+    \/\/       That maps to 4 ints, and the relevant field is the 4th element of 4.\n+    \/\/       Sum up all the field values.\n+    public static int reduceAddIFieldsX4_loop(int[] oops, int[] mem) {\n+        int sum = 0;\n+        for (int i = 0; i < oops.length; i++) {\n+            int oop = oops[i];\n+            if (oop != 0) {\n+                int fieldValue = mem[oop + 3]; \/\/ oop+12\n+                sum += fieldValue;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    public static int reduceAddIFieldsX4_VectorAPI(int[] oops, int[] mem) {\n+        var acc = IntVector.broadcast(SPECIES_I, 0);\n+        int i = 0;\n+        for (; i < SPECIES_I.loopBound(oops.length); i += SPECIES_I.length()) {\n+            var oopv = IntVector.fromArray(SPECIES_I, oops, i);\n+            var mask = oopv.compare(VectorOperators.NE, \/* null *\/0);\n+            \/\/ We are lucky today: we need to access mem[oop + 3]\n+            var fieldValues = IntVector.fromArray(SPECIES_I, mem, 3, oops, i, mask);\n+            acc = acc.add(fieldValues);\n+        }\n+        int sum = acc.reduceLanes(VectorOperators.ADD);\n+        for (; i < oops.length; i++) {\n+            int oop = oops[i];\n+            if (oop != 0) {\n+                int fieldValue = mem[oop + 3]; \/\/ oop+12\n+                sum += fieldValue;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ The lowerCase example demonstrates a lane-wise control-flow diamond.\n+    public static Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A'); \/\/ c += 32\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Control-flow diamonds can easily be simulated by \"if-conversion\", i.e.\n+    \/\/ by using masked operations. An alternative would be to use blend.\n+    public static Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            var maskA = vc.compare(VectorOperators.GE, (byte)'A');\n+            var maskZ = vc.compare(VectorOperators.LE, (byte)'Z');\n+            var mask = maskA.and(maskZ);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    public static Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            \/\/ We can convert the range 65..90 (represents ascii A..Z) into a range 0..25.\n+            \/\/ This allows us to only use a single unsigned comparison.\n+            var vt = vc.add((byte)-'A');\n+            var mask = vt.compare(VectorOperators.ULE, (byte)25);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java","additions":775,"deletions":0,"binary":false,"changes":775,"status":"added"}]}