{"files":[{"patch":"@@ -90,0 +90,2 @@\n+    byte[] aB;\n+\n@@ -144,0 +146,5 @@\n+        testGroups.put(\"hashCodeB\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_loop\",         () -> { return hashCodeB_loop(aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_Arrays\",       () -> { return hashCodeB_Arrays(aB); });\n+        testGroups.get(\"hashCodeB\").put(\"hashCodeB_VectorAPI_v1\", () -> { return hashCodeB_VectorAPI_v1(aB); });\n+\n@@ -188,0 +195,3 @@\n+                 \"hashCodeB_loop\",\n+                 \"hashCodeB_Arrays\",\n+                 \"hashCodeB_VectorAPI_v1\",\n@@ -239,0 +249,3 @@\n+            aB = new byte[size];\n+            RANDOM.nextBytes(aB);\n+\n@@ -412,0 +425,21 @@\n+    @Test\n+    public int hashCodeB_loop(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_loop(a);\n+    }\n+\n+    @Test\n+    public int hashCodeB_Arrays(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_Arrays(a);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,    IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.MUL_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.VECTOR_CAST_B2I,  IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_VI,           IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_REDUCTION_VI,                       \"> 0\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public int hashCodeB_VectorAPI_v1(byte[] a) {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(a);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private static final VectorSpecies<Integer> SPECIES_I256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Byte> SPECIES_B64     = ByteVector.SPECIES_64;\n@@ -219,0 +221,63 @@\n+    public static int hashCodeB_loop(byte[] a) {\n+        int h = 1;\n+        for (int i = 0; i < a.length; i++) {\n+            h = 31 * h + a[i];\n+        }\n+        return h;\n+    }\n+\n+    public static int hashCodeB_Arrays(byte[] a) {\n+        return Arrays.hashCode(a);\n+    }\n+\n+    \/\/ Simplified intrinsic code from C2_MacroAssembler::arrays_hashcode in c2_MacroAssembler_x86.cpp\n+    \/\/\n+    \/\/ Ideas that may help understand the code:\n+    \/\/\n+    \/\/ h(i) = 31 * h(i-1) + a[i]\n+    \/\/ \"unroll\" by factor of L=8:\n+    \/\/ h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/          -----------   ------------------------------------------------\n+    \/\/          scalar        vector: notice the powers of 31 in reverse\n+    \/\/\n+    \/\/ We notice that we can load a[i+1 .. i+8], then element-wise multiply with\n+    \/\/ the vector of reversed powers-of-31, and then do reduceLanes(ADD).\n+    \/\/ But we can do even better: By looking at multiple such 8-unrolled iterations.\n+    \/\/ Instead of applying the \"next\" factor of \"31^8\" to the reduced scalar, we can\n+    \/\/ already apply it element-wise. That allows us to move the reduction out\n+    \/\/ of the loop.\n+    \/\/\n+    \/\/ Note: the intrinsic additionally unrolls the loop by a factor of 4,\n+    \/\/       but we want to keep thins simple for demonstration purposes.\n+    \/\/\n+    private static int[] REVERSE_POWERS_OF_31 = new int[9];\n+    static {\n+        int p = 1;\n+        for (int i = REVERSE_POWERS_OF_31.length - 1; i >= 0; i--) {\n+            REVERSE_POWERS_OF_31[i] = p;\n+            p *= 31;\n+        }\n+    }\n+    public static int hashCodeB_VectorAPI_v1(byte[] a) {\n+        int result = 1; \/\/ initialValue\n+        var vresult = IntVector.zero(SPECIES_I256);\n+        int next = REVERSE_POWERS_OF_31[0]; \/\/ 31^L\n+        var vnext = IntVector.broadcast(SPECIES_I256, next);\n+        var vcoef = IntVector.fromArray(SPECIES_I256, REVERSE_POWERS_OF_31, 1); \/\/ powers of 2 in reverse\n+        int i;\n+        for (i = 0; i < SPECIES_B64.loopBound(a.length); i += SPECIES_B64.length()) {\n+            \/\/ scalar part: result *= 31^L\n+            result *= next;\n+            \/\/ vector part: element-wise apply the next factor and add in the new values.\n+            var vb = ByteVector.fromArray(SPECIES_B64, a, i);\n+            var vi = vb.castShape(SPECIES_I256, 0);\n+            vresult = vresult.mul(vnext).add(vi);\n+        }\n+        \/\/ reduce the partial hashes in the elements, using the reverse list of powers of 2.\n+        result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+    byte[] aB;\n+\n@@ -93,0 +95,3 @@\n+\n+        aB = new byte[SIZE];\n+        RANDOM.nextBytes(aB);\n@@ -209,0 +214,15 @@\n+    @Benchmark\n+    public int hashCodeB_loop() {\n+        return VectorAlgorithmsImpl.hashCodeB_loop(aB);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_Arrays() {\n+        return VectorAlgorithmsImpl.hashCodeB_Arrays(aB);\n+    }\n+\n+    @Benchmark\n+    public int hashCodeB_VectorAPI_v1() {\n+        return VectorAlgorithmsImpl.hashCodeB_VectorAPI_v1(aB);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private static final VectorSpecies<Integer> SPECIES_I256 = IntVector.SPECIES_256;\n+    private static final VectorSpecies<Byte> SPECIES_B64     = ByteVector.SPECIES_64;\n@@ -219,0 +221,63 @@\n+    public static int hashCodeB_loop(byte[] a) {\n+        int h = 1;\n+        for (int i = 0; i < a.length; i++) {\n+            h = 31 * h + a[i];\n+        }\n+        return h;\n+    }\n+\n+    public static int hashCodeB_Arrays(byte[] a) {\n+        return Arrays.hashCode(a);\n+    }\n+\n+    \/\/ Simplified intrinsic code from C2_MacroAssembler::arrays_hashcode in c2_MacroAssembler_x86.cpp\n+    \/\/\n+    \/\/ Ideas that may help understand the code:\n+    \/\/\n+    \/\/ h(i) = 31 * h(i-1) + a[i]\n+    \/\/ \"unroll\" by factor of L=8:\n+    \/\/ h(i+8) = h(i) * 31^8 + a[i+1] * 31^7 + a[i+2] * 31^6 + ... + a[i+8] * 1\n+    \/\/          -----------   ------------------------------------------------\n+    \/\/          scalar        vector: notice the powers of 31 in reverse\n+    \/\/\n+    \/\/ We notice that we can load a[i+1 .. i+8], then element-wise multiply with\n+    \/\/ the vector of reversed powers-of-31, and then do reduceLanes(ADD).\n+    \/\/ But we can do even better: By looking at multiple such 8-unrolled iterations.\n+    \/\/ Instead of applying the \"next\" factor of \"31^8\" to the reduced scalar, we can\n+    \/\/ already apply it element-wise. That allows us to move the reduction out\n+    \/\/ of the loop.\n+    \/\/\n+    \/\/ Note: the intrinsic additionally unrolls the loop by a factor of 4,\n+    \/\/       but we want to keep thins simple for demonstration purposes.\n+    \/\/\n+    private static int[] REVERSE_POWERS_OF_31 = new int[9];\n+    static {\n+        int p = 1;\n+        for (int i = REVERSE_POWERS_OF_31.length - 1; i >= 0; i--) {\n+            REVERSE_POWERS_OF_31[i] = p;\n+            p *= 31;\n+        }\n+    }\n+    public static int hashCodeB_VectorAPI_v1(byte[] a) {\n+        int result = 1; \/\/ initialValue\n+        var vresult = IntVector.zero(SPECIES_I256);\n+        int next = REVERSE_POWERS_OF_31[0]; \/\/ 31^L\n+        var vnext = IntVector.broadcast(SPECIES_I256, next);\n+        var vcoef = IntVector.fromArray(SPECIES_I256, REVERSE_POWERS_OF_31, 1); \/\/ powers of 2 in reverse\n+        int i;\n+        for (i = 0; i < SPECIES_B64.loopBound(a.length); i += SPECIES_B64.length()) {\n+            \/\/ scalar part: result *= 31^L\n+            result *= next;\n+            \/\/ vector part: element-wise apply the next factor and add in the new values.\n+            var vb = ByteVector.fromArray(SPECIES_B64, a, i);\n+            var vi = vb.castShape(SPECIES_I256, 0);\n+            vresult = vresult.mul(vnext).add(vi);\n+        }\n+        \/\/ reduce the partial hashes in the elements, using the reverse list of powers of 2.\n+        result += vresult.mul(vcoef).reduceLanes(VectorOperators.ADD);\n+        for (; i < a.length; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}