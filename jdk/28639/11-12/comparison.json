{"files":[{"patch":"@@ -93,2 +93,2 @@\n-        testGroups.get(\"fillI\").put(\"fillI_VectorAPI\", i -> { return fillI_VectorAPI(d.rI1); });\n-        testGroups.get(\"fillI\").put(\"fillI_Arrays\",    i -> { return fillI_Arrays(d.rI1); });\n+        testGroups.get(\"fillI\").put(\"fillI_VectorAPI\", i -> { return fillI_VectorAPI(d.rI2); });\n+        testGroups.get(\"fillI\").put(\"fillI_Arrays\",    i -> { return fillI_Arrays(d.rI3); });\n@@ -98,1 +98,1 @@\n-        testGroups.get(\"iotaI\").put(\"iotaI_VectorAPI\", i -> { return iotaI_VectorAPI(d.rI1); });\n+        testGroups.get(\"iotaI\").put(\"iotaI_VectorAPI\", i -> { return iotaI_VectorAPI(d.rI2); });\n@@ -102,2 +102,2 @@\n-        testGroups.get(\"copyI\").put(\"copyI_VectorAPI\",        i -> { return copyI_VectorAPI(d.aI, d.rI1); });\n-        testGroups.get(\"copyI\").put(\"copyI_System_arraycopy\", i -> { return copyI_System_arraycopy(d.aI, d.rI1); });\n+        testGroups.get(\"copyI\").put(\"copyI_VectorAPI\",        i -> { return copyI_VectorAPI(d.aI, d.rI2); });\n+        testGroups.get(\"copyI\").put(\"copyI_System_arraycopy\", i -> { return copyI_System_arraycopy(d.aI, d.rI3); });\n@@ -107,1 +107,1 @@\n-        testGroups.get(\"mapI\").put(\"mapI_VectorAPI\", i -> { return mapI_VectorAPI(d.aI, d.rI1); });\n+        testGroups.get(\"mapI\").put(\"mapI_VectorAPI\", i -> { return mapI_VectorAPI(d.aI, d.rI2); });\n@@ -150,0 +150,5 @@\n+\n+        testGroups.put(\"lowerCaseB\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_loop\",         i -> { return lowerCaseB_loop(d.strB, d.rB1); });\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_VectorAPI_v1\", i -> { return lowerCaseB_VectorAPI_v1(d.strB, d.rB2); });\n+        testGroups.get(\"lowerCaseB\").put(\"lowerCaseB_VectorAPI_v2\", i -> { return lowerCaseB_VectorAPI_v2(d.strB, d.rB3); });\n@@ -186,1 +191,4 @@\n-                 \"reduceAddIFieldsX4_VectorAPI\"})\n+                 \"reduceAddIFieldsX4_VectorAPI\",\n+                 \"lowerCaseB_loop\",\n+                 \"lowerCaseB_VectorAPI_v1\",\n+                 \"lowerCaseB_VectorAPI_v2\"})\n@@ -524,0 +532,23 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\"})\n+    \/\/ Currently does not vectorize, but might in the future.\n+    public Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_loop(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v1(a, r);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v2(a, r);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorAlgorithms.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    private static final VectorSpecies<Byte> SPECIES_B       = ByteVector.SPECIES_PREFERRED;\n@@ -70,0 +71,4 @@\n+        public byte[] strB;\n+        public byte[] rB1;\n+        public byte[] rB2;\n+        public byte[] rB3;\n@@ -117,0 +122,4 @@\n+            strB = new byte[size];\n+            rB1 = new byte[size];\n+            rB2 = new byte[size];\n+            rB3 = new byte[size];\n@@ -118,0 +127,1 @@\n+            random.nextBytes(strB); \/\/ TODO: special data!\n@@ -204,1 +214,1 @@\n-            r[i] = a[i];\n+            r[i] = a[i] * 42;\n@@ -709,0 +719,55 @@\n+\n+    \/\/ The lowerCase example demonstrates a lane-wise control-flow diamond.\n+    public static Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A'); \/\/ c += 32\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Control-flow diamonds can easily be simulated by \"if-conversion\", i.e.\n+    \/\/ by using masked operations. An alternative would be to use blend.\n+    public static Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            var maskA = vc.compare(VectorOperators.GE, (byte)'A');\n+            var maskZ = vc.compare(VectorOperators.LE, (byte)'Z');\n+            var mask = maskA.and(maskZ);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    public static Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            \/\/ We can convert the range 65..90 (represents ascii A..Z) into a range 0..25.\n+            \/\/ This allows us to only use a single unsigned comparison.\n+            var vt = vc.add((byte)-'A');\n+            var mask = vt.compare(VectorOperators.ULE, (byte)25);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/VectorAlgorithmsImpl.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -259,0 +259,15 @@\n+\n+    @Benchmark\n+    public Object lowerCaseB_loop() {\n+        return VectorAlgorithmsImpl.lowerCaseB_loop(d.strB, d.rB1);\n+    }\n+\n+    @Benchmark\n+    public Object lowerCaseB_VectorAPI_v1() {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v1(d.strB, d.rB1);\n+    }\n+\n+    @Benchmark\n+    public Object lowerCaseB_VectorAPI_v2() {\n+        return VectorAlgorithmsImpl.lowerCaseB_VectorAPI_v2(d.strB, d.rB1);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithms.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    private static final VectorSpecies<Byte> SPECIES_B       = ByteVector.SPECIES_PREFERRED;\n@@ -70,0 +71,4 @@\n+        public byte[] strB;\n+        public byte[] rB1;\n+        public byte[] rB2;\n+        public byte[] rB3;\n@@ -117,0 +122,4 @@\n+            strB = new byte[size];\n+            rB1 = new byte[size];\n+            rB2 = new byte[size];\n+            rB3 = new byte[size];\n@@ -118,0 +127,1 @@\n+            random.nextBytes(strB); \/\/ TODO: special data!\n@@ -204,1 +214,1 @@\n-            r[i] = a[i];\n+            r[i] = a[i] * 42;\n@@ -709,0 +719,55 @@\n+\n+    \/\/ The lowerCase example demonstrates a lane-wise control-flow diamond.\n+    public static Object lowerCaseB_loop(byte[] a, byte[] r) {\n+        for (int i = 0; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A'); \/\/ c += 32\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Control-flow diamonds can easily be simulated by \"if-conversion\", i.e.\n+    \/\/ by using masked operations. An alternative would be to use blend.\n+    public static Object lowerCaseB_VectorAPI_v1(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            var maskA = vc.compare(VectorOperators.GE, (byte)'A');\n+            var maskZ = vc.compare(VectorOperators.LE, (byte)'Z');\n+            var mask = maskA.and(maskZ);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n+\n+    public static Object lowerCaseB_VectorAPI_v2(byte[] a, byte[] r) {\n+        int i;\n+        for (i = 0; i < SPECIES_B.loopBound(a.length); i += SPECIES_B.length()) {\n+            var vc = ByteVector.fromArray(SPECIES_B, a, i);\n+            \/\/ We can convert the range 65..90 (represents ascii A..Z) into a range 0..25.\n+            \/\/ This allows us to only use a single unsigned comparison.\n+            var vt = vc.add((byte)-'A');\n+            var mask = vt.compare(VectorOperators.ULE, (byte)25);\n+            vc = vc.add((byte)32, mask);\n+            vc.intoArray(r, i);\n+        }\n+        for (; i < a.length; i++) {\n+            byte c = a[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                c += ('a' - 'A');\n+            }\n+            r[i] = c;\n+        }\n+        return r;\n+    }\n@@ -710,0 +775,1 @@\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlgorithmsImpl.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"}]}