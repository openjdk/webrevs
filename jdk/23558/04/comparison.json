{"files":[{"patch":"@@ -83,0 +83,4 @@\n+const char *IdealGraphPrinter::LIVEOUT_ELEMENT = \"liveOut\";\n+const char *IdealGraphPrinter::LIVE_RANGE_ELEMENT = \"lrg\";\n+const char *IdealGraphPrinter::LIVE_RANGE_ID_PROPERTY = \"id\";\n+const char *IdealGraphPrinter::LIVE_RANGES_ELEMENT = \"liveRanges\";\n@@ -784,0 +788,6 @@\n+bool IdealGraphPrinter::has_liveness_info() const {\n+  return _chaitin &&\n+    _chaitin != (PhaseChaitin *)((intptr_t)0xdeadbeef) &&\n+    _chaitin->get_live() != nullptr;\n+}\n+\n@@ -880,0 +890,13 @@\n+      if (has_liveness_info()) {\n+        head(LIVEOUT_ELEMENT);\n+        const IndexSet* liveout = _chaitin->get_live()->live(block);\n+        IndexSetIterator lrgs(liveout);\n+        uint lrg;\n+        while ((lrg = lrgs.next()) != 0) {\n+          begin_elem(LIVE_RANGE_ELEMENT);\n+          print_attr(LIVE_RANGE_ID_PROPERTY, lrg);\n+          end_elem();\n+        }\n+        tail(LIVEOUT_ELEMENT);\n+      }\n+\n@@ -903,0 +926,85 @@\n+\n+  if (has_liveness_info()) {\n+    head(LIVE_RANGES_ELEMENT);\n+    for (uint i = 1; i < _chaitin->_lrg_map.max_lrg_id(); i++) {\n+      begin_head(LIVE_RANGE_ELEMENT);\n+      print_attr(LIVE_RANGE_ID_PROPERTY, i);\n+      end_head();\n+      head(PROPERTIES_ELEMENT);\n+      const LRG& lrg = _chaitin->lrgs(i);\n+      buffer[0] = 0;\n+      stringStream lrg_mask_stream(buffer, sizeof(buffer) - 1);\n+      lrg.mask().dump(&lrg_mask_stream);\n+      print_prop(\"mask\", buffer);\n+      print_prop(\"mask_size\", lrg.mask_size());\n+      if (lrg._degree_valid) {\n+        print_prop(\"degree\", lrg.degree());\n+      }\n+      print_prop(\"num_regs\", lrg.num_regs());\n+      print_prop(\"reg_pressure\", lrg.reg_pressure());\n+      print_prop(\"cost\", lrg._cost);\n+      print_prop(\"area\", lrg._area);\n+      print_prop(\"score\", lrg.score());\n+      if (lrg._risk_bias != 0) {\n+        print_prop(\"risk_bias\", lrg._risk_bias);\n+      }\n+      if (lrg._copy_bias != 0) {\n+        print_prop(\"copy_bias\", lrg._copy_bias);\n+      }\n+      if (lrg.is_singledef()) {\n+        print_prop(\"is_singledef\", TRUE_VALUE);\n+      }\n+      if (lrg.is_multidef()) {\n+        print_prop(\"is_multidef\", TRUE_VALUE);\n+      }\n+      if (lrg._is_oop) {\n+        print_prop(\"is_oop\", TRUE_VALUE);\n+      }\n+      if (lrg._is_float) {\n+        print_prop(\"is_float\", TRUE_VALUE);\n+      }\n+      if (lrg._is_vector) {\n+        print_prop(\"is_vector\", TRUE_VALUE);\n+      }\n+      if (lrg._is_predicate) {\n+        print_prop(\"is_predicate\", TRUE_VALUE);\n+      }\n+      if (lrg._is_scalable) {\n+        print_prop(\"is_scalable\", TRUE_VALUE);\n+      }\n+      if (lrg._was_spilled1) {\n+        print_prop(\"was_spilled1\", TRUE_VALUE);\n+      }\n+      if (lrg._was_spilled2) {\n+        print_prop(\"was_spilled2\", TRUE_VALUE);\n+      }\n+      if (lrg._direct_conflict) {\n+        print_prop(\"direct_conflict\", TRUE_VALUE);\n+      }\n+      if (lrg._fat_proj) {\n+        print_prop(\"fat_proj\", TRUE_VALUE);\n+      }\n+      if (lrg._was_lo) {\n+        print_prop(\"_was_lo\", TRUE_VALUE);\n+      }\n+      if (lrg._has_copy) {\n+        print_prop(\"has_copy\", TRUE_VALUE);\n+      }\n+      if (lrg._at_risk) {\n+        print_prop(\"at_risk\", TRUE_VALUE);\n+      }\n+      if (lrg._must_spill) {\n+        print_prop(\"must_spill\", TRUE_VALUE);\n+      }\n+      if (lrg._is_bound) {\n+        print_prop(\"is_bound\", TRUE_VALUE);\n+      }\n+      if (lrg._msize_valid && lrg._degree_valid && lrg.lo_degree()) {\n+        print_prop(\"trivial\", TRUE_VALUE);\n+      }\n+      tail(PROPERTIES_ELEMENT);\n+      tail(LIVE_RANGE_ELEMENT);\n+    }\n+    tail(LIVE_RANGES_ELEMENT);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,4 @@\n+  static const char *LIVEOUT_ELEMENT;\n+  static const char *LIVE_RANGE_ELEMENT;\n+  static const char *LIVE_RANGE_ID_PROPERTY;\n+  static const char *LIVE_RANGES_ELEMENT;\n@@ -117,0 +121,1 @@\n+  bool has_liveness_info() const;\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-            p.clearSelectedNodes();\n+            p.clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesAction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+    private Set<Integer> liveOut;\n@@ -73,0 +74,9 @@\n+        if (this.liveOut.size() != b.liveOut.size()) {\n+            return false;\n+        }\n+        for (int liveRangeId : this.liveOut) {\n+            if (!b.liveOut.contains(liveRangeId)) {\n+                return false;\n+            }\n+        }\n+\n@@ -81,0 +91,1 @@\n+        liveOut = new HashSet<Integer>(0);\n@@ -102,0 +113,8 @@\n+    public void addLiveOut(int liveRangeId) {\n+        liveOut.add(liveRangeId);\n+    }\n+\n+    public Set<Integer> getLiveOut() {\n+        return Collections.unmodifiableSet(liveOut);\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,5 @@\n+    private final Map<Integer, InputLiveRange> liveRanges;\n+    private Map<Integer, LivenessInfo> livenessInfo;\n+    private Map<Integer, Set<InputNode>> relatedNodes;\n+    private Map<Integer, Set<InputNode>> defNodes;\n+    private Map<Integer, Set<InputNode>> useNodes;\n@@ -61,0 +66,5 @@\n+        liveRanges = new LinkedHashMap<>();\n+        livenessInfo = new LinkedHashMap<>();\n+        relatedNodes = new LinkedHashMap<>();\n+        defNodes = new LinkedHashMap<>();\n+        useNodes = new LinkedHashMap<>();\n@@ -307,0 +317,51 @@\n+    public void addLiveRange(InputLiveRange lrg) {\n+        liveRanges.put(lrg.getId(), lrg);\n+        relatedNodes.put(lrg.getId(), new HashSet<>());\n+        defNodes.put(lrg.getId(), new HashSet<>());\n+        useNodes.put(lrg.getId(), new HashSet<>());\n+    }\n+\n+    public InputLiveRange getLiveRange(int liveRangeId) {\n+        return liveRanges.get(liveRangeId);\n+    }\n+\n+    public Collection<InputLiveRange> getLiveRanges() {\n+        return Collections.unmodifiableCollection(liveRanges.values());\n+    }\n+\n+    public void addLivenessInfo(InputNode node, LivenessInfo info) {\n+        livenessInfo.put(node.getId(), info);\n+        if (info.def != null) {\n+            relatedNodes.get(info.def).add(node);\n+            defNodes.get(info.def).add(node);\n+        }\n+        if (info.use != null) {\n+            for (int lrg : info.use) {\n+                relatedNodes.get(lrg).add(node);\n+                useNodes.get(lrg).add(node);\n+            }\n+        }\n+        if (info.join != null) {\n+            for (int lrg : info.join) {\n+                relatedNodes.get(lrg).add(node);\n+                useNodes.get(lrg).add(node);\n+            }\n+        }\n+    }\n+\n+    public LivenessInfo getLivenessInfoForNode(InputNode node) {\n+        return livenessInfo.get(node.getId());\n+    }\n+\n+    public Set<InputNode> getRelatedNodes(int liveRangeId) {\n+        return relatedNodes.get(liveRangeId);\n+    }\n+\n+    public Set<InputNode> getDefNodes(int liveRangeId) {\n+        return defNodes.get(liveRangeId);\n+    }\n+\n+    public Set<InputNode> getUseNodes(int liveRangeId) {\n+        return useNodes.get(liveRangeId);\n+    }\n+\n@@ -313,0 +374,3 @@\n+            if (livenessInfo.containsKey(n.getId())) {\n+                sb.append(\" \" + livenessInfo.get(n.getId()).toString());\n+            }\n@@ -326,0 +390,5 @@\n+        for (InputLiveRange l : liveRanges.values()) {\n+            sb.append(l.toString());\n+            sb.append(\"\\n\");\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.data;\n+\n+import java.util.Objects;\n+\n+public class InputLiveRange extends Properties.Entity {\n+\n+    private int id;\n+\n+    public InputLiveRange(InputLiveRange n) {\n+        super(n);\n+        setId(n.id);\n+    }\n+\n+    public InputLiveRange(int id) {\n+        setId(id);\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InputLiveRange other = (InputLiveRange) obj;\n+        return id == other.id &&\n+                Objects.equals(getProperties(), other.getProperties());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id, getProperties());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"L\" + id + \" \" + getProperties().toString();\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputLiveRange.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.data;\n+\n+import java.util.*;\n+\n+public class LivenessInfo {\n+\n+    public Integer def;\n+    public Set<Integer> use;\n+    public Set<Integer> kill;\n+    public Set<Integer> join;\n+    public Set<Integer> livein;\n+    public Set<Integer> liveout;\n+\n+    public LivenessInfo() {}\n+\n+    @Override\n+    public String toString() {\n+        return \"def: \" + def +\n+            \", use: \" + use +\n+            \", kill: \" + kill +\n+            \", join: \" + join +\n+            \", livein: \" + livein +\n+            \", liveout: \" + liveout;\n+    }\n+\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/LivenessInfo.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,3 @@\n+    public static final String LIVE_RANGE_ELEMENT = \"lrg\";\n+    public static final String LIVE_RANGES_ELEMENT = \"liveRanges\";\n+    public static final String LIVE_RANGE_ID_PROPERTY = \"id\";\n@@ -92,0 +95,1 @@\n+    public static final String LIVEOUT_ELEMENT = \"liveOut\";\n@@ -153,0 +157,3 @@\n+    \/\/ <liveRanges>\n+    private final HandoverElementHandler<InputGraph> liveRangesHandler = new HandoverElementHandler<>(LIVE_RANGES_ELEMENT);\n+    \/\/ <lrg>\n@@ -225,0 +232,35 @@\n+    \/\/ <liveOut>\n+    private final HandoverElementHandler<InputBlock> liveOutHandler = new HandoverElementHandler<>(LIVEOUT_ELEMENT);\n+    \/\/ <lrg>\n+    private final ElementHandler<InputLiveRange, InputGraph> liveRangeHandler = new ElementHandler<>(LIVE_RANGE_ELEMENT) {\n+\n+        @Override\n+        protected InputLiveRange start() throws SAXException {\n+            String s = readRequiredAttribute(NODE_ID_PROPERTY);\n+            int id;\n+            try {\n+                id = lookupID(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n+            }\n+            InputLiveRange lrg = new InputLiveRange(id);\n+            getParentObject().addLiveRange(lrg);\n+            return lrg;\n+        }\n+    };\n+\n+    private final ElementHandler<InputBlock, InputBlock> blockLiveRangeHandler = new ElementHandler<>(LIVE_RANGE_ELEMENT) {\n+\n+        @Override\n+        protected InputBlock start() throws SAXException {\n+            String s = readRequiredAttribute(LIVE_RANGE_ID_PROPERTY);\n+            int liveRangeId;\n+            try {\n+                liveRangeId = Integer.parseInt(s);\n+            } catch (Exception e) {\n+                throw new SAXException(e);\n+            }\n+            getParentObject().addLiveOut(liveRangeId);\n+            return getParentObject();\n+        }\n+    };\n@@ -485,0 +527,1 @@\n+        graphHandler.addChild(liveRangesHandler);\n@@ -498,0 +541,4 @@\n+        blockHandler.addChild(liveOutHandler);\n+        liveOutHandler.addChild(blockLiveRangeHandler);\n+\n+        liveRangesHandler.addChild(liveRangeHandler);\n@@ -512,0 +559,1 @@\n+        liveRangeHandler.addChild(propertiesHandler);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,0 +173,8 @@\n+            if (!b.getLiveOut().isEmpty()) {\n+                writer.startTag(Parser.LIVEOUT_ELEMENT);\n+                for (Integer lrg : b.getLiveOut()) {\n+                    writer.simpleTag(Parser.LIVE_RANGE_ELEMENT, new Properties(Parser.LIVE_RANGE_ID_PROPERTY, String.valueOf(lrg)));\n+                }\n+                writer.endTag(); \/\/ Parser.LIVEOUT_ELEMENT\n+            }\n+\n@@ -178,0 +186,10 @@\n+        if (!graph.getLiveRanges().isEmpty()) {\n+            writer.startTag(Parser.LIVE_RANGES_ELEMENT);\n+            for (InputLiveRange liveRange : graph.getLiveRanges()) {\n+                writer.startTag(Parser.LIVE_RANGE_ELEMENT, new Properties(Parser.LIVE_RANGE_ID_PROPERTY, String.valueOf(liveRange.getId())));\n+                writer.writeProperties(liveRange.getProperties());\n+                writer.endTag(); \/\/ Parser.LIVE_RANGE_ELEMENT\n+            }\n+            writer.endTag(); \/\/ Parser.LIVE_RANGES_ELEMENT\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    void clearSelectedNodes();\n+    void clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/InputGraphProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.data.services;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+\n+public interface PreProcessor {\n+    public void preProcess(InputGraph graph);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/PreProcessor.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -146,0 +146,11 @@\n+            <xsd:element name=\"liveOut\" minOccurs=\"0\" maxOccurs=\"1\">\n+                <xsd:complexType>\n+                    <xsd:sequence>\n+                        <xsd:element name=\"lrg\" minOccurs=\"0\" maxOccurs=\"unbounded\">\n+                            <xsd:complexType>\n+                                <xsd:attribute name=\"id\" type=\"xsd:string\" use=\"required\" \/>\n+                            <\/xsd:complexType>\n+                        <\/xsd:element>\n+                    <\/xsd:sequence>\n+                <\/xsd:complexType>\n+            <\/xsd:element>\n@@ -147,1 +158,0 @@\n-        \n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/resources\/com\/sun\/hotspot\/igv\/data\/serialization\/graphdocument.xsd","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.data.services.PreProcessor;\n@@ -87,0 +88,2 @@\n+        PreProcessor p = Lookup.getDefault().lookup(PreProcessor.class);\n+        p.preProcess(a);\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.filter;\n+\n+import com.sun.hotspot.igv.graph.*;\n+import java.awt.Color;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ColorLiveRangeFilter extends AbstractFilter {\n+\n+    private List<ColorRule> colorRules;\n+    private String name;\n+\n+    public ColorLiveRangeFilter(String name) {\n+        this.name = name;\n+        colorRules = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void apply(Diagram diagram) {\n+        for (ColorRule rule : colorRules) {\n+            if (rule.getSelector() != null) {\n+                List<LiveRangeSegment> segments = rule.getSelector().selected(diagram);\n+                for (LiveRangeSegment s : segments) {\n+                    applyRule(rule, s);\n+                    if (rule.getColor() != null) {\n+                        s.setColor(rule.getColor());\n+                    }\n+                }\n+            } else {\n+                for (LiveRangeSegment s : diagram.getLiveRangeSegments()) {\n+                    applyRule(rule, s);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void applyRule(ColorRule rule, LiveRangeSegment s) {\n+        if (rule.getColor() != null) {\n+            s.setColor(rule.getColor());\n+        }\n+    }\n+\n+    public void addRule(ColorRule r) {\n+        colorRules.add(r);\n+    }\n+\n+    public static class ColorRule {\n+\n+        private Color color;\n+        private LiveRangeSelector selector;\n+\n+        public ColorRule(LiveRangeSelector selector, Color c) {\n+            this.selector = selector;\n+            this.color = c;\n+        }\n+\n+        public ColorRule(Color c) {\n+            this(null, c);\n+        }\n+\n+        public Color getColor() {\n+            return color;\n+        }\n+\n+        public LiveRangeSelector getSelector() {\n+            return selector;\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorLiveRangeFilter.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,5 @@\n+\/\/ Select the nodes for which the given property is defined.\n+function hasProperty(property) {\n+    return new MatcherSelector(new Properties.InvertPropertyMatcher(new Properties.RegexpPropertyMatcher(property, \"\")));\n+}\n+\n@@ -228,0 +233,12 @@\n+\n+\/\/ Color the selected live ranges.\n+function colorizeLiveRange(selector, color) {\n+    var f = new ColorLiveRangeFilter(\"\");\n+    f.addRule(new ColorLiveRangeFilter.ColorRule(selector, color));\n+    f.apply(graph);\n+}\n+\n+\/\/ Select the live ranges whose given property matches a given regular expression.\n+function matchesLiveRange(property, regexp) {\n+    return new LiveRangeMatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp));\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filter\/helper.js","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+    private List<Integer> liveRangeIds;\n+    int liveRangeSeparation = -1;\n@@ -73,0 +75,5 @@\n+    public int getLiveRangeSeparation() {\n+        assert liveRangeSeparation > 0;\n+        return liveRangeSeparation;\n+    }\n+\n@@ -94,0 +101,13 @@\n+    public List<Integer> getLiveRangeIds() {\n+        return liveRangeIds;\n+    }\n+\n+    public void setLiveRangeIds(List<Integer> liveRangeIds) {\n+        this.liveRangeIds = liveRangeIds;\n+        int extraDigits = 0;\n+        if (!liveRangeIds.isEmpty()) {\n+            extraDigits = (int)java.lang.Math.log10(Collections.max(liveRangeIds));\n+        }\n+        liveRangeSeparation = 20 + extraDigits * 7;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+    private final Hashtable<Integer, Figure> figureHash;\n@@ -39,0 +40,1 @@\n+    private List<LiveRangeSegment> liveRangeSegments;\n@@ -68,0 +70,1 @@\n+        this.figureHash = new Hashtable<>();\n@@ -69,0 +72,1 @@\n+        this.liveRangeSegments = new ArrayList<>();\n@@ -79,1 +83,0 @@\n-        Hashtable<Integer, Figure> figureHash = new Hashtable<>();\n@@ -131,0 +134,108 @@\n+\n+        Hashtable<Integer, InputLiveRange> liveRangeHash = new Hashtable<>();\n+        for (InputLiveRange lrg : graph.getLiveRanges()) {\n+            liveRangeHash.put(lrg.getId(), lrg);\n+        }\n+\n+        \/\/ Pre-compute live ranges joined by each block.\n+        Map<InputBlock, Set<Integer>> blockJoined = new HashMap<>();\n+        for (InputBlock b : graph.getBlocks()) {\n+            blockJoined.put(b, new HashSet<>());\n+            for (InputNode n : b.getNodes()) {\n+                LivenessInfo l = graph.getLivenessInfoForNode(n);\n+                if (l != null && l.join != null) {\n+                    blockJoined.get(b).addAll(l.join);\n+                }\n+            }\n+        }\n+\n+        for (InputBlock b : graph.getBlocks()) {\n+            if (b.getNodes().isEmpty()) {\n+                continue;\n+            }\n+            Map<Integer, InputNode> active = new HashMap<>();\n+            Set<Integer> instant = new HashSet<>();\n+            Set<Integer> opening = new HashSet<>();\n+            InputNode header = b.getNodes().get(0);\n+            if (graph.getLivenessInfoForNode(header) == null) {\n+                \/\/ No liveness information available, skip.\n+                continue;\n+            }\n+            Set<Integer> joined = new HashSet<>();\n+            if (b.getSuccessors().size() == 1) {\n+                \/\/ We assume the live-out ranges in this block might only be\n+                \/\/ joined if there is exactly one successor block (i.e. the CFG\n+                \/\/ does not contain critical edges).\n+                joined.addAll(b.getLiveOut());\n+                InputBlock succ = b.getSuccessors().iterator().next();\n+                joined.retainAll(blockJoined.get(succ));\n+            }\n+            for (int liveRangeId : graph.getLivenessInfoForNode(header).livein) {\n+                active.put(liveRangeId, null);\n+            }\n+            for (InputNode n : b.getNodes()) {\n+                LivenessInfo l = graph.getLivenessInfoForNode(n);\n+                \/\/ Commit segments killed by n.\n+                if (l.kill != null) {\n+                    for (int liveRangeId : l.kill) {\n+                        InputNode startNode = active.get(liveRangeId);\n+                        Figure start = startNode == null ? null : figureHash.get(startNode.getId());\n+                        InputNode endNode = n;\n+                        Figure end = figureHash.get(endNode.getId());\n+                        LiveRangeSegment s = new LiveRangeSegment(liveRangeHash.get(liveRangeId), getBlock(b), start, end);\n+                        if (opening.contains(liveRangeId)) {\n+                            s.setOpening(true);\n+                        }\n+                        s.setClosing(true);\n+                        liveRangeSegments.add(s);\n+                        active.remove(liveRangeId);\n+                    }\n+                }\n+                \/\/ Activate new segments.\n+                if (l.def != null && !active.containsKey(l.def)) {\n+                    InputNode startNode = n;\n+                    if (l.join != null && !l.join.isEmpty()) {\n+                        \/\/ Start of a \"joined\" live range. These start always at\n+                        \/\/ the beginning of the basic block.\n+                        startNode = null;\n+                    }\n+                    active.put(l.def, startNode);\n+                    opening.add(l.def);\n+                    if (!l.liveout.contains(l.def)) {\n+                        instant.add(l.def);\n+                    }\n+                }\n+            }\n+            \/\/ Commit segments live out the block.\n+            for (Integer liveRangeId : active.keySet()) {\n+                InputNode startNode = active.get(liveRangeId);\n+                Figure start = startNode == null ? null : figureHash.get(startNode.getId());\n+                LiveRangeSegment s = new LiveRangeSegment(liveRangeHash.get(liveRangeId), getBlock(b), start, null);\n+                if (instant.contains(liveRangeId)) {\n+                    s.setInstantaneous(true);\n+                }\n+                if (opening.contains(liveRangeId)) {\n+                    s.setOpening(true);\n+                }\n+                if (instant.contains(liveRangeId) || joined.contains(liveRangeId)) {\n+                    s.setClosing(true);\n+                }\n+                liveRangeSegments.add(s);\n+            }\n+        }\n+        liveRangeSegments.sort(Comparator.comparingInt(s -> s.getLiveRange().getId()));\n+        for (InputBlock inputBlock : graph.getBlocks()) {\n+            \/\/ This loop could be sped up by fusing it with the above one.\n+            List<Integer> liveRangeSegmentIds = new ArrayList<>();\n+            int lastAddedLiveRangeId = -1;\n+            for (LiveRangeSegment s : getLiveRangeSegments()) {\n+                if (s.getCluster().getInputBlock().getName().equals(inputBlock.getName())) {\n+                    int thisLiveRangeId = s.getLiveRange().getId();\n+                    if (thisLiveRangeId != lastAddedLiveRangeId) {\n+                        liveRangeSegmentIds.add(thisLiveRangeId);\n+                        lastAddedLiveRangeId = thisLiveRangeId;\n+                    }\n+                }\n+            }\n+            blocks.get(inputBlock).setLiveRangeIds(liveRangeSegmentIds);\n+        }\n@@ -179,0 +290,4 @@\n+    public List<LiveRangeSegment> getLiveRangeSegments() {\n+        return Collections.unmodifiableList(liveRangeSegments);\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":117,"deletions":2,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import com.sun.hotspot.igv.data.Properties;\n+import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n+import java.util.List;\n+\n+public class LiveRangeMatcherSelector implements LiveRangeSelector {\n+\n+    private PropertyMatcher matcher;\n+\n+    public LiveRangeMatcherSelector(PropertyMatcher matcher) {\n+        this.matcher = matcher;\n+    }\n+\n+    @Override\n+    public List<LiveRangeSegment> selected(Diagram d) {\n+        Properties.PropertySelector<LiveRangeSegment> selector = new Properties.PropertySelector<>(d.getLiveRangeSegments());\n+        List<LiveRangeSegment> list = selector.selectMultiple(matcher);\n+        return list;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/LiveRangeMatcherSelector.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import com.sun.hotspot.igv.data.InputLiveRange;\n+import com.sun.hotspot.igv.data.Properties;\n+import com.sun.hotspot.igv.layout.Segment;\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.util.Set;\n+\n+public class LiveRangeSegment extends Properties.Entity implements Segment {\n+\n+    private InputLiveRange liveRange;\n+    private Block block;\n+    private Figure start;\n+    private Figure end;\n+    private Point startPoint;\n+    private Point endPoint;\n+    private boolean lastOfLiveRange;\n+    private boolean instantaneous;\n+    private boolean opening;\n+    private boolean closing;\n+    private Set<LiveRangeSegment> segmentSet;\n+    private Color color;\n+\n+    protected LiveRangeSegment(InputLiveRange liveRange, Block block, Figure start, Figure end) {\n+        this.block = block;\n+        this.liveRange = liveRange;\n+        this.start = start;\n+        this.end = end;\n+        assert(start == null || end == null || (start.getBlock() == end.getBlock()));\n+        lastOfLiveRange = true;\n+        this.color = Color.BLACK;\n+    }\n+\n+    public InputLiveRange getLiveRange() {\n+        return liveRange;\n+    }\n+\n+    public Block getCluster() {\n+        return block;\n+    }\n+\n+    public Figure getStart() {\n+        return start;\n+    }\n+\n+    public Figure getEnd() {\n+        return end;\n+    }\n+\n+    public Point getStartPoint() {\n+        return startPoint;\n+    }\n+\n+    public void setStartPoint(Point startPoint) {\n+        this.startPoint = startPoint;\n+    }\n+\n+    public Point getEndPoint() {\n+        return endPoint;\n+    }\n+\n+    public void setEndPoint(Point endPoint) {\n+        this.endPoint = endPoint;\n+    }\n+\n+    public void setLastOfLiveRange(boolean lastOfLiveRange) {\n+        this.lastOfLiveRange = lastOfLiveRange;\n+    }\n+\n+    public boolean isLastOfLiveRange() {\n+        return lastOfLiveRange;\n+    }\n+\n+    public int parentId() {\n+        return this.liveRange.getId();\n+    }\n+\n+    public void setInstantaneous(boolean instantaneous) {\n+        this.instantaneous = instantaneous;\n+    }\n+\n+    public boolean isInstantaneous() {\n+        return instantaneous;\n+    }\n+\n+    public void setOpening(boolean opening) {\n+        this.opening = opening;\n+    }\n+\n+    public boolean isOpening() {\n+        return opening;\n+    }\n+\n+    public void setClosing(boolean closing) {\n+        this.closing = closing;\n+    }\n+\n+    public boolean isClosing() {\n+        return closing;\n+    }\n+\n+    public Set<LiveRangeSegment> getSegmentSet() {\n+        return segmentSet;\n+    }\n+\n+    public void setSegmentSet(Set<LiveRangeSegment> segmentSet) {\n+        this.segmentSet = segmentSet;\n+    }\n+\n+    public void setColor(Color color) {\n+        this.color = color;\n+    }\n+\n+    public Color getColor() {\n+        return color;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LiveRangeSegment(\" + liveRange + \"@B\" + block + \", \" + start + \", \" + end + \")\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof LiveRangeSegment)) {\n+            return false;\n+        }\n+        LiveRangeSegment other = (LiveRangeSegment)o;\n+        if (getStart() == null && other.getStart() != null) {\n+            return false;\n+        }\n+        if (getStart() != null && other.getStart() == null) {\n+            return false;\n+        }\n+        if (getEnd() == null && other.getEnd() != null) {\n+            return false;\n+        }\n+        if (getEnd() != null && other.getEnd() == null) {\n+            return false;\n+        }\n+        return getLiveRange().equals(((LiveRangeSegment)o).getLiveRange())\n+            && (getStart() == null || getStart().equals(((LiveRangeSegment)o).getStart()))\n+            && (getEnd() == null || getEnd().equals(((LiveRangeSegment)o).getEnd()));\n+    }\n+\n+    @Override\n+    public Properties getProperties() {\n+        return liveRange.getProperties();\n+    }\n+\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/LiveRangeSegment.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.graph;\n+\n+import java.util.List;\n+\n+public interface LiveRangeSelector {\n+    List<LiveRangeSegment> selected(Diagram d);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/LiveRangeSelector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.layout.Segment;\n@@ -48,0 +49,1 @@\n+    private final List<Segment> subSegments;\n@@ -53,0 +55,3 @@\n+    public static final int EMPTY_BLOCK_LIVE_RANGE_X_OFFSET = 20;\n+    public static final int EMPTY_BLOCK_LIVE_RANGE_Y_OFFSET = 6;\n+\n@@ -56,0 +61,1 @@\n+        this.subSegments = new ArrayList<>();\n@@ -86,0 +92,14 @@\n+    public void addSubSegment(Segment s) {\n+        subSegments.add(s);\n+    }\n+\n+    public void groupSegments() {\n+        for (int i = 1; i < subSegments.size(); i++) {\n+            if (subSegments.get(i).parentId() == subSegments.get(i - 1).parentId()) {\n+                subSegments.get(i - 1).setLastOfLiveRange(false);\n+            } else {\n+                subSegments.get(i - 1).setLastOfLiveRange(true);\n+            }\n+        }\n+    }\n+\n@@ -109,1 +129,1 @@\n-        if (subNodes.isEmpty()) {\n+        if (subNodes.isEmpty() && subSegments.isEmpty()) {\n@@ -140,0 +160,12 @@\n+        for (Segment segment : subSegments) {\n+            Point s = segment.getStartPoint();\n+            minX = Math.min(minX, s.x);\n+            maxX = Math.max(maxX, s.x + cluster.getLiveRangeSeparation());\n+        }\n+        if (!subSegments.isEmpty()) {\n+            maxX += cluster.getLiveRangeSeparation();\n+        }\n+        if (subNodes.isEmpty()) {\n+            maxX += ClusterNode.EMPTY_BLOCK_LIVE_RANGE_X_OFFSET;\n+        }\n+\n@@ -176,0 +208,2 @@\n+        int startX = pos.x + PADDING;\n+        int startY = pos.y + PADDING;\n@@ -177,0 +211,1 @@\n+        int minY = Integer.MAX_VALUE;\n@@ -180,1 +215,1 @@\n-            cur.translate(pos.x + PADDING, pos.y + PADDING);\n+            cur.translate(startX, startY);\n@@ -182,0 +217,1 @@\n+            minY = Math.min(minY, cur.y);\n@@ -190,1 +226,1 @@\n-                    p2.translate(pos.x + PADDING, pos.y + PADDING);\n+                    p2.translate(startX, startY);\n@@ -199,0 +235,8 @@\n+\n+        if (subNodes.isEmpty()) {\n+            minY = startY + 12;\n+        }\n+        for (Segment s : subSegments) {\n+            s.getStartPoint().translate(startX + cluster.getLiveRangeSeparation(), minY);\n+            s.getEndPoint().translate(startX + cluster.getLiveRangeSeparation(), minY);\n+        }\n@@ -230,0 +274,4 @@\n+    public List<? extends Segment> getSubSegments() {\n+        return subSegments;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.layout.Segment;\n@@ -29,1 +30,5 @@\n-import java.awt.*;\n+import java.awt.Canvas;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Point;\n@@ -40,0 +45,1 @@\n+    private List<Segment> segments;\n@@ -44,0 +50,1 @@\n+        this.segments = new ArrayList<>();\n@@ -57,1 +64,1 @@\n-    private static void doLinearLayout(ClusterNode clusterNode) {\n+    private void doLinearLayout(ClusterNode clusterNode) {\n@@ -59,0 +66,1 @@\n+        clusterNode.groupSegments();\n@@ -60,1 +68,3 @@\n-        int curY = 0;\n+\n+        \/\/ Compute list of vertices that are actually laid out.\n+        List<Vertex> vertices = new ArrayList<>(cluster.getVertices().size());\n@@ -62,3 +72,2 @@\n-            if (graph.containsVertex(vertex)) {\n-                vertex.setPosition(new Point(0, curY));\n-                curY += vertex.getSize().height;\n+            if (graph.containsVertex(vertex)) { \/\/ The vertex is visible.\n+                vertices.add(vertex);\n@@ -67,0 +76,39 @@\n+        int curY = 0;\n+        for (Vertex vertex : vertices) {\n+            vertex.setPosition(new Point(0, curY));\n+            curY += vertex.getSize().height;\n+        }\n+\n+        \/\/ If live segments are available, compute their position.\n+        if (vertices.isEmpty()) {\n+            int x = ClusterNode.EMPTY_BLOCK_LIVE_RANGE_X_OFFSET;\n+            final int y = ClusterNode.EMPTY_BLOCK_LIVE_RANGE_Y_OFFSET;\n+            for (Segment s : clusterNode.getSubSegments()) {\n+                s.setStartPoint(new Point(x, y));\n+                s.setEndPoint(new Point(x, y));\n+                if (s.isLastOfLiveRange()) {\n+                    x += s.getCluster().getLiveRangeSeparation();\n+                }\n+            }\n+        } else {\n+            Vertex first = vertices.get(0);\n+            int x = (int)first.getSize().getWidth();\n+            int entryY = (int)first.getPosition().getY();\n+            Vertex last = vertices.get(vertices.size() - 1);\n+            int exitY = (int)last.getPosition().getY() + (int)last.getSize().getHeight();\n+            for (Segment s : clusterNode.getSubSegments()) {\n+                Vertex start = s.getStart();\n+                Vertex end = s.getEnd();\n+                int startY = s.getStart() == null ? entryY : (start.getPosition().y + (int)(start.getSize().getHeight() \/ 2));\n+                s.setStartPoint(new Point(x, startY));\n+                int endY = end == null ? exitY : (end.getPosition().y + (int)(end.getSize().getHeight() \/ 2));\n+                if (s.isInstantaneous()) {\n+                    endY = startY;\n+                }\n+                s.setEndPoint(new Point(x, endY));\n+                if (s.isLastOfLiveRange()) {\n+                    x += s.getCluster().getLiveRangeSeparation();\n+                }\n+            }\n+        }\n+\n@@ -70,0 +118,4 @@\n+    public void setSegments(List<Segment> segments) {\n+        this.segments = segments;\n+    }\n+\n@@ -77,0 +129,7 @@\n+        \/\/ Compute sub-segments in every cluster.\n+        for (Segment s : segments) {\n+            Cluster c = s.getCluster();\n+            assert c != null : \"Cluster of segment \" + s + \" is null!\";\n+            clusterNodesMap.get(c).addSubSegment(s);\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+\n+    int getLiveRangeSeparation();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.layout;\n+\n+import java.awt.Point;\n+\n+public interface Segment {\n+    Cluster getCluster();\n+    Vertex getStart();\n+    Vertex getEnd();\n+    Point getStartPoint();\n+    void setStartPoint(Point startPoint);\n+    Point getEndPoint();\n+    void setEndPoint(Point endPoint);\n+    boolean isLastOfLiveRange();\n+    void setLastOfLiveRange(boolean lastOfLiveRange);\n+    int parentId();\n+    boolean isInstantaneous();\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Segment.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.servercompiler;\n+\n+import com.sun.hotspot.igv.data.*;\n+import com.sun.hotspot.igv.data.services.PreProcessor;\n+import org.openide.util.lookup.ServiceProvider;\n+import java.util.*;\n+import java.util.stream.*;\n+\n+@ServiceProvider(service = PreProcessor.class)\n+public class ServerCompilerPreProcessor implements PreProcessor {\n+\n+    private static boolean isPhi(InputNode node, int defLiveRange, List<Integer> uses) {\n+        String nodeName = node.getProperties().get(\"name\");\n+        if (nodeName == null) {\n+            return false;\n+        }\n+        if (!nodeName.equals(\"Phi\")) {\n+            return false;\n+        }\n+        Set<Integer> useSet = new HashSet<>(uses);\n+        if (useSet.size() == 1 && useSet.iterator().next() == defLiveRange) {\n+            \/\/ The phi operands have been coalesced, treat as a regular instruction.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static int getNumericPropertyOrZero(InputNode node, String k) {\n+        int v = 0;\n+        try {\n+            v = Integer.parseInt(node.getProperties().get(k));\n+        } catch (Exception e) {\n+        }\n+        return v;\n+    }\n+\n+    private static boolean isAllocatableLiveRange(int liveRangeId) {\n+        return liveRangeId > 0;\n+    }\n+\n+    private String liveRangeList(Stream<Integer> s) {\n+        return s.sorted().map(String::valueOf).collect(Collectors.joining(\", \"));\n+    }\n+\n+    @Override\n+    public void preProcess(InputGraph graph) {\n+        if (graph.getLiveRanges().isEmpty()) {\n+            \/\/ No block-level liveness information available, move on.\n+            return;\n+        }\n+        \/\/ Build a map from nodes to live ranges used.\n+        Map<Integer, List<Integer>> usedLiveRanges = new HashMap<>(graph.getNodes().size());\n+        for (InputEdge e : graph.getEdges()) {\n+            int liveRangeId = getNumericPropertyOrZero(graph.getNode(e.getFrom()), \"lrg\");\n+            if (isAllocatableLiveRange(liveRangeId)) {\n+                int toId = e.getTo();\n+                if (usedLiveRanges.get(toId) == null) {\n+                    usedLiveRanges.put(toId, new ArrayList<Integer>());\n+                }\n+                usedLiveRanges.get(toId).add(liveRangeId);\n+            }\n+        }\n+        \/\/ Propagate block-level live-out information to each node.\n+        for (InputBlock b : graph.getBlocks()) {\n+            Set<Integer> liveOut = new HashSet<>();\n+            for (int lrg : b.getLiveOut()) {\n+                liveOut.add(lrg);\n+            }\n+            for (int i = b.getNodes().size() - 1; i >= 0; i--) {\n+                LivenessInfo livenessInfo = new LivenessInfo();\n+                InputNode n = b.getNodes().get(i);\n+                String liveOutList = liveRangeList(liveOut.stream());\n+                n.getProperties().setProperty(\"liveout\", liveOutList);\n+                livenessInfo.liveout = new HashSet<>(liveOut);\n+                int defLiveRange = getNumericPropertyOrZero(n, \"lrg\");\n+                if (isAllocatableLiveRange(defLiveRange)) {\n+                    livenessInfo.def = defLiveRange;\n+                    \/\/ Otherwise it is missing or a non-allocatable live range.\n+                    liveOut.remove(defLiveRange);\n+                }\n+                List<Integer> uses = usedLiveRanges.get(n.getId());\n+                if (uses != null) {\n+                    String useList = liveRangeList(uses.stream());\n+                    if (isPhi(n, defLiveRange, uses)) {\n+                        \/\/ A phi's uses are not live simultaneously.\n+                        \/\/ Conceptually, they die at the block's incoming egdes.\n+                        n.getProperties().setProperty(\"joins\", useList);\n+                        livenessInfo.join = new HashSet<>(uses);\n+                    } else {\n+                        n.getProperties().setProperty(\"uses\", useList);\n+                        livenessInfo.use = new HashSet<>(uses);\n+                        \/\/ Compute kill set: all uses that are not in the\n+                        \/\/ live-out set of the node.\n+                        Set<Integer> kills = new HashSet<>();\n+                        for (int useLiveRange : uses) {\n+                            if (!liveOut.contains(useLiveRange) && useLiveRange != defLiveRange) {\n+                                kills.add(useLiveRange);\n+                            }\n+                        }\n+                        if (!kills.isEmpty()) {\n+                            String killList = liveRangeList(kills.stream());\n+                            n.getProperties().setProperty(\"kills\", killList);\n+                            livenessInfo.kill = new HashSet<>(kills);\n+                        }\n+                        for (int useLiveRange : uses) {\n+                            liveOut.add(useLiveRange);\n+                        }\n+                    }\n+                }\n+                String liveInList = liveRangeList(liveOut.stream());\n+                n.getProperties().setProperty(\"livein\", liveInList);\n+                livenessInfo.livein = new HashSet<>(liveOut);\n+                graph.addLivenessInfo(n, livenessInfo);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerPreProcessor.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+\/\/ Fade out live ranges allocated to stack lots.\n+\n+colorizeLiveRange(matchesLiveRange(\"mask\", \"\\\\[rS.+\\\\]\"), Color.LIGHT_GRAY);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/colorLiveRanges.filter","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/\/ This filter replaces the extra-label line with liveness information such as\n+\/\/ uses, defs, and live-out sets, if available.\n+\n+function formatLiveRange(lrg) {\n+  flrg = \"L\";\n+  flrg += lrg.trim();\n+  return flrg;\n+}\n+\n+function liveRangeSet(integerList) {\n+  return \"{\" + (integerList.split(\",\").map(function(lrg) {return formatLiveRange(lrg);})).join(\", \") + \"}\";\n+}\n+\n+\/\/ Replace extra label with liveness info.\n+function addLivenessInfo(lrg, idx, liveout, uses, joins, kills) {\n+  if (lrg == null || liveout == null) {\n+    return \"\";\n+  }\n+  elements = [];\n+  if (Number(lrg) > 0) {\n+    elements.push(\"def: \" + formatLiveRange(lrg));\n+  }\n+  if (uses != null) {\n+    elements.push(\"use: \" + liveRangeSet(uses));\n+  }\n+  if (joins != null) {\n+    elements.push(\"join: \" + liveRangeSet(joins));\n+  }\n+  if (kills != null) {\n+    elements.push(\"kill: \" + liveRangeSet(kills));\n+  }\n+  if (liveout.length > 0) {\n+    elements.push(\"liveout: \" + liveRangeSet(liveout));\n+  }\n+  return elements.join(\", \");\n+}\n+\n+editProperty(or([hasProperty(\"liveout\"), hasProperty(\"uses\"), hasProperty(\"joins\"), hasProperty(\"kills\")]),\n+             [\"lrg\", \"idx\", \"liveout\", \"uses\", \"joins\", \"kills\"],\n+             \"extra_label\",\n+             function(propertyValues) {return addLivenessInfo(propertyValues[0], propertyValues[1], propertyValues[2], propertyValues[3], propertyValues[4], propertyValues[5]);});\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/showLiveness.filter","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+\/\/ Remove all nodes except those that affect register allocation.\n+remove(and([matches(\"lrg\", \"0\"),\n+            not(hasProperty(\"uses\")),\n+            not(hasProperty(\"joins\")),\n+            not(hasProperty(\"kills\"))]));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/showRegisterAllocationOnly.filter","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -88,0 +88,12 @@\n+        <file name=\"Color live ranges by allocation.js\" url=\"filters\/colorLiveRanges.filter\">\n+            <attr name=\"enabled\" boolvalue=\"true\"\/>\n+            <attr name=\"after\" stringvalue=\"Hide exception blocks\"\/>\n+        <\/file>\n+        <file name=\"Show liveness information.js\" url=\"filters\/showLiveness.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Color live ranges by allocation\"\/>\n+        <\/file>\n+        <file name=\"Show register allocation only.js\" url=\"filters\/showRegisterAllocationOnly.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Show liveness information\"\/>\n+        <\/file>\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,13 +28,1 @@\n-import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n-import com.sun.hotspot.igv.util.LookupHistory;\n-import com.sun.hotspot.igv.util.StringUtils;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import org.netbeans.spi.quicksearch.SearchProvider;\n-import org.netbeans.spi.quicksearch.SearchRequest;\n-import org.netbeans.spi.quicksearch.SearchResponse;\n-import org.openide.DialogDisplayer;\n-import org.openide.NotifyDescriptor;\n-import org.openide.NotifyDescriptor.Message;\n+import java.util.*;\n@@ -42,1 +30,1 @@\n-public class BlockQuickSearch implements SearchProvider {\n+public class BlockQuickSearch extends SimpleQuickSearch {\n@@ -45,60 +33,2 @@\n-    public void evaluate(SearchRequest request, SearchResponse response) {\n-        String rawValue = request.getText();\n-        if (rawValue.trim().isEmpty()) {\n-            return;\n-        }\n-        String value = \".*\" + Pattern.quote(rawValue) + \".*\";\n-\n-        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n-        if (p == null || p.getGraph() == null) {\n-            return;\n-        }\n-\n-        InputGraph matchGraph = p.getGraph();\n-        \/\/ Search the current graph\n-        List<InputBlock> matches = findMatches(value, p.getGraph(), response);\n-        if (matches == null) {\n-            \/\/ See if the it hits in a later graph\n-            for (InputGraph graph : p.searchForward()) {\n-                matches = findMatches(value, graph, response);\n-                if (matches != null) {\n-                    matchGraph = graph;\n-                    break;\n-                }\n-            }\n-        }\n-        if (matches == null) {\n-            \/\/ See if it hits in a earlier graph\n-            for (InputGraph graph : p.searchBackward()) {\n-                matches = findMatches(value, graph, response);\n-                if (matches != null) {\n-                    matchGraph = graph;\n-                    break;\n-                }\n-            }\n-        }\n-        if (matches != null) {\n-            \/\/ Rank the matches.\n-            matches.sort((InputBlock a, InputBlock b) ->\n-                         compareByRankThenNumVal(rawValue,\n-                                                 \"B\" + a.getName(),\n-                                                 \"B\" + b.getName()));\n-\n-            final InputGraph theGraph = p.getGraph() != matchGraph ? matchGraph : null;\n-            for (final InputBlock b : matches) {\n-                if (!response.addResult(() -> {\n-                            final EditorTopComponent editor = EditorTopComponent.getActive();\n-                            assert(editor != null);\n-                            if (theGraph != null) {\n-                                editor.getModel().selectGraph(theGraph);\n-                            }\n-                            editor.clearSelectedNodes();\n-                            editor.addSelectedNodes(b.getNodes(), true);\n-                            editor.centerSelectedNodes();\n-                            editor.requestActive();\n-                        },\n-                        \"B\" + b.getName() + (theGraph != null ? \" in \" + theGraph.getName() : \"\"))) {\n-                    return;\n-                }\n-            }\n-        }\n+    String prefix() {\n+        return \"B\";\n@@ -107,22 +37,4 @@\n-    private List<InputBlock> findMatches(String blockName, InputGraph inputGraph, SearchResponse response) {\n-        try {\n-            RegexpPropertyMatcher matcher = new RegexpPropertyMatcher(\"\", blockName, Pattern.CASE_INSENSITIVE);\n-            List<InputBlock> matches = new ArrayList<>();\n-            for (InputBlock b : inputGraph.getBlocks()) {\n-                if (matcher.match(\"B\" + b.getName())) {\n-                    matches.add(b);\n-                }\n-            }\n-            return matches.size() == 0 ? null : matches;\n-        } catch (Exception e) {\n-            final String msg = e.getMessage();\n-            response.addResult(() -> {\n-                    Message desc = new NotifyDescriptor.Message(\"An exception occurred during the search, \"\n-                            + \"perhaps due to a malformed query string:\\n\" + msg,\n-                            NotifyDescriptor.WARNING_MESSAGE);\n-                    DialogDisplayer.getDefault().notify(desc);\n-                },\n-                \"(Error during search)\"\n-            );\n-        }\n-        return null;\n+    @Override\n+    String id(Object entity) {\n+        assert entity instanceof InputBlock;\n+        return ((InputBlock)entity).getName();\n@@ -131,15 +43,3 @@\n-    private int compareByRankThenNumVal(String qry, String b1, String b2) {\n-        int key1 = StringUtils.rankMatch(qry, b1);\n-        int key2 = StringUtils.rankMatch(qry, b2);\n-        if (key1 == key2) {\n-            \/\/ If the matches have the same rank, compare the numeric values of\n-            \/\/ their first words, if applicable.\n-            try {\n-                key1 = Integer.parseInt(b1.replace(\"B\", \"\"));\n-                key2 = Integer.parseInt(b2.replace(\"B\", \"\"));\n-            } catch (Exception e) {\n-                \/\/ Not applicable, return equality value.\n-                return 0;\n-            }\n-        }\n-        return Integer.compare(key1, key2);\n+    @Override\n+    Collection<Object> getAllEntities(InputGraph inputGraph) {\n+        return new ArrayList<>(inputGraph.getBlocks());\n@@ -148,0 +48,6 @@\n+    @Override\n+    void selectEntity(EditorTopComponent editor, Object entity) {\n+        assert entity instanceof InputBlock;\n+        editor.addSelectedNodes(((InputBlock)entity).getNodes(), true);\n+        editor.centerSelectedNodes();\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":18,"deletions":112,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -84,0 +85,1 @@\n+    private final LayerWidget segmentLayer;\n@@ -227,0 +229,1 @@\n+                centerSelectedLiveRanges();\n@@ -345,0 +348,4 @@\n+        segmentLayer = new LayerWidget(this);\n+        segmentLayer.setBorder(emptyBorder);\n+        addChild(segmentLayer);\n+\n@@ -377,1 +384,1 @@\n-            clearSelectedNodes();\n+            clearSelectedElements();\n@@ -432,1 +439,18 @@\n-                content.set(newSet, null);\n+                \/\/ Remove duplicate live range segments (i.e. segments that\n+                \/\/ represent the same live range in different basic blocks).\n+                Set<Object> newUnique = new HashSet<>();\n+                Set<Integer> visitedLiveRanges = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Properties.Provider &&\n+                        o instanceof LiveRangeSegment) {\n+                        int liveRangeId = ((LiveRangeSegment) o).getLiveRange().getId();\n+                        if (!visitedLiveRanges.contains(liveRangeId)) {\n+                            newUnique.add(o);\n+                            visitedLiveRanges.add(liveRangeId);\n+                        }\n+                    } else {\n+                        newUnique.add(o);\n+                    }\n+                }\n+\n+                content.set(newUnique, null);\n@@ -435,1 +459,2 @@\n-                for (Object o : newSet) {\n+                Set<Integer> liveRangeSelection = new HashSet<>();\n+                for (Object o : newUnique) {\n@@ -447,1 +472,8 @@\n-                        node.setDisplayName(provider.getProperties().get(\"name\"));\n+                        String displayName = null;\n+                        if (o instanceof Figure || o instanceof Slot) {\n+                            displayName = provider.getProperties().get(\"idx\") + \" \" +\n+                                          provider.getProperties().get(\"name\");\n+                        } else if (o instanceof LiveRangeSegment) {\n+                            displayName = \"L\" + ((LiveRangeSegment) o).getLiveRange().getId();\n+                        }\n+                        node.setDisplayName(displayName);\n@@ -456,0 +488,2 @@\n+                    } else if (o instanceof LiveRangeSegment) {\n+                        liveRangeSelection.add(((LiveRangeSegment) o).getLiveRange().getId());\n@@ -459,0 +493,1 @@\n+                getModel().setSelectedLiveRanges(liveRangeSelection);\n@@ -576,0 +611,47 @@\n+    public Action createGotoNodesAction(String name, Set<Figure> figures) {\n+        String iconResource = \"com\/sun\/hotspot\/igv\/view\/images\/selectNodes.png\";\n+        Action action = new AbstractAction(name, new ImageIcon(ImageUtilities.loadImage(iconResource))) {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                setFigureSelection(figures);\n+                model.showFigures(model.getSelectedFigures());\n+                centerSelectedFigures();\n+            }\n+        };\n+\n+        action.setEnabled(true);\n+        return action;\n+    }\n+\n+    private Action createGotoLiveRangeAction(String name, String iconResource, Set<InputLiveRange> liveRanges) {\n+        Action action = new AbstractAction(name, new ImageIcon(ImageUtilities.loadImage(iconResource))) {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                Set<LiveRangeSegment> segments = liveRangeSegmentSet(liveRanges);\n+                setLiveRangeSegmentSelection(segments);\n+                Diagram diagram = getModel().getDiagram();\n+                Set<Figure> figures = new HashSet<>();\n+                for (InputLiveRange liveRange : liveRanges) {\n+                    for (InputNode node : diagram.getInputGraph().getRelatedNodes(liveRange.getId())) {\n+                        figures.add((diagram.getFigure(node)));\n+                    }\n+                }\n+                model.showFigures(figures);\n+                centerSelectedLiveRanges();\n+            }\n+        };\n+\n+        action.setEnabled(true);\n+        return action;\n+    }\n+\n+    public Action createGotoLiveRangeAction(String name, Set<InputLiveRange> liveRanges) {\n+        return createGotoLiveRangeAction(name, \"com\/sun\/hotspot\/igv\/view\/images\/selectLiveRanges.png\", liveRanges);\n+    }\n+\n+    public Action createGotoLiveRangeAction(InputLiveRange liveRange) {\n+        return createGotoLiveRangeAction(\"L\" + liveRange.getId(),\n+                                         \"com\/sun\/hotspot\/igv\/view\/images\/liveRange.png\",\n+                                         Collections.singleton(liveRange));\n+    }\n+\n@@ -832,0 +914,1 @@\n+        rebuildSegmentLayer();\n@@ -844,0 +927,1 @@\n+        Set<LiveRangeWidget> oldVisibleLiveRangeWidgets = getVisibleLiveRangeWidgets();\n@@ -848,0 +932,1 @@\n+        updateVisibleLiveRangeWidgets();\n@@ -853,0 +938,1 @@\n+        List<LiveRangeSegment> visibleLiveRangeSegments = getVisibleLiveRangeSegments();\n@@ -862,1 +948,1 @@\n-            doCFGLayout(visibleFigures, visibleConnections);\n+            doCFGLayout(visibleFigures, visibleConnections, visibleLiveRangeSegments);\n@@ -865,0 +951,4 @@\n+        if (getModel().getShowCFG() && getModel().getShowLiveRanges()) {\n+            updateLiveRangeIdsInBlockWidgets();\n+            repaintLiveRangeWidgets();\n+        }\n@@ -867,0 +957,1 @@\n+        updateLiveRangeWidgetLocations(oldVisibleLiveRangeWidgets);\n@@ -869,1 +960,2 @@\n-        setFigureSelection(model.getSelectedFigures());\n+        setElementSelection(model.getSelectedFigures(),\n+                            model.getSelectedLiveRangeSegments());\n@@ -871,0 +963,1 @@\n+        centerSelectedLiveRanges();\n@@ -925,0 +1018,30 @@\n+    private boolean isVisibleBlock(Block b) {\n+        BlockWidget bw = getWidget(b);\n+        return bw != null && getWidget(b, BlockWidget.class).isVisible();\n+    }\n+\n+    private boolean isVisibleLiveRange(int liveRangeId) {\n+        if (!getModel().getShowLiveRanges()) {\n+            return false;\n+        }\n+        Set<InputNode> relatedNodes = getModel().getGraph().getRelatedNodes(liveRangeId);\n+        for (InputNode n : relatedNodes) {\n+            if (!getModel().getDiagram().hasFigure(n)) {\n+                return false;\n+            }\n+            Figure f = getModel().getDiagram().getFigure(n);\n+            FigureWidget fw = getWidget(f);\n+            if (isVisibleBlock(f.getBlock()) &&\n+                (fw == null || !fw.isVisible())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isVisibleLiveRangeSegment(LiveRangeSegment s) {\n+        return isVisibleLiveRange(s.getLiveRange().getId()) &&\n+               isVisibleBlock(s.getCluster());\n+    }\n+\n+\n@@ -957,1 +1080,1 @@\n-    private void doCFGLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+    private void doCFGLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections, List<LiveRangeSegment> segments) {\n@@ -961,0 +1084,1 @@\n+        cfgLayoutManager.setSegments(new ArrayList<>(segments));\n@@ -1213,1 +1337,1 @@\n-        clearSelectedNodes();\n+        clearSelectedElements();\n@@ -1237,2 +1361,15 @@\n-    @Override\n-    public void addSelectedNodes(Collection<InputNode> nodes, boolean showIfHidden) {\n+    public Set<LiveRangeSegment> liveRangeSegmentSet(Collection<InputLiveRange> liveRanges) {\n+        Set<Integer> liveRangeIds = new HashSet<>();\n+        for (InputLiveRange liveRange : liveRanges) {\n+            liveRangeIds.add(liveRange.getId());\n+        }\n+        Set<LiveRangeSegment> segments = new HashSet<>();\n+        for (LiveRangeSegment segment : model.getDiagram().getLiveRangeSegments()) {\n+            if (liveRangeIds.contains(segment.getLiveRange().getId())) {\n+                segments.add(segment);\n+            }\n+        }\n+        return segments;\n+    }\n+\n+    private Set<Figure> figureSet(Collection<InputNode> nodes) {\n@@ -1249,1 +1386,6 @@\n-        setFigureSelection(selectedFigures);\n+        return selectedFigures;\n+    }\n+\n+    @Override\n+    public void addSelectedNodes(Collection<InputNode> nodes, boolean showIfHidden) {\n+        setFigureSelection(figureSet(nodes));\n@@ -1256,1 +1398,16 @@\n-    public void clearSelectedNodes() {\n+    public void addSelectedLiveRanges(Collection<InputLiveRange> liveRanges, boolean showIfHidden) {\n+        setLiveRangeSegmentSelection(liveRangeSegmentSet(liveRanges));\n+    }\n+\n+    @Override\n+    public void addSelectedElements(Collection<InputNode> nodes,\n+                                    Collection<InputLiveRange> liveRanges,\n+                                    boolean showIfHidden) {\n+        setElementSelection(figureSet(nodes), liveRangeSegmentSet(liveRanges));\n+        if (showIfHidden) {\n+            model.showFigures(model.getSelectedFigures());\n+        }\n+    }\n+\n+    @Override\n+    public void clearSelectedElements() {\n@@ -1284,0 +1441,24 @@\n+    @Override\n+    public void centerSelectedLiveRanges() {\n+        Set<LiveRangeSegment> selectedLiveRanges = model.getSelectedLiveRangeSegments();\n+        Rectangle overallRect = null;\n+        for (LiveRangeSegment segment : selectedLiveRanges) {\n+            LiveRangeWidget liveRangeWidget = getWidget(segment);\n+            if (liveRangeWidget != null) {\n+                Rectangle bounds = liveRangeWidget.getBounds();\n+                if (bounds != null) {\n+                    Point location = liveRangeWidget.getLocation();\n+                    Rectangle rect = new Rectangle(location.x, location.y, bounds.width, bounds.height);\n+                    if (overallRect == null) {\n+                        overallRect = rect;\n+                    } else {\n+                        overallRect = overallRect.union(rect);\n+                    }\n+                }\n+            }\n+        }\n+        if (overallRect != null) {\n+            centerRectangle(overallRect);\n+        }\n+    }\n+\n@@ -1314,0 +1495,10 @@\n+    private void setLiveRangeSegmentSelection(Set<LiveRangeSegment> list) {\n+        super.setSelectedObjects(new HashSet<>(list));\n+    }\n+\n+    private void setElementSelection(Set<Figure> figures, Set<LiveRangeSegment> segments) {\n+        Set<Object> elements = new HashSet<>(figures);\n+        elements.addAll(segments);\n+        super.setSelectedObjects(elements);\n+    }\n+\n@@ -1374,1 +1565,27 @@\n-    private Set<FigureWidget> getVisibleFigureWidgets() {\n+    private void rebuildSegmentLayer() {\n+        segmentLayer.removeChildren();\n+        if (getModel().getShowCFG() && getModel().getShowLiveRanges()) {\n+            Map<Integer, Set<LiveRangeSegment>> segments = new HashMap<>();\n+            for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+                int liveRangeId = segment.getLiveRange().getId();\n+                if (!segments.containsKey(liveRangeId)) {\n+                    segments.put(liveRangeId, new HashSet<>());\n+                }\n+                segments.get(liveRangeId).add(segment);\n+            }\n+            for (Set<LiveRangeSegment> segmentSet : segments.values()) {\n+                for (LiveRangeSegment segment : segmentSet) {\n+                    segment.setStartPoint(null);\n+                    segment.setEndPoint(null);\n+                    segment.setSegmentSet(segmentSet);\n+                    LiveRangeWidget segmentWidget = new LiveRangeWidget(segment, this, 0);\n+                    segmentWidget.setVisible(false);\n+                    addObject(segment, segmentWidget);\n+                    segmentWidget.getActions().addAction(hoverAction);\n+                    segmentLayer.addChild(segmentWidget);\n+                }\n+            }\n+        }\n+    }\n+\n+   private Set<FigureWidget> getVisibleFigureWidgets() {\n@@ -1385,0 +1602,11 @@\n+    private Set<LiveRangeWidget> getVisibleLiveRangeWidgets() {\n+        Set<LiveRangeWidget> visibleLiveRangeWidgets = new HashSet<>();\n+        for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+            LiveRangeWidget liveRangeWidget = getWidget(segment);\n+            if (liveRangeWidget != null && liveRangeWidget.isVisible()) {\n+                visibleLiveRangeWidgets.add(liveRangeWidget);\n+            }\n+        }\n+        return visibleLiveRangeWidgets;\n+    }\n+\n@@ -1406,0 +1634,21 @@\n+    private void updateVisibleLiveRangeWidgets() {\n+        if (getModel().getShowCFG() && getModel().getShowLiveRanges()) {\n+            for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+                LiveRangeWidget liveRangeWidget = getWidget(segment);\n+                boolean visible = true;\n+                for (InputNode n : getModel().getDiagram().getInputGraph().getRelatedNodes(segment.getLiveRange().getId())) {\n+                    if (!getModel().getDiagram().hasFigure(n)) {\n+                        visible = false;\n+                        break;\n+                    }\n+                    FigureWidget f = getWidget(getModel().getDiagram().getFigure(n));\n+                    if (!f.isVisible()) {\n+                        visible = false;\n+                        break;\n+                    }\n+                }\n+                liveRangeWidget.setVisible(visible);\n+            }\n+        }\n+    }\n+\n@@ -1436,0 +1685,17 @@\n+    private void updateLiveRangeWidgetLocations(Set<LiveRangeWidget> oldVisibleLiveRangeWidgets) {\n+        if (getModel().getShowCFG() && getModel().getShowLiveRanges()) {\n+            boolean doAnimation = shouldAnimate();\n+            for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+                LiveRangeWidget liveRangeWidget = getWidget(segment);\n+                if (liveRangeWidget.isVisible()) {\n+                    Point location = new Point(segment.getStartPoint());\n+                    if (doAnimation && oldVisibleLiveRangeWidgets.contains(liveRangeWidget)) {\n+                        getSceneAnimator().animatePreferredLocation(liveRangeWidget, location);\n+                    } else {\n+                        liveRangeWidget.setPreferredLocation(location);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1445,0 +1711,6 @@\n+            for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+                LiveRangeWidget liveRangeWidget = getWidget(segment);\n+                if (liveRangeWidget != null && liveRangeWidget.isVisible()) {\n+                    visibleBlocks.add(segment.getCluster());\n+                }\n+            }\n@@ -1466,0 +1738,16 @@\n+\n+                \/\/ Update node width for live range layout.\n+                int nodeWidth = ClusterNode.EMPTY_BLOCK_LIVE_RANGE_X_OFFSET;\n+                for (InputNode n : block.getInputBlock().getNodes()) {\n+                    if (!getModel().getDiagram().hasFigure(n)) {\n+                        \/\/ n might not be visible (e.g. filtered out).\n+                        continue;\n+                    }\n+                    Figure f = getModel().getDiagram().getFigure(n);\n+                    FigureWidget figureWidget = getWidget(f);\n+                    if (figureWidget != null && figureWidget.isVisible()) {\n+                        nodeWidth = f.getWidth();\n+                        break;\n+                    }\n+                }\n+                blockWidget.setNodeWidth(nodeWidth);\n@@ -1512,0 +1800,10 @@\n+    private List<LiveRangeSegment> getVisibleLiveRangeSegments() {\n+        List<LiveRangeSegment> visibleLiveRangeSegments = new ArrayList<>();\n+        for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+            if (isVisibleLiveRangeSegment(segment)) {\n+                visibleLiveRangeSegments.add(segment);\n+            }\n+        }\n+        return visibleLiveRangeSegments;\n+    }\n+\n@@ -1544,0 +1842,27 @@\n+    private void updateLiveRangeIdsInBlockWidgets() {\n+        for (Block block : getModel().getDiagram().getBlocks()) {\n+            BlockWidget blockWidget = getWidget(block);\n+            if (blockWidget != null && blockWidget.isVisible()) {\n+                List<Integer> liveRangeIds = new ArrayList<>();\n+                for (Integer liveRangeId : block.getLiveRangeIds()) {\n+                    if (isVisibleLiveRange(liveRangeId)) {\n+                        liveRangeIds.add(liveRangeId);\n+                    }\n+                }\n+                blockWidget.setLiveRangeIds(liveRangeIds);\n+            }\n+        }\n+    }\n+\n+    private void repaintLiveRangeWidgets() {\n+        for (LiveRangeSegment segment : getModel().getDiagram().getLiveRangeSegments()) {\n+            LiveRangeWidget liveRangeWidget = getWidget(segment);\n+            if (liveRangeWidget.isVisible()) {\n+                assert segment.getStartPoint().x == segment.getEndPoint().x;\n+                int length = segment.getEndPoint().y - segment.getStartPoint().y;\n+                liveRangeWidget.setLength(length);\n+                liveRangeWidget.repaint();\n+            }\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":339,"deletions":14,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.data.services.PreProcessor;\n@@ -36,0 +37,1 @@\n+import com.sun.hotspot.igv.graph.LiveRangeSegment;\n@@ -56,0 +58,1 @@\n+    private Set<Integer> selectedLiveRanges;\n@@ -63,1 +66,2 @@\n-    private final ChangedEvent<DiagramViewModel> selectedNodesChangedEvent = new ChangedEvent<>(this);\n+    \/\/ This event signals a change in the selection of nodes and\/or live ranges.\n+    private final ChangedEvent<DiagramViewModel> selectedElementsChangedEvent = new ChangedEvent<>(this);\n@@ -73,0 +77,1 @@\n+    private boolean showLiveRanges;\n@@ -115,0 +120,1 @@\n+            selectedLiveRanges.clear();\n@@ -126,0 +132,1 @@\n+            selectedLiveRanges.clear();\n@@ -137,0 +144,1 @@\n+            selectedLiveRanges.clear();\n@@ -148,0 +156,1 @@\n+            selectedLiveRanges.clear();\n@@ -182,0 +191,12 @@\n+    public boolean getShowLiveRanges() {\n+        return showLiveRanges;\n+    }\n+\n+    public void setShowLiveRanges(boolean b) {\n+        showLiveRanges = b;\n+        if (!showLiveRanges) {\n+            selectedLiveRanges.clear();\n+        }\n+        diagramChangedEvent.fire();\n+    }\n+\n@@ -221,0 +242,1 @@\n+        showLiveRanges = model.getShowLiveRanges();\n@@ -224,0 +246,1 @@\n+        selectedLiveRanges = new HashSet<>();\n@@ -246,0 +269,1 @@\n+        showLiveRanges = true;\n@@ -249,0 +273,1 @@\n+        selectedLiveRanges = new HashSet<>();\n@@ -260,2 +285,2 @@\n-    public ChangedEvent<DiagramViewModel> getSelectedNodesChangedEvent() {\n-        return selectedNodesChangedEvent;\n+    public ChangedEvent<DiagramViewModel> getSelectedElementsChangedEvent() {\n+        return selectedElementsChangedEvent;\n@@ -314,1 +339,10 @@\n-        selectedNodesChangedEvent.fire();\n+        selectedElementsChangedEvent.fire();\n+    }\n+\n+    public Set<Integer> getSelectedLiveRanges() {\n+        return selectedLiveRanges;\n+    }\n+\n+    public void setSelectedLiveRanges(Set<Integer> liveRanges) {\n+        selectedLiveRanges = liveRanges;\n+        selectedElementsChangedEvent.fire();\n@@ -339,0 +373,10 @@\n+    public Set<LiveRangeSegment> getSelectedLiveRangeSegments() {\n+        Set<LiveRangeSegment> result = new HashSet<>();\n+        for (LiveRangeSegment segment : diagram.getLiveRangeSegments()) {\n+            if (getSelectedLiveRanges().contains(segment.getLiveRange().getId())) {\n+                result.add(segment);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -401,0 +445,2 @@\n+        PreProcessor p = Lookup.getDefault().lookup(PreProcessor.class);\n+        p.preProcess(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":51,"deletions":5,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.hotspot.igv.data.InputLiveRange;\n@@ -80,0 +81,2 @@\n+    void centerSelectedLiveRanges();\n+\n@@ -82,1 +85,5 @@\n-    void clearSelectedNodes();\n+    void addSelectedLiveRanges(Collection<InputLiveRange> liveRanges, boolean showIfHidden);\n+\n+    void addSelectedElements(Collection<InputNode> nodes, Collection<InputLiveRange> liveRanges, boolean showIfHidden);\n+\n+    void clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    public void clearSelectedNodes() {\n+    public void clearSelectedElements() {\n@@ -78,1 +78,1 @@\n-            editor.clearSelectedNodes();\n+            editor.clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorInputGraphProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.data.InputLiveRange;\n@@ -208,0 +209,1 @@\n+        toolBar.add(new JToggleButton(new ShowLiveRangesAction(cfgLayoutAction, diagramViewModel.getShowLiveRanges())));\n@@ -356,0 +358,10 @@\n+    public void addSelectedLiveRanges(Collection<InputLiveRange> liveRanges, boolean showIfHidden) {\n+        scene.addSelectedLiveRanges(liveRanges, showIfHidden);\n+    }\n+\n+    public void addSelectedElements(Collection<InputNode> nodes,\n+                                    Collection<InputLiveRange> liveRanges,\n+                                    boolean showIfHidden) {\n+        scene.addSelectedElements(nodes, liveRanges, showIfHidden);\n+    }\n+\n@@ -360,2 +372,6 @@\n-    public void clearSelectedNodes() {\n-        scene.clearSelectedNodes();\n+    public void centerSelectedLiveRanges() {\n+        scene.centerSelectedLiveRanges();\n+    }\n+\n+    public void clearSelectedElements() {\n+        scene.clearSelectedElements();\n@@ -453,1 +469,5 @@\n-        etc.addSelectedNodes(selectedNodes, false);\n+        Set<InputLiveRange> selectedLiveRanges = new HashSet<>();\n+        for (int liveRangeId : getModel().getSelectedLiveRanges()) {\n+            selectedLiveRanges.add(getModel().getGraph().getLiveRange(liveRangeId));\n+        }\n+        etc.addSelectedElements(selectedNodes, selectedLiveRanges, false);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputLiveRange;\n+import java.util.*;\n+\n+public class LiveRangeQuickSearch extends SimpleQuickSearch {\n+\n+    @Override\n+    String prefix() {\n+        return \"L\";\n+    }\n+\n+    @Override\n+    String id(Object entity) {\n+        assert entity instanceof InputLiveRange;\n+        return Integer.toString(((InputLiveRange)entity).getId());\n+    }\n+\n+    @Override\n+    Collection<Object> getAllEntities(InputGraph inputGraph) {\n+        return new ArrayList<>(inputGraph.getLiveRanges());\n+    }\n+\n+    @Override\n+    void selectEntity(EditorTopComponent editor, Object entity) {\n+        assert entity instanceof InputLiveRange;\n+        Set<InputLiveRange> entitySingleton = new HashSet<>();\n+        entitySingleton.add((InputLiveRange)entity);\n+        editor.addSelectedLiveRanges(entitySingleton, true);\n+        editor.centerSelectedLiveRanges();\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/LiveRangeQuickSearch.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-                            editor.clearSelectedNodes();\n+                            editor.clearSelectedElements();\n@@ -154,1 +154,1 @@\n-                                editor.clearSelectedNodes();\n+                                editor.clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n+import com.sun.hotspot.igv.util.LookupHistory;\n+import com.sun.hotspot.igv.util.StringUtils;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.netbeans.spi.quicksearch.SearchProvider;\n+import org.netbeans.spi.quicksearch.SearchRequest;\n+import org.netbeans.spi.quicksearch.SearchResponse;\n+import org.openide.DialogDisplayer;\n+import org.openide.NotifyDescriptor;\n+import org.openide.NotifyDescriptor.Message;\n+\n+public abstract class SimpleQuickSearch implements SearchProvider {\n+\n+    abstract String prefix();\n+\n+    abstract String id(Object entity);\n+\n+    abstract Collection<Object> getAllEntities(InputGraph inputGraph);\n+\n+    abstract void selectEntity(EditorTopComponent editor, Object entity);\n+\n+    @Override\n+    public void evaluate(SearchRequest request, SearchResponse response) {\n+        String rawValue = request.getText();\n+        if (rawValue.trim().isEmpty()) {\n+            return;\n+        }\n+        String value = \".*\" + Pattern.quote(rawValue) + \".*\";\n+\n+        final InputGraphProvider p = LookupHistory.getLast(InputGraphProvider.class);\n+        if (p == null || p.getGraph() == null) {\n+            return;\n+        }\n+\n+        InputGraph matchGraph = p.getGraph();\n+        \/\/ Search the current graph\n+        List<Object> matches = findMatches(value, p.getGraph(), response);\n+        if (matches == null) {\n+            \/\/ See if the it hits in a later graph\n+            for (InputGraph graph : p.searchForward()) {\n+                matches = findMatches(value, graph, response);\n+                if (matches != null) {\n+                    matchGraph = graph;\n+                    break;\n+                }\n+            }\n+        }\n+        if (matches == null) {\n+            \/\/ See if it hits in a earlier graph\n+            for (InputGraph graph : p.searchBackward()) {\n+                matches = findMatches(value, graph, response);\n+                if (matches != null) {\n+                    matchGraph = graph;\n+                    break;\n+                }\n+            }\n+        }\n+        if (matches != null) {\n+            \/\/ Rank the matches.\n+            matches.sort((Object a, Object b) ->\n+                         compareByRankThenNumVal(rawValue,\n+                                                 prefix() + id(a),\n+                                                 prefix() + id(b)));\n+\n+            final InputGraph theGraph = p.getGraph() != matchGraph ? matchGraph : null;\n+            for (final Object entity : matches) {\n+                if (!response.addResult(() -> {\n+                            final EditorTopComponent editor = EditorTopComponent.getActive();\n+                            assert(editor != null);\n+                            if (theGraph != null) {\n+                                editor.getModel().selectGraph(theGraph);\n+                            }\n+                            editor.clearSelectedElements();\n+                            selectEntity(editor, entity);\n+                            editor.requestActive();\n+                        },\n+                        prefix() + id(entity) + (theGraph != null ? \" in \" + theGraph.getName() : \"\"))) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<Object> findMatches(String entityName, InputGraph inputGraph, SearchResponse response) {\n+        try {\n+            RegexpPropertyMatcher matcher = new RegexpPropertyMatcher(\"\", entityName, Pattern.CASE_INSENSITIVE);\n+            List<Object> matches = new ArrayList<>();\n+            for (Object entity : getAllEntities(inputGraph)) {\n+                if (matcher.match(prefix() + id(entity))) {\n+                    matches.add(entity);\n+                }\n+            }\n+            return matches.size() == 0 ? null : matches;\n+        } catch (Exception e) {\n+            final String msg = e.getMessage();\n+            response.addResult(() -> {\n+                    Message desc = new NotifyDescriptor.Message(\"An exception occurred during the search, \"\n+                            + \"perhaps due to a malformed query string:\\n\" + msg,\n+                            NotifyDescriptor.WARNING_MESSAGE);\n+                    DialogDisplayer.getDefault().notify(desc);\n+                },\n+                \"(Error during search)\"\n+            );\n+        }\n+        return null;\n+    }\n+\n+    private int compareByRankThenNumVal(String qry, String l1, String l2) {\n+        int key1 = StringUtils.rankMatch(qry, l1);\n+        int key2 = StringUtils.rankMatch(qry, l2);\n+        if (key1 == key2) {\n+            \/\/ If the matches have the same rank, compare the numeric values of\n+            \/\/ their first words, if applicable.\n+            try {\n+                key1 = Integer.parseInt(l1.replace(prefix(), \"\"));\n+                key2 = Integer.parseInt(l2.replace(prefix(), \"\"));\n+            } catch (Exception e) {\n+                \/\/ Not applicable, return equality value.\n+                return 0;\n+            }\n+        }\n+        return Integer.compare(key1, key2);\n+    }\n+\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/SimpleQuickSearch.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.view.DiagramViewModel;\n@@ -33,1 +34,0 @@\n-import org.openide.util.actions.CallableSystemAction;\n@@ -36,1 +36,1 @@\n-public abstract class ExpandAdjacentAction extends CallableSystemAction {\n+public abstract class ExpandAdjacentAction extends ModelAwareAction {\n@@ -50,2 +50,0 @@\n-    public abstract void performAction();\n-\n@@ -54,0 +52,5 @@\n+    @Override\n+    public boolean isEnabled(DiagramViewModel model) {\n+        return model != null && !model.getSelectedNodes().isEmpty();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandAdjacentAction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.view.DiagramViewModel;\n@@ -35,1 +36,1 @@\n-    public void performAction() {\n+    public void performAction(DiagramViewModel model) {\n@@ -43,0 +44,5 @@\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Expand predecessors of current set of selected nodes\";\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandPredecessorsAction.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.view.DiagramViewModel;\n@@ -35,1 +36,1 @@\n-    public void performAction() {\n+    public void performAction(DiagramViewModel model) {\n@@ -43,0 +44,5 @@\n+\n+    @Override\n+    public String getDescription() {\n+        return \"Expand successors of current set of selected nodes\";\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandSuccessorsAction.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,5 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputNode;\n@@ -46,1 +51,1 @@\n-        \"HINT_ExtractAction=Extract current set of selected nodes\"\n+        \"HINT_ExtractAction=Extract selected nodes and live ranges\"\n@@ -67,1 +72,8 @@\n-        model.showOnly(model.getSelectedNodes());\n+        Set<Integer> nodes = new HashSet<>(model.getSelectedNodes());\n+        InputGraph graph = model.getDiagram().getInputGraph();\n+        for (int liveRangeId : model.getSelectedLiveRanges()) {\n+            for (InputNode node : graph.getRelatedNodes(liveRangeId)) {\n+                nodes.add(node.getId());\n+            }\n+        }\n+        model.showOnly(nodes);\n@@ -72,1 +84,2 @@\n-        return model != null && !model.getSelectedNodes().isEmpty();\n+        return model != null &&\n+               !(model.getSelectedNodes().isEmpty() && model.getSelectedLiveRanges().isEmpty());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExtractAction.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputNode;\n@@ -47,2 +49,2 @@\n-        \"CTL_HideAction=Hide nodes\",\n-        \"HINT_HideAction=Hide selected nodes\"\n+        \"CTL_HideAction=Hide\",\n+        \"HINT_HideAction=Hide selected nodes and live ranges\"\n@@ -72,0 +74,6 @@\n+        InputGraph graph = model.getDiagram().getInputGraph();\n+        for (int liveRangeId : model.getSelectedLiveRanges()) {\n+            for (InputNode node : graph.getRelatedNodes(liveRangeId)) {\n+                nodes.add(node.getId());\n+            }\n+        }\n@@ -77,1 +85,2 @@\n-        return model != null && !model.getSelectedNodes().isEmpty();\n+        return model != null &&\n+               !(model.getSelectedNodes().isEmpty() && model.getSelectedLiveRanges().isEmpty());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideAction.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-    protected abstract String iconResource();\n-\n@@ -57,1 +55,1 @@\n-        model.getSelectedNodesChangedEvent().addListener(this);\n+        model.getSelectedElementsChangedEvent().addListener(this);\n@@ -65,1 +63,1 @@\n-        model.getSelectedNodesChangedEvent().removeListener(this);\n+        model.getSelectedElementsChangedEvent().removeListener(this);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ModelAwareAction.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n+import java.awt.event.ActionEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.AbstractAction;\n+import javax.swing.ImageIcon;\n+import org.openide.util.ImageUtilities;\n+\n+public class ShowLiveRangesAction extends AbstractAction implements PropertyChangeListener {\n+\n+    private boolean selected;\n+    private AbstractAction parentAction;\n+\n+    public ShowLiveRangesAction(AbstractAction action, boolean select) {\n+        this.parentAction = action;\n+        this.selected = select;\n+        this.parentAction.addPropertyChangeListener(this);\n+        putValue(SELECTED_KEY, this.selected);\n+        putValue(SMALL_ICON, new ImageIcon(ImageUtilities.loadImage(iconResource())));\n+        putValue(SHORT_DESCRIPTION, \"Show live ranges in control-flow graph view (if liveness information is available)\");\n+        enableIfParentSelected();\n+    }\n+\n+    @Override\n+    public void actionPerformed(ActionEvent ev) {\n+        this.selected = isSelected();\n+        EditorTopComponent editor = EditorTopComponent.getActive();\n+        if (editor != null) {\n+            editor.getModel().setShowLiveRanges(this.selected);\n+        }\n+    }\n+\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/showLiveRanges.png\";\n+    }\n+\n+    private boolean isSelected() {\n+        return (Boolean)getValue(SELECTED_KEY);\n+    }\n+\n+    private void enableIfParentSelected() {\n+        boolean enable = parentAction.isEnabled() && (Boolean)parentAction.getValue(SELECTED_KEY);\n+        if (enable != this.isEnabled()) {\n+            if (enable) {\n+                putValue(SELECTED_KEY, this.selected);\n+            } else {\n+                this.selected = isSelected();\n+                putValue(SELECTED_KEY, false);\n+            }\n+        }\n+        this.setEnabled(enable);\n+    }\n+\n+    @Override\n+    public void propertyChange(PropertyChangeEvent evt) {\n+        if (evt.getSource() == this.parentAction) {\n+            enableIfParentSelected();\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowLiveRangesAction.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -49,0 +50,4 @@\n+    private static final Font LIVE_RANGE_FONT = new Font(\"Arial\", Font.BOLD, 12);\n+    public static final Color LIVE_RANGE_COLOR = Color.BLACK;\n+    private int nodeWidth;\n+    private List<Integer> liveRangeIds;\n@@ -58,0 +63,8 @@\n+    public void setLiveRangeIds(List<Integer> liveRangeIds) {\n+        this.liveRangeIds = liveRangeIds;\n+    }\n+\n+    public void setNodeWidth(int nodeWidth) {\n+        this.nodeWidth = nodeWidth;\n+    }\n+\n@@ -78,0 +91,13 @@\n+\n+        g.setColor(LIVE_RANGE_COLOR);\n+        g.setFont(LIVE_RANGE_FONT);\n+        if (liveRangeIds != null) {\n+            int x = nodeWidth + block.getLiveRangeSeparation();\n+            for (int liveRangeId : liveRangeIds) {\n+                String ls = \"L\" + String.valueOf(liveRangeId);\n+                Rectangle2D lr = g.getFontMetrics().getStringBounds(ls, g);\n+                g.drawString(ls, r.x + x, r.y + (int) lr.getHeight() + 2);\n+                x += block.getLiveRangeSeparation();\n+            }\n+        }\n+\n@@ -85,1 +111,1 @@\n-                graphProvider.clearSelectedNodes();\n+                graphProvider.clearSelectedElements();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputLiveRange;\n+import com.sun.hotspot.igv.data.LivenessInfo;\n@@ -29,0 +32,1 @@\n+import com.sun.hotspot.igv.graph.LiveRangeSegment;\n@@ -320,0 +324,41 @@\n+        if (diagramScene.getModel().getShowCFG() &&\n+            diagramScene.getModel().getShowLiveRanges()) {\n+            InputGraph graph = diagramScene.getModel().getGraph();\n+            LivenessInfo l = graph.getLivenessInfoForNode(getFigure().getInputNode());\n+            if (l != null) {\n+                Set<InputLiveRange> liveRanges = new HashSet<>();\n+                if (l.def != null) {\n+                    liveRanges.add(graph.getLiveRange(l.def));\n+                }\n+                if (l.use != null) {\n+                    for (int use : l.use) {\n+                        liveRanges.add(graph.getLiveRange(use));\n+                    }\n+                }\n+                if (l.join != null) {\n+                    for (int join : l.join) {\n+                        liveRanges.add(graph.getLiveRange(join));\n+                    }\n+                }\n+                if (!liveRanges.isEmpty()) {\n+                    menu.addSeparator();\n+                    menu.add(diagramScene.createGotoLiveRangeAction(\"Select live ranges\", liveRanges));\n+                    menu.addSeparator();\n+                    if (l.def != null) {\n+                        menu.add(diagramScene.createGotoLiveRangeAction(graph.getLiveRange(l.def)));\n+                    }\n+                    menu.addSeparator();\n+                    if (l.use != null) {\n+                        for (int use : l.use) {\n+                            menu.add(diagramScene.createGotoLiveRangeAction(graph.getLiveRange(use)));\n+                        }\n+                    }\n+                    if (l.join != null) {\n+                        for (int join : l.join) {\n+                            menu.add(diagramScene.createGotoLiveRangeAction(graph.getLiveRange(join)));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.widgets;\n+\n+import com.sun.hotspot.igv.data.InputGraph;\n+import com.sun.hotspot.igv.data.InputNode;\n+import com.sun.hotspot.igv.data.Properties;\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.LiveRangeSegment;\n+import com.sun.hotspot.igv.util.DoubleClickAction;\n+import com.sun.hotspot.igv.util.DoubleClickHandler;\n+import com.sun.hotspot.igv.util.PropertiesConverter;\n+import com.sun.hotspot.igv.util.PropertiesSheet;\n+import com.sun.hotspot.igv.view.DiagramScene;\n+import com.sun.hotspot.igv.view.DiagramViewModel;\n+import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n+\n+import java.awt.*;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.swing.JPopupMenu;\n+import org.netbeans.api.visual.action.ActionFactory;\n+import org.netbeans.api.visual.action.PopupMenuProvider;\n+import org.netbeans.api.visual.action.SelectProvider;\n+import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.model.ObjectState;\n+import org.netbeans.api.visual.widget.Widget;\n+import org.openide.nodes.AbstractNode;\n+import org.openide.nodes.Children;\n+import org.openide.nodes.Node;\n+import org.openide.nodes.Sheet;\n+\n+public class LiveRangeWidget extends Widget implements Properties.Provider, PopupMenuProvider, DoubleClickHandler {\n+\n+    private final LiveRangeSegment liveRangeSegment;\n+    private final DiagramScene scene;\n+    private int length;\n+    private Rectangle clientArea;\n+    private final Node node;\n+    private static final float NORMAL_THICKNESS = 1.4f;\n+    private static final float SELECTED_THICKNESS = 2.2f;\n+    private boolean highlighted;\n+    private static final Color HIGHLIGHTED_COLOR = Color.BLUE;\n+\n+    private static final int RANGE_WIDTH = 4;\n+\n+    public LiveRangeWidget(LiveRangeSegment liveRangeSegment, DiagramScene scene, int length) {\n+        super(scene);\n+        this.liveRangeSegment = liveRangeSegment;\n+        this.scene = scene;\n+        this.length = length;\n+\n+        getActions().addAction(new DoubleClickAction(this));\n+        getActions().addAction(ActionFactory.createPopupMenuAction(this));\n+\n+        updateClientArea();\n+\n+        \/\/ Initialize node for property sheet\n+        node = new AbstractNode(Children.LEAF) {\n+            @Override\n+            protected Sheet createSheet() {\n+                Sheet s = super.createSheet();\n+                PropertiesSheet.initializeSheet(liveRangeSegment.getProperties(), s);\n+                return s;\n+            }\n+        };\n+        node.setDisplayName(\"L\" + liveRangeSegment.getLiveRange().getId());\n+\n+        this.setToolTipText(PropertiesConverter.convertToHTML(liveRangeSegment.getProperties()));\n+        getActions().addAction(new CustomSelectAction(new SelectProvider() {\n+            @Override\n+            public boolean isAimingAllowed(Widget widget, Point localLocation, boolean invertSelection) {\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean isSelectionAllowed(Widget widget, Point localLocation, boolean invertSelection) {\n+                return true;\n+            }\n+\n+            @Override\n+            public void select(Widget widget, Point localLocation, boolean invertSelection) {\n+                scene.userSelectionSuggested(liveRangeSegment.getSegmentSet(), invertSelection);\n+            }\n+        }));\n+    }\n+\n+    public void setLength(int length) {\n+        this.length = length;\n+        updateClientArea();\n+    }\n+\n+    private void updateClientArea() {\n+        clientArea = new Rectangle(RANGE_WIDTH * 2, length);\n+        clientArea.grow(RANGE_WIDTH * 2, RANGE_WIDTH * 2);\n+    }\n+\n+    @Override\n+    protected Rectangle calculateClientArea() {\n+        return clientArea;\n+    }\n+\n+    @Override\n+    protected void paintWidget() {\n+        if (scene.getZoomFactor() < 0.1) {\n+            return;\n+        }\n+        Graphics2D g = getScene().getGraphics();\n+        g.setPaint(this.getBackground());\n+        boolean selected = scene.getSelectedObjects().contains(liveRangeSegment);\n+        g.setStroke(new BasicStroke(selected ? SELECTED_THICKNESS : NORMAL_THICKNESS));\n+        g.setColor(highlighted ? HIGHLIGHTED_COLOR : liveRangeSegment.getColor());\n+        if (highlighted) {\n+            g.setStroke(new BasicStroke(2));\n+        }\n+        int start = 0;\n+        int end = length;\n+        if (length == 0 && !liveRangeSegment.isInstantaneous()) {\n+            \/\/ Continuation segment in empty basic block.\n+            assert liveRangeSegment.getStart() == null && liveRangeSegment.getEnd() == null;\n+            start = -2;\n+            end = 3;\n+        }\n+        g.drawLine(0, start, 0, end);\n+        if (liveRangeSegment.isOpening()) {\n+            g.drawLine(-RANGE_WIDTH, 0, RANGE_WIDTH, 0);\n+        }\n+        if (liveRangeSegment.isClosing()) {\n+            g.drawLine(-RANGE_WIDTH, end, RANGE_WIDTH, end);\n+        }\n+    }\n+\n+    @Override\n+    protected void notifyStateChanged(ObjectState previousState, ObjectState state) {\n+        super.notifyStateChanged(previousState, state);\n+        if (previousState.isHighlighted() != state.isHighlighted()) {\n+            for (LiveRangeSegment segment : liveRangeSegment.getSegmentSet()) {\n+                LiveRangeWidget figureWidget = scene.getWidget(segment);\n+                figureWidget.highlighted = state.isHighlighted();\n+                figureWidget.revalidate(true);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public JPopupMenu getPopupMenu(Widget widget, Point point) {\n+        Diagram diagram = this.scene.getModel().getDiagram();\n+        InputGraph graph = diagram.getInputGraph();\n+        int liveRangeId = liveRangeSegment.getLiveRange().getId();\n+\n+        JPopupMenu menu = scene.createPopupMenu();\n+        menu.addSeparator();\n+        Set<Figure> figures = new HashSet<>();\n+        for (InputNode node : graph.getRelatedNodes(liveRangeId)) {\n+            figures.add((diagram.getFigure(node)));\n+        }\n+        menu.add(scene.createGotoNodesAction(\"Select nodes\", figures));\n+        menu.addSeparator();\n+        for (InputNode node : graph.getDefNodes(liveRangeId)) {\n+            menu.add(scene.createGotoAction(diagram.getFigure(node)));\n+        }\n+        menu.addSeparator();\n+        for (InputNode node : graph.getUseNodes(liveRangeId)) {\n+            menu.add(scene.createGotoAction(diagram.getFigure(node)));\n+        }\n+        return menu;\n+    }\n+\n+    @Override\n+    public void handleDoubleClick(Widget w, WidgetAction.WidgetMouseEvent e) {\n+        DiagramViewModel model = this.scene.getModel();\n+        Set<Integer> nodes = new HashSet<>();\n+        InputGraph graph = model.getDiagram().getInputGraph();\n+        int liveRangeId = liveRangeSegment.getLiveRange().getId();\n+        for (InputNode node : graph.getRelatedNodes(liveRangeId)) {\n+            nodes.add(node.getId());\n+        }\n+        model.showOnly(nodes);\n+    }\n+\n+    @Override\n+    public Properties getProperties() {\n+        return liveRangeSegment.getProperties();\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LiveRangeWidget.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/liveRange.png","binary":true,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/selectLiveRanges.png","binary":true,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/selectNodes.png","binary":true,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/showLiveRanges.png","binary":true,"status":"added"},{"patch":"@@ -17,0 +17,1 @@\n+            <file name=\"com-sun-hotspot-igv-view-actions-ShowLiveRangesAction.instance\"><attr name=\"position\" intvalue=\"2001\"\/><\/file>\n@@ -48,0 +49,5 @@\n+        <folder name=\"Live Ranges\">\n+            <attr name=\"command\" stringvalue=\"l\"\/>\n+            <attr name=\"position\" intvalue=\"2\"\/>\n+            <file name=\"com-sun-hotspot-igv-view-LiveRangeQuickSearch.instance\"\/>\n+        <\/folder>\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/layer.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}