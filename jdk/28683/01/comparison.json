{"files":[{"patch":"@@ -79,2 +79,0 @@\n-serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -31,0 +30,2 @@\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires !vm.emulatedClient\n@@ -37,2 +38,2 @@\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n@@ -51,0 +52,1 @@\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n@@ -58,0 +60,1 @@\n+                \"-Xbatch\",\n@@ -67,23 +70,68 @@\n-        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n-        String output = oa.getOutput();\n-        if (oa.getExitValue() != 0) {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n-        }\n-        Asserts.assertTrue(oa.getExitValue() == 0);\n-\n-        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (0x[0-9a-f]{16}) to (0x[0-9a-f]{16})$\");\n-        Matcher matcher = pattern.matcher(output);\n-\n-        if (matcher.find()) {\n-            String fromAddr = matcher.group(1);\n-            String toAddr = matcher.group(2);\n-\n-            \/\/ Confirm events sent for both original and relocated nmethod\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n-        } else {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Unable to find relocation information\");\n+        Process process = pb.start();\n+\n+        \/\/ Read output as stream\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n+\n+            Pattern loadPattern = Pattern.compile(\n+                    \"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: (0x[0-9a-f]{16})\");\n+            Pattern unloadPattern = Pattern.compile(\n+                    \"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: (0x[0-9a-f]{16})\");\n+\n+            String firstLoadAddress = null;\n+            String secondLoadAddress = null;\n+\n+            String firstUnloadAddress = null;\n+            String secondUnloadAddress = null;\n+\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                \/\/ Check for load\n+                Matcher loadMatcher = loadPattern.matcher(line);\n+                if (loadMatcher.find()) {\n+                    \/\/ Verify the load events come before the unloads\n+                    Asserts.assertNull(firstUnloadAddress);\n+                    Asserts.assertNull(secondUnloadAddress);\n+\n+                    String address = loadMatcher.group(1);\n+\n+                    if (firstLoadAddress == null) {\n+                        System.out.println(\"Received first COMPILED_METHOD_LOAD event. Address: \" + address);\n+                        firstLoadAddress = address;\n+                    } else if (secondLoadAddress == null) {\n+                        System.out.println(\"Received second COMPILED_METHOD_LOAD event. Address: \" + address);\n+                        secondLoadAddress = address;\n+                    } else {\n+                        throw new RuntimeException(\"Received too many COMPILED_METHOD_LOAD events\");\n+                    }\n+                }\n+\n+                \/\/ Check for unload\n+                Matcher unloadMatcher = unloadPattern.matcher(line);\n+                if (unloadMatcher.find()) {\n+                    \/\/ Verify the unload events come after the loads\n+                    Asserts.assertNotNull(firstLoadAddress);\n+                    Asserts.assertNotNull(secondLoadAddress);\n+\n+                    String address = unloadMatcher.group(1);\n+\n+                    if (firstUnloadAddress == null) {\n+                        System.out.println(\"Received first COMPILED_METHOD_UNLOAD event. Address: \" + address);\n+                        firstUnloadAddress = address;\n+                    } else if (secondUnloadAddress == null) {\n+                        System.out.println(\"Received second COMPILED_METHOD_UNLOAD event. Address: \" + address);\n+                        secondUnloadAddress = address;\n+\n+                        \/\/ We should have all events after receiving second unload\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            Asserts.assertNotNull(firstLoadAddress);\n+            Asserts.assertNotNull(secondLoadAddress);\n+\n+            Asserts.assertNotNull(firstUnloadAddress);\n+            Asserts.assertNotNull(secondUnloadAddress);\n+\n+            Asserts.assertEquals(firstLoadAddress, firstUnloadAddress);\n+            Asserts.assertEquals(secondLoadAddress, secondUnloadAddress);\n@@ -91,0 +139,2 @@\n+\n+        process.destroy();\n@@ -110,26 +160,0 @@\n-    \/**\n-     * Returns value of VM option.\n-     *\n-     * @param name option's name\n-     * @return value of option or {@code null}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     *\/\n-    protected static String getVMOption(String name) {\n-        Objects.requireNonNull(name);\n-        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n-    }\n-\n-    \/**\n-     * Returns value of VM option or default value.\n-     *\n-     * @param name         option's name\n-     * @param defaultValue default value\n-     * @return value of option or {@code defaultValue}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     * @see #getVMOption(String)\n-     *\/\n-    protected static String getVMOption(String name, String defaultValue) {\n-        String result = getVMOption(name);\n-        return result == null ? defaultValue : result;\n-    }\n-\n@@ -137,4 +161,0 @@\n-        run();\n-    }\n-\n-    public static void run() throws Exception {\n@@ -145,2 +165,3 @@\n-        while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            Thread.onSpinWait();\n+\n+        if (!WHITE_BOX.isMethodCompiled(method)) {\n+            throw new AssertionError(\"Method not compiled\");\n@@ -167,7 +188,4 @@\n-        WHITE_BOX.fullGC();\n-        WHITE_BOX.fullGC();\n-\n-        WHITE_BOX.lockCompilation();\n-\n-        System.out.printf(\"Relocated nmethod from 0x%016x to 0x%016x%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n-        System.out.flush();\n+        while (true) {\n+            WHITE_BOX.fullGC();\n+            System.out.flush();\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":83,"deletions":65,"binary":false,"changes":148,"status":"modified"}]}