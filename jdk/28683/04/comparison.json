{"files":[{"patch":"@@ -79,2 +79,0 @@\n-serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -29,2 +28,5 @@\n- * @requires vm.jvmti\n- * @requires vm.gc == \"null\" | vm.gc == \"Serial\"\n+ * @requires vm.jvmti &\n+ *           vm.gc != \"Epsilon\" &\n+ *           vm.flavor == \"server\" &\n+ *           !vm.emulatedClient &\n+ *           (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n@@ -34,1 +36,11 @@\n- * @run main\/othervm\/native NMethodRelocationTest\n+ * @run main\/othervm\/native -agentlib:NMethodRelocationTest\n+ *                          --enable-native-access=ALL-UNNAMED\n+ *                          -Xbootclasspath\/a:.\n+ *                          -Xbatch\n+ *                          -XX:+UnlockDiagnosticVMOptions\n+ *                          -XX:+WhiteBoxAPI\n+ *                          -XX:+SegmentedCodeCache\n+ *                          -XX:-TieredCompilation\n+ *                          -XX:+UnlockExperimentalVMOptions\n+ *                          -XX:+NMethodRelocation\n+ *                          NMethodRelocationTest\n@@ -37,2 +49,0 @@\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n@@ -40,3 +50,0 @@\n-import java.util.Objects;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -51,0 +58,1 @@\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n@@ -53,42 +61,0 @@\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                \"-agentlib:NMethodRelocationTest\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"-Xbootclasspath\/a:.\",\n-                \"-XX:+UseSerialGC\",\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n-                \"-XX:+SegmentedCodeCache\",\n-                \"-XX:-TieredCompilation\",\n-                \"-XX:+UnlockExperimentalVMOptions\",\n-                \"-XX:+NMethodRelocation\",\n-                \"DoWork\");\n-\n-        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n-        String output = oa.getOutput();\n-        if (oa.getExitValue() != 0) {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n-        }\n-        Asserts.assertTrue(oa.getExitValue() == 0);\n-\n-        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (0x[0-9a-f]{16}) to (0x[0-9a-f]{16})$\");\n-        Matcher matcher = pattern.matcher(output);\n-\n-        if (matcher.find()) {\n-            String fromAddr = matcher.group(1);\n-            String toAddr = matcher.group(2);\n-\n-            \/\/ Confirm events sent for both original and relocated nmethod\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n-        } else {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Unable to find relocation information\");\n-        }\n-    }\n-}\n-\n-class DoWork {\n@@ -98,0 +64,2 @@\n+    static volatile boolean shouldExit = false;\n+\n@@ -110,32 +78,2 @@\n-    \/**\n-     * Returns value of VM option.\n-     *\n-     * @param name option's name\n-     * @return value of option or {@code null}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     *\/\n-    protected static String getVMOption(String name) {\n-        Objects.requireNonNull(name);\n-        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n-    }\n-\n-    \/**\n-     * Returns value of VM option or default value.\n-     *\n-     * @param name         option's name\n-     * @param defaultValue default value\n-     * @return value of option or {@code defaultValue}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     * @see #getVMOption(String)\n-     *\/\n-    protected static String getVMOption(String name, String defaultValue) {\n-        String result = getVMOption(name);\n-        return result == null ? defaultValue : result;\n-    }\n-\n-    public static void main(String argv[]) throws Exception {\n-        run();\n-    }\n-\n-    public static void run() throws Exception {\n-        Executable method = DoWork.class.getDeclaredMethod(\"compiledMethod\");\n+    public static void main(String[] argv) throws Exception {\n+        Executable method = NMethodRelocationTest.class.getDeclaredMethod(\"compiledMethod\");\n@@ -145,2 +83,3 @@\n-        while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            Thread.onSpinWait();\n+\n+        if (!WHITE_BOX.isMethodCompiled(method)) {\n+            throw new AssertionError(\"Method not compiled\");\n@@ -167,7 +106,3 @@\n-        WHITE_BOX.fullGC();\n-        WHITE_BOX.fullGC();\n-\n-        WHITE_BOX.lockCompilation();\n-\n-        System.out.printf(\"Relocated nmethod from 0x%016x to 0x%016x%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n-        System.out.flush();\n+        while (!shouldExit) {\n+            WHITE_BOX.fullGC();\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":27,"deletions":92,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -25,3 +25,41 @@\n-#include <jvmti.h>\n-#include <stdio.h>\n-#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+\/\/ Track nmethod addresses for LOAD and UNLOAD events\n+static const void* first_load_addr      = nullptr;\n+static const void* second_load_addr     = nullptr;\n+static const void* first_unload_addr    = nullptr;\n+static const void* second_unload_addr   = nullptr;\n+\n+\/\/ Store JavaVM reference for JNI communication\n+static JavaVM* javaVM = nullptr;\n+\n+\/**\n+ * Helper function to update the shouldExit field in the Java test class.\n+ *\/\n+static void updateShouldExit() {\n+    if (javaVM == nullptr) {\n+        abort();\n+    }\n+\n+    JNIEnv* env = nullptr;\n+    jint result = javaVM->AttachCurrentThread((void**)&env, nullptr);\n+    if (result != JNI_OK || env == nullptr) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n+    }\n+\n+    \/\/ Find the NMethodRelocationTest class\n+    jclass testClass = env->FindClass(\"NMethodRelocationTest\");\n+    if (testClass == nullptr) {\n+        fatal(env, \"ERROR: Could not find NMethodRelocationTest class\");\n+    }\n+\n+    \/\/ Get the shouldExit field ID\n+    jfieldID shouldExitField = env->GetStaticFieldID(testClass, \"shouldExit\", \"Z\");\n+    if (shouldExitField == nullptr) {\n+        fatal(env, \"ERROR: Could not find shouldExit field\");\n+    }\n+\n+    \/\/ Set shouldExit to true\n+    env->SetStaticBooleanField(testClass, shouldExitField, JNI_TRUE);\n+}\n@@ -37,2 +75,5 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n+    JNIEnv* env = nullptr;\n+    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n+    }\n@@ -40,3 +81,3 @@\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n+    \/\/ Only track events for \"compiledMethod\"\n+    char* name = get_method_name(jvmti, env, method);\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n@@ -46,3 +87,14 @@\n-    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+    LOG(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    if (first_load_addr == nullptr) {\n+        first_load_addr = code_addr;\n+    } else if (second_load_addr == nullptr) {\n+        second_load_addr = code_addr;\n+\n+        \/\/ Verify that the addresses are different\n+        if (first_load_addr == second_load_addr) {\n+            fatal(env, \"ERROR: Load events for 'compiledMethod' are expected to use different addresses.\");\n+        }\n+    } else {\n+        fatal(env, \"ERROR: Received too many load events for 'compiledMethod'\");\n+    }\n@@ -57,2 +109,5 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n+    JNIEnv* env = nullptr;\n+    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n+    }\n@@ -60,3 +115,3 @@\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n+    \/\/ Only track events for \"compiledMethod\"\n+    char* name = get_method_name(jvmti, env, method);\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n@@ -65,3 +120,29 @@\n-    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+\n+    LOG(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    \/\/ Validate both loads have occurred\n+    if (first_load_addr == nullptr || second_load_addr == nullptr) {\n+        fatal(env, \"ERROR: UNLOAD event for 'compiledMethod' occurred before both LOAD events\");\n+    }\n+\n+    if (first_unload_addr == nullptr) {\n+        first_unload_addr = code_addr;\n+    } else {\n+        second_unload_addr = code_addr;\n+\n+        \/\/ Verify that the addresses are different\n+        if (first_unload_addr == second_unload_addr) {\n+            fatal(env, \"ERROR: Unload events for 'compiledMethod' are expected to use different addresses.\");\n+        }\n+\n+        \/\/ LOAD and UNLOAD events should report the same two addresses, but the order of\n+        \/\/ the UNLOADs is not guaranteed, since the GC may unload either nmethod first.\n+        if ((first_load_addr == first_unload_addr  && second_load_addr == second_unload_addr) ||\n+            (first_load_addr == second_unload_addr && second_load_addr == first_unload_addr)) {\n+\n+            \/\/ Update shouldExit to signal test completion\n+            updateShouldExit();\n+        } else {\n+            fatal(env, \"ERROR: Address mismatch for 'compiledMethod' events\");\n+        }\n+    }\n@@ -72,1 +153,3 @@\n-    jvmtiError error;\n+\n+    \/\/ Store JavaVM reference for later use\n+    javaVM = jvm;\n@@ -75,1 +158,1 @@\n-        printf(\"Unable to access JVMTI!\\n\");\n+        LOG(\"Unable to access JVMTI!\\n\");\n@@ -83,5 +166,2 @@\n-    error = jvmti->AddCapabilities(&caps);\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to add capabilities, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    jvmtiError error = jvmti->AddCapabilities(&caps);\n+    check_jvmti_error(error, \"Unable to add capabilities\");\n@@ -95,4 +175,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to set event callbacks, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to set event callbacks\");\n@@ -102,4 +179,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_LOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_LOAD event\");\n@@ -108,4 +182,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_UNLOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_UNLOAD event\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":109,"deletions":38,"binary":false,"changes":147,"status":"modified"}]}