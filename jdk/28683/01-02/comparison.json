{"files":[{"patch":"@@ -28,4 +28,5 @@\n- * @requires vm.jvmti\n- * @requires vm.gc == \"null\" | vm.gc == \"Serial\"\n- * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n- * @requires !vm.emulatedClient\n+ * @requires vm.jvmti &\n+ *           vm.gc != \"Epsilon\" &\n+ *           vm.flavor == \"server\" &\n+ *           !vm.emulatedClient &\n+ *           (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n@@ -38,2 +39,0 @@\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n@@ -41,3 +40,0 @@\n-import java.util.Objects;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -61,1 +57,0 @@\n-                \"-XX:+UseSerialGC\",\n@@ -70,68 +65,5 @@\n-        Process process = pb.start();\n-\n-        \/\/ Read output as stream\n-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n-\n-            Pattern loadPattern = Pattern.compile(\n-                    \"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: (0x[0-9a-f]{16})\");\n-            Pattern unloadPattern = Pattern.compile(\n-                    \"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: (0x[0-9a-f]{16})\");\n-\n-            String firstLoadAddress = null;\n-            String secondLoadAddress = null;\n-\n-            String firstUnloadAddress = null;\n-            String secondUnloadAddress = null;\n-\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                \/\/ Check for load\n-                Matcher loadMatcher = loadPattern.matcher(line);\n-                if (loadMatcher.find()) {\n-                    \/\/ Verify the load events come before the unloads\n-                    Asserts.assertNull(firstUnloadAddress);\n-                    Asserts.assertNull(secondUnloadAddress);\n-\n-                    String address = loadMatcher.group(1);\n-\n-                    if (firstLoadAddress == null) {\n-                        System.out.println(\"Received first COMPILED_METHOD_LOAD event. Address: \" + address);\n-                        firstLoadAddress = address;\n-                    } else if (secondLoadAddress == null) {\n-                        System.out.println(\"Received second COMPILED_METHOD_LOAD event. Address: \" + address);\n-                        secondLoadAddress = address;\n-                    } else {\n-                        throw new RuntimeException(\"Received too many COMPILED_METHOD_LOAD events\");\n-                    }\n-                }\n-\n-                \/\/ Check for unload\n-                Matcher unloadMatcher = unloadPattern.matcher(line);\n-                if (unloadMatcher.find()) {\n-                    \/\/ Verify the unload events come after the loads\n-                    Asserts.assertNotNull(firstLoadAddress);\n-                    Asserts.assertNotNull(secondLoadAddress);\n-\n-                    String address = unloadMatcher.group(1);\n-\n-                    if (firstUnloadAddress == null) {\n-                        System.out.println(\"Received first COMPILED_METHOD_UNLOAD event. Address: \" + address);\n-                        firstUnloadAddress = address;\n-                    } else if (secondUnloadAddress == null) {\n-                        System.out.println(\"Received second COMPILED_METHOD_UNLOAD event. Address: \" + address);\n-                        secondUnloadAddress = address;\n-\n-                        \/\/ We should have all events after receiving second unload\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            Asserts.assertNotNull(firstLoadAddress);\n-            Asserts.assertNotNull(secondLoadAddress);\n-\n-            Asserts.assertNotNull(firstUnloadAddress);\n-            Asserts.assertNotNull(secondUnloadAddress);\n-\n-            Asserts.assertEquals(firstLoadAddress, firstUnloadAddress);\n-            Asserts.assertEquals(secondLoadAddress, secondUnloadAddress);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        String output = oa.getOutput();\n+        if (oa.getExitValue() != 0) {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n@@ -139,2 +71,0 @@\n-\n-        process.destroy();\n@@ -190,1 +120,0 @@\n-            System.out.flush();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":10,"deletions":81,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <stdlib.h>\n@@ -29,0 +30,6 @@\n+\/\/ Track nmethod addresses for LOAD and UNLOAD events\n+static const void* first_load_addr      = nullptr;\n+static const void* second_load_addr     = nullptr;\n+static const void* first_unload_addr    = nullptr;\n+static const void* second_unload_addr   = nullptr;\n+\n@@ -41,2 +48,0 @@\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n@@ -46,3 +51,15 @@\n-    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+    \/\/ Only track events for \"compiledMethod\"\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n+        return;\n+    }\n+\n+    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    if (first_load_addr == nullptr) {\n+        first_load_addr = code_addr;\n+    } else if (second_load_addr == nullptr) {\n+        second_load_addr = code_addr;\n+    } else {\n+        printf(\"ERROR: Received too many load events for 'compiledMethod'\\n\");\n+        exit(1);\n+    }\n@@ -61,2 +78,0 @@\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n@@ -65,3 +80,29 @@\n-    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+\n+    \/\/ Only track events for \"compiledMethod\"\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n+        return;\n+    }\n+\n+    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    \/\/ Validate both loads have occurred\n+    if (first_load_addr == nullptr || second_load_addr == nullptr) {\n+        printf(\"ERROR: UNLOAD event for 'compiledMethod' occured before both LOAD events\\n\");\n+        exit(1);\n+    }\n+\n+    if (first_unload_addr == nullptr) {\n+        first_unload_addr = code_addr;\n+    } else {\n+        second_unload_addr = code_addr;\n+\n+        \/\/ LOAD and UNLOAD events should report the same two addresses, but the order of\n+        \/\/ the UNLOADs is not guaranteed, since the GC may unload either nmethod first.\n+        if ((first_load_addr == first_unload_addr  && second_load_addr == second_unload_addr) ||\n+            (first_load_addr == second_unload_addr && second_load_addr == first_unload_addr)) {\n+            exit(0);\n+        } else {\n+            printf(\"ERROR: Address mismatch for 'compiledMethod' events\\n\");\n+            exit(1);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"}]}