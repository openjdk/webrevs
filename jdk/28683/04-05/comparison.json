{"files":[{"patch":"@@ -62,4 +62,0 @@\n-    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-\n-    static volatile boolean shouldExit = false;\n-\n@@ -78,0 +74,4 @@\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    native static boolean shouldExit();\n+\n@@ -106,1 +106,1 @@\n-        while (!shouldExit) {\n+        while (!shouldExit()) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <atomic>\n@@ -27,0 +28,2 @@\n+extern \"C\" {\n+\n@@ -33,33 +36,2 @@\n-\/\/ Store JavaVM reference for JNI communication\n-static JavaVM* javaVM = nullptr;\n-\n-\/**\n- * Helper function to update the shouldExit field in the Java test class.\n- *\/\n-static void updateShouldExit() {\n-    if (javaVM == nullptr) {\n-        abort();\n-    }\n-\n-    JNIEnv* env = nullptr;\n-    jint result = javaVM->AttachCurrentThread((void**)&env, nullptr);\n-    if (result != JNI_OK || env == nullptr) {\n-        LOG(\"ERROR: Can't attach to current thread\\n\");\n-        abort();\n-    }\n-\n-    \/\/ Find the NMethodRelocationTest class\n-    jclass testClass = env->FindClass(\"NMethodRelocationTest\");\n-    if (testClass == nullptr) {\n-        fatal(env, \"ERROR: Could not find NMethodRelocationTest class\");\n-    }\n-\n-    \/\/ Get the shouldExit field ID\n-    jfieldID shouldExitField = env->GetStaticFieldID(testClass, \"shouldExit\", \"Z\");\n-    if (shouldExitField == nullptr) {\n-        fatal(env, \"ERROR: Could not find shouldExit field\");\n-    }\n-\n-    \/\/ Set shouldExit to true\n-    env->SetStaticBooleanField(testClass, shouldExitField, JNI_TRUE);\n-}\n+\/\/ Keep track of test completion\n+static std::atomic<bool> should_exit{false};\n@@ -75,5 +47,0 @@\n-    JNIEnv* env = nullptr;\n-    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n-        LOG(\"ERROR: Can't attach to current thread\\n\");\n-        abort();\n-    }\n@@ -82,1 +49,1 @@\n-    char* name = get_method_name(jvmti, env, method);\n+    char* name = get_method_name(jvmti, method);\n@@ -96,1 +63,1 @@\n-            fatal(env, \"ERROR: Load events for 'compiledMethod' are expected to use different addresses.\");\n+            fatal(\"Load events for 'compiledMethod' are expected to use different addresses\");\n@@ -99,1 +66,1 @@\n-        fatal(env, \"ERROR: Received too many load events for 'compiledMethod'\");\n+        fatal(\"Received too many load events for 'compiledMethod'\");\n@@ -109,5 +76,0 @@\n-    JNIEnv* env = nullptr;\n-    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n-        LOG(\"ERROR: Can't attach to current thread\\n\");\n-        abort();\n-    }\n@@ -116,1 +78,1 @@\n-    char* name = get_method_name(jvmti, env, method);\n+    char* name = get_method_name(jvmti, method);\n@@ -125,1 +87,1 @@\n-        fatal(env, \"ERROR: UNLOAD event for 'compiledMethod' occurred before both LOAD events\");\n+        fatal(\"UNLOAD event for 'compiledMethod' occurred before both LOAD events\");\n@@ -130,1 +92,1 @@\n-    } else {\n+    } else if (second_unload_addr == nullptr) {\n@@ -135,1 +97,1 @@\n-            fatal(env, \"ERROR: Unload events for 'compiledMethod' are expected to use different addresses.\");\n+            fatal(\"Unload events for 'compiledMethod' are expected to use different addresses\");\n@@ -143,2 +105,2 @@\n-            \/\/ Update shouldExit to signal test completion\n-            updateShouldExit();\n+            \/\/ Update should_exit to signal test completion\n+            should_exit.store(true);\n@@ -146,1 +108,1 @@\n-            fatal(env, \"ERROR: Address mismatch for 'compiledMethod' events\");\n+            fatal(\"Address mismatch for 'compiledMethod' events\");\n@@ -148,0 +110,2 @@\n+    } else {\n+        fatal(\"Received too many unload events for 'compiledMethod'\");\n@@ -154,3 +118,0 @@\n-    \/\/ Store JavaVM reference for later use\n-    javaVM = jvm;\n-\n@@ -186,0 +147,7 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NMethodRelocationTest_shouldExit(JNIEnv *env, jclass cls) {\n+  return should_exit.load();\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":24,"deletions":56,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -126,0 +126,6 @@\n+static void\n+fatal(const char* msg) {\n+  LOG(\"FATAL ERROR: %s\\n\", msg);\n+  abort();\n+}\n+\n@@ -316,0 +322,11 @@\n+static char*\n+get_method_name(jvmtiEnv *jvmti, jmethodID method) {\n+  char*  mname = nullptr;\n+  jvmtiError err;\n+\n+  err = jvmti->GetMethodName(method, &mname, nullptr, nullptr);\n+  check_jvmti_error(err, \"get_method_name: error in JVMTI GetMethodName call\");\n+\n+  return mname;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}