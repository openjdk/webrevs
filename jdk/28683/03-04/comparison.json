{"files":[{"patch":"@@ -36,1 +36,11 @@\n- * @run main\/othervm\/native NMethodRelocationTest\n+ * @run main\/othervm\/native -agentlib:NMethodRelocationTest\n+ *                          --enable-native-access=ALL-UNNAMED\n+ *                          -Xbootclasspath\/a:.\n+ *                          -Xbatch\n+ *                          -XX:+UnlockDiagnosticVMOptions\n+ *                          -XX:+WhiteBoxAPI\n+ *                          -XX:+SegmentedCodeCache\n+ *                          -XX:-TieredCompilation\n+ *                          -XX:+UnlockExperimentalVMOptions\n+ *                          -XX:+NMethodRelocation\n+ *                          NMethodRelocationTest\n@@ -51,24 +61,0 @@\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                \"-agentlib:NMethodRelocationTest\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"-Xbootclasspath\/a:.\",\n-                \"-Xbatch\",\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n-                \"-XX:+SegmentedCodeCache\",\n-                \"-XX:-TieredCompilation\",\n-                \"-XX:+UnlockExperimentalVMOptions\",\n-                \"-XX:+NMethodRelocation\",\n-                \"DoWork\");\n-\n-        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n-        String output = oa.getOutput();\n-        if (oa.getExitValue() != 0) {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n-        }\n-    }\n-}\n-\n-class DoWork {\n@@ -78,0 +64,2 @@\n+    static volatile boolean shouldExit = false;\n+\n@@ -90,2 +78,2 @@\n-    public static void main(String argv[]) throws Exception {\n-        Executable method = DoWork.class.getDeclaredMethod(\"compiledMethod\");\n+    public static void main(String[] argv) throws Exception {\n+        Executable method = NMethodRelocationTest.class.getDeclaredMethod(\"compiledMethod\");\n@@ -118,1 +106,1 @@\n-        while (true) {\n+        while (!shouldExit) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -25,4 +25,1 @@\n-#include <jvmti.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n+#include \"jvmti_common.hpp\"\n@@ -36,0 +33,34 @@\n+\/\/ Store JavaVM reference for JNI communication\n+static JavaVM* javaVM = nullptr;\n+\n+\/**\n+ * Helper function to update the shouldExit field in the Java test class.\n+ *\/\n+static void updateShouldExit() {\n+    if (javaVM == nullptr) {\n+        abort();\n+    }\n+\n+    JNIEnv* env = nullptr;\n+    jint result = javaVM->AttachCurrentThread((void**)&env, nullptr);\n+    if (result != JNI_OK || env == nullptr) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n+    }\n+\n+    \/\/ Find the NMethodRelocationTest class\n+    jclass testClass = env->FindClass(\"NMethodRelocationTest\");\n+    if (testClass == nullptr) {\n+        fatal(env, \"ERROR: Could not find NMethodRelocationTest class\");\n+    }\n+\n+    \/\/ Get the shouldExit field ID\n+    jfieldID shouldExitField = env->GetStaticFieldID(testClass, \"shouldExit\", \"Z\");\n+    if (shouldExitField == nullptr) {\n+        fatal(env, \"ERROR: Could not find shouldExit field\");\n+    }\n+\n+    \/\/ Set shouldExit to true\n+    env->SetStaticBooleanField(testClass, shouldExitField, JNI_TRUE);\n+}\n+\n@@ -44,5 +75,4 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n-\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        return;\n+    JNIEnv* env = nullptr;\n+    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n@@ -52,0 +82,1 @@\n+    char* name = get_method_name(jvmti, env, method);\n@@ -56,1 +87,1 @@\n-    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+    LOG(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n@@ -63,1 +94,1 @@\n-        \/\/ Verify that the addresses are differnt\n+        \/\/ Verify that the addresses are different\n@@ -65,2 +96,1 @@\n-            printf(\"ERROR: Load events for 'compiledMethod' are expected to use different addresses.\\n\");\n-            exit(1);\n+            fatal(env, \"ERROR: Load events for 'compiledMethod' are expected to use different addresses.\");\n@@ -69,2 +99,1 @@\n-        printf(\"ERROR: Received too many load events for 'compiledMethod'\\n\");\n-        exit(1);\n+        fatal(env, \"ERROR: Received too many load events for 'compiledMethod'\");\n@@ -80,5 +109,4 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n-\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        return;\n+    JNIEnv* env = nullptr;\n+    if (javaVM->AttachCurrentThread((void**)&env, nullptr) != JNI_OK) {\n+        LOG(\"ERROR: Can't attach to current thread\\n\");\n+        abort();\n@@ -88,0 +116,1 @@\n+    char* name = get_method_name(jvmti, env, method);\n@@ -92,1 +121,1 @@\n-    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+    LOG(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n@@ -96,2 +125,1 @@\n-        printf(\"ERROR: UNLOAD event for 'compiledMethod' occured before both LOAD events\\n\");\n-        exit(1);\n+        fatal(env, \"ERROR: UNLOAD event for 'compiledMethod' occurred before both LOAD events\");\n@@ -105,1 +133,1 @@\n-        \/\/ Verify that the addresses are differnt\n+        \/\/ Verify that the addresses are different\n@@ -107,2 +135,1 @@\n-            printf(\"ERROR: Unload events for 'compiledMethod' are expected to use different addresses.\\n\");\n-            exit(1);\n+            fatal(env, \"ERROR: Unload events for 'compiledMethod' are expected to use different addresses.\");\n@@ -115,1 +142,3 @@\n-            exit(0);\n+\n+            \/\/ Update shouldExit to signal test completion\n+            updateShouldExit();\n@@ -117,2 +146,1 @@\n-            printf(\"ERROR: Address mismatch for 'compiledMethod' events\\n\");\n-            exit(1);\n+            fatal(env, \"ERROR: Address mismatch for 'compiledMethod' events\");\n@@ -125,1 +153,3 @@\n-    jvmtiError error;\n+\n+    \/\/ Store JavaVM reference for later use\n+    javaVM = jvm;\n@@ -128,1 +158,1 @@\n-        printf(\"Unable to access JVMTI!\\n\");\n+        LOG(\"Unable to access JVMTI!\\n\");\n@@ -136,5 +166,2 @@\n-    error = jvmti->AddCapabilities(&caps);\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to add capabilities, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    jvmtiError error = jvmti->AddCapabilities(&caps);\n+    check_jvmti_error(error, \"Unable to add capabilities\");\n@@ -148,4 +175,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to set event callbacks, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to set event callbacks\");\n@@ -155,4 +179,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_LOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_LOAD event\");\n@@ -161,4 +182,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_UNLOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_UNLOAD event\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":66,"deletions":48,"binary":false,"changes":114,"status":"modified"}]}