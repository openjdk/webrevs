{"files":[{"patch":"@@ -2870,0 +2870,11 @@\n+void Assembler::movapd(XMMRegister dst, Address src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_rex_vex_w_reverted();\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x28);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -8073,0 +8084,8 @@\n+void Assembler::orpd(XMMRegister dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ !_legacy_mode_dq, \/* legacy_mode *\/ _legacy_mode_dq, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_rex_vex_w_reverted();\n+  int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x56, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -953,0 +953,1 @@\n+  void movapd(XMMRegister dst, Address src);\n@@ -2453,0 +2454,3 @@\n+  \/\/ Bitwise Logical OR of Packed Floating-Point Values\n+  void orpd(XMMRegister dst, XMMRegister src);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -723,1 +723,2 @@\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n+      x->id() == vmIntrinsics::_dcbrt\n@@ -810,1 +811,1 @@\n-       if (StubRoutines::dpow() != nullptr) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -831,1 +832,1 @@\n-       if (StubRoutines::dtan() != nullptr) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -838,2 +839,2 @@\n-       assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n-       if (StubRoutines::dtanh() != nullptr) {\n+      assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n+      if (StubRoutines::dtanh() != nullptr) {\n@@ -843,0 +844,6 @@\n+    case vmIntrinsics::_dcbrt:\n+      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n+      if (StubRoutines::dcbrt() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2253,0 +2253,10 @@\n+void MacroAssembler::movapd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::movapd(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::movapd(dst, Address(rscratch, 0));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -998,0 +998,2 @@\n+  void andnpd(XMMRegister dst, XMMRegister src) { Assembler::andnpd(dst, src); }\n+\n@@ -1010,0 +1012,2 @@\n+  void orpd(XMMRegister dst, XMMRegister src) { Assembler::orpd(dst, src); }\n+\n@@ -1244,0 +1248,3 @@\n+  using Assembler::movapd;\n+  void movapd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3695,0 +3695,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcbrt)) {\n+      StubRoutines::_dcbrt = generate_libmCbrt(); \/\/ from stubGenerator_x86_64_cbrt.cpp\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+  address generate_libmCbrt();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2025, Intel Corporation. All rights reserved.\n+ * Intel Math Library (LIBM) Source Code\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     ALGORITHM DESCRIPTION\n+\/\/                     ---------------------\n+\/\/\n+\/\/ x=2^{3*k+j} * 1.b1 b2 ... b5 b6 ... b52\n+\/\/ Let r=(x*2^{-3k-j} - 1.b1 b2 ... b5 1)* rcp[b1 b2 ..b5],\n+\/\/ where rcp[b1 b2 .. b5]=1\/(1.b1 b2 b3 b4 b5 1) in double precision\n+\/\/ cbrt(2^j * 1. b1 b2 .. b5 1) is approximated as T[j][b1..b5]+D[j][b1..b5]\n+\/\/ (T stores the high 53 bits, D stores the low order bits)\n+\/\/ Result=2^k*T+(2^k*T*r)*P+2^k*D\n+\/\/ where P=p1+p2*r+..+p8*r^7\n+\/\/\n+\/\/ Special cases:\n+\/\/  cbrt(NaN) = quiet NaN\n+\/\/  cbrt(+\/-INF) = +\/-INF\n+\/\/  cbrt(+\/-0) = +\/-0\n+\/\/\n+\/******************************************************************************\/\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _SIG_MASK[] =\n+{\n+    0, 1032192\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MASK[] =\n+{\n+    0, 3220176896\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MSK2[] =\n+{\n+    0, 3220193280\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _EXP_MSK3[] =\n+{\n+    4294967295, 1048575\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _SCALE63[] =\n+{\n+    0, 1138753536\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _ZERON[] =\n+{\n+    0, 2147483648\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _INF[] =\n+{\n+    0, 2146435072\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _NEG_INF[] =\n+{\n+    0, 4293918720\n+};\n+\n+ATTRIBUTE_ALIGNED(16) static const juint _coeff_table[] =\n+{\n+    1553778919, 3213899486, 3534952507, 3215266280, 1646371399,\n+    3214412045, 477218588,  3216798151, 3582521621, 1066628362,\n+    1007461464, 1068473053, 889629714,  1067378449, 1431655765,\n+    1070945621\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _rcp_table[] =\n+{\n+    528611360,  3220144632, 2884679527, 3220082993, 1991868891, 3220024928,\n+    2298714891, 3219970134, 58835168,   3219918343, 3035110223, 3219869313,\n+    1617585086, 3219822831, 2500867033, 3219778702, 4241943008, 3219736752,\n+    258732970,  3219696825, 404232216,  3219658776, 2172167368, 3219622476,\n+    1544257904, 3219587808, 377579543,  3219554664, 1616385542, 3219522945,\n+    813783277,  3219492562, 3940743189, 3219463431, 2689777499, 3219435478,\n+    1700977147, 3219408632, 3169102082, 3219382828, 327235604,  3219358008,\n+    1244336319, 3219334115, 1300311200, 3219311099, 3095471925, 3219288912,\n+    2166487928, 3219267511, 2913108253, 3219246854, 293672978,  3219226904,\n+    288737297,  3219207624, 1810275472, 3219188981, 174592167,  3219170945,\n+    3539053052, 3219153485, 2164392968, 3219136576\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _cbrt_table[] =\n+{\n+    572345495,  1072698681, 1998204467, 1072709382, 3861501553, 1072719872,\n+    2268192434, 1072730162, 2981979308, 1072740260, 270859143,  1072750176,\n+    2958651392, 1072759916, 313113243,  1072769490, 919449400,  1072778903,\n+    2809328903, 1072788162, 2222981587, 1072797274, 2352530781, 1072806244,\n+    594152517,  1072815078, 1555767199, 1072823780, 4282421314, 1072832355,\n+    2355578597, 1072840809, 1162590619, 1072849145, 797864051,  1072857367,\n+    431273680,  1072865479, 2669831148, 1072873484, 733477752,  1072881387,\n+    4280220604, 1072889189, 801961634,  1072896896, 2915370760, 1072904508,\n+    1159613482, 1072912030, 2689944798, 1072919463, 1248687822, 1072926811,\n+    2967951030, 1072934075, 630170432,  1072941259, 3760898254, 1072948363,\n+    0,          1072955392, 2370273294, 1072962345, 1261754802, 1072972640,\n+    546334065,  1072986123, 1054893830, 1072999340, 1571187597, 1073012304,\n+    1107975175, 1073025027, 3606909377, 1073037519, 1113616747, 1073049792,\n+    4154744632, 1073061853, 3358931423, 1073073713, 4060702372, 1073085379,\n+    747576176,  1073096860, 3023138255, 1073108161, 1419988548, 1073119291,\n+    1914185305, 1073130255, 294389948,  1073141060, 3761802570, 1073151710,\n+    978281566,  1073162213, 823148820,  1073172572, 2420954441, 1073182792,\n+    3815449908, 1073192878, 2046058587, 1073202835, 1807524753, 1073212666,\n+    2628681401, 1073222375, 3225667357, 1073231966, 1555307421, 1073241443,\n+    3454043099, 1073250808, 1208137896, 1073260066, 3659916772, 1073269218,\n+    1886261264, 1073278269, 3593647839, 1073287220, 3086012205, 1073296075,\n+    2769796922, 1073304836, 888716057,  1073317807, 2201465623, 1073334794,\n+    164369365,  1073351447, 3462666733, 1073367780, 2773905457, 1073383810,\n+    1342879088, 1073399550, 2543933975, 1073415012, 1684477781, 1073430209,\n+    3532178543, 1073445151, 1147747300, 1073459850, 1928031793, 1073474314,\n+    2079717015, 1073488553, 4016765315, 1073502575, 3670431139, 1073516389,\n+    3549227225, 1073530002, 11637607,   1073543422, 588220169,  1073556654,\n+    2635407503, 1073569705, 2042029317, 1073582582, 1925128962, 1073595290,\n+    4136375664, 1073607834, 759964600,  1073620221, 4257606771, 1073632453,\n+    297278907,  1073644538, 3655053093, 1073656477, 2442253172, 1073668277,\n+    1111876799, 1073679941, 3330973139, 1073691472, 3438879452, 1073702875,\n+    3671565478, 1073714153, 1317849547, 1073725310, 1642364115, 1073736348\n+};\n+\n+ATTRIBUTE_ALIGNED(4) static const juint _D_table[] =\n+{\n+    4050900474, 1014427190, 1157977860, 1016444461, 1374568199, 1017271387,\n+    2809163288, 1016882676, 3742377377, 1013168191, 3101606597, 1017541672,\n+    65224358,   1017217597, 2691591250, 1017266643, 4020758549, 1017689313,\n+    1316310992, 1018030788, 1031537856, 1014090882, 3261395239, 1016413641,\n+    886424999,  1016313335, 3114776834, 1014195875, 1681120620, 1017825416,\n+    1329600273, 1016625740, 465474623,  1017097119, 4251633980, 1017169077,\n+    1986990133, 1017710645, 752958613,  1017159641, 2216216792, 1018020163,\n+    4282860129, 1015924861, 1557627859, 1016039538, 3889219754, 1018086237,\n+    3684996408, 1017353275, 723532103,  1017717141, 2951149676, 1012528470,\n+    831890937,  1017830553, 1031212645, 1017387331, 2741737450, 1017604974,\n+    2863311531, 1003776682, 4276736099, 1013153088, 4111778382, 1015673686,\n+    1728065769, 1016413986, 2708718031, 1018078833, 1069335005, 1015291224,\n+    700037144,  1016482032, 2904566452, 1017226861, 4074156649, 1017622651,\n+    25019565,   1015245366, 3601952608, 1015771755, 3267129373, 1017904664,\n+    503203103,  1014921629, 2122011730, 1018027866, 3927295461, 1014189456,\n+    2790625147, 1016024251, 1330460186, 1016940346, 4033568463, 1015538390,\n+    3695818227, 1017509621, 257573361,  1017208868, 3227697852, 1017337964,\n+    234118548,  1017169577, 4009025803, 1017278524, 1948343394, 1017749310,\n+    678398162,  1018144239, 3083864863, 1016669086, 2415453452, 1017890370,\n+    175467344,  1017330033, 3197359580, 1010339928, 2071276951, 1015941358,\n+    268372543,  1016737773, 938132959,  1017389108, 1816750559, 1017337448,\n+    4119203749, 1017152174, 2578653878, 1013108497, 2470331096, 1014678606,\n+    123855735,  1016553320, 1265650889, 1014782687, 3414398172, 1017182638,\n+    1040773369, 1016158401, 3483628886, 1016886550, 4140499405, 1016191425,\n+    3893477850, 1016964495, 3935319771, 1009634717, 2978982660, 1015027112,\n+    2452709923, 1017990229, 3190365712, 1015835149, 4237588139, 1015832925,\n+    2610678389, 1017962711, 2127316774, 1017405770, 824267502,  1017959463,\n+    2165924042, 1017912225, 2774007076, 1013257418, 4123916326, 1017582284,\n+    1976417958, 1016959909, 4092806412, 1017711279, 119251817,  1015363631,\n+    3475418768, 1017675415, 1972580503, 1015470684, 815541017,  1017517969,\n+    2429917451, 1017397776, 4062888482, 1016749897, 68284153,   1017925678,\n+    2207779246, 1016320298, 1183466520, 1017408657, 143326427,  1017060403\n+};\n+\n+#define __ _masm->\n+\n+address StubGenerator::generate_libmCbrt() {\n+  StubGenStubId stub_id = StubGenStubId::dcbrt_id;\n+  StubCodeMark mark(this, stub_id);\n+  address start = __ pc();\n+\n+  Label L_2TAG_PACKET_0_0_1, L_2TAG_PACKET_1_0_1, L_2TAG_PACKET_2_0_1, L_2TAG_PACKET_3_0_1;\n+  Label L_2TAG_PACKET_4_0_1, L_2TAG_PACKET_5_0_1, L_2TAG_PACKET_6_0_1;\n+  Label B1_1, B1_2, B1_4;\n+\n+  address SIG_MASK        = (address)_SIG_MASK;\n+  address EXP_MASK        = (address)_EXP_MASK;\n+  address EXP_MSK2        = (address)_EXP_MSK2;\n+  address EXP_MSK3        = (address)_EXP_MSK3;\n+  address SCALE63         = (address)_SCALE63;\n+  address ZERON           = (address)_ZERON;\n+  address INF             = (address)_INF;\n+  address NEG_INF         = (address)_NEG_INF;\n+  address coeff_table     = (address)_coeff_table;\n+  address rcp_table       = (address)_rcp_table;\n+  address cbrt_table      = (address)_cbrt_table;\n+  address D_table         = (address)_D_table;\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  __ bind(B1_1);\n+  __ subq(rsp, 24);\n+  __ movsd(Address(rsp), xmm0);\n+\n+  __ bind(B1_2);\n+  __ movq(xmm7, xmm0);\n+  __ movl(rdx, 524032);\n+  __ movsd(xmm5, ExternalAddress(EXP_MSK3), r11 \/*rscratch*\/);\n+  __ movsd(xmm3, ExternalAddress(EXP_MSK2), r11 \/*rscratch*\/);\n+  __ psrlq(xmm7, 44);\n+  __ pextrw(rcx, xmm7, 0);\n+  __ movdl(rax, xmm7);\n+  __ movsd(xmm1, ExternalAddress(EXP_MASK), r11 \/*rscratch*\/);\n+  __ movsd(xmm2, ExternalAddress(SIG_MASK), r11 \/*rscratch*\/);\n+  __ andl(rcx, 248);\n+  __ lea(r8, ExternalAddress(rcp_table));\n+  __ movsd(xmm4, Address(rcx, r8, Address::times_1));\n+  __ movq(r9, rax);\n+  __ andl(rdx, rax);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_0_0_1); \/\/ Branch only if |x| is denormalized\n+  __ cmpl(rdx, 524032);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_1_0_1); \/\/ Branch only if |x| is INF or NaN\n+  __ shrl(rdx, 8);\n+  __ shrq(r9, 8);\n+  __ andpd(xmm2, xmm0);\n+  __ andpd(xmm0, xmm5);\n+  __ orpd(xmm3, xmm2);\n+  __ orpd(xmm1, xmm0);\n+  __ movapd(xmm5, ExternalAddress(coeff_table), r11 \/*rscratch*\/);\n+  __ movl(rax, 5462);\n+  __ movapd(xmm6, ExternalAddress(coeff_table + 16), r11 \/*rscratch*\/);\n+  __ mull(rdx);\n+  __ movq(rdx, r9);\n+  __ andq(r9, 2047);\n+  __ shrl(rax, 14);\n+  __ andl(rdx, 2048);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ shlq(r9, 8);\n+  __ addl(rax, 682);\n+  __ orl(rax, rdx);\n+  __ movdl(xmm7, rax);\n+  __ addq(rcx, r9);\n+  __ psllq(xmm7, 52);\n+\n+  __ bind(L_2TAG_PACKET_2_0_1);\n+  __ movapd(xmm2, ExternalAddress(coeff_table + 32), r11 \/*rscratch*\/);\n+  __ movapd(xmm0, ExternalAddress(coeff_table + 48), r11 \/*rscratch*\/);\n+  __ subsd(xmm1, xmm3);\n+  __ movq(xmm3, xmm7);\n+  __ lea(r8, ExternalAddress(cbrt_table));\n+  __ mulsd(xmm7, Address(rcx, r8, Address::times_1));\n+  __ mulsd(xmm1, xmm4);\n+  __ lea(r8, ExternalAddress(D_table));\n+  __ mulsd(xmm3, Address(rcx, r8, Address::times_1));\n+  __ movapd(xmm4, xmm1);\n+  __ unpcklpd(xmm1, xmm1);\n+  __ mulpd(xmm5, xmm1);\n+  __ mulpd(xmm6, xmm1);\n+  __ mulpd(xmm1, xmm1);\n+  __ addpd(xmm2, xmm5);\n+  __ addpd(xmm0, xmm6);\n+  __ mulpd(xmm2, xmm1);\n+  __ mulpd(xmm1, xmm1);\n+  __ mulsd(xmm4, xmm7);\n+  __ addpd(xmm0, xmm2);\n+  __ mulsd(xmm1, xmm0);\n+  __ unpckhpd(xmm0, xmm0);\n+  __ addsd(xmm0, xmm1);\n+  __ mulsd(xmm0, xmm4);\n+  __ addsd(xmm0, xmm3);\n+  __ addsd(xmm0, xmm7);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_0_0_1);\n+  __ mulsd(xmm0, ExternalAddress(SCALE63), r11 \/*rscratch*\/);\n+  __ movq(xmm7, xmm0);\n+  __ movl(rdx, 524032);\n+  __ psrlq(xmm7, 44);\n+  __ pextrw(rcx, xmm7, 0);\n+  __ movdl(rax, xmm7);\n+  __ andl(rcx, 248);\n+  __ lea(r8, ExternalAddress(rcp_table));\n+  __ movsd(xmm4, Address(rcx, r8, Address::times_1));\n+  __ movq(r9, rax);\n+  __ andl(rdx, rax);\n+  __ shrl(rdx, 8);\n+  __ shrq(r9, 8);\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::equal, L_2TAG_PACKET_3_0_1); \/\/ Branch only if |x| is zero\n+  __ andpd(xmm2, xmm0);\n+  __ andpd(xmm0, xmm5);\n+  __ orpd(xmm3, xmm2);\n+  __ orpd(xmm1, xmm0);\n+  __ movapd(xmm5, ExternalAddress(coeff_table), r11 \/*rscratch*\/);\n+  __ movl(rax, 5462);\n+  __ movapd(xmm6, ExternalAddress(coeff_table + 16), r11 \/*rscratch*\/);\n+  __ mull(rdx);\n+  __ movq(rdx, r9);\n+  __ andq(r9, 2047);\n+  __ shrl(rax, 14);\n+  __ andl(rdx, 2048);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ subq(r9, rax);\n+  __ shlq(r9, 8);\n+  __ addl(rax, 661);\n+  __ orl(rax, rdx);\n+  __ movdl(xmm7, rax);\n+  __ addq(rcx, r9);\n+  __ psllq(xmm7, 52);\n+  __ jmp(L_2TAG_PACKET_2_0_1);\n+\n+  __ bind(L_2TAG_PACKET_3_0_1);\n+  __ cmpq(r9, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_4_0_1); \/\/ Branch only if x is negative zero\n+  __ xorpd(xmm0, xmm0);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_4_0_1);\n+  __ movsd(xmm0, ExternalAddress(ZERON), r11 \/*rscratch*\/);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_1_0_1);\n+  __ movl(rax, Address(rsp, 4));\n+  __ movl(rdx, Address(rsp));\n+  __ movl(rcx, rax);\n+  __ andl(rcx, 2147483647);\n+  __ cmpl(rcx, 2146435072);\n+  __ jcc(Assembler::above, L_2TAG_PACKET_5_0_1); \/\/ Branch only if |x| is NaN\n+  __ cmpl(rdx, 0);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_5_0_1); \/\/ Branch only if |x| is NaN\n+  __ cmpl(rax, 2146435072);\n+  __ jcc(Assembler::notEqual, L_2TAG_PACKET_6_0_1); \/\/ Branch only if x is negative INF\n+  __ movsd(xmm0, ExternalAddress(INF), r11 \/*rscratch*\/);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_6_0_1);\n+  __ movsd(xmm0, ExternalAddress(NEG_INF), r11 \/*rscratch*\/);\n+  __ jmp(B1_4);\n+\n+  __ bind(L_2TAG_PACKET_5_0_1);\n+  __ movsd(xmm0, Address(rsp));\n+  __ addsd(xmm0, xmm0);\n+  __ movq(Address(rsp, 8), xmm0);\n+\n+  __ bind(B1_4);\n+  __ addq(rsp, 24);\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cbrt.cpp","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -471,0 +471,4 @@\n+  } else if (kind == Interpreter::java_lang_math_cbrt) {\n+    assert(StubRoutines::dcbrt() != nullptr, \"not initialized\");\n+    __ movdbl(xmm0, Address(rsp, wordSize));\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::dcbrt())));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  case vmIntrinsics::_dcbrt:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3301,0 +3301,1 @@\n+  case vmIntrinsics::_dcbrt         : \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2873,0 +2873,1 @@\n+  case vmIntrinsics::_dcbrt :         \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dcbrt());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -147,0 +148,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -291,0 +293,1 @@\n+  case vmIntrinsics::_dcbrt:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")                                                               \\\n+  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")       do_name(cbrt_name,\"cbrt\")                                                               \\\n@@ -164,1 +164,2 @@\n-  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,   double_double_signature,          F_S)   \\\n+  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,  double_double_signature,           F_S)   \\\n+  do_intrinsic(_dcbrt,                    java_lang_Math,         cbrt_name,  double_double_signature,           F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+      case vmIntrinsics::_dcbrt:             return java_lang_math_cbrt;\n@@ -202,0 +203,1 @@\n+  case java_lang_math_cbrt        : return vmIntrinsics::_dcbrt;\n@@ -306,0 +308,1 @@\n+    case java_lang_math_cbrt    : tty->print(\"java_lang_math_cbrt\"    ); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-\/\/ (aka c++ interpreter). Th division of labor is as follows:\n+\/\/ (aka c++ interpreter). The division of labor is as follows:\n@@ -76,0 +76,1 @@\n+    java_lang_math_cbrt,                                        \/\/ implementation of java.lang.Math.cbrt  (x)\n@@ -155,0 +156,1 @@\n+      case vmIntrinsics::_dcbrt : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+  method_entry(java_lang_math_cbrt )\n@@ -456,0 +457,1 @@\n+  case Interpreter::java_lang_math_cbrt    : \/\/ fall thru\n@@ -490,1 +492,0 @@\n-\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    method_entry(java_lang_math_cbrt  );\n@@ -99,0 +100,1 @@\n+  case Interpreter::java_lang_math_cbrt    : \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,1 @@\n+    static address dcbrt;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+address CompilerToVM::Data::dcbrt;\n@@ -267,0 +268,1 @@\n+  SET_TRIGFUNC_OR_NULL(dcbrt);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  static_field(CompilerToVM::Data,             dcbrt,                                  address)                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -619,0 +619,1 @@\n+  case vmIntrinsics::_dcbrt:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -1889,0 +1890,3 @@\n+  case vmIntrinsics::_dcbrt:\n+    return StubRoutines::dcbrt() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcbrt(), \"dcbrt\") : false;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -594,0 +594,2 @@\n+  do_stub(initial, dcbrt)                                               \\\n+  do_entry(initial, dcbrt, dcbrt, dcbrt)                                \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.util.Random;\n+\n+public class CbrtPerf {\n+\n+    @Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.MILLISECONDS)\n+    @Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.MILLISECONDS)\n+    @Fork(2)\n+    @BenchmarkMode(Mode.Throughput)\n+    @State(Scope.Thread)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public static class CbrtPerfRanges {\n+        public static int cbrtInputCount = 2048;\n+\n+        @Param({\"0\", \"1\"})\n+        public int cbrtRangeIndex;\n+\n+        public double [] cbrtPosRandInputs;\n+        public double [] cbrtNegRandInputs;\n+        public int       cbrtInputIndex = 0;\n+        public double    cbrtRangeInputs[][] = { {0.0, 0x1.0P-1022}, {0x1.0P-1022, 1.7976931348623157E308} };\n+\n+        @Setup\n+        public void setupValues() {\n+            Random random = new Random(1023);\n+\n+            \/\/ Fill the positive and negative cbrt vectors with random values\n+            cbrtPosRandInputs = new double[cbrtInputCount];\n+            cbrtNegRandInputs = new double[cbrtInputCount];\n+\n+            for (int i = 0; i < cbrtInputCount; i++) {\n+                double cbrtLowerBound = cbrtRangeInputs[cbrtRangeIndex][0];\n+                double cbrtUpperBound = cbrtRangeInputs[cbrtRangeIndex][1];\n+                cbrtPosRandInputs[i] = random.nextDouble(cbrtLowerBound, cbrtUpperBound);\n+                cbrtNegRandInputs[i] = random.nextDouble(-cbrtUpperBound, -cbrtLowerBound);\n+            }\n+        }\n+\n+        @Benchmark\n+        @OperationsPerInvocation(2048)\n+        public double  cbrtPosRangeDouble() {\n+            double res = 0.0;\n+            for (int i = 0; i < cbrtInputCount; i++) {\n+                res += Math.cbrt(cbrtPosRandInputs[i]);\n+            }\n+            return res;\n+        }\n+\n+        @Benchmark\n+        @OperationsPerInvocation(2048)\n+        public double  cbrtNegRangeDouble() {\n+            double res = 0.0;\n+            for (int i = 0; i < cbrtInputCount; i++) {\n+                res += Math.cbrt(cbrtNegRandInputs[i]);\n+            }\n+            return res;\n+        }\n+    }\n+\n+    @Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Fork(2)\n+    @BenchmarkMode(Mode.Throughput)\n+    @State(Scope.Thread)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public static class CbrtPerfConstant {\n+        public static final double constDouble0   = 0.0;\n+        public static final double constDouble1   = 1.0;\n+        public static final double constDouble27  = 27.0;\n+        public static final double constDouble512 = 512.0;\n+\n+        @Benchmark\n+        public double  cbrtConstDouble0() {\n+            return  Math.cbrt(constDouble0);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtConstDouble1() {\n+            return  Math.cbrt(constDouble1);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtConstDouble27() {\n+            return  Math.cbrt(constDouble27);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtConstDouble512() {\n+            return  Math.cbrt(constDouble512);\n+        }\n+    }\n+\n+    @Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+    @Fork(2)\n+    @BenchmarkMode(Mode.Throughput)\n+    @State(Scope.Thread)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public static class CbrtPerfSpecialValues {\n+        public double double0           = 0.0;\n+        public double doubleNegative0   = -0.0;\n+        public double doubleInf         = Double.POSITIVE_INFINITY;\n+        public double doubleNegativeInf = Double.NEGATIVE_INFINITY;\n+        public double doubleNaN         = Double.NaN;\n+\n+        @Benchmark\n+        public double  cbrtDouble0() {\n+            return  Math.cbrt(double0);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtDoubleNegative0() {\n+            return  Math.cbrt(doubleNegative0);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtDoubleInf() {\n+            return  Math.cbrt(doubleInf);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtDoubleNegativeInf() {\n+            return  Math.cbrt(doubleNegativeInf);\n+        }\n+\n+        @Benchmark\n+        public double  cbrtDoubleNaN() {\n+            return  Math.cbrt(doubleNaN);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(CbrtPerfRanges.class.getSimpleName())\n+                .build();\n+\n+        new Runner(opt).run();\n+\n+        opt = new OptionsBuilder()\n+                .include(CbrtPerfConstant.class.getSimpleName())\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/CbrtPerf.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}