{"files":[{"patch":"@@ -34,0 +34,3 @@\n+import static java.lang.Double.*;\n+import static java.lang.Double.MIN_VALUE;\n+\n@@ -3286,0 +3289,3 @@\n+    private static final double F_UP = 0x1p1023;  \/\/ normal, exact, 2^DoubleConsts.EXP_BIAS\n+    private static final double F_DOWN = 0x1p-1023;  \/\/ subnormal, exact, 2^-DoubleConsts.EXP_BIAS\n+\n@@ -3317,34 +3323,11 @@\n-        \/*\n-         * When scaling up, it does not matter what order the\n-         * multiply-store operations are done; the result will be\n-         * finite or overflow regardless of the operation ordering.\n-         * However, to get the correct result when scaling down, a\n-         * particular ordering must be used.\n-         *\n-         * When scaling down, the multiply-store operations are\n-         * sequenced so that it is not possible for two consecutive\n-         * multiply-stores to return subnormal results.  If one\n-         * multiply-store result is subnormal, the next multiply will\n-         * round it away to zero.  This is done by first multiplying\n-         * by 2 ^ (scaleFactor % n) and then multiplying several\n-         * times by 2^n as needed where n is the exponent of number\n-         * that is a convenient power of two.  In this way, at most one\n-         * real rounding error occurs.\n-         *\/\n-\n-        \/\/ magnitude of a power of two so large that scaling a finite\n-        \/\/ nonzero value by it would be guaranteed to over or\n-        \/\/ underflow; due to rounding, scaling down takes an\n-        \/\/ additional power of two which is reflected here\n-        final int MAX_SCALE = Double.MAX_EXPONENT + -Double.MIN_EXPONENT +\n-                              DoubleConsts.SIGNIFICAND_WIDTH + 1;\n-        int exp_adjust = 0;\n-        int scale_increment = 0;\n-        double exp_delta = Double.NaN;\n-\n-        \/\/ Make sure scaling factor is in a reasonable range\n-\n-        if(scaleFactor < 0) {\n-            scaleFactor = Math.max(scaleFactor, -MAX_SCALE);\n-            scale_increment = -512;\n-            exp_delta = 0x1p-512;\n+        if (scaleFactor > -DoubleConsts.EXP_BIAS) {\n+            if (scaleFactor <= DoubleConsts.EXP_BIAS) {\n+                return d * longBitsToDouble((long) (scaleFactor + DoubleConsts.EXP_BIAS) << PRECISION - 1);\n+            }\n+            if (scaleFactor <= 2 * DoubleConsts.EXP_BIAS) {\n+                return d * longBitsToDouble((long) scaleFactor << PRECISION - 1) * F_UP;\n+            }\n+            if (scaleFactor < 2 * DoubleConsts.EXP_BIAS + PRECISION - 1) {\n+                return d * longBitsToDouble((long) (scaleFactor - DoubleConsts.EXP_BIAS) << PRECISION - 1) * F_UP * F_UP;\n+            }\n+            return d * F_UP * F_UP * F_UP;\n@@ -3352,4 +3335,2 @@\n-        else {\n-            scaleFactor = Math.min(scaleFactor, MAX_SCALE);\n-            scale_increment = 512;\n-            exp_delta = 0x1p512;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS) {\n+            return d * longBitsToDouble((long) (scaleFactor + 2 * DoubleConsts.EXP_BIAS) << PRECISION - 1) * F_DOWN;\n@@ -3357,12 +3338,2 @@\n-\n-        \/\/ Calculate (scaleFactor % +\/-512), 512 = 2^9, using\n-        \/\/ technique from \"Hacker's Delight\" section 10-2.\n-        int t = (scaleFactor >> 9-1) >>> 32 - 9;\n-        exp_adjust = ((scaleFactor + t) & (512 -1)) - t;\n-\n-        d *= powerOfTwoD(exp_adjust);\n-        scaleFactor -= exp_adjust;\n-\n-        while(scaleFactor != 0) {\n-            d *= exp_delta;\n-            scaleFactor -= scale_increment;\n+        if (scaleFactor > -2 * DoubleConsts.EXP_BIAS - PRECISION) {\n+            return d * longBitsToDouble((long) (scaleFactor + 3 * DoubleConsts.EXP_BIAS) << PRECISION - 1) * F_DOWN * F_DOWN;\n@@ -3370,1 +3341,1 @@\n-        return d;\n+        return d * MIN_VALUE * MIN_VALUE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":22,"deletions":51,"binary":false,"changes":73,"status":"modified"}]}