{"files":[{"patch":"@@ -77,1 +77,1 @@\n-    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_NEWJDK_UPGRADED), \\\n@@ -80,1 +80,1 @@\n-    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n+    DISABLED_WARNINGS := this-escape rawtypes serial options preview, \\\n@@ -82,1 +82,1 @@\n-    JAVAC_FLAGS := -XDstringConcat=inline -Xprefer:newer, \\\n+    JAVAC_FLAGS := -XDstringConcat=inline -Xprefer:newer --enable-preview, \\\n@@ -126,1 +126,2 @@\n-\t$(JAVA_SMALL) -cp $(MICROBENCHMARK_TOOLS_CLASSES) \\\n+\t$(BUILD_JAVA_SMALL) -cp $(MICROBENCHMARK_TOOLS_CLASSES) \\\n+            --enable-preview \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    public static class MyCCS extends ConstantCallSite {\n+    static class MyCCS extends ConstantCallSite {\n","filename":"test\/jdk\/java\/lang\/invoke\/CallSiteTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    public static class Init1 {\n+    private static class Init1 {\n@@ -56,1 +56,1 @@\n-        public static int foo() { return Init1Tick; }\n+        static int foo() { return Init1Tick; }\n@@ -60,1 +60,1 @@\n-    public static class Init2 {\n+    private static class Init2 {\n@@ -62,1 +62,1 @@\n-        public static int bar() { return Init2Tick; }\n+        static int bar() { return Init2Tick; }\n@@ -66,1 +66,1 @@\n-    public static class Init3 {\n+    private static class Init3 {\n@@ -68,1 +68,1 @@\n-        public static int baz() { return Init3Tick; }\n+        static int baz() { return Init3Tick; }\n@@ -72,1 +72,1 @@\n-    public static class Init4 {\n+    private static class Init4 {\n@@ -74,1 +74,1 @@\n-        public static int bat() { return Init4Tick; }\n+        static int bat() { return Init4Tick; }\n@@ -78,1 +78,1 @@\n-    public static class Init5 {\n+    private static class Init5 {\n@@ -80,1 +80,1 @@\n-        public static int bang = Init5Tick;\n+        static int bang = Init5Tick;\n@@ -84,1 +84,1 @@\n-    public static class Init6 {\n+    private static class Init6 {\n@@ -86,1 +86,1 @@\n-        public static int pong;\n+        static int pong;\n@@ -115,1 +115,1 @@\n-            assertEquals(t1+1, t2);  \/\/ No other static initializations should have occurred in between\n+            assertEquals(t1+1, t2);  \/\/ no ticks in between\n@@ -153,1 +153,1 @@\n-        assertEquals(Init1Tick, 0);\/\/ Init1 has not been initialized before invoking INDY_foo\n+        assertEquals(Init1Tick, 0);  \/\/ Init1 not initialized yet\n@@ -157,8 +157,3 @@\n-        \/**\n-         * tick(\"runFoo\") increments TICK once\n-         * INDY_foo() increments TICK during Init1's static block.\n-         * tick(\"runFoo done\") increments TICK again.\n-         *\/\n-        assertEquals(Init1Tick + 3, t2);\n-        assertEquals(t1+1, t3); \/\/ one tick in between runFoo and runFoo done\n-        assertEquals(t1, t2);  \/\/ init happened inside\n+        assertEquals(Init1Tick, t2);  \/\/ when Init1 was initialized\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n@@ -177,3 +172,3 @@\n-        assertEquals(Init2Tick +4 , t2);  \/\/ when Init2 was initialized (Init1Tick + 3) + 1\n-        assertEquals(t1+1, t3);  \/\/ 1 tick in between runBar and runBar done\n-        assertEquals(t1, t2 +1);\n+        assertEquals(Init2Tick, t2);  \/\/ when Init2 was initialized\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n@@ -192,3 +187,3 @@\n-        assertEquals(Init3Tick + 5, t2);  \/\/\n-        assertEquals(t1+1, t3);\n-        assertEquals(t1, t2+4);\n+        assertEquals(Init3Tick, t2);  \/\/ when Init3 was initialized\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n@@ -207,3 +202,3 @@\n-        assertEquals(Init4Tick + 6, t2);\n-        assertEquals(t1+1, t3);\n-        assertEquals(t1, t2+5);\n+        assertEquals(Init4Tick, t2);  \/\/ when Init4 was initialized\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n@@ -222,3 +217,3 @@\n-        assertEquals(Init5Tick + 7, t2);\n-        assertEquals(t1+1, t3);\n-        assertEquals(t1, t2+6);\n+        assertEquals(Init5Tick, t2);  \/\/ when Init5 was initialized\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n@@ -238,2 +233,2 @@\n-        assertEquals(t1+1, t3);\n-        assertEquals(t1, t2 + 15);\n+        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n+        assertEquals(t1+1, t2);  \/\/ init happened inside\n","filename":"test\/jdk\/java\/lang\/invoke\/CallStaticInitOrder.java","additions":31,"deletions":36,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-    public static class TestPolicy extends Policy {\n+    static class TestPolicy extends Policy {\n@@ -242,1 +242,1 @@\n-        public TestPolicy() {\n+        TestPolicy() {\n","filename":"test\/jdk\/java\/lang\/invoke\/InvokeDynamicPrintArgs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-    public static class TestPolicy extends Policy {\n+    static class TestPolicy extends Policy {\n@@ -177,1 +177,1 @@\n-        public TestPolicy() {\n+        TestPolicy() {\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleConstants.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -28,1 +30,5 @@\n-import java.lang.classfile.instruction.*;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.NewObjectInstruction;\n+import java.lang.constant.ConstantDesc;\n@@ -30,0 +36,1 @@\n+import java.lang.reflect.Modifier;\n@@ -32,2 +39,0 @@\n-import java.io.*;\n-import java.lang.reflect.Modifier;\n@@ -35,1 +40,1 @@\n-import java.util.regex.*;\n+import java.util.regex.Pattern;\n@@ -42,1 +47,2 @@\n- * Transform one or more class files to incorporate JSR 292 features, such as {@code invokedynamic}.\n+ * Transform one or more class files to incorporate JSR 292 features,\n+ * such as {@code invokedynamic}.\n@@ -44,2 +50,4 @@\n- * This standalone program, contained within a single source file, is useful for test harnesses, small experiments, and Javadoc examples.\n- * Copies of this file may be distributed to various locations for standalone usage. The primary maintained location of this file is:\n+ * This is a standalone program in a single source file.\n+ * In this form, it may be useful for test harnesses, small experiments, and javadoc examples.\n+ * Copies of this file may show up in multiple locations for standalone usage.\n+ * The primary maintained location of this file is as follows:\n@@ -48,2 +56,0 @@\n- * <\/p>\n- *\n@@ -51,11 +57,19 @@\n- * Static private methods named MH_x and MT_x (where x is arbitrary) must generate MethodHandle and MethodType constants.\n- * All calls to these methods are transformed into {@code CONSTANT_MethodHandle} and {@code CONSTANT_MethodType} \"ldc\" instructions.\n- * The code must create method types using {@code methodType} or {@code fromMethodDescriptorString}. The \"lookup\" argument must be\n- * created using {@code java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}. The class and string arguments must be constant.\n- * The following methods of {@code java.lang.invoke.MethodHandle.Lookup Lookup} are allowed for method handle creation:\n- * {@code findStatic}, {@code findVirtual}, {@code findConstructor}, {@code findSpecial}, {@code findGetter}, {@code findSetter},\n- * {@code findStaticGetter}, or {@code findStaticSetter}. The call to one of these methods must be followed immediately by an\n- * {@code areturn} instruction. Replacing calls to MH_x or MT_x methods with {@code ldc} instructions should not change the program's\n- * meaning.\n- * <\/p>\n- *\n+ * Static private methods named MH_x and MT_x (where x is arbitrary)\n+ * must be stereotyped generators of MethodHandle and MethodType\n+ * constants.  All calls to them are transformed to {@code CONSTANT_MethodHandle}\n+ * and {@code CONSTANT_MethodType} \"ldc\" instructions.\n+ * The stereotyped code must create method types by calls to {@code methodType} or\n+ * {@code fromMethodDescriptorString}.  The \"lookup\" argument must be created\n+ * by calls to {@code java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.\n+ * The class and string arguments must be constant.\n+ * The following methods of {@code java.lang.invoke.MethodHandle.Lookup Lookup} are\n+ * allowed for method handle creation: {@code findStatic}, {@code findVirtual},\n+ * {@code findConstructor}, {@code findSpecial},\n+ * {@code findGetter}, {@code findSetter},\n+ * {@code findStaticGetter}, or {@code findStaticSetter}.\n+ * The call to one of these methods must be followed immediately\n+ * by an {@code areturn} instruction.\n+ * The net result of the call to the MH_x or MT_x method must be\n+ * the creation of a constant method handle.  Thus, replacing calls\n+ * to MH_x or MT_x methods by {@code ldc} instructions should leave\n+ * the meaning of the program unchanged.\n@@ -63,5 +77,12 @@\n- * Static private methods named INDY_x must generate {@code invokedynamic} call sites. All calls to them must be immediately followed\n- * by {@code invokeExact} calls. These pairs of calls are transformed into {@code invokedynamic} instructions. Each INDY_x method must\n- * start with a call to an MH_x method, which acts as its bootstrap method. This method must be immediately invoked (via {@code invokeGeneric})\n- * on constant lookup, name, and type arguments. An object array of constants may also be appended to the {@code invokeGeneric} call.\n- * This call must be cast to {@code CallSite}, and the result must be immediately followed by a call to {@code dynamicInvoker}, with the\n+ * Static private methods named INDY_x must be stereotyped generators\n+ * of {@code invokedynamic} call sites.\n+ * All calls to them must be immediately followed by\n+ * {@code invokeExact} calls.\n+ * All such pairs of calls are transformed to {@code invokedynamic}\n+ * instructions.  Each INDY_x method must begin with a call to a\n+ * MH_x method, which is taken to be its bootstrap method.\n+ * The method must be immediately invoked (via {@code invokeGeneric}\n+ * on constant lookup, name, and type arguments.  An object array of\n+ * constants may also be appended to the {@code invokeGeneric call}.\n+ * This call must be cast to {@code CallSite}, and the result must be\n+ * immediately followed by a call to {@code dynamicInvoker}, with the\n@@ -69,2 +90,0 @@\n- * <\/p>\n- *\n@@ -72,7 +91,10 @@\n- * These actions collectively simulate the JVM's execution of an {@code invokedynamic} instruction in the unlinked state. Running this\n- * code once should yield the same results as running the corresponding {@code invokedynamic} instruction. To model caching behavior,\n- * an INDY_x method's code can begin with getstatic, aaload, and if_acmpne instructions to load a static method handle value and return\n- * it if the value is non-null.\n- * <\/p>\n- *\n- * <h3>Example usage:<\/h3>\n+ * The net result of all of these actions is equivalent to the JVM's\n+ * execution of an {@code invokedynamic} instruction in the unlinked state.\n+ * Running this code once should produce the same results as running\n+ * the corresponding {@code invokedynamic} instruction.\n+ * In order to model the caching behavior, the code of an INDY_x\n+ * method is allowed to begin with getstatic, aaload, and if_acmpne\n+ * instructions which load a static method handle value and return it\n+ * if the value is non-null.\n+ * <p>\n+ * Example usage:\n@@ -80,10 +102,10 @@\n- * $ JAVA_HOME=(some recent OpenJDK 7 build)\n- * $ ant\n- * $ $JAVA_HOME\/bin\/java -cp build\/classes indify.Indify --overwrite --dest build\/testout build\/classes\/indify\/Example.class\n- * $ $JAVA_HOME\/bin\/java -cp build\/classes indify.Example\n- * MT = (java.lang.Object)java.lang.Object\n- * MH = adder(int,int)java.lang.Integer\n- * adder(1,2) = 3\n- * calling indy:  42\n- * $ $JAVA_HOME\/bin\/java -cp build\/testout indify.Example\n- * (same output as above)\n+$ JAVA_HOME=(some recent OpenJDK 7 build)\n+$ ant\n+$ $JAVA_HOME\/bin\/java -cp build\/classes indify.Indify --overwrite --dest build\/testout build\/classes\/indify\/Example.class\n+$ $JAVA_HOME\/bin\/java -cp build\/classes indify.Example\n+MT = (java.lang.Object)java.lang.Object\n+MH = adder(int,int)java.lang.Integer\n+adder(1,2) = 3\n+calling indy:  42\n+$ $JAVA_HOME\/bin\/java -cp build\/testout indify.Example\n+(same output as above)\n@@ -91,1 +113,0 @@\n- *\n@@ -94,2 +115,0 @@\n- * <\/p>\n- *\n@@ -98,1 +117,0 @@\n-\n@@ -350,1 +368,1 @@\n-        if (verbose)  System.err.println(\"reading \"+f);\n+        if (verbose)  System.err.println(\"reading \" + f);\n@@ -353,2 +371,2 @@\n-        ClassModel newClassModel = logic.transform();\n-        assert newClassModel != null;\n+        Boolean changed = logic.transform();\n+        System.err.println(\"Class file transformation: \" + changed);\n@@ -356,1 +374,1 @@\n-        writeNewClassFile(newClassModel);\n+        writeNewClassFile(logic.classModel, changed, f);\n@@ -359,1 +377,1 @@\n-    void writeNewClassFile(ClassModel newClassModel) throws IOException {\n+    void writeNewClassFile(ClassModel newClassModel, Boolean changed, File sourceFile) throws IOException {\n@@ -361,5 +379,12 @@\n-        File destFile = classPathFile(dest, newClassModel.thisClass().name().stringValue());\n-        ensureDirectory(destFile.getParentFile());\n-        if (verbose)  System.err.println(\"writing \"+destFile);\n-        Files.write(destFile.toPath(), new_bytes);\n-        System.err.println(\"Wrote New ClassFile to: \"+destFile);\n+        if(changed || all){\n+            File destFile;\n+            if(dest != null){\n+                ensureDirectory(dest);\n+                destFile = classPathFile(dest, newClassModel.thisClass().name().stringValue());\n+            } else {\n+                destFile = sourceFile;\n+            }\n+            if (verbose) System.err.println(\"writing \"+destFile);\n+            Files.write(destFile.toPath(), new_bytes);\n+            System.err.println(\"Wrote New ClassFile to: \"+destFile);\n+        }\n@@ -369,1 +394,1 @@\n-        return of(StackMapsOption.GENERATE_STACK_MAPS).transform(classModel, ClassTransform.ACCEPT_ALL);\n+        return of().transform(classModel, ClassTransform.ACCEPT_ALL);\n@@ -420,1 +445,2 @@\n-                    throw (RuntimeException) ex;\n+                    if (ex instanceof RuntimeException)  throw (RuntimeException) ex;\n+                    throw new RuntimeException(ex);\n@@ -451,2 +477,2 @@\n-            ClassModel newClassModel = logic.transform();\n-            if(newClassModel == null)  throw new IOException(\"No transformation has been done\");\n+            Boolean changed = logic.transform();\n+            if (verbose && changed) System.err.println(\"(no change)\");\n@@ -454,2 +480,1 @@\n-            byte[] new_Bytes = transformToBytes(newClassModel);\n-            System.err.println(\"Transformed bytes: \" + new_Bytes.length);\n+            byte[] new_Bytes = transformToBytes(logic.classModel);\n@@ -465,2 +490,1 @@\n-        final Map<MethodModel, PoolEntry> constants = new HashMap<>();\n-        final Map<MethodModel, String> indySignatures = new HashMap<>();\n+        final Map<String, PoolEntry> constants = new HashMap<>();\n@@ -473,3 +497,3 @@\n-        ClassModel transform(){\n-            if (!initializeMarks())  return null;\n-            if (!findPatternMethods()) return null;\n+        Boolean transform(){\n+            if (!initializeMarks())  return false;\n+            if (!findPatternMethods()) return false;\n@@ -477,1 +501,0 @@\n-            ClassModel newClassModel = transformFromCPBuilder(classModel, poolBuilder);\n@@ -482,1 +505,1 @@\n-                if(constants.containsKey(m)) continue;  \/\/skip if pattern method, it will be removed\n+                if(constants.containsKey(m.methodName().stringValue())) continue;  \/\/skip if pattern method, it will be removed\n@@ -486,3 +509,1 @@\n-                List<Instruction> instructionList = getInstructions(m);\n-                ListIterator<Instruction> iterator =instructionList.listIterator();\n-                final Stack<Boolean> shouldProceed = new Stack<>();\n+                final Stack<Boolean> shouldProceedAfterIndyAdded = new Stack<>();\n@@ -490,3 +511,2 @@\n-                while (iterator.hasNext()){\n-                    shouldProceed.push(true);\n-                    Instruction i = iterator.next();\n+                for (Instruction i : getInstructions(m)){\n+                    shouldProceedAfterIndyAdded.push(true);\n@@ -495,2 +515,2 @@\n-                    int methi = ((InvokeInstruction) i).method().index();\n-                    if (poolMarks[methi] == 0) continue;    \/\/Skip if marked as a pattern Method\n+                    int methodIndex = ((InvokeInstruction) i).method().index();\n+                    if (poolMarks[methodIndex] == 0) continue;    \/\/Skip if not marked\n@@ -498,1 +518,1 @@\n-                    MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(methi);\n+                    MemberRefEntry ref = (MemberRefEntry) poolBuilder.entryByIndex(methodIndex);\n@@ -502,1 +522,1 @@\n-                    MethodModel conm = null;\n+                    MethodModel patternMethod = null;\n@@ -505,1 +525,1 @@\n-                            conm = mm;\n+                            patternMethod = mm;\n@@ -508,16 +528,1 @@\n-                    if(conm == null) continue;\n-\n-                    PoolEntry con = constants.get(conm);\n-                    if(quiet){\n-                        System.out.println();\n-                        System.err.println(\"$$$$$$$$$$$$$$$----------------------------------------------------------------Patching Method: \" +  m.methodName() + \"------------------------------------------------------------------\");\n-                    }\n-\n-                    if(con instanceof InvokeDynamicEntry){\n-                        Instruction i2 = findPop(instructionList, iterator.previousIndex());\n-                        int ref2i;\n-                        MethodRefEntry methodEntry = null;\n-\n-                        if(i2 != null && i2.opcode().bytecode() == INVOKEVIRTUAL && poolMarks[ref2i = ((InvokeInstruction) i2).method().index()] == 'D'){\n-                            methodEntry = (MethodRefEntry) newClassModel.constantPool().entryByIndex(ref2i);\n-                        }\n+                    if(patternMethod == null) continue;\n@@ -525,4 +530,1 @@\n-                        if(methodEntry == null || !\"invokeExact\".equals(methodEntry.nameAndType().name().stringValue())){\n-                            System.err.println(m+\": Failed to create invokedynamic at \"+i.opcode().bytecode());\n-                            continue;\n-                        }\n+                    PoolEntry newConstant = constants.get(patternMethod.methodName().stringValue());\n@@ -530,5 +532,3 @@\n-                        String invType = methodEntry.type().stringValue();\n-                        String bsmType = indySignatures.get(conm);\n-                        if (!invType.equals(bsmType)) {\n-                            System.err.println(m+\": warning: \"+conm+\" call type and local invoke type differ: \" + bsmType+\", \" + invType);\n-                        }\n+                    if(newConstant instanceof InvokeDynamicEntry){\n+                        if (!quiet) System.err.println(\":::Transforming the Method: \"+ m.methodName() +\" instruction: \" + i + \" invokedynamic: \" + newConstant.index() );\n+                        MethodModel finalPatternMethod = patternMethod;\n@@ -536,4 +536,0 @@\n-                        assert (i.sizeInBytes() == 3 || i2.sizeInBytes() == 3);\n-                        System.err.println(\"----------------------------------------------------------------Transforming Method INDY Instructions & Creating New ClassModels------------------------------------------------------------------}}}\");\n-                        if (!quiet) System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: \" + i + \" invokedynamic: \" + con.index() );\n-                        MethodModel finalConm = conm;\n@@ -544,1 +540,1 @@\n-                                a2 = finalConm.methodName().stringValue();\n+                                a2 = finalPatternMethod.methodName().stringValue();\n@@ -546,11 +542,14 @@\n-                            if (e instanceof InvokeInstruction && Objects.equals(a1, a2)) {\n-                                System.err.println(\">> Removing instruction invokestatic for Method: \" + ((InvokeInstruction) e).name());\n-                                b.andThen(b);\n-                            } else if (shouldProceed.peek() && e instanceof InvokeInstruction && ((InvokeInstruction) e).method().equals(((InvokeInstruction) i2).method())) {\n-                                System.err.println(\">> Removing instruction invokevirtual for Method: \" + ((InvokeInstruction) e).name());\n-                                b.andThen(b);\n-                                System.out.println(\">> Adding invokedynamic instruction and nop instead of invoke virtual: \" + ((InvokeDynamicEntry) con).name());\n-                                b.invokeDynamicInstruction((InvokeDynamicEntry) con).nop();\n-\n-                                shouldProceed.pop();\n-                                shouldProceed.push(false);\n+                            if (e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)) {\n+                                System.err.println(\">> Removing instruction invokestatic for Method: \" + invokeInstruction.name());\n+                            }\n+                            else if (\n+                                    shouldProceedAfterIndyAdded.peek() &&\n+                                    e instanceof InvokeInstruction invokeInstruction &&\n+                                    invokeInstruction.method().name().stringValue().equals(\"invokeExact\"))\n+                            {\n+                                System.err.println(\">> Removing instruction invokevirtual for Method: \" + invokeInstruction.method());\n+                                System.err.println(\">> Adding invokedynamic instruction and nop instead of invoke virtual: \" + ((InvokeDynamicEntry) newConstant).name());\n+                                b.invokeDynamicInstruction((InvokeDynamicEntry) newConstant).nop();\n+\n+                                shouldProceedAfterIndyAdded.pop();\n+                                shouldProceedAfterIndyAdded.push(false);\n@@ -563,2 +562,2 @@\n-                        newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n-                               of(StackMapsOption.GENERATE_STACK_MAPS).transform(newClassModel, classTransform)\n+                        classModel = of().parse(\n+                               of().transform(classModel, classTransform)\n@@ -566,2 +565,0 @@\n-\n-                        System.out.println();\n@@ -570,2 +567,1 @@\n-                        System.err.println(\"----------------------------------------------------------------Transforming Method LDC Instructions & Creating New ClassModels------------------------------------------------------------------}}}\");\n-                        MethodModel finalConm = conm;\n+                        MethodModel finalConm = patternMethod;\n@@ -574,2 +570,2 @@\n-                            if(e instanceof InvokeInstruction){\n-                                a1 = ((InvokeInstruction) e).method().name().stringValue();\n+                            if(e instanceof InvokeInstruction invokeInstruction){\n+                                a1 = invokeInstruction.method().name().stringValue();\n@@ -578,3 +574,3 @@\n-                            if(e instanceof InvokeInstruction && Objects.equals(a1, a2)){\n-                                System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: invokestatic \" + ((InvokeInstruction) e).type() + \" to ldc: \" +  con.index() );\n-                                b.constantInstruction(Opcode.LDC_W,  ((LoadableConstantEntry) con).constantValue());\n+                            if(e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)){\n+                                System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: invokestatic \" + invokeInstruction.type() + \" to ldc: \" +  newConstant.index() );\n+                                b.ldc((LoadableConstantEntry) newConstant);\n@@ -584,2 +580,2 @@\n-                        newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n-                             of(StackMapsOption.GENERATE_STACK_MAPS).transform(newClassModel, classTransform));\n+                        classModel = of().parse(\n+                             of().transform(classModel, classTransform));\n@@ -587,1 +583,1 @@\n-                    shouldProceed.pop();\n+                    shouldProceedAfterIndyAdded.clear();\n@@ -590,1 +586,1 @@\n-            newClassModel = removePatternMethodsAndVerify(newClassModel);\n+            this.classModel = removePatternMethodsAndVerify(classModel);\n@@ -592,1 +588,1 @@\n-            return newClassModel;\n+            return true;\n@@ -597,2 +593,2 @@\n-            ClassModel newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n-                    of(StackMapsOption.GENERATE_STACK_MAPS).transform(classModel, (b, e) ->\n+            ClassModel newClassModel = of().parse(\n+                    of().transform(classModel, (b, e) ->\n@@ -608,1 +604,0 @@\n-            ClassHierarchyResolver classHierarchyResolver = classDesc -> ClassHierarchyResolver.ClassHierarchyInfo.ofInterface();\n@@ -611,1 +606,1 @@\n-                List<VerifyError> errors = of(StackMapsOption.GENERATE_STACK_MAPS,ClassHierarchyResolverOption.of(classHierarchyResolver)).verify(newClassModel);\n+                List<VerifyError> errors = of().verify(newClassModel);\n@@ -624,47 +619,1 @@\n-        Instruction findPop( List<Instruction> instructionList, int currentIndex){\n-            JVMState jvm = new JVMState();\n-\n-            ListIterator<Instruction> newIter = instructionList.listIterator(currentIndex + 1);\n-        decode:\n-            while (newIter.hasNext()) {\n-                Instruction i = newIter.next();\n-                String pops = INSTRUCTION_POPS[i.opcode().bytecode()];\n-\n-                if(pops == null) break;\n-                if (jvm.stackMotion(i.opcode().bytecode()))  continue;\n-                if (pops.indexOf('Q') >= 0 && i instanceof InvokeInstruction in) {\n-                    MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(in.method().index());\n-                    String methType = ref.nameAndType().type().stringValue();\n-                    String type = simplifyType(methType);\n-\n-                    pops = switch (i.opcode().bytecode()) {\n-                        case GETSTATIC, GETFIELD, PUTSTATIC, PUTFIELD -> pops.replace(\"Q\", type);\n-                        default -> {\n-                            if (!type.startsWith(\"(\"))\n-                                throw new InternalError(i.toString());\n-                            yield pops.replace(\"Q$Q\", type.substring(1).replace(\")\", \"$\"));\n-                        }\n-                    };\n-                    System.out.println(\"special type: \"+type+\" => \"+pops);\n-                }\n-                int npops = pops.indexOf('$');\n-                if (npops < 0)  throw new InternalError();\n-                if (npops > jvm.sp())  return i;\n-                List<Object> args = jvm.args(npops);\n-                int k = 0;\n-                for (Object x : args) {\n-                    char have = (Character) x;\n-                    char want = pops.charAt(k++);\n-                    if (have == 'X' || want == 'X')  continue;\n-                    if (have != want)  break decode;\n-                }\n-                if (pops.charAt(k++) != '$')  break;\n-                args.clear();\n-                while (k < pops.length())\n-                    args.add(pops.charAt(k++));\n-            }\n-            System.err.println(\"*** bailout on jvm: \"+jvm.stack);\n-            return null;\n-        }\n-\n-         boolean findPatternMethods() {\n+        boolean findPatternMethods() {\n@@ -676,1 +625,1 @@\n-                    if(nameAndTypeMark(m.methodName().index(), m.methodType().index()) == mark) {\n+                    if(nameAndTypeMark(m.methodName(), m.methodType()) == mark) {\n@@ -679,1 +628,1 @@\n-                        constants.put(m, entry);\n+                        constants.put(m.methodName().stringValue(), entry);\n@@ -687,76 +636,0 @@\n-        ClassModel transformFromCPBuilder(ClassModel oldClassModel, ConstantPoolBuilder cpBuilder){\n-            byte[] new_bytes = of(StackMapsOption.GENERATE_STACK_MAPS).transform(oldClassModel, ClassTransform.endHandler(clb -> {\n-                for (PoolEntry entry: cpBuilder) {\n-                    if (entry instanceof Utf8Entry utf8Entry) {\n-                        clb.constantPool().utf8Entry(utf8Entry.stringValue());\n-                        continue;\n-                    }\n-                    if (entry instanceof NameAndTypeEntry nameAndTypeEntry) {\n-                        clb.constantPool().nameAndTypeEntry(nameAndTypeEntry.name(), nameAndTypeEntry.type());\n-                        continue;\n-                    }\n-                    if (entry instanceof MethodTypeEntry methodTypeEntry) {\n-                        clb.constantPool().methodTypeEntry(methodTypeEntry.descriptor());\n-                        continue;\n-                    }\n-                    if (entry instanceof MethodHandleEntry methodHandleEntry) {\n-                        clb.constantPool().methodHandleEntry(methodHandleEntry.kind(), methodHandleEntry.reference());\n-                        continue;\n-                    }\n-                    if (entry instanceof MethodRefEntry methodRefEntry) {\n-                        clb.constantPool().methodRefEntry(methodRefEntry.owner(), methodRefEntry.nameAndType());\n-                        continue;\n-                    }\n-                    if (entry instanceof FieldRefEntry fieldRefEntry) {\n-                        clb.constantPool().fieldRefEntry(fieldRefEntry.owner(), fieldRefEntry.nameAndType());\n-                        continue;\n-                    }\n-                    if (entry instanceof ClassEntry classEntry) {\n-                        clb.constantPool().classEntry(classEntry.name());\n-                        continue;\n-                    }\n-                    if (entry instanceof StringEntry stringEntry) {\n-                        clb.constantPool().stringEntry(stringEntry.utf8());\n-                        continue;\n-                    }\n-                    if (entry instanceof IntegerEntry integerEntry) {\n-                        clb.constantPool().intEntry(integerEntry.intValue());\n-                        continue;\n-                    }\n-                    if (entry instanceof FloatEntry floatEntry) {\n-                        clb.constantPool().floatEntry(floatEntry.floatValue());\n-                        continue;\n-                    }\n-                    if (entry instanceof LongEntry longEntry) {\n-                        clb.constantPool().longEntry(longEntry.longValue());\n-                        continue;\n-                    }\n-                    if (entry instanceof DoubleEntry doubleEntry) {\n-                        clb.constantPool().doubleEntry(doubleEntry.doubleValue());\n-                        continue;\n-                    }\n-                    if (entry instanceof InterfaceMethodRefEntry interfaceMethodRefEntry) {\n-                        clb.constantPool().interfaceMethodRefEntry(interfaceMethodRefEntry.owner(), interfaceMethodRefEntry.nameAndType());\n-                        continue;\n-                    }\n-                    if (entry instanceof InvokeDynamicEntry invokeDynamicEntry) {\n-                        clb.constantPool().invokeDynamicEntry(invokeDynamicEntry.bootstrap(), invokeDynamicEntry.nameAndType());\n-                        continue;\n-                    }\n-                    if (entry instanceof ModuleEntry moduleEntry) {\n-                        clb.constantPool().moduleEntry(moduleEntry.name());\n-                        continue;\n-                    }\n-                    if (entry instanceof PackageEntry packageEntry) {\n-                        clb.constantPool().packageEntry(packageEntry.name());\n-                    }\n-                }\n-\n-                for (int i = 0; i < cpBuilder.bootstrapMethodCount(); i++) {\n-                    clb.constantPool().bsmEntry(cpBuilder.bootstrapMethodEntry(i).bootstrapMethod(), cpBuilder.bootstrapMethodEntry(i).arguments());\n-                }\n-            }));\n-\n-            return of(StackMapsOption.GENERATE_STACK_MAPS).parse(new_bytes);\n-        }\n-\n@@ -768,1 +641,1 @@\n-                        constants.get(m) == null) {\n+                        constants.get(m.methodName().stringValue()) == null) {\n@@ -807,5 +680,3 @@\n-                    switch (poolEntry.tag()) {\n-                        case TAG_UTF8:\n-                            mark = nameMark(((Utf8Entry) poolEntry).stringValue());\n-                            break;\n-                        case TAG_NAMEANDTYPE:\n+                    mark = switch (poolEntry.tag()) {\n+                        case TAG_UTF8 -> nameMark(((Utf8Entry) poolEntry).stringValue());\n+                        case TAG_NAMEANDTYPE -> {\n@@ -813,5 +684,3 @@\n-                            int ref1 = nameAndTypeEntry.name().index();\n-                            int ref2 = nameAndTypeEntry.type().index();\n-                            mark = nameAndTypeMark(ref1, ref2);\n-                            break;\n-                        case TAG_CLASS: {\n+                            yield nameAndTypeMark(nameAndTypeEntry.name(), nameAndTypeEntry.type());\n+                        }\n+                        case TAG_CLASS -> {\n@@ -821,1 +690,3 @@\n-                                mark = nameMark;\n+                                yield nameMark;\n+                            } else {\n+                                yield mark;\n@@ -823,1 +694,0 @@\n-                            break;\n@@ -825,2 +695,1 @@\n-                        case TAG_FIELDREF:\n-                        case TAG_METHODREF: {\n+                        case TAG_FIELDREF, TAG_METHODREF -> {\n@@ -832,10 +701,11 @@\n-                                mark = classMark;  \/\/ java.lang.invoke.* or java.lang.* method\n-                                break;\n-                            }\n-                            String cls = (classModel.constantPool().entryByIndex(classIndex) instanceof ClassEntry) ?\n-                                    ((ClassEntry) classModel.constantPool().entryByIndex(classIndex)).name().stringValue() : \"\";\n-                            if (cls.equals(classModel.thisClass().name().stringValue())) {\n-                                mark = switch (poolMarks[nameAndTypeIndex]) {\n-                                    case 'T', 'H', 'I' -> poolMarks[nameAndTypeIndex];\n-                                    default -> mark;\n-                                };\n+                                yield classMark;  \/\/ java.lang.invoke.* or java.lang.* method\n+                            } else {\n+                                String cls = memberRefEntry.owner().name().stringValue();\n+                                if (cls.equals(classModel.thisClass().name().stringValue())) {\n+                                    yield switch (poolMarks[nameAndTypeIndex]) {\n+                                        case 'T', 'H', 'I' -> poolMarks[nameAndTypeIndex];\n+                                        default -> mark;\n+                                    };\n+                                } else {\n+                                    yield mark;\n+                                }\n@@ -843,1 +713,0 @@\n-                            break;\n@@ -845,3 +714,2 @@\n-                        default:\n-                            break;\n-                    }\n+                        default -> mark;\n+                    };\n@@ -871,2 +739,2 @@\n-        char nameAndTypeMark(int ref1, int ref2){\n-            char mark = poolMarks[ref1];\n+        char nameAndTypeMark(Utf8Entry name, Utf8Entry type){\n+            char mark = poolMarks[name.index()];\n@@ -874,1 +742,1 @@\n-            String descriptor = (classModel.constantPool().entryByIndex(ref2) instanceof Utf8Entry) ? ((Utf8Entry) classModel.constantPool().entryByIndex(ref2)).stringValue() : \"\";\n+            String descriptor = type.stringValue();\n@@ -876,1 +744,1 @@\n-            switch (poolMarks[ref1]){\n+            switch (mark){\n@@ -1079,18 +947,2 @@\n-                                        if (argClass.isPrimitive()) {\n-                                            char tchar = switch (argClass.getName()) {\n-                                                case \"void\" -> 'V';\n-                                                case \"boolean\" -> 'Z';\n-                                                case \"byte\" -> 'B';\n-                                                case \"char\" -> 'C';\n-                                                case \"short\" -> 'S';\n-                                                case \"int\" -> 'I';\n-                                                case \"long\" -> 'J';\n-                                                case \"float\" -> 'F';\n-                                                case \"double\" -> 'D';\n-                                                default -> throw new InternalError(argClass.toString());\n-                                            };\n-                                            buf.append(tchar);\n-                                        } else {\n-                                            buf.append('L').append(argClass.getName().replace('.','\/')).append(';');\n-                                        }\n-                                    } else if (typeArg instanceof PoolEntry argCon) {\n+                                        buf.append(argClass.descriptorString());\n+                                    }else if (typeArg instanceof PoolEntry argCon) {\n@@ -1162,1 +1014,1 @@\n-                            con = constants.get(ownMethod);\n+                            con = constants.get(ownMethod.methodName().stringValue());\n@@ -1179,2 +1031,0 @@\n-                                PoolEntry typeCon = (PoolEntry) bsmArgs.get(3);\n-                                indySignatures.put(method, ((MethodTypeEntry) typeCon).descriptor().stringValue());\n@@ -1182,0 +1032,2 @@\n+                            }else {\n+                                System.err.println(\"Failed to create invokedynamic instruction for the method: \" + method.methodName());\n@@ -1195,2 +1047,3 @@\n-                        if (bc >= ICONST_M1 && bc <= DCONST_1)\n-                        { jvm.push(INSTRUCTION_CONSTANTS[bc - ICONST_M1]); break; }\n+                        if (bc >= ICONST_M1 && bc <= DCONST_1) {\n+                            jvm.push(instruction.opcode().constantValue()); break;\n+                        }\n@@ -1239,6 +1092,2 @@\n-            Utf8Entry utf8Entry;\n-\n-            if (x instanceof String) {\n-                utf8Entry = poolBuilder.utf8Entry((String) x);\n-            } else if (x instanceof PoolEntry && ((PoolEntry) x).tag() == TAG_STRING) {\n-                utf8Entry = ((StringEntry) x).utf8();\n+           if (x instanceof StringEntry stringEntry){\n+                return poolBuilder.methodTypeEntry(stringEntry.utf8());\n@@ -1246,2 +1095,1 @@\n-                return null;\n-            }\n+               return poolBuilder.methodTypeEntry(poolBuilder.utf8Entry((String) x));\n@@ -1249,1 +1097,1 @@\n-            return poolBuilder.methodTypeEntry(utf8Entry);\n+            }\n@@ -1255,2 +1103,0 @@\n-            int argi = 0;\n-            if(!\"lookup\".equals(args.get(argi++))) return null;\n@@ -1258,1 +1104,1 @@\n-            NameAndTypeEntry nt;\n+            NameAndTypeEntry nameAndTypeEntry;\n@@ -1260,2 +1106,1 @@\n-            ClassEntry cl;\n-            Object con;\n+            ClassEntry ownerClass;\n@@ -1263,2 +1108,1 @@\n-            if(!((con = args.get(argi++)) instanceof ClassEntry)) return null;\n-            cl = (ClassEntry) con;\n+            if(!\"lookup\".equals(args.getFirst())) return null;\n@@ -1266,2 +1110,5 @@\n-            if(!((con = args.get(argi++)) instanceof StringEntry)) return null;\n-            name = ((StringEntry) con).utf8();\n+            if(args.get(1) instanceof ClassEntry classEntry) ownerClass = classEntry;\n+            else return null;\n+\n+            if(args.get(2) instanceof StringEntry stringEntry) name = stringEntry.utf8();\n+            else return null;\n@@ -1269,4 +1116,2 @@\n-            if(((con = args.get(argi)) instanceof MethodTypeEntry) || (con instanceof ClassEntry)){\n-                assert con instanceof MethodTypeEntry;\n-                type = ((MethodTypeEntry) con).descriptor();\n-            } else return null;\n+            if(args.get(3) instanceof MethodTypeEntry methodTypeEntry) type = methodTypeEntry.descriptor();\n+            else return null;\n@@ -1274,1 +1119,1 @@\n-            nt = poolBuilder.nameAndTypeEntry(name,type);\n+            nameAndTypeEntry = poolBuilder.nameAndTypeEntry(name,type);\n@@ -1278,1 +1123,1 @@\n-                 ref = poolBuilder.fieldRefEntry(cl, nt);\n+                 ref = poolBuilder.fieldRefEntry(ownerClass, nameAndTypeEntry);\n@@ -1282,1 +1127,1 @@\n-                ref = poolBuilder.interfaceMethodRefEntry(cl, nt);\n+                ref = poolBuilder.interfaceMethodRefEntry(ownerClass, nameAndTypeEntry);\n@@ -1286,1 +1131,1 @@\n-                ref = poolBuilder.methodRefEntry(cl, nt);\n+                ref = poolBuilder.methodRefEntry(ownerClass, nameAndTypeEntry);\n@@ -1298,2 +1143,2 @@\n-            NameAndTypeEntry nt;\n-            MethodHandleEntry bsm;\n+            NameAndTypeEntry nameAndTypeEntry;\n+            MethodHandleEntry bootstrapMethod;\n@@ -1302,1 +1147,1 @@\n-            bsm = ((MethodHandleEntry) con);\n+            bootstrapMethod = ((MethodHandleEntry) con);\n@@ -1311,1 +1156,1 @@\n-            nt = poolBuilder.nameAndTypeEntry(name, type);\n+            nameAndTypeEntry = poolBuilder.nameAndTypeEntry(name, type);\n@@ -1326,1 +1171,1 @@\n-            List<LoadableConstantEntry> extraArgConstants = new ArrayList<>();\n+            List<ConstantDesc> extraArgConstantDescs = new ArrayList<>();\n@@ -1329,4 +1174,2 @@\n-                    if (x instanceof Integer) { x = poolBuilder.intEntry((Integer) x); }\n-                    if (x instanceof Float)   { x = poolBuilder.floatEntry((Float) x); }\n-                    if (x instanceof Long)    { x = poolBuilder.longEntry((Long) x); }\n-                    if (x instanceof Double)  { x = poolBuilder.doubleEntry((Double) x); }\n+                    extraArgConstantDescs.add(((ConstantDesc) x));\n+                    continue;\n@@ -1339,16 +1182,1 @@\n-                extraArgConstants.add(((LoadableConstantEntry) x));\n-            }\n-\n-            List<Object[]> specs = bootstrap_MethodSpecifiers();\n-            int specIndex = -1;\n-            Object[] spec = new Object[]{ bsm.index(), extraArgConstants };\n-            for (Object[] spec1 : specs) {\n-                if (Arrays.equals(spec1, spec)) {\n-                    specIndex = specs.indexOf(spec1);\n-                    if (verbose)  System.err.println(\"reusing BSM specifier: \"+spec1[0]+spec1[1]);\n-                    break;\n-                }\n-            }\n-            if (specIndex == -1) {\n-                specs.add(spec);\n-                if (verbose)  System.err.println(\"adding BSM specifier: \"+spec[0]+spec[1]);\n+                extraArgConstantDescs.add((((LoadableConstantEntry) x).constantValue()));\n@@ -1357,18 +1185,2 @@\n-            BootstrapMethodEntry bsmEntry = poolBuilder.bsmEntry(bsm, extraArgConstants);\n-            return poolBuilder.invokeDynamicEntry(bsmEntry, nt);\n-        }\n-\n-        List<Object[]> bootstrap_MethodSpecifiers() {\n-            List<Object[]> specs = new ArrayList<>();\n-            int count = classModel.constantPool().bootstrapMethodCount();\n-            if (count == 0){\n-                poolBuilder.utf8Entry(\"BootstrapMethods\");\n-                return specs;\n-            }\n-\n-            for (int i = 0; i < count; i++) {\n-                int bsmRef = classModel.constantPool().bootstrapMethodEntry(i).bsmIndex();\n-                List<LoadableConstantEntry> bsmArgs = new ArrayList<>(classModel.constantPool().bootstrapMethodEntry(i).arguments());\n-                specs.add(new Object[]{ bsmRef, bsmArgs});\n-            }\n-            return specs;\n+            BootstrapMethodEntry bsmEntry = poolBuilder.bsmEntry(bootstrapMethod.asSymbol(), extraArgConstantDescs);\n+            return poolBuilder.invokeDynamicEntry(bsmEntry, nameAndTypeEntry);\n@@ -1390,5 +1202,0 @@\n-        ClassHierarchyResolver classHierarchyResolver = classDesc -> {\n-            \/\/ Treat all classes as interfaces\n-            return ClassHierarchyResolver.ClassHierarchyInfo.ofInterface();\n-        };\n-\n@@ -1396,1 +1203,1 @@\n-            List<VerifyError> errors = of(ClassHierarchyResolverOption.of(classHierarchyResolver)).verify(bytes);\n+            List<VerifyError> errors = of().verify(bytes);\n@@ -1410,92 +1217,0 @@\n-    private static final Object[] INSTRUCTION_CONSTANTS = {\n-        -1, 0, 1, 2, 3, 4, 5, 0L, 1L, 0.0F, 1.0F, 2.0F, 0.0D, 1.0D\n-    };\n-\n-    private static final String INSTRUCTION_FORMATS =\n-        \"nop$ aconst_null$L iconst_m1$I iconst_0$I iconst_1$I \"+\n-        \"iconst_2$I iconst_3$I iconst_4$I iconst_5$I lconst_0$J_ \"+\n-        \"lconst_1$J_ fconst_0$F fconst_1$F fconst_2$F dconst_0$D_ \"+\n-        \"dconst_1$D_ bipush=bx$I sipush=bxx$I ldc=bk$X ldc_w=bkk$X \"+\n-        \"ldc2_w=bkk$X_ iload=bl\/wbll$I lload=bl\/wbll$J_ fload=bl\/wbll$F \"+\n-        \"dload=bl\/wbll$D_ aload=bl\/wbll$L iload_0$I iload_1$I \"+\n-        \"iload_2$I iload_3$I lload_0$J_ lload_1$J_ lload_2$J_ \"+\n-        \"lload_3$J_ fload_0$F fload_1$F fload_2$F fload_3$F dload_0$D_ \"+\n-        \"dload_1$D_ dload_2$D_ dload_3$D_ aload_0$L aload_1$L \"+\n-        \"aload_2$L aload_3$L iaload$LI$I laload$LI$J_ faload$LI$F \"+\n-        \"daload$LI$D_ aaload$LI$L baload$LI$I caload$LI$I saload$LI$I \"+\n-        \"istore=bl\/wbll$I$ lstore=bl\/wbll$J_$ fstore=bl\/wbll$F$ \"+\n-        \"dstore=bl\/wbll$D_$ astore=bl\/wbll$L$ istore_0$I$ istore_1$I$ \"+\n-        \"istore_2$I$ istore_3$I$ lstore_0$J_$ lstore_1$J_$ \"+\n-        \"lstore_2$J_$ lstore_3$J_$ fstore_0$F$ fstore_1$F$ fstore_2$F$ \"+\n-        \"fstore_3$F$ dstore_0$D_$ dstore_1$D_$ dstore_2$D_$ \"+\n-        \"dstore_3$D_$ astore_0$L$ astore_1$L$ astore_2$L$ astore_3$L$ \"+\n-        \"iastore$LII$ lastore$LIJ_$ fastore$LIF$ dastore$LID_$ \"+\n-        \"aastore$LIL$ bastore$LII$ castore$LII$ sastore$LII$ pop$X$ \"+\n-        \"pop2$XX$ dup$X$XX dup_x1$XX$XXX dup_x2$XXX$XXXX dup2$XX$XXXX \"+\n-        \"dup2_x1$XXX$XXXXX dup2_x2$XXXX$XXXXXX swap$XX$XX \"+\n-        \"iadd$II$I ladd$J_J_$J_ fadd$FF$F dadd$D_D_$D_ isub$II$I \"+\n-        \"lsub$J_J_$J_ fsub$FF$F dsub$D_D_$D_ imul$II$I lmul$J_J_$J_ \"+\n-        \"fmul$FF$F dmul$D_D_$D_ idiv$II$I ldiv$J_J_$J_ fdiv$FF$F \"+\n-        \"ddiv$D_D_$D_ irem$II$I lrem$J_J_$J_ frem$FF$F drem$D_D_$D_ \"+\n-        \"ineg$I$I lneg$J_$J_ fneg$F$F dneg$D_$D_ ishl$II$I lshl$J_I$J_ \"+\n-        \"ishr$II$I lshr$J_I$J_ iushr$II$I lushr$J_I$J_ iand$II$I \"+\n-        \"land$J_J_$J_ ior$II$I lor$J_J_$J_ ixor$II$I lxor$J_J_$J_ \"+\n-        \"iinc=blx\/wbllxx$ i2l$I$J_ i2f$I$F i2d$I$D_ l2i$J_$I l2f$J_$F \"+\n-        \"l2d$J_$D_ f2i$F$I f2l$F$J_ f2d$F$D_ d2i$D_$I d2l$D_$J_ \"+\n-        \"d2f$D_$F i2b$I$I i2c$I$I i2s$I$I lcmp fcmpl fcmpg dcmpl dcmpg \"+\n-        \"ifeq=boo ifne=boo iflt=boo ifge=boo ifgt=boo ifle=boo \"+\n-        \"if_icmpeq=boo if_icmpne=boo if_icmplt=boo if_icmpge=boo \"+\n-        \"if_icmpgt=boo if_icmple=boo if_acmpeq=boo if_acmpne=boo \"+\n-        \"goto=boo jsr=boo ret=bl\/wbll tableswitch=* lookupswitch=* \"+\n-        \"ireturn lreturn freturn dreturn areturn return \"+\n-        \"getstatic=bkf$Q putstatic=bkf$Q$ getfield=bkf$L$Q \"+\n-        \"putfield=bkf$LQ$ invokevirtual=bkm$LQ$Q \"+\n-        \"invokespecial=bkm$LQ$Q invokestatic=bkm$Q$Q \"+\n-        \"invokeinterface=bkixx$LQ$Q invokedynamic=bkd__$Q$Q new=bkc$L \"+\n-        \"newarray=bx$I$L anewarray=bkc$I$L arraylength$L$I athrow \"+\n-        \"checkcast=bkc$L$L instanceof=bkc$L$I monitorenter$L \"+\n-        \"monitorexit$L wide=* multianewarray=bkcx ifnull=boo \"+\n-        \"ifnonnull=boo goto_w=boooo jsr_w=boooo \";\n-    private static final String[] INSTRUCTION_POPS;\n-    static {\n-        String[] insns = INSTRUCTION_FORMATS.split(\" \");\n-        assert(insns[LOOKUPSWITCH].startsWith(\"lookupswitch\"));\n-        assert(insns[TABLESWITCH].startsWith(\"tableswitch\"));\n-        assert(insns[WIDE].startsWith(\"wide\"));\n-        assert(insns[INVOKEDYNAMIC].startsWith(\"invokedynamic\"));\n-        int[] info = new int[256];\n-        String[] names = new String[256];\n-        String[] pops = new String[256];\n-        for (int i = 0; i < insns.length; i++) {\n-            String insn = insns[i];\n-            int dl = insn.indexOf('$');\n-            if (dl > 0) {\n-                String p = insn.substring(dl+1);\n-                if (p.indexOf('$') < 0)  p = \"$\" + p;\n-                pops[i] = p;\n-                insn = insn.substring(0, dl);\n-            }\n-            int eq = insn.indexOf('=');\n-            if (eq < 0) {\n-                info[i] = 1;\n-                names[i] = insn;\n-                continue;\n-            }\n-            names[i] = insn.substring(0, eq);\n-            String fmt = insn.substring(eq+1);\n-            if (fmt.equals(\"*\")) {\n-                info[i] = 0;\n-                continue;\n-            }\n-            int sl = fmt.indexOf('\/');\n-            if (sl < 0) {\n-                info[i] = (char) fmt.length();\n-            } else {\n-                String wfmt = fmt.substring(sl+1);\n-                fmt = fmt.substring(0, sl);\n-                info[i] = (char)( fmt.length() + (wfmt.length() * 16) );\n-            }\n-        }\n-        INSTRUCTION_POPS = pops;\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/indify\/Indify.java","additions":206,"deletions":491,"binary":false,"changes":697,"status":"modified"}]}