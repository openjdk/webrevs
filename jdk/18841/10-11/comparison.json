{"files":[{"patch":"@@ -295,1 +295,1 @@\n-                    quiet = booleanOption(a2);   \/\/ less output\n+                    quiet = booleanOption(a2);  \/\/ less output\n@@ -298,1 +298,1 @@\n-                    verbose = booleanOption(a2); \/\/ more output\n+                    verbose = booleanOption(a2);  \/\/ more output\n@@ -497,2 +497,2 @@\n-        Boolean transform(){\n-            if (!initializeMarks())  return false;\n+        Boolean transform() {\n+            if (!initializeMarks()) return false;\n@@ -501,2 +501,1 @@\n-            CodeTransform codeTransform;\n-            ClassTransform classTransform;\n+            Stack<PoolEntry> pendingIndy = new Stack<>(); \/\/ stack to hold the pending invokedynamic constant to replace the invokeExact\n@@ -504,2 +503,3 @@\n-            for(MethodModel m : classModel.methods()){\n-                if(constants.containsKey(m.methodName().stringValue())) continue;  \/\/skip if pattern method, it will be removed\n+            CodeTransform codeTransform = (b, e) -> {\n+                if (e instanceof InvokeInstruction invokeInstruction) {\n+                    String methodInvoked = invokeInstruction.method().name().stringValue();\n@@ -507,10 +507,7 @@\n-                Predicate<MethodModel> filter = method -> Objects.equals(method.methodName().stringValue(), m.methodName().stringValue());\n-\n-                final Stack<Boolean> shouldProceedAfterIndyAdded = new Stack<>();\n-\n-                for (Instruction i : getInstructions(m)){\n-                    shouldProceedAfterIndyAdded.push(true);\n-\n-                    if(i.opcode().bytecode() != INVOKESTATIC) continue;  \/\/this is not an invokestatic instruction\n-                    int methodIndex = ((InvokeInstruction) i).method().index();\n-                    if (poolMarks[methodIndex] == 0) continue;    \/\/Skip if not marked\n+                    if (invokeInstruction.opcode().bytecode() == INVOKEVIRTUAL &&\n+                            !pendingIndy.isEmpty() &&\n+                            methodInvoked.equals(\"invokeExact\")) {\n+                        b.invokeDynamicInstruction((InvokeDynamicEntry) pendingIndy.pop());\n+                        if (!quiet) System.err.println(\"Removing <<invokeExact>> invocation on MethodHandle\");\n+                        return;\n+                    }\n@@ -518,3 +515,4 @@\n-                    MemberRefEntry ref = (MemberRefEntry) poolBuilder.entryByIndex(methodIndex);\n-                    String methName = ref.nameAndType().name().stringValue();\n-                    String methType = ref.nameAndType().type().stringValue();\n+                    if (invokeInstruction.opcode().bytecode() != INVOKESTATIC) {\n+                        b.with(e); \/\/ Not an INVOKESTATIC instruction, keep it as is\n+                        return;\n+                    }\n@@ -522,5 +520,3 @@\n-                    MethodModel patternMethod = null;\n-                    for (MethodModel mm : classModel.methods()) {\n-                        if (mm.methodName().stringValue().equals(methName) && mm.methodType().stringValue().equals(methType)) {\n-                            patternMethod = mm;\n-                        }\n+                    if (poolMarks[invokeInstruction.method().index()] == 0) {\n+                        b.with(e); \/\/ Skip if not marked\n+                        return;\n@@ -528,1 +524,0 @@\n-                    if(patternMethod == null) continue;\n@@ -530,1 +525,5 @@\n-                    PoolEntry newConstant = constants.get(patternMethod.methodName().stringValue());\n+                    \/\/ Is it a pattern method?\n+                    if (!constants.containsKey(methodInvoked)) {\n+                        b.with(e);\n+                        return;\n+                    }\n@@ -532,3 +531,1 @@\n-                    if(newConstant instanceof InvokeDynamicEntry){\n-                        if (!quiet) System.err.println(\":::Transforming the Method: \"+ m.methodName() +\" instruction: \" + i + \" invokedynamic: \" + newConstant.index() );\n-                        MethodModel finalPatternMethod = patternMethod;\n+                    PoolEntry newConstant = constants.get(methodInvoked);\n@@ -536,25 +533,7 @@\n-                        codeTransform = (b, e) ->{\n-                            String a1 = null, a2 = null;\n-                            if(e instanceof InvokeInstruction){\n-                                a1 = ((InvokeInstruction) e).method().name().stringValue();\n-                                a2 = finalPatternMethod.methodName().stringValue();\n-                            }\n-                            if (e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)) {\n-                                System.err.println(\">> Removing instruction invokestatic for Method: \" + invokeInstruction.name());\n-                            }\n-                            else if (\n-                                    shouldProceedAfterIndyAdded.peek() &&\n-                                    e instanceof InvokeInstruction invokeInstruction &&\n-                                    invokeInstruction.method().name().stringValue().equals(\"invokeExact\"))\n-                            {\n-                                System.err.println(\">> Removing instruction invokevirtual for Method: \" + invokeInstruction.method());\n-                                System.err.println(\">> Adding invokedynamic instruction and nop instead of invoke virtual: \" + ((InvokeDynamicEntry) newConstant).name());\n-                                b.invokeDynamicInstruction((InvokeDynamicEntry) newConstant).nop();\n-\n-                                shouldProceedAfterIndyAdded.pop();\n-                                shouldProceedAfterIndyAdded.push(false);\n-                            } else {\n-                                b.with(e);\n-                            }\n-                        };\n-                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n+                    if (newConstant instanceof InvokeDynamicEntry) {\n+                        pendingIndy.push(newConstant);\n+                        if (!quiet) {\n+                            System.err.println(\":::Transforming the Method Class for: \" + ((InvokeInstruction) e).method().name() +\n+                                    \"  to => invokedynamic: \" +\n+                                    ((InvokeDynamicEntry) newConstant).nameAndType());\n+                        }\n@@ -562,3 +541,2 @@\n-                        classModel = of().parse(\n-                               of().transform(classModel, classTransform)\n-                        );\n+                        if (!quiet) System.err.println(\"Removing instruction invokestatic for Method: \" + invokeInstruction.name());\n+                        b.nop();\n@@ -566,16 +544,5 @@\n-                        assert(i.sizeInBytes() == 3);\n-                        MethodModel finalConm = patternMethod;\n-                        codeTransform = (b, e) ->{\n-                            String a1 = null, a2 = null;\n-                            if(e instanceof InvokeInstruction invokeInstruction){\n-                                a1 = invokeInstruction.method().name().stringValue();\n-                                a2 = finalConm.methodName().stringValue();\n-                            }\n-                            if(e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)){\n-                                System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: invokestatic \" + invokeInstruction.type() + \" to ldc: \" +  newConstant.index() );\n-                                b.ldc((LoadableConstantEntry) newConstant);\n-                            } else b.with(e);\n-                        };\n-                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n-                        classModel = of().parse(\n-                             of().transform(classModel, classTransform));\n+                        if (!quiet) {\n+                            System.err.println(\":::Transforming the Method Call of: \" + ((InvokeInstruction) e).method().name() +\n+                                    \" to => ldc: \" + newConstant.index());\n+                        }\n+                        b.ldc((LoadableConstantEntry) newConstant);\n@@ -583,1 +550,2 @@\n-                    shouldProceedAfterIndyAdded.clear();\n+                } else {\n+                    b.with(e);\n@@ -585,2 +553,7 @@\n-            }\n-            this.classModel = removePatternMethodsAndVerify(classModel);\n+            };\n+\n+            \/\/ Remove all pattern methods from the class model\n+            removePatternMethods(quiet);\n+\n+            \/\/ Apply the transformation to the class model\n+            classModel = of().parse(of().transform(classModel, ClassTransform.transformingMethodBodies(codeTransform)));\n@@ -591,3 +564,2 @@\n-        ClassModel removePatternMethodsAndVerify(ClassModel classModel){\n-\n-            ClassModel newClassModel = of().parse(\n+        void removePatternMethods(boolean quietly) {\n+            classModel = of().parse(\n@@ -601,1 +573,3 @@\n-                        else System.err.println(\"Removing pattern method: \" + ((MethodModel) e).methodName());\n+                        else{\n+                            if(!quietly) System.err.println(\"Removing pattern method: \" + ((MethodModel) e).methodName());\n+                        }\n@@ -604,13 +578,0 @@\n-\n-            try {\n-                List<VerifyError> errors = of().verify(newClassModel);\n-                if (!errors.isEmpty()) {\n-                    for (VerifyError e : errors) {\n-                        System.err.println(e.getMessage());\n-                    }\n-                    throw new IOException(\"Verification failed\");\n-                } else System.out.println(\"Verification passed\");} catch (IOException ignored) {\n-\n-            }\n-\n-            return newClassModel;\n@@ -686,0 +647,1 @@\n+\n@@ -775,1 +737,1 @@\n-            List<Object> bsmArgs = null;  \/\/ args for invokeGeneric\n+            List<Object> bsmArgs = null;  \/\/ args to invokeGeneric\n@@ -1079,1 +1041,1 @@\n-                 ref = poolBuilder.fieldRefEntry(ownerClass, nameAndTypeEntry);\n+                ref = poolBuilder.fieldRefEntry(ownerClass, nameAndTypeEntry);\n","filename":"test\/jdk\/java\/lang\/invoke\/indify\/Indify.java","additions":59,"deletions":97,"binary":false,"changes":156,"status":"modified"}]}