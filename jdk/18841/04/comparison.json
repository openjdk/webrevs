{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -95,1 +96,1 @@\n-    static class MyCCS extends ConstantCallSite {\n+    public static class MyCCS extends ConstantCallSite {\n","filename":"test\/jdk\/java\/lang\/invoke\/CallSiteTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -53,1 +54,1 @@\n-    private static class Init1 {\n+    public static class Init1 {\n@@ -55,1 +56,1 @@\n-        static int foo() { return Init1Tick; }\n+        public static int foo() { return Init1Tick; }\n@@ -59,1 +60,1 @@\n-    private static class Init2 {\n+    public static class Init2 {\n@@ -61,1 +62,1 @@\n-        static int bar() { return Init2Tick; }\n+        public static int bar() { return Init2Tick; }\n@@ -65,1 +66,1 @@\n-    private static class Init3 {\n+    public static class Init3 {\n@@ -67,1 +68,1 @@\n-        static int baz() { return Init3Tick; }\n+        public static int baz() { return Init3Tick; }\n@@ -71,1 +72,1 @@\n-    private static class Init4 {\n+    public static class Init4 {\n@@ -73,1 +74,1 @@\n-        static int bat() { return Init4Tick; }\n+        public static int bat() { return Init4Tick; }\n@@ -77,1 +78,1 @@\n-    private static class Init5 {\n+    public static class Init5 {\n@@ -79,1 +80,1 @@\n-        static int bang = Init5Tick;\n+        public static int bang = Init5Tick;\n@@ -83,1 +84,1 @@\n-    private static class Init6 {\n+    public static class Init6 {\n@@ -85,1 +86,1 @@\n-        static int pong;\n+        public static int pong;\n@@ -114,1 +115,1 @@\n-            assertEquals(t1+1, t2);  \/\/ no ticks in between\n+            assertEquals(t1+1, t2);  \/\/ No other static initializations should have occurred in between\n@@ -152,1 +153,1 @@\n-        assertEquals(Init1Tick, 0);  \/\/ Init1 not initialized yet\n+        assertEquals(Init1Tick, 0);\/\/ Init1 has not been initialized before invoking INDY_foo\n@@ -156,3 +157,8 @@\n-        assertEquals(Init1Tick, t2);  \/\/ when Init1 was initialized\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        \/**\n+         * tick(\"runFoo\") increments TICK once\n+         * INDY_foo() increments TICK during Init1's static block.\n+         * tick(\"runFoo done\") increments TICK again.\n+         *\/\n+        assertEquals(Init1Tick + 3, t2);\n+        assertEquals(t1+1, t3); \/\/ one tick in between runFoo and runFoo done\n+        assertEquals(t1, t2);  \/\/ init happened inside\n@@ -171,3 +177,3 @@\n-        assertEquals(Init2Tick, t2);  \/\/ when Init2 was initialized\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        assertEquals(Init2Tick +4 , t2);  \/\/ when Init2 was initialized (Init1Tick + 3) + 1\n+        assertEquals(t1+1, t3);  \/\/ 1 tick in between runBar and runBar done\n+        assertEquals(t1, t2 +1);\n@@ -186,3 +192,3 @@\n-        assertEquals(Init3Tick, t2);  \/\/ when Init3 was initialized\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        assertEquals(Init3Tick + 5, t2);  \/\/\n+        assertEquals(t1+1, t3);\n+        assertEquals(t1, t2+4);\n@@ -201,3 +207,3 @@\n-        assertEquals(Init4Tick, t2);  \/\/ when Init4 was initialized\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        assertEquals(Init4Tick + 6, t2);\n+        assertEquals(t1+1, t3);\n+        assertEquals(t1, t2+5);\n@@ -216,3 +222,3 @@\n-        assertEquals(Init5Tick, t2);  \/\/ when Init5 was initialized\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        assertEquals(Init5Tick + 7, t2);\n+        assertEquals(t1+1, t3);\n+        assertEquals(t1, t2+6);\n@@ -232,2 +238,2 @@\n-        assertEquals(t1+2, t3);  \/\/ exactly two ticks in between\n-        assertEquals(t1+1, t2);  \/\/ init happened inside\n+        assertEquals(t1+1, t3);\n+        assertEquals(t1, t2 + 15);\n","filename":"test\/jdk\/java\/lang\/invoke\/CallStaticInitOrder.java","additions":38,"deletions":32,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -237,1 +238,1 @@\n-    static class TestPolicy extends Policy {\n+    public static class TestPolicy extends Policy {\n@@ -241,1 +242,1 @@\n-        TestPolicy() {\n+        public TestPolicy() {\n","filename":"test\/jdk\/java\/lang\/invoke\/InvokeDynamicPrintArgs.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -172,1 +173,1 @@\n-    static class TestPolicy extends Policy {\n+    public static class TestPolicy extends Policy {\n@@ -176,1 +177,1 @@\n-        TestPolicy() {\n+        public TestPolicy() {\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleConstants.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,5 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.*;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n@@ -29,0 +34,1 @@\n+import java.util.function.Predicate;\n@@ -30,0 +36,4 @@\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.*;\n@@ -32,2 +42,1 @@\n- * Transform one or more class files to incorporate JSR 292 features,\n- * such as {@code invokedynamic}.\n+ * Transform one or more class files to incorporate JSR 292 features, such as {@code invokedynamic}.\n@@ -35,4 +44,2 @@\n- * This is a standalone program in a single source file.\n- * In this form, it may be useful for test harnesses, small experiments, and javadoc examples.\n- * Copies of this file may show up in multiple locations for standalone usage.\n- * The primary maintained location of this file is as follows:\n+ * This standalone program, contained within a single source file, is useful for test harnesses, small experiments, and Javadoc examples.\n+ * Copies of this file may be distributed to various locations for standalone usage. The primary maintained location of this file is:\n@@ -41,0 +48,2 @@\n+ * <\/p>\n+ *\n@@ -42,19 +51,11 @@\n- * Static private methods named MH_x and MT_x (where x is arbitrary)\n- * must be stereotyped generators of MethodHandle and MethodType\n- * constants.  All calls to them are transformed to {@code CONSTANT_MethodHandle}\n- * and {@code CONSTANT_MethodType} \"ldc\" instructions.\n- * The stereotyped code must create method types by calls to {@code methodType} or\n- * {@code fromMethodDescriptorString}.  The \"lookup\" argument must be created\n- * by calls to {@code java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.\n- * The class and string arguments must be constant.\n- * The following methods of {@code java.lang.invoke.MethodHandle.Lookup Lookup} are\n- * allowed for method handle creation: {@code findStatic}, {@code findVirtual},\n- * {@code findConstructor}, {@code findSpecial},\n- * {@code findGetter}, {@code findSetter},\n- * {@code findStaticGetter}, or {@code findStaticSetter}.\n- * The call to one of these methods must be followed immediately\n- * by an {@code areturn} instruction.\n- * The net result of the call to the MH_x or MT_x method must be\n- * the creation of a constant method handle.  Thus, replacing calls\n- * to MH_x or MT_x methods by {@code ldc} instructions should leave\n- * the meaning of the program unchanged.\n+ * Static private methods named MH_x and MT_x (where x is arbitrary) must generate MethodHandle and MethodType constants.\n+ * All calls to these methods are transformed into {@code CONSTANT_MethodHandle} and {@code CONSTANT_MethodType} \"ldc\" instructions.\n+ * The code must create method types using {@code methodType} or {@code fromMethodDescriptorString}. The \"lookup\" argument must be\n+ * created using {@code java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}. The class and string arguments must be constant.\n+ * The following methods of {@code java.lang.invoke.MethodHandle.Lookup Lookup} are allowed for method handle creation:\n+ * {@code findStatic}, {@code findVirtual}, {@code findConstructor}, {@code findSpecial}, {@code findGetter}, {@code findSetter},\n+ * {@code findStaticGetter}, or {@code findStaticSetter}. The call to one of these methods must be followed immediately by an\n+ * {@code areturn} instruction. Replacing calls to MH_x or MT_x methods with {@code ldc} instructions should not change the program's\n+ * meaning.\n+ * <\/p>\n+ *\n@@ -62,12 +63,5 @@\n- * Static private methods named INDY_x must be stereotyped generators\n- * of {@code invokedynamic} call sites.\n- * All calls to them must be immediately followed by\n- * {@code invokeExact} calls.\n- * All such pairs of calls are transformed to {@code invokedynamic}\n- * instructions.  Each INDY_x method must begin with a call to a\n- * MH_x method, which is taken to be its bootstrap method.\n- * The method must be immediately invoked (via {@code invokeGeneric}\n- * on constant lookup, name, and type arguments.  An object array of\n- * constants may also be appended to the {@code invokeGeneric call}.\n- * This call must be cast to {@code CallSite}, and the result must be\n- * immediately followed by a call to {@code dynamicInvoker}, with the\n+ * Static private methods named INDY_x must generate {@code invokedynamic} call sites. All calls to them must be immediately followed\n+ * by {@code invokeExact} calls. These pairs of calls are transformed into {@code invokedynamic} instructions. Each INDY_x method must\n+ * start with a call to an MH_x method, which acts as its bootstrap method. This method must be immediately invoked (via {@code invokeGeneric})\n+ * on constant lookup, name, and type arguments. An object array of constants may also be appended to the {@code invokeGeneric} call.\n+ * This call must be cast to {@code CallSite}, and the result must be immediately followed by a call to {@code dynamicInvoker}, with the\n@@ -75,0 +69,2 @@\n+ * <\/p>\n+ *\n@@ -76,10 +72,7 @@\n- * The net result of all of these actions is equivalent to the JVM's\n- * execution of an {@code invokedynamic} instruction in the unlinked state.\n- * Running this code once should produce the same results as running\n- * the corresponding {@code invokedynamic} instruction.\n- * In order to model the caching behavior, the code of an INDY_x\n- * method is allowed to begin with getstatic, aaload, and if_acmpne\n- * instructions which load a static method handle value and return it\n- * if the value is non-null.\n- * <p>\n- * Example usage:\n+ * These actions collectively simulate the JVM's execution of an {@code invokedynamic} instruction in the unlinked state. Running this\n+ * code once should yield the same results as running the corresponding {@code invokedynamic} instruction. To model caching behavior,\n+ * an INDY_x method's code can begin with getstatic, aaload, and if_acmpne instructions to load a static method handle value and return\n+ * it if the value is non-null.\n+ * <\/p>\n+ *\n+ * <h3>Example usage:<\/h3>\n@@ -87,10 +80,10 @@\n-$ JAVA_HOME=(some recent OpenJDK 7 build)\n-$ ant\n-$ $JAVA_HOME\/bin\/java -cp build\/classes indify.Indify --overwrite --dest build\/testout build\/classes\/indify\/Example.class\n-$ $JAVA_HOME\/bin\/java -cp build\/classes indify.Example\n-MT = (java.lang.Object)java.lang.Object\n-MH = adder(int,int)java.lang.Integer\n-adder(1,2) = 3\n-calling indy:  42\n-$ $JAVA_HOME\/bin\/java -cp build\/testout indify.Example\n-(same output as above)\n+ * $ JAVA_HOME=(some recent OpenJDK 7 build)\n+ * $ ant\n+ * $ $JAVA_HOME\/bin\/java -cp build\/classes indify.Indify --overwrite --dest build\/testout build\/classes\/indify\/Example.class\n+ * $ $JAVA_HOME\/bin\/java -cp build\/classes indify.Example\n+ * MT = (java.lang.Object)java.lang.Object\n+ * MH = adder(int,int)java.lang.Integer\n+ * adder(1,2) = 3\n+ * calling indy:  42\n+ * $ $JAVA_HOME\/bin\/java -cp build\/testout indify.Example\n+ * (same output as above)\n@@ -98,0 +91,1 @@\n+ *\n@@ -100,0 +94,2 @@\n+ * <\/p>\n+ *\n@@ -102,0 +98,1 @@\n+\n@@ -107,0 +104,3 @@\n+    \/**\n+     * Destination file where output will be written.\n+     *\/\n@@ -108,0 +108,4 @@\n+\n+    \/**\n+     * Array of classpath entries, with the default being the current directory.\n+     *\/\n@@ -109,0 +113,5 @@\n+\n+    \/**\n+     * Flag indicating whether to continue processing after encountering an error.\n+     * Default is {@code false}.\n+     *\/\n@@ -110,0 +119,5 @@\n+\n+    \/**\n+     * Flag indicating whether to expand properties in input files.\n+     * Default is {@code false}.\n+     *\/\n@@ -111,0 +125,5 @@\n+\n+    \/**\n+     * Flag indicating whether to overwrite existing files.\n+     * Default is {@code false}.\n+     *\/\n@@ -112,0 +131,5 @@\n+\n+    \/**\n+     * Flag indicating whether to suppress output messages.\n+     * Default is {@code false}.\n+     *\/\n@@ -113,0 +137,5 @@\n+\n+    \/**\n+     * Flag indicating whether to enable verbose output.\n+     * Default is {@code false}.\n+     *\/\n@@ -114,0 +143,5 @@\n+\n+    \/**\n+     * Flag indicating whether to process all items.\n+     * Default is {@code false}.\n+     *\/\n@@ -115,0 +149,4 @@\n+\n+    \/**\n+     * Count of verify specifiers, with the default being -1 indicating no verification.\n+     *\/\n@@ -117,0 +155,12 @@\n+    \/**\n+     * Processes command-line arguments to transform class files by incorporating JSR 292 features.\n+     * <p>\n+     * This method accepts various options and a list of files to be processed. If the '--java' option\n+     * is specified, it runs the application with the provided arguments. Otherwise, it processes\n+     * each file using the {@code indify} method.\n+     * <\/p>\n+     *\n+     * @param av the command-line arguments\n+     * @throws IOException if an I\/O error occurs during file processing\n+     * @throws IllegalArgumentException if the arguments are invalid\n+     *\/\n@@ -120,1 +170,2 @@\n-        if (avl.isEmpty())\n+\n+        if (avl.isEmpty()) {\n@@ -122,0 +173,2 @@\n+        }\n+\n@@ -127,1 +180,3 @@\n-                if (ex instanceof RuntimeException)  throw (RuntimeException) ex;\n+                if (ex instanceof RuntimeException) {\n+                    throw (RuntimeException) ex;\n+                }\n@@ -132,0 +187,1 @@\n+\n@@ -137,3 +193,9 @@\n-                if (err == null)  err = ex;\n-                System.err.println(\"failure on \"+a);\n-                if (!keepgoing)  break;\n+                if (err == null) {\n+                    err = ex;\n+                }\n+                System.err.println(\"Failure on \" + a);\n+                if (!keepgoing) {\n+                    break;\n+                } else if (ex != err) {\n+                    err.addSuppressed(ex);\n+                }\n@@ -142,0 +204,1 @@\n+\n@@ -143,1 +206,3 @@\n-            if (err instanceof IOException)  throw (IOException) err;\n+            if (err instanceof IOException) {\n+                throw (IOException) err;\n+            }\n@@ -154,2 +219,2 @@\n-        java.lang.reflect.Method main = mainClass.getMethod(\"main\", String[].class);\n-        try { main.setAccessible(true); } catch (SecurityException ex) { }\n+        Method main = mainClass.getMethod(\"main\", String[].class);\n+        try { main.setAccessible(true); } catch (SecurityException ignored) { }\n@@ -171,1 +236,1 @@\n-                    return;  \/\/ keep this argument\n+                    return;\n@@ -179,1 +244,1 @@\n-                    keepgoing = booleanOption(a2);  \/\/ print errors but keep going\n+                    keepgoing = booleanOption(a2);\n@@ -182,1 +247,1 @@\n-                    expandProperties = booleanOption(a2);  \/\/ expand property references in subsequent arguments\n+                    expandProperties = booleanOption(a2);\n@@ -188,1 +253,1 @@\n-                    overwrite = booleanOption(a2);  \/\/ overwrite output files\n+                    overwrite = booleanOption(a2);\n@@ -191,1 +256,1 @@\n-                    all = booleanOption(a2);  \/\/ copy all classes, even if no patterns\n+                    all = booleanOption(a2);\n@@ -194,1 +259,1 @@\n-                    quiet = booleanOption(a2);  \/\/ less output\n+                    quiet = booleanOption(a2);\n@@ -197,1 +262,1 @@\n-                    verbose = booleanOption(a2);  \/\/ more output\n+                    verbose = booleanOption(a2);\n@@ -202,1 +267,0 @@\n-                continue;\n@@ -217,5 +281,5 @@\n-        switch (s) {\n-        case \"true\":  case \"yes\": case \"on\":  case \"1\": return true;\n-        case \"false\": case \"no\":  case \"off\": case \"0\": return false;\n-        }\n-        throw new IllegalArgumentException(\"unrecognized boolean flag=\"+s);\n+        return switch (s) {\n+            case \"true\", \"yes\", \"on\", \"1\" -> true;\n+            case \"false\", \"no\", \"off\", \"0\" -> false;\n+            default -> throw new IllegalArgumentException(\"unrecognized boolean flag=\" + s);\n+        };\n@@ -256,1 +320,1 @@\n-            System.err.println(\"created \"+dir);\n+            System.err.println(\"Created new directory to: \"+dir);\n@@ -261,3 +325,4 @@\n-        ClassFile cf = new ClassFile(f);\n-        Logic logic = new Logic(cf);\n-        boolean changed = logic.transform();\n+        ClassModel model = parseClassFile(f);\n+        Logic logic = new Logic(model);\n+        ClassModel newClassModel = logic.transform();\n+        assert newClassModel != null;\n@@ -265,11 +330,14 @@\n-        if (changed || all) {\n-            File outfile;\n-            if (dest != null) {\n-                ensureDirectory(dest);\n-                outfile = classPathFile(dest, cf.nameString());\n-            } else {\n-                outfile = f;  \/\/ overwrite input file, no matter where it is\n-            }\n-            cf.writeTo(outfile);\n-            if (!quiet)  System.err.println(\"wrote \"+outfile);\n-        }\n+        writeNewClassFile(newClassModel);\n+    }\n+\n+    void writeNewClassFile(ClassModel newClassModel) throws IOException {\n+        byte[] new_bytes = transformToBytes(newClassModel);\n+        File destFile = classPathFile(dest, newClassModel.thisClass().name().stringValue());\n+        ensureDirectory(destFile.getParentFile());\n+        if (verbose)  System.err.println(\"writing \"+destFile);\n+        Files.write(destFile.toPath(), new_bytes);\n+        System.err.println(\"Wrote New ClassFile to: \"+destFile);\n+    }\n+\n+    byte[] transformToBytes(ClassModel classModel) {\n+        return of(StackMapsOption.GENERATE_STACK_MAPS).transform(classModel, ClassTransform.ACCEPT_ALL);\n@@ -284,1 +352,1 @@\n-    public void indifyJar(File f, Object dest) throws IOException {\n+    public void indifyJar(File f, Object dest) {\n@@ -290,7 +358,8 @@\n-        for (File f2 : f.listFiles(new FilenameFilter() {\n-                public boolean accept(File dir, String name) {\n-                    if (name.endsWith(\".class\"))  return true;\n-                    if (name.contains(\".\"))  return false;\n-                    \/\/ return true if it might be a package name:\n-                    return Character.isJavaIdentifierStart(name.charAt(0));\n-                }})) {\n+        for (File f2 : Objects.requireNonNull(f.listFiles(new FilenameFilter() {\n+            public boolean accept(File dir, String name) {\n+                if (name.endsWith(\".class\")) return true;\n+                if (name.contains(\".\")) return false;\n+                \/\/ return true if it might be a package name:\n+                return Character.isJavaIdentifierStart(name.charAt(0));\n+            }\n+        }))) {\n@@ -359,4 +428,4 @@\n-            ClassFile cf = new ClassFile(f);\n-            Logic logic = new Logic(cf);\n-            boolean changed = logic.transform();\n-            if (verbose && !changed)  System.err.println(\"(no change)\");\n+            ClassModel model = parseClassFile(f);\n+            Logic logic = new Logic(model);\n+            ClassModel newClassModel = logic.transform();\n+            if(newClassModel == null)  throw new IOException(\"No transformation has been done\");\n@@ -364,2 +433,4 @@\n-            byte[] bytes = cf.toByteArray();\n-            return defineClass(null, bytes, 0, bytes.length);\n+            byte[] new_Bytes = transformToBytes(newClassModel);\n+            System.err.println(\"Transformed bytes: \" + new_Bytes.length);\n+\n+            return defineClass(null, new_Bytes, 0, new_Bytes.length);\n@@ -370,2 +441,2 @@\n-        \/\/ Indify logic, per se.\n-        ClassFile cf;\n+        ClassModel classModel;\n+        ConstantPoolBuilder poolBuilder;  \/\/Builder for the new constant pool\n@@ -373,5 +444,6 @@\n-        final Map<Method,Constant> constants = new HashMap<>();\n-        final Map<Method,String> indySignatures = new HashMap<>();\n-        Logic(ClassFile cf) {\n-            this.cf = cf;\n-            poolMarks = new char[cf.pool.size()];\n+        final Map<MethodModel, PoolEntry> Constants = new HashMap<>();\n+        final Map<MethodModel, String> IndySignatures = new HashMap<>();\n+        Logic(ClassModel classModel){\n+            this.classModel = classModel;\n+            poolBuilder = ConstantPoolBuilder.of(classModel);\n+            poolMarks = new char[classModel.constantPool().size()];\n@@ -379,32 +451,55 @@\n-        boolean transform() {\n-            if (!initializeMarks())  return false;\n-            if (!findPatternMethods())  return false;\n-            Pool pool = cf.pool;\n-            \/\/for (Constant c : cp)  System.out.println(\"  # \"+c);\n-            for (Method m : cf.methods) {\n-                if (constants.containsKey(m))  continue;  \/\/ don't bother\n-                \/\/ Transform references.\n-                int blab = 0;\n-                for (Instruction i = m.instructions(); i != null; i = i.next()) {\n-                    if (i.bc != opc_invokestatic)  continue;\n-                    int methi = i.u2At(1);\n-                    if (poolMarks[methi] == 0)  continue;\n-                    Short[] ref = pool.getMemberRef((short)methi);\n-                    Method conm = findMember(cf.methods, ref[1], ref[2]);\n-                    if (conm == null)  continue;\n-                    Constant con = constants.get(conm);\n-                    if (con == null)  continue;\n-                    if (blab++ == 0 && !quiet)\n-                        System.err.println(\"patching \"+cf.nameString()+\".\"+m);\n-                    \/\/if (blab == 1) { for (Instruction j = m.instructions(); j != null; j = j.next()) System.out.println(\"  |\"+j); }\n-                    if (con.tag == CONSTANT_InvokeDynamic) {\n-                        \/\/ need to patch the following instruction too,\n-                        \/\/ but there are usually intervening argument pushes too\n-                        Instruction i2 = findPop(i);\n-                        Short[] ref2 = null;\n-                        short ref2i = 0;\n-                        if (i2 != null && i2.bc == opc_invokevirtual &&\n-                                poolMarks[(char)(ref2i = (short) i2.u2At(1))] == 'D')\n-                            ref2 = pool.getMemberRef(ref2i);\n-                        if (ref2 == null || !\"invokeExact\".equals(pool.getString(ref2[1]))) {\n-                            System.err.println(m+\": failed to create invokedynamic at \"+i.pc);\n+\n+        ClassModel transform(){\n+            if (!initializeMarks())  return null;\n+            if (!findPatternMethods()) return null;\n+\n+            ClassModel newClassModel = transformFromCPBuilder(classModel, poolBuilder);\n+            CodeTransform codeTransform;\n+            ClassTransform classTransform;\n+\n+            for(MethodModel m : classModel.methods()){\n+                if(Constants.containsKey(m)) continue;  \/\/skip if pattern method, it will be removed\n+\n+                Predicate<MethodModel> filter = method -> Objects.equals(method.methodName().stringValue(), m.methodName().stringValue());\n+\n+                List<Instruction> instructionList = getInstructions(m);\n+                ListIterator<Instruction> iterator =instructionList.listIterator();\n+                final Stack<Boolean> shouldProceed = new Stack<>();\n+\n+                while (iterator.hasNext()){\n+                    shouldProceed.push(true);\n+                    Instruction i = iterator.next();\n+\n+                    if(i.opcode().bytecode() != INVOKESTATIC) continue;  \/\/this is not an invokestatic instruction\n+                    int methi = ((InvokeInstruction) i).method().index();\n+                    if (poolMarks[methi] == 0) continue;    \/\/Skip if marked as a pattern Method\n+\n+                    MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(methi);\n+                    String methName = ref.nameAndType().name().stringValue();\n+                    String methType = ref.nameAndType().type().stringValue();\n+\n+                    MethodModel conm = null;\n+                    for (MethodModel mm : classModel.methods()) {\n+                        if (mm.methodName().stringValue().equals(methName) && mm.methodType().stringValue().equals(methType)) {\n+                            conm = mm;\n+                        }\n+                    }\n+                    if(conm == null) continue;\n+\n+                    PoolEntry con = Constants.get(conm);\n+                    if(quiet){\n+                        System.out.println();\n+                        System.err.println(\"$$$$$$$$$$$$$$$----------------------------------------------------------------Patching Method: \" +  m.methodName() + \"------------------------------------------------------------------\");\n+                    }\n+\n+                    if(con instanceof InvokeDynamicEntry){\n+                        Instruction i2 = findPop(instructionList, iterator.previousIndex());\n+                        int ref2i;\n+                        MethodRefEntry methodEntry = null;\n+\n+                        if(i2 != null && i2.opcode().bytecode() == INVOKEVIRTUAL && poolMarks[ref2i = ((InvokeInstruction) i2).method().index()] == 'D'){\n+                            methodEntry = (MethodRefEntry) newClassModel.constantPool().entryByIndex(ref2i);\n+                        }\n+\n+                        if(methodEntry == null || !\"invokeExact\".equals(methodEntry.nameAndType().name().stringValue())){\n+                            System.err.println(m+\": Failed to create invokedynamic at \"+i.opcode().bytecode());\n@@ -413,2 +508,3 @@\n-                        String invType = pool.getString(ref2[2]);\n-                        String bsmType = indySignatures.get(conm);\n+\n+                        String invType = methodEntry.type().stringValue();\n+                        String bsmType = IndySignatures.get(conm);\n@@ -416,2 +512,1 @@\n-                            System.err.println(m+\": warning: \"+conm+\" call type and local invoke type differ: \"\n-                                    +bsmType+\", \"+invType);\n+                            System.err.println(m+\": warning: \"+conm+\" call type and local invoke type differ: \" + bsmType+\", \" + invType);\n@@ -419,10 +514,33 @@\n-                        assert(i.len == 3 || i2.len == 3);\n-                        if (!quiet)  System.err.println(i+\" \"+conm+\";...; \"+i2+\" => invokedynamic \"+con);\n-                        int start = i.pc + 3, end = i2.pc;\n-                        System.arraycopy(i.codeBase, start, i.codeBase, i.pc, end-start);\n-                        i.forceNext(0);  \/\/ force revisit of new instruction\n-                        i2.u1AtPut(-3, opc_invokedynamic);\n-                        i2.u2AtPut(-2, con.index);\n-                        i2.u2AtPut(0, (short)0);\n-                        i2.u1AtPut(2, opc_nop);\n-                        \/\/System.out.println(new Instruction(i.codeBase, i2.pc-3));\n+\n+                        assert (i.sizeInBytes() == 3 || i2.sizeInBytes() == 3);\n+                        System.err.println(\"----------------------------------------------------------------Transforming Method INDY Instructions & Creating New ClassModels------------------------------------------------------------------}}}\");\n+                        if (!quiet) System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: \" + i + \" invokedynamic: \" + con.index() );\n+                        MethodModel finalConm = conm;\n+                        codeTransform = (b, e) ->{\n+                            String a1 = null, a2 = null;\n+                            if(e instanceof InvokeInstruction){\n+                                a1 = ((InvokeInstruction) e).method().name().stringValue();\n+                                a2 = finalConm.methodName().stringValue();\n+                            }\n+                            if (e instanceof InvokeInstruction && Objects.equals(a1, a2)) {\n+                                System.err.println(\">> Removing instruction invokestatic for Method: \" + ((InvokeInstruction) e).name());\n+                                b.andThen(b);\n+                            } else if (shouldProceed.peek() && e instanceof InvokeInstruction && ((InvokeInstruction) e).method().equals(((InvokeInstruction) i2).method())) {\n+                                System.err.println(\">> Removing instruction invokevirtual for Method: \" + ((InvokeInstruction) e).name());\n+                                b.andThen(b);\n+                                System.out.println(\">> Adding invokedynamic instruction and nop instead of invoke virtual: \" + ((InvokeDynamicEntry) con).name());\n+                                b.invokeDynamicInstruction((InvokeDynamicEntry) con).nop();\n+\n+                                shouldProceed.pop();\n+                                shouldProceed.push(false);\n+                            } else {\n+                                b.with(e);\n+                            }\n+                        };\n+                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n+\n+                        newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n+                               of(StackMapsOption.GENERATE_STACK_MAPS).transform(newClassModel, classTransform)\n+                        );\n+\n+                        System.out.println();\n@@ -430,4 +548,17 @@\n-                        if (!quiet)  System.err.println(i+\" \"+conm+\" => ldc \"+con);\n-                        assert(i.len == 3);\n-                        i.u1AtPut(0, opc_ldc_w);\n-                        i.u2AtPut(1, con.index);\n+                        assert(i.sizeInBytes() == 3);\n+                        System.err.println(\"----------------------------------------------------------------Transforming Method LDC Instructions & Creating New ClassModels------------------------------------------------------------------}}}\");\n+                        MethodModel finalConm = conm;\n+                        codeTransform = (b, e) ->{\n+                            String a1 = null, a2 = null;\n+                            if(e instanceof InvokeInstruction){\n+                                a1 = ((InvokeInstruction) e).method().name().stringValue();\n+                                a2 = finalConm.methodName().stringValue();\n+                            }\n+                            if(e instanceof InvokeInstruction && Objects.equals(a1, a2)){\n+                                System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: invokestatic \" + ((InvokeInstruction) e).type() + \" to ldc: \" + ((LoadableConstantEntry) con).index() );\n+                                b.constantInstruction(Opcode.LDC_W,  ((LoadableConstantEntry) con).constantValue());\n+                            } else b.with(e);\n+                        };\n+                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n+                        newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n+                             of(StackMapsOption.GENERATE_STACK_MAPS).transform(newClassModel, classTransform));\n@@ -435,0 +566,1 @@\n+                    shouldProceed.pop();\n@@ -436,1 +568,0 @@\n-                \/\/if (blab >= 1) { for (Instruction j = m.instructions(); j != null; j = j.next()) System.out.println(\"    |\"+j); }\n@@ -438,2 +569,32 @@\n-            cf.methods.removeAll(constants.keySet());\n-            return true;\n+            newClassModel = removePatternMethodsAndVerify(newClassModel);\n+\n+            return newClassModel;\n+        }\n+\n+        ClassModel removePatternMethodsAndVerify(ClassModel classModel){\n+\n+            ClassModel newClassModel = of(StackMapsOption.GENERATE_STACK_MAPS).parse(\n+                    of(StackMapsOption.GENERATE_STACK_MAPS).transform(classModel, (b, e) ->\n+                    {\n+                        if (!(e instanceof MethodModel mm &&\n+                                (mm.methodName().stringValue().startsWith(\"MH_\") ||\n+                                        mm.methodName().stringValue().startsWith(\"MT_\") ||\n+                                        mm.methodName().stringValue().startsWith(\"INDY_\"))\n+                        )) b.with(e);\n+                        else System.err.println(\"Removing pattern method: \" + ((MethodModel) e).methodName());\n+                    })\n+            );\n+            ClassHierarchyResolver classHierarchyResolver = classDesc -> ClassHierarchyResolver.ClassHierarchyInfo.ofInterface();\n+\n+            try {\n+                List<VerifyError> errors = of(StackMapsOption.GENERATE_STACK_MAPS,ClassHierarchyResolverOption.of(classHierarchyResolver)).verify(newClassModel);\n+                if (!errors.isEmpty()) {\n+                    for (VerifyError e : errors) {\n+                        System.err.println(e.getMessage());\n+                    }\n+                    throw new IOException(\"Verification failed\");\n+                } else System.out.println(\"Verification passed\");} catch (IOException ignored) {\n+\n+            }\n+\n+            return newClassModel;\n@@ -442,5 +603,1 @@\n-        \/\/ Scan forward from the instruction to find where the stack p\n-        \/\/ below the current sp at the instruction.\n-        Instruction findPop(Instruction i) {\n-            \/\/System.out.println(\"findPop from \"+i);\n-            Pool pool = cf.pool;\n+        Instruction findPop( List<Instruction> instructionList, int currentIndex){\n@@ -448,0 +605,2 @@\n+\n+            ListIterator<Instruction> newIter = instructionList.listIterator(currentIndex + 1);\n@@ -449,20 +608,23 @@\n-            for (i = i.clone().next(); i != null; i = i.next()) {\n-                String pops = INSTRUCTION_POPS[i.bc];\n-                \/\/System.out.println(\"  \"+i+\" \"+jvm.stack+\" : \"+pops.replace(\"$\", \" => \"));\n-                if (pops == null)  break;\n-                if (jvm.stackMotion(i.bc))  continue decode;\n-                if (pops.indexOf('Q') >= 0) {\n-                    Short[] ref = pool.getMemberRef((short) i.u2At(1));\n-                    String type = simplifyType(pool.getString(CONSTANT_Utf8, ref[2]));\n-                    switch (i.bc) {\n-                    case opc_getstatic:\n-                    case opc_getfield:\n-                    case opc_putstatic:\n-                    case opc_putfield:\n-                        pops = pops.replace(\"Q\", type);\n-                        break;\n-                    default:\n-                        if (!type.startsWith(\"(\"))\n-                            throw new InternalError(i.toString());\n-                        pops = pops.replace(\"Q$Q\", type.substring(1).replace(\")\",\"$\"));\n-                        break;\n+            while (newIter.hasNext()) {\n+                Instruction i = newIter.next();\n+                String pops = INSTRUCTION_POPS[i.opcode().bytecode()];\n+\n+                if(pops == null) break;\n+                if (jvm.stackMotion(i.opcode().bytecode()))  continue decode;\n+                if (pops.indexOf('Q') >= 0 && i instanceof InvokeInstruction in) {\n+                    MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(in.method().index());\n+                    String methType = ref.nameAndType().type().stringValue();\n+                    String type = simplifyType(methType);\n+\n+                    switch (i.opcode().bytecode()){\n+                        case GETSTATIC:\n+                        case GETFIELD:\n+                        case PUTSTATIC:\n+                        case PUTFIELD:\n+                            pops = pops.replace(\"Q\", type);\n+                            break;\n+                        default:\n+                            if (!type.startsWith(\"(\"))\n+                                throw new InternalError(i.toString());\n+                            pops = pops.replace(\"Q$Q\", type.substring(1).replace(\")\",\"$\"));\n+                            break;\n@@ -470,1 +632,1 @@\n-                    \/\/System.out.println(\"special type: \"+type+\" => \"+pops);\n+                    System.out.println(\"special type: \"+type+\" => \"+pops);\n@@ -488,1 +650,1 @@\n-            System.err.println(\"*** bailout on jvm: \"+jvm.stack+\" \"+i);\n+            System.err.println(\"*** bailout on jvm: \"+jvm.stack);\n@@ -492,1 +654,1 @@\n-        boolean findPatternMethods() {\n+         boolean findPatternMethods() {\n@@ -494,8 +656,8 @@\n-            for (char mark : \"THI\".toCharArray()) {\n-                for (Method m : cf.methods) {\n-                    if (!Modifier.isPrivate(m.access))  continue;\n-                    if (!Modifier.isStatic(m.access))  continue;\n-                    if (nameAndTypeMark(m.name, m.type) == mark) {\n-                        Constant con = scanPattern(m, mark);\n-                        if (con == null)  continue;\n-                        constants.put(m, con);\n+            for(char mark : \"THI\".toCharArray()) {\n+                for(MethodModel m : classModel.methods()){\n+                    if (!Modifier.isPrivate(m.flags().flagsMask())) continue;\n+                    if (!Modifier.isStatic(m.flags().flagsMask())) continue;\n+                    if(nameAndTypeMark(m.methodName().index(), m.methodType().index()) == mark) {\n+                        PoolEntry entry = scanPattern(m, mark);\n+                        if (entry == null) continue;\n+                        Constants.put(m, entry);\n@@ -509,0 +671,76 @@\n+        ClassModel transformFromCPBuilder(ClassModel oldClassModel, ConstantPoolBuilder cpBuilder){\n+            byte[] new_bytes = of(StackMapsOption.GENERATE_STACK_MAPS).transform(oldClassModel, ClassTransform.endHandler(clb -> {\n+                for (PoolEntry entry: cpBuilder) {\n+                    if (entry instanceof Utf8Entry utf8Entry) {\n+                        clb.constantPool().utf8Entry(utf8Entry.stringValue());\n+                        continue;\n+                    }\n+                    if (entry instanceof NameAndTypeEntry nameAndTypeEntry) {\n+                        clb.constantPool().nameAndTypeEntry(nameAndTypeEntry.name(), nameAndTypeEntry.type());\n+                        continue;\n+                    }\n+                    if (entry instanceof MethodTypeEntry methodTypeEntry) {\n+                        clb.constantPool().methodTypeEntry(methodTypeEntry.descriptor());\n+                        continue;\n+                    }\n+                    if (entry instanceof MethodHandleEntry methodHandleEntry) {\n+                        clb.constantPool().methodHandleEntry(methodHandleEntry.kind(), methodHandleEntry.reference());\n+                        continue;\n+                    }\n+                    if (entry instanceof MethodRefEntry methodRefEntry) {\n+                        clb.constantPool().methodRefEntry(methodRefEntry.owner(), methodRefEntry.nameAndType());\n+                        continue;\n+                    }\n+                    if (entry instanceof FieldRefEntry fieldRefEntry) {\n+                        clb.constantPool().fieldRefEntry(fieldRefEntry.owner(), fieldRefEntry.nameAndType());\n+                        continue;\n+                    }\n+                    if (entry instanceof ClassEntry classEntry) {\n+                        clb.constantPool().classEntry(classEntry.name());\n+                        continue;\n+                    }\n+                    if (entry instanceof StringEntry stringEntry) {\n+                        clb.constantPool().stringEntry(stringEntry.utf8());\n+                        continue;\n+                    }\n+                    if (entry instanceof IntegerEntry integerEntry) {\n+                        clb.constantPool().intEntry(integerEntry.intValue());\n+                        continue;\n+                    }\n+                    if (entry instanceof FloatEntry floatEntry) {\n+                        clb.constantPool().floatEntry(floatEntry.floatValue());\n+                        continue;\n+                    }\n+                    if (entry instanceof LongEntry longEntry) {\n+                        clb.constantPool().longEntry(longEntry.longValue());\n+                        continue;\n+                    }\n+                    if (entry instanceof DoubleEntry doubleEntry) {\n+                        clb.constantPool().doubleEntry(doubleEntry.doubleValue());\n+                        continue;\n+                    }\n+                    if (entry instanceof InterfaceMethodRefEntry interfaceMethodRefEntry) {\n+                        clb.constantPool().interfaceMethodRefEntry(interfaceMethodRefEntry.owner(), interfaceMethodRefEntry.nameAndType());\n+                        continue;\n+                    }\n+                    if (entry instanceof InvokeDynamicEntry invokeDynamicEntry) {\n+                        clb.constantPool().invokeDynamicEntry(invokeDynamicEntry.bootstrap(), invokeDynamicEntry.nameAndType());\n+                        continue;\n+                    }\n+                    if (entry instanceof ModuleEntry moduleEntry) {\n+                        clb.constantPool().moduleEntry(moduleEntry.name());\n+                        continue;\n+                    }\n+                    if (entry instanceof PackageEntry packageEntry) {\n+                        clb.constantPool().packageEntry(packageEntry.name());\n+                    }\n+                }\n+\n+                for (int i = 0; i < cpBuilder.bootstrapMethodCount(); i++) {\n+                    clb.constantPool().bsmEntry(cpBuilder.bootstrapMethodEntry(i).bootstrapMethod(), cpBuilder.bootstrapMethodEntry(i).arguments());\n+                }\n+            }));\n+\n+            return of(StackMapsOption.GENERATE_STACK_MAPS).parse(new_bytes);\n+        }\n+\n@@ -510,6 +748,6 @@\n-            if (!quietly && !constants.keySet().isEmpty())\n-                System.err.println(\"pattern methods removed: \"+constants.keySet());\n-            for (Method m : cf.methods) {\n-                if (nameMark(cf.pool.getString(m.name)) != 0 &&\n-                    constants.get(m) == null) {\n-                    String failure = \"method has special name but fails to match pattern: \"+m;\n+            if (!quietly && !Constants.keySet().isEmpty())\n+                System.err.println(\"pattern methods removed: \"+Constants.keySet());\n+            for (MethodModel m : classModel.methods()) {\n+                if (nameMark(m.methodName().stringValue()) != 0 &&\n+                        Constants.get(m) == null) {\n+                    String failure = \"method has a special name but fails to match pattern: \"+ m.methodName();\n@@ -522,9 +760,0 @@\n-            if (verifySpecifierCount >= 0) {\n-                List<Object[]> specs = bootstrapMethodSpecifiers(false);\n-                int specsLen = (specs == null ? 0 : specs.size());\n-                \/\/ Pass by specsLen == 0, to help with associated (inner) classes.\n-                if (specsLen == 0)  specsLen = verifySpecifierCount;\n-                if (specsLen != verifySpecifierCount) {\n-                    throw new IllegalArgumentException(\"BootstrapMethods length is \"+specsLen+\" but should be \"+verifySpecifierCount);\n-                }\n-            }\n@@ -534,1 +763,12 @@\n-        \/\/ mark constant pool entries according to participation in patterns\n+        \/**\n+         * Initializes the marks for the constant pool entries.\n+         * <p>\n+         * This method iterates through the constant pool and assigns marks to each entry\n+         * based on its type and value. These marks are used to identify specific types of\n+         * constant pool entries .\n+         * <p>\n+         * The method iterates until no changes are made to the pool marks array in a complete pass.\n+         * This ensures that all dependent entries are processed correctly.\n+         *\n+         * @return true if any marks were changed, false otherwise.\n+         *\/\n@@ -536,1 +776,1 @@\n-            boolean changed = false;\n+            boolean anyMarksChanged = false;\n@@ -538,18 +778,5 @@\n-                boolean changed1 = false;\n-                int cpindex = -1;\n-                for (Constant e : cf.pool) {\n-                    ++cpindex;\n-                    if (e == null)  continue;\n-                    char mark = poolMarks[cpindex];\n-                    if (mark != 0)  continue;\n-                    switch (e.tag) {\n-                    case CONSTANT_Utf8:\n-                        mark = nameMark(e.itemString()); break;\n-                    case CONSTANT_NameAndType:\n-                        mark = nameAndTypeMark(e.itemIndexes()); break;\n-                    case CONSTANT_Class: {\n-                        int n1 = e.itemIndex();\n-                        char nmark = poolMarks[(char)n1];\n-                        if (\"DJ\".indexOf(nmark) >= 0)\n-                            mark = nmark;\n-                        break;\n+                boolean someMarksChangedInLoop = false;\n+                for (PoolEntry poolEntry : classModel.constantPool()) {\n+                    \/\/ Get the index directly from PoolEntry\n+                    if (poolEntry == null) {\n+                        continue; \/\/ Skip null entries\n@@ -557,8 +784,23 @@\n-                    case CONSTANT_Field:\n-                    case CONSTANT_Method: {\n-                        Short[] n12 = e.itemIndexes();\n-                        short cl = n12[0];\n-                        short nt = n12[1];\n-                        char cmark = poolMarks[(char)cl];\n-                        if (cmark != 0) {\n-                            mark = cmark;  \/\/ it is a java.lang.invoke.* or java.lang.* method\n+                    int cpIndex = poolEntry.index();\n+\n+                    char mark = poolMarks[cpIndex];\n+                    if (mark != 0) {\n+                        continue;\n+                    }\n+\n+                    switch (poolEntry.tag()) {\n+                        case TAG_UTF8:\n+                            mark = nameMark(((Utf8Entry) poolEntry).stringValue());\n+                            break;\n+                        case TAG_NAMEANDTYPE:\n+                            NameAndTypeEntry nameAndTypeEntry = (NameAndTypeEntry) poolEntry;\n+                            int ref1 = nameAndTypeEntry.name().index();\n+                            int ref2 = nameAndTypeEntry.type().index();\n+                            mark = nameAndTypeMark(ref1, ref2);\n+                            break;\n+                        case TAG_CLASS: {\n+                            int nameIndex = ((ClassEntry) poolEntry).name().index();\n+                            char nameMark = poolMarks[nameIndex];\n+                            if (\"DJ\".indexOf(nameMark) >= 0) {\n+                                mark = nameMark;\n+                            }\n@@ -567,6 +809,8 @@\n-                        String cls = cf.pool.getString(CONSTANT_Class, cl);\n-                        if (cls.equals(cf.nameString())) {\n-                            switch (poolMarks[(char)nt]) {\n-                            \/\/ it is a private MH\/MT\/INDY method\n-                            case 'T': case 'H': case 'I':\n-                                mark = poolMarks[(char)nt];\n+                        case TAG_FIELDREF:\n+                        case TAG_METHODREF: {\n+                            MemberRefEntry memberRefEntry = (MemberRefEntry) poolEntry;\n+                            int classIndex = memberRefEntry.owner().index();\n+                            int nameAndTypeIndex = memberRefEntry.nameAndType().index();\n+                            char classMark = poolMarks[classIndex];\n+                            if (classMark != 0) {\n+                                mark = classMark;  \/\/ java.lang.invoke.* or java.lang.* method\n@@ -575,0 +819,9 @@\n+                            String cls = (classModel.constantPool().entryByIndex(classIndex) instanceof ClassEntry) ?\n+                                    ((ClassEntry) classModel.constantPool().entryByIndex(classIndex)).name().stringValue() : \"\";\n+                            if (cls.equals(classModel.thisClass().name().stringValue())) {\n+                                mark = switch (poolMarks[nameAndTypeIndex]) {\n+                                    case 'T', 'H', 'I' -> poolMarks[nameAndTypeIndex];\n+                                    default -> mark;\n+                                };\n+                            }\n+                            break;\n@@ -576,3 +829,2 @@\n-                        break;\n-                    }\n-                    default:  break;\n+                        default:\n+                            break;\n@@ -580,0 +832,1 @@\n+\n@@ -581,2 +834,2 @@\n-                        poolMarks[cpindex] = mark;\n-                        changed1 = true;\n+                        poolMarks[cpIndex] = mark;\n+                        someMarksChangedInLoop = true;\n@@ -585,1 +838,1 @@\n-                if (!changed1)\n+                if (!someMarksChangedInLoop) {\n@@ -587,1 +840,2 @@\n-                changed = true;\n+                }\n+                anyMarksChanged = true;\n@@ -589,1 +843,1 @@\n-            return changed;\n+            return anyMarksChanged;\n@@ -591,0 +845,1 @@\n+\n@@ -599,7 +854,5 @@\n-        char nameAndTypeMark(Short[] n12) {\n-            return nameAndTypeMark(n12[0], n12[1]);\n-        }\n-        char nameAndTypeMark(short n1, short n2) {\n-            char mark = poolMarks[(char)n1];\n-            if (mark == 0)  return 0;\n-            String descr = cf.pool.getString(CONSTANT_Utf8, n2);\n+\n+        char nameAndTypeMark(int ref1, int ref2){\n+            char mark = poolMarks[ref1];\n+            if (mark == 0) return 0;\n+            String descriptor = (classModel.constantPool().entryByIndex(ref2) instanceof Utf8Entry) ? ((Utf8Entry) classModel.constantPool().entryByIndex(ref2)).stringValue() : \"\";\n@@ -607,5 +860,4 @@\n-            switch (poolMarks[(char)n1]) {\n-            case 'H': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n-            case 'T': requiredType = \"()Ljava\/lang\/invoke\/MethodType;\";    break;\n-            case 'I': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n-            default:  return 0;\n+            switch (poolMarks[ref1]){\n+                case 'H', 'I': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n+                case 'T': requiredType = \"()Ljava\/lang\/invoke\/MethodType;\";    break;\n+                default:  return 0;\n@@ -613,1 +865,1 @@\n-            if (matchType(descr, requiredType))  return mark;\n+            if(matchType(descriptor, requiredType)) return mark;\n@@ -638,6 +890,6 @@\n-                case opc_pop:    pop();             break;\n-                case opc_pop2:   pop(); pop();      break;\n-                case opc_swap:   pushAt(-1, pop()); break;\n-                case opc_dup:    push(top());       break;\n-                case opc_dup_x1: pushAt(-2, top()); break;\n-                case opc_dup_x2: pushAt(-3, top()); break;\n+                case POP:    pop();             break;\n+                case POP2:   pop(); pop();      break;\n+                case SWAP:   pushAt(-1, pop()); break;\n+                case DUP:    push(top());       break;\n+                case DUP_X1: pushAt(-2, top()); break;\n+                case DUP_X2: pushAt(-3, top()); break;\n@@ -651,0 +903,1 @@\n+\n@@ -652,1 +905,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -654,3 +907,3 @@\n-                if (i >= 0 && i+1 < args.size()\n-                    && (isConstant(args.get(i+1), CONSTANT_Long) ||\n-                        isConstant(args.get(i+1), CONSTANT_Double)))\n+                if (i >= 0 && i + 1 < args.size()\n+                        && (args.get(i + 1) instanceof LongEntry ||\n+                        args.get(i + 1) instanceof DoubleEntry))\n@@ -658,1 +911,1 @@\n-                else  break;\n+                else break;\n@@ -662,10 +915,16 @@\n-        private Constant scanPattern(Method m, char patternMark) {\n-            if (verbose)  System.err.println(\"scan \"+m+\" for pattern=\"+patternMark);\n-            int wantTag;\n-            switch (patternMark) {\n-            case 'T': wantTag = CONSTANT_MethodType; break;\n-            case 'H': wantTag = CONSTANT_MethodHandle; break;\n-            case 'I': wantTag = CONSTANT_InvokeDynamic; break;\n-            default: throw new InternalError();\n-            }\n-            Instruction i = m.instructions();\n+        private List<Instruction> getInstructions(MethodModel method) {\n+            return method.code().get().elementStream()\n+                    .filter(Instruction.class::isInstance)\n+                    .map(Instruction.class::cast)\n+                    .collect(Collectors.toList());\n+        }\n+\n+        private PoolEntry scanPattern(MethodModel method, char patternMark) {\n+            if(verbose) System.err.println(\"Scanning the method: \" + method.methodName().stringValue() + \"for the pattern mark: \" + patternMark);\n+            int wantedTag = switch (patternMark) {\n+                case 'T' -> TAG_METHODTYPE;\n+                case 'H' -> TAG_METHODHANDLE;\n+                case 'I' -> TAG_INVOKEDYNAMIC;\n+                default -> throw new InternalError();\n+            };\n+            List<Instruction> instructions = getInstructions(method);\n@@ -673,1 +932,1 @@\n-            Pool pool = cf.pool;\n+            ConstantPool pool = classModel.constantPool();\n@@ -677,1 +936,1 @@\n-            List<Object> bsmArgs = null;  \/\/ args to invokeGeneric\n+            List<Object> bsmArgs = null;  \/\/ args for invokeGeneric\n@@ -679,60 +938,54 @@\n-            for (; i != null; i = i.next()) {\n-                \/\/System.out.println(jvm.stack+\" \"+i);\n-                int bc = i.bc;\n-                switch (bc) {\n-                case opc_ldc:           jvm.push(pool.get(i.u1At(1)));   break;\n-                case opc_ldc_w:         jvm.push(pool.get(i.u2At(1)));   break;\n-                case opc_ldc2_w:        jvm.push2(pool.get(i.u2At(1)));  break;\n-                case opc_aconst_null:   jvm.push(null);                  break;\n-                case opc_bipush:        jvm.push((int)(byte) i.u1At(1)); break;\n-                case opc_sipush:        jvm.push((int)(short)i.u2At(1)); break;\n-\n-                \/\/ these support creation of a restarg array\n-                case opc_anewarray:\n-                    arg = jvm.pop();\n-                    if (!(arg instanceof Integer))  break decode;\n-                    arg = Arrays.asList(new Object[(Integer)arg]);\n-                    jvm.push(arg);\n-                    break;\n-                case opc_dup:\n-                    jvm.push(jvm.top()); break;\n-                case opc_aastore:\n-                    args = jvm.args(3);  \/\/ array, index, value\n-                    if (args.get(0) instanceof List &&\n-                        args.get(1) instanceof Integer) {\n-                        @SuppressWarnings(\"unchecked\")\n-                        List<Object> arg0 = (List<Object>)args.get(0);\n-                        arg0.set( (Integer)args.get(1), args.get(2) );\n-                    }\n-                    args.clear();\n-                    break;\n-\n-                case opc_new:\n-                {\n-                    String type = pool.getString(CONSTANT_Class, (short)i.u2At(1));\n-                    \/\/System.out.println(\"new \"+type);\n-                    switch (type) {\n-                    case \"java\/lang\/StringBuilder\":\n-                        jvm.push(\"StringBuilder\");\n-                        continue decode;  \/\/ go to next instruction\n-                    }\n-                    break decode;  \/\/ bail out\n-                }\n-\n-                case opc_getstatic:\n-                {\n-                    \/\/ int.class compiles to getstatic Integer.TYPE\n-                    int fieldi = i.u2At(1);\n-                    char mark = poolMarks[fieldi];\n-                    \/\/System.err.println(\"getstatic \"+fieldi+Arrays.asList(pool.getStrings(pool.getMemberRef((short)fieldi)))+mark);\n-                    if (mark == 'J') {\n-                        Short[] ref = pool.getMemberRef((short) fieldi);\n-                        String name = pool.getString(CONSTANT_Utf8, ref[1]);\n-                        if (\"TYPE\".equals(name)) {\n-                            String wrapperName = pool.getString(CONSTANT_Class, ref[0]).replace('\/', '.');\n-                            \/\/ a primitive type descriptor\n-                            Class<?> primClass;\n-                            try {\n-                                primClass = (Class<?>) Class.forName(wrapperName).getField(name).get(null);\n-                            } catch (Exception ex) {\n-                                throw new InternalError(\"cannot load \"+wrapperName+\".\"+name);\n+            for(Instruction instruction : instructions){\n+\n+                int bc = instruction.opcode().bytecode();\n+                switch (bc){\n+                    case LDC,LDC_W:           jvm.push(((ConstantInstruction.LoadConstantInstruction) instruction).constantEntry()); break;\n+                    case LDC2_W:              jvm.push2(((ConstantInstruction.LoadConstantInstruction) instruction).constantEntry()); break;\n+                    case ACONST_NULL:         jvm.push(null); break;\n+                    case BIPUSH, SIPUSH:      jvm.push(((ConstantInstruction) instruction).constantValue()); break;\n+\n+                    case ANEWARRAY :\n+                        arg = jvm.pop();\n+                        if( !(arg instanceof Integer)) break decode;\n+                        arg = Arrays.asList(new Object[(Integer)arg]);\n+                        jvm.push(arg);\n+                        break;\n+                    case DUP:\n+                        jvm.push(jvm.top()); break;\n+                    case AASTORE:\n+                        args = jvm.args(3);  \/\/ array, index, value\n+                        if (args.get(0) instanceof List &&\n+                                args.get(1) instanceof Integer) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            List<Object> arg0 = (List<Object>)args.get(0);\n+                            arg0.set( (Integer)args.get(1), args.get(2) );\n+                        }\n+                        args.clear();\n+                        break;\n+                    case NEW:\n+                        String type = ((NewObjectInstruction) instruction).className().name().stringValue();\n+                        switch (type) {\n+                            case \"java\/lang\/StringBuilder\":\n+                                jvm.push(\"StringBuilder\");\n+                                continue decode;\n+                        }\n+                        break decode;\n+                    case GETSTATIC:\n+                    {\n+                        int fieldId = ((FieldInstruction) instruction).field().index();\n+                        char mark = poolMarks[fieldId];\n+                        if (mark == 'J') {\n+                            int classIndex = ((FieldInstruction) instruction).field().owner().index();\n+                            int nameIndex = ((FieldInstruction) instruction).field().name().index();\n+                            String name = ((Utf8Entry) classModel.constantPool().entryByIndex(nameIndex)).stringValue();\n+                            if (\"TYPE\".equals(name)) {\n+                                String wrapperName = ((ClassEntry) pool.entryByIndex(classIndex)).name().stringValue().replace('\/', '.');\n+                                \/\/Primitive type descriptor\n+                                Class<?> primClass;\n+                                try {\n+                                    primClass = (Class<?>) Class.forName(wrapperName).getField(name).get(null);\n+                                } catch (Exception e) {\n+                                    throw new InternalError(\"cannot load \" + wrapperName + \".\" + name);\n+                                }\n+                                jvm.push(primClass);\n+                                break;\n@@ -740,2 +993,0 @@\n-                            jvm.push(primClass);\n-                            break;\n@@ -743,0 +994,10 @@\n+                        \/\/Unknown Field; keep going\n+                        jvm.push(UNKNOWN_CON);\n+                        break;\n+                    }\n+                    case PUTSTATIC:\n+                    {\n+                        if (patternMark != 'I') break decode;\n+                        jvm.pop();\n+                        \/\/Unknown Field; keep going\n+                        break;\n@@ -744,11 +1005,0 @@\n-                    \/\/ unknown field; keep going...\n-                    jvm.push(UNKNOWN_CON);\n-                    break;\n-                }\n-                case opc_putstatic:\n-                {\n-                    if (patternMark != 'I')  break decode;\n-                    jvm.pop();\n-                    \/\/ unknown field; keep going...\n-                    break;\n-                }\n@@ -756,31 +1006,38 @@\n-                case opc_invokestatic:\n-                case opc_invokevirtual:\n-                case opc_invokespecial:\n-                {\n-                    boolean hasRecv = (bc != opc_invokestatic);\n-                    int methi = i.u2At(1);\n-                    char mark = poolMarks[methi];\n-                    Short[] ref = pool.getMemberRef((short)methi);\n-                    String type = pool.getString(CONSTANT_Utf8, ref[2]);\n-                    \/\/System.out.println(\"invoke \"+pool.getString(CONSTANT_Utf8, ref[1])+\" \"+Arrays.asList(ref)+\" : \"+type);\n-                    args = jvm.args(hasRecv, type);\n-                    String intrinsic = null;\n-                    Constant con;\n-                    if (mark == 'D' || mark == 'J') {\n-                        intrinsic = pool.getString(CONSTANT_Utf8, ref[1]);\n-                        if (mark == 'J') {\n-                            String cls = pool.getString(CONSTANT_Class, ref[0]);\n-                            cls = cls.substring(1+cls.lastIndexOf('\/'));\n-                            intrinsic = cls+\".\"+intrinsic;\n-                        }\n-                        \/\/System.out.println(\"recognized intrinsic \"+intrinsic);\n-                        byte refKind = -1;\n-                        switch (intrinsic) {\n-                        case \"findGetter\":          refKind = REF_getField;         break;\n-                        case \"findStaticGetter\":    refKind = REF_getStatic;        break;\n-                        case \"findSetter\":          refKind = REF_putField;         break;\n-                        case \"findStaticSetter\":    refKind = REF_putStatic;        break;\n-                        case \"findVirtual\":         refKind = REF_invokeVirtual;    break;\n-                        case \"findStatic\":          refKind = REF_invokeStatic;     break;\n-                        case \"findSpecial\":         refKind = REF_invokeSpecial;    break;\n-                        case \"findConstructor\":     refKind = REF_newInvokeSpecial; break;\n+                    case INVOKESTATIC:\n+                    case INVOKEVIRTUAL:\n+                    case INVOKESPECIAL:\n+                    {\n+                        boolean hasReceiver = (bc != INVOKESTATIC);\n+                        int methodIndex = ((InvokeInstruction) instruction).method().index();\n+                        char mark = poolMarks[methodIndex];\n+                        MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(methodIndex);\n+                        String methClass = ref.owner().name().stringValue();\n+                        String methType = ref.nameAndType().type().stringValue();\n+                        String methName = ref.nameAndType().name().stringValue();\n+                        System.out.println(\"invoke \" + methName + \" : \" + ref + \" : \" + methType);\n+                        args = jvm.args(hasReceiver, methType);\n+                        String intrinsic = null;\n+                        PoolEntry con;\n+                        if (mark == 'D' || mark == 'J') {\n+                            intrinsic = methName;\n+                            if (mark == 'J') {\n+                                String cls = methClass;\n+                                cls = cls.substring(1 + cls.lastIndexOf('\/'));\n+                                intrinsic = cls + \".\" + intrinsic;\n+                            }\n+                            System.out.println(\"recognized intrinsic \" + intrinsic);\n+                            byte refKind = -1;\n+                            switch (intrinsic) {\n+                                case \"findGetter\":          refKind = (byte) GETTER.refKind;            break;\n+                                case \"findStaticGetter\":    refKind = (byte) STATIC_GETTER.refKind;     break;\n+                                case \"findSetter\":          refKind = (byte) SETTER.refKind;            break;\n+                                case \"findStaticSetter\":    refKind = (byte) STATIC_SETTER.refKind;     break;\n+                                case \"findVirtual\":         refKind = (byte) VIRTUAL.refKind;           break;\n+                                case \"findStatic\":          refKind = (byte) STATIC.refKind;            break;\n+                                case \"findSpecial\":         refKind = (byte) SPECIAL.refKind;           break;\n+                                case \"findConstructor\":     refKind = (byte) CONSTRUCTOR.refKind;       break;\n+                            }\n+                            if (refKind >= 0 && (con = parseMemberLookup(refKind, args)) != null) {\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            }\n@@ -788,3 +1045,7 @@\n-                        if (refKind >= 0 && (con = parseMemberLookup(refKind, args)) != null) {\n-                            args.clear(); args.add(con);\n-                            continue;\n+                        MethodModel ownMethod = null;\n+                        if (mark == 'T' || mark == 'H' || mark == 'I') {\n+                            for (MethodModel m : classModel.methods()) {\n+                                if (m.methodName().stringValue().equals(methName) && m.methodType().stringValue().equals(methType)) {\n+                                    ownMethod = m;\n+                                }\n+                            }\n@@ -792,31 +1053,49 @@\n-                    }\n-                    Method ownMethod = null;\n-                    if (mark == 'T' || mark == 'H' || mark == 'I') {\n-                        ownMethod = findMember(cf.methods, ref[1], ref[2]);\n-                    }\n-                    \/\/if (intrinsic != null)  System.out.println(\"intrinsic = \"+intrinsic);\n-                    switch (intrinsic == null ? \"\" : intrinsic) {\n-                    case \"fromMethodDescriptorString\":\n-                        con = makeMethodTypeCon(args.get(0));\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    case \"methodType\": {\n-                        flattenVarargs(args);  \/\/ there are several overloadings, some with varargs\n-                        StringBuilder buf = new StringBuilder();\n-                        String rtype = null;\n-                        for (Object typeArg : args) {\n-                            if (typeArg instanceof Class) {\n-                                Class<?> argClass = (Class<?>) typeArg;\n-                                if (argClass.isPrimitive()) {\n-                                    char tchar;\n-                                    switch (argClass.getName()) {\n-                                    case \"void\":    tchar = 'V'; break;\n-                                    case \"boolean\": tchar = 'Z'; break;\n-                                    case \"byte\":    tchar = 'B'; break;\n-                                    case \"char\":    tchar = 'C'; break;\n-                                    case \"short\":   tchar = 'S'; break;\n-                                    case \"int\":     tchar = 'I'; break;\n-                                    case \"long\":    tchar = 'J'; break;\n-                                    case \"float\":   tchar = 'F'; break;\n-                                    case \"double\":  tchar = 'D'; break;\n-                                    default:  throw new InternalError(argClass.toString());\n+                        switch (intrinsic == null ? \"\" : intrinsic) {\n+                            case \"fromMethodDescriptorString\":\n+                                con = makeMethodTypeCon(args.get(0));\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            case \"methodType\": {\n+                                flattenVarargs(args);\n+                                StringBuilder buf = new StringBuilder();\n+                                String rtype = null;\n+                                for(Object typeArg : args) {\n+                                    if (typeArg instanceof Class) {\n+                                        Class<?> argClass = (Class<?>) typeArg;\n+                                        if (argClass.isPrimitive()) {\n+                                            char tchar;\n+                                            switch (argClass.getName()) {\n+                                                case \"void\":    tchar = 'V'; break;\n+                                                case \"boolean\": tchar = 'Z'; break;\n+                                                case \"byte\":    tchar = 'B'; break;\n+                                                case \"char\":    tchar = 'C'; break;\n+                                                case \"short\":   tchar = 'S'; break;\n+                                                case \"int\":     tchar = 'I'; break;\n+                                                case \"long\":    tchar = 'J'; break;\n+                                                case \"float\":   tchar = 'F'; break;\n+                                                case \"double\":  tchar = 'D'; break;\n+                                                default:  throw new InternalError(argClass.toString());\n+                                            }\n+                                            buf.append(tchar);\n+                                        } else {\n+                                            buf.append('L').append(argClass.getName().replace('.','\/')).append(';');\n+                                        }\n+                                    } else if (typeArg instanceof PoolEntry) {\n+                                        PoolEntry argCon = (PoolEntry) typeArg;\n+                                        if(argCon.tag() == TAG_CLASS) {\n+                                            String cn = ((ClassEntry) argCon).name().stringValue();\n+                                            if (cn.endsWith(\";\"))\n+                                                buf.append(cn);\n+                                            else\n+                                                buf.append('L').append(cn).append(';');\n+                                        } else {\n+                                            break decode;\n+                                        }\n+                                    } else {\n+                                        break decode;\n+                                    }\n+                                    if (rtype == null) {\n+                                        \/\/ first arg is treated differently\n+                                        rtype = buf.toString();\n+                                        buf.setLength(0);\n+                                        buf.append('(');\n@@ -824,4 +1103,0 @@\n-                                    buf.append(tchar);\n-                                } else {\n-                                    \/\/ should not happen, but...\n-                                    buf.append('L').append(argClass.getName().replace('.','\/')).append(';');\n@@ -829,10 +1104,34 @@\n-                            } else if (typeArg instanceof Constant) {\n-                                Constant argCon = (Constant) typeArg;\n-                                if (argCon.tag == CONSTANT_Class) {\n-                                    String cn = pool.get(argCon.itemIndex()).itemString();\n-                                    if (cn.endsWith(\";\"))\n-                                        buf.append(cn);\n-                                    else\n-                                        buf.append('L').append(cn).append(';');\n-                                } else {\n-                                    break decode;\n+                                buf.append(')').append(rtype);\n+                                con = con = makeMethodTypeCon(buf.toString());\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            }\n+                            case \"lookup\":\n+                            case \"dynamicInvoker\":\n+                                args.clear(); args.add(intrinsic);\n+                                continue;\n+                            case \"lookupClass\":\n+                                if(args.equals(Arrays.asList(\"lookup\"))) {\n+                                    args.clear(); args.add(classModel.thisClass());\n+                                    continue;\n+                                }\n+                                break;\n+                            case \"invoke\":\n+                            case \"invokeGeneric\":\n+                            case \"invokeWithArguments\":\n+                                if (patternMark != 'I')  break decode;\n+                                if (\"invokeWithArguments\".equals(intrinsic))\n+                                    flattenVarargs(args);\n+                                bsmArgs = new ArrayList<>(args);\n+                                args.clear(); args.add(\"invokeGeneric\");\n+                                continue;\n+                            case \"Integer.valueOf\":\n+                            case \"Float.valueOf\":\n+                            case \"Long.valueOf\":\n+                            case \"Double.valueOf\":\n+                                removeEmptyJVMSlots(args);\n+                                if(args.size() == 1 ) {\n+                                    arg = args.remove(0);\n+                                    if (arg instanceof Number) {\n+                                        args.add(arg); continue;\n+                                    }\n@@ -840,1 +1139,0 @@\n-                            } else {\n@@ -842,7 +1140,8 @@\n-                            }\n-                            if (rtype == null) {\n-                                \/\/ first arg is treated differently\n-                                rtype = buf.toString();\n-                                buf.setLength(0);\n-                                buf.append('(');\n-                            }\n+                            case \"StringBuilder.append\":\n+                                removeEmptyJVMSlots(args);\n+                                args.subList(1, args.size()).clear();\n+                                continue;\n+                            case \"StringBuilder.toString\":\n+                                args.clear();\n+                                args.add(intrinsic);\n+                                continue;\n@@ -850,13 +1149,7 @@\n-                        buf.append(')').append(rtype);\n-                        con = con = makeMethodTypeCon(buf.toString());\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    }\n-                    case \"lookup\":\n-                    case \"dynamicInvoker\":\n-                        args.clear(); args.add(intrinsic);\n-                        continue;\n-                    case \"lookupClass\":\n-                        if (args.equals(Arrays.asList(\"lookup\"))) {\n-                            \/\/ fold lookup().lookupClass() to the enclosing class\n-                            args.clear(); args.add(pool.get(cf.thisc));\n+                        if(!hasReceiver && ownMethod != null && patternMark != 0) {\n+                            con = Constants.get(ownMethod);\n+                            if (con == null)  break decode;\n+                            args.clear(); args.add(con);\n+                            continue;\n+                        } else if (methType.endsWith(\")V\")) {\n+                            args.clear();\n@@ -864,23 +1157,0 @@\n-                        }\n-                        break;\n-                    case \"invoke\":\n-                    case \"invokeGeneric\":\n-                    case \"invokeWithArguments\":\n-                        if (patternMark != 'I')  break decode;\n-                        if (\"invokeWithArguments\".equals(intrinsic))\n-                            flattenVarargs(args);\n-                        bsmArgs = new ArrayList<>(args);\n-                        args.clear(); args.add(\"invokeGeneric\");\n-                        continue;\n-                    case \"Integer.valueOf\":\n-                    case \"Float.valueOf\":\n-                    case \"Long.valueOf\":\n-                    case \"Double.valueOf\":\n-                        removeEmptyJVMSlots(args);\n-                        if (args.size() == 1) {\n-                            arg = args.remove(0);\n-                            assert(3456 == (CONSTANT_Integer*1000 + CONSTANT_Float*100 + CONSTANT_Long*10 + CONSTANT_Double));\n-                            if (isConstant(arg, CONSTANT_Integer + \"IFLD\".indexOf(intrinsic.charAt(0)))\n-                                || arg instanceof Number) {\n-                                args.add(arg); continue;\n-                            }\n@@ -889,9 +1159,0 @@\n-                    case \"StringBuilder.append\":\n-                        \/\/ allow calls like (\"value = \"+x)\n-                        removeEmptyJVMSlots(args);\n-                        args.subList(1, args.size()).clear();\n-                        continue;\n-                    case \"StringBuilder.toString\":\n-                        args.clear();\n-                        args.add(intrinsic);\n-                        continue;\n@@ -899,22 +1160,13 @@\n-                    if (!hasRecv && ownMethod != null && patternMark != 0) {\n-                        con = constants.get(ownMethod);\n-                        if (con == null)  break decode;\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    } else if (type.endsWith(\")V\")) {\n-                        \/\/ allow calls like println(\"reached the pattern method\")\n-                        args.clear();\n-                        continue;\n-                    }\n-                    break decode;  \/\/ bail out for most calls\n-                }\n-                case opc_areturn:\n-                {\n-                    ++branchCount;\n-                    if (bsmArgs != null) {\n-                        \/\/ parse bsmArgs as (MH, lookup, String, MT, [extra])\n-                        Constant indyCon = makeInvokeDynamicCon(bsmArgs);\n-                        if (indyCon != null) {\n-                            Constant typeCon = (Constant) bsmArgs.get(3);\n-                            indySignatures.put(m, pool.getString(typeCon.itemIndex()));\n-                            return indyCon;\n+                    case ARETURN:\n+                    {\n+                        ++branchCount;\n+                        if(bsmArgs != null){\n+                            \/\/ parse bsmArgs as (MH, lookup, String, MT, [extra])\n+                            PoolEntry indyCon = makeInvokeDynamicCon(bsmArgs);\n+                            if (indyCon != null) {\n+                                PoolEntry typeCon = (PoolEntry) bsmArgs.get(3);\n+                                IndySignatures.put(method, ((MethodTypeEntry) typeCon).descriptor().stringValue());\n+                                return indyCon;\n+                            }\n+                            System.err.println(method+\": inscrutable bsm arguments: \"+bsmArgs);\n+                            break decode;\n@@ -922,2 +1174,6 @@\n-                        System.err.println(m+\": inscrutable bsm arguments: \"+bsmArgs);\n-                        break decode;  \/\/ bail out\n+                        arg = jvm.pop();\n+                        if(branchCount == 2 && UNKNOWN_CON.equals(arg))\n+                            break;\n+                        if((arg instanceof PoolEntry) && ((PoolEntry) arg).tag() == wantedTag)\n+                            return (PoolEntry) arg;\n+                        break decode;\n@@ -925,14 +1181,6 @@\n-                    arg = jvm.pop();\n-                    if (branchCount == 2 && UNKNOWN_CON.equals(arg))\n-                        break;  \/\/ merge to next path\n-                    if (isConstant(arg, wantTag))\n-                        return (Constant) arg;\n-                    break decode;  \/\/ bail out\n-                }\n-                default:\n-                    if (jvm.stackMotion(i.bc))  break;\n-                    if (bc >= opc_nconst_MIN && bc <= opc_nconst_MAX)\n-                        { jvm.push(INSTRUCTION_CONSTANTS[bc - opc_nconst_MIN]); break; }\n-                    if (patternMark == 'I') {\n-                        \/\/ these support caching paths in INDY_x methods\n-                        if (bc == opc_aload || bc >= opc_aload_0 && bc <= opc_aload_MAX)\n+                    default:\n+                        if(jvm.stackMotion(instruction.opcode().bytecode())) break;\n+                        if (bc >= ICONST_M1 && bc <= DCONST_1)\n+                        { jvm.push(INSTRUCTION_CONSTANTS[bc - ICONST_M1]); break; }\n+                        if (patternMark == 'I') {\n+                            if (bc == ALOAD || bc >= ALOAD_0 && bc <= ALOAD_3)\n@@ -940,1 +1188,1 @@\n-                        if (bc == opc_astore || bc >= opc_astore_0 && bc <= opc_astore_MAX)\n+                            if (bc == ASTORE || bc >= ASTORE_0 && bc <= ASTORE_3)\n@@ -942,18 +1190,20 @@\n-                        switch (bc) {\n-                        case opc_getfield:\n-                        case opc_aaload:\n-                            jvm.push(UNKNOWN_CON); break;\n-                        case opc_ifnull:\n-                        case opc_ifnonnull:\n-                            \/\/ ignore branch target\n-                            if (++branchCount != 1)  break decode;\n-                            jvm.pop();\n-                            break;\n-                        case opc_checkcast:\n-                            arg = jvm.top();\n-                            if (\"invokeWithArguments\".equals(arg) ||\n-                                \"invokeGeneric\".equals(arg))\n-                                break;  \/\/ assume it is a helpful cast\n-                            break decode;\n-                        default:\n-                            break decode;  \/\/ bail out\n+                            switch (bc) {\n+                                case GETFIELD:\n+                                case AALOAD:\n+                                    jvm.push(UNKNOWN_CON); break;\n+                                case IFNULL:\n+                                case IFNONNULL:\n+                                    \/\/ ignore branch target\n+                                    if (++branchCount != 1)  break decode;\n+                                    jvm.pop();\n+                                    break;\n+                                case CHECKCAST:\n+                                    arg = jvm.top();\n+                                    if (\"invokeWithArguments\".equals(arg) ||\n+                                            \"invokeGeneric\".equals(arg))\n+                                        break;\n+                                    break decode;\n+                                default:\n+                                    break decode;  \/\/ bail out\n+                            }\n+                            continue decode;\n@@ -961,4 +1211,2 @@\n-                        continue decode; \/\/ go to next instruction\n-                    }\n-                    break decode;  \/\/ bail out\n-                } \/\/end switch\n+                        break decode;  \/\/ bail out\n+                }\n@@ -966,1 +1214,1 @@\n-            System.err.println(m+\": bailout on \"+i+\" jvm stack: \"+jvm.stack);\n+            System.err.println(method+\": bailout ==> jvm stack: \"+jvm.stack);\n@@ -979,11 +1227,12 @@\n-        private boolean isConstant(Object x, int tag) {\n-            return x instanceof Constant && ((Constant)x).tag == tag;\n-        }\n-        private Constant makeMethodTypeCon(Object x) {\n-            short utfIndex;\n-            if (x instanceof String)\n-                utfIndex = (short) cf.pool.addConstant(CONSTANT_Utf8, x).index;\n-            else if (isConstant(x, CONSTANT_String))\n-                utfIndex = ((Constant)x).itemIndex();\n-            else  return null;\n-            return cf.pool.addConstant(CONSTANT_MethodType, utfIndex);\n+        private PoolEntry makeMethodTypeCon(Object x){\n+            Utf8Entry utf8Entry;\n+\n+            if (x instanceof String) {\n+                utf8Entry = poolBuilder.utf8Entry((String) x);\n+            } else if (x instanceof PoolEntry && ((PoolEntry) x).tag() == TAG_STRING) {\n+                utf8Entry = ((StringEntry) x).utf8();\n+            } else {\n+                return null;\n+            }\n+\n+            return poolBuilder.methodTypeEntry(utf8Entry);\n@@ -991,3 +1240,4 @@\n-        private Constant parseMemberLookup(byte refKind, List<Object> args) {\n-            \/\/ E.g.: lookup().findStatic(Foo.class, \"name\", MethodType)\n-            if (args.size() != 4)  return null;\n+\n+        private PoolEntry parseMemberLookup(byte refKind, List<Object> args){\n+            \/\/E.g.: lookup().findStatic(Foo.class, \"name\", MethodType)\n+            if(args.size() != 4) return null;\n@@ -995,2 +1245,5 @@\n-            if (!\"lookup\".equals(args.get(argi++)))  return null;\n-            short refindex, cindex, ntindex, nindex, tindex;\n+            if(!\"lookup\".equals(args.get(argi++))) return null;\n+\n+            NameAndTypeEntry nt;\n+            Utf8Entry name, type;\n+            ClassEntry cl;\n@@ -998,7 +1251,10 @@\n-            if (!isConstant(con = args.get(argi++), CONSTANT_Class))  return null;\n-            cindex = (short)((Constant)con).index;\n-            if (!isConstant(con = args.get(argi++), CONSTANT_String))  return null;\n-            nindex = ((Constant)con).itemIndex();\n-            if (isConstant(con = args.get(argi++), CONSTANT_MethodType) ||\n-                isConstant(con, CONSTANT_Class)) {\n-                tindex = ((Constant)con).itemIndex();\n+\n+            if(!((con = args.get(argi++)) instanceof ClassEntry)) return null;\n+            cl = (ClassEntry) con;\n+\n+            if(!((con = args.get(argi++)) instanceof StringEntry)) return null;\n+            name = ((StringEntry) con).utf8();\n+\n+            if(((con = args.get(argi++)) instanceof MethodTypeEntry) || (con instanceof ClassEntry)){\n+                assert con instanceof MethodTypeEntry;\n+                type = ((MethodTypeEntry) con).descriptor();\n@@ -1006,9 +1262,16 @@\n-            ntindex = (short) cf.pool.addConstant(CONSTANT_NameAndType,\n-                    new Short[]{ nindex, tindex }).index;\n-            byte reftag = CONSTANT_Method;\n-            if (refKind <= REF_putStatic)\n-                reftag = CONSTANT_Field;\n-            else if (refKind == REF_invokeInterface)\n-                reftag = CONSTANT_InterfaceMethod;\n-            Constant ref = cf.pool.addConstant(reftag, new Short[]{ cindex, ntindex });\n-            return cf.pool.addConstant(CONSTANT_MethodHandle, new Object[]{ refKind, (short)ref.index });\n+\n+            nt = poolBuilder.nameAndTypeEntry(name,type);\n+\n+            MemberRefEntry ref;\n+            if(refKind <= (byte) STATIC_SETTER.refKind){\n+                 ref = poolBuilder.fieldRefEntry(cl, nt);\n+                return poolBuilder.methodHandleEntry(refKind, ref);\n+            }\n+            else if(refKind == (byte) INTERFACE_VIRTUAL.refKind){\n+                ref = poolBuilder.interfaceMethodRefEntry(cl, nt);\n+                return poolBuilder.methodHandleEntry(refKind, ref);\n+            }\n+            else{\n+                ref = poolBuilder.methodRefEntry(cl, nt);\n+            }\n+            return poolBuilder.methodHandleEntry(refKind, ref);\n@@ -1016,1 +1279,2 @@\n-        private Constant makeInvokeDynamicCon(List<Object> args) {\n+\n+        private PoolEntry makeInvokeDynamicCon(List<Object> args) {\n@@ -1019,1 +1283,1 @@\n-            if (args.size() < 4)  return null;\n+            if(args.size() < 4) return null;\n@@ -1021,1 +1285,0 @@\n-            short nindex, tindex, ntindex, bsmindex;\n@@ -1023,2 +1286,7 @@\n-            if (!isConstant(con = args.get(argi++), CONSTANT_MethodHandle))  return null;\n-            bsmindex = (short) ((Constant)con).index;\n+            Utf8Entry name, type;\n+            NameAndTypeEntry nt;\n+            MethodHandleEntry bsm;\n+\n+            if (!((con = args.get(argi++)) instanceof MethodHandleEntry)) return null;\n+            bsm = ((MethodHandleEntry) con);\n+\n@@ -1026,6 +1294,8 @@\n-            if (!isConstant(con = args.get(argi++), CONSTANT_String))  return null;\n-            nindex = ((Constant)con).itemIndex();\n-            if (!isConstant(con = args.get(argi++), CONSTANT_MethodType))  return null;\n-            tindex = ((Constant)con).itemIndex();\n-            ntindex = (short) cf.pool.addConstant(CONSTANT_NameAndType,\n-                                                  new Short[]{ nindex, tindex }).index;\n+            if (!((con = args.get(argi++)) instanceof StringEntry)) return null;\n+            name = ((StringEntry) con).utf8();\n+\n+            if (!((con = args.get(argi++)) instanceof MethodTypeEntry)) return null;\n+            type = ((MethodTypeEntry) con).descriptor();\n+\n+            nt = poolBuilder.nameAndTypeEntry(name, type);\n+\n@@ -1045,1 +1315,1 @@\n-            List<Short> extraArgIndexes = new CountedList<>(Short.class);\n+            List<LoadableConstantEntry> extraArgConstants = new ArrayList<>();\n@@ -1048,6 +1318,4 @@\n-                    Object num = null; byte numTag = 0;\n-                    if (x instanceof Integer) { num = x; numTag = CONSTANT_Integer; }\n-                    if (x instanceof Float)   { num = Float.floatToRawIntBits((Float)x); numTag = CONSTANT_Float; }\n-                    if (x instanceof Long)    { num = x; numTag = CONSTANT_Long; }\n-                    if (x instanceof Double)  { num = Double.doubleToRawLongBits((Double)x); numTag = CONSTANT_Double; }\n-                    if (num != null)  x = cf.pool.addConstant(numTag, x);\n+                    if (x instanceof Integer) { x = poolBuilder.intEntry((Integer) x); }\n+                    if (x instanceof Float)   { x = poolBuilder.floatEntry((Float) x); }\n+                    if (x instanceof Long)    { x = poolBuilder.longEntry((Long) x); }\n+                    if (x instanceof Double)  { x = poolBuilder.doubleEntry((Double) x); }\n@@ -1055,1 +1323,1 @@\n-                if (!(x instanceof Constant)) {\n+                if (!(x instanceof PoolEntry)) {\n@@ -1059,1 +1327,2 @@\n-                extraArgIndexes.add((short) ((Constant)x).index);\n+                assert x instanceof LoadableConstantEntry;\n+                extraArgConstants.add(((LoadableConstantEntry) x));\n@@ -1061,3 +1330,4 @@\n-            List<Object[]> specs = bootstrapMethodSpecifiers(true);\n-            int specindex = -1;\n-            Object[] spec = new Object[]{ bsmindex, extraArgIndexes };\n+\n+            List<Object[]> specs = bootstrap_MethodSpecifiers();\n+            int specIndex = -1;\n+            Object[] spec = new Object[]{ bsm.index(), extraArgConstants };\n@@ -1066,1 +1336,1 @@\n-                    specindex = specs.indexOf(spec1);\n+                    specIndex = specs.indexOf(spec1);\n@@ -1071,2 +1341,1 @@\n-            if (specindex == -1) {\n-                specindex = (short) specs.size();\n+            if (specIndex == -1) {\n@@ -1076,3 +1345,0 @@\n-            return cf.pool.addConstant(CONSTANT_InvokeDynamic,\n-                        new Short[]{ (short)specindex, ntindex });\n-        }\n@@ -1080,27 +1346,2 @@\n-        List<Object[]> bootstrapMethodSpecifiers(boolean createIfNotFound) {\n-            Attr bsms = cf.findAttr(\"BootstrapMethods\");\n-            if (bsms == null) {\n-                if (!createIfNotFound)  return null;\n-                bsms = new Attr(cf, \"BootstrapMethods\", new byte[]{0,0});\n-                assert(bsms == cf.findAttr(\"BootstrapMethods\"));\n-            }\n-            if (bsms.item instanceof byte[]) {\n-                \/\/ unflatten\n-                List<Object[]> specs = new CountedList<>(Object[].class);\n-                DataInputStream in = new DataInputStream(new ByteArrayInputStream((byte[]) bsms.item));\n-                try {\n-                    int len = (char) in.readShort();\n-                    for (int i = 0; i < len; i++) {\n-                        short bsm = in.readShort();\n-                        int argc = (char) in.readShort();\n-                        List<Short> argv = new CountedList<>(Short.class);\n-                        for (int j = 0; j < argc; j++)\n-                            argv.add(in.readShort());\n-                        specs.add(new Object[]{ bsm, argv });\n-                    }\n-                } catch (IOException ex) { throw new InternalError(); }\n-                bsms.item = specs;\n-            }\n-            @SuppressWarnings(\"unchecked\")\n-            List<Object[]> specs = (List<Object[]>) bsms.item;\n-            return specs;\n+            BootstrapMethodEntry bsmEntry = poolBuilder.bsmEntry(bsm, extraArgConstants);\n+            return poolBuilder.invokeDynamicEntry(bsmEntry, nt);\n@@ -1108,1 +1349,0 @@\n-    }\n@@ -1110,50 +1350,6 @@\n-    private DataInputStream openInput(File f) throws IOException {\n-        return new DataInputStream(new BufferedInputStream(new FileInputStream(f)));\n-    }\n-\n-    private DataOutputStream openOutput(File f) throws IOException {\n-        if (!overwrite && f.exists())\n-            throw new IOException(\"file already exists: \"+f);\n-        ensureDirectory(f.getParentFile());\n-        return new DataOutputStream(new BufferedOutputStream(new FileOutputStream(f)));\n-    }\n-\n-    static byte[] readRawBytes(DataInputStream in, int size) throws IOException {\n-        byte[] bytes = new byte[size];\n-        int nr = in.read(bytes);\n-        if (nr != size)\n-            throw new InternalError(\"wrong size: \"+nr);\n-        return bytes;\n-    }\n-\n-    private interface Chunk {\n-        void readFrom(DataInputStream in) throws IOException;\n-        void writeTo(DataOutputStream out) throws IOException;\n-    }\n-\n-    private static class CountedList<T> extends ArrayList<T> implements Chunk {\n-        final Class<? extends T> itemClass;\n-        final int rowlen;\n-        CountedList(Class<? extends T> itemClass, int rowlen) {\n-            this.itemClass = itemClass;\n-            this.rowlen = rowlen;\n-        }\n-        CountedList(Class<? extends T> itemClass) { this(itemClass, -1); }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            int count = in.readUnsignedShort();\n-            while (size() < count) {\n-                if (rowlen < 0) {\n-                    add(readInput(in, itemClass));\n-                } else {\n-                    Class<?> elemClass = itemClass.getComponentType();\n-                    Object[] row = (Object[]) java.lang.reflect.Array.newInstance(elemClass, rowlen);\n-                    for (int i = 0; i < rowlen; i++)\n-                        row[i] = readInput(in, elemClass);\n-                    add(itemClass.cast(row));\n-                }\n-            }\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            out.writeShort((short)size());\n-            for (T item : this) {\n-                writeOutput(out, item);\n+        List<Object[]> bootstrap_MethodSpecifiers() {\n+            List<Object[]> specs = new ArrayList<>();\n+            int count = classModel.constantPool().bootstrapMethodCount();\n+            if (count == 0){\n+                poolBuilder.utf8Entry(\"BootstrapMethods\");\n+                return specs;\n@@ -1161,2 +1357,0 @@\n-        }\n-    }\n@@ -1164,80 +1358,5 @@\n-    private static <T> T readInput(DataInputStream in, Class<T> dataClass) throws IOException {\n-        Object data;\n-        if (dataClass == Integer.class) {\n-            data = in.readInt();\n-        } else if (dataClass == Short.class) {\n-            data = in.readShort();\n-        } else if (dataClass == Byte.class) {\n-            data = in.readByte();\n-        } else if (dataClass == String.class) {\n-            data = in.readUTF();\n-        } else if (Chunk.class.isAssignableFrom(dataClass)) {\n-            T obj;\n-            try { obj = dataClass.getDeclaredConstructor().newInstance(); }\n-                catch (Exception ex) { throw new RuntimeException(ex); }\n-            ((Chunk)obj).readFrom(in);\n-            data = obj;\n-        } else {\n-            throw new InternalError(\"bad input datum: \"+dataClass);\n-        }\n-        return dataClass.cast(data);\n-    }\n-    private static <T> T readInput(byte[] bytes, Class<T> dataClass) {\n-        try {\n-            return readInput(new DataInputStream(new ByteArrayInputStream(bytes)), dataClass);\n-        } catch (IOException ex) {\n-            throw new InternalError();\n-        }\n-    }\n-    private static void readInputs(DataInputStream in, Object... data) throws IOException {\n-        for (Object x : data)  ((Chunk)x).readFrom(in);\n-    }\n-\n-    private static void writeOutput(DataOutputStream out, Object data) throws IOException {\n-        if (data == null) {\n-            return;\n-        } if (data instanceof Integer) {\n-            out.writeInt((Integer)data);\n-        } else if (data instanceof Long) {\n-            out.writeLong((Long)data);\n-        } else if (data instanceof Short) {\n-            out.writeShort((Short)data);\n-        } else if (data instanceof Byte) {\n-            out.writeByte((Byte)data);\n-        } else if (data instanceof String) {\n-            out.writeUTF((String)data);\n-        } else if (data instanceof byte[]) {\n-            out.write((byte[])data);\n-        } else if (data instanceof Object[]) {\n-            for (Object x : (Object[]) data)\n-                writeOutput(out, x);\n-        } else if (data instanceof Chunk) {\n-            Chunk x = (Chunk) data;\n-            x.writeTo(out);\n-        } else if (data instanceof List) {\n-            for (Object x : (List<?>) data)\n-                writeOutput(out, x);\n-        } else {\n-            throw new InternalError(\"bad output datum: \"+data+\" : \"+data.getClass().getName());\n-        }\n-    }\n-    private static void writeOutputs(DataOutputStream out, Object... data) throws IOException {\n-        for (Object x : data)  writeOutput(out, x);\n-    }\n-\n-    public abstract static class Outer {\n-        public abstract List<? extends Inner> inners();\n-        protected void linkInners() {\n-            for (Inner i : inners()) {\n-                i.linkOuter(this);\n-                if (i instanceof Outer)\n-                    ((Outer)i).linkInners();\n-            }\n-        }\n-        public <T extends Outer> T outer(Class<T> c) {\n-            for (Outer walk = this;; walk = ((Inner)walk).outer()) {\n-                if (c.isInstance(walk))\n-                    return c.cast(walk);\n-                \/\/if (!(walk instanceof Inner))  return null;\n-            }\n-        }\n+            for (int i = 0; i < count; i++) {\n+                int bsmRef = classModel.constantPool().bootstrapMethodEntry(i).bsmIndex();\n+                List<LoadableConstantEntry> bsmArgs = new ArrayList<>();\n+                for (LoadableConstantEntry lce : classModel.constantPool().bootstrapMethodEntry(i).arguments()){\n+                    bsmArgs.add(lce);\n@@ -1245,49 +1364,2 @@\n-        public abstract List<Attr> attrs();\n-        public Attr findAttr(String name) {\n-            return findAttr(outer(ClassFile.class).pool.stringIndex(name, false));\n-        }\n-        public Attr findAttr(int name) {\n-            if (name == 0)  return null;\n-            for (Attr a : attrs()) {\n-                if (a.name == name)  return a;\n-            }\n-            return null;\n-        }\n-    }\n-    public interface Inner { Outer outer(); void linkOuter(Outer o); }\n-    public abstract static class InnerOuter extends Outer implements Inner {\n-        public Outer outer;\n-        public Outer outer() { return outer; }\n-        public void linkOuter(Outer o) { assert(outer == null); outer = o; }\n-    }\n-    public static class Constant<T> implements Chunk {\n-        public final byte tag;\n-        public final T item;\n-        public final int index;\n-        public Constant(int index, byte tag, T item) {\n-            this.index = index;\n-            this.tag = tag;\n-            this.item = item;\n-        }\n-        public Constant checkTag(byte tag) {\n-            if (this.tag != tag)  throw new InternalError(this.toString());\n-            return this;\n-        }\n-        public String itemString() { return (String)item; }\n-        public Short itemIndex() { return (Short)item; }\n-        public Short[] itemIndexes() { return (Short[])item; }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            throw new InternalError(\"do not call\");\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, tag, item);\n-        }\n-        public boolean equals(Object x) { return (x instanceof Constant && equals((Constant)x)); }\n-        public boolean equals(Constant that) {\n-            return (this.tag == that.tag && this.itemAsComparable().equals(that.itemAsComparable()));\n-        }\n-        public int hashCode() { return (tag * 31) + this.itemAsComparable().hashCode(); }\n-        public Object itemAsComparable() {\n-            switch (tag) {\n-            case CONSTANT_Double:   return Double.longBitsToDouble((Long)item);\n-            case CONSTANT_Float:    return Float.intBitsToFloat((Integer)item);\n+                }\n+                specs.add(new Object[]{ bsmRef, bsmArgs});\n@@ -1295,14 +1367,1 @@\n-            return (item instanceof Object[] ? Arrays.asList((Object[])item) : item);\n-        }\n-        public String toString() {\n-            String itstr = String.valueOf(itemAsComparable());\n-            return (index + \":\" + tagName(tag) + (itstr.startsWith(\"[\")?\"\":\"=\") + itstr);\n-        }\n-        private static String[] TAG_NAMES;\n-        public static String tagName(byte tag) {  \/\/ used for error messages\n-            if (TAG_NAMES == null)\n-                TAG_NAMES = (\"None Utf8 Unicode Integer Float Long Double Class String\"\n-                             +\" Fieldref Methodref InterfaceMethodref NameAndType #13 #14\"\n-                             +\" MethodHandle MethodType InvokeDynamic#17 InvokeDynamic\").split(\" \");\n-            if ((tag & 0xFF) >= TAG_NAMES.length)  return \"#\"+(tag & 0xFF);\n-            return TAG_NAMES[tag & 0xFF];\n+            return specs;\n@@ -1312,12 +1371,3 @@\n-    public static class Pool extends CountedList<Constant> implements Chunk {\n-        private Map<String,Short> strings = new TreeMap<>();\n-\n-        public Pool() {\n-            super(Constant.class);\n-        }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            int count = in.readUnsignedShort();\n-            add(null);  \/\/ always ignore first item\n-            while (size() < count) {\n-                readConstant(in);\n-            }\n+    private byte[] openInputIntoBytes(File f) throws IOException{\n+        try{\n+            return Files.readAllBytes(f.toPath());\n@@ -1325,79 +1375,2 @@\n-        public <T> Constant addConstant(byte tag, T item) {\n-            Constant<T> con = new Constant<>(size(), tag, item);\n-            int idx = indexOf(con);\n-            if (idx >= 0)  return get(idx);\n-            add(con);\n-            if (tag == CONSTANT_Utf8)  strings.put((String)item, (short) con.index);\n-            return con;\n-        }\n-        private void readConstant(DataInputStream in) throws IOException {\n-            byte tag = in.readByte();\n-            int index = size();\n-            Object arg;\n-            switch (tag) {\n-            case CONSTANT_Utf8:\n-                arg = in.readUTF();\n-                strings.put((String) arg, (short) size());\n-                break;\n-            case CONSTANT_Integer:\n-            case CONSTANT_Float:\n-                arg = in.readInt(); break;\n-            case CONSTANT_Long:\n-            case CONSTANT_Double:\n-                add(new Constant<>(index, tag, in.readLong()));\n-                add(null);\n-                return;\n-            case CONSTANT_Class:\n-            case CONSTANT_String:\n-                arg = in.readShort(); break;\n-            case CONSTANT_Field:\n-            case CONSTANT_Method:\n-            case CONSTANT_InterfaceMethod:\n-            case CONSTANT_NameAndType:\n-            case CONSTANT_InvokeDynamic:\n-                \/\/ read an ordered pair\n-                arg = new Short[] { in.readShort(), in.readShort() };\n-                break;\n-            case CONSTANT_MethodHandle:\n-                \/\/ read an ordered pair; first part is a u1 (not u2)\n-                arg = new Object[] { in.readByte(), in.readShort() };\n-                break;\n-            case CONSTANT_MethodType:\n-                arg = in.readShort(); break;\n-            default:\n-                throw new InternalError(\"bad CP tag \"+tag);\n-            }\n-            add(new Constant<>(index, tag, arg));\n-        }\n-\n-        \/\/ Access:\n-        public Constant get(int index) {\n-            \/\/ extra 1-bits get into the shorts\n-            return super.get((char) index);\n-        }\n-        String getString(byte tag, short index) {\n-            get(index).checkTag(tag);\n-            return getString(index);\n-        }\n-        String getString(short index) {\n-            Object v = get(index).item;\n-            if (v instanceof Short)\n-                v = get((Short)v).checkTag(CONSTANT_Utf8).item;\n-            return (String) v;\n-        }\n-        String[] getStrings(Short[] indexes) {\n-            String[] res = new String[indexes.length];\n-            for (int i = 0; i < indexes.length; i++)\n-                res[i] = getString(indexes[i]);\n-            return res;\n-        }\n-        int stringIndex(String name, boolean createIfNotFound) {\n-            Short x = strings.get(name);\n-            if (x != null)  return (char)(int) x;\n-            if (!createIfNotFound)  return 0;\n-            return addConstant(CONSTANT_Utf8, name).index;\n-        }\n-        Short[] getMemberRef(short index) {\n-            Short[] cls_nnt = get(index).itemIndexes();\n-            Short[] name_type = get(cls_nnt[1]).itemIndexes();\n-            return new Short[]{ cls_nnt[0], name_type[0], name_type[1] };\n+        catch(IOException e){\n+            throw new IOException(\"Error reading file: \"+f);\n@@ -1407,65 +1380,2 @@\n-    public class ClassFile extends Outer implements Chunk {\n-        ClassFile(File f) throws IOException {\n-            DataInputStream in = openInput(f);\n-            try {\n-                readFrom(in);\n-            } finally {\n-                if (in != null)  in.close();\n-            }\n-        }\n-\n-        public int                magic, version;  \/\/ <min:maj>\n-        public final Pool         pool       = new Pool();\n-        public short              access, thisc, superc;\n-        public final List<Short>  interfaces = new CountedList<>(Short.class);\n-        public final List<Field>  fields     = new CountedList<>(Field.class);\n-        public final List<Method> methods    = new CountedList<>(Method.class);\n-        public final List<Attr>   attrs      = new CountedList<>(Attr.class);\n-\n-        public final void readFrom(DataInputStream in) throws IOException {\n-            magic = in.readInt(); version = in.readInt();\n-            if (magic != 0xCAFEBABE)  throw new IOException(\"bad magic number\");\n-            pool.readFrom(in);\n-            Code_index = pool.stringIndex(\"Code\", false);\n-            access = in.readShort(); thisc = in.readShort(); superc = in.readShort();\n-            readInputs(in, interfaces, fields, methods, attrs);\n-            if (in.read() >= 0)  throw new IOException(\"junk after end of file\");\n-            linkInners();\n-        }\n-\n-        void writeTo(File f) throws IOException {\n-            DataOutputStream out = openOutput(f);\n-            try {\n-                writeTo(out);\n-            } finally {\n-                out.close();\n-            }\n-        }\n-\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, magic, version, pool,\n-                         access, thisc, superc, interfaces,\n-                         fields, methods, attrs);\n-        }\n-\n-        public byte[] toByteArray() {\n-            try {\n-                ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-                writeTo(new DataOutputStream(buf));\n-                return buf.toByteArray();\n-            } catch (IOException ex) {\n-                throw new InternalError();\n-            }\n-        }\n-\n-        public List<Inner> inners() {\n-            List<Inner> inns = new ArrayList<>();\n-            inns.addAll(fields); inns.addAll(methods); inns.addAll(attrs);\n-            return inns;\n-        }\n-        public List<Attr> attrs() { return attrs; }\n-\n-        \/\/ derived stuff:\n-        public String nameString() { return pool.getString(CONSTANT_Class, thisc); }\n-        int Code_index;\n-    }\n+    private ClassModel parseClassFile(File f) throws IOException{\n+        byte[] bytes = openInputIntoBytes(f);\n@@ -1473,7 +1383,4 @@\n-    private static <T extends Member> T findMember(List<T> mems, int name, int type) {\n-        if (name == 0 || type == 0)  return null;\n-        for (T m : mems) {\n-            if (m.name == name && m.type == type)  return m;\n-        }\n-        return null;\n-    }\n+        ClassHierarchyResolver classHierarchyResolver = classDesc -> {\n+            \/\/ Treat all classes as interfaces\n+            return ClassHierarchyResolver.ClassHierarchyInfo.ofInterface();\n+        };\n@@ -1481,102 +1388,7 @@\n-    public static class Member extends InnerOuter implements Chunk {\n-        public short access, name, type;\n-        public final List<Attr> attrs = new CountedList<>(Attr.class);\n-        public void readFrom(DataInputStream in) throws IOException {\n-            access = in.readShort(); name = in.readShort(); type = in.readShort();\n-            readInputs(in, attrs);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, access, name, type, attrs);\n-        }\n-        public List<Attr> inners() { return attrs; }\n-        public List<Attr> attrs() { return attrs; }\n-        public ClassFile outer() { return (ClassFile) outer; }\n-        public String nameString() { return outer().pool.getString(CONSTANT_Utf8, name); }\n-        public String typeString() { return outer().pool.getString(CONSTANT_Utf8, type); }\n-        public String toString() {\n-            if (outer == null)  return super.toString();\n-            return nameString() + (this instanceof Method ? \"\" : \":\")\n-                    + simplifyType(typeString());\n-        }\n-    }\n-    public static class Field extends Member {\n-    }\n-    public static class Method extends Member {\n-        public Code code() {\n-            Attr a = findAttr(\"Code\");\n-            if (a == null)  return null;\n-            return (Code) a.item;\n-        }\n-        public Instruction instructions() {\n-            Code code = code();\n-            if (code == null)  return null;\n-            return code.instructions();\n-        }\n-    }\n-\n-    public static class Attr extends InnerOuter implements Chunk {\n-        public short name;\n-        public int size = -1;  \/\/ no pre-declared size\n-        public Object item;\n-\n-        public Attr() {}\n-        public Attr(Outer outer, String name, Object item) {\n-            ClassFile cf = outer.outer(ClassFile.class);\n-            linkOuter(outer);\n-            this.name = (short) cf.pool.stringIndex(name, true);\n-            this.item = item;\n-            outer.attrs().add(this);\n-        }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            name = in.readShort();\n-            size = in.readInt();\n-            item = readRawBytes(in, size);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            out.writeShort(name);\n-            \/\/ write the 4-byte size header and then the contents:\n-            byte[] bytes;\n-            int trueSize;\n-            if (item instanceof byte[]) {\n-                bytes = (byte[]) item;\n-                out.writeInt(trueSize = bytes.length);\n-                out.write(bytes);\n-            } else {\n-                trueSize = flatten(out);\n-                \/\/if (!(item instanceof Code))  System.err.println(\"wrote complex attr name=\"+(int)(char)name+\" size=\"+trueSize+\" data=\"+Arrays.toString(flatten()));\n-            }\n-            if (trueSize != size && size >= 0)\n-                System.err.println(\"warning: attribute size changed \"+size+\" to \"+trueSize);\n-        }\n-        public void linkOuter(Outer o) {\n-            super.linkOuter(o);\n-            if (item instanceof byte[] &&\n-                outer instanceof Method &&\n-                ((Method)outer).outer().Code_index == name) {\n-                    item = readInput((byte[])item, Code.class);\n-            }\n-        }\n-        public List<Inner> inners() {\n-            if (item instanceof Inner)\n-                return Collections.nCopies(1, (Inner)item);\n-            return Collections.emptyList();\n-        }\n-        public List<Attr> attrs() { return null; }  \/\/ Code overrides this\n-        public byte[] flatten() {\n-            ByteArrayOutputStream buf = new ByteArrayOutputStream(Math.max(20, size));\n-            flatten(buf);\n-            return buf.toByteArray();\n-        }\n-        public int flatten(DataOutputStream out) throws IOException {\n-            ByteArrayOutputStream buf = new ByteArrayOutputStream(Math.max(20, size));\n-            int trueSize = flatten(buf);\n-            out.writeInt(trueSize);\n-            buf.writeTo(out);\n-            return trueSize;\n-        }\n-        private int flatten(ByteArrayOutputStream buf) {\n-            try {\n-                writeOutput(new DataOutputStream(buf), item);\n-                return buf.size();\n-            } catch (IOException ex) {\n-                throw new InternalError();\n+        try {\n+            List<VerifyError> errors = of(ClassHierarchyResolverOption.of(classHierarchyResolver)).verify(bytes);\n+            if (!errors.isEmpty()) {\n+                for (VerifyError e : errors) {\n+                    System.err.println(e.getMessage());\n+                }\n+                throw new IOException(\"Verification failed\");\n@@ -1584,0 +1396,2 @@\n+        } catch (IOException e) {\n+            System.err.println(e.getMessage());\n@@ -1585,9 +1399,0 @@\n-        public String nameString() {\n-            ClassFile cf = outer(ClassFile.class);\n-            if (cf == null)  return \"#\"+name;\n-            return cf.pool.getString(name);\n-        }\n-        public String toString() {\n-            return nameString()+(size < 0 ? \"=\" : \"[\"+size+\"]=\")+item;\n-        }\n-    }\n@@ -1595,19 +1400,1 @@\n-    public static class Code extends InnerOuter implements Chunk {\n-        public short stacks, locals;\n-        public byte[] bytes;\n-        public final List<Short[]> etable = new CountedList<>(Short[].class, 4);\n-        public final List<Attr> attrs = new CountedList<>(Attr.class);\n-        \/\/ etable[N] = (N)*{ startpc, endpc, handlerpc, catchtype }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            stacks = in.readShort(); locals = in.readShort();\n-            bytes = readRawBytes(in, in.readInt());\n-            readInputs(in, etable, attrs);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, stacks, locals, bytes.length, bytes, etable, attrs);\n-        }\n-        public List<Attr> inners() { return attrs; }\n-        public List<Attr> attrs() { return attrs; }\n-        public Instruction instructions() {\n-            return new Instruction(bytes, 0);\n-        }\n+        return ClassFile.of().parse(bytes);\n@@ -1616,73 +1403,0 @@\n-    \/\/ lots of constants\n-    private static final byte\n-        CONSTANT_Utf8              = 1,\n-        CONSTANT_Integer           = 3,\n-        CONSTANT_Float             = 4,\n-        CONSTANT_Long              = 5,\n-        CONSTANT_Double            = 6,\n-        CONSTANT_Class             = 7,\n-        CONSTANT_String            = 8,\n-        CONSTANT_Field             = 9,\n-        CONSTANT_Method            = 10,\n-        CONSTANT_InterfaceMethod   = 11,\n-        CONSTANT_NameAndType       = 12,\n-        CONSTANT_MethodHandle      = 15,  \/\/ JSR 292\n-        CONSTANT_MethodType        = 16,  \/\/ JSR 292\n-        CONSTANT_InvokeDynamic     = 18;  \/\/ JSR 292\n-    private static final byte\n-        REF_getField               = 1,\n-        REF_getStatic              = 2,\n-        REF_putField               = 3,\n-        REF_putStatic              = 4,\n-        REF_invokeVirtual          = 5,\n-        REF_invokeStatic           = 6,\n-        REF_invokeSpecial          = 7,\n-        REF_newInvokeSpecial       = 8,\n-        REF_invokeInterface        = 9;\n-\n-    private static final int\n-        opc_nop                    = 0,\n-        opc_aconst_null            = 1,\n-        opc_nconst_MIN             = 2,  \/\/ iconst_m1\n-        opc_nconst_MAX             = 15, \/\/ dconst_1\n-        opc_bipush                 = 16,\n-        opc_sipush                 = 17,\n-        opc_ldc                    = 18,\n-        opc_ldc_w                  = 19,\n-        opc_ldc2_w                 = 20,\n-        opc_aload                  = 25,\n-        opc_aload_0                = 42,\n-        opc_aload_MAX              = 45,\n-        opc_aaload                 = 50,\n-        opc_astore                 = 58,\n-        opc_astore_0               = 75,\n-        opc_astore_MAX             = 78,\n-        opc_aastore                = 83,\n-        opc_pop                    = 87,\n-        opc_pop2                   = 88,\n-        opc_dup                    = 89,\n-        opc_dup_x1                 = 90,\n-        opc_dup_x2                 = 91,\n-        opc_dup2                   = 92,\n-        opc_dup2_x1                = 93,\n-        opc_dup2_x2                = 94,\n-        opc_swap                   = 95,\n-        opc_tableswitch            = 170,\n-        opc_lookupswitch           = 171,\n-        opc_areturn                = 176,\n-        opc_getstatic              = 178,\n-        opc_putstatic              = 179,\n-        opc_getfield               = 180,\n-        opc_putfield               = 181,\n-        opc_invokevirtual          = 182,\n-        opc_invokespecial          = 183,\n-        opc_invokestatic           = 184,\n-        opc_invokeinterface        = 185,\n-        opc_invokedynamic          = 186,\n-        opc_new                    = 187,\n-        opc_anewarray              = 189,\n-        opc_checkcast              = 192,\n-        opc_ifnull                 = 198,\n-        opc_ifnonnull              = 199,\n-        opc_wide                   = 196;\n-\n@@ -1743,4 +1457,4 @@\n-        assert(insns[opc_lookupswitch].startsWith(\"lookupswitch\"));\n-        assert(insns[opc_tableswitch].startsWith(\"tableswitch\"));\n-        assert(insns[opc_wide].startsWith(\"wide\"));\n-        assert(insns[opc_invokedynamic].startsWith(\"invokedynamic\"));\n+        assert(insns[LOOKUPSWITCH].startsWith(\"lookupswitch\"));\n+        assert(insns[TABLESWITCH].startsWith(\"tableswitch\"));\n+        assert(insns[WIDE].startsWith(\"wide\"));\n+        assert(insns[INVOKEDYNAMIC].startsWith(\"invokedynamic\"));\n@@ -1785,102 +1499,0 @@\n-    public static class Instruction implements Cloneable {\n-        byte[] codeBase;\n-        int pc;\n-        int bc;\n-        int info;\n-        int wide;\n-        int len;\n-        Instruction(byte[] codeBase, int pc) {\n-            this.codeBase = codeBase;\n-            init(pc);\n-        }\n-        public Instruction clone() {\n-            try {\n-                return (Instruction) super.clone();\n-            } catch (CloneNotSupportedException ex) {\n-                throw new InternalError();\n-            }\n-        }\n-        private Instruction init(int pc) {\n-            this.pc = pc;\n-            this.bc = codeBase[pc] & 0xFF;\n-            this.info = INSTRUCTION_INFO[bc];\n-            this.wide = 0;\n-            this.len = (info & 0x0F);\n-            if (len == 0)\n-                computeLength();\n-            return this;\n-        }\n-        Instruction next() {\n-            if (len == 0 && bc != 0)  throw new InternalError();\n-            int npc = pc + len;\n-            if (npc == codeBase.length)\n-                return null;\n-            return init(npc);\n-        }\n-        void forceNext(int newLen) {\n-            bc = opc_nop;\n-            len = newLen;\n-        }\n-\n-        public String toString() {\n-            StringBuilder buf = new StringBuilder();\n-            buf.append(pc).append(\":\").append(INSTRUCTION_NAMES[bc]);\n-            switch (len) {\n-            case 3: buf.append(\" \").append(u2At(1)); break;\n-            case 5: buf.append(\" \").append(u2At(1)).append(\" \").append(u2At(3)); break;\n-            default:  for (int i = 1; i < len; i++)  buf.append(\" \").append(u1At(1));\n-            }\n-            return buf.toString();\n-        }\n-\n-        \/\/ these are the hard parts\n-        private void computeLength() {\n-            int cases;\n-            switch (bc) {\n-            case opc_wide:\n-                bc = codeBase[pc + 1];\n-                info = INSTRUCTION_INFO[bc];\n-                len = ((info >> 4) & 0x0F);\n-                if (len == 0)  throw new RuntimeException(\"misplaced wide bytecode: \"+bc);\n-                return;\n-\n-            case opc_tableswitch:\n-                cases = (u4At(alignedIntOffset(2)) - u4At(alignedIntOffset(1)) + 1);\n-                len = alignedIntOffset(3 + cases*1);\n-                return;\n-\n-            case opc_lookupswitch:\n-                cases = u4At(alignedIntOffset(1));\n-                len = alignedIntOffset(2 + cases*2);\n-                return;\n-\n-            default:\n-                throw new RuntimeException(\"unknown bytecode: \"+bc);\n-            }\n-        }\n-        \/\/ switch code\n-        \/\/ clget the Nth int (where 0 is the first after the opcode itself)\n-        public int alignedIntOffset(int n) {\n-            int pos = pc + 1;\n-            pos += ((-pos) & 0x03);  \/\/ align it\n-            pos += (n * 4);\n-            return pos - pc;\n-        }\n-        public int u1At(int pos) {\n-            return (codeBase[pc+pos] & 0xFF);\n-        }\n-        public int u2At(int pos) {\n-            return (u1At(pos+0)<<8) + u1At(pos+1);\n-        }\n-        public int u4At(int pos) {\n-            return (u2At(pos+0)<<16) + u2At(pos+2);\n-        }\n-        public void u1AtPut(int pos, int x) {\n-            codeBase[pc+pos] = (byte)x;\n-        }\n-        public void u2AtPut(int pos, int x) {\n-            codeBase[pc+pos+0] = (byte)(x >> 8);\n-            codeBase[pc+pos+1] = (byte)(x >> 0);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/indify\/Indify.java","additions":932,"deletions":1320,"binary":false,"changes":2252,"status":"modified"}]}