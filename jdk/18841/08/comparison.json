{"files":[{"patch":"@@ -77,1 +77,1 @@\n-    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_NEWJDK_UPGRADED), \\\n@@ -80,1 +80,1 @@\n-    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n+    DISABLED_WARNINGS := this-escape rawtypes serial options preview, \\\n@@ -82,1 +82,1 @@\n-    JAVAC_FLAGS := -XDstringConcat=inline -Xprefer:newer, \\\n+    JAVAC_FLAGS := -XDstringConcat=inline -Xprefer:newer --enable-preview, \\\n@@ -126,1 +126,2 @@\n-\t$(JAVA_SMALL) -cp $(MICROBENCHMARK_TOOLS_CLASSES) \\\n+\t$(BUILD_JAVA_SMALL) -cp $(MICROBENCHMARK_TOOLS_CLASSES) \\\n+            --enable-preview \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/CallSiteTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/CallStaticInitOrder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/InvokeDynamicPrintArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,10 @@\n-import java.util.*;\n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.NewObjectInstruction;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.reflect.Method;\n@@ -29,1 +37,8 @@\n-import java.util.regex.*;\n+import java.nio.file.Files;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.*;\n@@ -107,0 +122,3 @@\n+    \/**\n+     * Destination file where output will be written.\n+     *\/\n@@ -108,0 +126,4 @@\n+\n+    \/**\n+     * Array of classpath entries, with the default being the current directory.\n+     *\/\n@@ -109,0 +131,5 @@\n+\n+    \/**\n+     * Flag indicating whether to continue processing after encountering an error.\n+     * Default is {@code false}.\n+     *\/\n@@ -110,0 +137,5 @@\n+\n+    \/**\n+     * Flag indicating whether to expand properties in input files.\n+     * Default is {@code false}.\n+     *\/\n@@ -111,0 +143,5 @@\n+\n+    \/**\n+     * Flag indicating whether to overwrite existing files.\n+     * Default is {@code false}.\n+     *\/\n@@ -112,0 +149,5 @@\n+\n+    \/**\n+     * Flag indicating whether to suppress output messages.\n+     * Default is {@code false}.\n+     *\/\n@@ -113,0 +155,5 @@\n+\n+    \/**\n+     * Flag indicating whether to enable verbose output.\n+     * Default is {@code false}.\n+     *\/\n@@ -114,0 +161,5 @@\n+\n+    \/**\n+     * Flag indicating whether to process all items.\n+     * Default is {@code false}.\n+     *\/\n@@ -115,0 +167,4 @@\n+\n+    \/**\n+     * Count of verify specifiers, with the default being -1 indicating no verification.\n+     *\/\n@@ -117,0 +173,12 @@\n+    \/**\n+     * Processes command-line arguments to transform class files by incorporating JSR 292 features.\n+     * <p>\n+     * This method accepts various options and a list of files to be processed. If the '--java' option\n+     * is specified, it runs the application with the provided arguments. Otherwise, it processes\n+     * each file using the {@code indify} method.\n+     * <\/p>\n+     *\n+     * @param av the command-line arguments\n+     * @throws IOException if an I\/O error occurs during file processing\n+     * @throws IllegalArgumentException if the arguments are invalid\n+     *\/\n@@ -120,1 +188,2 @@\n-        if (avl.isEmpty())\n+\n+        if (avl.isEmpty()) {\n@@ -122,2 +191,4 @@\n-        if (\"--java\".equals(avl.get(0))) {\n-            avl.remove(0);\n+        }\n+\n+        if (\"--java\".equals(avl.getFirst())) {\n+            avl.removeFirst();\n@@ -127,1 +198,3 @@\n-                if (ex instanceof RuntimeException)  throw (RuntimeException) ex;\n+                if (ex instanceof RuntimeException) {\n+                    throw (RuntimeException) ex;\n+                }\n@@ -132,0 +205,1 @@\n+\n@@ -137,3 +211,9 @@\n-                if (err == null)  err = ex;\n-                System.err.println(\"failure on \"+a);\n-                if (!keepgoing)  break;\n+                if (err == null) {\n+                    err = ex;\n+                }\n+                System.err.println(\"Failure on \" + a);\n+                if (!keepgoing) {\n+                    break;\n+                } else if (ex != err) {\n+                    err.addSuppressed(ex);\n+                }\n@@ -142,0 +222,1 @@\n+\n@@ -143,1 +224,3 @@\n-            if (err instanceof IOException)  throw (IOException) err;\n+            if (err instanceof IOException) {\n+                throw (IOException) err;\n+            }\n@@ -148,1 +231,8 @@\n-    \/** Execute the given application under a class loader which indifies all application classes. *\/\n+    \/**\n+     *  Execute the given application under a class loader which indifies all application classes.\n+     *\n+     * @param av an array of strings where the first element is the fully qualified name\n+     *           of the main class to be executed, and the remaining elements are arguments\n+     *           to be passed to the main method of the specified class.\n+     * @throws Exception if there is an error during class loading, method retrieval, or invocation.\n+     *\/\n@@ -151,1 +241,1 @@\n-        String mainClassName = avl.remove(0);\n+        String mainClassName = avl.removeFirst();\n@@ -154,2 +244,2 @@\n-        java.lang.reflect.Method main = mainClass.getMethod(\"main\", String[].class);\n-        try { main.setAccessible(true); } catch (SecurityException ex) { }\n+        Method main = mainClass.getMethod(\"main\", String[].class);\n+        try { main.setAccessible(true); } catch (SecurityException ignored) { }\n@@ -159,0 +249,10 @@\n+    \/**\n+     * Parses a list of options and arguments, configuring the application's settings based on the provided options.\n+     *\n+     * @param av a list of strings representing the options and arguments to be parsed.\n+     *           Options are expected to start with a hyphen ('-') or double hyphen ('--').\n+     *           Arguments that do not start with a hyphen are considered as positional arguments and terminate the options parsing.\n+     * @throws IOException if an I\/O error occurs during the processing of options.\n+     * @throws IllegalArgumentException if an unrecognized flag is encountered.\n+     * @throws RuntimeException if no output destination is specified and the overwrite option is not enabled.\n+     *\/\n@@ -161,1 +261,1 @@\n-            String a = av.get(0);\n+            String a = av.getFirst();\n@@ -171,1 +271,1 @@\n-                    return;  \/\/ keep this argument\n+                    return;\n@@ -179,1 +279,1 @@\n-                    keepgoing = booleanOption(a2);  \/\/ print errors but keep going\n+                    keepgoing = booleanOption(a2);\n@@ -182,1 +282,1 @@\n-                    expandProperties = booleanOption(a2);  \/\/ expand property references in subsequent arguments\n+                    expandProperties = booleanOption(a2);\n@@ -185,1 +285,2 @@\n-                    verifySpecifierCount = Integer.valueOf(a2);\n+                        assert a2 != null;\n+                        verifySpecifierCount = Integer.parseInt(a2);\n@@ -188,1 +289,1 @@\n-                    overwrite = booleanOption(a2);  \/\/ overwrite output files\n+                    overwrite = booleanOption(a2);\n@@ -191,1 +292,1 @@\n-                    all = booleanOption(a2);  \/\/ copy all classes, even if no patterns\n+                    all = booleanOption(a2);\n@@ -194,1 +295,1 @@\n-                    quiet = booleanOption(a2);  \/\/ less output\n+                    quiet = booleanOption(a2);\n@@ -197,1 +298,1 @@\n-                    verbose = booleanOption(a2);  \/\/ more output\n+                    verbose = booleanOption(a2);\n@@ -202,1 +303,0 @@\n-                continue;\n@@ -210,2 +310,1 @@\n-            for (int i = 0; i < av.size(); i++)\n-                av.set(i, maybeExpandProperties(av.get(i)));\n+            av.replaceAll(this::maybeExpandProperties);\n@@ -215,0 +314,9 @@\n+    \/**\n+     * Converts a string representation of a boolean option to its boolean value.\n+     * If the input string is null, it returns true by default.\n+     *\n+     * @param s the string representation of the boolean option. Accepted values for true are \"true\", \"yes\", \"on\", and \"1\".\n+     *          Accepted values for false are \"false\", \"no\", \"off\", and \"0\".\n+     * @return the boolean value corresponding to the input string.\n+     * @throws IllegalArgumentException if the input string is not recognized as a valid boolean option.\n+     *\/\n@@ -217,5 +325,5 @@\n-        switch (s) {\n-        case \"true\":  case \"yes\": case \"on\":  case \"1\": return true;\n-        case \"false\": case \"no\":  case \"off\": case \"0\": return false;\n-        }\n-        throw new IllegalArgumentException(\"unrecognized boolean flag=\"+s);\n+        return switch (s) {\n+            case \"true\", \"yes\", \"on\", \"1\" -> true;\n+            case \"false\", \"no\", \"off\", \"0\" -> false;\n+            default -> throw new IllegalArgumentException(\"unrecognized boolean flag=\" + s);\n+        };\n@@ -245,1 +353,1 @@\n-            indifyFile(f, dest);\n+            indifyFile(f);\n@@ -247,1 +355,1 @@\n-            indifyJar(f, dest);\n+            indifyJar(); \/\/Not yet implemented\n@@ -249,1 +357,1 @@\n-            indifyTree(f, dest);\n+            indifyTree(f);\n@@ -256,1 +364,1 @@\n-            System.err.println(\"created \"+dir);\n+            System.err.println(\"Created new directory to: \"+dir);\n@@ -259,5 +367,6 @@\n-    public void indifyFile(File f, File dest) throws IOException {\n-        if (verbose)  System.err.println(\"reading \"+f);\n-        ClassFile cf = new ClassFile(f);\n-        Logic logic = new Logic(cf);\n-        boolean changed = logic.transform();\n+    public void indifyFile(File f) throws IOException {\n+        if (verbose)  System.err.println(\"reading \" + f);\n+        ClassModel model = parseClassFile(f);\n+        Logic logic = new Logic(model);\n+        Boolean changed = logic.transform();\n+        System.err.println(\"Class file transformation: \" + changed);\n@@ -265,3 +374,8 @@\n-        if (changed || all) {\n-            File outfile;\n-            if (dest != null) {\n+        writeNewClassFile(logic.classModel, changed, f);\n+    }\n+\n+    void writeNewClassFile(ClassModel newClassModel, Boolean changed, File sourceFile) throws IOException {\n+        byte[] new_bytes = transformToBytes(newClassModel);\n+        if(changed || all){\n+            File destFile;\n+            if(dest != null){\n@@ -269,1 +383,1 @@\n-                outfile = classPathFile(dest, cf.nameString());\n+                destFile = classPathFile(dest, newClassModel.thisClass().name().stringValue());\n@@ -271,1 +385,1 @@\n-                outfile = f;  \/\/ overwrite input file, no matter where it is\n+                destFile = sourceFile;\n@@ -273,2 +387,3 @@\n-            cf.writeTo(outfile);\n-            if (!quiet)  System.err.println(\"wrote \"+outfile);\n+            if (verbose) System.err.println(\"writing \"+destFile);\n+            Files.write(destFile.toPath(), new_bytes);\n+            System.err.println(\"Wrote New ClassFile to: \"+destFile);\n@@ -278,0 +393,4 @@\n+    byte[] transformToBytes(ClassModel classModel) {\n+        return of().transform(classModel, ClassTransform.ACCEPT_ALL);\n+    }\n+\n@@ -284,1 +403,1 @@\n-    public void indifyJar(File f, Object dest) throws IOException {\n+    public void indifyJar() {\n@@ -288,1 +407,1 @@\n-    public void indifyTree(File f, File dest) throws IOException {\n+    public void indifyTree(File f) throws IOException {\n@@ -290,7 +409,6 @@\n-        for (File f2 : f.listFiles(new FilenameFilter() {\n-                public boolean accept(File dir, String name) {\n-                    if (name.endsWith(\".class\"))  return true;\n-                    if (name.contains(\".\"))  return false;\n-                    \/\/ return true if it might be a package name:\n-                    return Character.isJavaIdentifierStart(name.charAt(0));\n-                }})) {\n+        for (File f2 : Objects.requireNonNull(f.listFiles((dir, name) -> {\n+            if (name.endsWith(\".class\")) return true;\n+            if (name.contains(\".\")) return false;\n+            \/\/ return true if it might be a package name:\n+            return Character.isJavaIdentifierStart(name.charAt(0));\n+        }))) {\n@@ -298,1 +416,1 @@\n-                indifyFile(f2, dest);\n+                indifyFile(f2);\n@@ -300,1 +418,1 @@\n-                indifyTree(f2, dest);\n+                indifyTree(f2);\n@@ -323,3 +441,1 @@\n-                } catch (ClassNotFoundException ex) {\n-                    \/\/ fall through\n-                } catch (IOException ex) {\n+                } catch (ClassNotFoundException | IOException ex) {\n@@ -359,4 +475,4 @@\n-            ClassFile cf = new ClassFile(f);\n-            Logic logic = new Logic(cf);\n-            boolean changed = logic.transform();\n-            if (verbose && !changed)  System.err.println(\"(no change)\");\n+            ClassModel model = parseClassFile(f);\n+            Logic logic = new Logic(model);\n+            Boolean changed = logic.transform();\n+            if (verbose && changed) System.err.println(\"(no change)\");\n@@ -364,2 +480,3 @@\n-            byte[] bytes = cf.toByteArray();\n-            return defineClass(null, bytes, 0, bytes.length);\n+            byte[] new_Bytes = transformToBytes(logic.classModel);\n+\n+            return defineClass(null, new_Bytes, 0, new_Bytes.length);\n@@ -370,2 +487,2 @@\n-        \/\/ Indify logic, per se.\n-        ClassFile cf;\n+        ClassModel classModel;\n+        ConstantPoolBuilder poolBuilder;  \/\/Builder for the new constant pool\n@@ -373,5 +490,5 @@\n-        final Map<Method,Constant> constants = new HashMap<>();\n-        final Map<Method,String> indySignatures = new HashMap<>();\n-        Logic(ClassFile cf) {\n-            this.cf = cf;\n-            poolMarks = new char[cf.pool.size()];\n+        final Map<String, PoolEntry> constants = new HashMap<>();\n+        Logic(ClassModel classModel){\n+            this.classModel = classModel;\n+            poolBuilder = ConstantPoolBuilder.of(classModel);\n+            poolMarks = new char[classModel.constantPool().size()];\n@@ -379,1 +496,2 @@\n-        boolean transform() {\n+\n+        Boolean transform(){\n@@ -381,37 +499,27 @@\n-            if (!findPatternMethods())  return false;\n-            Pool pool = cf.pool;\n-            \/\/for (Constant c : cp)  System.out.println(\"  # \"+c);\n-            for (Method m : cf.methods) {\n-                if (constants.containsKey(m))  continue;  \/\/ don't bother\n-                \/\/ Transform references.\n-                int blab = 0;\n-                for (Instruction i = m.instructions(); i != null; i = i.next()) {\n-                    if (i.bc != opc_invokestatic)  continue;\n-                    int methi = i.u2At(1);\n-                    if (poolMarks[methi] == 0)  continue;\n-                    Short[] ref = pool.getMemberRef((short)methi);\n-                    Method conm = findMember(cf.methods, ref[1], ref[2]);\n-                    if (conm == null)  continue;\n-                    Constant con = constants.get(conm);\n-                    if (con == null)  continue;\n-                    if (blab++ == 0 && !quiet)\n-                        System.err.println(\"patching \"+cf.nameString()+\".\"+m);\n-                    \/\/if (blab == 1) { for (Instruction j = m.instructions(); j != null; j = j.next()) System.out.println(\"  |\"+j); }\n-                    if (con.tag == CONSTANT_InvokeDynamic) {\n-                        \/\/ need to patch the following instruction too,\n-                        \/\/ but there are usually intervening argument pushes too\n-                        Instruction i2 = findPop(i);\n-                        Short[] ref2 = null;\n-                        short ref2i = 0;\n-                        if (i2 != null && i2.bc == opc_invokevirtual &&\n-                                poolMarks[(char)(ref2i = (short) i2.u2At(1))] == 'D')\n-                            ref2 = pool.getMemberRef(ref2i);\n-                        if (ref2 == null || !\"invokeExact\".equals(pool.getString(ref2[1]))) {\n-                            System.err.println(m+\": failed to create invokedynamic at \"+i.pc);\n-                            continue;\n-                        }\n-                        String invType = pool.getString(ref2[2]);\n-                        String bsmType = indySignatures.get(conm);\n-                        if (!invType.equals(bsmType)) {\n-                            System.err.println(m+\": warning: \"+conm+\" call type and local invoke type differ: \"\n-                                    +bsmType+\", \"+invType);\n+            if (!findPatternMethods()) return false;\n+\n+            CodeTransform codeTransform;\n+            ClassTransform classTransform;\n+\n+            for(MethodModel m : classModel.methods()){\n+                if(constants.containsKey(m.methodName().stringValue())) continue;  \/\/skip if pattern method, it will be removed\n+\n+                Predicate<MethodModel> filter = method -> Objects.equals(method.methodName().stringValue(), m.methodName().stringValue());\n+\n+                final Stack<Boolean> shouldProceedAfterIndyAdded = new Stack<>();\n+\n+                for (Instruction i : getInstructions(m)){\n+                    shouldProceedAfterIndyAdded.push(true);\n+\n+                    if(i.opcode().bytecode() != INVOKESTATIC) continue;  \/\/this is not an invokestatic instruction\n+                    int methodIndex = ((InvokeInstruction) i).method().index();\n+                    if (poolMarks[methodIndex] == 0) continue;    \/\/Skip if not marked\n+\n+                    MemberRefEntry ref = (MemberRefEntry) poolBuilder.entryByIndex(methodIndex);\n+                    String methName = ref.nameAndType().name().stringValue();\n+                    String methType = ref.nameAndType().type().stringValue();\n+\n+                    MethodModel patternMethod = null;\n+                    for (MethodModel mm : classModel.methods()) {\n+                        if (mm.methodName().stringValue().equals(methName) && mm.methodType().stringValue().equals(methType)) {\n+                            patternMethod = mm;\n@@ -419,10 +527,38 @@\n-                        assert(i.len == 3 || i2.len == 3);\n-                        if (!quiet)  System.err.println(i+\" \"+conm+\";...; \"+i2+\" => invokedynamic \"+con);\n-                        int start = i.pc + 3, end = i2.pc;\n-                        System.arraycopy(i.codeBase, start, i.codeBase, i.pc, end-start);\n-                        i.forceNext(0);  \/\/ force revisit of new instruction\n-                        i2.u1AtPut(-3, opc_invokedynamic);\n-                        i2.u2AtPut(-2, con.index);\n-                        i2.u2AtPut(0, (short)0);\n-                        i2.u1AtPut(2, opc_nop);\n-                        \/\/System.out.println(new Instruction(i.codeBase, i2.pc-3));\n+                    }\n+                    if(patternMethod == null) continue;\n+\n+                    PoolEntry newConstant = constants.get(patternMethod.methodName().stringValue());\n+\n+                    if(newConstant instanceof InvokeDynamicEntry){\n+                        if (!quiet) System.err.println(\":::Transforming the Method: \"+ m.methodName() +\" instruction: \" + i + \" invokedynamic: \" + newConstant.index() );\n+                        MethodModel finalPatternMethod = patternMethod;\n+\n+                        codeTransform = (b, e) ->{\n+                            String a1 = null, a2 = null;\n+                            if(e instanceof InvokeInstruction){\n+                                a1 = ((InvokeInstruction) e).method().name().stringValue();\n+                                a2 = finalPatternMethod.methodName().stringValue();\n+                            }\n+                            if (e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)) {\n+                                System.err.println(\">> Removing instruction invokestatic for Method: \" + invokeInstruction.name());\n+                            }\n+                            else if (\n+                                    shouldProceedAfterIndyAdded.peek() &&\n+                                    e instanceof InvokeInstruction invokeInstruction &&\n+                                    invokeInstruction.method().name().stringValue().equals(\"invokeExact\"))\n+                            {\n+                                System.err.println(\">> Removing instruction invokevirtual for Method: \" + invokeInstruction.method());\n+                                System.err.println(\">> Adding invokedynamic instruction and nop instead of invoke virtual: \" + ((InvokeDynamicEntry) newConstant).name());\n+                                b.invokeDynamicInstruction((InvokeDynamicEntry) newConstant).nop();\n+\n+                                shouldProceedAfterIndyAdded.pop();\n+                                shouldProceedAfterIndyAdded.push(false);\n+                            } else {\n+                                b.with(e);\n+                            }\n+                        };\n+                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n+\n+                        classModel = of().parse(\n+                               of().transform(classModel, classTransform)\n+                        );\n@@ -430,4 +566,16 @@\n-                        if (!quiet)  System.err.println(i+\" \"+conm+\" => ldc \"+con);\n-                        assert(i.len == 3);\n-                        i.u1AtPut(0, opc_ldc_w);\n-                        i.u2AtPut(1, con.index);\n+                        assert(i.sizeInBytes() == 3);\n+                        MethodModel finalConm = patternMethod;\n+                        codeTransform = (b, e) ->{\n+                            String a1 = null, a2 = null;\n+                            if(e instanceof InvokeInstruction invokeInstruction){\n+                                a1 = invokeInstruction.method().name().stringValue();\n+                                a2 = finalConm.methodName().stringValue();\n+                            }\n+                            if(e instanceof InvokeInstruction invokeInstruction && Objects.equals(a1, a2)){\n+                                System.err.println(\":::Transfmoring the Method: \"+ m.methodName() +\" instruction: invokestatic \" + invokeInstruction.type() + \" to ldc: \" +  newConstant.index() );\n+                                b.ldc((LoadableConstantEntry) newConstant);\n+                            } else b.with(e);\n+                        };\n+                        classTransform = ClassTransform.transformingMethodBodies(filter, codeTransform);\n+                        classModel = of().parse(\n+                             of().transform(classModel, classTransform));\n@@ -435,0 +583,1 @@\n+                    shouldProceedAfterIndyAdded.clear();\n@@ -436,1 +585,0 @@\n-                \/\/if (blab >= 1) { for (Instruction j = m.instructions(); j != null; j = j.next()) System.out.println(\"    |\"+j); }\n@@ -438,1 +586,2 @@\n-            cf.methods.removeAll(constants.keySet());\n+            this.classModel = removePatternMethodsAndVerify(classModel);\n+\n@@ -442,27 +591,19 @@\n-        \/\/ Scan forward from the instruction to find where the stack p\n-        \/\/ below the current sp at the instruction.\n-        Instruction findPop(Instruction i) {\n-            \/\/System.out.println(\"findPop from \"+i);\n-            Pool pool = cf.pool;\n-            JVMState jvm = new JVMState();\n-        decode:\n-            for (i = i.clone().next(); i != null; i = i.next()) {\n-                String pops = INSTRUCTION_POPS[i.bc];\n-                \/\/System.out.println(\"  \"+i+\" \"+jvm.stack+\" : \"+pops.replace(\"$\", \" => \"));\n-                if (pops == null)  break;\n-                if (jvm.stackMotion(i.bc))  continue decode;\n-                if (pops.indexOf('Q') >= 0) {\n-                    Short[] ref = pool.getMemberRef((short) i.u2At(1));\n-                    String type = simplifyType(pool.getString(CONSTANT_Utf8, ref[2]));\n-                    switch (i.bc) {\n-                    case opc_getstatic:\n-                    case opc_getfield:\n-                    case opc_putstatic:\n-                    case opc_putfield:\n-                        pops = pops.replace(\"Q\", type);\n-                        break;\n-                    default:\n-                        if (!type.startsWith(\"(\"))\n-                            throw new InternalError(i.toString());\n-                        pops = pops.replace(\"Q$Q\", type.substring(1).replace(\")\",\"$\"));\n-                        break;\n+        ClassModel removePatternMethodsAndVerify(ClassModel classModel){\n+\n+            ClassModel newClassModel = of().parse(\n+                    of().transform(classModel, (b, e) ->\n+                    {\n+                        if (!(e instanceof MethodModel mm &&\n+                                (mm.methodName().stringValue().startsWith(\"MH_\") ||\n+                                        mm.methodName().stringValue().startsWith(\"MT_\") ||\n+                                        mm.methodName().stringValue().startsWith(\"INDY_\"))\n+                        )) b.with(e);\n+                        else System.err.println(\"Removing pattern method: \" + ((MethodModel) e).methodName());\n+                    })\n+            );\n+\n+            try {\n+                List<VerifyError> errors = of().verify(newClassModel);\n+                if (!errors.isEmpty()) {\n+                    for (VerifyError e : errors) {\n+                        System.err.println(e.getMessage());\n@@ -470,17 +611,3 @@\n-                    \/\/System.out.println(\"special type: \"+type+\" => \"+pops);\n-                }\n-                int npops = pops.indexOf('$');\n-                if (npops < 0)  throw new InternalError();\n-                if (npops > jvm.sp())  return i;\n-                List<Object> args = jvm.args(npops);\n-                int k = 0;\n-                for (Object x : args) {\n-                    char have = (Character) x;\n-                    char want = pops.charAt(k++);\n-                    if (have == 'X' || want == 'X')  continue;\n-                    if (have != want)  break decode;\n-                }\n-                if (pops.charAt(k++) != '$')  break decode;\n-                args.clear();\n-                while (k < pops.length())\n-                    args.add(pops.charAt(k++));\n+                    throw new IOException(\"Verification failed\");\n+                } else System.out.println(\"Verification passed\");} catch (IOException ignored) {\n+\n@@ -488,2 +615,2 @@\n-            System.err.println(\"*** bailout on jvm: \"+jvm.stack+\" \"+i);\n-            return null;\n+\n+            return newClassModel;\n@@ -494,8 +621,8 @@\n-            for (char mark : \"THI\".toCharArray()) {\n-                for (Method m : cf.methods) {\n-                    if (!Modifier.isPrivate(m.access))  continue;\n-                    if (!Modifier.isStatic(m.access))  continue;\n-                    if (nameAndTypeMark(m.name, m.type) == mark) {\n-                        Constant con = scanPattern(m, mark);\n-                        if (con == null)  continue;\n-                        constants.put(m, con);\n+            for(char mark : \"THI\".toCharArray()) {\n+                for(MethodModel m : classModel.methods()){\n+                    if (!Modifier.isPrivate(m.flags().flagsMask())) continue;\n+                    if (!Modifier.isStatic(m.flags().flagsMask())) continue;\n+                    if(nameAndTypeMark(m.methodName(), m.methodType()) == mark) {\n+                        PoolEntry entry = scanPattern(m, mark);\n+                        if (entry == null) continue;\n+                        constants.put(m.methodName().stringValue(), entry);\n@@ -512,4 +639,4 @@\n-            for (Method m : cf.methods) {\n-                if (nameMark(cf.pool.getString(m.name)) != 0 &&\n-                    constants.get(m) == null) {\n-                    String failure = \"method has special name but fails to match pattern: \"+m;\n+            for (MethodModel m : classModel.methods()) {\n+                if (nameMark(m.methodName().stringValue()) != 0 &&\n+                        constants.get(m.methodName().stringValue()) == null) {\n+                    String failure = \"method has a special name but fails to match pattern: \"+ m.methodName();\n@@ -522,9 +649,0 @@\n-            if (verifySpecifierCount >= 0) {\n-                List<Object[]> specs = bootstrapMethodSpecifiers(false);\n-                int specsLen = (specs == null ? 0 : specs.size());\n-                \/\/ Pass by specsLen == 0, to help with associated (inner) classes.\n-                if (specsLen == 0)  specsLen = verifySpecifierCount;\n-                if (specsLen != verifySpecifierCount) {\n-                    throw new IllegalArgumentException(\"BootstrapMethods length is \"+specsLen+\" but should be \"+verifySpecifierCount);\n-                }\n-            }\n@@ -534,1 +652,12 @@\n-        \/\/ mark constant pool entries according to participation in patterns\n+        \/**\n+         * Initializes the marks for the constant pool entries.\n+         * <p>\n+         * This method iterates through the constant pool and assigns marks to each entry\n+         * based on its type and value. These marks are used to identify specific types of\n+         * constant pool entries .\n+         * <p>\n+         * The method iterates until no changes are made to the pool marks array in a complete pass.\n+         * This ensures that all dependent entries are processed correctly.\n+         *\n+         * @return true if any marks were changed, false otherwise.\n+         *\/\n@@ -536,1 +665,1 @@\n-            boolean changed = false;\n+            boolean anyMarksChanged = false;\n@@ -538,18 +667,5 @@\n-                boolean changed1 = false;\n-                int cpindex = -1;\n-                for (Constant e : cf.pool) {\n-                    ++cpindex;\n-                    if (e == null)  continue;\n-                    char mark = poolMarks[cpindex];\n-                    if (mark != 0)  continue;\n-                    switch (e.tag) {\n-                    case CONSTANT_Utf8:\n-                        mark = nameMark(e.itemString()); break;\n-                    case CONSTANT_NameAndType:\n-                        mark = nameAndTypeMark(e.itemIndexes()); break;\n-                    case CONSTANT_Class: {\n-                        int n1 = e.itemIndex();\n-                        char nmark = poolMarks[(char)n1];\n-                        if (\"DJ\".indexOf(nmark) >= 0)\n-                            mark = nmark;\n-                        break;\n+                boolean someMarksChangedInLoop = false;\n+                for (PoolEntry poolEntry : classModel.constantPool()) {\n+                    \/\/ Get the index directly from PoolEntry\n+                    if (poolEntry == null) {\n+                        continue; \/\/ Skip null entries\n@@ -557,9 +673,12 @@\n-                    case CONSTANT_Field:\n-                    case CONSTANT_Method: {\n-                        Short[] n12 = e.itemIndexes();\n-                        short cl = n12[0];\n-                        short nt = n12[1];\n-                        char cmark = poolMarks[(char)cl];\n-                        if (cmark != 0) {\n-                            mark = cmark;  \/\/ it is a java.lang.invoke.* or java.lang.* method\n-                            break;\n+                    int cpIndex = poolEntry.index();\n+\n+                    char mark = poolMarks[cpIndex];\n+                    if (mark != 0) {\n+                        continue;\n+                    }\n+\n+                    mark = switch (poolEntry.tag()) {\n+                        case TAG_UTF8 -> nameMark(((Utf8Entry) poolEntry).stringValue());\n+                        case TAG_NAMEANDTYPE -> {\n+                            NameAndTypeEntry nameAndTypeEntry = (NameAndTypeEntry) poolEntry;\n+                            yield nameAndTypeMark(nameAndTypeEntry.name(), nameAndTypeEntry.type());\n@@ -567,7 +686,7 @@\n-                        String cls = cf.pool.getString(CONSTANT_Class, cl);\n-                        if (cls.equals(cf.nameString())) {\n-                            switch (poolMarks[(char)nt]) {\n-                            \/\/ it is a private MH\/MT\/INDY method\n-                            case 'T': case 'H': case 'I':\n-                                mark = poolMarks[(char)nt];\n-                                break;\n+                        case TAG_CLASS -> {\n+                            int nameIndex = ((ClassEntry) poolEntry).name().index();\n+                            char nameMark = poolMarks[nameIndex];\n+                            if (\"DJ\".indexOf(nameMark) >= 0) {\n+                                yield nameMark;\n+                            } else {\n+                                yield mark;\n@@ -576,4 +695,22 @@\n-                        break;\n-                    }\n-                    default:  break;\n-                    }\n+                        case TAG_FIELDREF, TAG_METHODREF -> {\n+                            MemberRefEntry memberRefEntry = (MemberRefEntry) poolEntry;\n+                            int classIndex = memberRefEntry.owner().index();\n+                            int nameAndTypeIndex = memberRefEntry.nameAndType().index();\n+                            char classMark = poolMarks[classIndex];\n+                            if (classMark != 0) {\n+                                yield classMark;  \/\/ java.lang.invoke.* or java.lang.* method\n+                            } else {\n+                                String cls = memberRefEntry.owner().name().stringValue();\n+                                if (cls.equals(classModel.thisClass().name().stringValue())) {\n+                                    yield switch (poolMarks[nameAndTypeIndex]) {\n+                                        case 'T', 'H', 'I' -> poolMarks[nameAndTypeIndex];\n+                                        default -> mark;\n+                                    };\n+                                } else {\n+                                    yield mark;\n+                                }\n+                            }\n+                        }\n+                        default -> mark;\n+                    };\n+\n@@ -581,2 +718,2 @@\n-                        poolMarks[cpindex] = mark;\n-                        changed1 = true;\n+                        poolMarks[cpIndex] = mark;\n+                        someMarksChangedInLoop = true;\n@@ -585,1 +722,1 @@\n-                if (!changed1)\n+                if (!someMarksChangedInLoop) {\n@@ -587,1 +724,2 @@\n-                changed = true;\n+                }\n+                anyMarksChanged = true;\n@@ -589,1 +727,1 @@\n-            return changed;\n+            return anyMarksChanged;\n@@ -591,0 +729,1 @@\n+\n@@ -599,7 +738,5 @@\n-        char nameAndTypeMark(Short[] n12) {\n-            return nameAndTypeMark(n12[0], n12[1]);\n-        }\n-        char nameAndTypeMark(short n1, short n2) {\n-            char mark = poolMarks[(char)n1];\n-            if (mark == 0)  return 0;\n-            String descr = cf.pool.getString(CONSTANT_Utf8, n2);\n+\n+        char nameAndTypeMark(Utf8Entry name, Utf8Entry type){\n+            char mark = poolMarks[name.index()];\n+            if (mark == 0) return 0;\n+            String descriptor = type.stringValue();\n@@ -607,5 +744,4 @@\n-            switch (poolMarks[(char)n1]) {\n-            case 'H': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n-            case 'T': requiredType = \"()Ljava\/lang\/invoke\/MethodType;\";    break;\n-            case 'I': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n-            default:  return 0;\n+            switch (mark){\n+                case 'H', 'I': requiredType = \"()Ljava\/lang\/invoke\/MethodHandle;\";  break;\n+                case 'T': requiredType = \"()Ljava\/lang\/invoke\/MethodType;\";    break;\n+                default:  return 0;\n@@ -613,1 +749,1 @@\n-            if (matchType(descr, requiredType))  return mark;\n+            if(matchType(descriptor, requiredType)) return mark;\n@@ -618,2 +754,1 @@\n-            if (descr.equals(requiredType))  return true;\n-            return false;\n+            return descr.equals(requiredType);\n@@ -638,6 +773,6 @@\n-                case opc_pop:    pop();             break;\n-                case opc_pop2:   pop(); pop();      break;\n-                case opc_swap:   pushAt(-1, pop()); break;\n-                case opc_dup:    push(top());       break;\n-                case opc_dup_x1: pushAt(-2, top()); break;\n-                case opc_dup_x2: pushAt(-3, top()); break;\n+                case POP:    pop();             break;\n+                case POP2:   pop(); pop();      break;\n+                case SWAP:   pushAt(-1, pop()); break;\n+                case DUP:    push(top());       break;\n+                case DUP_X1: pushAt(-2, top()); break;\n+                case DUP_X2: pushAt(-3, top()); break;\n@@ -651,0 +786,1 @@\n+\n@@ -652,1 +788,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -654,3 +790,3 @@\n-                if (i >= 0 && i+1 < args.size()\n-                    && (isConstant(args.get(i+1), CONSTANT_Long) ||\n-                        isConstant(args.get(i+1), CONSTANT_Double)))\n+                if (i >= 0 && i + 1 < args.size()\n+                        && (args.get(i + 1) instanceof LongEntry ||\n+                        args.get(i + 1) instanceof DoubleEntry))\n@@ -658,1 +794,1 @@\n-                else  break;\n+                else break;\n@@ -662,10 +798,16 @@\n-        private Constant scanPattern(Method m, char patternMark) {\n-            if (verbose)  System.err.println(\"scan \"+m+\" for pattern=\"+patternMark);\n-            int wantTag;\n-            switch (patternMark) {\n-            case 'T': wantTag = CONSTANT_MethodType; break;\n-            case 'H': wantTag = CONSTANT_MethodHandle; break;\n-            case 'I': wantTag = CONSTANT_InvokeDynamic; break;\n-            default: throw new InternalError();\n-            }\n-            Instruction i = m.instructions();\n+        private List<Instruction> getInstructions(MethodModel method) {\n+            return method.code().get().elementStream()\n+                    .filter(Instruction.class::isInstance)\n+                    .map(Instruction.class::cast)\n+                    .collect(Collectors.toList());\n+        }\n+\n+        private PoolEntry scanPattern(MethodModel method, char patternMark) {\n+            if(verbose) System.err.println(\"Scanning the method: \" + method.methodName().stringValue() + \"for the pattern mark: \" + patternMark);\n+            int wantedTag = switch (patternMark) {\n+                case 'T' -> TAG_METHODTYPE;\n+                case 'H' -> TAG_METHODHANDLE;\n+                case 'I' -> TAG_INVOKEDYNAMIC;\n+                default -> throw new InternalError();\n+            };\n+            List<Instruction> instructions = getInstructions(method);\n@@ -673,1 +815,1 @@\n-            Pool pool = cf.pool;\n+            ConstantPool pool = classModel.constantPool();\n@@ -677,1 +819,1 @@\n-            List<Object> bsmArgs = null;  \/\/ args to invokeGeneric\n+            List<Object> bsmArgs = null;  \/\/ args for invokeGeneric\n@@ -679,60 +821,54 @@\n-            for (; i != null; i = i.next()) {\n-                \/\/System.out.println(jvm.stack+\" \"+i);\n-                int bc = i.bc;\n-                switch (bc) {\n-                case opc_ldc:           jvm.push(pool.get(i.u1At(1)));   break;\n-                case opc_ldc_w:         jvm.push(pool.get(i.u2At(1)));   break;\n-                case opc_ldc2_w:        jvm.push2(pool.get(i.u2At(1)));  break;\n-                case opc_aconst_null:   jvm.push(null);                  break;\n-                case opc_bipush:        jvm.push((int)(byte) i.u1At(1)); break;\n-                case opc_sipush:        jvm.push((int)(short)i.u2At(1)); break;\n-\n-                \/\/ these support creation of a restarg array\n-                case opc_anewarray:\n-                    arg = jvm.pop();\n-                    if (!(arg instanceof Integer))  break decode;\n-                    arg = Arrays.asList(new Object[(Integer)arg]);\n-                    jvm.push(arg);\n-                    break;\n-                case opc_dup:\n-                    jvm.push(jvm.top()); break;\n-                case opc_aastore:\n-                    args = jvm.args(3);  \/\/ array, index, value\n-                    if (args.get(0) instanceof List &&\n-                        args.get(1) instanceof Integer) {\n-                        @SuppressWarnings(\"unchecked\")\n-                        List<Object> arg0 = (List<Object>)args.get(0);\n-                        arg0.set( (Integer)args.get(1), args.get(2) );\n-                    }\n-                    args.clear();\n-                    break;\n-\n-                case opc_new:\n-                {\n-                    String type = pool.getString(CONSTANT_Class, (short)i.u2At(1));\n-                    \/\/System.out.println(\"new \"+type);\n-                    switch (type) {\n-                    case \"java\/lang\/StringBuilder\":\n-                        jvm.push(\"StringBuilder\");\n-                        continue decode;  \/\/ go to next instruction\n-                    }\n-                    break decode;  \/\/ bail out\n-                }\n-\n-                case opc_getstatic:\n-                {\n-                    \/\/ int.class compiles to getstatic Integer.TYPE\n-                    int fieldi = i.u2At(1);\n-                    char mark = poolMarks[fieldi];\n-                    \/\/System.err.println(\"getstatic \"+fieldi+Arrays.asList(pool.getStrings(pool.getMemberRef((short)fieldi)))+mark);\n-                    if (mark == 'J') {\n-                        Short[] ref = pool.getMemberRef((short) fieldi);\n-                        String name = pool.getString(CONSTANT_Utf8, ref[1]);\n-                        if (\"TYPE\".equals(name)) {\n-                            String wrapperName = pool.getString(CONSTANT_Class, ref[0]).replace('\/', '.');\n-                            \/\/ a primitive type descriptor\n-                            Class<?> primClass;\n-                            try {\n-                                primClass = (Class<?>) Class.forName(wrapperName).getField(name).get(null);\n-                            } catch (Exception ex) {\n-                                throw new InternalError(\"cannot load \"+wrapperName+\".\"+name);\n+            for(Instruction instruction : instructions){\n+\n+                int bc = instruction.opcode().bytecode();\n+                String UNKNOWN_CON = \"<unknown>\";\n+                switch (bc){\n+                    case LDC,LDC_W:           jvm.push(((ConstantInstruction.LoadConstantInstruction) instruction).constantEntry()); break;\n+                    case LDC2_W:              jvm.push2(((ConstantInstruction.LoadConstantInstruction) instruction).constantEntry()); break;\n+                    case ACONST_NULL:         jvm.push(null); break;\n+                    case BIPUSH, SIPUSH:      jvm.push(((ConstantInstruction) instruction).constantValue()); break;\n+\n+                    case ANEWARRAY :\n+                        arg = jvm.pop();\n+                        if( !(arg instanceof Integer)) break decode;\n+                        arg = Arrays.asList(new Object[(Integer)arg]);\n+                        jvm.push(arg);\n+                        break;\n+                    case DUP:\n+                        jvm.push(jvm.top()); break;\n+                    case AASTORE:\n+                        args = jvm.args(3);  \/\/ array, index, value\n+                        if (args.get(0) instanceof List &&\n+                                args.get(1) instanceof Integer) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            List<Object> arg0 = (List<Object>)args.get(0);\n+                            arg0.set( (Integer)args.get(1), args.get(2) );\n+                        }\n+                        args.clear();\n+                        break;\n+                    case NEW:\n+                        String type = ((NewObjectInstruction) instruction).className().name().stringValue();\n+                        if (type.equals(\"java\/lang\/StringBuilder\")) {\n+                            jvm.push(\"StringBuilder\");\n+                            continue;\n+                        }\n+                        break decode;\n+                    case GETSTATIC:\n+                    {\n+                        int fieldId = ((FieldInstruction) instruction).field().index();\n+                        char mark = poolMarks[fieldId];\n+                        if (mark == 'J') {\n+                            int classIndex = ((FieldInstruction) instruction).field().owner().index();\n+                            int nameIndex = ((FieldInstruction) instruction).field().name().index();\n+                            String name = ((Utf8Entry) classModel.constantPool().entryByIndex(nameIndex)).stringValue();\n+                            if (\"TYPE\".equals(name)) {\n+                                String wrapperName = ((ClassEntry) pool.entryByIndex(classIndex)).name().stringValue().replace('\/', '.');\n+                                \/\/Primitive type descriptor\n+                                Class<?> primClass;\n+                                try {\n+                                    primClass = (Class<?>) Class.forName(wrapperName).getField(name).get(null);\n+                                } catch (Exception e) {\n+                                    throw new InternalError(\"cannot load \" + wrapperName + \".\" + name);\n+                                }\n+                                jvm.push(primClass);\n+                                break;\n@@ -740,2 +876,0 @@\n-                            jvm.push(primClass);\n-                            break;\n@@ -743,0 +877,10 @@\n+                        \/\/Unknown Field; keep going\n+                        jvm.push(UNKNOWN_CON);\n+                        break;\n+                    }\n+                    case PUTSTATIC:\n+                    {\n+                        if (patternMark != 'I') break decode;\n+                        jvm.pop();\n+                        \/\/Unknown Field; keep going\n+                        break;\n@@ -744,11 +888,0 @@\n-                    \/\/ unknown field; keep going...\n-                    jvm.push(UNKNOWN_CON);\n-                    break;\n-                }\n-                case opc_putstatic:\n-                {\n-                    if (patternMark != 'I')  break decode;\n-                    jvm.pop();\n-                    \/\/ unknown field; keep going...\n-                    break;\n-                }\n@@ -756,31 +889,38 @@\n-                case opc_invokestatic:\n-                case opc_invokevirtual:\n-                case opc_invokespecial:\n-                {\n-                    boolean hasRecv = (bc != opc_invokestatic);\n-                    int methi = i.u2At(1);\n-                    char mark = poolMarks[methi];\n-                    Short[] ref = pool.getMemberRef((short)methi);\n-                    String type = pool.getString(CONSTANT_Utf8, ref[2]);\n-                    \/\/System.out.println(\"invoke \"+pool.getString(CONSTANT_Utf8, ref[1])+\" \"+Arrays.asList(ref)+\" : \"+type);\n-                    args = jvm.args(hasRecv, type);\n-                    String intrinsic = null;\n-                    Constant con;\n-                    if (mark == 'D' || mark == 'J') {\n-                        intrinsic = pool.getString(CONSTANT_Utf8, ref[1]);\n-                        if (mark == 'J') {\n-                            String cls = pool.getString(CONSTANT_Class, ref[0]);\n-                            cls = cls.substring(1+cls.lastIndexOf('\/'));\n-                            intrinsic = cls+\".\"+intrinsic;\n-                        }\n-                        \/\/System.out.println(\"recognized intrinsic \"+intrinsic);\n-                        byte refKind = -1;\n-                        switch (intrinsic) {\n-                        case \"findGetter\":          refKind = REF_getField;         break;\n-                        case \"findStaticGetter\":    refKind = REF_getStatic;        break;\n-                        case \"findSetter\":          refKind = REF_putField;         break;\n-                        case \"findStaticSetter\":    refKind = REF_putStatic;        break;\n-                        case \"findVirtual\":         refKind = REF_invokeVirtual;    break;\n-                        case \"findStatic\":          refKind = REF_invokeStatic;     break;\n-                        case \"findSpecial\":         refKind = REF_invokeSpecial;    break;\n-                        case \"findConstructor\":     refKind = REF_newInvokeSpecial; break;\n+                    case INVOKESTATIC:\n+                    case INVOKEVIRTUAL:\n+                    case INVOKESPECIAL:\n+                    {\n+                        boolean hasReceiver = (bc != INVOKESTATIC);\n+                        int methodIndex = ((InvokeInstruction) instruction).method().index();\n+                        char mark = poolMarks[methodIndex];\n+                        MemberRefEntry ref = (MemberRefEntry) classModel.constantPool().entryByIndex(methodIndex);\n+                        String methClass = ref.owner().name().stringValue();\n+                        String methType = ref.nameAndType().type().stringValue();\n+                        String methName = ref.nameAndType().name().stringValue();\n+                        System.out.println(\"invoke \" + methName + \" : \" + ref + \" : \" + methType);\n+                        args = jvm.args(hasReceiver, methType);\n+                        String intrinsic = null;\n+                        PoolEntry con;\n+                        if (mark == 'D' || mark == 'J') {\n+                            intrinsic = methName;\n+                            if (mark == 'J') {\n+                                String cls = methClass;\n+                                cls = cls.substring(1 + cls.lastIndexOf('\/'));\n+                                intrinsic = cls + \".\" + intrinsic;\n+                            }\n+                            System.out.println(\"recognized intrinsic \" + intrinsic);\n+                            byte refKind = -1;\n+                            switch (intrinsic) {\n+                                case \"findGetter\":          refKind = (byte) GETTER.refKind;            break;\n+                                case \"findStaticGetter\":    refKind = (byte) STATIC_GETTER.refKind;     break;\n+                                case \"findSetter\":          refKind = (byte) SETTER.refKind;            break;\n+                                case \"findStaticSetter\":    refKind = (byte) STATIC_SETTER.refKind;     break;\n+                                case \"findVirtual\":         refKind = (byte) VIRTUAL.refKind;           break;\n+                                case \"findStatic\":          refKind = (byte) STATIC.refKind;            break;\n+                                case \"findSpecial\":         refKind = (byte) SPECIAL.refKind;           break;\n+                                case \"findConstructor\":     refKind = (byte) CONSTRUCTOR.refKind;       break;\n+                            }\n+                            if (refKind >= 0 && (con = parseMemberLookup(refKind, args)) != null) {\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            }\n@@ -788,3 +928,7 @@\n-                        if (refKind >= 0 && (con = parseMemberLookup(refKind, args)) != null) {\n-                            args.clear(); args.add(con);\n-                            continue;\n+                        MethodModel ownMethod = null;\n+                        if (mark == 'T' || mark == 'H' || mark == 'I') {\n+                            for (MethodModel m : classModel.methods()) {\n+                                if (m.methodName().stringValue().equals(methName) && m.methodType().stringValue().equals(methType)) {\n+                                    ownMethod = m;\n+                                }\n+                            }\n@@ -792,31 +936,30 @@\n-                    }\n-                    Method ownMethod = null;\n-                    if (mark == 'T' || mark == 'H' || mark == 'I') {\n-                        ownMethod = findMember(cf.methods, ref[1], ref[2]);\n-                    }\n-                    \/\/if (intrinsic != null)  System.out.println(\"intrinsic = \"+intrinsic);\n-                    switch (intrinsic == null ? \"\" : intrinsic) {\n-                    case \"fromMethodDescriptorString\":\n-                        con = makeMethodTypeCon(args.get(0));\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    case \"methodType\": {\n-                        flattenVarargs(args);  \/\/ there are several overloadings, some with varargs\n-                        StringBuilder buf = new StringBuilder();\n-                        String rtype = null;\n-                        for (Object typeArg : args) {\n-                            if (typeArg instanceof Class) {\n-                                Class<?> argClass = (Class<?>) typeArg;\n-                                if (argClass.isPrimitive()) {\n-                                    char tchar;\n-                                    switch (argClass.getName()) {\n-                                    case \"void\":    tchar = 'V'; break;\n-                                    case \"boolean\": tchar = 'Z'; break;\n-                                    case \"byte\":    tchar = 'B'; break;\n-                                    case \"char\":    tchar = 'C'; break;\n-                                    case \"short\":   tchar = 'S'; break;\n-                                    case \"int\":     tchar = 'I'; break;\n-                                    case \"long\":    tchar = 'J'; break;\n-                                    case \"float\":   tchar = 'F'; break;\n-                                    case \"double\":  tchar = 'D'; break;\n-                                    default:  throw new InternalError(argClass.toString());\n+                        switch (intrinsic == null ? \"\" : intrinsic) {\n+                            case \"fromMethodDescriptorString\":\n+                                con = makeMethodTypeCon(args.getFirst());\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            case \"methodType\": {\n+                                flattenVarargs(args);\n+                                StringBuilder buf = new StringBuilder();\n+                                String rtype = null;\n+                                for(Object typeArg : args) {\n+                                    if (typeArg instanceof Class<?> argClass) {\n+                                        buf.append(argClass.descriptorString());\n+                                    }else if (typeArg instanceof PoolEntry argCon) {\n+                                        if(argCon.tag() == TAG_CLASS) {\n+                                            String cn = ((ClassEntry) argCon).name().stringValue();\n+                                            if (cn.endsWith(\";\"))\n+                                                buf.append(cn);\n+                                            else\n+                                                buf.append('L').append(cn).append(';');\n+                                        } else {\n+                                            break decode;\n+                                        }\n+                                    } else {\n+                                        break decode;\n+                                    }\n+                                    if (rtype == null) {\n+                                        \/\/ first arg is treated differently\n+                                        rtype = buf.toString();\n+                                        buf.setLength(0);\n+                                        buf.append('(');\n@@ -824,4 +967,0 @@\n-                                    buf.append(tchar);\n-                                } else {\n-                                    \/\/ should not happen, but...\n-                                    buf.append('L').append(argClass.getName().replace('.','\/')).append(';');\n@@ -829,10 +968,34 @@\n-                            } else if (typeArg instanceof Constant) {\n-                                Constant argCon = (Constant) typeArg;\n-                                if (argCon.tag == CONSTANT_Class) {\n-                                    String cn = pool.get(argCon.itemIndex()).itemString();\n-                                    if (cn.endsWith(\";\"))\n-                                        buf.append(cn);\n-                                    else\n-                                        buf.append('L').append(cn).append(';');\n-                                } else {\n-                                    break decode;\n+                                buf.append(')').append(rtype);\n+                                con = makeMethodTypeCon(buf.toString());\n+                                args.clear(); args.add(con);\n+                                continue;\n+                            }\n+                            case \"lookup\":\n+                            case \"dynamicInvoker\":\n+                                args.clear(); args.add(intrinsic);\n+                                continue;\n+                            case \"lookupClass\":\n+                                if(args.equals(List.of(\"lookup\"))) {\n+                                    args.clear(); args.add(classModel.thisClass());\n+                                    continue;\n+                                }\n+                                break;\n+                            case \"invoke\":\n+                            case \"invokeGeneric\":\n+                            case \"invokeWithArguments\":\n+                                if (patternMark != 'I')  break decode;\n+                                if (\"invokeWithArguments\".equals(intrinsic))\n+                                    flattenVarargs(args);\n+                                bsmArgs = new ArrayList<>(args);\n+                                args.clear(); args.add(\"invokeGeneric\");\n+                                continue;\n+                            case \"Integer.valueOf\":\n+                            case \"Float.valueOf\":\n+                            case \"Long.valueOf\":\n+                            case \"Double.valueOf\":\n+                                removeEmptyJVMSlots(args);\n+                                if(args.size() == 1 ) {\n+                                    arg = args.removeFirst();\n+                                    if (arg instanceof Number) {\n+                                        args.add(arg); continue;\n+                                    }\n@@ -840,1 +1003,0 @@\n-                            } else {\n@@ -842,7 +1004,8 @@\n-                            }\n-                            if (rtype == null) {\n-                                \/\/ first arg is treated differently\n-                                rtype = buf.toString();\n-                                buf.setLength(0);\n-                                buf.append('(');\n-                            }\n+                            case \"StringBuilder.append\":\n+                                removeEmptyJVMSlots(args);\n+                                args.subList(1, args.size()).clear();\n+                                continue;\n+                            case \"StringBuilder.toString\":\n+                                args.clear();\n+                                args.add(intrinsic);\n+                                continue;\n@@ -850,13 +1013,7 @@\n-                        buf.append(')').append(rtype);\n-                        con = con = makeMethodTypeCon(buf.toString());\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    }\n-                    case \"lookup\":\n-                    case \"dynamicInvoker\":\n-                        args.clear(); args.add(intrinsic);\n-                        continue;\n-                    case \"lookupClass\":\n-                        if (args.equals(Arrays.asList(\"lookup\"))) {\n-                            \/\/ fold lookup().lookupClass() to the enclosing class\n-                            args.clear(); args.add(pool.get(cf.thisc));\n+                        if(!hasReceiver && ownMethod != null) {\n+                            con = constants.get(ownMethod.methodName().stringValue());\n+                            if (con == null)  break decode;\n+                            args.clear(); args.add(con);\n+                            continue;\n+                        } else if (methType.endsWith(\")V\")) {\n+                            args.clear();\n@@ -865,21 +1022,12 @@\n-                        break;\n-                    case \"invoke\":\n-                    case \"invokeGeneric\":\n-                    case \"invokeWithArguments\":\n-                        if (patternMark != 'I')  break decode;\n-                        if (\"invokeWithArguments\".equals(intrinsic))\n-                            flattenVarargs(args);\n-                        bsmArgs = new ArrayList<>(args);\n-                        args.clear(); args.add(\"invokeGeneric\");\n-                        continue;\n-                    case \"Integer.valueOf\":\n-                    case \"Float.valueOf\":\n-                    case \"Long.valueOf\":\n-                    case \"Double.valueOf\":\n-                        removeEmptyJVMSlots(args);\n-                        if (args.size() == 1) {\n-                            arg = args.remove(0);\n-                            assert(3456 == (CONSTANT_Integer*1000 + CONSTANT_Float*100 + CONSTANT_Long*10 + CONSTANT_Double));\n-                            if (isConstant(arg, CONSTANT_Integer + \"IFLD\".indexOf(intrinsic.charAt(0)))\n-                                || arg instanceof Number) {\n-                                args.add(arg); continue;\n+                        break decode;\n+                    }\n+                    case ARETURN:\n+                    {\n+                        ++branchCount;\n+                        if(bsmArgs != null){\n+                            \/\/ parse bsmArgs as (MH, lookup, String, MT, [extra])\n+                            PoolEntry indyCon = makeInvokeDynamicCon(bsmArgs);\n+                            if (indyCon != null) {\n+                                return indyCon;\n+                            }else {\n+                                System.err.println(\"Failed to create invokedynamic instruction for the method: \" + method.methodName());\n@@ -887,0 +1035,2 @@\n+                            System.err.println(method+\": inscrutable bsm arguments: \"+bsmArgs);\n+                            break decode;\n@@ -888,0 +1038,5 @@\n+                        arg = jvm.pop();\n+                        if(branchCount == 2 && UNKNOWN_CON.equals(arg))\n+                            break;\n+                        if((arg instanceof PoolEntry) && ((PoolEntry) arg).tag() == wantedTag)\n+                            return (PoolEntry) arg;\n@@ -889,9 +1044,0 @@\n-                    case \"StringBuilder.append\":\n-                        \/\/ allow calls like (\"value = \"+x)\n-                        removeEmptyJVMSlots(args);\n-                        args.subList(1, args.size()).clear();\n-                        continue;\n-                    case \"StringBuilder.toString\":\n-                        args.clear();\n-                        args.add(intrinsic);\n-                        continue;\n@@ -899,22 +1045,4 @@\n-                    if (!hasRecv && ownMethod != null && patternMark != 0) {\n-                        con = constants.get(ownMethod);\n-                        if (con == null)  break decode;\n-                        args.clear(); args.add(con);\n-                        continue;\n-                    } else if (type.endsWith(\")V\")) {\n-                        \/\/ allow calls like println(\"reached the pattern method\")\n-                        args.clear();\n-                        continue;\n-                    }\n-                    break decode;  \/\/ bail out for most calls\n-                }\n-                case opc_areturn:\n-                {\n-                    ++branchCount;\n-                    if (bsmArgs != null) {\n-                        \/\/ parse bsmArgs as (MH, lookup, String, MT, [extra])\n-                        Constant indyCon = makeInvokeDynamicCon(bsmArgs);\n-                        if (indyCon != null) {\n-                            Constant typeCon = (Constant) bsmArgs.get(3);\n-                            indySignatures.put(m, pool.getString(typeCon.itemIndex()));\n-                            return indyCon;\n+                    default:\n+                        if(jvm.stackMotion(instruction.opcode().bytecode())) break;\n+                        if (bc >= ICONST_M1 && bc <= DCONST_1) {\n+                            jvm.push(instruction.opcode().constantValue()); break;\n@@ -922,17 +1050,2 @@\n-                        System.err.println(m+\": inscrutable bsm arguments: \"+bsmArgs);\n-                        break decode;  \/\/ bail out\n-                    }\n-                    arg = jvm.pop();\n-                    if (branchCount == 2 && UNKNOWN_CON.equals(arg))\n-                        break;  \/\/ merge to next path\n-                    if (isConstant(arg, wantTag))\n-                        return (Constant) arg;\n-                    break decode;  \/\/ bail out\n-                }\n-                default:\n-                    if (jvm.stackMotion(i.bc))  break;\n-                    if (bc >= opc_nconst_MIN && bc <= opc_nconst_MAX)\n-                        { jvm.push(INSTRUCTION_CONSTANTS[bc - opc_nconst_MIN]); break; }\n-                    if (patternMark == 'I') {\n-                        \/\/ these support caching paths in INDY_x methods\n-                        if (bc == opc_aload || bc >= opc_aload_0 && bc <= opc_aload_MAX)\n+                        if (patternMark == 'I') {\n+                            if (bc == ALOAD || bc >= ALOAD_0 && bc <= ALOAD_3)\n@@ -940,1 +1053,1 @@\n-                        if (bc == opc_astore || bc >= opc_astore_0 && bc <= opc_astore_MAX)\n+                            if (bc == ASTORE || bc >= ASTORE_0 && bc <= ASTORE_3)\n@@ -942,18 +1055,20 @@\n-                        switch (bc) {\n-                        case opc_getfield:\n-                        case opc_aaload:\n-                            jvm.push(UNKNOWN_CON); break;\n-                        case opc_ifnull:\n-                        case opc_ifnonnull:\n-                            \/\/ ignore branch target\n-                            if (++branchCount != 1)  break decode;\n-                            jvm.pop();\n-                            break;\n-                        case opc_checkcast:\n-                            arg = jvm.top();\n-                            if (\"invokeWithArguments\".equals(arg) ||\n-                                \"invokeGeneric\".equals(arg))\n-                                break;  \/\/ assume it is a helpful cast\n-                            break decode;\n-                        default:\n-                            break decode;  \/\/ bail out\n+                            switch (bc) {\n+                                case GETFIELD:\n+                                case AALOAD:\n+                                    jvm.push(UNKNOWN_CON); break;\n+                                case IFNULL:\n+                                case IFNONNULL:\n+                                    \/\/ ignore branch target\n+                                    if (++branchCount != 1)  break decode;\n+                                    jvm.pop();\n+                                    break;\n+                                case CHECKCAST:\n+                                    arg = jvm.top();\n+                                    if (\"invokeWithArguments\".equals(arg) ||\n+                                            \"invokeGeneric\".equals(arg))\n+                                        break;\n+                                    break decode;\n+                                default:\n+                                    break decode;  \/\/ bail out\n+                            }\n+                            continue;\n@@ -961,4 +1076,2 @@\n-                        continue decode; \/\/ go to next instruction\n-                    }\n-                    break decode;  \/\/ bail out\n-                } \/\/end switch\n+                        break decode;  \/\/ bail out\n+                }\n@@ -966,1 +1079,1 @@\n-            System.err.println(m+\": bailout on \"+i+\" jvm stack: \"+jvm.stack);\n+            System.err.println(method+\": bailout ==> jvm stack: \"+jvm.stack);\n@@ -969,1 +1082,0 @@\n-        private final String UNKNOWN_CON = \"<unknown>\";\n@@ -979,11 +1091,7 @@\n-        private boolean isConstant(Object x, int tag) {\n-            return x instanceof Constant && ((Constant)x).tag == tag;\n-        }\n-        private Constant makeMethodTypeCon(Object x) {\n-            short utfIndex;\n-            if (x instanceof String)\n-                utfIndex = (short) cf.pool.addConstant(CONSTANT_Utf8, x).index;\n-            else if (isConstant(x, CONSTANT_String))\n-                utfIndex = ((Constant)x).itemIndex();\n-            else  return null;\n-            return cf.pool.addConstant(CONSTANT_MethodType, utfIndex);\n+        private PoolEntry makeMethodTypeCon(Object x){\n+           if (x instanceof StringEntry stringEntry){\n+                return poolBuilder.methodTypeEntry(stringEntry.utf8());\n+            } else {\n+               return poolBuilder.methodTypeEntry(poolBuilder.utf8Entry((String) x));\n+\n+            }\n@@ -991,24 +1099,35 @@\n-        private Constant parseMemberLookup(byte refKind, List<Object> args) {\n-            \/\/ E.g.: lookup().findStatic(Foo.class, \"name\", MethodType)\n-            if (args.size() != 4)  return null;\n-            int argi = 0;\n-            if (!\"lookup\".equals(args.get(argi++)))  return null;\n-            short refindex, cindex, ntindex, nindex, tindex;\n-            Object con;\n-            if (!isConstant(con = args.get(argi++), CONSTANT_Class))  return null;\n-            cindex = (short)((Constant)con).index;\n-            if (!isConstant(con = args.get(argi++), CONSTANT_String))  return null;\n-            nindex = ((Constant)con).itemIndex();\n-            if (isConstant(con = args.get(argi++), CONSTANT_MethodType) ||\n-                isConstant(con, CONSTANT_Class)) {\n-                tindex = ((Constant)con).itemIndex();\n-            } else return null;\n-            ntindex = (short) cf.pool.addConstant(CONSTANT_NameAndType,\n-                    new Short[]{ nindex, tindex }).index;\n-            byte reftag = CONSTANT_Method;\n-            if (refKind <= REF_putStatic)\n-                reftag = CONSTANT_Field;\n-            else if (refKind == REF_invokeInterface)\n-                reftag = CONSTANT_InterfaceMethod;\n-            Constant ref = cf.pool.addConstant(reftag, new Short[]{ cindex, ntindex });\n-            return cf.pool.addConstant(CONSTANT_MethodHandle, new Object[]{ refKind, (short)ref.index });\n+\n+        private PoolEntry parseMemberLookup(byte refKind, List<Object> args){\n+            \/\/E.g.: lookup().findStatic(Foo.class, \"name\", MethodType)\n+            if(args.size() != 4) return null;\n+\n+            NameAndTypeEntry nameAndTypeEntry;\n+            Utf8Entry name, type;\n+            ClassEntry ownerClass;\n+\n+            if(!\"lookup\".equals(args.getFirst())) return null;\n+\n+            if(args.get(1) instanceof ClassEntry classEntry) ownerClass = classEntry;\n+            else return null;\n+\n+            if(args.get(2) instanceof StringEntry stringEntry) name = stringEntry.utf8();\n+            else return null;\n+\n+            if(args.get(3) instanceof MethodTypeEntry methodTypeEntry) type = methodTypeEntry.descriptor();\n+            else return null;\n+\n+            nameAndTypeEntry = poolBuilder.nameAndTypeEntry(name,type);\n+\n+            MemberRefEntry ref;\n+            if(refKind <= (byte) STATIC_SETTER.refKind){\n+                 ref = poolBuilder.fieldRefEntry(ownerClass, nameAndTypeEntry);\n+                return poolBuilder.methodHandleEntry(refKind, ref);\n+            }\n+            else if(refKind == (byte) INTERFACE_VIRTUAL.refKind){\n+                ref = poolBuilder.interfaceMethodRefEntry(ownerClass, nameAndTypeEntry);\n+                return poolBuilder.methodHandleEntry(refKind, ref);\n+            }\n+            else{\n+                ref = poolBuilder.methodRefEntry(ownerClass, nameAndTypeEntry);\n+            }\n+            return poolBuilder.methodHandleEntry(refKind, ref);\n@@ -1016,1 +1135,2 @@\n-        private Constant makeInvokeDynamicCon(List<Object> args) {\n+\n+        private PoolEntry makeInvokeDynamicCon(List<Object> args) {\n@@ -1019,1 +1139,1 @@\n-            if (args.size() < 4)  return null;\n+            if(args.size() < 4) return null;\n@@ -1021,1 +1141,0 @@\n-            short nindex, tindex, ntindex, bsmindex;\n@@ -1023,2 +1142,7 @@\n-            if (!isConstant(con = args.get(argi++), CONSTANT_MethodHandle))  return null;\n-            bsmindex = (short) ((Constant)con).index;\n+            Utf8Entry name, type;\n+            NameAndTypeEntry nameAndTypeEntry;\n+            MethodHandleEntry bootstrapMethod;\n+\n+            if (!((con = args.get(argi++)) instanceof MethodHandleEntry)) return null;\n+            bootstrapMethod = ((MethodHandleEntry) con);\n+\n@@ -1026,7 +1150,9 @@\n-            if (!isConstant(con = args.get(argi++), CONSTANT_String))  return null;\n-            nindex = ((Constant)con).itemIndex();\n-            if (!isConstant(con = args.get(argi++), CONSTANT_MethodType))  return null;\n-            tindex = ((Constant)con).itemIndex();\n-            ntindex = (short) cf.pool.addConstant(CONSTANT_NameAndType,\n-                                                  new Short[]{ nindex, tindex }).index;\n-            List<Object> extraArgs = new ArrayList<Object>();\n+            if (!((con = args.get(argi++)) instanceof StringEntry)) return null;\n+            name = ((StringEntry) con).utf8();\n+\n+            if (!((con = args.get(argi++)) instanceof MethodTypeEntry)) return null;\n+            type = ((MethodTypeEntry) con).descriptor();\n+\n+            nameAndTypeEntry = poolBuilder.nameAndTypeEntry(name, type);\n+\n+            List<Object> extraArgs = new ArrayList<>();\n@@ -1035,1 +1161,1 @@\n-                Object lastArg = args.get(args.size() - 1);\n+                Object lastArg = args.getLast();\n@@ -1045,1 +1171,1 @@\n-            List<Short> extraArgIndexes = new CountedList<>(Short.class);\n+            List<ConstantDesc> extraArgConstantDescs = new ArrayList<>();\n@@ -1048,6 +1174,2 @@\n-                    Object num = null; byte numTag = 0;\n-                    if (x instanceof Integer) { num = x; numTag = CONSTANT_Integer; }\n-                    if (x instanceof Float)   { num = Float.floatToRawIntBits((Float)x); numTag = CONSTANT_Float; }\n-                    if (x instanceof Long)    { num = x; numTag = CONSTANT_Long; }\n-                    if (x instanceof Double)  { num = Double.doubleToRawLongBits((Double)x); numTag = CONSTANT_Double; }\n-                    if (num != null)  x = cf.pool.addConstant(numTag, x);\n+                    extraArgConstantDescs.add(((ConstantDesc) x));\n+                    continue;\n@@ -1055,1 +1177,1 @@\n-                if (!(x instanceof Constant)) {\n+                if (!(x instanceof PoolEntry)) {\n@@ -1059,11 +1181,2 @@\n-                extraArgIndexes.add((short) ((Constant)x).index);\n-            }\n-            List<Object[]> specs = bootstrapMethodSpecifiers(true);\n-            int specindex = -1;\n-            Object[] spec = new Object[]{ bsmindex, extraArgIndexes };\n-            for (Object[] spec1 : specs) {\n-                if (Arrays.equals(spec1, spec)) {\n-                    specindex = specs.indexOf(spec1);\n-                    if (verbose)  System.err.println(\"reusing BSM specifier: \"+spec1[0]+spec1[1]);\n-                    break;\n-                }\n+                assert x instanceof LoadableConstantEntry;\n+                extraArgConstantDescs.add((((LoadableConstantEntry) x).constantValue()));\n@@ -1071,8 +1184,0 @@\n-            if (specindex == -1) {\n-                specindex = (short) specs.size();\n-                specs.add(spec);\n-                if (verbose)  System.err.println(\"adding BSM specifier: \"+spec[0]+spec[1]);\n-            }\n-            return cf.pool.addConstant(CONSTANT_InvokeDynamic,\n-                        new Short[]{ (short)specindex, ntindex });\n-        }\n@@ -1080,27 +1185,2 @@\n-        List<Object[]> bootstrapMethodSpecifiers(boolean createIfNotFound) {\n-            Attr bsms = cf.findAttr(\"BootstrapMethods\");\n-            if (bsms == null) {\n-                if (!createIfNotFound)  return null;\n-                bsms = new Attr(cf, \"BootstrapMethods\", new byte[]{0,0});\n-                assert(bsms == cf.findAttr(\"BootstrapMethods\"));\n-            }\n-            if (bsms.item instanceof byte[]) {\n-                \/\/ unflatten\n-                List<Object[]> specs = new CountedList<>(Object[].class);\n-                DataInputStream in = new DataInputStream(new ByteArrayInputStream((byte[]) bsms.item));\n-                try {\n-                    int len = (char) in.readShort();\n-                    for (int i = 0; i < len; i++) {\n-                        short bsm = in.readShort();\n-                        int argc = (char) in.readShort();\n-                        List<Short> argv = new CountedList<>(Short.class);\n-                        for (int j = 0; j < argc; j++)\n-                            argv.add(in.readShort());\n-                        specs.add(new Object[]{ bsm, argv });\n-                    }\n-                } catch (IOException ex) { throw new InternalError(); }\n-                bsms.item = specs;\n-            }\n-            @SuppressWarnings(\"unchecked\")\n-            List<Object[]> specs = (List<Object[]>) bsms.item;\n-            return specs;\n+            BootstrapMethodEntry bsmEntry = poolBuilder.bsmEntry(bootstrapMethod.asSymbol(), extraArgConstantDescs);\n+            return poolBuilder.invokeDynamicEntry(bsmEntry, nameAndTypeEntry);\n@@ -1110,30 +1190,3 @@\n-    private DataInputStream openInput(File f) throws IOException {\n-        return new DataInputStream(new BufferedInputStream(new FileInputStream(f)));\n-    }\n-\n-    private DataOutputStream openOutput(File f) throws IOException {\n-        if (!overwrite && f.exists())\n-            throw new IOException(\"file already exists: \"+f);\n-        ensureDirectory(f.getParentFile());\n-        return new DataOutputStream(new BufferedOutputStream(new FileOutputStream(f)));\n-    }\n-\n-    static byte[] readRawBytes(DataInputStream in, int size) throws IOException {\n-        byte[] bytes = new byte[size];\n-        int nr = in.read(bytes);\n-        if (nr != size)\n-            throw new InternalError(\"wrong size: \"+nr);\n-        return bytes;\n-    }\n-\n-    private interface Chunk {\n-        void readFrom(DataInputStream in) throws IOException;\n-        void writeTo(DataOutputStream out) throws IOException;\n-    }\n-\n-    private static class CountedList<T> extends ArrayList<T> implements Chunk {\n-        final Class<? extends T> itemClass;\n-        final int rowlen;\n-        CountedList(Class<? extends T> itemClass, int rowlen) {\n-            this.itemClass = itemClass;\n-            this.rowlen = rowlen;\n+    private byte[] openInputIntoBytes(File f) throws IOException{\n+        try{\n+            return Files.readAllBytes(f.toPath());\n@@ -1141,20 +1194,2 @@\n-        CountedList(Class<? extends T> itemClass) { this(itemClass, -1); }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            int count = in.readUnsignedShort();\n-            while (size() < count) {\n-                if (rowlen < 0) {\n-                    add(readInput(in, itemClass));\n-                } else {\n-                    Class<?> elemClass = itemClass.getComponentType();\n-                    Object[] row = (Object[]) java.lang.reflect.Array.newInstance(elemClass, rowlen);\n-                    for (int i = 0; i < rowlen; i++)\n-                        row[i] = readInput(in, elemClass);\n-                    add(itemClass.cast(row));\n-                }\n-            }\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            out.writeShort((short)size());\n-            for (T item : this) {\n-                writeOutput(out, item);\n-            }\n+        catch(IOException e){\n+            throw new IOException(\"Error reading file: \"+f);\n@@ -1164,208 +1199,2 @@\n-    private static <T> T readInput(DataInputStream in, Class<T> dataClass) throws IOException {\n-        Object data;\n-        if (dataClass == Integer.class) {\n-            data = in.readInt();\n-        } else if (dataClass == Short.class) {\n-            data = in.readShort();\n-        } else if (dataClass == Byte.class) {\n-            data = in.readByte();\n-        } else if (dataClass == String.class) {\n-            data = in.readUTF();\n-        } else if (Chunk.class.isAssignableFrom(dataClass)) {\n-            T obj;\n-            try { obj = dataClass.getDeclaredConstructor().newInstance(); }\n-                catch (Exception ex) { throw new RuntimeException(ex); }\n-            ((Chunk)obj).readFrom(in);\n-            data = obj;\n-        } else {\n-            throw new InternalError(\"bad input datum: \"+dataClass);\n-        }\n-        return dataClass.cast(data);\n-    }\n-    private static <T> T readInput(byte[] bytes, Class<T> dataClass) {\n-        try {\n-            return readInput(new DataInputStream(new ByteArrayInputStream(bytes)), dataClass);\n-        } catch (IOException ex) {\n-            throw new InternalError();\n-        }\n-    }\n-    private static void readInputs(DataInputStream in, Object... data) throws IOException {\n-        for (Object x : data)  ((Chunk)x).readFrom(in);\n-    }\n-\n-    private static void writeOutput(DataOutputStream out, Object data) throws IOException {\n-        if (data == null) {\n-            return;\n-        } if (data instanceof Integer) {\n-            out.writeInt((Integer)data);\n-        } else if (data instanceof Long) {\n-            out.writeLong((Long)data);\n-        } else if (data instanceof Short) {\n-            out.writeShort((Short)data);\n-        } else if (data instanceof Byte) {\n-            out.writeByte((Byte)data);\n-        } else if (data instanceof String) {\n-            out.writeUTF((String)data);\n-        } else if (data instanceof byte[]) {\n-            out.write((byte[])data);\n-        } else if (data instanceof Object[]) {\n-            for (Object x : (Object[]) data)\n-                writeOutput(out, x);\n-        } else if (data instanceof Chunk) {\n-            Chunk x = (Chunk) data;\n-            x.writeTo(out);\n-        } else if (data instanceof List) {\n-            for (Object x : (List<?>) data)\n-                writeOutput(out, x);\n-        } else {\n-            throw new InternalError(\"bad output datum: \"+data+\" : \"+data.getClass().getName());\n-        }\n-    }\n-    private static void writeOutputs(DataOutputStream out, Object... data) throws IOException {\n-        for (Object x : data)  writeOutput(out, x);\n-    }\n-\n-    public abstract static class Outer {\n-        public abstract List<? extends Inner> inners();\n-        protected void linkInners() {\n-            for (Inner i : inners()) {\n-                i.linkOuter(this);\n-                if (i instanceof Outer)\n-                    ((Outer)i).linkInners();\n-            }\n-        }\n-        public <T extends Outer> T outer(Class<T> c) {\n-            for (Outer walk = this;; walk = ((Inner)walk).outer()) {\n-                if (c.isInstance(walk))\n-                    return c.cast(walk);\n-                \/\/if (!(walk instanceof Inner))  return null;\n-            }\n-        }\n-\n-        public abstract List<Attr> attrs();\n-        public Attr findAttr(String name) {\n-            return findAttr(outer(ClassFile.class).pool.stringIndex(name, false));\n-        }\n-        public Attr findAttr(int name) {\n-            if (name == 0)  return null;\n-            for (Attr a : attrs()) {\n-                if (a.name == name)  return a;\n-            }\n-            return null;\n-        }\n-    }\n-    public interface Inner { Outer outer(); void linkOuter(Outer o); }\n-    public abstract static class InnerOuter extends Outer implements Inner {\n-        public Outer outer;\n-        public Outer outer() { return outer; }\n-        public void linkOuter(Outer o) { assert(outer == null); outer = o; }\n-    }\n-    public static class Constant<T> implements Chunk {\n-        public final byte tag;\n-        public final T item;\n-        public final int index;\n-        public Constant(int index, byte tag, T item) {\n-            this.index = index;\n-            this.tag = tag;\n-            this.item = item;\n-        }\n-        public Constant checkTag(byte tag) {\n-            if (this.tag != tag)  throw new InternalError(this.toString());\n-            return this;\n-        }\n-        public String itemString() { return (String)item; }\n-        public Short itemIndex() { return (Short)item; }\n-        public Short[] itemIndexes() { return (Short[])item; }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            throw new InternalError(\"do not call\");\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, tag, item);\n-        }\n-        public boolean equals(Object x) { return (x instanceof Constant && equals((Constant)x)); }\n-        public boolean equals(Constant that) {\n-            return (this.tag == that.tag && this.itemAsComparable().equals(that.itemAsComparable()));\n-        }\n-        public int hashCode() { return (tag * 31) + this.itemAsComparable().hashCode(); }\n-        public Object itemAsComparable() {\n-            switch (tag) {\n-            case CONSTANT_Double:   return Double.longBitsToDouble((Long)item);\n-            case CONSTANT_Float:    return Float.intBitsToFloat((Integer)item);\n-            }\n-            return (item instanceof Object[] ? Arrays.asList((Object[])item) : item);\n-        }\n-        public String toString() {\n-            String itstr = String.valueOf(itemAsComparable());\n-            return (index + \":\" + tagName(tag) + (itstr.startsWith(\"[\")?\"\":\"=\") + itstr);\n-        }\n-        private static String[] TAG_NAMES;\n-        public static String tagName(byte tag) {  \/\/ used for error messages\n-            if (TAG_NAMES == null)\n-                TAG_NAMES = (\"None Utf8 Unicode Integer Float Long Double Class String\"\n-                             +\" Fieldref Methodref InterfaceMethodref NameAndType #13 #14\"\n-                             +\" MethodHandle MethodType InvokeDynamic#17 InvokeDynamic\").split(\" \");\n-            if ((tag & 0xFF) >= TAG_NAMES.length)  return \"#\"+(tag & 0xFF);\n-            return TAG_NAMES[tag & 0xFF];\n-        }\n-    }\n-\n-    public static class Pool extends CountedList<Constant> implements Chunk {\n-        private Map<String,Short> strings = new TreeMap<>();\n-\n-        public Pool() {\n-            super(Constant.class);\n-        }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            int count = in.readUnsignedShort();\n-            add(null);  \/\/ always ignore first item\n-            while (size() < count) {\n-                readConstant(in);\n-            }\n-        }\n-        public <T> Constant addConstant(byte tag, T item) {\n-            Constant<T> con = new Constant<>(size(), tag, item);\n-            int idx = indexOf(con);\n-            if (idx >= 0)  return get(idx);\n-            add(con);\n-            if (tag == CONSTANT_Utf8)  strings.put((String)item, (short) con.index);\n-            return con;\n-        }\n-        private void readConstant(DataInputStream in) throws IOException {\n-            byte tag = in.readByte();\n-            int index = size();\n-            Object arg;\n-            switch (tag) {\n-            case CONSTANT_Utf8:\n-                arg = in.readUTF();\n-                strings.put((String) arg, (short) size());\n-                break;\n-            case CONSTANT_Integer:\n-            case CONSTANT_Float:\n-                arg = in.readInt(); break;\n-            case CONSTANT_Long:\n-            case CONSTANT_Double:\n-                add(new Constant<>(index, tag, in.readLong()));\n-                add(null);\n-                return;\n-            case CONSTANT_Class:\n-            case CONSTANT_String:\n-                arg = in.readShort(); break;\n-            case CONSTANT_Field:\n-            case CONSTANT_Method:\n-            case CONSTANT_InterfaceMethod:\n-            case CONSTANT_NameAndType:\n-            case CONSTANT_InvokeDynamic:\n-                \/\/ read an ordered pair\n-                arg = new Short[] { in.readShort(), in.readShort() };\n-                break;\n-            case CONSTANT_MethodHandle:\n-                \/\/ read an ordered pair; first part is a u1 (not u2)\n-                arg = new Object[] { in.readByte(), in.readShort() };\n-                break;\n-            case CONSTANT_MethodType:\n-                arg = in.readShort(); break;\n-            default:\n-                throw new InternalError(\"bad CP tag \"+tag);\n-            }\n-            add(new Constant<>(index, tag, arg));\n-        }\n+    private ClassModel parseClassFile(File f) throws IOException{\n+        byte[] bytes = openInputIntoBytes(f);\n@@ -1373,459 +1202,7 @@\n-        \/\/ Access:\n-        public Constant get(int index) {\n-            \/\/ extra 1-bits get into the shorts\n-            return super.get((char) index);\n-        }\n-        String getString(byte tag, short index) {\n-            get(index).checkTag(tag);\n-            return getString(index);\n-        }\n-        String getString(short index) {\n-            Object v = get(index).item;\n-            if (v instanceof Short)\n-                v = get((Short)v).checkTag(CONSTANT_Utf8).item;\n-            return (String) v;\n-        }\n-        String[] getStrings(Short[] indexes) {\n-            String[] res = new String[indexes.length];\n-            for (int i = 0; i < indexes.length; i++)\n-                res[i] = getString(indexes[i]);\n-            return res;\n-        }\n-        int stringIndex(String name, boolean createIfNotFound) {\n-            Short x = strings.get(name);\n-            if (x != null)  return (char)(int) x;\n-            if (!createIfNotFound)  return 0;\n-            return addConstant(CONSTANT_Utf8, name).index;\n-        }\n-        Short[] getMemberRef(short index) {\n-            Short[] cls_nnt = get(index).itemIndexes();\n-            Short[] name_type = get(cls_nnt[1]).itemIndexes();\n-            return new Short[]{ cls_nnt[0], name_type[0], name_type[1] };\n-        }\n-    }\n-\n-    public class ClassFile extends Outer implements Chunk {\n-        ClassFile(File f) throws IOException {\n-            DataInputStream in = openInput(f);\n-            try {\n-                readFrom(in);\n-            } finally {\n-                if (in != null)  in.close();\n-            }\n-        }\n-\n-        public int                magic, version;  \/\/ <min:maj>\n-        public final Pool         pool       = new Pool();\n-        public short              access, thisc, superc;\n-        public final List<Short>  interfaces = new CountedList<>(Short.class);\n-        public final List<Field>  fields     = new CountedList<>(Field.class);\n-        public final List<Method> methods    = new CountedList<>(Method.class);\n-        public final List<Attr>   attrs      = new CountedList<>(Attr.class);\n-\n-        public final void readFrom(DataInputStream in) throws IOException {\n-            magic = in.readInt(); version = in.readInt();\n-            if (magic != 0xCAFEBABE)  throw new IOException(\"bad magic number\");\n-            pool.readFrom(in);\n-            Code_index = pool.stringIndex(\"Code\", false);\n-            access = in.readShort(); thisc = in.readShort(); superc = in.readShort();\n-            readInputs(in, interfaces, fields, methods, attrs);\n-            if (in.read() >= 0)  throw new IOException(\"junk after end of file\");\n-            linkInners();\n-        }\n-\n-        void writeTo(File f) throws IOException {\n-            DataOutputStream out = openOutput(f);\n-            try {\n-                writeTo(out);\n-            } finally {\n-                out.close();\n-            }\n-        }\n-\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, magic, version, pool,\n-                         access, thisc, superc, interfaces,\n-                         fields, methods, attrs);\n-        }\n-\n-        public byte[] toByteArray() {\n-            try {\n-                ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-                writeTo(new DataOutputStream(buf));\n-                return buf.toByteArray();\n-            } catch (IOException ex) {\n-                throw new InternalError();\n-            }\n-        }\n-\n-        public List<Inner> inners() {\n-            List<Inner> inns = new ArrayList<>();\n-            inns.addAll(fields); inns.addAll(methods); inns.addAll(attrs);\n-            return inns;\n-        }\n-        public List<Attr> attrs() { return attrs; }\n-\n-        \/\/ derived stuff:\n-        public String nameString() { return pool.getString(CONSTANT_Class, thisc); }\n-        int Code_index;\n-    }\n-\n-    private static <T extends Member> T findMember(List<T> mems, int name, int type) {\n-        if (name == 0 || type == 0)  return null;\n-        for (T m : mems) {\n-            if (m.name == name && m.type == type)  return m;\n-        }\n-        return null;\n-    }\n-\n-    public static class Member extends InnerOuter implements Chunk {\n-        public short access, name, type;\n-        public final List<Attr> attrs = new CountedList<>(Attr.class);\n-        public void readFrom(DataInputStream in) throws IOException {\n-            access = in.readShort(); name = in.readShort(); type = in.readShort();\n-            readInputs(in, attrs);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, access, name, type, attrs);\n-        }\n-        public List<Attr> inners() { return attrs; }\n-        public List<Attr> attrs() { return attrs; }\n-        public ClassFile outer() { return (ClassFile) outer; }\n-        public String nameString() { return outer().pool.getString(CONSTANT_Utf8, name); }\n-        public String typeString() { return outer().pool.getString(CONSTANT_Utf8, type); }\n-        public String toString() {\n-            if (outer == null)  return super.toString();\n-            return nameString() + (this instanceof Method ? \"\" : \":\")\n-                    + simplifyType(typeString());\n-        }\n-    }\n-    public static class Field extends Member {\n-    }\n-    public static class Method extends Member {\n-        public Code code() {\n-            Attr a = findAttr(\"Code\");\n-            if (a == null)  return null;\n-            return (Code) a.item;\n-        }\n-        public Instruction instructions() {\n-            Code code = code();\n-            if (code == null)  return null;\n-            return code.instructions();\n-        }\n-    }\n-\n-    public static class Attr extends InnerOuter implements Chunk {\n-        public short name;\n-        public int size = -1;  \/\/ no pre-declared size\n-        public Object item;\n-\n-        public Attr() {}\n-        public Attr(Outer outer, String name, Object item) {\n-            ClassFile cf = outer.outer(ClassFile.class);\n-            linkOuter(outer);\n-            this.name = (short) cf.pool.stringIndex(name, true);\n-            this.item = item;\n-            outer.attrs().add(this);\n-        }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            name = in.readShort();\n-            size = in.readInt();\n-            item = readRawBytes(in, size);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            out.writeShort(name);\n-            \/\/ write the 4-byte size header and then the contents:\n-            byte[] bytes;\n-            int trueSize;\n-            if (item instanceof byte[]) {\n-                bytes = (byte[]) item;\n-                out.writeInt(trueSize = bytes.length);\n-                out.write(bytes);\n-            } else {\n-                trueSize = flatten(out);\n-                \/\/if (!(item instanceof Code))  System.err.println(\"wrote complex attr name=\"+(int)(char)name+\" size=\"+trueSize+\" data=\"+Arrays.toString(flatten()));\n-            }\n-            if (trueSize != size && size >= 0)\n-                System.err.println(\"warning: attribute size changed \"+size+\" to \"+trueSize);\n-        }\n-        public void linkOuter(Outer o) {\n-            super.linkOuter(o);\n-            if (item instanceof byte[] &&\n-                outer instanceof Method &&\n-                ((Method)outer).outer().Code_index == name) {\n-                    item = readInput((byte[])item, Code.class);\n-            }\n-        }\n-        public List<Inner> inners() {\n-            if (item instanceof Inner)\n-                return Collections.nCopies(1, (Inner)item);\n-            return Collections.emptyList();\n-        }\n-        public List<Attr> attrs() { return null; }  \/\/ Code overrides this\n-        public byte[] flatten() {\n-            ByteArrayOutputStream buf = new ByteArrayOutputStream(Math.max(20, size));\n-            flatten(buf);\n-            return buf.toByteArray();\n-        }\n-        public int flatten(DataOutputStream out) throws IOException {\n-            ByteArrayOutputStream buf = new ByteArrayOutputStream(Math.max(20, size));\n-            int trueSize = flatten(buf);\n-            out.writeInt(trueSize);\n-            buf.writeTo(out);\n-            return trueSize;\n-        }\n-        private int flatten(ByteArrayOutputStream buf) {\n-            try {\n-                writeOutput(new DataOutputStream(buf), item);\n-                return buf.size();\n-            } catch (IOException ex) {\n-                throw new InternalError();\n-            }\n-        }\n-        public String nameString() {\n-            ClassFile cf = outer(ClassFile.class);\n-            if (cf == null)  return \"#\"+name;\n-            return cf.pool.getString(name);\n-        }\n-        public String toString() {\n-            return nameString()+(size < 0 ? \"=\" : \"[\"+size+\"]=\")+item;\n-        }\n-    }\n-\n-    public static class Code extends InnerOuter implements Chunk {\n-        public short stacks, locals;\n-        public byte[] bytes;\n-        public final List<Short[]> etable = new CountedList<>(Short[].class, 4);\n-        public final List<Attr> attrs = new CountedList<>(Attr.class);\n-        \/\/ etable[N] = (N)*{ startpc, endpc, handlerpc, catchtype }\n-        public void readFrom(DataInputStream in) throws IOException {\n-            stacks = in.readShort(); locals = in.readShort();\n-            bytes = readRawBytes(in, in.readInt());\n-            readInputs(in, etable, attrs);\n-        }\n-        public void writeTo(DataOutputStream out) throws IOException {\n-            writeOutputs(out, stacks, locals, bytes.length, bytes, etable, attrs);\n-        }\n-        public List<Attr> inners() { return attrs; }\n-        public List<Attr> attrs() { return attrs; }\n-        public Instruction instructions() {\n-            return new Instruction(bytes, 0);\n-        }\n-    }\n-\n-    \/\/ lots of constants\n-    private static final byte\n-        CONSTANT_Utf8              = 1,\n-        CONSTANT_Integer           = 3,\n-        CONSTANT_Float             = 4,\n-        CONSTANT_Long              = 5,\n-        CONSTANT_Double            = 6,\n-        CONSTANT_Class             = 7,\n-        CONSTANT_String            = 8,\n-        CONSTANT_Field             = 9,\n-        CONSTANT_Method            = 10,\n-        CONSTANT_InterfaceMethod   = 11,\n-        CONSTANT_NameAndType       = 12,\n-        CONSTANT_MethodHandle      = 15,  \/\/ JSR 292\n-        CONSTANT_MethodType        = 16,  \/\/ JSR 292\n-        CONSTANT_InvokeDynamic     = 18;  \/\/ JSR 292\n-    private static final byte\n-        REF_getField               = 1,\n-        REF_getStatic              = 2,\n-        REF_putField               = 3,\n-        REF_putStatic              = 4,\n-        REF_invokeVirtual          = 5,\n-        REF_invokeStatic           = 6,\n-        REF_invokeSpecial          = 7,\n-        REF_newInvokeSpecial       = 8,\n-        REF_invokeInterface        = 9;\n-\n-    private static final int\n-        opc_nop                    = 0,\n-        opc_aconst_null            = 1,\n-        opc_nconst_MIN             = 2,  \/\/ iconst_m1\n-        opc_nconst_MAX             = 15, \/\/ dconst_1\n-        opc_bipush                 = 16,\n-        opc_sipush                 = 17,\n-        opc_ldc                    = 18,\n-        opc_ldc_w                  = 19,\n-        opc_ldc2_w                 = 20,\n-        opc_aload                  = 25,\n-        opc_aload_0                = 42,\n-        opc_aload_MAX              = 45,\n-        opc_aaload                 = 50,\n-        opc_astore                 = 58,\n-        opc_astore_0               = 75,\n-        opc_astore_MAX             = 78,\n-        opc_aastore                = 83,\n-        opc_pop                    = 87,\n-        opc_pop2                   = 88,\n-        opc_dup                    = 89,\n-        opc_dup_x1                 = 90,\n-        opc_dup_x2                 = 91,\n-        opc_dup2                   = 92,\n-        opc_dup2_x1                = 93,\n-        opc_dup2_x2                = 94,\n-        opc_swap                   = 95,\n-        opc_tableswitch            = 170,\n-        opc_lookupswitch           = 171,\n-        opc_areturn                = 176,\n-        opc_getstatic              = 178,\n-        opc_putstatic              = 179,\n-        opc_getfield               = 180,\n-        opc_putfield               = 181,\n-        opc_invokevirtual          = 182,\n-        opc_invokespecial          = 183,\n-        opc_invokestatic           = 184,\n-        opc_invokeinterface        = 185,\n-        opc_invokedynamic          = 186,\n-        opc_new                    = 187,\n-        opc_anewarray              = 189,\n-        opc_checkcast              = 192,\n-        opc_ifnull                 = 198,\n-        opc_ifnonnull              = 199,\n-        opc_wide                   = 196;\n-\n-    private static final Object[] INSTRUCTION_CONSTANTS = {\n-        -1, 0, 1, 2, 3, 4, 5, 0L, 1L, 0.0F, 1.0F, 2.0F, 0.0D, 1.0D\n-    };\n-\n-    private static final String INSTRUCTION_FORMATS =\n-        \"nop$ aconst_null$L iconst_m1$I iconst_0$I iconst_1$I \"+\n-        \"iconst_2$I iconst_3$I iconst_4$I iconst_5$I lconst_0$J_ \"+\n-        \"lconst_1$J_ fconst_0$F fconst_1$F fconst_2$F dconst_0$D_ \"+\n-        \"dconst_1$D_ bipush=bx$I sipush=bxx$I ldc=bk$X ldc_w=bkk$X \"+\n-        \"ldc2_w=bkk$X_ iload=bl\/wbll$I lload=bl\/wbll$J_ fload=bl\/wbll$F \"+\n-        \"dload=bl\/wbll$D_ aload=bl\/wbll$L iload_0$I iload_1$I \"+\n-        \"iload_2$I iload_3$I lload_0$J_ lload_1$J_ lload_2$J_ \"+\n-        \"lload_3$J_ fload_0$F fload_1$F fload_2$F fload_3$F dload_0$D_ \"+\n-        \"dload_1$D_ dload_2$D_ dload_3$D_ aload_0$L aload_1$L \"+\n-        \"aload_2$L aload_3$L iaload$LI$I laload$LI$J_ faload$LI$F \"+\n-        \"daload$LI$D_ aaload$LI$L baload$LI$I caload$LI$I saload$LI$I \"+\n-        \"istore=bl\/wbll$I$ lstore=bl\/wbll$J_$ fstore=bl\/wbll$F$ \"+\n-        \"dstore=bl\/wbll$D_$ astore=bl\/wbll$L$ istore_0$I$ istore_1$I$ \"+\n-        \"istore_2$I$ istore_3$I$ lstore_0$J_$ lstore_1$J_$ \"+\n-        \"lstore_2$J_$ lstore_3$J_$ fstore_0$F$ fstore_1$F$ fstore_2$F$ \"+\n-        \"fstore_3$F$ dstore_0$D_$ dstore_1$D_$ dstore_2$D_$ \"+\n-        \"dstore_3$D_$ astore_0$L$ astore_1$L$ astore_2$L$ astore_3$L$ \"+\n-        \"iastore$LII$ lastore$LIJ_$ fastore$LIF$ dastore$LID_$ \"+\n-        \"aastore$LIL$ bastore$LII$ castore$LII$ sastore$LII$ pop$X$ \"+\n-        \"pop2$XX$ dup$X$XX dup_x1$XX$XXX dup_x2$XXX$XXXX dup2$XX$XXXX \"+\n-        \"dup2_x1$XXX$XXXXX dup2_x2$XXXX$XXXXXX swap$XX$XX \"+\n-        \"iadd$II$I ladd$J_J_$J_ fadd$FF$F dadd$D_D_$D_ isub$II$I \"+\n-        \"lsub$J_J_$J_ fsub$FF$F dsub$D_D_$D_ imul$II$I lmul$J_J_$J_ \"+\n-        \"fmul$FF$F dmul$D_D_$D_ idiv$II$I ldiv$J_J_$J_ fdiv$FF$F \"+\n-        \"ddiv$D_D_$D_ irem$II$I lrem$J_J_$J_ frem$FF$F drem$D_D_$D_ \"+\n-        \"ineg$I$I lneg$J_$J_ fneg$F$F dneg$D_$D_ ishl$II$I lshl$J_I$J_ \"+\n-        \"ishr$II$I lshr$J_I$J_ iushr$II$I lushr$J_I$J_ iand$II$I \"+\n-        \"land$J_J_$J_ ior$II$I lor$J_J_$J_ ixor$II$I lxor$J_J_$J_ \"+\n-        \"iinc=blx\/wbllxx$ i2l$I$J_ i2f$I$F i2d$I$D_ l2i$J_$I l2f$J_$F \"+\n-        \"l2d$J_$D_ f2i$F$I f2l$F$J_ f2d$F$D_ d2i$D_$I d2l$D_$J_ \"+\n-        \"d2f$D_$F i2b$I$I i2c$I$I i2s$I$I lcmp fcmpl fcmpg dcmpl dcmpg \"+\n-        \"ifeq=boo ifne=boo iflt=boo ifge=boo ifgt=boo ifle=boo \"+\n-        \"if_icmpeq=boo if_icmpne=boo if_icmplt=boo if_icmpge=boo \"+\n-        \"if_icmpgt=boo if_icmple=boo if_acmpeq=boo if_acmpne=boo \"+\n-        \"goto=boo jsr=boo ret=bl\/wbll tableswitch=* lookupswitch=* \"+\n-        \"ireturn lreturn freturn dreturn areturn return \"+\n-        \"getstatic=bkf$Q putstatic=bkf$Q$ getfield=bkf$L$Q \"+\n-        \"putfield=bkf$LQ$ invokevirtual=bkm$LQ$Q \"+\n-        \"invokespecial=bkm$LQ$Q invokestatic=bkm$Q$Q \"+\n-        \"invokeinterface=bkixx$LQ$Q invokedynamic=bkd__$Q$Q new=bkc$L \"+\n-        \"newarray=bx$I$L anewarray=bkc$I$L arraylength$L$I athrow \"+\n-        \"checkcast=bkc$L$L instanceof=bkc$L$I monitorenter$L \"+\n-        \"monitorexit$L wide=* multianewarray=bkcx ifnull=boo \"+\n-        \"ifnonnull=boo goto_w=boooo jsr_w=boooo \";\n-    private static final String[] INSTRUCTION_NAMES;\n-    private static final String[] INSTRUCTION_POPS;\n-    private static final int[] INSTRUCTION_INFO;\n-    static {\n-        String[] insns = INSTRUCTION_FORMATS.split(\" \");\n-        assert(insns[opc_lookupswitch].startsWith(\"lookupswitch\"));\n-        assert(insns[opc_tableswitch].startsWith(\"tableswitch\"));\n-        assert(insns[opc_wide].startsWith(\"wide\"));\n-        assert(insns[opc_invokedynamic].startsWith(\"invokedynamic\"));\n-        int[] info = new int[256];\n-        String[] names = new String[256];\n-        String[] pops = new String[256];\n-        for (int i = 0; i < insns.length; i++) {\n-            String insn = insns[i];\n-            int dl = insn.indexOf('$');\n-            if (dl > 0) {\n-                String p = insn.substring(dl+1);\n-                if (p.indexOf('$') < 0)  p = \"$\" + p;\n-                pops[i] = p;\n-                insn = insn.substring(0, dl);\n-            }\n-            int eq = insn.indexOf('=');\n-            if (eq < 0) {\n-                info[i] = 1;\n-                names[i] = insn;\n-                continue;\n-            }\n-            names[i] = insn.substring(0, eq);\n-            String fmt = insn.substring(eq+1);\n-            if (fmt.equals(\"*\")) {\n-                info[i] = 0;\n-                continue;\n-            }\n-            int sl = fmt.indexOf('\/');\n-            if (sl < 0) {\n-                info[i] = (char) fmt.length();\n-            } else {\n-                String wfmt = fmt.substring(sl+1);\n-                fmt = fmt.substring(0, sl);\n-                info[i] = (char)( fmt.length() + (wfmt.length() * 16) );\n-            }\n-        }\n-        INSTRUCTION_INFO = info;\n-        INSTRUCTION_NAMES = names;\n-        INSTRUCTION_POPS = pops;\n-    }\n-\n-    public static class Instruction implements Cloneable {\n-        byte[] codeBase;\n-        int pc;\n-        int bc;\n-        int info;\n-        int wide;\n-        int len;\n-        Instruction(byte[] codeBase, int pc) {\n-            this.codeBase = codeBase;\n-            init(pc);\n-        }\n-        public Instruction clone() {\n-            try {\n-                return (Instruction) super.clone();\n-            } catch (CloneNotSupportedException ex) {\n-                throw new InternalError();\n-            }\n-        }\n-        private Instruction init(int pc) {\n-            this.pc = pc;\n-            this.bc = codeBase[pc] & 0xFF;\n-            this.info = INSTRUCTION_INFO[bc];\n-            this.wide = 0;\n-            this.len = (info & 0x0F);\n-            if (len == 0)\n-                computeLength();\n-            return this;\n-        }\n-        Instruction next() {\n-            if (len == 0 && bc != 0)  throw new InternalError();\n-            int npc = pc + len;\n-            if (npc == codeBase.length)\n-                return null;\n-            return init(npc);\n-        }\n-        void forceNext(int newLen) {\n-            bc = opc_nop;\n-            len = newLen;\n-        }\n-\n-        public String toString() {\n-            StringBuilder buf = new StringBuilder();\n-            buf.append(pc).append(\":\").append(INSTRUCTION_NAMES[bc]);\n-            switch (len) {\n-            case 3: buf.append(\" \").append(u2At(1)); break;\n-            case 5: buf.append(\" \").append(u2At(1)).append(\" \").append(u2At(3)); break;\n-            default:  for (int i = 1; i < len; i++)  buf.append(\" \").append(u1At(1));\n+        try {\n+            List<VerifyError> errors = of().verify(bytes);\n+            if (!errors.isEmpty()) {\n+                for (VerifyError e : errors) {\n+                    System.err.println(e.getMessage());\n+                }\n+                throw new IOException(\"Verification failed\");\n@@ -1833,1 +1210,2 @@\n-            return buf.toString();\n+        } catch (IOException e) {\n+            System.err.println(e.getMessage());\n@@ -1836,49 +1214,1 @@\n-        \/\/ these are the hard parts\n-        private void computeLength() {\n-            int cases;\n-            switch (bc) {\n-            case opc_wide:\n-                bc = codeBase[pc + 1];\n-                info = INSTRUCTION_INFO[bc];\n-                len = ((info >> 4) & 0x0F);\n-                if (len == 0)  throw new RuntimeException(\"misplaced wide bytecode: \"+bc);\n-                return;\n-\n-            case opc_tableswitch:\n-                cases = (u4At(alignedIntOffset(2)) - u4At(alignedIntOffset(1)) + 1);\n-                len = alignedIntOffset(3 + cases*1);\n-                return;\n-\n-            case opc_lookupswitch:\n-                cases = u4At(alignedIntOffset(1));\n-                len = alignedIntOffset(2 + cases*2);\n-                return;\n-\n-            default:\n-                throw new RuntimeException(\"unknown bytecode: \"+bc);\n-            }\n-        }\n-        \/\/ switch code\n-        \/\/ clget the Nth int (where 0 is the first after the opcode itself)\n-        public int alignedIntOffset(int n) {\n-            int pos = pc + 1;\n-            pos += ((-pos) & 0x03);  \/\/ align it\n-            pos += (n * 4);\n-            return pos - pc;\n-        }\n-        public int u1At(int pos) {\n-            return (codeBase[pc+pos] & 0xFF);\n-        }\n-        public int u2At(int pos) {\n-            return (u1At(pos+0)<<8) + u1At(pos+1);\n-        }\n-        public int u4At(int pos) {\n-            return (u2At(pos+0)<<16) + u2At(pos+2);\n-        }\n-        public void u1AtPut(int pos, int x) {\n-            codeBase[pc+pos] = (byte)x;\n-        }\n-        public void u2AtPut(int pos, int x) {\n-            codeBase[pc+pos+0] = (byte)(x >> 8);\n-            codeBase[pc+pos+1] = (byte)(x >> 0);\n-        }\n+        return ClassFile.of().parse(bytes);\n","filename":"test\/jdk\/java\/lang\/invoke\/indify\/Indify.java","additions":746,"deletions":1416,"binary":false,"changes":2162,"status":"modified"}]}