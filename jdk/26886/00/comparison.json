{"files":[{"patch":"@@ -1841,3 +1841,0 @@\n-  \/\/ return a flag when a method terminates by throwing an exception\n-  \/\/ i.e. if an exception is thrown and it's not caught by the current method\n-  bool exception_exit = state->is_exception_detected() && !state->is_exception_caught();\n@@ -1849,11 +1846,7 @@\n-    \/\/ if the method hasn't been popped because of an exception then we populate\n-    \/\/ the return_value parameter for the callback. At this point we only have\n-    \/\/ the address of a \"raw result\" and we just call into the interpreter to\n-    \/\/ convert this into a jvalue.\n-    if (!exception_exit) {\n-      oop oop_result;\n-      BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n-      if (is_reference_type(type)) {\n-        result = Handle(thread, oop_result);\n-        value.l = JNIHandles::make_local(thread, result());\n-      }\n+    \/\/ At this point we only have the address of a \"raw result\" and\n+    \/\/ we just call into the interpreter to convert this into a jvalue.\n+    oop oop_result;\n+    BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n+    if (is_reference_type(type)) {\n+      result = Handle(thread, oop_result);\n+      value.l = JNIHandles::make_local(thread, result());\n@@ -1872,1 +1865,1 @@\n-    post_method_exit_inner(thread, mh, state, exception_exit, current_frame, value);\n+    post_method_exit_inner(thread, mh, state, false, current_frame, value);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that MethodExit event is correctly posted\n+ * if method is called while there is a pending exception on this thread.\n+ *\n+ * @bug 8365937\n+ * @run main\/othervm\/native -agentlib:TestMethodExitWithPendingException TestMethodExitWithPendingException\n+ *\/\n+public class TestMethodExitWithPendingException {\n+\n+    private static native void enable();\n+    private static native void disableAndCheck();\n+\n+    static String exceptionExit() {\n+        throw new RuntimeException(\"MyRuntimeException\");\n+    }\n+\n+\n+    \/\/ Called from ExceptionExit MethodExit callback via JNI.\n+    \/\/ So MyRuntimeException is thrown already and hasn't been caught yet\n+    \/\/ when this method is called.\n+    static String upCall() {\n+        return \"MyNewString\";\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"TestMethodExitWithPendingException\");\n+        try {\n+            enable();\n+            exceptionExit();\n+        } catch (RuntimeException e){\n+            disableAndCheck();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/TestMethodExitWithPendingException.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+bool method_exit_posted = false;\n+\/\/ This method exit callback actually works only for 2 methods:\n+\/\/ 1) for ExceptionExit it verifies that method exit\n+\/\/    has been popped by exception and call 'upCall' mthod using JNI.\n+\/\/ 2) for upCall method it verifies that event has correct\n+\/\/    return value and was not popped by exception.\n+\/\/ The event callback just exits for all other methods.\n+static void JNICALL\n+cbMethodExit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+             jboolean was_popped_by_exception, jvalue return_value) {\n+  const char * mname = get_method_name(jvmti, jni, method);\n+  if (strcmp(\"upCall\", mname) == 0) {\n+    if (was_popped_by_exception) {\n+      fatal(jni, \"The method's was_popped_by_exception value is incorrect.\");\n+    }\n+    jstring upcall_result = (jstring) return_value.l;\n+    const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+    if (str == nullptr) {\n+      fatal(jni ,\"Failed to convert Java string to C string.\");\n+    }\n+    if (strcmp(\"MyNewString\", str) != 0) {\n+      fatal(jni, \"The upCall result value is incorrect.\");\n+    }\n+    method_exit_posted = true;\n+  }\n+  if (strcmp(\"exceptionExit\", mname) != 0) {\n+    return;\n+  }\n+  if (!was_popped_by_exception) {\n+    fatal(jni, \"Should have was_popped_by_esxception = true.\");\n+  }\n+  jclass main_class = jni->FindClass(\"TestMethodExitWithPendingException\");\n+  if (main_class == nullptr) {\n+    fatal(jni,\"Can't find TestMethodExitWithPendingException class.\");\n+    return;\n+  }\n+  jmethodID upcall_method = jni->GetStaticMethodID(main_class,\n+      \"upCall\", \"()Ljava\/lang\/String;\");\n+  if (upcall_method == nullptr) {\n+    fatal(jni,\"Can't find upCall method.\");\n+  }\n+  \/\/ Call 'upCall' method while current thread has exception\n+  \/\/ that has been thrown but hasn't been caught yet.\n+  jstring upcall_result = (jstring) jni->CallStaticObjectMethod(main_class, upcall_method);\n+  const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+  if (str == nullptr) {\n+    fatal(jni ,\"Failed to convert Java string to C string.\");\n+    return;\n+  }\n+  if (strcmp(\"MyNewString\", str) != 0) {\n+    fatal(jni, \"The upCall result value is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(upcall_result, str);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_method_exit_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.MethodExit = &cbMethodExit;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+ return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_enable(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_disableAndCheck(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (!method_exit_posted) {\n+    fatal(jni, \"Failed to post method exit event.\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/libTestMethodExitWithPendingException.cpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main\/othervm\/native -agentlib:TestPoppedByException TestPoppedByException\n+ *\/\n+public class TestPoppedByException {\n+\n+    private static native void enable();\n+    private static native void disableAndCheck();\n+\n+   static String exceptionExit() {\n+        throw new RuntimeException(\"MyRuntimeException\");\n+    }\n+\n+    static String exceptionExitOuter() {\n+        return exceptionExit();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"TestPoppedByException\");\n+        try {\n+            enable();\n+            exceptionExitOuter();\n+        } catch (RuntimeException e){\n+            disableAndCheck();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PoppedByException\/TestPoppedByException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+bool method_exit_posted = false;\n+static void JNICALL\n+cbMethodExit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+             jboolean was_popped_by_exception, jvalue return_value) {\n+  const char * mname = get_method_name(jvmti, jni, method);\n+  if (strcmp(\"exceptionExitOuter\", mname) == 0) {\n+    if (!was_popped_by_exception) {\n+      fatal(jni, \"The method's was_popped_by_exception value is incorrect.\");\n+    }\n+    if (return_value.l != nullptr) {\n+      fatal(jni ,\"return_value should be nullptr.\");\n+    }\n+    method_exit_posted = true;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_method_exit_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.MethodExit = &cbMethodExit;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+ return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_TestPoppedByException_enable(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestPoppedByException_disableAndCheck(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (!method_exit_posted) {\n+    fatal(jni, \"Failed to post method exit event.\");\n+  }\n+  printf(\"The expected method_exit posted.\\n\");\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PoppedByException\/libTestPoppedByException.cpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}