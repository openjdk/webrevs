{"files":[{"patch":"@@ -40,5 +40,8 @@\n-    \/**\n-     * @throws IllegalArgumentException if the descriptor is invalid\n-     * @throws TypeNotPresentException if the descriptor is valid, but\n-     * the class cannot be found by the loader\n-     *\/\n+    \/\/\/ Parses and validates a field descriptor string in the {@code loader} context.\n+    \/\/\/\n+    \/\/\/ @param descriptor a field descriptor string\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/ @throws IllegalArgumentException if the descriptor is invalid\n+    \/\/\/ @throws TypeNotPresentException if the descriptor is valid, but\n+    \/\/\/         the class cannot be found by the loader\n@@ -54,9 +57,10 @@\n-    \/**\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     * @throws IllegalArgumentException if the descriptor is invalid\n-     * @throws TypeNotPresentException if the descriptor is valid, but\n-     * a reference type cannot be found by the loader\n-     *\/\n-    public static List<Class<?>> parseMethod(String bytecodeSignature, ClassLoader loader) {\n-        return parseMethod(bytecodeSignature, 0, bytecodeSignature.length(), loader);\n+    \/\/\/ Parses and validates a method descriptor string in the {@code loader} context.\n+    \/\/\/\n+    \/\/\/ @param descriptor a method descriptor string\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/ @throws IllegalArgumentException if the descriptor is invalid\n+    \/\/\/ @throws TypeNotPresentException if a reference type cannot be found by\n+    \/\/\/         the loader (before the descriptor is found invalid)\n+    public static List<Class<?>> parseMethod(String descriptor, ClassLoader loader) {\n+        return parseMethod(descriptor, 0, descriptor.length(), loader);\n@@ -97,11 +101,13 @@\n-    \/**\n-     * Parse a single type in a descriptor. Results can be:\n-     * <ul>\n-     *     <li>A {@code Class} for successful parsing\n-     *     <li>{@code null} for malformed descriptor format\n-     *     <li>Throwing a {@link TypeNotPresentException} for valid class name,\n-     *     but class cannot be discovered\n-     * <\/ul>\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     *\/\n+    \/\/\/ Parse a single type in a descriptor. Results can be:\n+    \/\/\/\n+    \/\/\/ - A `Class` for successful parsing\n+    \/\/\/ - `null` for malformed descriptor format\n+    \/\/\/ - Throwing a [TypeNotPresentException] for valid class name,\n+    \/\/\/   but class cannot be found\n+    \/\/\/\n+    \/\/\/ @param str contains the string to parse\n+    \/\/\/ @param i cursor for the next token in the string, modified in-place\n+    \/\/\/ @param end the limit for parsing\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/\n@@ -134,2 +140,8 @@\n-            var w = Wrapper.forPrimitiveTypeOrNull(c);\n-            return w == null ? null : w.primitiveType();\n+            Wrapper w;\n+            try {\n+                w = Wrapper.forBasicType(c);\n+            } catch (IllegalArgumentException ex) {\n+                \/\/ Our reporting has better error message\n+                return null;\n+            }\n+            return w.primitiveType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,13 +355,0 @@\n-    \/**\n-     * Return the primitive wrapper for the given char.  Does not return\n-     * {@code OBJECT}. Returns {@code null} to allow flexible error messages.\n-     * Dedicated for {@link BytecodeDescriptor}.\n-     *\/\n-    static Wrapper forPrimitiveTypeOrNull(char type) {\n-        Wrapper w = FROM_CHAR[(type + (type >> 1)) & 0xf];\n-        if (w != null && w != OBJECT && w.basicTypeChar == type) {\n-            return w;\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356022\n+ * @summary Tests for sun.invoke.util.BytecodeDescriptor\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.invoke.util\n+ * @run junit BytecodeDescriptorTest\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import sun.invoke.util.BytecodeDescriptor;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BytecodeDescriptorTest {\n+\n+    private static final String FOO_NAME = \"dummy.Foo\";\n+    private static final String BAR_NAME = \"dummy.Bar\";\n+    private static final String FOO_DESC = \"L\" + FOO_NAME.replace('.', '\/') + \";\";\n+    private static final String BAR_DESC = \"L\" + BAR_NAME.replace('.', '\/') + \";\";\n+    private static final String DOES_NOT_EXIST_DESC = \"Ldoes\/not\/Exist;\";\n+    static Class<?> foo1, foo2, bar1;\n+    static ClassLoader cl1, cl2;\n+\n+    @BeforeAll\n+    static void setup() throws Throwable {\n+        var fooBytes = ClassFile.of().build(ClassDesc.of(FOO_NAME), _ -> {});\n+        var barBytes = ClassFile.of().build(ClassDesc.of(BAR_NAME), _ -> {});\n+        cl1 = new ByteCodeLoader(Map.of(FOO_NAME, fooBytes, BAR_NAME, barBytes), ClassLoader.getSystemClassLoader());\n+        foo1 = cl1.loadClass(FOO_NAME);\n+        bar1 = cl1.loadClass(BAR_NAME);\n+        foo2 = ByteCodeLoader.load(FOO_NAME, fooBytes);\n+        cl2 = foo2.getClassLoader();\n+\n+        \/\/ Sanity\n+        assertNotSame(foo1, foo2);\n+        assertNotSame(cl1, cl2);\n+        assertSame(cl1, foo1.getClassLoader());\n+        assertSame(cl1, bar1.getClassLoader());\n+        assertNotSame(cl1, foo2.getClassLoader());\n+        assertEquals(FOO_DESC, foo1.descriptorString());\n+        assertEquals(FOO_DESC, foo2.descriptorString());\n+        assertEquals(BAR_DESC, bar1.descriptorString());\n+    }\n+\n+    @Test\n+    void testParseClass() throws ReflectiveOperationException {\n+        assertSame(void.class,     BytecodeDescriptor.parseClass(\"V\", null),                  \"void\");\n+        assertSame(int.class,      BytecodeDescriptor.parseClass(\"I\", null),                  \"primitive\");\n+        assertSame(long[][].class, BytecodeDescriptor.parseClass(\"[[J\", null),                \"array\");\n+        assertSame(Object.class,   BytecodeDescriptor.parseClass(\"Ljava\/lang\/Object;\", null), \"class or interface\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"java\/lang\/Object\", null),    \"internal name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"[V\", null),                  \"bad array\");\n+        assertSame(Class.forName(\"[\".repeat(255) + \"I\"), BytecodeDescriptor.parseClass(\"[\".repeat(255) + \"I\", null),   \"good array\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"[\".repeat(256) + \"I\", null), \"bad array\");\n+\n+        assertSame(foo2, BytecodeDescriptor.parseClass(FOO_DESC, cl2), \"class loader\");\n+        assertThrows(TypeNotPresentException.class, () -> BytecodeDescriptor.parseClass(DOES_NOT_EXIST_DESC, null),       \"not existent\");\n+        assertThrows(TypeNotPresentException.class, () -> BytecodeDescriptor.parseClass(BAR_DESC, cl2), \"cross loader\");\n+    }\n+\n+    @Test\n+    void testParseMethod() {\n+        assertEquals(List.of(void.class),\n+                     BytecodeDescriptor.parseMethod(\"()V\", null),\n+                     \"no-arg\");\n+        assertEquals(List.of(int.class, Object.class, long[].class, void.class),\n+                     BytecodeDescriptor.parseMethod(\"(ILjava\/lang\/Object;[J)V\", null),\n+                     \"sanity\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"()\", null),\n+                     \"no return\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(V)V\", null),\n+                     \"bad arg\");\n+        var voidInMsgIAE = assertThrows(IllegalArgumentException.class,\n+                                        () -> BytecodeDescriptor.parseMethod(\"([V)I\", null),\n+                                        \"bad arg\");\n+        assertTrue(voidInMsgIAE.getMessage().contains(\"[V\"), () -> \"missing [V type in: '%s'\".formatted(voidInMsgIAE.getMessage()));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseClass(\"([\".repeat(256) + \"I)J\", null),\n+                     \"bad arg\");\n+\n+        assertEquals(List.of(foo1, bar1),\n+                     BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \")\" + BAR_DESC, cl1),\n+                     \"class loader\");\n+        assertThrows(TypeNotPresentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \")\" + BAR_DESC, cl2),\n+                     \"no bar\");\n+        assertThrows(TypeNotPresentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \"V)V\", null),\n+                     \"first encounter TNPE\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(V\" + FOO_DESC + \")V\", null),\n+                     \"first encounter IAE\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/invoke\/util\/BytecodeDescriptorTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}