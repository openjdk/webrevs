{"files":[{"patch":"@@ -86,0 +86,1 @@\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -90,2 +91,0 @@\n-import sun.reflect.generics.repository.MethodRepository;\n-import sun.reflect.generics.repository.ConstructorRepository;\n@@ -1444,11 +1443,4 @@\n-            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),\n-                                                              getFactory());\n-            Class<?>   returnType       = toClass(typeInfo.getReturnType());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for(int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            Class<?>   returnType       = types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(EMPTY_CLASS_ARRAY);\n@@ -1573,11 +1565,4 @@\n-            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),\n-                                                                        getFactory());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for (int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n-\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(EMPTY_CLASS_ARRAY);\n@@ -1889,1 +1874,1 @@\n-        return list.toArray(new Class<?>[0]);\n+        return list.toArray(EMPTY_CLASS_ARRAY);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,6 +40,27 @@\n-    \/**\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     *\/\n-    public static List<Class<?>> parseMethod(String bytecodeSignature, ClassLoader loader) {\n-        return parseMethod(bytecodeSignature, 0, bytecodeSignature.length(), loader);\n+    \/\/\/ Parses and validates a field descriptor string in the {@code loader} context.\n+    \/\/\/\n+    \/\/\/ @param descriptor a field descriptor string\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/ @throws IllegalArgumentException if the descriptor is invalid\n+    \/\/\/ @throws TypeNotPresentException if the descriptor is valid, but\n+    \/\/\/         the class cannot be found by the loader\n+    public static Class<?> parseClass(String descriptor, ClassLoader loader) {\n+        int[] i = {0};\n+        var ret = parseSig(descriptor, i, descriptor.length(), loader);\n+        if (i[0] != descriptor.length() || ret == null) {\n+            parseError(\"not a class descriptor\", descriptor);\n+        }\n+        return ret;\n+    }\n+\n+    \/\/\/ Parses and validates a method descriptor string in the {@code loader} context.\n+    \/\/\/\n+    \/\/\/ @param descriptor a method descriptor string\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/ @throws IllegalArgumentException if the descriptor is invalid\n+    \/\/\/ @throws TypeNotPresentException if a reference type cannot be found by\n+    \/\/\/         the loader (before the descriptor is found invalid)\n+    public static List<Class<?>> parseMethod(String descriptor, ClassLoader loader) {\n+        return parseMethod(descriptor, 0, descriptor.length(), loader);\n@@ -80,4 +101,13 @@\n-    \/**\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     *\/\n+    \/\/\/ Parse a single type in a descriptor. Results can be:\n+    \/\/\/\n+    \/\/\/ - A `Class` for successful parsing\n+    \/\/\/ - `null` for malformed descriptor format\n+    \/\/\/ - Throwing a [TypeNotPresentException] for valid class name,\n+    \/\/\/   but class cannot be found\n+    \/\/\/\n+    \/\/\/ @param str contains the string to parse\n+    \/\/\/ @param i cursor for the next token in the string, modified in-place\n+    \/\/\/ @param end the limit for parsing\n+    \/\/\/ @param loader the class loader in which to look up the types (null means\n+    \/\/\/               bootstrap class loader)\n+    \/\/\/\n@@ -110,1 +140,8 @@\n-            return Wrapper.forBasicType(c).primitiveType();\n+            Wrapper w;\n+            try {\n+                w = Wrapper.forBasicType(c);\n+            } catch (IllegalArgumentException ex) {\n+                \/\/ Our reporting has better error message\n+                return null;\n+            }\n+            return w.primitiveType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,6 +37,1 @@\n-import sun.reflect.generics.parser.SignatureParser;\n-import sun.reflect.generics.tree.TypeSignature;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.visitor.Reifier;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -432,13 +427,5 @@\n-        if (sig.equals(\"V\")) return void.class;\n-        SignatureParser parser = SignatureParser.make();\n-        TypeSignature typeSig = parser.parseTypeSig(sig);\n-        GenericsFactory factory = CoreReflectionFactory.make(container, ClassScope.make(container));\n-        Reifier reify = Reifier.make(factory);\n-        typeSig.accept(reify);\n-        Type result = reify.getResult();\n-        return toClass(result);\n-    }\n-    static Class<?> toClass(Type o) {\n-        if (o instanceof GenericArrayType gat)\n-            return toClass(gat.getGenericComponentType()).arrayType();\n-        return (Class<?>) o;\n+        try {\n+            return BytecodeDescriptor.parseClass(sig, container.getClassLoader());\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356022\n+ * @summary Tests for sun.invoke.util.BytecodeDescriptor\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.invoke.util\n+ * @run junit BytecodeDescriptorTest\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import sun.invoke.util.BytecodeDescriptor;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BytecodeDescriptorTest {\n+\n+    private static final String FOO_NAME = \"dummy.Foo\";\n+    private static final String BAR_NAME = \"dummy.Bar\";\n+    private static final String FOO_DESC = \"L\" + FOO_NAME.replace('.', '\/') + \";\";\n+    private static final String BAR_DESC = \"L\" + BAR_NAME.replace('.', '\/') + \";\";\n+    private static final String DOES_NOT_EXIST_DESC = \"Ldoes\/not\/Exist;\";\n+    static Class<?> foo1, foo2, bar1;\n+    static ClassLoader cl1, cl2;\n+\n+    @BeforeAll\n+    static void setup() throws Throwable {\n+        var fooBytes = ClassFile.of().build(ClassDesc.of(FOO_NAME), _ -> {});\n+        var barBytes = ClassFile.of().build(ClassDesc.of(BAR_NAME), _ -> {});\n+        cl1 = new ByteCodeLoader(Map.of(FOO_NAME, fooBytes, BAR_NAME, barBytes), ClassLoader.getSystemClassLoader());\n+        foo1 = cl1.loadClass(FOO_NAME);\n+        bar1 = cl1.loadClass(BAR_NAME);\n+        foo2 = ByteCodeLoader.load(FOO_NAME, fooBytes);\n+        cl2 = foo2.getClassLoader();\n+\n+        \/\/ Sanity\n+        assertNotSame(foo1, foo2);\n+        assertNotSame(cl1, cl2);\n+        assertSame(cl1, foo1.getClassLoader());\n+        assertSame(cl1, bar1.getClassLoader());\n+        assertNotSame(cl1, foo2.getClassLoader());\n+        assertEquals(FOO_DESC, foo1.descriptorString());\n+        assertEquals(FOO_DESC, foo2.descriptorString());\n+        assertEquals(BAR_DESC, bar1.descriptorString());\n+    }\n+\n+    @Test\n+    void testParseClass() throws ReflectiveOperationException {\n+        assertSame(void.class,     BytecodeDescriptor.parseClass(\"V\", null),                  \"void\");\n+        assertSame(int.class,      BytecodeDescriptor.parseClass(\"I\", null),                  \"primitive\");\n+        assertSame(long[][].class, BytecodeDescriptor.parseClass(\"[[J\", null),                \"array\");\n+        assertSame(Object.class,   BytecodeDescriptor.parseClass(\"Ljava\/lang\/Object;\", null), \"class or interface\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"java\/lang\/Object\", null),    \"internal name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"[V\", null),                  \"bad array\");\n+        assertSame(Class.forName(\"[\".repeat(255) + \"I\"), BytecodeDescriptor.parseClass(\"[\".repeat(255) + \"I\", null),   \"good array\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"[\".repeat(256) + \"I\", null), \"bad array\");\n+\n+        assertSame(foo2, BytecodeDescriptor.parseClass(FOO_DESC, cl2), \"class loader\");\n+        assertThrows(TypeNotPresentException.class, () -> BytecodeDescriptor.parseClass(DOES_NOT_EXIST_DESC, null),       \"not existent\");\n+        assertThrows(TypeNotPresentException.class, () -> BytecodeDescriptor.parseClass(BAR_DESC, cl2), \"cross loader\");\n+    }\n+\n+    @Test\n+    void testParseMethod() {\n+        assertEquals(List.of(void.class),\n+                     BytecodeDescriptor.parseMethod(\"()V\", null),\n+                     \"no-arg\");\n+        assertEquals(List.of(int.class, Object.class, long[].class, void.class),\n+                     BytecodeDescriptor.parseMethod(\"(ILjava\/lang\/Object;[J)V\", null),\n+                     \"sanity\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"()\", null),\n+                     \"no return\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(V)V\", null),\n+                     \"bad arg\");\n+        var voidInMsgIAE = assertThrows(IllegalArgumentException.class,\n+                                        () -> BytecodeDescriptor.parseMethod(\"([V)I\", null),\n+                                        \"bad arg\");\n+        assertTrue(voidInMsgIAE.getMessage().contains(\"[V\"), () -> \"missing [V type in: '%s'\".formatted(voidInMsgIAE.getMessage()));\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseClass(\"([\".repeat(256) + \"I)J\", null),\n+                     \"bad arg\");\n+\n+        assertEquals(List.of(foo1, bar1),\n+                     BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \")\" + BAR_DESC, cl1),\n+                     \"class loader\");\n+        assertThrows(TypeNotPresentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \")\" + BAR_DESC, cl2),\n+                     \"no bar\");\n+        assertThrows(TypeNotPresentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(\" + FOO_DESC + \"V)V\", null),\n+                     \"first encounter TNPE\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(V\" + FOO_DESC + \")V\", null),\n+                     \"first encounter IAE\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/invoke\/util\/BytecodeDescriptorTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}