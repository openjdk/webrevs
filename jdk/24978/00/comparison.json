{"files":[{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.reflect.Proxy;\n@@ -85,0 +84,1 @@\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -89,2 +89,0 @@\n-import sun.reflect.generics.repository.MethodRepository;\n-import sun.reflect.generics.repository.ConstructorRepository;\n@@ -1440,11 +1438,4 @@\n-            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),\n-                                                              getFactory());\n-            Class<?>   returnType       = toClass(typeInfo.getReturnType());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for(int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            Class<?>   returnType       = types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(EMPTY_CLASS_ARRAY);\n@@ -1569,11 +1560,4 @@\n-            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),\n-                                                                        getFactory());\n-            Type []    parameterTypes   = typeInfo.getParameterTypes();\n-            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];\n-\n-            \/\/ Convert Types to Classes; returned types *should*\n-            \/\/ be class objects since the methodDescriptor's used\n-            \/\/ don't have generics information\n-            for (int i = 0; i < parameterClasses.length; i++)\n-                parameterClasses[i] = toClass(parameterTypes[i]);\n-\n+            \/\/ Descriptor already validated by VM\n+            List<Class<?>> types = BytecodeDescriptor.parseMethod(enclosingInfo.getDescriptor(), getClassLoader());\n+            types.removeLast();\n+            Class<?>[] parameterClasses = types.toArray(EMPTY_CLASS_ARRAY);\n@@ -1885,1 +1869,1 @@\n-        return list.toArray(new Class<?>[0]);\n+        return list.toArray(EMPTY_CLASS_ARRAY);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":10,"deletions":26,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,14 @@\n+    \/**\n+     * @throws IllegalArgumentException if the descriptor is invalid\n+     * @throws TypeNotPresentException if the descriptor is valid, but\n+     * the class cannot be found by the loader\n+     *\/\n+    public static Class<?> parseClass(String descriptor, ClassLoader loader) {\n+        int[] i = {0};\n+        var ret = parseSig(descriptor, i, descriptor.length(), loader);\n+        if (i[0] != descriptor.length() || ret == null) {\n+            parseError(\"not a class descriptor\", descriptor);\n+        }\n+        return ret;\n+    }\n+\n@@ -43,0 +57,3 @@\n+     * @throws IllegalArgumentException if the descriptor is invalid\n+     * @throws TypeNotPresentException if the descriptor is valid, but\n+     * a reference type cannot be found by the loader\n@@ -81,0 +98,7 @@\n+     * Parse a single type in a descriptor. Results can be:\n+     * <ul>\n+     *     <li>A {@code Class} for successful parsing\n+     *     <li>{@code null} for malformed descriptor format\n+     *     <li>Throwing a {@link TypeNotPresentException} for valid class name,\n+     *     but class cannot be discovered\n+     * <\/ul>\n@@ -103,1 +127,2 @@\n-            return Wrapper.forBasicType(c).primitiveType();\n+            var w = Wrapper.forPrimitiveTypeOrNull(c);\n+            return w == null ? null : w.primitiveType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,0 +355,13 @@\n+    \/**\n+     * Return the primitive wrapper for the given char.  Does not return\n+     * {@code OBJECT}. Returns {@code null} to allow flexible error messages.\n+     * Dedicated for {@link BytecodeDescriptor}.\n+     *\/\n+    static Wrapper forPrimitiveTypeOrNull(char type) {\n+        Wrapper w = FROM_CHAR[(type + (type >> 1)) & 0xf];\n+        if (w != null && w != OBJECT && w.basicTypeChar == type) {\n+            return w;\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,6 +37,1 @@\n-import sun.reflect.generics.parser.SignatureParser;\n-import sun.reflect.generics.tree.TypeSignature;\n-import sun.reflect.generics.factory.GenericsFactory;\n-import sun.reflect.generics.factory.CoreReflectionFactory;\n-import sun.reflect.generics.visitor.Reifier;\n-import sun.reflect.generics.scope.ClassScope;\n+import sun.invoke.util.BytecodeDescriptor;\n@@ -432,13 +427,5 @@\n-        if (sig.equals(\"V\")) return void.class;\n-        SignatureParser parser = SignatureParser.make();\n-        TypeSignature typeSig = parser.parseTypeSig(sig);\n-        GenericsFactory factory = CoreReflectionFactory.make(container, ClassScope.make(container));\n-        Reifier reify = Reifier.make(factory);\n-        typeSig.accept(reify);\n-        Type result = reify.getResult();\n-        return toClass(result);\n-    }\n-    static Class<?> toClass(Type o) {\n-        if (o instanceof GenericArrayType gat)\n-            return toClass(gat.getGenericComponentType()).arrayType();\n-        return (Class<?>) o;\n+        try {\n+            return BytecodeDescriptor.parseClass(sig, container.getClassLoader());\n+        } catch (IllegalArgumentException ex) {\n+            throw new GenericSignatureFormatError(ex.getMessage());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"}]}