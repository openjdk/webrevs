{"files":[{"patch":"@@ -539,11 +539,0 @@\n-  case vmIntrinsics::_isPrimitive        : {\n-    assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-    \/\/ Class.isPrimitive is known on constant classes:\n-    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n-    if (c != nullptr && !c->value()->is_null_object()) {\n-      ciType* t = c->value()->java_mirror_type();\n-      set_constant(t->is_primitive_type());\n-    }\n-    break;\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-  case vmIntrinsics::_isPrimitive:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1281,19 +1281,0 @@\n-\/\/ java.lang.Class::isPrimitive()\n-void LIRGenerator::do_isPrimitive(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-  LIRItem rcvr(x->argument_at(0), this);\n-  rcvr.load_item();\n-  LIR_Opr temp = new_register(T_METADATA);\n-  LIR_Opr result = rlock_result(x);\n-\n-  CodeEmitInfo* info = nullptr;\n-  if (x->needs_null_check()) {\n-    info = state_for(x);\n-  }\n-\n-  __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset(), T_ADDRESS), temp, info);\n-  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(nullptr));\n-  __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);\n-}\n-\n@@ -2917,1 +2898,0 @@\n-  case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  void do_isPrimitive(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -871,0 +871,1 @@\n+int java_lang_Class::_is_primitive_offset;\n@@ -1065,1 +1066,1 @@\n-  int computed_modifiers = k->compute_modifier_flags();\n+  u2 computed_modifiers = k->compute_modifier_flags();\n@@ -1350,0 +1351,6 @@\n+void java_lang_Class::set_is_primitive(oop java_class) {\n+  assert(_is_primitive_offset != 0, \"must be set\");\n+  java_class->bool_field_put(_is_primitive_offset, true);\n+}\n+\n+\n@@ -1364,0 +1371,1 @@\n+  set_is_primitive(java_class);\n@@ -1503,2 +1511,3 @@\n-  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), int_signature,    false); \\\n-  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false);\n+  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), char_signature,    false); \\\n+  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false); \\\n+  macro(_is_primitive_offset,        k, \"isPrimitiveType\",     bool_signature,         false);\n@@ -1540,1 +1549,1 @@\n-  return the_class_mirror->int_field(_modifiers_offset);\n+  return the_class_mirror->char_field(_modifiers_offset);\n@@ -1543,1 +1552,1 @@\n-void java_lang_Class::set_modifiers(oop the_class_mirror, int value) {\n+void java_lang_Class::set_modifiers(oop the_class_mirror, u2 value) {\n@@ -1545,1 +1554,1 @@\n-  the_class_mirror->int_field_put(_modifiers_offset, value);\n+  the_class_mirror->char_field_put(_modifiers_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+  static int _is_primitive_offset;\n@@ -305,0 +306,1 @@\n+  static void set_is_primitive(oop java_class);\n@@ -341,1 +343,1 @@\n-  static void set_modifiers(oop java_class, int value);\n+  static void set_modifiers(oop java_class, u2 value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-  \/\/assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n+  \/\/ assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n@@ -300,0 +300,2 @@\n+  \/\/ The heapwalker walks through Classes that have had their Klass pointers removed, so can't assert this.\n+  \/\/ assert(is_primitive == java_class->bool_field(_is_primitive_offset), \"must match what we told Java\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,3 +259,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,6 +307,0 @@\n-  do_intrinsic(_isInterface,              java_lang_Class,        isInterface_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isInterface_name,                                \"isInterface\")                                         \\\n-  do_intrinsic(_isArray,                  java_lang_Class,        isArray_name, void_boolean_signature,          F_RN)  \\\n-   do_name(     isArray_name,                                    \"isArray\")                                             \\\n-  do_intrinsic(_isPrimitive,              java_lang_Class,        isPrimitive_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isPrimitive_name,                                \"isPrimitive\")                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -752,3 +752,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -518,3 +518,0 @@\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n@@ -3893,11 +3890,0 @@\n-  case vmIntrinsics::_isInterface:\n-    prim_return_value = intcon(0);\n-    break;\n-  case vmIntrinsics::_isArray:\n-    prim_return_value = intcon(0);\n-    expect_prim = true;  \/\/ cf. ObjectStreamClass.getClassSignature\n-    break;\n-  case vmIntrinsics::_isPrimitive:\n-    prim_return_value = intcon(1);\n-    expect_prim = true;  \/\/ obviously\n-    break;\n@@ -3972,22 +3958,0 @@\n-  case vmIntrinsics::_isInterface:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsInterface.)\n-    if (generate_interface_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an interface.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isArray:\n-    \/\/ (To verify this code sequence, check the asserts in JVM_IsArrayClass.)\n-    if (generate_array_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an array.\n-      phi->add_req(intcon(1));\n-    \/\/ If we fall through, it's a plain class.\n-    query_value = intcon(0);\n-    break;\n-\n-  case vmIntrinsics::_isPrimitive:\n-    query_value = intcon(0); \/\/ \"normal\" path produces false\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1190,14 +1190,0 @@\n-JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    return JNI_FALSE;\n-  }\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  jboolean result = k->is_interface();\n-  assert(!result || k->is_instance_klass(),\n-         \"all interfaces are instance types\");\n-  \/\/ The compiler intrinsic for isInterface tests the\n-  \/\/ Klass::_access_flags bits in the same way.\n-  return result;\n-JVM_END\n-\n@@ -1262,12 +1248,0 @@\n-JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n-  return (k != nullptr) && k->is_array_klass() ? true : false;\n-JVM_END\n-\n-\n-JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  return (jboolean) java_lang_Class::is_primitive(mirror);\n-JVM_END\n-\n-\n@@ -2308,1 +2282,17 @@\n-\/\/ Please, refer to the description in the jvmtiThreadSate.hpp.\n+\/\/ Please, refer to the description in the jvmtiThreadState.hpp.\n+\n+JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  \/\/ This isn't necessary since answer is the same since redefinition\n+  \/\/ has already checked this matches for the scratch class.\n+  \/\/ k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);\n+  jboolean result = k->is_interface();\n+  assert(!result || k->is_instance_klass(),\n+         \"all interfaces are instance types\");\n+  return result;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType, int mods, ProtectionDomain pd) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean primitive) {\n@@ -246,0 +246,1 @@\n+        isPrimitiveType = primitive;\n@@ -793,2 +794,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isInterface();\n+    public boolean isInterface() {\n+        return Modifier.isInterface(getModifiers());\n+    }\n@@ -804,2 +806,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isArray();\n+    public boolean isArray() {\n+        return componentType != null;\n+    }\n@@ -846,2 +849,3 @@\n-    @IntrinsicCandidate\n-    public native boolean isPrimitive();\n+    public boolean isPrimitive() {\n+        return isPrimitiveType;\n+    }\n@@ -1005,1 +1009,2 @@\n-    private final transient int modifiers;  \/\/ Set by the VM\n+    private final transient char modifiers;  \/\/ Set by the VM\n+    private final transient boolean isPrimitiveType;  \/\/ Set by the VM\n@@ -1287,6 +1292,1 @@\n-        \/\/ Only return for array types. Storage may be reused for Class for instance types.\n-        if (isArray()) {\n-            return componentType;\n-        } else {\n-            return null;\n-        }\n+        return componentType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            Class.class, Set.of(\"classLoader\", \"classData\", \"modifiers\", \"protectionDomain\"),\n+            Class.class, Set.of(\"classLoader\", \"classData\", \"modifiers\", \"protectionDomain\", \"isPrimitiveType\"),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-    {\"isInterface\",      \"()Z\",             (void *)&JVM_IsInterface},\n-    {\"isArray\",          \"()Z\",             (void *)&JVM_IsArrayClass},\n@@ -62,1 +60,0 @@\n-    {\"isPrimitive\",      \"()Z\",             (void *)&JVM_IsPrimitiveClass},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -932,4 +932,6 @@\n-            return f.getName().equals(\"classLoader\") ||\n-                   f.getName().equals(\"classData\") ||\n-                   f.getName().equals(\"modifiers\") ||\n-                   f.getName().equals(\"protectionDomain\");\n+            String name = f.getName();\n+            return name.equals(\"classLoader\") ||\n+                   name.equals(\"classData\") ||\n+                   name.equals(\"modifiers\") ||\n+                   name.equals(\"protectionDomain\") ||\n+                   name.equals(\"isPrimitiveType\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, int.class, ProtectionDomain.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/ModuleSetAccessibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, int.class, ProtectionDomain.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/TrySetAccessibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+            { Class.class, \"isPrimitiveType\" },\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/Filtering.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}