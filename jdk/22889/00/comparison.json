{"files":[{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test passing of a structure which contains a double with 4 Byte alignment on AIX.\n+ *\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED Test4BAlignedDouble\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class Test4BAlignedDouble {\n+\n+    static {\n+      System.loadLibrary(\"Test4BAlignedDouble\");\n+    }\n+\n+    static final Linker abi = Linker.nativeLinker();\n+    static final SymbolLookup lookup = SymbolLookup.loaderLookup();\n+    static final boolean isAix = System.getProperty(\"os.name\").equals(\"AIX\");\n+\n+    static final OfInt C_INT = JAVA_INT;\n+    static final OfFloat C_FLOAT = JAVA_FLOAT;\n+    static final OfDouble C_DOUBLE = JAVA_DOUBLE;\n+    \/\/ Double with platform specific alignment rule. Can be used on AIX with #pragma align (power).\n+    static final OfDouble C_DOUBLE4B = JAVA_DOUBLE.withByteAlignment(4);\n+    static final OfDouble platform_C_DOUBLE = isAix ? C_DOUBLE4B : C_DOUBLE;\n+\n+    static final StructLayout S_IDFLayout_with_padding = MemoryLayout.structLayout(\n+        C_INT.withName(\"p0\"),\n+        MemoryLayout.paddingLayout(4), \/\/ AIX: only with #pragma align (natural)\n+        C_DOUBLE.withName(\"p1\"),\n+        C_FLOAT.withName(\"p2\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"S_IDF\");\n+\n+    static final StructLayout S_IDFLayout_without_padding = MemoryLayout.structLayout(\n+        C_INT.withName(\"p0\"),\n+        \/\/ AIX uses #pragma align (power) by default. This means no padding, here.\n+        C_DOUBLE4B.withName(\"p1\"),\n+        C_FLOAT.withName(\"p2\")\n+    ).withName(\"S_IDF\");\n+\n+    static final StructLayout platform_S_IDFLayout = isAix ? S_IDFLayout_without_padding : S_IDFLayout_with_padding;\n+\n+    static final long p0_offs = platform_S_IDFLayout.byteOffset(PathElement.groupElement(\"p0\")),\n+                      p1_offs = platform_S_IDFLayout.byteOffset(PathElement.groupElement(\"p1\")),\n+                      p2_offs = platform_S_IDFLayout.byteOffset(PathElement.groupElement(\"p2\"));\n+\n+    static final FunctionDescriptor fdpass_S_IDF = FunctionDescriptor.of(platform_S_IDFLayout, platform_S_IDFLayout);\n+\n+    static final MethodHandle mhpass_S_IDF = abi.downcallHandle(lookup.find(\"pass_S_IDF\").orElseThrow(), fdpass_S_IDF);\n+    static final MethodHandle mhpass_S_IDF_fun = abi.downcallHandle(lookup.find(\"call_S_IDF_fun\").orElseThrow(),\n+        FunctionDescriptor.of(platform_S_IDFLayout, ADDRESS, platform_S_IDFLayout));\n+\n+    @Test\n+    public static void testDowncall() {\n+        int p0 = 0;\n+        double p1 = 0.0d;\n+        float p2 = 0.0f;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(platform_S_IDFLayout);\n+            s.set(C_INT, p0_offs, 1);\n+            s.set(platform_C_DOUBLE, p1_offs, 2.0d);\n+            s.set(C_FLOAT, p2_offs, 3.0f);\n+            s = (MemorySegment) mhpass_S_IDF.invokeExact((SegmentAllocator) arena, s);\n+            p0 = s.get(C_INT, p0_offs);\n+            p1 = s.get(platform_C_DOUBLE, p1_offs);\n+            p2 = s.get(C_FLOAT, p2_offs);\n+            System.out.println(\"S_IDF(\" + p0 + \";\" + p1 + \";\" + p2 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2 || p1 != 5.0d || p2 != 3.0f) throw new RuntimeException(\"pass_S_IDF downcall error\");\n+    }\n+\n+    \/\/ Java version for Upcall test.\n+    public static MemorySegment S_IDF_fun(MemorySegment p) {\n+        int    p0 = p.get(C_INT,  p0_offs);\n+        double p1 = p.get(platform_C_DOUBLE, p1_offs);\n+        float  p2 = p.get(C_FLOAT, p2_offs);\n+        p.set(C_INT,  p0_offs, p0 + 1);\n+        p.set(platform_C_DOUBLE, p1_offs, p1 + (double) p2);\n+        return p;\n+    }\n+\n+    @Test\n+    public static void testUpcall() {\n+        int p0 = 0;\n+        double p1 = 0.0d;\n+        float p2 = 0.0f;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(platform_S_IDFLayout);\n+            s.set(C_INT, p0_offs, 1);\n+            s.set(platform_C_DOUBLE, p1_offs, 2.0d);\n+            s.set(C_FLOAT, p2_offs, 3.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class, MemorySegment.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(Test4BAlignedDouble.class, \"S_IDF_fun\", mt),\n+                                                fdpass_S_IDF, arena);\n+            s = (MemorySegment) mhpass_S_IDF_fun.invokeExact((SegmentAllocator) arena, stub, s);\n+            p0 = s.get(C_INT, p0_offs);\n+            p1 = s.get(platform_C_DOUBLE, p1_offs);\n+            p2 = s.get(C_FLOAT, p2_offs);\n+            System.out.println(\"S_IDF(\" + p0 + \";\" + p1 + \";\" + p2 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2 || p1 != 5.0d || p2 != 3.0f) throw new RuntimeException(\"pass_S_IDF upcall error\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/Test4BAlignedDouble.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+\/\/ This test uses the platform's default alignment rules, no pragma align directive.\n+struct S_IDF { int p0; double p1; float p2; };\n+\n+EXPORT struct S_IDF pass_S_IDF(struct S_IDF s) {\n+  s.p0++;\n+  s.p1 += (double)s.p2;\n+  return s;\n+}\n+\n+\/\/ Upcall version.\n+EXPORT struct S_IDF call_S_IDF_fun(struct S_IDF (*fun)(struct S_IDF), struct S_IDF s) {\n+  return fun(s);\n+}\n","filename":"test\/jdk\/java\/foreign\/libTest4BAlignedDouble.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"}]}