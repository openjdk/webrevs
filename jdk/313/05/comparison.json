{"files":[{"patch":"@@ -2224,0 +2224,3 @@\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+\n@@ -95,0 +101,193 @@\n+\n+    \/**\n+     * Invokes the specified default method on the given {@code proxy} instance with\n+     * the given parameters.  The given {@code method} must be a default method\n+     * declared in a proxy interface of the {@code proxy}'s class or inherited\n+     * from its superinterface directly or indirectly.\n+     * <p>\n+     * Invoking this method behaves as if {@code invokespecial} instruction executed\n+     * from the proxy class, targeting the default method in a proxy interface.\n+     * This is equivalent to the invocation:\n+     * {@code X.super.m(A* a)} where {@code X} is a proxy interface and the call to\n+     * {@code X.super::m(A*)} is resolved to the given {@code method}.\n+     * <p>\n+     * Examples: interface {@code A} and {@code B} both declare a default\n+     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n+     * and inherits the default method {@code m} from its superinterface {@code A}.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface A {\n+     *     default T m(A a) { return t1; }\n+     * }\n+     * interface B {\n+     *     default T m(A a) { return t2; }\n+     * }\n+     * interface C extends A {}\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code A}\n+     * and invokes the default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class },\n+     *         (o, m, params) -> {\n+     *             if (m.isDefault()) {\n+     *                 \/\/ if it's a default method, invoke it\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements both {@code A} and {@code B}, both\n+     * of which provides the default implementation of method {@code m},\n+     * the invocation handler can dispatch the method invocation to\n+     * {@code A::m} or {@code B::m} via the {@code invokeDefault} method.\n+     * For example, the following code delegates the method invocation\n+     * to {@code B::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n+     *         (o, m, params) -> {\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ invoke B::m instead of A::m\n+     *                 Method bMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, bMethod, params);\n+     *             }\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements {@code C} that inherits the default\n+     * method {@code m} from its superinterface {@code A}, then\n+     * the interface method invocation on {@code \"m\"} is dispatched to\n+     * the invocation handler's {@link #invoke(Object, Method, Object[]) invoke}\n+     * method with the {@code Method} object argument representing the\n+     * default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *        (o, m, params) -> {\n+     *             if (m.isDefault()) {\n+     *                 \/\/ behaves as if calling C.super.m(params)\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n+     *        });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation of method {@code \"m\"} on this {@code proxy} will behave\n+     * as if {@code C.super::m} is called and that is resolved to invoking\n+     * {@code A::m}.\n+     * <p>\n+     * Adding a default method, or changing a method from abstract to default\n+     * may cause an exception if an existing code attempts to call {@code invokeDefault}\n+     * to invoke a default method.\n+     *\n+     * For example, if {@code C} is modified to implement a default method\n+     * {@code m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * interface C extends A {\n+     *     default T m(A a) { return t3; }\n+     * }\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The code above that creates proxy instance {@code proxy} with\n+     * the modified {@code C} will run with no exception and it will result in\n+     * calling {@code C::m} instead of {@code A::m}.\n+     * <p>\n+     * The following is another example that creates a proxy instance of {@code C}\n+     * and the invocation handler calls the {@code invokeDefault} method\n+     * to invoke {@code A::m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * C c = (C) Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *         (o, m, params) -> {\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *                 \/\/ inherited from its proxy interface C\n+     *                 Method aMethod = A.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, aMethod params);\n+     *             }\n+     *         });\n+     * c.m(...);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The above code runs successfully with the old version of {@code C} and\n+     * {@code A::m} is invoked.  When running with the new version of {@code C},\n+     * the above code will fail with {@code IllegalArgumentException} because\n+     * {@code C} overrides the implementation of the same method and\n+     * {@code A::m} is not accessible by a proxy instance.\n+     *\n+     * @apiNote\n+     * The {@code proxy} parameter is of type {@code Object} rather than {@code Proxy}\n+     * to make it easy for {@link InvocationHandler#invoke(Object, Method, Object[])\n+     * InvocationHandler::invoke} implementation to call directly without the need\n+     * of casting.\n+     *\n+     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n+     * @param method  the {@code Method} instance corresponding to a default method\n+     *                declared in a proxy interface of the proxy class or inherited\n+     *                from its superinterface directly or indirectly\n+     * @param args    the parameters used for the method invocation; can be {@code null}\n+     *                if the number of formal parameters required by the method is zero.\n+     * @return the value returned from the method invocation\n+     *\n+     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n+     *         <ul>\n+     *         <li>{@code proxy} is not {@linkplain Proxy#isProxyClass(Class)\n+     *             a proxy instance}; or<\/li>\n+     *         <li>the given {@code method} is not a default method declared\n+     *             in a proxy interface of the proxy class and not inherited from\n+     *             any of its superinterfaces; or<\/li>\n+     *         <li>the given {@code method} is overridden directly or indirectly by\n+     *             the proxy interfaces and the method reference to the named\n+     *             method never resolves to the given {@code method}; or<\/li>\n+     *         <li>the length of the given {@code args} array does not match the\n+     *             number of parameters of the method to be invoked; or<\/li>\n+     *         <li>any of the {@code args} elements fails the unboxing\n+     *             conversion if the corresponding method parameter type is\n+     *             a primitive type; or if, after possible unboxing, any of the\n+     *             {@code args} elements cannot be assigned to the corresponding\n+     *             method parameter type.<\/li>\n+     *         <\/ul>\n+     * @throws IllegalAccessException if the declaring class of the specified\n+     *         default method is inaccessible to the caller class\n+     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n+     * @throws Throwable anything thrown by the default method\n+\n+     * @since 16\n+     * @jvms 5.4.3. Method Resolution\n+     *\/\n+    @CallerSensitive\n+    public static Object invokeDefault(Object proxy, Method method, Object... args)\n+            throws Throwable {\n+        Objects.requireNonNull(proxy);\n+        Objects.requireNonNull(method);\n+\n+        \/\/ verify that the object is actually a proxy instance\n+        if (!Proxy.isProxyClass(proxy.getClass())) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n+\n+        Class<?> intf = method.getDeclaringClass();\n+        \/\/ access check on the default method\n+        method.checkAccess(Reflection.getCallerClass(), intf, proxyClass, method.getModifiers());\n+\n+        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return mh.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (Proxy.InvocationException e) {\n+            \/\/ unwrap and throw the exception thrown by the default method\n+            throw e.getCause();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":200,"deletions":1,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -69,0 +70,1 @@\n+    @Stable\n@@ -77,0 +79,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.WrongMethodTypeException;\n@@ -31,0 +35,1 @@\n+import java.util.ArrayDeque;\n@@ -33,0 +38,1 @@\n+import java.util.Deque;\n@@ -40,0 +46,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -42,0 +49,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -45,1 +53,0 @@\n-import jdk.internal.loader.BootLoader;\n@@ -51,0 +58,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -52,1 +60,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -56,0 +63,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -58,1 +66,0 @@\n-\n@@ -147,0 +154,6 @@\n+ * <li>A proxy interface may define a default method or inherit\n+ * a default method from its superinterface directly or indirectly.\n+ * An invocation handler can invoke a default method of a proxy interface\n+ * by calling {@link InvocationHandler#invokeDefault(Object, Method, Object...)\n+ * InvocationHandler::invokeDefault}.\n+ *\n@@ -175,3 +188,2 @@\n- *     <em>public<\/em> in a package exported by the\n- *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified\n- *     loader. The name of the package is unspecified.<\/li>\n+ *     <em>public<\/em> in an unconditionally exported but non-open package.\n+ *     The name of the package and the module are unspecified.<\/li>\n@@ -488,0 +500,1 @@\n+            boolean nonExported = false;\n@@ -505,0 +518,5 @@\n+                } else {\n+                    if (!intf.getModule().isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -509,3 +527,5 @@\n-                \/\/ all proxy interfaces are public\n-                proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : PROXY_PACKAGE_PREFIX;\n+                \/\/ all proxy interfaces are public and exported\n+                if (!m.isNamed())\n+                    throw new InternalError(\"ununamed module: \" + m);\n+                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n+                                       : m.getName();\n@@ -649,0 +669,2 @@\n+            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n+\n@@ -745,3 +767,0 @@\n-         * If all proxy interfaces are public and in exported packages,\n-         * then the proxy class is in unnamed module.\n-         *\n@@ -751,0 +770,4 @@\n+         * If all proxy interfaces are public and in exported packages,\n+         * then the proxy class is in a dynamic module in an unconditionally\n+         * exported package.\n+         *\n@@ -753,2 +776,5 @@\n-         * non-exported package.  Reads edge and qualified exports are added\n-         * for dynamic module to access.\n+         * non-exported package.\n+         *\n+         * The package of proxy class is open to java.base for deep reflective access.\n+         *\n+         * Reads edge and qualified exports are added for dynamic module to access.\n@@ -759,1 +785,0 @@\n-            Map<Class<?>, Module> modulePrivateTypes = new HashMap<>();\n@@ -763,6 +788,1 @@\n-                if (Modifier.isPublic(intf.getModifiers())) {\n-                    \/\/ module-private types\n-                    if (!m.isExported(intf.getPackageName())) {\n-                        modulePrivateTypes.put(intf, m);\n-                    }\n-                } else {\n+                if (!Modifier.isPublic(intf.getModifiers())) {\n@@ -773,8 +793,0 @@\n-            \/\/ all proxy interfaces are public and exported, the proxy class\n-            \/\/ is in unnamed module.  Such proxy class is accessible to\n-            \/\/ any unnamed module and named module that can read unnamed module\n-            if (packagePrivateTypes.isEmpty() && modulePrivateTypes.isEmpty()) {\n-                return loader != null ? loader.getUnnamedModule()\n-                                      : BootLoader.getUnnamedModule();\n-            }\n-\n@@ -787,12 +799,10 @@\n-                if (packagePrivateTypes.size() > 1 &&\n-                        (packagePrivateTypes.keySet().stream()  \/\/ more than one package\n-                                 .map(Class::getPackageName).distinct().count() > 1 ||\n-                         packagePrivateTypes.values().stream()  \/\/ or more than one module\n-                                 .distinct().count() > 1)) {\n-                    throw new IllegalArgumentException(\n-                            \"non-public interfaces from different packages\");\n-                }\n-\n-                \/\/ all package-private types are in the same module (named or unnamed)\n-                Module target = null;\n-                for (Module m : packagePrivateTypes.values()) {\n+                Module targetModule = null;\n+                String targetPackageName = null;\n+                for (Map.Entry<Class<?>, Module> e : packagePrivateTypes.entrySet()) {\n+                    Class<?> intf = e.getKey();\n+                    Module m = e.getValue();\n+                    if ((targetModule != null && targetModule != m) ||\n+                        (targetPackageName != null && targetPackageName != intf.getPackageName())) {\n+                        throw new IllegalArgumentException(\n+                                \"cannot have non-public interfaces in different packages\");\n+                    }\n@@ -805,1 +815,3 @@\n-                    target = m;\n+\n+                    targetModule = m;\n+                    targetPackageName = e.getKey().getPackageName();\n@@ -811,1 +823,1 @@\n-                    if (m == target) continue;\n+                    if (m == targetModule) continue;\n@@ -813,2 +825,2 @@\n-                    if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {\n-                        throw new IllegalArgumentException(target + \" can't access \" + intf.getName());\n+                    if (!targetModule.canRead(m) || !m.isExported(intf.getPackageName(), targetModule)) {\n+                        throw new IllegalArgumentException(targetModule + \" can't access \" + intf.getName());\n@@ -818,0 +830,4 @@\n+                \/\/ opens the package of the non-public proxy class for java.base to access\n+                if (targetModule.isNamed()) {\n+                    Modules.addOpens(targetModule, targetPackageName, Proxy.class.getModule());\n+                }\n@@ -819,1 +835,1 @@\n-                return target;\n+                return targetModule;\n@@ -822,4 +838,3 @@\n-            \/\/ All proxy interfaces are public and at least one in a non-exported\n-            \/\/ package.  So maps to a dynamic proxy module and add reads edge\n-            \/\/ and qualified exports, if necessary\n-            Module target = getDynamicModule(loader);\n+            \/\/ All proxy interfaces are public.  So maps to a dynamic proxy module\n+            \/\/ and add reads edge and qualified exports, if necessary\n+            Module targetModule = getDynamicModule(loader);\n@@ -832,1 +847,1 @@\n-                ensureAccess(target, c);\n+                ensureAccess(targetModule, c);\n@@ -834,1 +849,1 @@\n-            return target;\n+            return targetModule;\n@@ -880,2 +895,3 @@\n-         * Define a dynamic module for the generated proxy classes in\n-         * a non-exported package named com.sun.proxy.$MODULE.\n+         * Define a dynamic module with a packge named $MODULE which\n+         * is unconditionally exported and another package named\n+         * com.sun.proxy.$MODULE which is encapsulated.\n@@ -891,3 +907,4 @@\n-                    ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n-                                    .packages(Set.of(pn))\n-                                    .build();\n+                        ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                                        .packages(Set.of(pn, mn))\n+                                        .exports(mn)\n+                                        .build();\n@@ -896,2 +913,4 @@\n-                \/\/ java.base to create proxy instance\n-                Modules.addExports(m, pn, Object.class.getModule());\n+                Modules.addExports(m, mn);\n+                \/\/ java.base to create proxy instance and access its Lookup instance\n+                Modules.addOpens(m, pn, Proxy.class.getModule());\n+                Modules.addOpens(m, mn, Proxy.class.getModule());\n@@ -1127,0 +1146,195 @@\n+\n+    \/**\n+     * A cache of Method -> MethodHandle for default methods.\n+     *\/\n+    private static final ClassValue<ConcurrentHashMap<Method, MethodHandle>>\n+            DEFAULT_METHODS_MAP = new ClassValue<>() {\n+        @Override\n+        protected ConcurrentHashMap<Method, MethodHandle> computeValue(Class<?> type) {\n+            return new ConcurrentHashMap<>(4);\n+        }\n+    };\n+\n+    private static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n+        assert isProxyClass(proxyClass);\n+        return DEFAULT_METHODS_MAP.get(proxyClass);\n+    }\n+\n+    static final Object[] EMPTY_ARGS = new Object[0];\n+\n+    static MethodHandle defaultMethodHandle(Class<? extends Proxy> proxyClass, Method method) {\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = defaultMethodMap(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Class<?> proxyInterface = findProxyInterfaceOrElseThrow(proxyClass, method);\n+            MethodHandle dmh;\n+            try {\n+                dmh = proxyClassLookup(lookup, proxyClass)\n+                        .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                        .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, InvocationException.wrapMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n+            if (cached != null) {\n+                superMH = cached;\n+            } else {\n+                superMH = mh;\n+            }\n+        }\n+        return superMH;\n+    }\n+\n+    \/**\n+     * Finds the first proxy interface that declares the given method\n+     * directly or indirectly.\n+     *\n+     * @throws IllegalArgumentException if not found\n+     *\/\n+    private static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+        Class<?> declaringClass = method.getDeclaringClass();\n+        if (!declaringClass.isInterface()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method +\n+                    \"\\\" is not a method declared in the proxy class\");\n+        }\n+\n+        List<Class<?>> proxyInterfaces = Arrays.asList(proxyClass.getInterfaces());\n+        \/\/ the method's declaring class is a proxy interface\n+        if (proxyInterfaces.contains(declaringClass))\n+            return declaringClass;\n+\n+        Deque<Class<?>> deque = new ArrayDeque<>();\n+        Set<Class<?>> visited = new HashSet<>();\n+        boolean indirectMethodRef = false;\n+        for (Class<?> intf : proxyInterfaces) {\n+            assert intf != declaringClass;\n+            visited.add(intf);\n+            deque.add(intf);\n+\n+            Class<?> c;\n+            while ((c = deque.poll()) != null) {\n+                if (c == declaringClass) {\n+                    try {\n+                        \/\/ check if this method is the resolved method if referenced from\n+                        \/\/ this proxy interface (i.e. this method is not implemented\n+                        \/\/ by any other superinterface)\n+                        Method m = intf.getMethod(method.getName(), method.getParameterTypes());\n+                        if (m.getDeclaringClass() == declaringClass) {\n+                            return intf;\n+                        }\n+                        indirectMethodRef = true;\n+                    } catch (NoSuchMethodException e) {}\n+\n+                    \/\/ skip traversing its superinterfaces\n+                    \/\/ another proxy interface may extend it and so\n+                    \/\/ the method's declaring class is left unvisited.\n+                    continue;\n+                }\n+                \/\/ visit all superinteraces of one proxy interface to find if\n+                \/\/ this proxy interface inherits the method directly or indirectly\n+                visited.add(c);\n+                for (Class<?> superIntf : c.getInterfaces()) {\n+                    if (!visited.contains(superIntf) && !deque.contains(superIntf)) {\n+                        if (superIntf == declaringClass) {\n+                            deque.addFirst(superIntf);\n+                        } else {\n+                            deque.add(superIntf);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"\\\"\" + method + (indirectMethodRef\n+                ? \"\\\" is overridden directly or indirectly by the proxy interfaces\"\n+                : \"\\\" is not a method declared in the proxy class\"));\n+    }\n+\n+    \/**\n+     * Returns a Lookup object for the lookup class which is the class of this\n+     * proxy instance.\n+     *\n+     * @return a lookup for proxy class of this proxy instance\n+     *\/\n+    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup caller, Class<?> proxyClass) {\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public MethodHandles.Lookup run() {\n+                try {\n+                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n+                    m.setAccessible(true);\n+                    return (MethodHandles.Lookup) m.invoke(null, caller);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        });\n+    }\n+\n+\n+    \/**\n+     * Internal exception type to wrap the exception thrown by the default method\n+     * so that it can distinguish CCE and NPE thrown due to the arguments\n+     * incompatible with the method signature.\n+     *\/\n+    static class InvocationException extends ReflectiveOperationException {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n+\n+        InvocationException(Throwable cause) {\n+            super(cause);\n+        }\n+\n+        \/**\n+         * Wraps given cause with InvocationException and throws it.\n+         *\/\n+        static Object wrap(Throwable cause) throws InvocationException {\n+            throw new InvocationException(cause);\n+        }\n+\n+        @Stable\n+        static MethodHandle wrapMethodHandle;\n+\n+        static MethodHandle wrapMH() {\n+            MethodHandle mh = wrapMethodHandle;\n+            if (mh == null) {\n+                try {\n+                    wrapMethodHandle = mh = MethodHandles.lookup().findStatic(\n+                            InvocationException.class,\n+                            \"wrap\",\n+                            MethodType.methodType(Object.class, Throwable.class)\n+                    );\n+                } catch (NoSuchMethodException | IllegalAccessException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+            return mh;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":273,"deletions":59,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -62,0 +63,2 @@\n+    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n+\n@@ -65,0 +68,2 @@\n+    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n@@ -78,0 +83,1 @@\n+    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -487,1 +493,1 @@\n-                visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,\n+                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n@@ -496,1 +502,1 @@\n-\n+        generateLookupAccessor();\n@@ -628,0 +634,40 @@\n+    \/**\n+     * Generate the static lookup accessor method that returns the Lookup\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n+     * otherwise, IllegalAccessException is thrown\n+     *\/\n+    private void generateLookupAccessor() {\n+        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n+                new String[] { JL_ILLEGAL_ACCESS_EX });\n+        mv.visitCode();\n+        Label L_illegalAccess = new Label();\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n+                \"()Ljava\/lang\/Class;\", false);\n+        mv.visitLdcInsn(Type.getType(Proxy.class));\n+        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n+                \"()Z\", false);\n+        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n+        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n+                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n+        mv.visitInsn(ARETURN);\n+\n+        mv.visitLabel(L_illegalAccess);\n+        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n+                \"()Ljava\/lang\/String;\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n+                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        mv.visitInsn(ATHROW);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -212,0 +212,5 @@\n+    \/**\n+     * Updates module m1 to export a package unconditionally.\n+     *\/\n+    void addExports(Module m1, String pkg);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,7 @@\n+    \/**\n+     * Updates module m to export a package unconditionally.\n+     *\/\n+    public static void addExports(Module m, String pn) {\n+        JLA.addExports(m, pn);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,2 +266,1 @@\n-        String pkg = cls.getPackageName();\n-        return pkg == null || !pkg.startsWith(PROXY_PACKAGE);\n+        return !Modifier.isPublic(cls.getModifiers());\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8159746\n+ * @run testng DefaultMethods\n+ * @summary Basic tests for Proxy::invokeSuper default method\n+ *\/\n+\n+public class DefaultMethods {\n+    public interface I1 {\n+        default int m() {\n+            return 10;\n+        }\n+    }\n+\n+    public interface I2 {\n+        default int m() {\n+            return 20;\n+        }\n+\n+        private void privateMethod() {\n+            throw new Error(\"should not reach here\");\n+        }\n+    }\n+\n+    \/\/ I3::m inherits from I2:m\n+    public interface I3 extends I2 {\n+        default int m3(String... s) {\n+            return Arrays.stream(s).mapToInt(String::length).sum();\n+        }\n+    }\n+\n+    public interface I4 extends I1, I2 {\n+        default int m() {\n+            return 40;\n+        }\n+\n+        default int mix(int a, String b) {\n+            return 0;\n+        }\n+    }\n+\n+    public interface I12 extends I1, I2 {\n+        @Override\n+        int m();\n+\n+        default int sum(int a, int b) {\n+            return a + b;\n+        }\n+\n+        default Object[] concat(Object first, Object... rest) {\n+            Object[] result = new Object[1 + rest.length];\n+            result[0] = first;\n+            System.arraycopy(rest, 0, result, 1, rest.length);\n+            return result;\n+        }\n+    }\n+\n+    public interface IX {\n+        default void doThrow(Throwable exception) throws Throwable {\n+            throw exception;\n+        }\n+    }\n+\n+    private static Method findDefaultMethod(Class<?> refc, Method m) {\n+        try {\n+            assertTrue(refc.isInterface());\n+\n+            Method method = refc.getMethod(m.getName(), m.getParameterTypes());\n+            assertTrue(method.isDefault());\n+            return method;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { I1.class, I2.class},\n+                (o, method, params) -> {\n+                    return InvocationHandler.invokeDefault(o, findDefaultMethod(I2.class, method), params);\n+                });\n+        I1 i1 = (I1) proxy;\n+        assertEquals(i1.m(), 20);\n+    }\n+\n+    \/\/ a default method is declared in one of the proxy interfaces\n+    @DataProvider(name = \"defaultMethods\")\n+    private Object[][] defaultMethods() {\n+        return new Object[][]{\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I12.class}, true, 10},\n+            new Object[]{new Class<?>[]{I2.class, I12.class}, true, 20},\n+            new Object[]{new Class<?>[]{I4.class}, true, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, true, 40},\n+            new Object[]{new Class<?>[]{I12.class}, false, -1},\n+            new Object[]{new Class<?>[]{I12.class, I1.class, I2.class}, false, -1}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"defaultMethods\")\n+    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Throwable {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault() == isDefault);\n+                    assertTrue(Arrays.stream(proxy.getClass().getInterfaces())\n+                                     .anyMatch(intf -> method.getDeclaringClass() == intf),\n+                               Arrays.toString(proxy.getClass().getInterfaces()));\n+                    if (method.isDefault()) {\n+                        return InvocationHandler.invokeDefault(proxy, method, params);\n+                    } else {\n+                        return -1;\n+                    }\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+\n+        Object proxy = Proxy.newProxyInstance(DefaultMethods.class.getClassLoader(), intfs, ih);\n+        Method m = proxy.getClass().getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        assertEquals(result, expected);\n+    }\n+\n+    \/\/ a default method may be declared in a proxy interface or\n+    \/\/ inherited from a superinterface of a proxy interface\n+    @DataProvider(name = \"supers\")\n+    private Object[][] supers() {\n+        return new Object[][]{\n+            \/\/ invoke \"m\" implemented in the first proxy interface\n+            \/\/ same as the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class}, I1.class, 10},\n+            new Object[]{new Class<?>[]{I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I1.class, 10},\n+            \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n+            new Object[]{new Class<?>[]{I3.class}, I3.class, 20},\n+            \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n+            new Object[]{new Class<?>[]{I4.class}, I4.class, 40},\n+            \/\/ invoke \"m\" implemented in the second proxy interface\n+            \/\/ different from the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, I3.class, 20},\n+            \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n+            \/\/ I3::m resolves to I2::m (indirect superinterface)\n+            \/\/ I2 is the superinterface of I4 and I4 overrides m\n+            \/\/ the proxy class can invoke I4::m and I2::m\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I4.class, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I4.class, 40}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"supers\")\n+    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Throwable {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefault(proxy, findDefaultMethod(proxyInterface, method), params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = proxyInterface.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, intfs, ih);\n+        if (proxyInterface == I1.class) {\n+            I1 i1 = (I1) proxy;\n+            assertEquals(i1.m(), expected);\n+        } else if (proxyInterface == I2.class) {\n+            I2 i2 = (I2) proxy;\n+            assertEquals(i2.m(), expected);\n+        } else if (proxyInterface == I3.class) {\n+            I3 i3 = (I3) proxy;\n+            assertEquals(i3.m(), expected);\n+        } else if (proxyInterface == I4.class) {\n+            I4 i4 = (I4) proxy;\n+            assertEquals(i4.m(), expected);\n+        } else {\n+            throw new UnsupportedOperationException(proxyInterface.toString());\n+        }\n+        \/\/ invoke via InvocationHandler.invokeDefaultMethod directly\n+        assertEquals(InvocationHandler.invokeDefault(proxy, proxyInterface.getMethod(\"m\")), expected);\n+    }\n+\n+    \/\/ invoke I12 default methods with parameters and var args\n+    @Test\n+    public void testI12() throws Throwable {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"sum\":\n+                case \"concat\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefault(proxy, method, params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 i12 = (I12) Proxy.newProxyInstance(loader, new Class<?>[] { I12.class }, ih);\n+        assertEquals(i12.sum(1, 2), 3);\n+        assertEquals(i12.concat(1, 2, 3, 4), new Object[]{1, 2, 3, 4});\n+        Method m = I12.class.getMethod(\"concat\", Object.class, Object[].class);\n+        assertTrue(m.isDefault());\n+        assertEquals(InvocationHandler.invokeDefault(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+                     new Object[] {100, \"foo\", true, \"bar\"});\n+    }\n+\n+    \/\/ test a no-arg default method with and without arguments passed in the invocation\n+    @Test\n+    public void testEmptyArgument() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m1 = I4.class.getMethod(\"m\");\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m1);\n+        InvocationHandler.invokeDefault(proxy, m1, new Object[0]);\n+\n+        Method m2 = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m2, Integer.valueOf(100), \"foo\");\n+    }\n+\n+    @Test\n+    public void testVarArgs() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3)Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I3.class.getMethod(\"m3\", String[].class);\n+        assertTrue(m.isVarArgs() && m.isDefault());\n+        assertEquals(proxy.m3(\"a\", \"b\", \"cde\"), 5);\n+        assertEquals(InvocationHandler.invokeDefault(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+    }\n+\n+    \/*\n+     * Invoke I12::m which is an abstract method\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeAbstractMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 proxy = (I12) Proxy.newProxyInstance(loader, new Class<?>[]{I12.class}, HANDLER);\n+        Method method = I12.class.getMethod(\"m\");\n+        assertTrue(method.getDeclaringClass() == I12.class);\n+        assertFalse(method.isDefault());\n+        proxy.m();\n+    }\n+\n+    \/*\n+     * Invoke a non proxy (default) method with parameters\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeNonProxyMethod() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3) Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m);\n+    }\n+\n+    \/\/ negative cases\n+    @DataProvider(name = \"negativeCases\")\n+    private Object[][] negativeCases() {\n+        return new Object[][]{\n+            \/\/ I4::m overrides I1::m and I2::m\n+            new Object[] { new Class<?>[]{I4.class}, I1.class, \"m\" },\n+            new Object[] { new Class<?>[]{I4.class}, I2.class, \"m\" },\n+            \/\/ I12::m is not a default method\n+            new Object[] { new Class<?>[]{I12.class}, I12.class, \"m\" },\n+            \/\/ non-proxy default method\n+            new Object[] { new Class<?>[]{I3.class}, I1.class, \"m\" },\n+            \/\/ not a default method and not a proxy interface\n+            new Object[] { new Class<?>[]{I12.class}, DefaultMethods.class, \"test\" },\n+            new Object[] { new Class<?>[]{I12.class}, Runnable.class, \"run\" },\n+            \/\/ I2::privateMethod is a private method\n+            new Object[] { new Class<?>[]{I3.class}, I2.class, \"privateMethod\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeCase(Class<?>[] interfaces, Class<?> defc, String name)\n+            throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, interfaces, HANDLER);\n+        try {\n+            Method method = defc.getDeclaredMethod(name);\n+            InvocationHandler.invokeDefault(proxy, method);\n+        } catch (Throwable e) {\n+            System.out.format(\"%s method %s::%s exception thrown: %s%n\",\n+                              Arrays.toString(interfaces), defc.getName(), name, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    @DataProvider(name = \"illegalArguments\")\n+    private Object[][] illegalArguments() {\n+        return new Object[][] {\n+            new Object[] {},\n+            new Object[] { 100 },\n+            new Object[] { 100, \"foo\", 100 },\n+            new Object[] { 100L, \"foo\" },\n+            new Object[] { \"foo\", 100},\n+            new Object[] { null, \"foo\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"illegalArguments\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testIllegalArgument(Object... args) throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        if (args.length == 0) {\n+            \/\/ substitute empty args with null since @DataProvider doesn't allow null array\n+            args = null;\n+        }\n+        InvocationHandler.invokeDefault(proxy, m, args);\n+    }\n+\n+    @DataProvider(name = \"throwables\")\n+    private Object[][] throwables() {\n+        return new Object[][] {\n+            new Object[] { new IOException() },\n+            new Object[] { new IllegalArgumentException() },\n+            new Object[] { new ClassCastException() },\n+            new Object[] { new NullPointerException() },\n+            new Object[] { new AssertionError() },\n+            new Object[] { new Throwable() }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"throwables\")\n+    public void testInvocationException(Throwable exception) throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        IX proxy = (IX)Proxy.newProxyInstance(loader, new Class<?>[]{IX.class}, HANDLER);\n+        Method m = IX.class.getMethod(\"doThrow\", Throwable.class);\n+        try {\n+            InvocationHandler.invokeDefault(proxy, m, exception);\n+        } catch (Throwable e) {\n+            assertEquals(e, exception);\n+        }\n+    }\n+\n+    private static final InvocationHandler HANDLER = (proxy, method, params) -> {\n+        System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n+    };\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -90,1 +90,1 @@\n-    public void testNoReadAccess() throws Exception {\n+    public void testNoReadAccess() throws Throwable {\n@@ -107,1 +107,1 @@\n-    private void checkIAE(ClassLoader loader, Class<?>[] interfaces) {\n+    private void checkIAE(ClassLoader loader, Class<?>[] interfaces)  throws Throwable {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyClassAccessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,2 +102,3 @@\n-        assertFalse(proxyClass.getModule().isNamed());\n-        assertFalse(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isNamed());\n+        assertTrue(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isExported(pkg.getName()));\n@@ -135,0 +136,1 @@\n+        assertFalse(proxyClass.getModule().isExported(pkg.getName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyLayerTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        new ProxyModuleMapping(unnamed, Runnable.class).test();\n+        new ProxyModuleMapping(Runnable.class).test();\n@@ -82,1 +82,2 @@\n-            if (module.isNamed()) {\n+            \/\/ the exported package name is same as the module name\n+            if (!c.getPackageName().equals(module.getName())) {\n@@ -86,1 +87,2 @@\n-            if (!module.isNamed()) {\n+            \/\/ non-exported package from the dynamic module\n+            if (c.getPackageName().equals(module.getName())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,16 @@\n+\n+    \/**\n+     * Tests invocation of default methods in exported and non-exported types\n+     * in a named module\n+     *\/\n+    @Test\n+    public void runDefaultMethodsTest() throws Exception {\n+        int exitValue = executeTestJava(\"-cp\", CPATH_DIR.toString(),\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"-m\", \"test\/jdk.test.DefaultMethods\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue();\n+\n+        assertTrue(exitValue == 0);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8159746\n+ * @summary Test invoking a default method in a non-public proxy interface\n+ * @build p.Foo p.Bar p.DefaultMethodInvoker\n+ * @run testng DefaultMethodProxy\n+ *\/\n+public class DefaultMethodProxy {\n+    public interface I {\n+        default String m() { return \"I\"; }\n+    }\n+\n+    @Test\n+    public static void hasPackageAccess() throws Exception {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+\n+        \/\/ create a proxy instance of a non-public proxy interface\n+        makeProxy(IH, fooClass).testDefaultMethod(\"foo\");\n+        makeProxy(IH, barClass, fooClass).testDefaultMethod(\"bar\");\n+\n+        \/\/ create a proxy instance of a public proxy interface should succeed\n+        makeProxy(IH, I.class).testDefaultMethod(\"I\");\n+    }\n+\n+    @DataProvider(name = \"nonPublicIntfs\")\n+    private static Object[][] nonPublicIntfs() throws ClassNotFoundException {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+        return new Object[][]{\n+                new Object[]{new Class<?>[]{ fooClass }},\n+                new Object[]{new Class<?>[]{ barClass }},\n+                new Object[]{new Class<?>[]{ barClass, fooClass }},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"nonPublicIntfs\")\n+    public static void noPackageAccess(Class<?>[] intfs) throws Exception {\n+        makeProxy(IH_NO_ACCESS, intfs).testDefaultMethod(\"dummy\");\n+    }\n+\n+    final Object proxy;\n+    DefaultMethodProxy(Object proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    \/*\n+     * Verify if a default method \"m\" can be invoked successfully\n+     *\/\n+    void testDefaultMethod(String expected) throws ReflectiveOperationException {\n+        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n+        m.setAccessible(true);\n+        String name = (String)m.invoke(proxy);\n+        if (!expected.equals(name)) {\n+            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n+        }\n+    }\n+\n+    \/\/ invocation handler with access to the non-public interface in package p\n+    private static final InvocationHandler IH = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                      .map(Class::getName)\n+                      .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            return p.DefaultMethodInvoker.invoke(proxy, method, params);\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    \/\/ invocation handler with no access to the non-public interface in package p\n+    \/\/ expect IllegalAccessException thrown\n+    private static final InvocationHandler IH_NO_ACCESS = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                        .map(Class::getName)\n+                        .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            try {\n+                InvocationHandler.invokeDefault(proxy, method, params);\n+                throw new RuntimeException(\"IAE not thrown in invoking: \" + method);\n+            } catch (IllegalAccessException e) {\n+                return \"dummy\";\n+            }\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    private static DefaultMethodProxy makeProxy(InvocationHandler ih, Class<?>... intfs) {\n+        Object proxy = Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, ih);\n+        return new DefaultMethodProxy(proxy);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/DefaultMethodProxy.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/NonPublicProxyClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"bar\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Bar.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+import java.lang.reflect.*;\n+\n+public class DefaultMethodInvoker {\n+     public static Object invoke(Object proxy, Method method, Object... args)\n+            throws Throwable {\n+         return InvocationHandler.invokeDefault(proxy, method, args);\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/DefaultMethodInvoker.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"foo\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Foo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+    default int m() { return 1; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m1\/p\/one\/I.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    default int m() { return 2; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/internal\/C.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+    default int m() {\n+        throw new UnsupportedOperationException(\"Q::m is in a non-exported package\");\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m3\/p\/three\/internal\/Q.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+\/**\n+ * Tests invocation of default methods in exported types and inaccessible types\n+ * in a named module\n+ *\/\n+public class DefaultMethods {\n+    private final static Module TEST_MODULE = DefaultMethods.class.getModule();\n+    private final static InvocationHandler IH = (proxy, method, params) -> {\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n+    };\n+\n+    public static void main(String... args) throws Throwable {\n+        \/\/ exported types from m1\n+        testDefaultMethod(new Class<?>[] { p.one.I.class, p.two.A.class}, 1);\n+        \/\/ qualified-exported type from m2\n+        testDefaultMethod(new Class<?>[] { p.two.internal.C.class, p.two.A.class }, 2);\n+        \/\/ module-private type from test module\n+        testDefaultMethod(new Class<?>[] { jdk.test.internal.R.class }, 10);\n+        \/\/ non-public interface in the same runtime package\n+        testDefaultMethod(new Class<?>[] { Class.forName(\"jdk.test.NP\") }, 100);\n+\n+        \/\/ inaccessible type - not exported to test module\n+        Class<?> qType = Class.forName(\"p.three.internal.Q\");\n+        inaccessibleDefaultMethod(qType);\n+        \/\/ non-public interface in the same runtime package\n+        Class<?> nonPublicType = Class.forName(\"jdk.test.internal.NP\");\n+        inaccessibleDefaultMethod(nonPublicType);\n+    }\n+\n+    static void testDefaultMethod(Class<?>[] intfs, int expected) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), intfs, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intfs[0].getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        if (result != expected) {\n+            throw new RuntimeException(\"return value: \" + result + \" expected: \" + expected);\n+        }\n+    }\n+\n+    static void inaccessibleDefaultMethod(Class<?> intf) throws Throwable {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), new Class<?>[] { intf }, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intf.getMethod(\"m\");\n+        try {\n+            InvocationHandler.invokeDefault(proxy, m, null);\n+            throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+        } catch (IllegalAccessException e) {}\n+\n+        if (m.trySetAccessible()) {\n+            try {\n+                m.invoke(proxy);\n+                throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+            } catch (InvocationTargetException e) {\n+                \/\/ IAE wrapped by InvocationHandler::invoke with UndeclaredThrowableException\n+                \/\/ then wrapped by Method::invoke with InvocationTargetException\n+                assert e.getCause() instanceof UndeclaredThrowableException;\n+                Throwable cause = e.getCause().getCause();\n+                if (!(cause instanceof IllegalAccessException))\n+                    throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/DefaultMethods.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -69,1 +69,0 @@\n-        Module unnamed = ld.getUnnamedModule();\n@@ -71,1 +70,0 @@\n-        Module unnamed2 = ld2.getUnnamedModule();\n@@ -74,11 +72,11 @@\n-            new Data(unnamed,  ld, Runnable.class),\n-            new Data(unnamed,  ld, p.one.I.class),\n-            new Data(unnamed,  ld, p.one.I.class, p.two.A.class),\n-            new Data(unnamed,  ld, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed2, ld2, Runnable.class),\n-            new Data(unnamed2, ld2, p.one.I.class),\n-            new Data(unnamed2, ld2, p.one.I.class, p.two.A.class),\n-            new Data(unnamed2, ld2, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed, m1.getClassLoader(), p.one.I.class),\n-            new Data(unnamed, m2.getClassLoader(), p.two.A.class),\n-            new Data(unnamed, m3.getClassLoader(), p.three.P.class),\n+            new Data(ld, Runnable.class),\n+            new Data(ld, p.one.I.class),\n+            new Data(ld, p.one.I.class, p.two.A.class),\n+            new Data(ld, p.one.I.class, unnamedModuleClass),\n+            new Data(ld2, Runnable.class),\n+            new Data(ld2, p.one.I.class),\n+            new Data(ld2, p.one.I.class, p.two.A.class),\n+            new Data(ld2, p.one.I.class, unnamedModuleClass),\n+            new Data(m1.getClassLoader(), p.one.I.class),\n+            new Data(m2.getClassLoader(), p.two.A.class),\n+            new Data(m3.getClassLoader(), p.three.P.class),\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/Main.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+\n+    default int m() {\n+        return 100;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/NP.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,4 @@\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            \/\/ the exported package has the same name as the dynamic module\n+            if (!proxyClass.getPackageName().equals(m.getName())) {\n+                throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/ProxyTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.internal;\n+\n+\/*\n+ * Non-public interface\n+ *\/\n+interface NP {\n+    default int m() {\n+        throw new UnsupportedOperationException(\"non-public interface: \" + NP.class.getName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/NP.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+\n+    default int m() { return 10; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/R.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                        new StackTraceElement(\"com.sun.proxy.$Proxy0\", \"hashCode\", null, -1),\n+                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,12 @@\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n@@ -28,0 +40,1 @@\n+import java.lang.reflect.Method;\n@@ -29,1 +42,1 @@\n-import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -32,3 +45,0 @@\n-@Warmup(iterations = 5)\n-@Measurement(iterations = 10)\n-@Fork(value = 1)\n@@ -36,0 +46,1 @@\n+@Fork(1)\n@@ -37,1 +48,3 @@\n-@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@State(Scope.Benchmark)\n@@ -39,0 +52,3 @@\n+    Interfaze implClass, implProxy;\n+    PpInterfaze ppImplClass, ppImplProxy;\n+    int a, b, c;\n@@ -40,17 +56,14 @@\n-    \/**\n-     * On Dell T7610:\n-     *\n-     * Benchmark w\/ the old ProxyGenerator\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  20.472 +\/- 0.209  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  57.353 +\/- 0.461  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  31.459 +\/- 0.516  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  66.580 +\/- 0.983  ns\/op\n-     *\n-     * Benchmark w\/ the new ProxyGenerator using ASM\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  21.291 +\/- 0.475  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  61.481 +\/- 4.709  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  30.177 +\/- 0.761  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  68.302 +\/- 1.344  ns\/op\n-     *\/\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        implClass = new Clazz();\n+        implProxy = (Interfaze) Proxy.newProxyInstance(\n+                Interfaze.class.getClassLoader(),\n+                new Class<?>[]{Interfaze.class},\n+                new IHandler()\n+        );\n+        ppImplClass = new PpClazz();\n+        ppImplProxy = (PpInterfaze) Proxy.newProxyInstance(\n+                PpInterfaze.class.getClassLoader(),\n+                new Class<?>[]{PpInterfaze.class},\n+                new IHandler()\n+        );\n@@ -58,2 +71,4 @@\n-    interface PkgPrivate1 {\n-        void m1();\n+        ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+        a = tlr.nextInt();\n+        b = tlr.nextInt();\n+        c = tlr.nextInt();\n@@ -62,2 +77,3 @@\n-    interface PkgPrivate2 {\n-        void m2();\n+    @Benchmark\n+    public int implClass() {\n+        return implClass.sum(a, b, c);\n@@ -66,9 +82,0 @@\n-    static final InvocationHandler handler = (proxy, method, args) -> null;\n-\n-    static final ClassLoader loader1 = null;\n-    static final Class<?>[] interfaces1 = {Runnable.class};\n-\n-    static final ClassLoader loader4 = PkgPrivate1.class.getClassLoader();\n-    static final Class<?>[] interfaces4 = {Runnable.class, Callable.class,\n-                                           PkgPrivate1.class, PkgPrivate2.class};\n-\n@@ -76,3 +83,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass1i() {\n-        return Proxy.getProxyClass(loader1, interfaces1);\n+    public int implProxy() {\n+        return implProxy.sum(a, b, c);\n@@ -82,3 +88,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass4i() {\n-        return Proxy.getProxyClass(loader4, interfaces4);\n+    public int ppImplClass() {\n+        return ppImplClass.sum(a, b, c);\n@@ -88,2 +93,2 @@\n-    public Object newProxyInstance1i() {\n-        return Proxy.newProxyInstance(loader1, interfaces1, handler);\n+    public int ppImplProxy() {\n+        return ppImplProxy.sum(a, b, c);\n@@ -92,3 +97,31 @@\n-    @Benchmark\n-    public Object newProxyInstance4i() {\n-        return Proxy.newProxyInstance(loader4, interfaces4, handler);\n+    public interface Interfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class Clazz implements Interfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return Interfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    interface PpInterfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class PpClazz implements PpInterfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return PpInterfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    static class IHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return InvocationHandler.invokeDefault(proxy, method, args);\n+        }\n@@ -96,1 +129,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Proxy\/ProxyBench.java","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"}]}