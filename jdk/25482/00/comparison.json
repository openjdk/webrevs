{"files":[{"patch":"@@ -83,5 +83,0 @@\n-  bool is_maximal_no_gc() const override {\n-    \/\/ No GC is going to happen. Return \"we are at max\", when we are about to fail.\n-    return used() == capacity();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -969,1 +969,1 @@\n-  bool is_maximal_no_gc() const override {\n+  bool is_maximal_no_gc() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,6 +211,0 @@\n-bool ParallelScavengeHeap::is_maximal_no_gc() const {\n-  \/\/ We don't expand young-gen except at a GC.\n-  return old_gen()->is_maximal_no_gc();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,5 +161,0 @@\n-  \/\/ Return \"true\" if all generations have reached the\n-  \/\/ maximal committed limit that they can reach, without a garbage\n-  \/\/ collection.\n-  bool is_maximal_no_gc() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -113,4 +113,0 @@\n-  bool is_maximal_no_gc() const {\n-    return virtual_space()->uncommitted_size() == 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -769,5 +769,0 @@\n-bool SerialHeap::is_maximal_no_gc() const {\n-  \/\/ We don't expand young-gen except at a GC.\n-  return _old_gen->is_maximal_no_gc();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -219,5 +219,0 @@\n-  \/\/ Return \"true\" if all generations have reached the\n-  \/\/ maximal committed limit that they can reach, without a garbage\n-  \/\/ collection.\n-  virtual bool is_maximal_no_gc() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,6 +105,0 @@\n-  \/\/ Returns true if this generation cannot be expanded further\n-  \/\/ without a GC.\n-  bool is_maximal_no_gc() const {\n-    return _virtual_space.uncommitted_size() == 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -262,5 +262,0 @@\n-  \/\/ Return \"true\" if the part of the heap that allocates Java\n-  \/\/ objects has reached the maximal committed limit that it can\n-  \/\/ reach, without a garbage collection.\n-  virtual bool is_maximal_no_gc() const = 0;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -617,2 +617,0 @@\n-  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,6 +129,0 @@\n-bool ZCollectedHeap::is_maximal_no_gc() const {\n-  \/\/ Not supported\n-  ShouldNotReachHere();\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  bool is_maximal_no_gc() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}