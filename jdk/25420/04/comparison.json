{"files":[{"patch":"@@ -816,0 +816,8 @@\n+C2V_VMENTRY_0(jint, getNumIndyEntries, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp)))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  if (cp->cache()->resolved_indy_entries() == nullptr) {\n+    return 0;\n+  }\n+  return cp->resolved_indy_entries_length();\n+C2V_END\n+\n@@ -3323,0 +3331,1 @@\n+  {CC \"getNumIndyEntries\",                            CC \"(\" HS_CONSTANT_POOL2 \")I\",                                                        FN_PTR(getNumIndyEntries)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -471,1 +471,11 @@\n-  }\n+    }\n+\n+    private native int decodeMethodIndexToCPIndex(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex);\n+\n+    \/**\n+     * Returns the number of {@code ResolvedIndyEntry}s present within this constant\n+     * pool.\n+     *\/\n+    int getNumIndyEntries(HotSpotConstantPool constantPool) {\n+        return getNumIndyEntries(constantPool, constantPool.getConstantPoolPointer());\n+    }\n@@ -473,1 +483,1 @@\n-  private native int decodeMethodIndexToCPIndex(HotSpotConstantPool constantPool, long constantPoolPointer, int rawIndex);\n+    private native int getNumIndyEntries(HotSpotConstantPool constantPool, long constantPoolPointer);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.stream.IntStream;\n@@ -533,1 +534,1 @@\n-    static class BootstrapMethodInvocationImpl implements BootstrapMethodInvocation {\n+    class BootstrapMethodInvocationImpl implements BootstrapMethodInvocation {\n@@ -539,0 +540,1 @@\n+        private final int cpiOrIndyIndex;\n@@ -540,1 +542,1 @@\n-        BootstrapMethodInvocationImpl(boolean indy, ResolvedJavaMethod method, String name, JavaConstant type, List<JavaConstant> staticArguments) {\n+        BootstrapMethodInvocationImpl(boolean indy, ResolvedJavaMethod method, String name, JavaConstant type, List<JavaConstant> staticArguments, int cpiOrIndyIndex) {\n@@ -546,0 +548,1 @@\n+            this.cpiOrIndyIndex = cpiOrIndyIndex;\n@@ -573,0 +576,18 @@\n+        @Override\n+        public void resolve() {\n+            if (isInvokeDynamic()) {\n+                loadReferencedType(cpiOrIndyIndex, Bytecodes.INVOKEDYNAMIC);\n+            } else {\n+                lookupConstant(cpiOrIndyIndex, true);\n+            }\n+        }\n+\n+        @Override\n+        public JavaConstant lookup() {\n+            if (isInvokeDynamic()) {\n+                return lookupAppendix(cpiOrIndyIndex, Bytecodes.INVOKEDYNAMIC);\n+            } else {\n+                return (JavaConstant) lookupConstant(cpiOrIndyIndex, false);\n+            }\n+        }\n+\n@@ -615,1 +636,2 @@\n-                return new BootstrapMethodInvocationImpl(tag.name.equals(\"InvokeDynamic\"), method, name, type, staticArgumentsList);\n+                boolean isIndy = tag.name.equals(\"InvokeDynamic\");\n+                return new BootstrapMethodInvocationImpl(isIndy, method, name, type, staticArgumentsList, isIndy ? index : cpi);\n@@ -621,0 +643,23 @@\n+    private boolean isDynamicEntry(int cpi) {\n+        JvmConstant tagAt = getTagAt(cpi);\n+        return tagAt != null && tagAt.name.equals(\"Dynamic\");\n+    }\n+\n+    @Override\n+    public List<BootstrapMethodInvocation> lookupBootstrapMethodInvocations(boolean invokeDynamic){\n+        if (invokeDynamic) {\n+            int numIndys = compilerToVM().getNumIndyEntries(this);\n+            if (numIndys == 0) {\n+                return List.of();\n+            }\n+            return IntStream.range(0, numIndys)\n+                            .mapToObj(i -> lookupBootstrapMethodInvocation(i, Bytecodes.INVOKEDYNAMIC))\n+                            .toList();\n+        } else {\n+            return IntStream.range(1, length())\n+                            .filter(this::isDynamicEntry)\n+                            .mapToObj(cpi -> lookupBootstrapMethodInvocation(cpi, -1))\n+                            .toList();\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-         * The other types of entries are already resolved an can be used directly.\n+         * The other types of entries are already resolved and can be used directly.\n@@ -194,0 +194,17 @@\n+\n+        \/**\n+         * Resolves the element corresponding to this bootstrap. If\n+         * {@code isInvokeDynamic()}, then the corresponding invoke dynamic is resolved.\n+         * If {@code !isInvokeDynamic()}, then the dynamic constant pool entry will be\n+         * resolved.\n+         *\n+         * @jvms 5.4.3.6\n+         *\/\n+        void resolve();\n+\n+        \/**\n+         * If {@code isInvokeDynamic()}, then this method looks up the corresponding\n+         * invoke dynamic's appendix. If {@code !isInvokeDynamic()}, then this will\n+         * return the constant pool entry's value.\n+         *\/\n+        JavaConstant lookup();\n@@ -207,1 +224,1 @@\n-     *         is not a {@code CONSTANT_Dynamic_info} or @{code CONSTANT_InvokeDynamic_info}\n+     *         is not a {@code CONSTANT_Dynamic_info} or {@code CONSTANT_InvokeDynamic_info}\n@@ -214,0 +231,14 @@\n+    \/**\n+     * Returns either the BootstrapMethodInvocation instances for all invokedynamic\n+     * bytecodes which reference this constant pool, or all\n+     * {@code CONSTANT_Dynamic_info} BootstrapMethodInvocations within this constant\n+     * pool. The returned List is unmodifiable; calls to any mutator method will\n+     * always cause {@code UnsupportedOperationException} to be thrown.\n+     *\n+     * @param invokeDynamic when true, return all invokedynamic\n+     *                      BootstrapMethodInvocations; otherwise, return all\n+     *                      {@code CONSTANT_Dynamic_info}\n+     *                      BootstrapMethodInvocations.\n+     *\/\n+    List<BootstrapMethodInvocation> lookupBootstrapMethodInvocations(boolean invokeDynamic);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ConstantPool.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import java.util.Set;\n+import java.util.Map;\n@@ -379,3 +379,4 @@\n-        Set<String> expectedBSMs = Set.of(\n-            \"jdk.vm.ci.hotspot.test.TestDynamicConstant.shouldNotBeCalledBSM\",\n-            \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\"\n+        \/\/ Contains a map of (bootstrap method names, resolvable) values.\n+        Map<String, Boolean> expectedIndyBSMs = Map.of(\n+            \"jdk.vm.ci.hotspot.test.TestDynamicConstant.shouldNotBeCalledBSM\", false,\n+            \"java.lang.invoke.StringConcatFactory.makeConcatWithConstants\", true\n@@ -392,1 +393,1 @@\n-                    Assert.assertTrue(expectedBSMs.contains(bsm), expectedBSMs.toString());\n+                    Assert.assertTrue(expectedIndyBSMs.containsKey(bsm), expectedIndyBSMs.toString());\n@@ -395,0 +396,1 @@\n+                    Assert.assertNull(bsmi.lookup());\n@@ -426,0 +428,35 @@\n+\n+        testLookupBootstrapMethodInvocations(condyType, cp, expectedIndyBSMs);\n+    }\n+\n+    private static void testLookupBootstrapMethodInvocations(CondyType condyType, ConstantPool cp, Map<String, Boolean> expectedIndyBSMs) {\n+        List<BootstrapMethodInvocation> indyBSMs = cp.lookupBootstrapMethodInvocations(true);\n+        Assert.assertEquals(indyBSMs.size(), 2);\n+        for (var bsmi : indyBSMs) {\n+            String bsm = bsmi.getMethod().format(\"%H.%n\");\n+            Assert.assertTrue(expectedIndyBSMs.containsKey(bsm), expectedIndyBSMs.toString());\n+            Assert.assertTrue(bsmi.isInvokeDynamic());\n+            if (expectedIndyBSMs.get(bsm)) {\n+                bsmi.resolve();\n+                Assert.assertNotNull(bsmi.lookup());\n+            } else {\n+                try {\n+                    bsmi.resolve();\n+                } catch (BootstrapMethodError bme) {\n+                    \/\/ expected error\n+                }\n+                Assert.assertNull(bsmi.lookup());\n+            }\n+        }\n+\n+        List<BootstrapMethodInvocation> condyBSMs = cp.lookupBootstrapMethodInvocations(false);\n+        int expectedNumCondys = switch(condyType) {\n+            case CALL_DIRECT_BSM, CALL_INDIRECT_BSM -> 1;\n+            case CALL_DIRECT_WITH_ARGS_BSM, CALL_INDIRECT_WITH_ARGS_BSM -> 2;\n+        };\n+        Assert.assertEquals(condyBSMs.size(), expectedNumCondys);\n+        for (var bsmi : condyBSMs) {\n+            Assert.assertTrue(!bsmi.isInvokeDynamic());\n+            bsmi.resolve();\n+            Assert.assertNotNull(bsmi.lookup());\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"}]}