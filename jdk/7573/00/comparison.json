{"files":[{"patch":"@@ -120,0 +120,72 @@\n+static void prefetch_write(void *p) {\n+  if (PrefetchScanIntervalInBytes >= 0) {\n+    Prefetch::write(p, PrefetchScanIntervalInBytes);\n+  }\n+}\n+\n+\/\/ postcondition: ret is a dirty card or end_card\n+CardTable::CardValue* PSCardTable::find_first_dirty_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n+    if (*i_card != PSCardTable::clean_card_val()) {\n+      return i_card;\n+    }\n+  }\n+  return end_card;\n+}\n+\n+\/\/ postcondition: ret is a clean card or end_card\n+\/\/ Note: if a part of an object is on a dirty card, all cards this object\n+\/\/ resides on are considered dirty.\n+CardTable::CardValue* PSCardTable::find_first_clean_card(ObjectStartArray* const start_array,\n+                                                         CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  assert(start_card == end_card ||\n+         *start_card != PSCardTable::clean_card_val(), \"precondition\");\n+  \/\/ Skip the first dirty card.\n+  CardValue* i_card = start_card + 1;\n+  while (i_card < end_card) {\n+    if (*i_card != PSCardTable::clean_card_val()) {\n+      i_card++;\n+      continue;\n+    }\n+    assert(i_card - 1 >= start_card, \"inv\");\n+    assert(*(i_card - 1) != PSCardTable::clean_card_val(), \"prev card must be dirty\");\n+    \/\/ Find the final obj on the prev dirty card.\n+    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n+    HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+    CardValue* final_card_by_obj = byte_for(obj_end_addr - 1);\n+    assert(final_card_by_obj < end_card, \"inv\");\n+    if (final_card_by_obj <= i_card) {\n+      return i_card;\n+    }\n+    \/\/ This final obj extends beyond i_card, check if this new card is dirty.\n+    if (*final_card_by_obj == PSCardTable::clean_card_val()) {\n+      return final_card_by_obj;\n+    }\n+    \/\/ This new card is dirty, continuing the search...\n+    i_card = final_card_by_obj + 1;\n+  }\n+  return end_card;\n+}\n+\n+void PSCardTable::clear_cards(CardValue* const start, CardValue* const end) {\n+  for (CardValue* i_card = start; i_card < end; ++i_card) {\n+    *i_card = clean_card;\n+  }\n+}\n+\n+void PSCardTable::scan_objects_in_range(PSPromotionManager* pm,\n+                                        HeapWord* start,\n+                                        HeapWord* end) {\n+  HeapWord* obj_addr = start;\n+  while (obj_addr < end) {\n+    oop obj = cast_to_oop(obj_addr);\n+    assert(oopDesc::is_oop(obj), \"inv\");\n+    prefetch_write(obj_addr);\n+    pm->push_contents(obj);\n+    obj_addr += obj->size();\n+  }\n+  pm->drain_stacks_cond_depth();\n+}\n+\n@@ -125,3 +197,1 @@\n-\/\/ do no work.  If this method needs to be called\n-\/\/ when the space is empty, fix the calculation of\n-\/\/ end_card to allow sp_top == sp->bottom().\n+\/\/ do no work. This method is just a no-op if space_top == sp->bottom().\n@@ -131,1 +201,1 @@\n-\/\/ a stripe is a constant, ssize.\n+\/\/ a stripe is a constant, num_cards_in_stripe.\n@@ -155,5 +225,4 @@\n-\/\/ the next slice is calculated based on the number of stripes.  The next\n-\/\/ stripe is at ssize * number_of_stripes (= slice_stride)..  So after\n-\/\/ finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1 by\n-\/\/ adding slice_stride to the start of stripe 0 in slice 0 to get to the start\n-\/\/ of stride 0 in slice 1.\n+\/\/ the next slice is calculated based on the number of stripes. After finishing\n+\/\/ stripe 0 in slice 0, the thread finds the stripe 0 in slice 1 by adding\n+\/\/ slice_size_in_words to the start of stripe 0 in slice 0 to get to the start\n+\/\/ of stripe 0 in slice 1.\n@@ -165,34 +234,15 @@\n-                                             uint stripe_number,\n-                                             uint stripe_total) {\n-  int ssize = 128; \/\/ Naked constant!  Work unit = 64k.\n-\n-  \/\/ It is a waste to get here if empty.\n-  assert(sp->bottom() < sp->top(), \"Should not be called if empty\");\n-  oop* sp_top = (oop*)space_top;\n-  CardValue* start_card = byte_for(sp->bottom());\n-  CardValue* end_card   = byte_for(sp_top - 1) + 1;\n-  oop* last_scanned = NULL; \/\/ Prevent scanning objects more than once\n-  \/\/ The width of the stripe ssize*stripe_total must be\n-  \/\/ consistent with the number of stripes so that the complete slice\n-  \/\/ is covered.\n-  size_t slice_width = ssize * stripe_total;\n-  for (CardValue* slice = start_card; slice < end_card; slice += slice_width) {\n-    CardValue* worker_start_card = slice + stripe_number * ssize;\n-    if (worker_start_card >= end_card)\n-      return; \/\/ We're done.\n-\n-    CardValue* worker_end_card = worker_start_card + ssize;\n-    if (worker_end_card > end_card)\n-      worker_end_card = end_card;\n-\n-    \/\/ We do not want to scan objects more than once. In order to accomplish\n-    \/\/ this, we assert that any object with an object head inside our 'slice'\n-    \/\/ belongs to us. We may need to extend the range of scanned cards if the\n-    \/\/ last object continues into the next 'slice'.\n-    \/\/\n-    \/\/ Note! ending cards are exclusive!\n-    HeapWord* slice_start = addr_for(worker_start_card);\n-    HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));\n-\n-    \/\/ If there are not objects starting within the chunk, skip it.\n-    if (!start_array->object_starts_in_range(slice_start, slice_end)) {\n+                                             uint stripe_index,\n+                                             uint n_stripes) {\n+  const size_t num_cards_in_stripe = 128;\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n+\n+  HeapWord* cur_stripe_addr = sp->bottom() + stripe_index * stripe_size_in_words;\n+\n+  for (\/* empty *\/; cur_stripe_addr < space_top; cur_stripe_addr += slice_size_in_words) {\n+    \/\/ exclusive\n+    HeapWord* const cur_stripe_end_addr = MIN2(cur_stripe_addr + stripe_size_in_words,\n+                                               space_top);\n+\n+    \/\/ Process a stripe iff it contains any obj-start\n+    if (!start_array->object_starts_in_range(cur_stripe_addr, cur_stripe_end_addr)) {\n@@ -201,7 +251,21 @@\n-    \/\/ Update our beginning addr\n-    HeapWord* first_object = start_array->object_start(slice_start);\n-    debug_only(oop* first_object_within_slice = (oop*) first_object;)\n-    if (first_object < slice_start) {\n-      last_scanned = (oop*)(first_object + cast_to_oop(first_object)->size());\n-      debug_only(first_object_within_slice = last_scanned;)\n-      worker_start_card = byte_for(last_scanned);\n+\n+    \/\/ Constraints:\n+    \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+    \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+    \/\/ 3. range of objs (obj-start) can be scanned: [first_obj_addr, cur_stripe_end_addr)\n+\n+    CardValue* iter_limit_l;\n+    CardValue* iter_limit_r;\n+    CardValue* clear_limit_l;\n+    CardValue* clear_limit_r;\n+\n+    \/\/ Identify left ends and the first obj-start inside this stripe.\n+    HeapWord* first_obj_addr = start_array->object_start(cur_stripe_addr);\n+    if (first_obj_addr < cur_stripe_addr) {\n+      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n+      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n+      clear_limit_l = byte_for(first_obj_addr - 1) + 1;\n+      iter_limit_l = byte_for(first_obj_addr);\n+    } else {\n+      assert(first_obj_addr == cur_stripe_addr, \"inv\");\n+      iter_limit_l = clear_limit_l = byte_for(cur_stripe_addr);\n@@ -210,11 +274,10 @@\n-    \/\/ Update the ending addr\n-    if (slice_end < (HeapWord*)sp_top) {\n-      \/\/ The subtraction is important! An object may start precisely at slice_end.\n-      HeapWord* last_object = start_array->object_start(slice_end - 1);\n-      slice_end = last_object + cast_to_oop(last_object)->size();\n-      \/\/ worker_end_card is exclusive, so bump it one past the end of last_object's\n-      \/\/ covered span.\n-      worker_end_card = byte_for(slice_end) + 1;\n-\n-      if (worker_end_card > end_card)\n-        worker_end_card = end_card;\n+    assert(cur_stripe_addr <= first_obj_addr, \"inside this stripe\");\n+    assert(first_obj_addr <= cur_stripe_end_addr, \"can be empty\");\n+\n+    {\n+      \/\/ Identify right ends.\n+      HeapWord* obj_addr = start_array->object_start(cur_stripe_end_addr - 1);\n+      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n+      clear_limit_r = byte_for(obj_end_addr);\n+      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n@@ -223,13 +286,17 @@\n-    assert(slice_end <= (HeapWord*)sp_top, \"Last object in slice crosses space boundary\");\n-    assert(is_valid_card_address(worker_start_card), \"Invalid worker start card\");\n-    assert(is_valid_card_address(worker_end_card), \"Invalid worker end card\");\n-    \/\/ Note that worker_start_card >= worker_end_card is legal, and happens when\n-    \/\/ an object spans an entire slice.\n-    assert(worker_start_card <= end_card, \"worker start card beyond end card\");\n-    assert(worker_end_card <= end_card, \"worker end card beyond end card\");\n-\n-    CardValue* current_card = worker_start_card;\n-    while (current_card < worker_end_card) {\n-      \/\/ Find an unclean card.\n-      while (current_card < worker_end_card && card_is_clean(*current_card)) {\n-        current_card++;\n+    assert(iter_limit_l <= clear_limit_l &&\n+           clear_limit_r <= iter_limit_r, \"clear cards only if we iterate over them\");\n+\n+    \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+    \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+    CardValue* dirty_l;\n+    CardValue* dirty_r;\n+\n+    for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+      dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n+      assert(dirty_l <= dirty_r, \"inv\");\n+\n+      \/\/ empty\n+      if (dirty_l == dirty_r) {\n+        assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+        break;\n@@ -237,25 +304,10 @@\n-      CardValue* first_unclean_card = current_card;\n-\n-      \/\/ Find the end of a run of contiguous unclean cards\n-      while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-        while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-          current_card++;\n-        }\n-\n-        if (current_card < worker_end_card) {\n-          \/\/ Some objects may be large enough to span several cards. If such\n-          \/\/ an object has more than one dirty card, separated by a clean card,\n-          \/\/ we will attempt to scan it twice. The test against \"last_scanned\"\n-          \/\/ prevents the redundant object scan, but it does not prevent newly\n-          \/\/ marked cards from being cleaned.\n-          HeapWord* last_object_in_dirty_region = start_array->object_start(addr_for(current_card)-1);\n-          size_t size_of_last_object = cast_to_oop(last_object_in_dirty_region)->size();\n-          HeapWord* end_of_last_object = last_object_in_dirty_region + size_of_last_object;\n-          CardValue* ending_card_of_last_object = byte_for(end_of_last_object);\n-          assert(ending_card_of_last_object <= worker_end_card, \"ending_card_of_last_object is greater than worker_end_card\");\n-          if (ending_card_of_last_object > current_card) {\n-            \/\/ This means the object spans the next complete card.\n-            \/\/ We need to bump the current_card to ending_card_of_last_object\n-            current_card = ending_card_of_last_object;\n-          }\n-        }\n+\n+      assert(*dirty_l != clean_card, \"inv\");\n+      assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+             \"clean card or belonging to next stripe\");\n+\n+      \/\/ Process this non-empty dirty chunk in two steps:\n+      {\n+        \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+        clear_cards(MAX2(dirty_l, clear_limit_l),\n+                    MIN2(dirty_r, clear_limit_r));\n@@ -263,61 +315,10 @@\n-      CardValue* following_clean_card = current_card;\n-\n-      if (first_unclean_card < worker_end_card) {\n-        oop* p = (oop*) start_array->object_start(addr_for(first_unclean_card));\n-        assert((HeapWord*)p <= addr_for(first_unclean_card), \"checking\");\n-        \/\/ \"p\" should always be >= \"last_scanned\" because newly GC dirtied\n-        \/\/ cards are no longer scanned again (see comment at end\n-        \/\/ of loop on the increment of \"current_card\").  Test that\n-        \/\/ hypothesis before removing this code.\n-        \/\/ If this code is removed, deal with the first time through\n-        \/\/ the loop when the last_scanned is the object starting in\n-        \/\/ the previous slice.\n-        assert((p >= last_scanned) ||\n-               (last_scanned == first_object_within_slice),\n-               \"Should no longer be possible\");\n-        if (p < last_scanned) {\n-          \/\/ Avoid scanning more than once; this can happen because\n-          \/\/ newgen cards set by GC may a different set than the\n-          \/\/ originally dirty set\n-          p = last_scanned;\n-        }\n-        oop* to = (oop*)addr_for(following_clean_card);\n-\n-        \/\/ Test slice_end first!\n-        if ((HeapWord*)to > slice_end) {\n-          to = (oop*)slice_end;\n-        } else if (to > sp_top) {\n-          to = sp_top;\n-        }\n-\n-        \/\/ we know which cards to scan, now clear them\n-        if (first_unclean_card <= worker_start_card+1)\n-          first_unclean_card = worker_start_card+1;\n-        if (following_clean_card >= worker_end_card-1)\n-          following_clean_card = worker_end_card-1;\n-\n-        while (first_unclean_card < following_clean_card) {\n-          *first_unclean_card++ = clean_card;\n-        }\n-\n-        const int interval = PrefetchScanIntervalInBytes;\n-        \/\/ scan all objects in the range\n-        if (interval != 0) {\n-          while (p < to) {\n-            Prefetch::write(p, interval);\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        } else {\n-          while (p < to) {\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        }\n-        last_scanned = p;\n+\n+      {\n+        \/\/ 2. Scan objs in [dirty_l, dirty_r) subject to [first_obj_addr, cur_stripe_end_addr) constraint\n+        HeapWord* obj_l = MAX2(start_array->object_start(addr_for(dirty_l)),\n+                               first_obj_addr);\n+\n+        HeapWord* obj_r = MIN2(addr_for(dirty_r),\n+                               cur_stripe_end_addr);\n+\n+        scan_objects_in_range(pm, obj_l, obj_r);\n@@ -325,12 +326,0 @@\n-      \/\/ \"current_card\" is still the \"following_clean_card\" or\n-      \/\/ the current_card is >= the worker_end_card so the\n-      \/\/ loop will not execute again.\n-      assert((current_card == following_clean_card) ||\n-             (current_card >= worker_end_card),\n-        \"current_card should only be incremented if it still equals \"\n-        \"following_clean_card\");\n-      \/\/ Increment current_card so that it is not processed again.\n-      \/\/ It may now be dirty because a old-to-young pointer was\n-      \/\/ found on it an updated.  If it is now dirty, it cannot be\n-      \/\/ be safely cleaned in the next iteration.\n-      current_card++;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":161,"deletions":172,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -45,0 +45,13 @@\n+  CardValue* find_first_dirty_card(CardValue* const start_card,\n+                                   CardValue* const end_card);\n+\n+  CardValue* find_first_clean_card(ObjectStartArray* start_array,\n+                                   CardValue* const start_card,\n+                                   CardValue* const end_card);\n+\n+  void clear_cards(CardValue* const start, CardValue* const end);\n+\n+  void scan_objects_in_range(PSPromotionManager* pm,\n+                             HeapWord* start,\n+                             HeapWord* end);\n+\n@@ -56,2 +69,2 @@\n-                                  uint stripe_number,\n-                                  uint stripe_total);\n+                                  uint stripe_index,\n+                                  uint n_stripes);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}