{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.classfile.ClassTransform;\n@@ -30,0 +29,5 @@\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n@@ -62,2 +66,7 @@\n-                        byte[] content = newClassReader(path, resource, Classfile.Option.processDebug(false))\n-                                                .transform(ClassTransform.ACCEPT_ALL);\n+                        byte[] content = newClassReader(path, resource,\n+                                Classfile.Option.processDebug(false),\n+                                Classfile.Option.processLineNumbers(false)).transform(ClassTransform\n+                                        .dropping(cle -> cle instanceof SourceFileAttribute\n+                                                      || cle instanceof SourceDebugExtensionAttribute)\n+                                        .andThen(ClassTransform.transformingMethods(MethodTransform\n+                                                .dropping(me -> me instanceof MethodParametersAttribute))));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -430,1 +430,2 @@\n-                        .anyMatch(e -> e instanceof ModulePackagesAttribute mpa && !mpa.packages().isEmpty());\n+                        .anyMatch(e -> e instanceof ModulePackagesAttribute mpa\n+                                    && !mpa.packages().isEmpty());\n@@ -866,1 +867,2 @@\n-                            MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\");\n+                            MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(\n+                                    \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\");\n@@ -878,1 +880,2 @@\n-                                MethodTypeDesc.ofDescriptor(\"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\"), true);\n+                                MethodTypeDesc.ofDescriptor(\n+                                        \"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\"), true);\n@@ -1260,1 +1263,2 @@\n-                    \"of\", MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/Object;)Ljava\/util\/List;\"), true);\n+                    \"of\", MethodTypeDesc.ofDescriptor(\n+                            \"([Ljava\/lang\/Object;)Ljava\/util\/List;\"), true);\n@@ -1599,1 +1603,2 @@\n-                            \"of\", MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"), true);\n+                            \"of\", MethodTypeDesc.ofDescriptor(\n+                                    \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"), true);\n@@ -1701,1 +1706,1 @@\n-                                    cob.stackInstruction(Opcode.DUP);                  \/\/ arrayref\n+                                    cob.stackInstruction(Opcode.DUP); \/\/ arrayref\n@@ -1721,1 +1726,1 @@\n-                                    cob.stackInstruction(Opcode.DUP);                  \/\/ arrayref\n+                                    cob.stackInstruction(Opcode.DUP); \/\/ arrayref\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.classfile.ClassTransform;\n@@ -31,1 +32,0 @@\n-import jdk.internal.classfile.CodeModel;\n@@ -34,2 +34,0 @@\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.Opcode;\n@@ -104,13 +102,11 @@\n-        return newClassReader(path, classFile).transform((clb, cle) -> {\n-                if (cle instanceof MethodModel mm && mm.methodName().equalsString(\"<clinit>\")) {\n-                        clb.transformMethod(mm, (mb, me) -> {\n-                            if (me instanceof CodeModel cm) {\n-                                mb.transformCode(cm, new CodeTransform() {\n-                                    private CodeElement pendingLDC = null;\n-\n-                                    private void flushPendingLDC(CodeBuilder cob) {\n-                                        if (pendingLDC != null) {\n-                                            cob.accept(pendingLDC);\n-                                            pendingLDC = null;\n-                                        }\n-                                    }\n+        return newClassReader(path, classFile).transform(ClassTransform.transformingMethodBodies(\n+                mm -> mm.methodName().equalsString(\"<clinit>\"),\n+                new CodeTransform() {\n+                    private CodeElement pendingLDC = null;\n+\n+                    private void flushPendingLDC(CodeBuilder cob) {\n+                        if (pendingLDC != null) {\n+                            cob.accept(pendingLDC);\n+                            pendingLDC = null;\n+                        }\n+                    }\n@@ -118,36 +114,25 @@\n-                                    @Override\n-                                    public void accept(CodeBuilder cob, CodeElement coe) {\n-                                        if (coe instanceof Instruction ins) switch (ins.opcode()) {\n-                                            case LDC, LDC_W, LDC2_W -> {\n-                                                flushPendingLDC(cob);\n-                                                pendingLDC = coe;\n-                                            }\n-                                            case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE -> {\n-                                                flushPendingLDC(cob);\n-                                                cob.accept(coe);\n-                                            }\n-                                            case GETSTATIC, GETFIELD, PUTFIELD -> {\n-                                                flushPendingLDC(cob);\n-                                                cob.accept(coe);\n-                                            }\n-                                            case PUTSTATIC -> {\n-                                                if (((FieldInstruction)coe).name().equalsString(field)) {\n-                                                    \/\/ assert that there is a pending ldc\n-                                                    \/\/ for the old value\n-                                                    if (pendingLDC == null) {\n-                                                        throw new AssertionError(\"No load \" +\n-                                                            \"instruction found for field \" + field +\n-                                                            \" in static initializer of \" +\n-                                                            VERSION_PROPS_CLASS);\n-                                                    }\n-                                                    \/\/ forget about it\n-                                                    pendingLDC = null;\n-                                                    \/\/ and add an ldc for the new value\n-                                                    cob.constantInstruction(value);\n-                                                    redefined = true;\n-                                                } else {\n-                                                    flushPendingLDC(cob);\n-                                                }\n-                                                cob.accept(coe);\n-                                            }\n-                                            default -> cob.accept(coe);\n+                    @Override\n+                    public void accept(CodeBuilder cob, CodeElement coe) {\n+                        if (coe instanceof Instruction ins) {\n+                            switch (ins.opcode()) {\n+                                case LDC, LDC_W, LDC2_W -> {\n+                                    flushPendingLDC(cob);\n+                                    pendingLDC = coe;\n+                                }\n+                                case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE -> {\n+                                    flushPendingLDC(cob);\n+                                    cob.accept(coe);\n+                                }\n+                                case GETSTATIC, GETFIELD, PUTFIELD -> {\n+                                    flushPendingLDC(cob);\n+                                    cob.accept(coe);\n+                                }\n+                                case PUTSTATIC -> {\n+                                    if (((FieldInstruction)coe).name().equalsString(field)) {\n+                                        \/\/ assert that there is a pending ldc\n+                                        \/\/ for the old value\n+                                        if (pendingLDC == null) {\n+                                            throw new AssertionError(\"No load \" +\n+                                                \"instruction found for field \" + field +\n+                                                \" in static initializer of \" +\n+                                                VERSION_PROPS_CLASS);\n@@ -155,0 +140,7 @@\n+                                        \/\/ forget about it\n+                                        pendingLDC = null;\n+                                        \/\/ and add an ldc for the new value\n+                                        cob.constantInstruction(value);\n+                                        redefined = true;\n+                                    } else {\n+                                        flushPendingLDC(cob);\n@@ -156,1 +148,3 @@\n-                                });\n+                                    cob.accept(coe);\n+                                }\n+                                default -> cob.accept(coe);\n@@ -158,3 +152,5 @@\n-                        });\n-                }\n-        });\n+                        } else {\n+                            cob.accept(coe);\n+                        }\n+                    }\n+                }));\n@@ -177,1 +173,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":52,"deletions":57,"binary":false,"changes":109,"status":"modified"}]}