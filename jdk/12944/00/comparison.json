{"files":[{"patch":"@@ -193,0 +193,8 @@\n+    exports jdk.internal.classfile to\n+        jdk.jlink;\n+    exports jdk.internal.classfile.attribute to\n+        jdk.jlink;\n+    exports jdk.internal.classfile.instruction to\n+        jdk.jlink;\n+    exports jdk.internal.classfile.constantpool to\n+        jdk.jlink;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n@@ -87,1 +88,1 @@\n-    ClassReader newClassReader(String path, ResourcePoolEntry resource) {\n+    ClassModel newClassReader(String path, ResourcePoolEntry resource, Classfile.Option... options) {\n@@ -90,1 +91,1 @@\n-            return new ClassReader(content);\n+            return Classfile.parse(content, options);\n@@ -102,1 +103,1 @@\n-    protected ClassReader newClassReader(String path, byte[] buf) {\n+    protected ClassModel newClassReader(String path, byte[] buf, Classfile.Option... options) {\n@@ -104,1 +105,1 @@\n-            return new ClassReader(buf);\n+            return Classfile.parse(buf, options);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AbstractPlugin.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.stream.IntStream;\n@@ -43,1 +42,1 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -161,4 +160,3 @@\n-                    ClassReader cr = newClassReader(path, bytes);\n-                    if (Arrays.stream(cr.getInterfaces())\n-                        .anyMatch(i -> i.contains(METAINFONAME)) &&\n-                        stripUnsupportedLocales(bytes, cr)) {\n+                    if (newClassReader(path, bytes).interfaces().stream()\n+                        .anyMatch(i -> i.asInternalName().contains(METAINFONAME)) &&\n+                        stripUnsupportedLocales(bytes)) {\n@@ -272,15 +270,18 @@\n-    private boolean stripUnsupportedLocales(byte[] bytes, ClassReader cr) {\n-        boolean[] modified = new boolean[1];\n-\n-        IntStream.range(1, cr.getItemCount())\n-            .map(item -> cr.getItem(item))\n-            .forEach(itemIndex -> {\n-                if (bytes[itemIndex - 1] == 1 &&         \/\/ UTF-8\n-                    bytes[itemIndex + 2] == (byte)' ') { \/\/ fast check for leading space\n-                    int length = cr.readUnsignedShort(itemIndex);\n-                    byte[] b = new byte[length];\n-                    System.arraycopy(bytes, itemIndex + 2, b, 0, length);\n-                    if (filterOutUnsupportedTags(b)) {\n-                        \/\/ copy back\n-                        System.arraycopy(b, 0, bytes, itemIndex + 2, length);\n-                        modified[0] = true;\n+    private boolean stripUnsupportedLocales(byte[] bytes) {\n+        boolean modified = false;\n+        \/\/ I haven't found a way how to change content of existing CP entries or get entry offset to the byteocde array using Bytecode lib\n+        \/\/ so scanning CP entries directly\n+        final int cpLength = (bytes[8] << 8) + (int)bytes[9];\n+        int offset = 10;\n+        for (int cpSlot=1; cpSlot<cpLength; cpSlot++) {\n+            switch (bytes[offset]) { \/\/entry tag\n+                case TAG_UTF8 -> {\n+                    final int length = (bytes[offset+1] << 8) + (int)bytes[offset+2];\n+                    if (bytes[offset + 3] == (byte)' ') { \/\/ fast check for leading space\n+                        byte[] b = new byte[length];\n+                        System.arraycopy(bytes, offset + 3, b, 0, length);\n+                        if (filterOutUnsupportedTags(b)) {\n+                            \/\/ copy back\n+                            System.arraycopy(b, 0, bytes, offset + 3, length);\n+                            modified = true;\n+                        }\n@@ -288,0 +289,1 @@\n+                    offset += 3 + length;\n@@ -289,3 +291,19 @@\n-            });\n-\n-        return modified[0];\n+                case TAG_CLASS,\n+                        TAG_STRING,\n+                        TAG_METHODTYPE,\n+                        TAG_MODULE,\n+                        TAG_PACKAGE -> offset += 3;\n+                case TAG_METHODHANDLE -> offset += 4;\n+                case TAG_INTEGER,\n+                        TAG_FLOAT,\n+                        TAG_FIELDREF,\n+                        TAG_METHODREF,\n+                        TAG_INTERFACEMETHODREF,\n+                        TAG_NAMEANDTYPE,\n+                        TAG_CONSTANTDYNAMIC,\n+                        TAG_INVOKEDYNAMIC -> offset += 5;\n+                case TAG_LONG,\n+                        TAG_DOUBLE -> {offset += 9; cpSlot++;} \/\/additional slot for double and long entries\n+            }\n+        }\n+        return modified;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin.java","additions":42,"deletions":24,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n@@ -29,2 +31,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n@@ -62,4 +62,2 @@\n-                        ClassReader reader = newClassReader(path, resource);\n-                        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-                        reader.accept(writer, ClassReader.SKIP_DEBUG);\n-                        byte[] content = writer.toByteArray();\n+                        byte[] content = newClassReader(path, resource, Classfile.Option.processDebug(false))\n+                                                .transform(ClassTransform.ACCEPT_ALL);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -71,7 +75,7 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.CodeBuilder;\n@@ -99,1 +103,1 @@\n-    private static final String SYSTEM_MODULES_MAP_CLASS =\n+    private static final String SYSTEM_MODULES_MAP_CLASSNAME =\n@@ -103,1 +107,2 @@\n-    private static final String ALL_SYSTEM_MODULES_CLASS =\n+\n+    private static final String ALL_SYSTEM_MODULES_CLASSNAME =\n@@ -105,1 +110,1 @@\n-    private static final String DEFAULT_SYSTEM_MODULES_CLASS =\n+    private static final String DEFAULT_SYSTEM_MODULES_CLASSNAME =\n@@ -107,1 +112,4 @@\n-\n+    private static final ClassDesc CD_SYSTEM_MODULES =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/SystemModules\");\n+    private static final ClassDesc CD_SYSTEM_MODULES_MAP =\n+            ClassDesc.ofInternalName(SYSTEM_MODULES_MAP_CLASSNAME);\n@@ -225,1 +233,1 @@\n-                                          ALL_SYSTEM_MODULES_CLASS,\n+                                          ALL_SYSTEM_MODULES_CLASSNAME,\n@@ -235,1 +243,1 @@\n-            defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASS;\n+            defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASSNAME;\n@@ -237,1 +245,1 @@\n-            defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASS;\n+            defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASSNAME;\n@@ -253,1 +261,1 @@\n-                    map.put(moduleName, ALL_SYSTEM_MODULES_CLASS);\n+                    map.put(moduleName, ALL_SYSTEM_MODULES_CLASSNAME);\n@@ -264,2 +272,2 @@\n-        rn = genSystemModulesMapClass(ALL_SYSTEM_MODULES_CLASS,\n-                                      defaultSystemModulesClassName,\n+        rn = genSystemModulesMapClass(ClassDesc.ofInternalName(ALL_SYSTEM_MODULES_CLASSNAME),\n+                                      ClassDesc.ofInternalName(defaultSystemModulesClassName),\n@@ -307,1 +315,1 @@\n-        byte[] bytes = generator.getClassWriter(cf).toByteArray();\n+        byte[] bytes = generator.getClassWriter(cf);\n@@ -419,15 +427,0 @@\n-            Set<String> packages = new HashSet<>();\n-            ClassVisitor cv = new ClassVisitor(Opcodes.ASM7) {\n-                @Override\n-                public ModuleVisitor visitModule(String name,\n-                                                 int flags,\n-                                                 String version) {\n-                    return new ModuleVisitor(Opcodes.ASM7) {\n-                        @Override\n-                        public void visitPackage(String pn) {\n-                            packages.add(pn);\n-                        }\n-                    };\n-                }\n-            };\n-\n@@ -436,3 +429,2 @@\n-                ClassReader cr = new ClassReader(in);\n-                cr.accept(cv, 0);\n-                return packages.size() > 0;\n+                return Classfile.parse(in.readAllBytes()).elementStream()\n+                        .anyMatch(e -> e instanceof ModulePackagesAttribute mpa && !mpa.packages().isEmpty());\n@@ -505,20 +497,16 @@\n-        private static final String MODULE_DESCRIPTOR_BUILDER =\n-            \"jdk\/internal\/module\/Builder\";\n-        private static final String MODULE_DESCRIPTOR_ARRAY_SIGNATURE =\n-            \"[Ljava\/lang\/module\/ModuleDescriptor;\";\n-        private static final String REQUIRES_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\";\n-        private static final String EXPORTS_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\";\n-        private static final String OPENS_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\";\n-        private static final String MODULE_TARGET_CLASSNAME  =\n-            \"jdk\/internal\/module\/ModuleTarget\";\n-        private static final String MODULE_TARGET_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleTarget;\";\n-        private static final String MODULE_HASHES_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleHashes;\";\n-        private static final String MODULE_RESOLUTION_CLASSNAME  =\n-            \"jdk\/internal\/module\/ModuleResolution\";\n-        private static final String MODULE_RESOLUTIONS_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleResolution;\";\n+        private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+        private static final ClassDesc CD_MODULE_BUILDER =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+        private static final ClassDesc CD_REQUIRES_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\");\n+        private static final ClassDesc CD_EXPORTS_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\");\n+        private static final ClassDesc CD_OPENS_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\");\n+        private static final ClassDesc CD_MODULE_TARGET =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleTarget\");\n+        private static final ClassDesc CD_MODULE_HASHES =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleHashes\");\n+        private static final ClassDesc CD_MODULE_RESOLUTION =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleResolution\");\n@@ -534,3 +522,0 @@\n-        \/\/ Method visitor for generating the SystemModules::modules() method\n-        private MethodVisitor mv;\n-\n@@ -538,1 +523,1 @@\n-        private final String className;\n+        private final ClassDesc classDesc;\n@@ -551,1 +536,1 @@\n-            this.className = className;\n+            this.classDesc = ClassDesc.ofInternalName(className);\n@@ -590,12 +575,6 @@\n-        public ClassWriter getClassWriter(Configuration cf) {\n-            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                             + ClassWriter.COMPUTE_FRAMES);\n-            cw.visit(Opcodes.V1_8,\n-                     ACC_FINAL+ACC_SUPER,\n-                     className,\n-                     null,\n-                     \"java\/lang\/Object\",\n-                     new String[] { \"jdk\/internal\/module\/SystemModules\" });\n-\n-            \/\/ generate <init>\n-            genConstructor(cw);\n+        public byte[] getClassWriter(Configuration cf) {\n+            return Classfile.build(classDesc,\n+                    clb -> {\n+                        clb.withFlags(ACC_FINAL + ACC_SUPER);\n+                        clb.withInterfaceSymbols(List.of(CD_SYSTEM_MODULES));\n+                        clb.withVersion(52, 0);\n@@ -603,2 +582,2 @@\n-            \/\/ generate hasSplitPackages\n-            genHasSplitPackages(cw);\n+                        \/\/ generate <init>\n+                        genConstructor(clb);\n@@ -606,2 +585,2 @@\n-            \/\/ generate hasIncubatorModules\n-            genIncubatorModules(cw);\n+                        \/\/ generate hasSplitPackages\n+                        genHasSplitPackages(clb);\n@@ -609,2 +588,2 @@\n-            \/\/ generate moduleDescriptors\n-            genModuleDescriptorsMethod(cw);\n+                        \/\/ generate hasIncubatorModules\n+                        genIncubatorModules(clb);\n@@ -612,2 +591,2 @@\n-            \/\/ generate moduleTargets\n-            genModuleTargetsMethod(cw);\n+                        \/\/ generate moduleDescriptors\n+                        genModuleDescriptorsMethod(clb);\n@@ -615,2 +594,2 @@\n-            \/\/ generate moduleHashes\n-            genModuleHashesMethod(cw);\n+                        \/\/ generate moduleTargets\n+                        genModuleTargetsMethod(clb);\n@@ -618,2 +597,2 @@\n-            \/\/ generate moduleResolutions\n-            genModuleResolutionsMethod(cw);\n+                        \/\/ generate moduleHashes\n+                        genModuleHashesMethod(clb);\n@@ -621,2 +600,2 @@\n-            \/\/ generate moduleReads\n-            genModuleReads(cw, cf);\n+                        \/\/ generate moduleResolutions\n+                        genModuleResolutionsMethod(clb);\n@@ -624,1 +603,3 @@\n-            return cw;\n+                        \/\/ generate moduleReads\n+                        genModuleReads(clb, cf);\n+                    });\n@@ -630,11 +611,11 @@\n-        private void genConstructor(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL,\n-                               \"java\/lang\/Object\",\n-                               \"<init>\",\n-                               \"()V\",\n-                               false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        private void genConstructor(ClassBuilder clb) {\n+            clb.withMethod(\"<init>\", MethodTypeDesc.of(CD_void),\n+                    ACC_PUBLIC, mb -> mb.withFlags(ACC_PUBLIC).withCode( cob -> {\n+                        cob.loadInstruction(TypeKind.ReferenceType, 0);\n+                        cob.invokeInstruction(Opcode.INVOKESPECIAL,\n+                                              CD_Object,\n+                                              \"<init>\",\n+                                               MethodTypeDesc.of(CD_void),\n+                                               false);\n+                        cob.returnInstruction(TypeKind.VoidType);\n+                    }));\n@@ -646,1 +627,1 @@\n-        private void genHasSplitPackages(ClassWriter cw) {\n+        private void genHasSplitPackages(ClassBuilder clb) {\n@@ -653,14 +634,7 @@\n-            mv = cw.visitMethod(ACC_PUBLIC,\n-                                \"hasSplitPackages\",\n-                                \"()Z\",\n-                                \"()Z\",\n-                                null);\n-            mv.visitCode();\n-            if (hasSplitPackages) {\n-                mv.visitInsn(ICONST_1);\n-            } else {\n-                mv.visitInsn(ICONST_0);\n-            }\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethod(\"hasSplitPackages\",\n+                    MethodTypeDesc.of(CD_boolean),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                        cob.constantInstruction(hasSplitPackages ? 1 : 0);\n+                        cob.returnInstruction(TypeKind.IntType);\n+                    }));\n@@ -672,1 +646,1 @@\n-        private void genIncubatorModules(ClassWriter cw) {\n+        private void genIncubatorModules(ClassBuilder clb) {\n@@ -679,14 +653,7 @@\n-            mv = cw.visitMethod(ACC_PUBLIC,\n-                                \"hasIncubatorModules\",\n-                                \"()Z\",\n-                                \"()Z\",\n-                                null);\n-            mv.visitCode();\n-            if (hasIncubatorModules) {\n-                mv.visitInsn(ICONST_1);\n-            } else {\n-                mv.visitInsn(ICONST_0);\n-            }\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethod(\"hasIncubatorModules\",\n+                    MethodTypeDesc.of(CD_boolean),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                        cob.constantInstruction(hasIncubatorModules ? 1 : 0);\n+                        cob.returnInstruction(TypeKind.IntType);\n+                    }));\n@@ -698,21 +665,19 @@\n-        private void genModuleDescriptorsMethod(ClassWriter cw) {\n-            this.mv = cw.visitMethod(ACC_PUBLIC,\n-                                     \"moduleDescriptors\",\n-                                     \"()\" + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,\n-                                     \"()\" + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,\n-                                     null);\n-            mv.visitCode();\n-            pushInt(mv, moduleInfos.size());\n-            mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor\");\n-            mv.visitVarInsn(ASTORE, MD_VAR);\n-\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                new ModuleDescriptorBuilder(minfo.descriptor(),\n-                                            minfo.packages(),\n-                                            index).build();\n-            }\n-            mv.visitVarInsn(ALOAD, MD_VAR);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        private void genModuleDescriptorsMethod(ClassBuilder clb) {\n+            clb.withMethod(\"moduleDescriptors\",\n+                    MethodTypeDesc.of(CD_MODULE_DESCRIPTOR.arrayType()),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                        cob.constantInstruction(moduleInfos.size());\n+                        cob.anewarray(CD_MODULE_DESCRIPTOR);\n+                        cob.storeInstruction(TypeKind.ReferenceType, MD_VAR);\n+\n+                        for (int index = 0; index < moduleInfos.size(); index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            new ModuleDescriptorBuilder(cob,\n+                                                        minfo.descriptor(),\n+                                                        minfo.packages(),\n+                                                        index).build();\n+                        }\n+                        cob.loadInstruction(TypeKind.ReferenceType, MD_VAR);\n+                        cob.returnInstruction(TypeKind.ReferenceType);\n+                    }));\n@@ -724,39 +689,23 @@\n-        private void genModuleTargetsMethod(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,\n-                                              \"moduleTargets\",\n-                                              \"()\" + MODULE_TARGET_ARRAY_SIGNATURE,\n-                                              \"()\" + MODULE_TARGET_ARRAY_SIGNATURE,\n-                                              null);\n-            mv.visitCode();\n-            pushInt(mv, moduleInfos.size());\n-            mv.visitTypeInsn(ANEWARRAY, MODULE_TARGET_CLASSNAME);\n-            mv.visitVarInsn(ASTORE, MT_VAR);\n-\n-\n-            \/\/ if java.base has a ModuleTarget attribute then generate the array\n-            \/\/ with one element, all other elements will be null.\n-\n-            ModuleInfo base = moduleInfos.get(0);\n-            if (!base.moduleName().equals(\"java.base\"))\n-                throw new InternalError(\"java.base should be first module in list\");\n-            ModuleTarget target = base.target();\n-\n-            int count;\n-            if (target != null && target.targetPlatform() != null) {\n-                count = 1;\n-            } else {\n-                count = moduleInfos.size();\n-            }\n-\n-            for (int index = 0; index < count; index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.target() != null) {\n-                    mv.visitVarInsn(ALOAD, MT_VAR);\n-                    pushInt(mv, index);\n-\n-                    \/\/ new ModuleTarget(String)\n-                    mv.visitTypeInsn(NEW, MODULE_TARGET_CLASSNAME);\n-                    mv.visitInsn(DUP);\n-                    mv.visitLdcInsn(minfo.target().targetPlatform());\n-                    mv.visitMethodInsn(INVOKESPECIAL, MODULE_TARGET_CLASSNAME,\n-                                       \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        private void genModuleTargetsMethod(ClassBuilder clb) {\n+            clb.withMethod(\"moduleTargets\",\n+                    MethodTypeDesc.of(CD_MODULE_TARGET.arrayType()),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                        cob.constantInstruction(moduleInfos.size());\n+                        cob.anewarray(CD_MODULE_TARGET);\n+                        cob.storeInstruction(TypeKind.ReferenceType, MT_VAR);\n+\n+                        \/\/ if java.base has a ModuleTarget attribute then generate the array\n+                        \/\/ with one element, all other elements will be null.\n+\n+                        ModuleInfo base = moduleInfos.get(0);\n+                        if (!base.moduleName().equals(\"java.base\"))\n+                            throw new InternalError(\"java.base should be first module in list\");\n+                        ModuleTarget target = base.target();\n+\n+                        int count;\n+                        if (target != null && target.targetPlatform() != null) {\n+                            count = 1;\n+                        } else {\n+                            count = moduleInfos.size();\n+                        }\n@@ -764,3 +713,16 @@\n-                    mv.visitInsn(AASTORE);\n-                }\n-            }\n+                        for (int index = 0; index < count; index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            if (minfo.target() != null) {\n+                                cob.loadInstruction(TypeKind.ReferenceType, MT_VAR);\n+                                cob.constantInstruction(index);\n+\n+                                \/\/ new ModuleTarget(String)\n+                                cob.newObjectInstruction(CD_MODULE_TARGET);\n+                                cob.stackInstruction(Opcode.DUP);\n+                                cob.constantInstruction(minfo.target().targetPlatform());\n+                                cob.invokeInstruction(Opcode.INVOKESPECIAL, CD_MODULE_TARGET,\n+                                                   \"<init>\", MethodTypeDesc.of(CD_void, CD_String), false);\n+\n+                                cob.arrayStoreInstruction(TypeKind.ReferenceType);\n+                            }\n+                        }\n@@ -768,4 +730,3 @@\n-            mv.visitVarInsn(ALOAD, MT_VAR);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+                        cob.loadInstruction(TypeKind.ReferenceType, MT_VAR);\n+                        cob.returnInstruction(TypeKind.ReferenceType);\n+                    }));\n@@ -777,20 +738,17 @@\n-        private void genModuleHashesMethod(ClassWriter cw) {\n-            MethodVisitor hmv =\n-                cw.visitMethod(ACC_PUBLIC,\n-                               \"moduleHashes\",\n-                               \"()\" + MODULE_HASHES_ARRAY_SIGNATURE,\n-                               \"()\" + MODULE_HASHES_ARRAY_SIGNATURE,\n-                               null);\n-            hmv.visitCode();\n-            pushInt(hmv, moduleInfos.size());\n-            hmv.visitTypeInsn(ANEWARRAY, \"jdk\/internal\/module\/ModuleHashes\");\n-            hmv.visitVarInsn(ASTORE, MH_VAR);\n-\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.recordedHashes() != null) {\n-                    new ModuleHashesBuilder(minfo.recordedHashes(),\n-                                            index,\n-                                            hmv).build();\n-                }\n-            }\n+        private void genModuleHashesMethod(ClassBuilder clb) {\n+            clb.withMethod(\"moduleHashes\",\n+                    MethodTypeDesc.of(CD_MODULE_HASHES.arrayType()),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                        cob.constantInstruction(moduleInfos.size());\n+                        cob.anewarray(CD_MODULE_HASHES);\n+                        cob.storeInstruction(TypeKind.ReferenceType, MH_VAR);\n+\n+                        for (int index = 0; index < moduleInfos.size(); index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            if (minfo.recordedHashes() != null) {\n+                                new ModuleHashesBuilder(minfo.recordedHashes(),\n+                                                        index,\n+                                                        cob).build();\n+                            }\n+                        }\n@@ -798,4 +756,3 @@\n-            hmv.visitVarInsn(ALOAD, MH_VAR);\n-            hmv.visitInsn(ARETURN);\n-            hmv.visitMaxs(0, 0);\n-            hmv.visitEnd();\n+                        cob.loadInstruction(TypeKind.ReferenceType, MH_VAR);\n+                        cob.returnInstruction(TypeKind.ReferenceType);\n+                    }));\n@@ -807,31 +764,27 @@\n-        private void genModuleResolutionsMethod(ClassWriter cw) {\n-            MethodVisitor mresmv =\n-                cw.visitMethod(ACC_PUBLIC,\n-                               \"moduleResolutions\",\n-                               \"()\" + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,\n-                               \"()\" + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,\n-                               null);\n-            mresmv.visitCode();\n-            pushInt(mresmv, moduleInfos.size());\n-            mresmv.visitTypeInsn(ANEWARRAY, MODULE_RESOLUTION_CLASSNAME);\n-            mresmv.visitVarInsn(ASTORE, 0);\n-\n-            for (int index=0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.moduleResolution() != null) {\n-                    mresmv.visitVarInsn(ALOAD, 0);\n-                    pushInt(mresmv, index);\n-                    mresmv.visitTypeInsn(NEW, MODULE_RESOLUTION_CLASSNAME);\n-                    mresmv.visitInsn(DUP);\n-                    mresmv.visitLdcInsn(minfo.moduleResolution().value());\n-                    mresmv.visitMethodInsn(INVOKESPECIAL,\n-                                           MODULE_RESOLUTION_CLASSNAME,\n-                                           \"<init>\",\n-                                           \"(I)V\", false);\n-                    mresmv.visitInsn(AASTORE);\n-                }\n-            }\n-            mresmv.visitVarInsn(ALOAD, 0);\n-            mresmv.visitInsn(ARETURN);\n-            mresmv.visitMaxs(0, 0);\n-            mresmv.visitEnd();\n+        private void genModuleResolutionsMethod(ClassBuilder clb) {\n+            clb.withMethod(\"moduleResolutions\",\n+                MethodTypeDesc.of(CD_MODULE_RESOLUTION.arrayType()),\n+                ACC_PUBLIC,\n+                mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+                    cob.constantInstruction(moduleInfos.size());\n+                    cob.anewarray(CD_MODULE_RESOLUTION);\n+                    cob.storeInstruction(TypeKind.ReferenceType, 0);\n+\n+                    for (int index=0; index < moduleInfos.size(); index++) {\n+                        ModuleInfo minfo = moduleInfos.get(index);\n+                        if (minfo.moduleResolution() != null) {\n+                            cob.loadInstruction(TypeKind.ReferenceType, 0);\n+                            cob.constantInstruction(index);\n+                            cob.newObjectInstruction(CD_MODULE_RESOLUTION);\n+                            cob.stackInstruction(Opcode.DUP);\n+                            cob.constantInstruction(minfo.moduleResolution().value());\n+                            cob.invokeInstruction(Opcode.INVOKESPECIAL,\n+                                                  CD_MODULE_RESOLUTION,\n+                                                  \"<init>\",\n+                                                  MethodTypeDesc.of(CD_void, CD_int), false);\n+                            cob.arrayStoreInstruction(TypeKind.ReferenceType);\n+                        }\n+                    }\n+                    cob.loadInstruction(TypeKind.ReferenceType, 0);\n+                    cob.returnInstruction(TypeKind.ReferenceType);\n+                }));\n@@ -843,1 +796,1 @@\n-        private void genModuleReads(ClassWriter cw, Configuration cf) {\n+        private void genModuleReads(ClassBuilder clb, Configuration cf) {\n@@ -851,1 +804,1 @@\n-            generate(cw, \"moduleReads\", map, true);\n+            generate(clb, \"moduleReads\", map, true);\n@@ -859,1 +812,1 @@\n-        private void generate(ClassWriter cw,\n+        private void generate(ClassBuilder clb,\n@@ -863,51 +816,28 @@\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,\n-                                              methodName,\n-                                              \"()Ljava\/util\/Map;\",\n-                                              \"()Ljava\/util\/Map;\",\n-                                              null);\n-            mv.visitCode();\n-\n-            \/\/ map of Set -> local\n-            Map<Set<String>, Integer> locals;\n-\n-            \/\/ generate code to create the sets that are duplicated\n-            if (dedup) {\n-                Collection<Set<String>> values = map.values();\n-                Set<Set<String>> duplicateSets = values.stream()\n-                        .distinct()\n-                        .filter(s -> Collections.frequency(values, s) > 1)\n-                        .collect(Collectors.toSet());\n-                locals = new HashMap<>();\n-                int index = 1;\n-                for (Set<String> s : duplicateSets) {\n-                    genImmutableSet(mv, s);\n-                    mv.visitVarInsn(ASTORE, index);\n-                    locals.put(s, index);\n-                    if (++index >= MAX_LOCAL_VARS) {\n-                        break;\n-                    }\n-                }\n-            } else {\n-                locals = Map.of();\n-            }\n-\n-            \/\/ new Map$Entry[size]\n-            pushInt(mv, map.size());\n-            mv.visitTypeInsn(ANEWARRAY, \"java\/util\/Map$Entry\");\n-\n-            int index = 0;\n-            for (var e : new TreeMap<>(map).entrySet()) {\n-                String name = e.getKey();\n-                Set<String> s = e.getValue();\n-\n-                mv.visitInsn(DUP);\n-                pushInt(mv, index);\n-                mv.visitLdcInsn(name);\n-\n-                \/\/ if de-duplicated then load the local, otherwise generate code\n-                Integer varIndex = locals.get(s);\n-                if (varIndex == null) {\n-                    genImmutableSet(mv, s);\n-                } else {\n-                    mv.visitVarInsn(ALOAD, varIndex);\n-                }\n+            clb.withMethod(methodName,\n+                    MethodTypeDesc.of(CD_Map),\n+                    ACC_PUBLIC,\n+                    mb -> mb.withFlags(ACC_PUBLIC).withCode(cob -> {\n+\n+                        \/\/ map of Set -> local\n+                        Map<Set<String>, Integer> locals;\n+\n+                        \/\/ generate code to create the sets that are duplicated\n+                        if (dedup) {\n+                            Collection<Set<String>> values = map.values();\n+                            Set<Set<String>> duplicateSets = values.stream()\n+                                    .distinct()\n+                                    .filter(s -> Collections.frequency(values, s) > 1)\n+                                    .collect(Collectors.toSet());\n+                            locals = new HashMap<>();\n+                            int index = 1;\n+                            for (Set<String> s : duplicateSets) {\n+                                genImmutableSet(cob, s);\n+                                cob.storeInstruction(TypeKind.ReferenceType, index);\n+                                locals.put(s, index);\n+                                if (++index >= MAX_LOCAL_VARS) {\n+                                    break;\n+                                }\n+                            }\n+                        } else {\n+                            locals = Map.of();\n+                        }\n@@ -915,9 +845,30 @@\n-                String desc = \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\";\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                                   \"java\/util\/Map\",\n-                                   \"entry\",\n-                                   desc,\n-                                   true);\n-                mv.visitInsn(AASTORE);\n-                index++;\n-            }\n+                        \/\/ new Map$Entry[size]\n+                        cob.constantInstruction(map.size());\n+                        cob.anewarray(ClassDesc.ofInternalName(\"java\/util\/Map$Entry\"));\n+\n+                        int index = 0;\n+                        for (var e : new TreeMap<>(map).entrySet()) {\n+                            String name = e.getKey();\n+                            Set<String> s = e.getValue();\n+\n+                            cob.stackInstruction(Opcode.DUP);\n+                            cob.constantInstruction(index);\n+                            cob.constantInstruction(name);\n+\n+                            \/\/ if de-duplicated then load the local, otherwise generate code\n+                            Integer varIndex = locals.get(s);\n+                            if (varIndex == null) {\n+                                genImmutableSet(cob, s);\n+                            } else {\n+                                cob.loadInstruction(TypeKind.ReferenceType, varIndex);\n+                            }\n+\n+                            MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\");\n+                            cob.invokeInstruction(Opcode.INVOKESTATIC,\n+                                               CD_Map,\n+                                               \"entry\",\n+                                               desc,\n+                                               true);\n+                            cob.arrayStoreInstruction(TypeKind.ReferenceType);\n+                            index++;\n+                        }\n@@ -925,6 +876,5 @@\n-            \/\/ invoke Map.ofEntries(Map$Entry[])\n-            mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Map\", \"ofEntries\",\n-                    \"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\", true);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+                        \/\/ invoke Map.ofEntries(Map$Entry[])\n+                        cob.invokeInstruction(Opcode.INVOKESTATIC, CD_Map, \"ofEntries\",\n+                                MethodTypeDesc.ofDescriptor(\"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\"), true);\n+                        cob.returnInstruction(TypeKind.ReferenceType);\n+                    }));\n@@ -936,1 +886,1 @@\n-        private void genImmutableSet(MethodVisitor mv, Set<String> set) {\n+        private void genImmutableSet(CodeBuilder cob, Set<String> set) {\n@@ -942,2 +892,2 @@\n-                pushInt(mv, size);\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                cob.constantInstruction(size);\n+                cob.anewarray(CD_String);\n@@ -946,4 +896,4 @@\n-                    mv.visitInsn(DUP);\n-                    pushInt(mv, i);\n-                    mv.visitLdcInsn(element);\n-                    mv.visitInsn(AASTORE);\n+                    cob.stackInstruction(Opcode.DUP);\n+                    cob.constantInstruction(i);\n+                    cob.constantInstruction(element);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -952,2 +902,2 @@\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                        \"java\/util\/Set\",\n+                cob.invokeInstruction(Opcode.INVOKESTATIC,\n+                        CD_Set,\n@@ -955,1 +905,1 @@\n-                        \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\",\n+                        MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"),\n@@ -960,1 +910,1 @@\n-                    mv.visitLdcInsn(element);\n+                    cob.constantInstruction(element);\n@@ -964,2 +914,2 @@\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                        \"java\/util\/Set\",\n+                cob.invokeInstruction(Opcode.INVOKESTATIC,\n+                        CD_Set,\n@@ -967,1 +917,1 @@\n-                        sb.toString(),\n+                        MethodTypeDesc.ofDescriptor(sb.toString()),\n@@ -973,9 +923,8 @@\n-            static final String BUILDER_TYPE = \"Ljdk\/internal\/module\/Builder;\";\n-            static final String EXPORTS_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Exports;\";\n-            static final String OPENS_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Opens;\";\n-            static final String PROVIDES_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Provides;\";\n-            static final String REQUIRES_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Requires;\";\n+            static final ClassDesc CD_EXPORTS =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+            static final ClassDesc CD_OPENS =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+            static final ClassDesc CD_PROVIDES =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+            static final ClassDesc CD_REQUIRES =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n@@ -985,16 +934,14 @@\n-            static final String EXPORTS_MODIFIER_SET_STRING_SET_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/util\/Set;)\"\n-                    + EXPORTS_TYPE;\n-            static final String EXPORTS_MODIFIER_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + EXPORTS_TYPE;\n-            static final String OPENS_MODIFIER_SET_STRING_SET_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/util\/Set;)\"\n-                    + OPENS_TYPE;\n-            static final String OPENS_MODIFIER_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + OPENS_TYPE;\n-            static final String PROVIDES_STRING_LIST_SIG =\n-                \"(Ljava\/lang\/String;Ljava\/util\/List;)\" + PROVIDES_TYPE;\n-            static final String REQUIRES_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + REQUIRES_TYPE;\n-            static final String REQUIRES_SET_STRING_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/lang\/String;)\" + REQUIRES_TYPE;\n+            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+                MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+            static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n@@ -1004,12 +951,13 @@\n-            static final String EXPORTS_ARRAY_SIG =\n-                \"([\" + EXPORTS_TYPE + \")\" + BUILDER_TYPE;\n-            static final String OPENS_ARRAY_SIG =\n-                \"([\" + OPENS_TYPE + \")\" + BUILDER_TYPE;\n-            static final String PROVIDES_ARRAY_SIG =\n-                \"([\" + PROVIDES_TYPE + \")\" + BUILDER_TYPE;\n-            static final String REQUIRES_ARRAY_SIG =\n-                \"([\" + REQUIRES_TYPE + \")\" + BUILDER_TYPE;\n-            static final String SET_SIG = \"(Ljava\/util\/Set;)\" + BUILDER_TYPE;\n-            static final String STRING_SIG = \"(Ljava\/lang\/String;)\" + BUILDER_TYPE;\n-            static final String BOOLEAN_SIG = \"(Z)\" + BUILDER_TYPE;\n-\n+            static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+            static final MethodTypeDesc MTD_OPENS_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+            static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+            static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+            static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+            static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+            static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+\n+            final CodeBuilder cob;\n@@ -1020,1 +968,1 @@\n-            ModuleDescriptorBuilder(ModuleDescriptor md, Set<String> packages, int index) {\n+            ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n@@ -1024,0 +972,1 @@\n+                this.cob = cob;\n@@ -1061,7 +1010,7 @@\n-                mv.visitTypeInsn(NEW, MODULE_DESCRIPTOR_BUILDER);\n-                mv.visitInsn(DUP);\n-                mv.visitLdcInsn(md.name());\n-                mv.visitMethodInsn(INVOKESPECIAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-                mv.visitVarInsn(ASTORE, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n+                cob.newObjectInstruction(CD_MODULE_BUILDER);\n+                cob.stackInstruction(Opcode.DUP);\n+                cob.constantInstruction(md.name());\n+                cob.invokeInstruction(Opcode.INVOKESPECIAL, CD_MODULE_BUILDER,\n+                    \"<init>\", MethodTypeDesc.of(CD_void, CD_String), false);\n+                cob.storeInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n@@ -1084,9 +1033,5 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                if (value) {\n-                    mv.visitInsn(ICONST_1);\n-                } else {\n-                    mv.visitInsn(ICONST_0);\n-                }\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    methodName, BOOLEAN_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(value ? 1 : 0);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    methodName, MTD_BOOLEAN, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1099,6 +1044,6 @@\n-                mv.visitVarInsn(ALOAD, MD_VAR);\n-                pushInt(mv, index);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(md.hashCode());\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"build\", \"(I)Ljava\/lang\/module\/ModuleDescriptor;\",\n+                cob.loadInstruction(TypeKind.ReferenceType, MD_VAR);\n+                cob.constantInstruction(index);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(md.hashCode());\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"build\", MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int),\n@@ -1106,1 +1051,1 @@\n-                mv.visitInsn(AASTORE);\n+                cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1116,3 +1061,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, requires.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Requires\");\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(requires.size());\n+                cob.anewarray(CD_REQUIRES);\n@@ -1126,2 +1071,2 @@\n-                    mv.visitInsn(DUP);               \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.stackInstruction(Opcode.DUP);               \/\/ arrayref\n+                    cob.constantInstruction(arrayIndex++);\n@@ -1129,1 +1074,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1131,2 +1076,2 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"requires\", REQUIRES_ARRAY_SIG, false);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"requires\", MTD_REQUIRES_ARRAY, false);\n@@ -1142,3 +1087,3 @@\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(mods);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitLdcInsn(name);\n+                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n+                cob.loadInstruction(TypeKind.ReferenceType, varIndex);\n+                cob.constantInstruction(name);\n@@ -1146,3 +1091,3 @@\n-                    mv.visitLdcInsn(compiledVersion);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newRequires\", REQUIRES_SET_STRING_STRING_SIG, false);\n+                    cob.constantInstruction(compiledVersion);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newRequires\", MTD_REQUIRES_SET_STRING_STRING, false);\n@@ -1150,2 +1095,2 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newRequires\", REQUIRES_SET_STRING_SIG, false);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newRequires\", MTD_REQUIRES_SET_STRING, false);\n@@ -1162,3 +1107,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, exports.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Exports\");\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(exports.size());\n+                cob.anewarray(CD_EXPORTS);\n@@ -1167,2 +1112,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.stackInstruction(Opcode.DUP);    \/\/ arrayref\n+                    cob.constantInstruction(arrayIndex++);\n@@ -1170,1 +1115,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1172,2 +1117,2 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"exports\", EXPORTS_ARRAY_SIG, false);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"exports\", MTD_EXPORTS_ARRAY, false);\n@@ -1192,1 +1137,1 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(ms);\n+                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n@@ -1194,6 +1139,6 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitVarInsn(ALOAD, stringSetIndex);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newExports\", EXPORTS_MODIFIER_SET_STRING_SET_SIG, false);\n+                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n+                    cob.loadInstruction(TypeKind.ReferenceType, modifiersSetIndex);\n+                    cob.constantInstruction(pn);\n+                    cob.loadInstruction(TypeKind.ReferenceType, stringSetIndex);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newExports\", MTD_EXPORTS_MODIFIER_SET_STRING_SET, false);\n@@ -1201,4 +1146,4 @@\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newExports\", EXPORTS_MODIFIER_SET_STRING_SIG, false);\n+                    cob.loadInstruction(TypeKind.ReferenceType, modifiersSetIndex);\n+                    cob.constantInstruction(pn);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newExports\", MTD_EXPORTS_MODIFIER_SET_STRING, false);\n@@ -1215,3 +1160,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, opens.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Opens\");\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(opens.size());\n+                cob.anewarray(CD_OPENS);\n@@ -1220,2 +1165,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.stackInstruction(Opcode.DUP);    \/\/ arrayref\n+                    cob.constantInstruction(arrayIndex++);\n@@ -1223,1 +1168,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1225,2 +1170,2 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"opens\", OPENS_ARRAY_SIG, false);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"opens\", MTD_OPENS_ARRAY, false);\n@@ -1245,1 +1190,1 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(ms);\n+                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n@@ -1247,6 +1192,6 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitVarInsn(ALOAD, stringSetIndex);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newOpens\", OPENS_MODIFIER_SET_STRING_SET_SIG, false);\n+                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n+                    cob.loadInstruction(TypeKind.ReferenceType, modifiersSetIndex);\n+                    cob.constantInstruction(pn);\n+                    cob.loadInstruction(TypeKind.ReferenceType, stringSetIndex);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newOpens\", MTD_OPENS_MODIFIER_SET_STRING_SET, false);\n@@ -1254,4 +1199,4 @@\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newOpens\", OPENS_MODIFIER_SET_STRING_SIG, false);\n+                    cob.loadInstruction(TypeKind.ReferenceType, modifiersSetIndex);\n+                    cob.constantInstruction(pn);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                        \"newOpens\", MTD_OPENS_MODIFIER_SET_STRING, false);\n@@ -1265,6 +1210,6 @@\n-                int varIndex = dedupSetBuilder.indexOfStringSet(uses);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"uses\", SET_SIG, false);\n-                mv.visitInsn(POP);\n+                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.loadInstruction(TypeKind.ReferenceType, varIndex);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"uses\", MTD_SET, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1280,3 +1225,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, provides.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Provides\");\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(provides.size());\n+                cob.anewarray(CD_PROVIDES);\n@@ -1285,2 +1230,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.stackInstruction(Opcode.DUP);    \/\/ arrayref\n+                    cob.constantInstruction(arrayIndex++);\n@@ -1288,1 +1233,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1290,2 +1235,2 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"provides\", PROVIDES_ARRAY_SIG, false);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"provides\", MTD_PROVIDES_ARRAY, false);\n@@ -1304,3 +1249,3 @@\n-                mv.visitLdcInsn(service);\n-                pushInt(mv, providers.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                cob.constantInstruction(service);\n+                cob.constantInstruction(providers.size());\n+                cob.anewarray(CD_String);\n@@ -1309,4 +1254,4 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n-                    mv.visitLdcInsn(provider);\n-                    mv.visitInsn(AASTORE);\n+                    cob.stackInstruction(Opcode.DUP);    \/\/ arrayref\n+                    cob.constantInstruction(arrayIndex++);\n+                    cob.constantInstruction(provider);\n+                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1314,4 +1259,4 @@\n-                mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/List\",\n-                    \"of\", \"([Ljava\/lang\/Object;)Ljava\/util\/List;\", true);\n-                mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                    \"newProvides\", PROVIDES_STRING_LIST_SIG, false);\n+                cob.invokeInstruction(Opcode.INVOKESTATIC, CD_List,\n+                    \"of\", MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/Object;)Ljava\/util\/List;\"), true);\n+                cob.invokeInstruction(Opcode.INVOKESTATIC, CD_MODULE_BUILDER,\n+                    \"newProvides\", MTD_PROVIDES_STRING_LIST, false);\n@@ -1324,6 +1269,6 @@\n-                int varIndex = dedupSetBuilder.newStringSet(packages);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"packages\", SET_SIG, false);\n-                mv.visitInsn(POP);\n+                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.loadInstruction(TypeKind.ReferenceType, varIndex);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"packages\", MTD_SET, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1336,5 +1281,5 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(cn);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"mainClass\", STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(cn);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"mainClass\", MTD_STRING, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1347,5 +1292,5 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(v.toString());\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"version\", STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(v.toString());\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    \"version\", MTD_STRING, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1355,5 +1300,5 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(value);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    methodName, STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(value);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, CD_MODULE_BUILDER,\n+                    methodName, MTD_STRING, false);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1364,6 +1309,4 @@\n-            private static final String MODULE_HASHES_BUILDER =\n-                \"jdk\/internal\/module\/ModuleHashes$Builder\";\n-            private static final String MODULE_HASHES_BUILDER_TYPE =\n-                \"L\" + MODULE_HASHES_BUILDER + \";\";\n-            static final String STRING_BYTE_ARRAY_SIG =\n-                \"(Ljava\/lang\/String;[B)\" + MODULE_HASHES_BUILDER_TYPE;\n+            private static final ClassDesc MODULE_HASHES_BUILDER =\n+                ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleHashes$Builder\");\n+            static final MethodTypeDesc STRING_BYTE_ARRAY_SIG =\n+                MethodTypeDesc.of(MODULE_HASHES_BUILDER, CD_String, CD_byte.arrayType());\n@@ -1372,1 +1315,1 @@\n-            final MethodVisitor hmv;\n+            final CodeBuilder cob;\n@@ -1375,1 +1318,1 @@\n-            ModuleHashesBuilder(ModuleHashes hashes, int index, MethodVisitor hmv) {\n+            ModuleHashesBuilder(ModuleHashes hashes, int index, CodeBuilder cob) {\n@@ -1377,1 +1320,1 @@\n-                this.hmv = hmv;\n+                this.cob = cob;\n@@ -1407,8 +1350,8 @@\n-                hmv.visitTypeInsn(NEW, MODULE_HASHES_BUILDER);\n-                hmv.visitInsn(DUP);\n-                hmv.visitLdcInsn(recordedHashes.algorithm());\n-                pushInt(hmv, ((4 * recordedHashes.names().size()) \/ 3) + 1);\n-                hmv.visitMethodInsn(INVOKESPECIAL, MODULE_HASHES_BUILDER,\n-                    \"<init>\", \"(Ljava\/lang\/String;I)V\", false);\n-                hmv.visitVarInsn(ASTORE, BUILDER_VAR);\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n+                cob.newObjectInstruction(MODULE_HASHES_BUILDER);\n+                cob.stackInstruction(Opcode.DUP);\n+                cob.constantInstruction(recordedHashes.algorithm());\n+                cob.constantInstruction(((4 * recordedHashes.names().size()) \/ 3) + 1);\n+                cob.invokeInstruction(Opcode.INVOKESPECIAL, MODULE_HASHES_BUILDER,\n+                    \"<init>\", MethodTypeDesc.of(CD_void, CD_String, CD_int), false);\n+                cob.storeInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n@@ -1423,5 +1366,5 @@\n-                hmv.visitVarInsn(ALOAD, MH_VAR);\n-                pushInt(hmv, index);\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n-                    \"build\", \"()Ljdk\/internal\/module\/ModuleHashes;\",\n+                cob.loadInstruction(TypeKind.ReferenceType, MH_VAR);\n+                cob.constantInstruction(index);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n+                    \"build\", MethodTypeDesc.of(CD_MODULE_HASHES),\n@@ -1429,1 +1372,1 @@\n-                hmv.visitInsn(AASTORE);\n+                cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1436,2 +1379,2 @@\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                hmv.visitLdcInsn(name);\n+                cob.loadInstruction(TypeKind.ReferenceType, BUILDER_VAR);\n+                cob.constantInstruction(name);\n@@ -1439,2 +1382,2 @@\n-                pushInt(hmv, hash.length);\n-                hmv.visitIntInsn(NEWARRAY, T_BYTE);\n+                cob.constantInstruction(hash.length);\n+                cob.newarray(TypeKind.ByteType);\n@@ -1442,4 +1385,4 @@\n-                    hmv.visitInsn(DUP);              \/\/ arrayref\n-                    pushInt(hmv, i);\n-                    hmv.visitIntInsn(BIPUSH, hash[i]);\n-                    hmv.visitInsn(BASTORE);\n+                    cob.stackInstruction(Opcode.DUP);              \/\/ arrayref\n+                    cob.constantInstruction(i);\n+                    cob.constantInstruction((int)hash[i]);\n+                    cob.arrayStoreInstruction(TypeKind.ByteType);\n@@ -1448,1 +1391,1 @@\n-                hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n+                cob.invokeInstruction(Opcode.INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n@@ -1450,1 +1393,1 @@\n-                hmv.visitInsn(POP);\n+                cob.stackInstruction(Opcode.POP);\n@@ -1457,1 +1400,1 @@\n-        class DedupSetBuilder {\n+        static class DedupSetBuilder {\n@@ -1501,1 +1444,1 @@\n-                                new EnumSetBuilder<>(s, EXPORTS_MODIFIER_CLASSNAME,\n+                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n@@ -1511,1 +1454,1 @@\n-                                new EnumSetBuilder<>(s, OPENS_MODIFIER_CLASSNAME,\n+                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n@@ -1521,1 +1464,1 @@\n-                    new EnumSetBuilder<>(s, REQUIRES_MODIFIER_CLASSNAME,\n+                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n@@ -1530,2 +1473,2 @@\n-            int indexOfStringSet(Set<String> names) {\n-                return stringSets.get(names).build();\n+            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n+                return stringSets.get(names).build(cob);\n@@ -1538,2 +1481,2 @@\n-            int indexOfExportsModifiers(Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build();\n+            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                return exportsModifiersSets.get(mods).build(cob);\n@@ -1546,2 +1489,2 @@\n-            int indexOfOpensModifiers(Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build();\n+            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                return opensModifiersSets.get(mods).build(cob);\n@@ -1555,2 +1498,2 @@\n-            int indexOfRequiresModifiers(Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build();\n+            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                return requiresModifiersSets.get(mods).build(cob);\n@@ -1562,2 +1505,2 @@\n-            int newStringSet(Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build();\n+            int newStringSet(CodeBuilder cob, Set<String> names) {\n+                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n@@ -1576,1 +1519,1 @@\n-        class SetBuilder<T extends Comparable<T>> {\n+        static class SetBuilder<T extends Comparable<T>> {\n@@ -1602,2 +1545,2 @@\n-            void visitElement(T element, MethodVisitor mv) {\n-                mv.visitLdcInsn(element);\n+            void visitElement(T element, CodeBuilder cob) {\n+                cob.constantInstruction((ConstantDesc)element);\n@@ -1613,1 +1556,1 @@\n-            final int build() {\n+            final int build(CodeBuilder cob) {\n@@ -1627,1 +1570,1 @@\n-                    generateSetOf(index);\n+                    generateSetOf(cob, index);\n@@ -1632,1 +1575,1 @@\n-            private void generateSetOf(int index) {\n+            private void generateSetOf(CodeBuilder cob, int index) {\n@@ -1638,1 +1581,1 @@\n-                        visitElement(t, mv);\n+                        visitElement(t, cob);\n@@ -1641,2 +1584,2 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Set\",\n-                            \"of\", sb.toString(), true);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_Set,\n+                            \"of\", MethodTypeDesc.ofDescriptor(sb.toString()), true);\n@@ -1645,2 +1588,2 @@\n-                    pushInt(mv, elements.size());\n-                    mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                    cob.constantInstruction(elements.size());\n+                    cob.anewarray(CD_String);\n@@ -1649,4 +1592,4 @@\n-                        mv.visitInsn(DUP);    \/\/ arrayref\n-                        pushInt(mv, arrayIndex);\n-                        visitElement(t, mv);  \/\/ value\n-                        mv.visitInsn(AASTORE);\n+                        cob.stackInstruction(Opcode.DUP);    \/\/ arrayref\n+                        cob.constantInstruction(arrayIndex);\n+                        visitElement(t, cob);  \/\/ value\n+                        cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -1655,2 +1598,2 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Set\",\n-                            \"of\", \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\", true);\n+                    cob.invokeInstruction(Opcode.INVOKESTATIC, CD_Set,\n+                            \"of\", MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"), true);\n@@ -1658,1 +1601,1 @@\n-                mv.visitVarInsn(ASTORE, index);\n+                cob.storeInstruction(TypeKind.ReferenceType, index);\n@@ -1666,1 +1609,2 @@\n-        class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n+        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n+            private final ClassDesc classDesc;\n@@ -1668,3 +1612,1 @@\n-            private final String className;\n-\n-            EnumSetBuilder(Set<T> modifiers, String className,\n+            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n@@ -1674,1 +1616,1 @@\n-                this.className = className;\n+                this.classDesc = classDesc;\n@@ -1681,3 +1623,2 @@\n-            void visitElement(T t, MethodVisitor mv) {\n-                mv.visitFieldInsn(GETSTATIC, className, t.toString(),\n-                                  \"L\" + className + \";\");\n+            void visitElement(T t, CodeBuilder cob) {\n+                cob.fieldInstruction(Opcode.GETSTATIC, classDesc, t.toString(), classDesc);\n@@ -1693,2 +1634,2 @@\n-    private String genSystemModulesMapClass(String allSystemModulesClassName,\n-                                            String defaultSystemModulesClassName,\n+    private String genSystemModulesMapClass(ClassDesc allSystemModules,\n+                                            ClassDesc defaultSystemModules,\n@@ -1697,102 +1638,0 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V1_8,\n-                 ACC_FINAL+ACC_SUPER,\n-                 SYSTEM_MODULES_MAP_CLASS,\n-                 null,\n-                 \"java\/lang\/Object\",\n-                 null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           \"java\/lang\/Object\",\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ allSystemModules()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"allSystemModules\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            null);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, allSystemModulesClassName);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           allSystemModulesClassName,\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ defaultSystemModules()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"defaultSystemModules\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            null);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, defaultSystemModulesClassName);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           defaultSystemModulesClassName,\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ moduleNames()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"moduleNames\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            null);\n-        mv.visitCode();\n-        pushInt(mv, map.size());\n-        mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n-\n-        int index = 0;\n-        for (String moduleName : sorted(map.keySet())) {\n-            mv.visitInsn(DUP);                  \/\/ arrayref\n-            pushInt(mv, index);\n-            mv.visitLdcInsn(moduleName);\n-            mv.visitInsn(AASTORE);\n-            index++;\n-        }\n-\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ classNames()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"classNames\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            null);\n-        mv.visitCode();\n-        pushInt(mv, map.size());\n-        mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n-\n-        index = 0;\n-        for (String className : sorted(map.values())) {\n-            mv.visitInsn(DUP);                  \/\/ arrayref\n-            pushInt(mv, index);\n-            mv.visitLdcInsn(className.replace('\/', '.'));\n-            mv.visitInsn(AASTORE);\n-            index++;\n-        }\n-\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n@@ -1801,2 +1640,92 @@\n-        String rn = \"\/java.base\/\" + SYSTEM_MODULES_MAP_CLASS + \".class\";\n-        ResourcePoolEntry e = ResourcePoolEntry.create(rn, cw.toByteArray());\n+        String rn = \"\/java.base\/\" + SYSTEM_MODULES_MAP_CLASSNAME + \".class\";\n+        ResourcePoolEntry e = ResourcePoolEntry.create(rn, Classfile.build(\n+                CD_SYSTEM_MODULES_MAP,\n+                clb -> {\n+                    clb.withFlags(ACC_FINAL+ACC_SUPER);\n+                    clb.withVersion(52, 0);\n+\n+                    \/\/ <init>\n+                    clb.withMethod(\"<init>\",\n+                            MethodTypeDesc.of(CD_void),\n+                            0,\n+                            mb -> mb.withCode(cob -> {\n+                                cob.loadInstruction(TypeKind.ReferenceType, 0);\n+                                cob.invokeInstruction(Opcode.INVOKESPECIAL,\n+                                                      CD_Object,\n+                                                     \"<init>\",\n+                                                      MethodTypeDesc.of(CD_void),\n+                                                      false);\n+                                cob.returnInstruction(TypeKind.VoidType);\n+                            }));\n+\n+                    \/\/ allSystemModules()\n+                    clb.withMethod(\"allSystemModules\",\n+                            MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                            ACC_STATIC,\n+                            mb -> mb.withFlags(ACC_STATIC).withCode(cob -> {\n+                                cob.newObjectInstruction(allSystemModules);\n+                                cob.stackInstruction(Opcode.DUP);\n+                                cob.invokeInstruction(Opcode.INVOKESPECIAL,\n+                                                      allSystemModules,\n+                                                      \"<init>\",\n+                                                      MethodTypeDesc.of(CD_void),\n+                                                      false);\n+                                cob.returnInstruction(TypeKind.ReferenceType);\n+                            }));\n+\n+                    \/\/ defaultSystemModules()\n+                    clb.withMethod(\"defaultSystemModules\",\n+                            MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                            ACC_STATIC,\n+                            mb -> mb.withFlags(ACC_STATIC).withCode(cob -> {\n+                                cob.newObjectInstruction(defaultSystemModules);\n+                                cob.stackInstruction(Opcode.DUP);\n+                                cob.invokeInstruction(Opcode.INVOKESPECIAL,\n+                                                      defaultSystemModules,\n+                                                      \"<init>\",\n+                                                       MethodTypeDesc.of(CD_void),\n+                                                      false);\n+                                cob.returnInstruction(TypeKind.ReferenceType);\n+                            }));\n+\n+                    \/\/ moduleNames()\n+                    clb.withMethod(\"moduleNames\",\n+                            MethodTypeDesc.of(CD_String.arrayType()),\n+                            ACC_STATIC,\n+                            mb -> mb.withFlags(ACC_STATIC).withCode(cob -> {\n+                                cob.constantInstruction(map.size());\n+                                cob.anewarray(CD_String);\n+\n+                                int index = 0;\n+                                for (String moduleName : sorted(map.keySet())) {\n+                                    cob.stackInstruction(Opcode.DUP);                  \/\/ arrayref\n+                                    cob.constantInstruction(index);\n+                                    cob.constantInstruction(moduleName);\n+                                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n+                                    index++;\n+                                }\n+\n+                                cob.returnInstruction(TypeKind.ReferenceType);\n+                            }));\n+\n+                    \/\/ classNames()\n+                    clb.withMethod(\"classNames\",\n+                            MethodTypeDesc.of(CD_String.arrayType()),\n+                            ACC_STATIC,\n+                            mb -> mb.withFlags(ACC_STATIC).withCode(cob -> {\n+                                cob.constantInstruction(map.size());\n+                                cob.anewarray(CD_String);\n+\n+                                int index = 0;\n+                                for (String className : sorted(map.values())) {\n+                                    cob.stackInstruction(Opcode.DUP);                  \/\/ arrayref\n+                                    cob.constantInstruction(index);\n+                                    cob.constantInstruction(className);\n+                                    cob.arrayStoreInstruction(TypeKind.ReferenceType);\n+                                    index++;\n+                                }\n+\n+                                cob.returnInstruction(TypeKind.ReferenceType);\n+                            }));\n+                }));\n+\n@@ -1821,15 +1750,0 @@\n-    \/**\n-     * Pushes an int constant\n-     *\/\n-    private static void pushInt(MethodVisitor mv, int value) {\n-        if (value <= 5) {\n-            mv.visitInsn(ICONST_0 + value);\n-        } else if (value < Byte.MAX_VALUE) {\n-            mv.visitIntInsn(BIPUSH, value);\n-        } else if (value < Short.MAX_VALUE) {\n-            mv.visitIntInsn(SIPUSH, value);\n-        } else {\n-            throw new IllegalArgumentException(\"exceed limit: \" + value);\n-        }\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":603,"deletions":689,"binary":false,"changes":1292,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.CodeTransform;\n@@ -30,5 +38,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -99,0 +102,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -100,63 +104,11 @@\n-\n-        var cr = newClassReader(path, classFile);\n-        var cw = new ClassWriter(0);\n-\n-        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n-\n-                @Override\n-                public MethodVisitor visitMethod(int access,\n-                                                 String name,\n-                                                 String desc,\n-                                                 String sig,\n-                                                 String[] xs)\n-                {\n-                    if (name.equals(\"<clinit>\"))\n-                        return new MethodVisitor(Opcodes.ASM7,\n-                                                 super.visitMethod(access,\n-                                                                   name,\n-                                                                   desc,\n-                                                                   sig,\n-                                                                   xs))\n-                            {\n-                                private Object pendingLDC = null;\n-\n-                                private void flushPendingLDC() {\n-                                    if (pendingLDC != null) {\n-                                        super.visitLdcInsn(pendingLDC);\n-                                        pendingLDC = null;\n-                                    }\n-                                }\n-\n-                                @Override\n-                                public void visitLdcInsn(Object value) {\n-                                    flushPendingLDC();\n-                                    pendingLDC = value;\n-                                }\n-\n-                                @Override\n-                                public void visitMethodInsn(int opcode,\n-                                                            String owner,\n-                                                            String name,\n-                                                            String descriptor,\n-                                                            boolean isInterface) {\n-                                    flushPendingLDC();\n-                                    super.visitMethodInsn(opcode, owner, name,\n-                                                          descriptor, isInterface);\n-                                }\n-\n-                                @Override\n-                                public void visitFieldInsn(int opcode,\n-                                                           String owner,\n-                                                           String name,\n-                                                           String desc)\n-                                {\n-                                    if (opcode == Opcodes.PUTSTATIC\n-                                        && name.equals(field))\n-                                    {\n-                                        \/\/ assert that there is a pending ldc\n-                                        \/\/ for the old value\n-                                        if (pendingLDC == null) {\n-                                            throw new AssertionError(\"No load \" +\n-                                                \"instruction found for field \" + field +\n-                                                \" in static initializer of \" +\n-                                                VERSION_PROPS_CLASS);\n+        return newClassReader(path, classFile).transform((clb, cle) -> {\n+                if (cle instanceof MethodModel mm && mm.methodName().equalsString(\"<clinit>\")) {\n+                        clb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel cm) {\n+                                mb.transformCode(cm, new CodeTransform() {\n+                                    private CodeElement pendingLDC = null;\n+\n+                                    private void flushPendingLDC(CodeBuilder cob) {\n+                                        if (pendingLDC != null) {\n+                                            cob.accept(pendingLDC);\n+                                            pendingLDC = null;\n@@ -164,7 +116,0 @@\n-                                        \/\/ forget about it\n-                                        pendingLDC = null;\n-                                        \/\/ and add an ldc for the new value\n-                                        super.visitLdcInsn(value);\n-                                        redefined = true;\n-                                    } else {\n-                                        flushPendingLDC();\n@@ -172,3 +117,0 @@\n-                                    super.visitFieldInsn(opcode, owner,\n-                                                         name, desc);\n-                                }\n@@ -176,3 +118,41 @@\n-                        };\n-                    else\n-                        return super.visitMethod(access, name, desc, sig, xs);\n+                                    @Override\n+                                    public void accept(CodeBuilder cob, CodeElement coe) {\n+                                        if (coe instanceof Instruction ins) switch (ins.opcode()) {\n+                                            case LDC, LDC_W, LDC2_W -> {\n+                                                flushPendingLDC(cob);\n+                                                pendingLDC = coe;\n+                                            }\n+                                            case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE -> {\n+                                                flushPendingLDC(cob);\n+                                                cob.accept(coe);\n+                                            }\n+                                            case GETSTATIC, GETFIELD, PUTFIELD -> {\n+                                                flushPendingLDC(cob);\n+                                                cob.accept(coe);\n+                                            }\n+                                            case PUTSTATIC -> {\n+                                                if (((FieldInstruction)coe).name().equalsString(field)) {\n+                                                    \/\/ assert that there is a pending ldc\n+                                                    \/\/ for the old value\n+                                                    if (pendingLDC == null) {\n+                                                        throw new AssertionError(\"No load \" +\n+                                                            \"instruction found for field \" + field +\n+                                                            \" in static initializer of \" +\n+                                                            VERSION_PROPS_CLASS);\n+                                                    }\n+                                                    \/\/ forget about it\n+                                                    pendingLDC = null;\n+                                                    \/\/ and add an ldc for the new value\n+                                                    cob.constantInstruction(value);\n+                                                    redefined = true;\n+                                                } else {\n+                                                    flushPendingLDC(cob);\n+                                                }\n+                                                cob.accept(coe);\n+                                            }\n+                                            default -> cob.accept(coe);\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        });\n@@ -180,5 +160,1 @@\n-\n-            }, 0);\n-\n-        return cw.toByteArray();\n-\n+        });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":62,"deletions":86,"binary":false,"changes":148,"status":"modified"}]}