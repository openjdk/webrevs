{"files":[{"patch":"@@ -199,1 +199,2 @@\n-        jdk.jartool;\n+        jdk.jartool,\n+        jdk.jlink;\n@@ -201,1 +202,2 @@\n-        jdk.jartool;\n+        jdk.jartool,\n+        jdk.jlink;\n@@ -203,0 +205,1 @@\n+        jdk.jlink,\n@@ -205,2 +208,1 @@\n-        jdk.jfr,\n-        jdk.jlink;\n+        jdk.jfr;\n@@ -208,2 +210,1 @@\n-        jdk.jfr,\n-        jdk.jlink;\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n@@ -87,1 +88,1 @@\n-    ClassReader newClassReader(String path, ResourcePoolEntry resource) {\n+    ClassModel newClassReader(String path, ResourcePoolEntry resource, Classfile.Option... options) {\n@@ -90,1 +91,1 @@\n-            return new ClassReader(content);\n+            return Classfile.parse(content, options);\n@@ -102,1 +103,1 @@\n-    protected ClassReader newClassReader(String path, byte[] buf) {\n+    protected ClassModel newClassReader(String path, byte[] buf, Classfile.Option... options) {\n@@ -104,1 +105,1 @@\n-            return new ClassReader(buf);\n+            return Classfile.parse(buf, options);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AbstractPlugin.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.IntUnaryOperator;\n@@ -41,1 +42,0 @@\n-import java.util.stream.IntStream;\n@@ -43,1 +43,1 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -162,4 +162,3 @@\n-                    ClassReader cr = newClassReader(path, bytes);\n-                    if (Arrays.stream(cr.getInterfaces())\n-                        .anyMatch(i -> i.contains(METAINFONAME)) &&\n-                        stripUnsupportedLocales(bytes, cr)) {\n+                    if (newClassReader(path, bytes).interfaces().stream()\n+                        .anyMatch(i -> i.asInternalName().contains(METAINFONAME)) &&\n+                        stripUnsupportedLocales(bytes)) {\n@@ -273,15 +272,19 @@\n-    private boolean stripUnsupportedLocales(byte[] bytes, ClassReader cr) {\n-        boolean[] modified = new boolean[1];\n-\n-        IntStream.range(1, cr.getItemCount())\n-            .map(item -> cr.getItem(item))\n-            .forEach(itemIndex -> {\n-                if (bytes[itemIndex - 1] == 1 &&         \/\/ UTF-8\n-                    bytes[itemIndex + 2] == (byte)' ') { \/\/ fast check for leading space\n-                    int length = cr.readUnsignedShort(itemIndex);\n-                    byte[] b = new byte[length];\n-                    System.arraycopy(bytes, itemIndex + 2, b, 0, length);\n-                    if (filterOutUnsupportedTags(b)) {\n-                        \/\/ copy back\n-                        System.arraycopy(b, 0, bytes, itemIndex + 2, length);\n-                        modified[0] = true;\n+    private boolean stripUnsupportedLocales(byte[] bytes) {\n+        boolean modified = false;\n+        \/\/ scan CP entries directly to read the bytes of UTF8 entries and\n+        \/\/ patch in place with unsupported locale tags stripped\n+        IntUnaryOperator readU2 = p -> ((bytes[p] & 0xff) << 8) + (bytes[p + 1] & 0xff);\n+        int cpLength = readU2.applyAsInt(8);\n+        int offset = 10;\n+        for (int cpSlot=1; cpSlot<cpLength; cpSlot++) {\n+            switch (bytes[offset]) { \/\/entry tag\n+                case TAG_UTF8 -> {\n+                    int length = readU2.applyAsInt(offset + 1);\n+                    if (bytes[offset + 3] == (byte)' ') { \/\/ fast check for leading space\n+                        byte[] b = new byte[length];\n+                        System.arraycopy(bytes, offset + 3, b, 0, length);\n+                        if (filterOutUnsupportedTags(b)) {\n+                            \/\/ copy back\n+                            System.arraycopy(b, 0, bytes, offset + 3, length);\n+                            modified = true;\n+                        }\n@@ -289,0 +292,1 @@\n+                    offset += 3 + length;\n@@ -290,3 +294,21 @@\n-            });\n-\n-        return modified[0];\n+                case TAG_CLASS,\n+                     TAG_STRING,\n+                     TAG_METHODTYPE,\n+                     TAG_MODULE,\n+                     TAG_PACKAGE -> offset += 3;\n+                case TAG_METHODHANDLE -> offset += 4;\n+                case TAG_INTEGER,\n+                     TAG_FLOAT,\n+                     TAG_FIELDREF,\n+                     TAG_METHODREF,\n+                     TAG_INTERFACEMETHODREF,\n+                     TAG_NAMEANDTYPE,\n+                     TAG_CONSTANTDYNAMIC,\n+                     TAG_INVOKEDYNAMIC -> offset += 5;\n+                case TAG_LONG,\n+                     TAG_DOUBLE -> {offset += 9; cpSlot++;} \/\/additional slot for double and long entries\n+                default -> throw new IllegalArgumentException(\"Unknown constant pool entry: 0x\"\n+                        + Integer.toHexString(Byte.toUnsignedInt(bytes[offset])).toUpperCase(Locale.ROOT));\n+            }\n+        }\n+        return modified;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin.java","additions":46,"deletions":24,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n@@ -29,2 +36,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n@@ -60,1 +65,1 @@\n-                        \/\/ XXX. Do we have debug info? Is Asm ready for module-info?\n+                        \/\/ XXX. Do we have debug info?\n@@ -62,4 +67,9 @@\n-                        ClassReader reader = newClassReader(path, resource);\n-                        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-                        reader.accept(writer, ClassReader.SKIP_DEBUG);\n-                        byte[] content = writer.toByteArray();\n+                        byte[] content = newClassReader(path, resource,\n+                                Classfile.Option.processDebug(false),\n+                                Classfile.Option.processLineNumbers(false)).transform(ClassTransform\n+                                        .dropping(cle -> cle instanceof SourceFileAttribute\n+                                                      || cle instanceof SourceDebugExtensionAttribute)\n+                                        .andThen(ClassTransform.transformingMethods(MethodTransform\n+                                                .dropping(me -> me instanceof MethodParametersAttribute)\n+                                                .andThen(MethodTransform\n+                                                        .transformingCode(CodeTransform.ACCEPT_ALL)))));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -45,0 +49,1 @@\n+import java.util.Arrays;\n@@ -72,7 +77,6 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.TypeKind;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.CodeBuilder;\n@@ -102,1 +106,1 @@\n-    private static final String SYSTEM_MODULES_MAP_CLASS =\n+    private static final String SYSTEM_MODULES_MAP_CLASSNAME =\n@@ -106,1 +110,2 @@\n-    private static final String ALL_SYSTEM_MODULES_CLASS =\n+\n+    private static final String ALL_SYSTEM_MODULES_CLASSNAME =\n@@ -108,1 +113,1 @@\n-    private static final String DEFAULT_SYSTEM_MODULES_CLASS =\n+    private static final String DEFAULT_SYSTEM_MODULES_CLASSNAME =\n@@ -110,1 +115,6 @@\n-\n+    private static final ClassDesc CD_ALL_SYSTEM_MODULES =\n+            ClassDesc.ofInternalName(ALL_SYSTEM_MODULES_CLASSNAME);\n+    private static final ClassDesc CD_SYSTEM_MODULES =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/SystemModules\");\n+    private static final ClassDesc CD_SYSTEM_MODULES_MAP =\n+            ClassDesc.ofInternalName(SYSTEM_MODULES_MAP_CLASSNAME);\n@@ -228,1 +238,1 @@\n-                                          ALL_SYSTEM_MODULES_CLASS,\n+                                          ALL_SYSTEM_MODULES_CLASSNAME,\n@@ -238,1 +248,1 @@\n-            defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASS;\n+            defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASSNAME;\n@@ -240,1 +250,1 @@\n-            defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASS;\n+            defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASSNAME;\n@@ -256,1 +266,1 @@\n-                    map.put(moduleName, ALL_SYSTEM_MODULES_CLASS);\n+                    map.put(moduleName, ALL_SYSTEM_MODULES_CLASSNAME);\n@@ -267,2 +277,2 @@\n-        rn = genSystemModulesMapClass(ALL_SYSTEM_MODULES_CLASS,\n-                                      defaultSystemModulesClassName,\n+        rn = genSystemModulesMapClass(CD_ALL_SYSTEM_MODULES,\n+                                      ClassDesc.ofInternalName(defaultSystemModulesClassName),\n@@ -310,1 +320,1 @@\n-        byte[] bytes = generator.getClassWriter(cf).toByteArray();\n+        byte[] bytes = generator.genClassBytes(cf);\n@@ -422,15 +432,0 @@\n-            Set<String> packages = new HashSet<>();\n-            ClassVisitor cv = new ClassVisitor(Opcodes.ASM7) {\n-                @Override\n-                public ModuleVisitor visitModule(String name,\n-                                                 int flags,\n-                                                 String version) {\n-                    return new ModuleVisitor(Opcodes.ASM7) {\n-                        @Override\n-                        public void visitPackage(String pn) {\n-                            packages.add(pn);\n-                        }\n-                    };\n-                }\n-            };\n-\n@@ -439,3 +434,3 @@\n-                ClassReader cr = new ClassReader(in);\n-                cr.accept(cv, 0);\n-                return packages.size() > 0;\n+                return Classfile.parse(in.readAllBytes()).elementStream()\n+                        .anyMatch(e -> e instanceof ModulePackagesAttribute mpa\n+                                    && !mpa.packages().isEmpty());\n@@ -508,20 +503,16 @@\n-        private static final String MODULE_DESCRIPTOR_BUILDER =\n-            \"jdk\/internal\/module\/Builder\";\n-        private static final String MODULE_DESCRIPTOR_ARRAY_SIGNATURE =\n-            \"[Ljava\/lang\/module\/ModuleDescriptor;\";\n-        private static final String REQUIRES_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\";\n-        private static final String EXPORTS_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\";\n-        private static final String OPENS_MODIFIER_CLASSNAME =\n-            \"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\";\n-        private static final String MODULE_TARGET_CLASSNAME  =\n-            \"jdk\/internal\/module\/ModuleTarget\";\n-        private static final String MODULE_TARGET_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleTarget;\";\n-        private static final String MODULE_HASHES_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleHashes;\";\n-        private static final String MODULE_RESOLUTION_CLASSNAME  =\n-            \"jdk\/internal\/module\/ModuleResolution\";\n-        private static final String MODULE_RESOLUTIONS_ARRAY_SIGNATURE  =\n-            \"[Ljdk\/internal\/module\/ModuleResolution;\";\n+        private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+        private static final ClassDesc CD_MODULE_BUILDER =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+        private static final ClassDesc CD_REQUIRES_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\");\n+        private static final ClassDesc CD_EXPORTS_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\");\n+        private static final ClassDesc CD_OPENS_MODIFIER =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\");\n+        private static final ClassDesc CD_MODULE_TARGET =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleTarget\");\n+        private static final ClassDesc CD_MODULE_HASHES =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleHashes\");\n+        private static final ClassDesc CD_MODULE_RESOLUTION =\n+            ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleResolution\");\n@@ -537,3 +528,0 @@\n-        \/\/ Method visitor for generating the SystemModules::modules() method\n-        private MethodVisitor mv;\n-\n@@ -541,1 +529,1 @@\n-        private final String className;\n+        private final ClassDesc classDesc;\n@@ -543,1 +531,1 @@\n-        \/\/ list of all ModuleDescriptorBuilders, invoked in turn when building.\n+        \/\/ list of all ModuleInfos\n@@ -554,1 +542,1 @@\n-            this.className = className;\n+            this.classDesc = ClassDesc.ofInternalName(className);\n@@ -593,12 +581,6 @@\n-        public ClassWriter getClassWriter(Configuration cf) {\n-            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                             + ClassWriter.COMPUTE_FRAMES);\n-            cw.visit(CLASSFILE_VERSION,\n-                     ACC_FINAL+ACC_SUPER,\n-                     className,\n-                     null,\n-                     \"java\/lang\/Object\",\n-                     new String[] { \"jdk\/internal\/module\/SystemModules\" });\n-\n-            \/\/ generate <init>\n-            genConstructor(cw);\n+        public byte[] genClassBytes(Configuration cf) {\n+            return Classfile.build(classDesc,\n+                    clb -> {\n+                        clb.withFlags(ACC_FINAL + ACC_SUPER)\n+                           .withInterfaceSymbols(List.of(CD_SYSTEM_MODULES))\n+                           .withVersion(CLASSFILE_VERSION, 0);\n@@ -606,2 +588,2 @@\n-            \/\/ generate hasSplitPackages\n-            genHasSplitPackages(cw);\n+                        \/\/ generate <init>\n+                        genConstructor(clb);\n@@ -609,2 +591,2 @@\n-            \/\/ generate hasIncubatorModules\n-            genIncubatorModules(cw);\n+                        \/\/ generate hasSplitPackages\n+                        genHasSplitPackages(clb);\n@@ -612,2 +594,2 @@\n-            \/\/ generate moduleDescriptors\n-            genModuleDescriptorsMethod(cw);\n+                        \/\/ generate hasIncubatorModules\n+                        genIncubatorModules(clb);\n@@ -615,2 +597,2 @@\n-            \/\/ generate moduleTargets\n-            genModuleTargetsMethod(cw);\n+                        \/\/ generate moduleDescriptors\n+                        genModuleDescriptorsMethod(clb);\n@@ -618,2 +600,2 @@\n-            \/\/ generate moduleHashes\n-            genModuleHashesMethod(cw);\n+                        \/\/ generate moduleTargets\n+                        genModuleTargetsMethod(clb);\n@@ -621,2 +603,2 @@\n-            \/\/ generate moduleResolutions\n-            genModuleResolutionsMethod(cw);\n+                        \/\/ generate moduleHashes\n+                        genModuleHashesMethod(clb);\n@@ -624,2 +606,2 @@\n-            \/\/ generate moduleReads\n-            genModuleReads(cw, cf);\n+                        \/\/ generate moduleResolutions\n+                        genModuleResolutionsMethod(clb);\n@@ -627,1 +609,3 @@\n-            return cw;\n+                        \/\/ generate moduleReads\n+                        genModuleReads(clb, cf);\n+                    });\n@@ -633,11 +617,10 @@\n-        private void genConstructor(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL,\n-                               \"java\/lang\/Object\",\n-                               \"<init>\",\n-                               \"()V\",\n-                               false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        private void genConstructor(ClassBuilder clb) {\n+            clb.withMethodBody(\n+                    \"<init>\",\n+                    MethodTypeDesc.of(CD_void),\n+                    ACC_PUBLIC,\n+                    cob -> cob.aload(0)\n+                              .invokespecial(CD_Object,\n+                                             \"<init>\",\n+                                             MethodTypeDesc.of(CD_void))\n+                              .return_());\n@@ -649,1 +632,1 @@\n-        private void genHasSplitPackages(ClassWriter cw) {\n+        private void genHasSplitPackages(ClassBuilder clb) {\n@@ -656,14 +639,6 @@\n-            mv = cw.visitMethod(ACC_PUBLIC,\n-                                \"hasSplitPackages\",\n-                                \"()Z\",\n-                                \"()Z\",\n-                                null);\n-            mv.visitCode();\n-            if (hasSplitPackages) {\n-                mv.visitInsn(ICONST_1);\n-            } else {\n-                mv.visitInsn(ICONST_0);\n-            }\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethodBody(\n+                    \"hasSplitPackages\",\n+                    MethodTypeDesc.of(CD_boolean),\n+                    ACC_PUBLIC,\n+                    cob -> cob.constantInstruction(hasSplitPackages ? 1 : 0)\n+                              .ireturn());\n@@ -675,1 +650,1 @@\n-        private void genIncubatorModules(ClassWriter cw) {\n+        private void genIncubatorModules(ClassBuilder clb) {\n@@ -682,14 +657,6 @@\n-            mv = cw.visitMethod(ACC_PUBLIC,\n-                                \"hasIncubatorModules\",\n-                                \"()Z\",\n-                                \"()Z\",\n-                                null);\n-            mv.visitCode();\n-            if (hasIncubatorModules) {\n-                mv.visitInsn(ICONST_1);\n-            } else {\n-                mv.visitInsn(ICONST_0);\n-            }\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethodBody(\n+                    \"hasIncubatorModules\",\n+                    MethodTypeDesc.of(CD_boolean),\n+                    ACC_PUBLIC,\n+                    cob -> cob.constantInstruction(hasIncubatorModules ? 1 : 0)\n+                              .ireturn());\n@@ -701,21 +668,20 @@\n-        private void genModuleDescriptorsMethod(ClassWriter cw) {\n-            this.mv = cw.visitMethod(ACC_PUBLIC,\n-                                     \"moduleDescriptors\",\n-                                     \"()\" + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,\n-                                     \"()\" + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,\n-                                     null);\n-            mv.visitCode();\n-            pushInt(mv, moduleInfos.size());\n-            mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor\");\n-            mv.visitVarInsn(ASTORE, MD_VAR);\n-\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                new ModuleDescriptorBuilder(minfo.descriptor(),\n-                                            minfo.packages(),\n-                                            index).build();\n-            }\n-            mv.visitVarInsn(ALOAD, MD_VAR);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        private void genModuleDescriptorsMethod(ClassBuilder clb) {\n+            clb.withMethodBody(\n+                    \"moduleDescriptors\",\n+                    MethodTypeDesc.of(CD_MODULE_DESCRIPTOR.arrayType()),\n+                    ACC_PUBLIC,\n+                    cob -> {\n+                        cob.constantInstruction(moduleInfos.size())\n+                           .anewarray(CD_MODULE_DESCRIPTOR)\n+                           .astore(MD_VAR);\n+\n+                        for (int index = 0; index < moduleInfos.size(); index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            new ModuleDescriptorBuilder(cob,\n+                                                        minfo.descriptor(),\n+                                                        minfo.packages(),\n+                                                        index).build();\n+                        }\n+                        cob.aload(MD_VAR)\n+                           .areturn();\n+                    });\n@@ -727,39 +693,24 @@\n-        private void genModuleTargetsMethod(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,\n-                                              \"moduleTargets\",\n-                                              \"()\" + MODULE_TARGET_ARRAY_SIGNATURE,\n-                                              \"()\" + MODULE_TARGET_ARRAY_SIGNATURE,\n-                                              null);\n-            mv.visitCode();\n-            pushInt(mv, moduleInfos.size());\n-            mv.visitTypeInsn(ANEWARRAY, MODULE_TARGET_CLASSNAME);\n-            mv.visitVarInsn(ASTORE, MT_VAR);\n-\n-\n-            \/\/ if java.base has a ModuleTarget attribute then generate the array\n-            \/\/ with one element, all other elements will be null.\n-\n-            ModuleInfo base = moduleInfos.get(0);\n-            if (!base.moduleName().equals(\"java.base\"))\n-                throw new InternalError(\"java.base should be first module in list\");\n-            ModuleTarget target = base.target();\n-\n-            int count;\n-            if (target != null && target.targetPlatform() != null) {\n-                count = 1;\n-            } else {\n-                count = moduleInfos.size();\n-            }\n-\n-            for (int index = 0; index < count; index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.target() != null) {\n-                    mv.visitVarInsn(ALOAD, MT_VAR);\n-                    pushInt(mv, index);\n-\n-                    \/\/ new ModuleTarget(String)\n-                    mv.visitTypeInsn(NEW, MODULE_TARGET_CLASSNAME);\n-                    mv.visitInsn(DUP);\n-                    mv.visitLdcInsn(minfo.target().targetPlatform());\n-                    mv.visitMethodInsn(INVOKESPECIAL, MODULE_TARGET_CLASSNAME,\n-                                       \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        private void genModuleTargetsMethod(ClassBuilder clb) {\n+            clb.withMethodBody(\n+                    \"moduleTargets\",\n+                    MethodTypeDesc.of(CD_MODULE_TARGET.arrayType()),\n+                    ACC_PUBLIC,\n+                    cob -> {\n+                        cob.constantInstruction(moduleInfos.size())\n+                           .anewarray(CD_MODULE_TARGET)\n+                           .astore(MT_VAR);\n+\n+                        \/\/ if java.base has a ModuleTarget attribute then generate the array\n+                        \/\/ with one element, all other elements will be null.\n+\n+                        ModuleInfo base = moduleInfos.get(0);\n+                        if (!base.moduleName().equals(\"java.base\"))\n+                            throw new InternalError(\"java.base should be first module in list\");\n+                        ModuleTarget target = base.target();\n+\n+                        int count;\n+                        if (target != null && target.targetPlatform() != null) {\n+                            count = 1;\n+                        } else {\n+                            count = moduleInfos.size();\n+                        }\n@@ -767,3 +718,17 @@\n-                    mv.visitInsn(AASTORE);\n-                }\n-            }\n+                        for (int index = 0; index < count; index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            if (minfo.target() != null) {\n+                                cob.aload(MT_VAR)\n+                                   .constantInstruction(index);\n+\n+                                \/\/ new ModuleTarget(String)\n+                                cob.new_(CD_MODULE_TARGET)\n+                                   .dup()\n+                                   .constantInstruction(minfo.target().targetPlatform())\n+                                   .invokespecial(CD_MODULE_TARGET,\n+                                                  \"<init>\",\n+                                                  MethodTypeDesc.of(CD_void, CD_String));\n+\n+                                cob.aastore();\n+                            }\n+                        }\n@@ -771,4 +736,3 @@\n-            mv.visitVarInsn(ALOAD, MT_VAR);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+                        cob.aload(MT_VAR)\n+                           .areturn();\n+                    });\n@@ -780,20 +744,18 @@\n-        private void genModuleHashesMethod(ClassWriter cw) {\n-            MethodVisitor hmv =\n-                cw.visitMethod(ACC_PUBLIC,\n-                               \"moduleHashes\",\n-                               \"()\" + MODULE_HASHES_ARRAY_SIGNATURE,\n-                               \"()\" + MODULE_HASHES_ARRAY_SIGNATURE,\n-                               null);\n-            hmv.visitCode();\n-            pushInt(hmv, moduleInfos.size());\n-            hmv.visitTypeInsn(ANEWARRAY, \"jdk\/internal\/module\/ModuleHashes\");\n-            hmv.visitVarInsn(ASTORE, MH_VAR);\n-\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.recordedHashes() != null) {\n-                    new ModuleHashesBuilder(minfo.recordedHashes(),\n-                                            index,\n-                                            hmv).build();\n-                }\n-            }\n+        private void genModuleHashesMethod(ClassBuilder clb) {\n+            clb.withMethodBody(\n+                    \"moduleHashes\",\n+                    MethodTypeDesc.of(CD_MODULE_HASHES.arrayType()),\n+                    ACC_PUBLIC,\n+                    cob -> {\n+                        cob.constantInstruction(moduleInfos.size())\n+                           .anewarray(CD_MODULE_HASHES)\n+                           .astore(MH_VAR);\n+\n+                        for (int index = 0; index < moduleInfos.size(); index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            if (minfo.recordedHashes() != null) {\n+                                new ModuleHashesBuilder(minfo.recordedHashes(),\n+                                                        index,\n+                                                        cob).build();\n+                            }\n+                        }\n@@ -801,4 +763,3 @@\n-            hmv.visitVarInsn(ALOAD, MH_VAR);\n-            hmv.visitInsn(ARETURN);\n-            hmv.visitMaxs(0, 0);\n-            hmv.visitEnd();\n+                        cob.aload(MH_VAR)\n+                           .areturn();\n+                    });\n@@ -810,31 +771,27 @@\n-        private void genModuleResolutionsMethod(ClassWriter cw) {\n-            MethodVisitor mresmv =\n-                cw.visitMethod(ACC_PUBLIC,\n-                               \"moduleResolutions\",\n-                               \"()\" + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,\n-                               \"()\" + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,\n-                               null);\n-            mresmv.visitCode();\n-            pushInt(mresmv, moduleInfos.size());\n-            mresmv.visitTypeInsn(ANEWARRAY, MODULE_RESOLUTION_CLASSNAME);\n-            mresmv.visitVarInsn(ASTORE, 0);\n-\n-            for (int index=0; index < moduleInfos.size(); index++) {\n-                ModuleInfo minfo = moduleInfos.get(index);\n-                if (minfo.moduleResolution() != null) {\n-                    mresmv.visitVarInsn(ALOAD, 0);\n-                    pushInt(mresmv, index);\n-                    mresmv.visitTypeInsn(NEW, MODULE_RESOLUTION_CLASSNAME);\n-                    mresmv.visitInsn(DUP);\n-                    mresmv.visitLdcInsn(minfo.moduleResolution().value());\n-                    mresmv.visitMethodInsn(INVOKESPECIAL,\n-                                           MODULE_RESOLUTION_CLASSNAME,\n-                                           \"<init>\",\n-                                           \"(I)V\", false);\n-                    mresmv.visitInsn(AASTORE);\n-                }\n-            }\n-            mresmv.visitVarInsn(ALOAD, 0);\n-            mresmv.visitInsn(ARETURN);\n-            mresmv.visitMaxs(0, 0);\n-            mresmv.visitEnd();\n+        private void genModuleResolutionsMethod(ClassBuilder clb) {\n+            clb.withMethodBody(\n+                    \"moduleResolutions\",\n+                    MethodTypeDesc.of(CD_MODULE_RESOLUTION.arrayType()),\n+                    ACC_PUBLIC,\n+                    cob -> {\n+                        cob.constantInstruction(moduleInfos.size())\n+                           .anewarray(CD_MODULE_RESOLUTION)\n+                           .astore(0);\n+\n+                        for (int index=0; index < moduleInfos.size(); index++) {\n+                            ModuleInfo minfo = moduleInfos.get(index);\n+                            if (minfo.moduleResolution() != null) {\n+                                cob.aload(0)\n+                                   .constantInstruction(index)\n+                                   .new_(CD_MODULE_RESOLUTION)\n+                                   .dup()\n+                                   .constantInstruction(minfo.moduleResolution().value())\n+                                   .invokespecial(CD_MODULE_RESOLUTION,\n+                                                  \"<init>\",\n+                                                  MethodTypeDesc.of(CD_void, CD_int))\n+                                   .aastore();\n+                            }\n+                        }\n+                        cob.aload(0)\n+                           .areturn();\n+                    });\n@@ -846,1 +803,1 @@\n-        private void genModuleReads(ClassWriter cw, Configuration cf) {\n+        private void genModuleReads(ClassBuilder clb, Configuration cf) {\n@@ -854,1 +811,1 @@\n-            generate(cw, \"moduleReads\", map, true);\n+            generate(clb, \"moduleReads\", map, true);\n@@ -862,1 +819,1 @@\n-        private void generate(ClassWriter cw,\n+        private void generate(ClassBuilder clb,\n@@ -866,51 +823,29 @@\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,\n-                                              methodName,\n-                                              \"()Ljava\/util\/Map;\",\n-                                              \"()Ljava\/util\/Map;\",\n-                                              null);\n-            mv.visitCode();\n-\n-            \/\/ map of Set -> local\n-            Map<Set<String>, Integer> locals;\n-\n-            \/\/ generate code to create the sets that are duplicated\n-            if (dedup) {\n-                Collection<Set<String>> values = map.values();\n-                Set<Set<String>> duplicateSets = values.stream()\n-                        .distinct()\n-                        .filter(s -> Collections.frequency(values, s) > 1)\n-                        .collect(Collectors.toSet());\n-                locals = new HashMap<>();\n-                int index = 1;\n-                for (Set<String> s : duplicateSets) {\n-                    genImmutableSet(mv, s);\n-                    mv.visitVarInsn(ASTORE, index);\n-                    locals.put(s, index);\n-                    if (++index >= MAX_LOCAL_VARS) {\n-                        break;\n-                    }\n-                }\n-            } else {\n-                locals = Map.of();\n-            }\n-\n-            \/\/ new Map$Entry[size]\n-            pushInt(mv, map.size());\n-            mv.visitTypeInsn(ANEWARRAY, \"java\/util\/Map$Entry\");\n-\n-            int index = 0;\n-            for (var e : new TreeMap<>(map).entrySet()) {\n-                String name = e.getKey();\n-                Set<String> s = e.getValue();\n-\n-                mv.visitInsn(DUP);\n-                pushInt(mv, index);\n-                mv.visitLdcInsn(name);\n-\n-                \/\/ if de-duplicated then load the local, otherwise generate code\n-                Integer varIndex = locals.get(s);\n-                if (varIndex == null) {\n-                    genImmutableSet(mv, s);\n-                } else {\n-                    mv.visitVarInsn(ALOAD, varIndex);\n-                }\n+            clb.withMethodBody(\n+                    methodName,\n+                    MethodTypeDesc.of(CD_Map),\n+                    ACC_PUBLIC,\n+                    cob -> {\n+\n+                        \/\/ map of Set -> local\n+                        Map<Set<String>, Integer> locals;\n+\n+                        \/\/ generate code to create the sets that are duplicated\n+                        if (dedup) {\n+                            Collection<Set<String>> values = map.values();\n+                            Set<Set<String>> duplicateSets = values.stream()\n+                                    .distinct()\n+                                    .filter(s -> Collections.frequency(values, s) > 1)\n+                                    .collect(Collectors.toSet());\n+                            locals = new HashMap<>();\n+                            int index = 1;\n+                            for (Set<String> s : duplicateSets) {\n+                                genImmutableSet(cob, s);\n+                                cob.astore(index);\n+                                locals.put(s, index);\n+                                if (++index >= MAX_LOCAL_VARS) {\n+                                    break;\n+                                }\n+                            }\n+                        } else {\n+                            locals = Map.of();\n+                        }\n@@ -918,9 +853,30 @@\n-                String desc = \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\";\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                                   \"java\/util\/Map\",\n-                                   \"entry\",\n-                                   desc,\n-                                   true);\n-                mv.visitInsn(AASTORE);\n-                index++;\n-            }\n+                        \/\/ new Map$Entry[size]\n+                        cob.constantInstruction(map.size())\n+                           .anewarray(ClassDesc.ofInternalName(\"java\/util\/Map$Entry\"));\n+\n+                        int index = 0;\n+                        for (var e : new TreeMap<>(map).entrySet()) {\n+                            String name = e.getKey();\n+                            Set<String> s = e.getValue();\n+\n+                            cob.dup()\n+                               .constantInstruction(index)\n+                               .constantInstruction(name);\n+\n+                            \/\/ if de-duplicated then load the local, otherwise generate code\n+                            Integer varIndex = locals.get(s);\n+                            if (varIndex == null) {\n+                                genImmutableSet(cob, s);\n+                            } else {\n+                                cob.aload(varIndex);\n+                            }\n+\n+                            MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(\n+                                    \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\");\n+                            cob.invokestatic(CD_Map,\n+                                             \"entry\",\n+                                             desc,\n+                                             true)\n+                               .aastore();\n+                            index++;\n+                        }\n@@ -928,6 +884,8 @@\n-            \/\/ invoke Map.ofEntries(Map$Entry[])\n-            mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Map\", \"ofEntries\",\n-                    \"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\", true);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+                        \/\/ invoke Map.ofEntries(Map$Entry[])\n+                        cob.invokestatic(CD_Map,\n+                                         \"ofEntries\",\n+                                         MethodTypeDesc.ofDescriptor(\n+                                                 \"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\"),\n+                                         true)\n+                           .areturn();\n+                    });\n@@ -939,1 +897,1 @@\n-        private void genImmutableSet(MethodVisitor mv, Set<String> set) {\n+        private void genImmutableSet(CodeBuilder cob, Set<String> set) {\n@@ -945,2 +903,2 @@\n-                pushInt(mv, size);\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                cob.constantInstruction(size)\n+                   .anewarray(CD_String);\n@@ -949,4 +907,4 @@\n-                    mv.visitInsn(DUP);\n-                    pushInt(mv, i);\n-                    mv.visitLdcInsn(element);\n-                    mv.visitInsn(AASTORE);\n+                    cob.dup()\n+                       .constantInstruction(i)\n+                       .constantInstruction(element)\n+                       .aastore();\n@@ -955,5 +913,5 @@\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                        \"java\/util\/Set\",\n-                        \"of\",\n-                        \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\",\n-                        true);\n+                cob.invokestatic(CD_Set,\n+                                 \"of\",\n+                                 MethodTypeDesc.ofDescriptor(\n+                                         \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"),\n+                                 true);\n@@ -961,1 +919,0 @@\n-                StringBuilder sb = new StringBuilder(\"(\");\n@@ -963,2 +920,1 @@\n-                    mv.visitLdcInsn(element);\n-                    sb.append(\"Ljava\/lang\/Object;\");\n+                    cob.constantInstruction(element);\n@@ -966,6 +922,6 @@\n-                sb.append(\")Ljava\/util\/Set;\");\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                        \"java\/util\/Set\",\n-                        \"of\",\n-                        sb.toString(),\n-                        true);\n+                var mtdArgs = new ClassDesc[size];\n+                Arrays.fill(mtdArgs, CD_Object);\n+                cob.invokestatic(CD_Set,\n+                                 \"of\",\n+                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n+                                 true);\n@@ -976,9 +932,8 @@\n-            static final String BUILDER_TYPE = \"Ljdk\/internal\/module\/Builder;\";\n-            static final String EXPORTS_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Exports;\";\n-            static final String OPENS_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Opens;\";\n-            static final String PROVIDES_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Provides;\";\n-            static final String REQUIRES_TYPE =\n-                \"Ljava\/lang\/module\/ModuleDescriptor$Requires;\";\n+            static final ClassDesc CD_EXPORTS =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+            static final ClassDesc CD_OPENS =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+            static final ClassDesc CD_PROVIDES =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+            static final ClassDesc CD_REQUIRES =\n+                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n@@ -988,16 +943,14 @@\n-            static final String EXPORTS_MODIFIER_SET_STRING_SET_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/util\/Set;)\"\n-                    + EXPORTS_TYPE;\n-            static final String EXPORTS_MODIFIER_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + EXPORTS_TYPE;\n-            static final String OPENS_MODIFIER_SET_STRING_SET_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/util\/Set;)\"\n-                    + OPENS_TYPE;\n-            static final String OPENS_MODIFIER_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + OPENS_TYPE;\n-            static final String PROVIDES_STRING_LIST_SIG =\n-                \"(Ljava\/lang\/String;Ljava\/util\/List;)\" + PROVIDES_TYPE;\n-            static final String REQUIRES_SET_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;)\" + REQUIRES_TYPE;\n-            static final String REQUIRES_SET_STRING_STRING_SIG =\n-                \"(Ljava\/util\/Set;Ljava\/lang\/String;Ljava\/lang\/String;)\" + REQUIRES_TYPE;\n+            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+                MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+            static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+            static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n@@ -1007,12 +960,13 @@\n-            static final String EXPORTS_ARRAY_SIG =\n-                \"([\" + EXPORTS_TYPE + \")\" + BUILDER_TYPE;\n-            static final String OPENS_ARRAY_SIG =\n-                \"([\" + OPENS_TYPE + \")\" + BUILDER_TYPE;\n-            static final String PROVIDES_ARRAY_SIG =\n-                \"([\" + PROVIDES_TYPE + \")\" + BUILDER_TYPE;\n-            static final String REQUIRES_ARRAY_SIG =\n-                \"([\" + REQUIRES_TYPE + \")\" + BUILDER_TYPE;\n-            static final String SET_SIG = \"(Ljava\/util\/Set;)\" + BUILDER_TYPE;\n-            static final String STRING_SIG = \"(Ljava\/lang\/String;)\" + BUILDER_TYPE;\n-            static final String BOOLEAN_SIG = \"(Z)\" + BUILDER_TYPE;\n-\n+            static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+            static final MethodTypeDesc MTD_OPENS_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+            static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+            static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+            static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+            static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+            static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+\n+            final CodeBuilder cob;\n@@ -1023,1 +977,1 @@\n-            ModuleDescriptorBuilder(ModuleDescriptor md, Set<String> packages, int index) {\n+            ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n@@ -1027,0 +981,1 @@\n+                this.cob = cob;\n@@ -1064,7 +1019,7 @@\n-                mv.visitTypeInsn(NEW, MODULE_DESCRIPTOR_BUILDER);\n-                mv.visitInsn(DUP);\n-                mv.visitLdcInsn(md.name());\n-                mv.visitMethodInsn(INVOKESPECIAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-                mv.visitVarInsn(ASTORE, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n+                cob.new_(CD_MODULE_BUILDER)\n+                   .dup()\n+                   .constantInstruction(md.name())\n+                   .invokespecial(CD_MODULE_BUILDER,\n+                                  \"<init>\",\n+                                  MethodTypeDesc.of(CD_void, CD_String))\n+                   .astore(BUILDER_VAR);\n@@ -1087,9 +1042,6 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                if (value) {\n-                    mv.visitInsn(ICONST_1);\n-                } else {\n-                    mv.visitInsn(ICONST_0);\n-                }\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    methodName, BOOLEAN_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(value ? 1 : 0)\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  methodName,\n+                                  MTD_BOOLEAN)\n+                   .pop();\n@@ -1102,8 +1054,8 @@\n-                mv.visitVarInsn(ALOAD, MD_VAR);\n-                pushInt(mv, index);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(md.hashCode());\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"build\", \"(I)Ljava\/lang\/module\/ModuleDescriptor;\",\n-                    false);\n-                mv.visitInsn(AASTORE);\n+                cob.aload(MD_VAR)\n+                   .constantInstruction(index)\n+                   .aload(BUILDER_VAR)\n+                   .constantInstruction(md.hashCode())\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  \"build\",\n+                                  MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int))\n+                   .aastore();\n@@ -1119,3 +1071,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, requires.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Requires\");\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(requires.size())\n+                   .anewarray(CD_REQUIRES);\n@@ -1129,2 +1081,2 @@\n-                    mv.visitInsn(DUP);               \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.dup()               \/\/ arrayref\n+                       .constantInstruction(arrayIndex++);\n@@ -1132,1 +1084,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.aastore();\n@@ -1134,2 +1086,3 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"requires\", REQUIRES_ARRAY_SIG, false);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                                  \"requires\",\n+                                  MTD_REQUIRES_ARRAY);\n@@ -1145,3 +1098,3 @@\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(mods);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitLdcInsn(name);\n+                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n+                cob.aload(varIndex)\n+                   .constantInstruction(name);\n@@ -1149,3 +1102,4 @@\n-                    mv.visitLdcInsn(compiledVersion);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newRequires\", REQUIRES_SET_STRING_STRING_SIG, false);\n+                    cob.constantInstruction(compiledVersion)\n+                       .invokestatic(CD_MODULE_BUILDER,\n+                                     \"newRequires\",\n+                                     MTD_REQUIRES_SET_STRING_STRING);\n@@ -1153,2 +1107,3 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newRequires\", REQUIRES_SET_STRING_SIG, false);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                     \"newRequires\",\n+                                     MTD_REQUIRES_SET_STRING);\n@@ -1165,3 +1120,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, exports.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Exports\");\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(exports.size())\n+                   .anewarray(CD_EXPORTS);\n@@ -1170,2 +1125,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.dup()    \/\/ arrayref\n+                       .constantInstruction(arrayIndex++);\n@@ -1173,1 +1128,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.aastore();\n@@ -1175,2 +1130,3 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"exports\", EXPORTS_ARRAY_SIG, false);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                                  \"exports\",\n+                                  MTD_EXPORTS_ARRAY);\n@@ -1195,1 +1151,1 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(ms);\n+                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n@@ -1197,6 +1153,7 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitVarInsn(ALOAD, stringSetIndex);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newExports\", EXPORTS_MODIFIER_SET_STRING_SET_SIG, false);\n+                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n+                    cob.aload(modifiersSetIndex)\n+                       .constantInstruction(pn)\n+                       .aload(stringSetIndex)\n+                       .invokestatic(CD_MODULE_BUILDER,\n+                                     \"newExports\",\n+                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n@@ -1204,4 +1161,5 @@\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newExports\", EXPORTS_MODIFIER_SET_STRING_SIG, false);\n+                    cob.aload(modifiersSetIndex)\n+                       .constantInstruction(pn)\n+                       .invokestatic(CD_MODULE_BUILDER,\n+                                     \"newExports\",\n+                                     MTD_EXPORTS_MODIFIER_SET_STRING);\n@@ -1218,3 +1176,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, opens.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Opens\");\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(opens.size())\n+                   .anewarray(CD_OPENS);\n@@ -1223,2 +1181,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.dup()    \/\/ arrayref\n+                       .constantInstruction(arrayIndex++);\n@@ -1226,1 +1184,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.aastore();\n@@ -1228,2 +1186,3 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"opens\", OPENS_ARRAY_SIG, false);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                                  \"opens\",\n+                                  MTD_OPENS_ARRAY);\n@@ -1248,1 +1207,1 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(ms);\n+                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n@@ -1250,6 +1209,7 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitVarInsn(ALOAD, stringSetIndex);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newOpens\", OPENS_MODIFIER_SET_STRING_SET_SIG, false);\n+                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n+                    cob.aload(modifiersSetIndex)\n+                       .constantInstruction(pn)\n+                       .aload(stringSetIndex)\n+                       .invokestatic(CD_MODULE_BUILDER,\n+                                     \"newOpens\",\n+                                     MTD_OPENS_MODIFIER_SET_STRING_SET);\n@@ -1257,4 +1217,5 @@\n-                    mv.visitVarInsn(ALOAD, modifiersSetIndex);\n-                    mv.visitLdcInsn(pn);\n-                    mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                        \"newOpens\", OPENS_MODIFIER_SET_STRING_SIG, false);\n+                    cob.aload(modifiersSetIndex)\n+                       .constantInstruction(pn)\n+                       .invokestatic(CD_MODULE_BUILDER,\n+                                     \"newOpens\",\n+                                     MTD_OPENS_MODIFIER_SET_STRING);\n@@ -1268,6 +1229,7 @@\n-                int varIndex = dedupSetBuilder.indexOfStringSet(uses);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"uses\", SET_SIG, false);\n-                mv.visitInsn(POP);\n+                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n+                cob.aload(BUILDER_VAR)\n+                   .aload(varIndex)\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  \"uses\",\n+                                  MTD_SET)\n+                   .pop();\n@@ -1283,3 +1245,3 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                pushInt(mv, provides.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/module\/ModuleDescriptor$Provides\");\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(provides.size())\n+                   .anewarray(CD_PROVIDES);\n@@ -1288,2 +1250,2 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n+                    cob.dup()    \/\/ arrayref\n+                       .constantInstruction(arrayIndex++);\n@@ -1291,1 +1253,1 @@\n-                    mv.visitInsn(AASTORE);\n+                    cob.aastore();\n@@ -1293,2 +1255,3 @@\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"provides\", PROVIDES_ARRAY_SIG, false);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                                  \"provides\",\n+                                  MTD_PROVIDES_ARRAY);\n@@ -1307,3 +1270,3 @@\n-                mv.visitLdcInsn(service);\n-                pushInt(mv, providers.size());\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                cob.constantInstruction(service)\n+                   .constantInstruction(providers.size())\n+                   .anewarray(CD_String);\n@@ -1312,4 +1275,4 @@\n-                    mv.visitInsn(DUP);    \/\/ arrayref\n-                    pushInt(mv, arrayIndex++);\n-                    mv.visitLdcInsn(provider);\n-                    mv.visitInsn(AASTORE);\n+                    cob.dup()    \/\/ arrayref\n+                       .constantInstruction(arrayIndex++)\n+                       .constantInstruction(provider)\n+                       .aastore();\n@@ -1317,4 +1280,8 @@\n-                mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/List\",\n-                    \"of\", \"([Ljava\/lang\/Object;)Ljava\/util\/List;\", true);\n-                mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,\n-                    \"newProvides\", PROVIDES_STRING_LIST_SIG, false);\n+                cob.invokestatic(CD_List,\n+                                 \"of\",\n+                                 MethodTypeDesc.ofDescriptor(\n+                                        \"([Ljava\/lang\/Object;)Ljava\/util\/List;\"),\n+                                 true)\n+                   .invokestatic(CD_MODULE_BUILDER,\n+                                 \"newProvides\",\n+                                 MTD_PROVIDES_STRING_LIST);\n@@ -1327,6 +1294,7 @@\n-                int varIndex = dedupSetBuilder.newStringSet(packages);\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitVarInsn(ALOAD, varIndex);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"packages\", SET_SIG, false);\n-                mv.visitInsn(POP);\n+                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n+                cob.aload(BUILDER_VAR)\n+                   .aload(varIndex)\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  \"packages\",\n+                                  MTD_SET)\n+                   .pop();\n@@ -1339,5 +1307,6 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(cn);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"mainClass\", STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(cn)\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  \"mainClass\",\n+                                  MTD_STRING)\n+                   .pop();\n@@ -1350,5 +1319,6 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(v.toString());\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    \"version\", STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(v.toString())\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  \"version\",\n+                                  MTD_STRING)\n+                   .pop();\n@@ -1358,5 +1328,6 @@\n-                mv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                mv.visitLdcInsn(value);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,\n-                    methodName, STRING_SIG, false);\n-                mv.visitInsn(POP);\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(value)\n+                   .invokevirtual(CD_MODULE_BUILDER,\n+                                  methodName,\n+                                  MTD_STRING)\n+                   .pop();\n@@ -1367,6 +1338,4 @@\n-            private static final String MODULE_HASHES_BUILDER =\n-                \"jdk\/internal\/module\/ModuleHashes$Builder\";\n-            private static final String MODULE_HASHES_BUILDER_TYPE =\n-                \"L\" + MODULE_HASHES_BUILDER + \";\";\n-            static final String STRING_BYTE_ARRAY_SIG =\n-                \"(Ljava\/lang\/String;[B)\" + MODULE_HASHES_BUILDER_TYPE;\n+            private static final ClassDesc MODULE_HASHES_BUILDER =\n+                ClassDesc.ofInternalName(\"jdk\/internal\/module\/ModuleHashes$Builder\");\n+            static final MethodTypeDesc STRING_BYTE_ARRAY_SIG =\n+                MethodTypeDesc.of(MODULE_HASHES_BUILDER, CD_String, CD_byte.arrayType());\n@@ -1375,1 +1344,1 @@\n-            final MethodVisitor hmv;\n+            final CodeBuilder cob;\n@@ -1378,1 +1347,1 @@\n-            ModuleHashesBuilder(ModuleHashes hashes, int index, MethodVisitor hmv) {\n+            ModuleHashesBuilder(ModuleHashes hashes, int index, CodeBuilder cob) {\n@@ -1380,1 +1349,1 @@\n-                this.hmv = hmv;\n+                this.cob = cob;\n@@ -1410,8 +1379,9 @@\n-                hmv.visitTypeInsn(NEW, MODULE_HASHES_BUILDER);\n-                hmv.visitInsn(DUP);\n-                hmv.visitLdcInsn(recordedHashes.algorithm());\n-                pushInt(hmv, ((4 * recordedHashes.names().size()) \/ 3) + 1);\n-                hmv.visitMethodInsn(INVOKESPECIAL, MODULE_HASHES_BUILDER,\n-                    \"<init>\", \"(Ljava\/lang\/String;I)V\", false);\n-                hmv.visitVarInsn(ASTORE, BUILDER_VAR);\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n+                cob.new_(MODULE_HASHES_BUILDER)\n+                   .dup()\n+                   .constantInstruction(recordedHashes.algorithm())\n+                   .constantInstruction(((4 * recordedHashes.names().size()) \/ 3) + 1)\n+                   .invokespecial(MODULE_HASHES_BUILDER,\n+                                  \"<init>\",\n+                                  MethodTypeDesc.of(CD_void, CD_String, CD_int))\n+                   .astore(BUILDER_VAR)\n+                   .aload(BUILDER_VAR);\n@@ -1426,7 +1396,7 @@\n-                hmv.visitVarInsn(ALOAD, MH_VAR);\n-                pushInt(hmv, index);\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n-                    \"build\", \"()Ljdk\/internal\/module\/ModuleHashes;\",\n-                    false);\n-                hmv.visitInsn(AASTORE);\n+                cob.aload(MH_VAR)\n+                   .constantInstruction(index)\n+                   .aload(BUILDER_VAR)\n+                   .invokevirtual(MODULE_HASHES_BUILDER,\n+                                  \"build\",\n+                                  MethodTypeDesc.of(CD_MODULE_HASHES))\n+                   .aastore();\n@@ -1439,5 +1409,4 @@\n-                hmv.visitVarInsn(ALOAD, BUILDER_VAR);\n-                hmv.visitLdcInsn(name);\n-\n-                pushInt(hmv, hash.length);\n-                hmv.visitIntInsn(NEWARRAY, T_BYTE);\n+                cob.aload(BUILDER_VAR)\n+                   .constantInstruction(name)\n+                   .constantInstruction(hash.length)\n+                   .newarray(TypeKind.ByteType);\n@@ -1445,4 +1414,4 @@\n-                    hmv.visitInsn(DUP);              \/\/ arrayref\n-                    pushInt(hmv, i);\n-                    hmv.visitIntInsn(BIPUSH, hash[i]);\n-                    hmv.visitInsn(BASTORE);\n+                    cob.dup()              \/\/ arrayref\n+                       .constantInstruction(i)\n+                       .constantInstruction((int)hash[i])\n+                       .bastore();\n@@ -1451,3 +1420,4 @@\n-                hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,\n-                    \"hashForModule\", STRING_BYTE_ARRAY_SIG, false);\n-                hmv.visitInsn(POP);\n+                cob.invokevirtual(MODULE_HASHES_BUILDER,\n+                                  \"hashForModule\",\n+                                  STRING_BYTE_ARRAY_SIG)\n+                   .pop();\n@@ -1460,1 +1430,1 @@\n-        class DedupSetBuilder {\n+        static class DedupSetBuilder {\n@@ -1504,1 +1474,1 @@\n-                                new EnumSetBuilder<>(s, EXPORTS_MODIFIER_CLASSNAME,\n+                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n@@ -1514,1 +1484,1 @@\n-                                new EnumSetBuilder<>(s, OPENS_MODIFIER_CLASSNAME,\n+                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n@@ -1524,1 +1494,1 @@\n-                    new EnumSetBuilder<>(s, REQUIRES_MODIFIER_CLASSNAME,\n+                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n@@ -1533,2 +1503,2 @@\n-            int indexOfStringSet(Set<String> names) {\n-                return stringSets.get(names).build();\n+            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n+                return stringSets.get(names).build(cob);\n@@ -1541,2 +1511,2 @@\n-            int indexOfExportsModifiers(Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build();\n+            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                return exportsModifiersSets.get(mods).build(cob);\n@@ -1549,2 +1519,2 @@\n-            int indexOfOpensModifiers(Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build();\n+            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                return opensModifiersSets.get(mods).build(cob);\n@@ -1558,2 +1528,2 @@\n-            int indexOfRequiresModifiers(Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build();\n+            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                return requiresModifiersSets.get(mods).build(cob);\n@@ -1565,2 +1535,2 @@\n-            int newStringSet(Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build();\n+            int newStringSet(CodeBuilder cob, Set<String> names) {\n+                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n@@ -1579,1 +1549,1 @@\n-        class SetBuilder<T extends Comparable<T>> {\n+        static class SetBuilder<T extends Comparable<T>> {\n@@ -1605,2 +1575,2 @@\n-            void visitElement(T element, MethodVisitor mv) {\n-                mv.visitLdcInsn(element);\n+            void visitElement(T element, CodeBuilder cob) {\n+                cob.constantInstruction((ConstantDesc)element);\n@@ -1616,1 +1586,1 @@\n-            final int build() {\n+            final int build(CodeBuilder cob) {\n@@ -1630,1 +1600,1 @@\n-                    generateSetOf(index);\n+                    generateSetOf(cob, index);\n@@ -1635,1 +1605,1 @@\n-            private void generateSetOf(int index) {\n+            private void generateSetOf(CodeBuilder cob, int index) {\n@@ -1638,1 +1608,0 @@\n-                    StringBuilder sb = new StringBuilder(\"(\");\n@@ -1640,2 +1609,1 @@\n-                        sb.append(\"Ljava\/lang\/Object;\");\n-                        visitElement(t, mv);\n+                        visitElement(t, cob);\n@@ -1643,3 +1611,6 @@\n-                    sb.append(\")Ljava\/util\/Set;\");\n-                    mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Set\",\n-                            \"of\", sb.toString(), true);\n+                    var mtdArgs = new ClassDesc[elements.size()];\n+                    Arrays.fill(mtdArgs, CD_Object);\n+                    cob.invokestatic(CD_Set,\n+                                     \"of\",\n+                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n+                                     true);\n@@ -1648,2 +1619,2 @@\n-                    pushInt(mv, elements.size());\n-                    mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n+                    cob.constantInstruction(elements.size())\n+                       .anewarray(CD_String);\n@@ -1652,4 +1623,4 @@\n-                        mv.visitInsn(DUP);    \/\/ arrayref\n-                        pushInt(mv, arrayIndex);\n-                        visitElement(t, mv);  \/\/ value\n-                        mv.visitInsn(AASTORE);\n+                        cob.dup()    \/\/ arrayref\n+                           .constantInstruction(arrayIndex);\n+                        visitElement(t, cob);  \/\/ value\n+                        cob.aastore();\n@@ -1658,2 +1629,5 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Set\",\n-                            \"of\", \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\", true);\n+                    cob.invokestatic(CD_Set,\n+                                     \"of\",\n+                                     MethodTypeDesc.ofDescriptor(\n+                                            \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"),\n+                                     true);\n@@ -1661,1 +1635,1 @@\n-                mv.visitVarInsn(ASTORE, index);\n+                cob.astore(index);\n@@ -1669,1 +1643,2 @@\n-        class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n+        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n+            private final ClassDesc classDesc;\n@@ -1671,3 +1646,1 @@\n-            private final String className;\n-\n-            EnumSetBuilder(Set<T> modifiers, String className,\n+            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n@@ -1677,1 +1650,1 @@\n-                this.className = className;\n+                this.classDesc = classDesc;\n@@ -1684,3 +1657,2 @@\n-            void visitElement(T t, MethodVisitor mv) {\n-                mv.visitFieldInsn(GETSTATIC, className, t.toString(),\n-                                  \"L\" + className + \";\");\n+            void visitElement(T t, CodeBuilder cob) {\n+                cob.getstatic(classDesc, t.toString(), classDesc);\n@@ -1696,2 +1668,2 @@\n-    private String genSystemModulesMapClass(String allSystemModulesClassName,\n-                                            String defaultSystemModulesClassName,\n+    private String genSystemModulesMapClass(ClassDesc allSystemModules,\n+                                            ClassDesc defaultSystemModules,\n@@ -1700,102 +1672,0 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(CLASSFILE_VERSION,\n-                 ACC_FINAL+ACC_SUPER,\n-                 SYSTEM_MODULES_MAP_CLASS,\n-                 null,\n-                 \"java\/lang\/Object\",\n-                 null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           \"java\/lang\/Object\",\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ allSystemModules()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"allSystemModules\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            null);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, allSystemModulesClassName);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           allSystemModulesClassName,\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ defaultSystemModules()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"defaultSystemModules\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            \"()Ljdk\/internal\/module\/SystemModules;\",\n-                            null);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, defaultSystemModulesClassName);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                           defaultSystemModulesClassName,\n-                           \"<init>\",\n-                           \"()V\",\n-                           false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ moduleNames()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"moduleNames\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            null);\n-        mv.visitCode();\n-        pushInt(mv, map.size());\n-        mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n-\n-        int index = 0;\n-        for (String moduleName : sorted(map.keySet())) {\n-            mv.visitInsn(DUP);                  \/\/ arrayref\n-            pushInt(mv, index);\n-            mv.visitLdcInsn(moduleName);\n-            mv.visitInsn(AASTORE);\n-            index++;\n-        }\n-\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ classNames()\n-        mv = cw.visitMethod(ACC_STATIC,\n-                            \"classNames\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            \"()[Ljava\/lang\/String;\",\n-                            null);\n-        mv.visitCode();\n-        pushInt(mv, map.size());\n-        mv.visitTypeInsn(ANEWARRAY, \"java\/lang\/String\");\n-\n-        index = 0;\n-        for (String className : sorted(map.values())) {\n-            mv.visitInsn(DUP);                  \/\/ arrayref\n-            pushInt(mv, index);\n-            mv.visitLdcInsn(className.replace('\/', '.'));\n-            mv.visitInsn(AASTORE);\n-            index++;\n-        }\n-\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n@@ -1804,2 +1674,83 @@\n-        String rn = \"\/java.base\/\" + SYSTEM_MODULES_MAP_CLASS + \".class\";\n-        ResourcePoolEntry e = ResourcePoolEntry.create(rn, cw.toByteArray());\n+        String rn = \"\/java.base\/\" + SYSTEM_MODULES_MAP_CLASSNAME + \".class\";\n+        ResourcePoolEntry e = ResourcePoolEntry.create(rn, Classfile.build(\n+                CD_SYSTEM_MODULES_MAP,\n+                clb -> clb.withFlags(ACC_FINAL + ACC_SUPER)\n+                          .withVersion(52, 0)\n+\n+                          \/\/ <init>\n+                          .withMethodBody(\n+                                  \"<init>\",\n+                                  MethodTypeDesc.of(CD_void),\n+                                  0,\n+                                  cob -> cob.aload(0)\n+                                            .invokespecial(CD_Object,\n+                                                           \"<init>\",\n+                                                           MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+\n+                          \/\/ allSystemModules()\n+                          .withMethodBody(\n+                                  \"allSystemModules\",\n+                                  MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                                  ACC_STATIC,\n+                                  cob -> cob.new_(allSystemModules)\n+                                            .dup()\n+                                            .invokespecial(allSystemModules,\n+                                                           \"<init>\",\n+                                                           MethodTypeDesc.of(CD_void))\n+                                            .areturn())\n+\n+                          \/\/ defaultSystemModules()\n+                          .withMethodBody(\n+                                  \"defaultSystemModules\",\n+                                   MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                                   ACC_STATIC,\n+                                   cob -> cob.new_(defaultSystemModules)\n+                                             .dup()\n+                                             .invokespecial(defaultSystemModules,\n+                                                            \"<init>\",\n+                                                            MethodTypeDesc.of(CD_void))\n+                                             .areturn())\n+\n+                          \/\/ moduleNames()\n+                          .withMethodBody(\n+                                  \"moduleNames\",\n+                                  MethodTypeDesc.of(CD_String.arrayType()),\n+                                  ACC_STATIC,\n+                                  cob -> {\n+                                      cob.constantInstruction(map.size());\n+                                      cob.anewarray(CD_String);\n+\n+                                      int index = 0;\n+                                      for (String moduleName : sorted(map.keySet())) {\n+                                          cob.dup() \/\/ arrayref\n+                                             .constantInstruction(index)\n+                                             .constantInstruction(moduleName)\n+                                             .aastore();\n+                                          index++;\n+                                      }\n+\n+                                      cob.areturn();\n+                                  })\n+\n+                          \/\/ classNames()\n+                          .withMethodBody(\n+                                  \"classNames\",\n+                                  MethodTypeDesc.of(CD_String.arrayType()),\n+                                  ACC_STATIC,\n+                                  cob -> {\n+                                      cob.constantInstruction(map.size())\n+                                         .anewarray(CD_String);\n+\n+                                      int index = 0;\n+                                      for (String className : sorted(map.values())) {\n+                                          cob.dup() \/\/ arrayref\n+                                             .constantInstruction(index)\n+                                             .constantInstruction(className.replace('\/', '.'))\n+                                             .aastore();\n+                                          index++;\n+                                      }\n+\n+                                      cob.areturn();\n+                                  })));\n+\n@@ -1824,15 +1775,0 @@\n-    \/**\n-     * Pushes an int constant\n-     *\/\n-    private static void pushInt(MethodVisitor mv, int value) {\n-        if (value <= 5) {\n-            mv.visitInsn(ICONST_0 + value);\n-        } else if (value < Byte.MAX_VALUE) {\n-            mv.visitIntInsn(BIPUSH, value);\n-        } else if (value < Short.MAX_VALUE) {\n-            mv.visitIntInsn(SIPUSH, value);\n-        } else {\n-            throw new IllegalArgumentException(\"exceed limit: \" + value);\n-        }\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":640,"deletions":704,"binary":false,"changes":1344,"status":"modified"},{"patch":"@@ -29,0 +29,6 @@\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.CodeTransform;\n@@ -30,5 +36,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -99,0 +100,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -100,0 +102,11 @@\n+        return newClassReader(path, classFile).transform(ClassTransform.transformingMethodBodies(\n+                mm -> mm.methodName().equalsString(\"<clinit>\"),\n+                new CodeTransform() {\n+                    private CodeElement pendingLDC = null;\n+\n+                    private void flushPendingLDC(CodeBuilder cob) {\n+                        if (pendingLDC != null) {\n+                            cob.accept(pendingLDC);\n+                            pendingLDC = null;\n+                        }\n+                    }\n@@ -101,27 +114,7 @@\n-        var cr = newClassReader(path, classFile);\n-        var cw = new ClassWriter(0);\n-\n-        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n-\n-                @Override\n-                public MethodVisitor visitMethod(int access,\n-                                                 String name,\n-                                                 String desc,\n-                                                 String sig,\n-                                                 String[] xs)\n-                {\n-                    if (name.equals(\"<clinit>\"))\n-                        return new MethodVisitor(Opcodes.ASM7,\n-                                                 super.visitMethod(access,\n-                                                                   name,\n-                                                                   desc,\n-                                                                   sig,\n-                                                                   xs))\n-                            {\n-                                private Object pendingLDC = null;\n-\n-                                private void flushPendingLDC() {\n-                                    if (pendingLDC != null) {\n-                                        super.visitLdcInsn(pendingLDC);\n-                                        pendingLDC = null;\n-                                    }\n+                    @Override\n+                    public void accept(CodeBuilder cob, CodeElement coe) {\n+                        if (coe instanceof Instruction ins) {\n+                            switch (ins.opcode()) {\n+                                case LDC, LDC_W, LDC2_W -> {\n+                                    flushPendingLDC(cob);\n+                                    pendingLDC = coe;\n@@ -129,5 +122,3 @@\n-\n-                                @Override\n-                                public void visitLdcInsn(Object value) {\n-                                    flushPendingLDC();\n-                                    pendingLDC = value;\n+                                case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE -> {\n+                                    flushPendingLDC(cob);\n+                                    cob.accept(coe);\n@@ -135,10 +126,3 @@\n-\n-                                @Override\n-                                public void visitMethodInsn(int opcode,\n-                                                            String owner,\n-                                                            String name,\n-                                                            String descriptor,\n-                                                            boolean isInterface) {\n-                                    flushPendingLDC();\n-                                    super.visitMethodInsn(opcode, owner, name,\n-                                                          descriptor, isInterface);\n+                                case GETSTATIC, GETFIELD, PUTFIELD -> {\n+                                    flushPendingLDC(cob);\n+                                    cob.accept(coe);\n@@ -146,10 +130,2 @@\n-\n-                                @Override\n-                                public void visitFieldInsn(int opcode,\n-                                                           String owner,\n-                                                           String name,\n-                                                           String desc)\n-                                {\n-                                    if (opcode == Opcodes.PUTSTATIC\n-                                        && name.equals(field))\n-                                    {\n+                                case PUTSTATIC -> {\n+                                    if (((FieldInstruction)coe).name().equalsString(field)) {\n@@ -167,1 +143,1 @@\n-                                        super.visitLdcInsn(value);\n+                                        cob.constantInstruction(value);\n@@ -170,1 +146,1 @@\n-                                        flushPendingLDC();\n+                                        flushPendingLDC(cob);\n@@ -172,2 +148,1 @@\n-                                    super.visitFieldInsn(opcode, owner,\n-                                                         name, desc);\n+                                    cob.accept(coe);\n@@ -175,10 +150,7 @@\n-\n-                        };\n-                    else\n-                        return super.visitMethod(access, name, desc, sig, xs);\n-                }\n-\n-            }, 0);\n-\n-        return cw.toByteArray();\n-\n+                                default -> cob.accept(coe);\n+                            }\n+                        } else {\n+                            cob.accept(coe);\n+                        }\n+                    }\n+                }));\n@@ -201,1 +173,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":43,"deletions":72,"binary":false,"changes":115,"status":"modified"}]}