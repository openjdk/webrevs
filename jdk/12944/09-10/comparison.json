{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.IntUnaryOperator;\n@@ -160,2 +161,3 @@\n-                    var helper = new ResourceFileHelper(bytes);\n-                    if (helper.interfacesContainMetaInfo() && helper.stripUnsupportedLocales()) {\n+                    if (newClassReader(path, bytes).interfaces().stream()\n+                        .anyMatch(i -> i.asInternalName().contains(METAINFONAME)) &&\n+                        stripUnsupportedLocales(bytes)) {\n@@ -269,42 +271,18 @@\n-    class ResourceFileHelper {\n-\n-        final byte[] data;\n-        final int[] cpOffsets;\n-        final int intfsOffset;\n-\n-        public ResourceFileHelper(byte[] data) {\n-            this.data = data;\n-            this.cpOffsets = new int[readU2(8)];\n-            int p = 10;\n-            for (int i = 1; i < cpOffsets.length; ++i) {\n-                cpOffsets[i] = p;\n-                byte tag = data[p];\n-                ++p;\n-                switch (tag) {\n-                    case TAG_CLASS, TAG_METHODTYPE, TAG_MODULE, TAG_STRING, TAG_PACKAGE -> p += 2;\n-                    case TAG_METHODHANDLE -> p += 3;\n-                    case TAG_CONSTANTDYNAMIC, TAG_FIELDREF, TAG_FLOAT, TAG_INTEGER,\n-                         TAG_INTERFACEMETHODREF, TAG_INVOKEDYNAMIC, TAG_METHODREF,\n-                         TAG_NAMEANDTYPE -> p += 4;\n-                    case TAG_DOUBLE, TAG_LONG -> {\n-                        p += 8;\n-                        ++i;\n-                    }\n-                    case TAG_UTF8 -> p += 2 + readU2(p);\n-                    default -> throw new IllegalArgumentException(\n-                            \"Bad tag (\" + tag + \") at index (\" + i + \") position (\" + p + \")\");\n-                }\n-            }\n-            intfsOffset = p + 6;\n-        }\n-\n-        public boolean interfacesContainMetaInfo() {\n-            int iCount = readU2(intfsOffset);\n-            for (int i = 0; i < iCount; i++) {\n-                int iClassOff = cpOffsets[readU2(intfsOffset + 2 + 2 * i)];\n-                if (data[iClassOff] == TAG_CLASS) {\n-                    int iNameOff = cpOffsets[readU2(iClassOff + 1)];\n-                    if (data[iNameOff] == TAG_UTF8) {\n-                        int iNameLength = readU2(iNameOff + 1);\n-                        if (new String(data, iNameOff + 3, iNameLength).contains(METAINFONAME)) {\n-                            return true;\n+    private boolean stripUnsupportedLocales(byte[] bytes) {\n+        boolean modified = false;\n+        \/\/ scan CP entries directly to read the bytes of UTF8 entries and\n+        \/\/ patch in place with unsupported locale tags stripped\n+        IntUnaryOperator readU2 = p -> ((bytes[p] & 0xff) << 8) + (bytes[p + 1] & 0xff);\n+        int cpLength = readU2.applyAsInt(8);\n+        int offset = 10;\n+        for (int cpSlot=1; cpSlot<cpLength; cpSlot++) {\n+            switch (bytes[offset]) { \/\/entry tag\n+                case TAG_UTF8 -> {\n+                    int length = readU2.applyAsInt(offset + 1);\n+                    if (bytes[offset + 3] == (byte)' ') { \/\/ fast check for leading space\n+                        byte[] b = new byte[length];\n+                        System.arraycopy(bytes, offset + 3, b, 0, length);\n+                        if (filterOutUnsupportedTags(b)) {\n+                            \/\/ copy back\n+                            System.arraycopy(b, 0, bytes, offset + 3, length);\n+                            modified = true;\n@@ -313,0 +291,1 @@\n+                    offset += 3 + length;\n@@ -314,0 +293,16 @@\n+                case TAG_CLASS,\n+                     TAG_STRING,\n+                     TAG_METHODTYPE,\n+                     TAG_MODULE,\n+                     TAG_PACKAGE -> offset += 3;\n+                case TAG_METHODHANDLE -> offset += 4;\n+                case TAG_INTEGER,\n+                     TAG_FLOAT,\n+                     TAG_FIELDREF,\n+                     TAG_METHODREF,\n+                     TAG_INTERFACEMETHODREF,\n+                     TAG_NAMEANDTYPE,\n+                     TAG_CONSTANTDYNAMIC,\n+                     TAG_INVOKEDYNAMIC -> offset += 5;\n+                case TAG_LONG,\n+                     TAG_DOUBLE -> {offset += 9; cpSlot++;} \/\/additional slot for double and long entries\n@@ -315,24 +310,0 @@\n-            return false;\n-        }\n-\n-        public boolean stripUnsupportedLocales() {\n-            boolean modified = false;\n-            for (int o : cpOffsets) {\n-                if (o > 0 && data[o] == TAG_UTF8 && data[o + 3] == (byte)' ') {\n-                    int length = readU2(o + 1);\n-                    byte[] b = new byte[length];\n-                    System.arraycopy(data, o + 3, b, 0, length);\n-                    if (filterOutUnsupportedTags(b)) {\n-                        \/\/ copy back\n-                        System.arraycopy(b, 0, data, o + 3, length);\n-                        modified = true;\n-                    }\n-                }\n-            }\n-            return modified;\n-        }\n-\n-        private int readU2(int p) {\n-            int b1 = data[p] & 0xFF;\n-            int b2 = data[p + 1] & 0xFF;\n-            return (b1 << 8) + b2;\n@@ -340,0 +311,1 @@\n+        return modified;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin.java","additions":40,"deletions":68,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-import jdk.internal.classfile.Opcode;\n@@ -316,1 +315,1 @@\n-        byte[] bytes = generator.getClassWriter(cf);\n+        byte[] bytes = generator.genClassBytes(cf);\n@@ -577,1 +576,1 @@\n-        public byte[] getClassWriter(Configuration cf) {\n+        public byte[] genClassBytes(Configuration cf) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}