{"files":[{"patch":"@@ -160,3 +160,2 @@\n-                    if (newClassReader(path, bytes).interfaces().stream()\n-                        .anyMatch(i -> i.asInternalName().contains(METAINFONAME)) &&\n-                        stripUnsupportedLocales(bytes)) {\n+                    var helper = new ResourceFileHelper(bytes);\n+                    if (helper.interfacesContainMetaInfo() && helper.stripUnsupportedLocales()) {\n@@ -270,17 +269,42 @@\n-    private boolean stripUnsupportedLocales(byte[] bytes) {\n-        boolean modified = false;\n-        \/\/ scan CP entries directly to read the bytes of UTF8 entries and\n-        \/\/ patch in place with unsupported locale tags stripped\n-        final int cpLength = (bytes[8] << 8) + (int)bytes[9];\n-        int offset = 10;\n-        for (int cpSlot=1; cpSlot<cpLength; cpSlot++) {\n-            switch (bytes[offset]) { \/\/entry tag\n-                case TAG_UTF8 -> {\n-                    final int length = (bytes[offset+1] << 8) + (int)bytes[offset+2];\n-                    if (bytes[offset + 3] == (byte)' ') { \/\/ fast check for leading space\n-                        byte[] b = new byte[length];\n-                        System.arraycopy(bytes, offset + 3, b, 0, length);\n-                        if (filterOutUnsupportedTags(b)) {\n-                            \/\/ copy back\n-                            System.arraycopy(b, 0, bytes, offset + 3, length);\n-                            modified = true;\n+    class ResourceFileHelper {\n+\n+        final byte[] data;\n+        final int[] cpOffsets;\n+        final int intfsOffset;\n+\n+        public ResourceFileHelper(byte[] data) {\n+            this.data = data;\n+            this.cpOffsets = new int[readU2(8)];\n+            int p = 10;\n+            for (int i = 1; i < cpOffsets.length; ++i) {\n+                cpOffsets[i] = p;\n+                byte tag = data[p];\n+                ++p;\n+                switch (tag) {\n+                    case TAG_CLASS, TAG_METHODTYPE, TAG_MODULE, TAG_STRING, TAG_PACKAGE -> p += 2;\n+                    case TAG_METHODHANDLE -> p += 3;\n+                    case TAG_CONSTANTDYNAMIC, TAG_FIELDREF, TAG_FLOAT, TAG_INTEGER,\n+                         TAG_INTERFACEMETHODREF, TAG_INVOKEDYNAMIC, TAG_METHODREF,\n+                         TAG_NAMEANDTYPE -> p += 4;\n+                    case TAG_DOUBLE, TAG_LONG -> {\n+                        p += 8;\n+                        ++i;\n+                    }\n+                    case TAG_UTF8 -> p += 2 + readU2(p);\n+                    default -> throw new IllegalArgumentException(\n+                            \"Bad tag (\" + tag + \") at index (\" + i + \") position (\" + p + \")\");\n+                }\n+            }\n+            intfsOffset = p + 6;\n+        }\n+\n+        public boolean interfacesContainMetaInfo() {\n+            int iCount = readU2(intfsOffset);\n+            for (int i = 0; i < iCount; i++) {\n+                int iClassOff = cpOffsets[readU2(intfsOffset + 2 + 2 * i)];\n+                if (data[iClassOff] == TAG_CLASS) {\n+                    int iNameOff = cpOffsets[readU2(iClassOff + 1)];\n+                    if (data[iNameOff] == TAG_UTF8) {\n+                        int iNameLength = readU2(iNameOff + 1);\n+                        if (new String(data, iNameOff + 3, iNameLength).contains(METAINFONAME)) {\n+                            return true;\n@@ -289,1 +313,0 @@\n-                    offset += 3 + length;\n@@ -291,16 +314,0 @@\n-                case TAG_CLASS,\n-                        TAG_STRING,\n-                        TAG_METHODTYPE,\n-                        TAG_MODULE,\n-                        TAG_PACKAGE -> offset += 3;\n-                case TAG_METHODHANDLE -> offset += 4;\n-                case TAG_INTEGER,\n-                        TAG_FLOAT,\n-                        TAG_FIELDREF,\n-                        TAG_METHODREF,\n-                        TAG_INTERFACEMETHODREF,\n-                        TAG_NAMEANDTYPE,\n-                        TAG_CONSTANTDYNAMIC,\n-                        TAG_INVOKEDYNAMIC -> offset += 5;\n-                case TAG_LONG,\n-                        TAG_DOUBLE -> {offset += 9; cpSlot++;} \/\/additional slot for double and long entries\n@@ -308,0 +315,24 @@\n+            return false;\n+        }\n+\n+        public boolean stripUnsupportedLocales() {\n+            boolean modified = false;\n+            for (int o : cpOffsets) {\n+                if (o > 0 && data[o] == TAG_UTF8 && data[o + 3] == (byte)' ') {\n+                    int length = readU2(o + 1);\n+                    byte[] b = new byte[length];\n+                    System.arraycopy(data, o + 3, b, 0, length);\n+                    if (filterOutUnsupportedTags(b)) {\n+                        \/\/ copy back\n+                        System.arraycopy(b, 0, data, o + 3, length);\n+                        modified = true;\n+                    }\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        private int readU2(int p) {\n+            int b1 = data[p] & 0xFF;\n+            int b2 = data[p + 1] & 0xFF;\n+            return (b1 << 8) + b2;\n@@ -309,1 +340,0 @@\n-        return modified;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin.java","additions":68,"deletions":38,"binary":false,"changes":106,"status":"modified"}]}