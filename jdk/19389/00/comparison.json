{"files":[{"patch":"@@ -153,1 +153,3 @@\n-  report_region_type_change(G1HeapRegionTraceType::Free);\n+  if (!is_free()) {\n+    report_region_type_change(G1HeapRegionTraceType::Free);\n+  }\n@@ -173,0 +175,1 @@\n+  G1HeapRegionTraceType::Type prev_trace_type = _type.get_trace_type();\n@@ -174,1 +177,1 @@\n-    report_region_type_change(G1HeapRegionTraceType::Old);\n+    report_region_type_change(prev_trace_type);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.gc.detailed;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.GCHelper;\n+\n+\/**\n+ * @test\n+ * @bug 8330577\n+ * @requires vm.hasJFR\n+ * @requires vm.gc == \"G1\" | vm.gc == null\n+ * @requires vm.debug\n+ * @key jfr\n+ * @library \/test\/lib \/test\/jdk\n+ * @summary Make sure that there are no Old->Old and Free->Free events sent.\n+ * @run main\/othervm -XX:+G1GCAllocationFailureALot -XX:NewSize=2m -XX:MaxNewSize=2m -XX:MaxTenuringThreshold=1\n+ *                   -Xmx32m -XX:G1HeapRegionSize=1m -XX:+UseG1GC -Xlog:gc jdk.jfr.event.gc.detailed.TestG1InvalidHeapRegionTypeChangeEvent\n+ *\/\n+\n+public class TestG1InvalidHeapRegionTypeChangeEvent {\n+    private final static String EVENT_NAME = EventNames.G1HeapRegionTypeChange;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = null;\n+        try {\n+            recording = new Recording();\n+            \/\/ activate the event we are interested in and start recording\n+            recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n+            recording.start();\n+\n+            \/\/ Compact the heap, creating some Old regions. Previously this sent\n+            \/\/ Free->Free transitions too.\n+            System.gc();\n+\n+            \/\/ Setting NewSize and MaxNewSize will limit eden, so\n+            \/\/ allocating 1024 20k byte arrays should trigger at\n+            \/\/ least a few Young GCs.\n+            \/\/ This fragments the heap a little (together with\n+            \/\/ G1GCAllocationFailureALot), so that the next Full GC\n+            \/\/ will generate Free -> Old transitions that were incorrectly\n+            \/\/ sent as Old -> Old.\n+            \/\/ Note that an Old -> Old transition is actually valid in case\n+            \/\/ of evacuation failure in an old region, but this is no\n+            \/\/ change of region and should not be sent either.\n+\n+            byte[][] array = new byte[1024][];\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new byte[20 * 1024];\n+            }\n+\n+            System.gc();\n+            recording.stop();\n+\n+            \/\/ Verify recording\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            Asserts.assertFalse(events.isEmpty(), \"No events found\");\n+\n+            for (RecordedEvent event : events) {\n+                Events.assertField(event, \"index\").notEqual(-1);\n+                Asserts.assertTrue(GCHelper.isValidG1HeapRegionType(Events.assertField(event, \"from\").getValue()));\n+                Asserts.assertTrue(GCHelper.isValidG1HeapRegionType(Events.assertField(event, \"to\").getValue()));\n+                Events.assertField(event, \"used\").atMost(1L*1024*1024);\n+                \/\/ There should be no Old->Old and Free->Free \"changes\".\n+                Asserts.assertFalse(Events.assertField(event, \"from\").getValue().equals(\"Old\") && Events.assertField(event, \"to\").getValue().equals(\"Old\"));\n+                Asserts.assertFalse(Events.assertField(event, \"from\").getValue().equals(\"Free\") && Events.assertField(event, \"to\").getValue().equals(\"Free\"));\n+            }\n+        } catch (Throwable t) {\n+            if (recording != null) {\n+                recording.dump(Paths.get(\"TestG1HeapRegionTypeChangeEvent.jfr\"));\n+            }\n+            throw t;\n+        } finally {\n+            if (recording != null) {\n+                recording.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestG1InvalidHeapRegionTypeChangeEvent.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}