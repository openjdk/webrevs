{"files":[{"patch":"@@ -1738,0 +1738,2 @@\n+\n+  bool can_move_to_inner_loop(Node* n, LoopNode* n_loop, Node* x);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,2 +155,1 @@\n-    if (x != the_clone && the_clone != nullptr)\n-      _igvn.remove_dead_node(the_clone);\n+\n@@ -158,0 +157,13 @@\n+\n+    if (the_clone == nullptr) {\n+      continue;\n+    }\n+\n+    if (the_clone != x) {\n+      _igvn.remove_dead_node(the_clone);\n+    } else if (region->is_Loop() && i == LoopNode::LoopBackControl &&\n+               n->is_Load() && can_move_to_inner_loop(n, region->as_Loop(), x)) {\n+      \/\/ it is not a win if 'x' moved from an outer to an inner loop\n+      wins = 0;\n+      break;\n+    }\n@@ -221,0 +233,10 @@\n+\/\/ Test whether node 'x' can move into an inner loop relative to node 'n'.\n+\/\/ Note: The test is not exact. Returns true if 'x' COULD end up in an inner loop,\n+\/\/ BUT it can also return true and 'x' is in the outer loop\n+bool PhaseIdealLoop::can_move_to_inner_loop(Node* n, LoopNode* n_loop, Node* x) {\n+  IdealLoopTree* n_loop_tree = get_loop(n_loop);\n+  IdealLoopTree* x_loop_tree = get_loop(get_early_ctrl(x));\n+  \/\/ x_loop_tree should be outer or same loop as n_loop_tree\n+  return !x_loop_tree->is_member(n_loop_tree);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"}]}