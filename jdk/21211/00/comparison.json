{"files":[{"patch":"@@ -923,1 +923,4 @@\n-  static constexpr jlong deadline_ns = 30000; \/\/ 30 us\n+  jlong batch_start_time = 0;\n+  jlong batch_end_time = os::javaTimeNanos();    \/\/ This value will be treated as the initial batch_start_time\n+  \/\/ Process batches of regions until it has been 8 us since the last yield.\n+  static constexpr jlong deadline_ns = 8000;     \/\/ 8 us\n@@ -926,5 +929,2 @@\n-    os::naked_yield(); \/\/ Yield to allow allocators to take the lock\n-    ShenandoahHeapLocker locker(_heap->lock());\n-    const jlong deadline = os::javaTimeNanos() + deadline_ns;\n-    while (idx < count && os::javaTimeNanos() < deadline) {\n-      try_recycle_trashed(_trash_regions[idx++]);\n+    if (idx > 0) {\n+      os::naked_yield(); \/\/ Yield to allow allocators to take the lock, except on the first iteration\n@@ -932,0 +932,19 @@\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    \/\/ Avoid another call to javaTimeNanos() if we already know time at which last batch ended\n+    batch_start_time = batch_end_time;\n+    const jlong deadline = batch_start_time + deadline_ns;\n+    do {\n+      \/\/ Measurements suggest it typically takes less than 200 ns on average to recycle_trash() for a single region.\n+      \/\/ With an 8 us deadline and a 32-region batch, we find that we typically process 3 batches between yields.\n+      \/\/\n+      \/\/ Note that deadline is enforced since the end of previous batch.  In the case that yield() or acquisition of heap lock\n+      \/\/ takes a \"long time\", we will have less time to process regions, but we will always process at least one batch between\n+      \/\/ yields.  Yielding more frequently when there is heavy contention for the heap lock or for CPU cores is considered the\n+      \/\/ right thing to do.\n+      const size_t REGIONS_PER_BATCH = 32;\n+      size_t max_idx = MIN2(count, idx + REGIONS_PER_BATCH);\n+      while (idx < max_idx) {\n+        try_recycle_trashed(_trash_regions[idx++]);\n+      }\n+      batch_end_time = os::javaTimeNanos();\n+    } while ((idx < count) && (batch_end_time < deadline));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"}]}