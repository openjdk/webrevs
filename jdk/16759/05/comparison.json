{"files":[{"patch":"@@ -602,1 +602,1 @@\n-  \/\/ these classes are unloading.  Must be called\n+  \/\/ these classes are unloading.  This must be called\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-  void set_unloading_next(ClassLoaderData* unloading_next);\n-  ClassLoaderData* unloading_next() const;\n-\n@@ -193,0 +190,2 @@\n+\n+public:\n@@ -195,0 +194,5 @@\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n+  void unload();\n+\n+private:\n@@ -206,0 +210,2 @@\n+  void classes_do(void f(Klass* const));\n+\n@@ -207,1 +213,0 @@\n-  void unload();\n@@ -210,1 +215,0 @@\n-  void classes_do(void f(Klass* const));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -127,1 +128,0 @@\n-ClassLoaderData* ClassLoaderDataGraph::_unloading_head = nullptr;\n@@ -345,5 +345,1 @@\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _unloading_head; cld != nullptr; cld = cld->unloading_next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cld->classes_do(f);\n-  }\n+  ClassUnloadingContext::context()->classes_unloading_do(f);\n@@ -428,1 +424,2 @@\n-      data->unload();\n+\n+      ClassUnloadingContext::context()->register_unloading_class_loader_data(data);\n@@ -438,2 +435,0 @@\n-      data->set_unloading_next(_unloading_head);\n-      _unloading_head = data;\n@@ -472,10 +467,3 @@\n-  ClassLoaderData* list = _unloading_head;\n-  _unloading_head = nullptr;\n-  ClassLoaderData* next = list;\n-  bool classes_unloaded = false;\n-  while (next != nullptr) {\n-    ClassLoaderData* purge_me = next;\n-    next = purge_me->unloading_next();\n-    delete purge_me;\n-    classes_unloaded = true;\n-  }\n+  ClassUnloadingContext::context()->purge_class_loader_data();\n+\n+  bool classes_unloaded = ClassUnloadingContext::context()->has_unloaded_classes();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  \/\/ All unlinked CLDs\n-  static ClassLoaderData* _unloading_head;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  blob->flush();\n+  blob->purge();\n@@ -176,1 +176,1 @@\n-void CodeBlob::flush() {\n+void CodeBlob::purge(bool free_code_cache_data) {\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  virtual void flush();\n+  virtual void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -612,1 +613,1 @@\n-  get_code_heap(cb)->deallocate(cb);\n+  heap->deallocate(cb);\n@@ -968,30 +969,2 @@\n-\/\/ Register an is_unloading nmethod to be flushed after unlinking\n-void CodeCache::register_unlinked(nmethod* nm) {\n-  assert(nm->unlinked_next() == nullptr, \"Only register for unloading once\");\n-  for (;;) {\n-    \/\/ Only need acquire when reading the head, when the next\n-    \/\/ pointer is walked, which it is not here.\n-    nmethod* head = Atomic::load(&_unlinked_head);\n-    nmethod* next = head != nullptr ? head : nm; \/\/ Self looped means end of list\n-    nm->set_unlinked_next(next);\n-    if (Atomic::cmpxchg(&_unlinked_head, head, nm) == head) {\n-      break;\n-    }\n-  }\n-}\n-\n-\/\/ Flush all the nmethods the GC unlinked\n-void CodeCache::flush_unlinked_nmethods() {\n-  nmethod* nm = _unlinked_head;\n-  _unlinked_head = nullptr;\n-  size_t freed_memory = 0;\n-  while (nm != nullptr) {\n-    nmethod* next = nm->unlinked_next();\n-    freed_memory += nm->total_size();\n-    nm->flush();\n-    if (next == nm) {\n-      \/\/ Self looped means end of list\n-      break;\n-    }\n-    nm = next;\n-  }\n+\/\/ Restart compiler if possible and required..\n+void CodeCache::maybe_restart_compiler(size_t freed_memory) {\n@@ -1011,1 +984,0 @@\n-nmethod* volatile CodeCache::_unlinked_head = nullptr;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  static nmethod* volatile _unlinked_head;\n@@ -214,2 +213,1 @@\n-  static void flush_unlinked_nmethods();\n-  static void register_unlinked(nmethod* nm);\n+  static void maybe_restart_compiler(size_t freed_memory);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  virtual void flush() = 0;\n+  virtual void purge(bool free_code_cache_data = true) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -642,1 +643,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -786,1 +787,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -1409,1 +1410,1 @@\n-  if (_unlinked_next != nullptr) {\n+  if (_is_unlinked) {\n@@ -1443,1 +1444,1 @@\n-  CodeCache::register_unlinked(this);\n+  ClassUnloadingContext::context()->register_unlinked_nmethod(this);\n@@ -1446,1 +1447,1 @@\n-void nmethod::flush() {\n+void nmethod::purge(bool free_code_cache_data) {\n@@ -1469,2 +1470,4 @@\n-  CodeBlob::flush();\n-  CodeCache::free(this);\n+  CodeBlob::purge();\n+  if (free_code_cache_data) {\n+    CodeCache::free(this);\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  nmethod* _unlinked_next;\n+  bool _is_unlinked;\n@@ -444,2 +444,2 @@\n-  nmethod* unlinked_next() const                  { return _unlinked_next; }\n-  void set_unlinked_next(nmethod* next)           { _unlinked_next = next; }\n+  bool is_unlinked() const                        { return _is_unlinked; }\n+  void set_is_unlinked()                          { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n@@ -525,1 +525,1 @@\n-  void flush();\n+  void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1791,1 +1791,1 @@\n-    blob->flush();\n+    blob->purge();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -77,0 +77,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -775,4 +776,0 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n@@ -2491,0 +2488,27 @@\n+void G1CollectedHeap::unload_classes_and_code(const char* description, BoolObjectClosure* is_alive, GCTimer* timer) {\n+  GCTraceTime(Debug, gc, phases) debug(description, timer);\n+\n+  ClassUnloadingContext ctx(workers()->active_workers(),\n+                            false \/* lock_codeblob_free_separately *\/);\n+  {\n+    CodeCache::UnlinkingScope scope(is_alive);\n+    bool unloading_occurred = SystemDictionary::do_unloading(timer);\n+    GCTraceTime(Debug, gc, phases) t(\"G1 Complete Cleaning\", timer);\n+    complete_cleaning(unloading_occurred);\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", timer);\n+    ctx.purge_nmethods();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", timer);\n+    ctx.free_code_blobs();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", timer);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1270,0 +1270,2 @@\n+  void unload_classes_and_code(const char* description, BoolObjectClosure* cl, GCTimer* timer);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n@@ -1258,0 +1256,6 @@\n+    \/\/ Unload Klasses, String, Code Cache, etc.\n+    if (ClassUnloadingWithConcurrentMark) {\n+      G1CMIsAliveClosure is_alive(_g1h);\n+      _g1h->unload_classes_and_code(\"Class Unloading\", &is_alive, _gc_timer_cm);\n+    }\n+\n@@ -1295,6 +1299,0 @@\n-    \/\/ Clean out dead classes\n-    if (ClassUnloadingWithConcurrentMark) {\n-      GCTraceTime(Debug, gc, phases) debug(\"Purge Metaspace\", _gc_timer_cm);\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-    }\n-\n@@ -1628,3 +1626,0 @@\n-  \/\/ Is alive closure.\n-  G1CMIsAliveClosure g1_is_alive(_g1h);\n-\n@@ -1687,12 +1682,2 @@\n-    WeakProcessor::weak_oops_do(_g1h->workers(), &g1_is_alive, &do_nothing_cl, 1);\n-  }\n-\n-  \/\/ Unload Klasses, String, Code Cache, etc.\n-  if (ClassUnloadingWithConcurrentMark) {\n-    GCTraceTime(Debug, gc, phases) debug(\"Class Unloading\", _gc_timer_cm);\n-    {\n-      CodeCache::UnlinkingScope scope(&g1_is_alive);\n-      bool unloading_occurred = SystemDictionary::do_unloading(_gc_timer_cm);\n-      _g1h->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    G1CMIsAliveClosure is_alive(_g1h);\n+    WeakProcessor::weak_oops_do(_g1h->workers(), &is_alive, &do_nothing_cl, 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n@@ -44,0 +41,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -322,8 +320,1 @@\n-    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Class Unloading and Cleanup\", scope()->timer());\n-    {\n-      CodeCache::UnlinkingScope unloading_scope(&_is_alive);\n-      \/\/ Unload classes and purge the SystemDictionary.\n-      bool unloading_occurred = SystemDictionary::do_unloading(scope()->timer());\n-      _heap->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    _heap->unload_classes_and_code(\"Phase 1: Class Unloading and Cleanup\", &_is_alive, scope()->timer());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1027,3 +1028,6 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n+  {\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n@@ -1767,0 +1771,3 @@\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n@@ -2056,0 +2063,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -2067,2 +2076,9 @@\n-    \/\/ Release unloaded nmethods's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -203,0 +204,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -214,2 +217,9 @@\n-    \/\/ Release unloaded nmethod's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+ClassUnloadingContext* ClassUnloadingContext::_context = nullptr;\n+\n+ClassUnloadingContext::ClassUnloadingContext(uint num_workers, bool lock_codeblob_free_separately) :\n+  _cld_head(nullptr),\n+  _num_nmethod_unlink_workers(num_workers),\n+  _unlinked_nmethods(nullptr),\n+  _lock_codeblob_free_separately(lock_codeblob_free_separately) {\n+\n+  assert(_context == nullptr, \"context already set\");\n+  _context = this;\n+\n+  assert(num_workers > 0, \"must be\");\n+\n+  _unlinked_nmethods = NEW_C_HEAP_ARRAY(NMethodSet*, num_workers, mtGC);\n+  for (uint i = 0; i < num_workers; ++i) {\n+    _unlinked_nmethods[i] = new NMethodSet();\n+  }\n+}\n+\n+ClassUnloadingContext::~ClassUnloadingContext() {\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    delete _unlinked_nmethods[i];\n+  }\n+  FREE_C_HEAP_ARRAY(NMethodSet*, _unlinked_nmethods);\n+\n+  assert(_context == this, \"context not set correctly\");\n+  _context = nullptr;\n+}\n+\n+bool ClassUnloadingContext::has_unloaded_classes() const {\n+  return _cld_head != nullptr;\n+}\n+\n+void ClassUnloadingContext::register_unloading_class_loader_data(ClassLoaderData* cld) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  cld->unload();\n+\n+  cld->set_unloading_next(_cld_head);\n+  _cld_head = cld;\n+}\n+\n+void ClassUnloadingContext::purge_class_loader_data() {\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr;) {\n+    assert(cld->is_unloading(), \"invariant\");\n+\n+    ClassLoaderData* next = cld->unloading_next();\n+    delete cld;\n+    cld = next;\n+  }\n+}\n+\n+void ClassUnloadingContext::classes_unloading_do(void f(Klass* const)) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr; cld = cld->unloading_next()) {\n+    assert(cld->is_unloading(), \"invariant\");\n+    cld->classes_do(f);\n+  }\n+}\n+\n+void ClassUnloadingContext::register_unlinked_nmethod(nmethod* nm) {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  assert(!nm->is_unlinked(), \"Only register for unloading once\");\n+  assert(_num_nmethod_unlink_workers == 1 || Thread::current()->is_Worker_thread(), \"must be worker thread if parallel\");\n+\n+  uint worker_id = _num_nmethod_unlink_workers == 1 ? 0 : WorkerThread::worker_id();\n+  assert(worker_id < _num_nmethod_unlink_workers, \"larger than expected worker id %u\", worker_id);\n+\n+  _unlinked_nmethods[worker_id]->append(nm);\n+\n+  nm->set_is_unlinked();\n+}\n+\n+void ClassUnloadingContext::purge_nmethods() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  size_t freed_memory = 0;\n+\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    NMethodSet* set = _unlinked_nmethods[i];\n+    for (nmethod* nm : *set) {\n+      freed_memory += nm->size();\n+      nm->purge(false \/* free_code_cache_data *\/);\n+    }\n+  }\n+\n+  CodeCache::maybe_restart_compiler(freed_memory);\n+}\n+\n+void ClassUnloadingContext::free_code_blobs() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  \/\/ Sort nmethods before freeing to benefit from optimizations. If Nmethods were\n+  \/\/ collected in parallel, use a new temporary buffer for the result, otherwise\n+  \/\/ sort in-place.\n+  NMethodSet* nmethod_set = nullptr;\n+\n+  bool is_parallel = _num_nmethod_unlink_workers > 1;\n+\n+  \/\/ Merge all collected nmethods into a huge array.\n+  if (is_parallel) {\n+    int num_nmethods = 0;\n+\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      num_nmethods += _unlinked_nmethods[i]->length();\n+    }\n+    nmethod_set = new NMethodSet(num_nmethods);\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      nmethod_set->appendAll(_unlinked_nmethods[i]);\n+    }\n+  } else {\n+    nmethod_set = _unlinked_nmethods[0];\n+  }\n+\n+  \/\/ Sort by ascending address.\n+  auto sort_nmethods = [] (nmethod** a, nmethod** b) -> int {\n+    uintptr_t u_a = (uintptr_t)*a;\n+    uintptr_t u_b = (uintptr_t)*b;\n+    if (u_a == u_b) return 0;\n+    if (u_a < u_b) return -1;\n+    return 1;\n+  };\n+  nmethod_set->sort(sort_nmethods);\n+\n+  \/\/ And free. Duplicate loop for clarity depending on where we want the locking.\n+  if (_lock_codeblob_free_separately) {\n+    for (nmethod* nm : *nmethod_set) {\n+      MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      CodeCache::free(nm);\n+    }\n+  } else {\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    for (nmethod* nm : *nmethod_set) {\n+      CodeCache::free(nm);\n+    }\n+  }\n+\n+  if (is_parallel) {\n+    delete nmethod_set;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+#define SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ClassLoaderData;\n+class Klass;\n+class nmethod;\n+\n+class ClassUnloadingContext : public CHeapObj<mtGC> {\n+  static ClassUnloadingContext* _context;\n+\n+  ClassLoaderData* volatile _cld_head;\n+\n+  const uint _num_nmethod_unlink_workers;\n+\n+  using NMethodSet = GrowableArrayCHeap<nmethod*, mtGC>;\n+  NMethodSet** _unlinked_nmethods;\n+\n+  bool _lock_codeblob_free_separately;\n+\n+public:\n+  static ClassUnloadingContext* context() { assert(_context != nullptr, \"context not set\"); return _context; }\n+\n+  \/\/ Num_nmethod_unlink_workers configures the maximum numbers of threads unlinking\n+  \/\/     nmethods.\n+  \/\/ lock_codeblob_free_separately determines whether freeing the code blobs takes\n+  \/\/     the CodeCache_lock during the whole operation (=false) or per code blob\n+  \/\/     free operation (=true).\n+  ClassUnloadingContext(uint num_nmethod_unlink_workers,\n+                        bool lock_codeblob_free_separately);\n+  ~ClassUnloadingContext();\n+\n+  bool has_unloaded_classes() const;\n+\n+  void register_unloading_class_loader_data(ClassLoaderData* cld);\n+  void purge_class_loader_data();\n+\n+  void classes_unloading_do(void f(Klass* const));\n+\n+  \/\/ Register unloading nmethods, potentially in parallel.\n+  void register_unlinked_nmethod(nmethod* nm);\n+  void purge_nmethods();\n+  void free_code_blobs();\n+\n+  void purge_and_free_nmethods() {\n+    purge_nmethods();\n+    free_code_blobs();\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -525,0 +526,3 @@\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n@@ -540,1 +544,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -238,1 +239,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1827,0 +1828,3 @@\n+  ClassUnloadingContext ctx(_workers->active_workers(),\n+                            false \/* lock_codeblob_free_separately *\/);\n+\n@@ -1844,1 +1848,1 @@\n-    CodeCache::flush_unlinked_nmethods();\n+    ClassUnloadingContext::context()->purge_and_free_nmethods();\n@@ -1851,1 +1855,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -141,0 +142,3 @@\n+  ClassUnloadingContext ctx(heap->workers()->active_workers(),\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n@@ -184,1 +188,1 @@\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/false);\n+      ClassLoaderDataGraph::purge(false \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -323,0 +324,3 @@\n+  ClassUnloadingContext ctx(_workers.active_workers(),\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -365,1 +366,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1319,0 +1320,3 @@\n+  ClassUnloadingContext ctx(_workers.active_workers(),\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -446,1 +447,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}