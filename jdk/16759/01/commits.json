[{"commit":{"message":"iwalulya review, naming"},"files":[{"filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp"}],"sha":"448232df3b2644b6a2639850bcf245d0ab3e8520"},{"commit":{"message":"8317809 Insert code blobs in a sorted fashion to exploit the finger-optimization when adding, making this procedure O(n) instead of O(n^2)\n\nIntroduce a globally available ClassUnloadingContext that contains common methods pertaining to class and code unloading.\nGCs may use it to efficiently manage unlinked class loader datas and nmethods to allow use of common methods (unlink\/merge).\n\nThe steps typically are registering a new to be unlinked CLD\/nmethod, and then purge its memory later. STW collectors perform\nthis work in one big chunk taking the CodeCache_lock, for the entire duration, while concurrent collectors lock\/unlock for every\ninsertion to allow for concurrent users for the lock to progress.\n\nSome care has been taken to stay consistent with an \"unloading = unlinking + purge\" scheme; however particularly the existing\nCLD handling API (still) mixes unlinking and purging in its CLD::unload() call. To simplify this change that is mostly geared\ntowards separating nmethod unlinking from purging, to make code blob freeing O(n) instead of O(n^2).\n\nUpcoming changes will\n* separate nmethod unregistering from nmethod purging to allow doing that in bulk (for the STW collectors); that can significantly\n  reduce code purging time for the STW collectors.\n* better name the second stage of unlinking (called \"cleaning\" throughout, e.g. the work done in `G1CollectedHeap::complete_cleaning`)\n* untangle CLD unlinking and what's called \"cleaning\" now to allow moving more stuff into the second unlinking stage for better\n  parallelism\n* G1: move some signifcant tasks from the remark pause to concurrent (unregistering nmethods, freeing code blobs and cld\/metaspace purging)\n* Maybe move Serial\/Parallel GC metaspace purging closer to other unlinking\/purging code to keep things local and allow easier logging."},"files":[{"filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp"},{"filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp"},{"filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp"},{"filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"},{"filename":"src\/hotspot\/share\/code\/codeCache.cpp"},{"filename":"src\/hotspot\/share\/code\/codeCache.hpp"},{"filename":"src\/hotspot\/share\/code\/compiledMethod.hpp"},{"filename":"src\/hotspot\/share\/code\/nmethod.cpp"},{"filename":"src\/hotspot\/share\/code\/nmethod.hpp"},{"filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp"},{"filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp"},{"filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/x\/xNMethod.cpp"},{"filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp"},{"filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp"}],"sha":"d63ff4a4f681656ee7f50a936474b4566529a060"}]