{"files":[{"patch":"@@ -602,1 +602,1 @@\n-  \/\/ these classes are unloading.  Must be called\n+  \/\/ these classes are unloading.  This must be called\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-  void set_unloading_next(ClassLoaderData* unloading_next);\n-  ClassLoaderData* unloading_next() const;\n-\n@@ -193,0 +190,2 @@\n+\n+public:\n@@ -195,0 +194,5 @@\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n+  void unload();\n+\n+private:\n@@ -206,0 +210,2 @@\n+  void classes_do(void f(Klass* const));\n+\n@@ -207,1 +213,0 @@\n-  void unload();\n@@ -210,1 +215,0 @@\n-  void classes_do(void f(Klass* const));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -127,1 +128,0 @@\n-ClassLoaderData* ClassLoaderDataGraph::_unloading_head = nullptr;\n@@ -345,5 +345,1 @@\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _unloading_head; cld != nullptr; cld = cld->unloading_next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cld->classes_do(f);\n-  }\n+  ClassUnloadingContext::context()->classes_unloading_do(f);\n@@ -428,1 +424,2 @@\n-      data->unload();\n+\n+      ClassUnloadingContext::context()->register_unloading_class_loader_data(data);\n@@ -438,2 +435,0 @@\n-      data->set_unloading_next(_unloading_head);\n-      _unloading_head = data;\n@@ -472,10 +467,3 @@\n-  ClassLoaderData* list = _unloading_head;\n-  _unloading_head = nullptr;\n-  ClassLoaderData* next = list;\n-  bool classes_unloaded = false;\n-  while (next != nullptr) {\n-    ClassLoaderData* purge_me = next;\n-    next = purge_me->unloading_next();\n-    delete purge_me;\n-    classes_unloaded = true;\n-  }\n+  ClassUnloadingContext::context()->purge_class_loader_data();\n+\n+  bool classes_unloaded = ClassUnloadingContext::context()->has_unloaded_classes();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  \/\/ All unlinked CLDs\n-  static ClassLoaderData* _unloading_head;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  blob->flush();\n+  blob->purge();\n@@ -176,1 +176,1 @@\n-void CodeBlob::flush() {\n+void CodeBlob::purge(bool free_code_cache_data) {\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  virtual void flush();\n+  virtual void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -612,1 +613,1 @@\n-  get_code_heap(cb)->deallocate(cb);\n+  heap->deallocate(cb);\n@@ -968,30 +969,2 @@\n-\/\/ Register an is_unloading nmethod to be flushed after unlinking\n-void CodeCache::register_unlinked(nmethod* nm) {\n-  assert(nm->unlinked_next() == nullptr, \"Only register for unloading once\");\n-  for (;;) {\n-    \/\/ Only need acquire when reading the head, when the next\n-    \/\/ pointer is walked, which it is not here.\n-    nmethod* head = Atomic::load(&_unlinked_head);\n-    nmethod* next = head != nullptr ? head : nm; \/\/ Self looped means end of list\n-    nm->set_unlinked_next(next);\n-    if (Atomic::cmpxchg(&_unlinked_head, head, nm) == head) {\n-      break;\n-    }\n-  }\n-}\n-\n-\/\/ Flush all the nmethods the GC unlinked\n-void CodeCache::flush_unlinked_nmethods() {\n-  nmethod* nm = _unlinked_head;\n-  _unlinked_head = nullptr;\n-  size_t freed_memory = 0;\n-  while (nm != nullptr) {\n-    nmethod* next = nm->unlinked_next();\n-    freed_memory += nm->total_size();\n-    nm->flush();\n-    if (next == nm) {\n-      \/\/ Self looped means end of list\n-      break;\n-    }\n-    nm = next;\n-  }\n+\/\/ Restart compiler if possible and required..\n+void CodeCache::maybe_restart_compiler(size_t freed_memory) {\n@@ -1011,1 +984,0 @@\n-nmethod* volatile CodeCache::_unlinked_head = nullptr;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  static nmethod* volatile _unlinked_head;\n@@ -214,2 +213,1 @@\n-  static void flush_unlinked_nmethods();\n-  static void register_unlinked(nmethod* nm);\n+  static void maybe_restart_compiler(size_t freed_memory);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  virtual void flush() = 0;\n+  virtual void purge(bool free_code_cache_data = true) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -642,1 +643,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -786,1 +787,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -1409,1 +1410,1 @@\n-  if (_unlinked_next != nullptr) {\n+  if (_is_unlinked) {\n@@ -1443,1 +1444,1 @@\n-  CodeCache::register_unlinked(this);\n+  ClassUnloadingContext::context()->register_unlinked_nmethod(this);\n@@ -1446,1 +1447,1 @@\n-void nmethod::flush() {\n+void nmethod::purge(bool free_code_cache_data) {\n@@ -1469,2 +1470,4 @@\n-  CodeBlob::flush();\n-  CodeCache::free(this);\n+  CodeBlob::purge();\n+  if (free_code_cache_data) {\n+    CodeCache::free(this);\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  nmethod* _unlinked_next;\n+  bool _is_unlinked;\n@@ -444,2 +444,2 @@\n-  nmethod* unlinked_next() const                  { return _unlinked_next; }\n-  void set_unlinked_next(nmethod* next)           { _unlinked_next = next; }\n+  bool is_unlinked() const                        { return _is_unlinked; }\n+  void set_is_unlinked()                          { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n@@ -525,1 +525,1 @@\n-  void flush();\n+  void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1797,1 +1797,1 @@\n-    blob->flush();\n+    blob->purge();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -77,0 +77,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -851,4 +852,0 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n@@ -2598,0 +2595,27 @@\n+void G1CollectedHeap::unload_classes_and_code(const char* description, BoolObjectClosure* is_alive, GCTimer* timer) {\n+  GCTraceTime(Debug, gc, phases) debug(description, timer);\n+\n+  DefaultClassUnloadingContext ctx(workers()->active_workers(),\n+                                   false \/* lock_codeblob_free_separately *\/);\n+  {\n+    CodeCache::UnlinkingScope scope(is_alive);\n+    bool unloading_occurred = SystemDictionary::do_unloading(timer);\n+    GCTraceTime(Debug, gc, phases) t(\"G1 Complete Cleaning\", timer);\n+    complete_cleaning(unloading_occurred);\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", timer);\n+    ctx.purge_nmethods();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", timer);\n+    ctx.free_code_blobs();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", timer);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1267,0 +1267,2 @@\n+  void unload_classes_and_code(const char* description, BoolObjectClosure* cl, GCTimer* timer);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n@@ -1302,6 +1300,0 @@\n-    \/\/ Clean out dead classes\n-    if (ClassUnloadingWithConcurrentMark) {\n-      GCTraceTime(Debug, gc, phases) debug(\"Purge Metaspace\", _gc_timer_cm);\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-    }\n-\n@@ -1632,3 +1624,0 @@\n-  \/\/ Is alive closure.\n-  G1CMIsAliveClosure g1_is_alive(_g1h);\n-\n@@ -1689,0 +1678,1 @@\n+  G1CMIsAliveClosure is_alive(_g1h);\n@@ -1691,1 +1681,1 @@\n-    WeakProcessor::weak_oops_do(_g1h->workers(), &g1_is_alive, &do_nothing_cl, 1);\n+    WeakProcessor::weak_oops_do(_g1h->workers(), &is_alive, &do_nothing_cl, 1);\n@@ -1696,7 +1686,1 @@\n-    GCTraceTime(Debug, gc, phases) debug(\"Class Unloading\", _gc_timer_cm);\n-    {\n-      CodeCache::UnlinkingScope scope(&g1_is_alive);\n-      bool unloading_occurred = SystemDictionary::do_unloading(_gc_timer_cm);\n-      _g1h->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    _g1h->unload_classes_and_code(\"Class Unloading\", &is_alive, _gc_timer_cm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n@@ -44,0 +41,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -322,8 +320,1 @@\n-    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Class Unloading and Cleanup\", scope()->timer());\n-    {\n-      CodeCache::UnlinkingScope unloading_scope(&_is_alive);\n-      \/\/ Unload classes and purge the SystemDictionary.\n-      bool unloading_occurred = SystemDictionary::do_unloading(scope()->timer());\n-      _heap->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    _heap->unload_classes_and_code(\"Phase 1: Class Unloading and Cleanup\", &_is_alive, scope()->timer());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1027,3 +1028,6 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n+  {\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n@@ -1767,0 +1771,3 @@\n+    DefaultClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                                     false \/* lock_codeblob_free_separately *\/);\n+\n@@ -2056,0 +2063,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -2067,2 +2076,9 @@\n-    \/\/ Release unloaded nmethods's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -203,0 +204,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -214,2 +217,9 @@\n-    \/\/ Release unloaded nmethod's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+ClassUnloadingContext* ClassUnloadingContext::_context = nullptr;\n+\n+ClassUnloadingContext::ClassUnloadingContext() {\n+  assert(_context == nullptr, \"context already set\");\n+  _context = this;\n+}\n+\n+ClassUnloadingContext::~ClassUnloadingContext() {\n+  assert(_context == this, \"context not set correctly\");\n+  _context = nullptr;\n+}\n+\n+\n+DefaultClassUnloadingContext::DefaultClassUnloadingContext(uint num_workers, bool lock_codeblob_free_separately) :\n+  ClassUnloadingContext(),\n+  _cld_head(nullptr),\n+  _num_nmethod_unlink_workers(num_workers),\n+  _unlinked_nmethods(nullptr),\n+  _lock_codeblob_free_separately(lock_codeblob_free_separately) {\n+\n+  assert(num_workers > 0, \"must be\");\n+\n+  _unlinked_nmethods = NEW_C_HEAP_ARRAY(NmethodSet*, num_workers, mtGC);\n+  for (uint i = 0; i < num_workers; ++i) {\n+    _unlinked_nmethods[i] = new NmethodSet();\n+  }\n+}\n+\n+DefaultClassUnloadingContext::~DefaultClassUnloadingContext() {\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    delete _unlinked_nmethods[i];\n+  }\n+  FREE_C_HEAP_ARRAY(NmethodSet*, _unlinked_nmethods);\n+}\n+\n+bool DefaultClassUnloadingContext::has_unloaded_classes() const {\n+  return _cld_head != nullptr;\n+}\n+\n+void DefaultClassUnloadingContext::register_unloading_class_loader_data(ClassLoaderData* cld) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  cld->unload();\n+\n+  cld->set_unloading_next(_cld_head);\n+  _cld_head = cld;\n+}\n+\n+void DefaultClassUnloadingContext::purge_class_loader_data() {\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr;) {\n+    assert(cld->is_unloading(), \"invariant\");\n+\n+    ClassLoaderData* next = cld->unloading_next();\n+    delete cld;\n+    cld = next;\n+  }\n+}\n+\n+void DefaultClassUnloadingContext::classes_unloading_do(void f(Klass* const)) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr; cld = cld->unloading_next()) {\n+    assert(cld->is_unloading(), \"invariant\");\n+    cld->classes_do(f);\n+  }\n+}\n+\n+void DefaultClassUnloadingContext::register_unlinked_nmethod(nmethod* nm) {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  assert(!nm->is_unlinked(), \"Only register for unloading once\");\n+  assert(_num_nmethod_unlink_workers == 1 || Thread::current()->is_Worker_thread(), \"must be worker thread if parallel\");\n+\n+  uint worker_id = _num_nmethod_unlink_workers == 1 ? 0 : WorkerThread::worker_id();\n+  assert(worker_id < _num_nmethod_unlink_workers, \"larger than expected worker id %u\", worker_id);\n+\n+  _unlinked_nmethods[worker_id]->append(nm);\n+\n+  nm->set_is_unlinked();\n+}\n+\n+void DefaultClassUnloadingContext::purge_nmethods() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  size_t freed_memory = 0;\n+\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    NmethodSet* set = _unlinked_nmethods[i];\n+    for (int j = 0; j < set->length(); ++j) {\n+      nmethod* nm = set->at(j);\n+      freed_memory += nm->size();\n+      nm->purge(false \/* free_code_cache_data *\/);\n+    }\n+  }\n+\n+  CodeCache::maybe_restart_compiler(freed_memory);\n+}\n+\n+void DefaultClassUnloadingContext::free_code_blobs() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  \/\/ Sort nmethods before freeing to benefit from optimizations. If Nmethods were\n+  \/\/ collected in parallel, use a new temporary buffer for the result, otherwise\n+  \/\/ sort in-place.\n+  NmethodSet* all = nullptr;\n+\n+  bool is_parallel = _num_nmethod_unlink_workers != 1;\n+\n+  \/\/ Merge all collected nmethods into a huge array.\n+  if (is_parallel) {\n+    int num_nmethods = 0;\n+\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      num_nmethods += _unlinked_nmethods[i]->length();\n+    }\n+    all = new NmethodSet(num_nmethods);\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      all->appendAll(_unlinked_nmethods[i]);\n+    }\n+  } else {\n+    all = _unlinked_nmethods[0];\n+  }\n+\n+  \/\/ Sort by ascending address.\n+  auto sort_nmethods = [] (nmethod** a, nmethod** b) -> int {\n+    uintptr_t u_a = (uintptr_t)*a;\n+    uintptr_t u_b = (uintptr_t)*b;\n+    if (u_a == u_b) return 0;\n+    if (u_a < u_b) return -1;\n+    return 1;\n+  };\n+  all->sort(sort_nmethods);\n+\n+  \/\/ And free.\n+  {\n+    ConditionalMutexLocker ml_outer(CodeCache_lock, !_lock_codeblob_free_separately, Mutex::_no_safepoint_check_flag);\n+    for (int i = 0; i < all->length(); ++i) {\n+      ConditionalMutexLocker ml_inner(CodeCache_lock, _lock_codeblob_free_separately, Mutex::_no_safepoint_check_flag);\n+      CodeCache::free(all->at(i));\n+    }\n+  }\n+\n+  if (is_parallel) {\n+    delete all;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+#define SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ClassLoaderData;\n+class Klass;\n+class nmethod;\n+\n+class ClassUnloadingContext : public CHeapObj<mtGC> {\n+protected:\n+  static ClassUnloadingContext* _context;\n+\n+  ClassUnloadingContext();\n+  virtual ~ClassUnloadingContext();\n+\n+public:\n+  static ClassUnloadingContext* context() { assert(_context != nullptr, \"context not set\"); return _context; }\n+\n+  \/\/ Has class unloading occurred?\n+  virtual bool has_unloaded_classes() const = 0;\n+\n+  virtual void register_unloading_class_loader_data(ClassLoaderData* cld) = 0;\n+  virtual void purge_class_loader_data() = 0;\n+\n+  \/\/ Apply f on all Klasses of all unloading ClassLoaderDatas.\n+  virtual void classes_unloading_do(void f(Klass* const)) = 0;\n+\n+  virtual void register_unlinked_nmethod(nmethod* nm) = 0;\n+  virtual void purge_nmethods() = 0;\n+  virtual void free_code_blobs() = 0;\n+\n+  void purge_and_free_nmethods() {\n+    purge_nmethods();\n+    free_code_blobs();\n+  }\n+};\n+\n+class DefaultClassUnloadingContext : public ClassUnloadingContext {\n+  ClassLoaderData* volatile _cld_head;\n+\n+  uint _num_nmethod_unlink_workers;\n+\n+  using NmethodSet = GrowableArrayCHeap<nmethod*, mtGC>;\n+  NmethodSet** _unlinked_nmethods;\n+\n+  bool _lock_codeblob_free_separately;\n+\n+public:\n+  \/\/ Num_nmethod_unlink_workers configures the maximum numbers of threads unlinking\n+  \/\/     nmethods.\n+  \/\/ lock_codeblob_free_separately determines whether freeing the code blobs takes\n+  \/\/     the CodeCache_lock during the whole operation or per code blob free operation.\n+  DefaultClassUnloadingContext(uint num_nmethod_unlink_workers,\n+                               bool lock_codeblob_free_separately);\n+  ~DefaultClassUnloadingContext();\n+\n+  bool has_unloaded_classes() const override;\n+\n+  void register_unloading_class_loader_data(ClassLoaderData* cld) override;\n+  void purge_class_loader_data() override;\n+\n+  void classes_unloading_do(void f(Klass* const)) override;\n+\n+  \/\/ Register unloading nmethods, potentially in parallel.\n+  void register_unlinked_nmethod(nmethod* nm) override;\n+  void purge_nmethods() override;\n+  void free_code_blobs() override;\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -541,0 +542,3 @@\n+    DefaultClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                                     false \/* lock_codeblob_free_separately *\/);\n+\n@@ -556,1 +560,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -238,1 +239,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1827,0 +1828,3 @@\n+  DefaultClassUnloadingContext ctx(_workers->active_workers(),\n+                                   false \/* lock_codeblob_free_separately *\/);\n+\n@@ -1844,1 +1848,1 @@\n-    CodeCache::flush_unlinked_nmethods();\n+    ClassUnloadingContext::context()->purge_and_free_nmethods();\n@@ -1851,1 +1855,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -141,0 +142,3 @@\n+  DefaultClassUnloadingContext ctx(heap->workers()->active_workers(),\n+                                   true \/* lock_codeblob_free_separately *\/);\n+\n@@ -184,1 +188,1 @@\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/false);\n+      ClassLoaderDataGraph::purge(false \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -323,0 +324,3 @@\n+  DefaultClassUnloadingContext ctx(_workers.active_workers(),\n+                                   true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -365,1 +366,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1319,0 +1320,3 @@\n+  DefaultClassUnloadingContext ctx(_workers.active_workers(),\n+                                   true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -446,1 +447,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}