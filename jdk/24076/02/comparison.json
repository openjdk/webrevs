{"files":[{"patch":"@@ -137,1 +137,1 @@\n-int G1CSetCandidateGroup::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CollectionSetCandidateInfo::compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -149,2 +149,3 @@\n-  size_t reclaimable1 = ci1->_r->reclaimable_bytes();\n-  size_t reclaimable2 = ci2->_r->reclaimable_bytes();\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  size_t gc_efficiency1 = p->predict_gc_efficiency(ci1->_r);\n+  size_t gc_efficiency2 = p->predict_gc_efficiency(ci2->_r);\n@@ -152,1 +153,1 @@\n-  if (reclaimable1 > reclaimable2) {\n+  if (gc_efficiency1 > gc_efficiency2) {\n@@ -154,1 +155,1 @@\n-  } else if (reclaimable1 < reclaimable2) {\n+  } else if (gc_efficiency1 < gc_efficiency2) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+\n+  static int compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -109,2 +111,0 @@\n-  static int compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    void sort_by_reclaimable_bytes() {\n+    void sort_by_gc_efficiency() {\n@@ -106,1 +106,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CSetCandidateGroup::compare_reclaimble_bytes);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionSetCandidateInfo::compare_region_gc_efficiency);\n@@ -250,1 +250,1 @@\n-    _result.sort_by_reclaimable_bytes();\n+    _result.sort_by_gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1291,1 +1291,2 @@\n-        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(hr->hrm_index()));\n+        uint region_idx = hr->hrm_index();\n+        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(region_idx), _cm->incoming_refs(region_idx));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -565,0 +565,2 @@\n+  \/\/ Approximate number of incoming references found during marking.\n+  size_t incoming_refs(uint region) const { return _region_mark_stats[region]._incoming_refs; }\n@@ -955,0 +957,2 @@\n+  inline void inc_incoming_refs(oop const obj);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,0 +231,4 @@\n+inline void G1CMTask::inc_incoming_refs(oop const obj) {\n+  _mark_stats_cache.inc_incoming_refs(_g1h->addr_to_region(obj));\n+}\n+\n@@ -291,0 +295,4 @@\n+\n+  if (!G1HeapRegion::is_in_same_region(p, obj)) {\n+    inc_incoming_refs(obj);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  _incoming_refs = 0;\n@@ -242,0 +243,1 @@\n+  _incoming_refs(0),\n@@ -281,0 +283,1 @@\n+  _incoming_refs = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -240,0 +240,4 @@\n+  \/\/ Approximate number of references to this regions at the end of concurrent\n+  \/\/ marking. We we do not mark through all objects, so this is an estimate.\n+  size_t _incoming_refs;\n+\n@@ -342,0 +346,2 @@\n+  size_t incoming_refs() { return _incoming_refs; }\n+\n@@ -354,3 +360,3 @@\n-  \/\/ Notify the region that concurrent marking has finished. Passes TAMS and the number of\n-  \/\/ bytes marked between bottom and TAMS.\n-  inline void note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes);\n+  \/\/ Notify the region that concurrent marking has finished. Passes TAMS, the number of\n+  \/\/ bytes marked between bottom and TAMS, and the estimate for incoming references.\n+  inline void note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes, size_t incoming_refs);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  _incoming_refs = 0;\n+\n@@ -266,1 +268,1 @@\n-inline void G1HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes) {\n+inline void G1HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes, size_t incoming_refs) {\n@@ -271,0 +273,1 @@\n+    _incoming_refs = incoming_refs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1110,0 +1110,9 @@\n+double G1Policy::predict_gc_efficiency(G1HeapRegion* hr) {\n+\n+  double total_based_on_incoming_refs_ms = predict_merge_scan_time(hr->incoming_refs()) + \/\/ We use the number of incoming references as an estimate for remset cards.\n+                                           predict_non_young_other_time_ms(1) +\n+                                           predict_region_copy_time_ms(hr, false \/* for_young_only_phase *\/);\n+\n+  return hr->reclaimable_bytes() \/ total_based_on_incoming_refs_ms;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -246,0 +246,4 @@\n+  \/\/ GC efficiency for collecting the region based on the time estimate for\n+  \/\/ merging and scanning incoming references.\n+  double predict_gc_efficiency(G1HeapRegion* hr);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ This includes\n+\/\/ These include:\n@@ -38,2 +38,4 @@\n-\/\/ to tams. This is an exact measure.\n-\/\/ The code corrects later for the live data between tams and top.\n+\/\/   to tams. This is an exact measure. The code corrects later for the live data\n+\/\/   between tams and top.\n+\/\/ * the number of incoming references found during marking. This is an approximate\n+\/\/   value because we do not mark through all objects.\n@@ -42,0 +44,1 @@\n+  size_t _incoming_refs;\n@@ -46,0 +49,1 @@\n+    _incoming_refs = 0;\n@@ -47,2 +51,3 @@\n-  \/\/ Clear all members after a marking overflow. Nothing to do as the live words\n-  \/\/ are updated by the atomic mark. We do not remark objects after overflow.\n+  \/\/ Clear all members after a marking overflow. Only needs to clear the number of\n+  \/\/ incoming references as all objects will be rescanned, while the live words are\n+  \/\/ gathered whenever a thread can mark an object, which is synchronized.\n@@ -50,0 +55,1 @@\n+    _incoming_refs = 0;\n@@ -110,0 +116,5 @@\n+  void inc_incoming_refs(uint region_idx) {\n+    G1RegionMarkStatsCacheEntry* const cur = find_for_add(region_idx);\n+    cur->_stats._incoming_refs++;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+\n+  if (cur->_stats._incoming_refs != 0) {\n+    Atomic::add(&_target[cur->_region_idx]._incoming_refs, cur->_stats._incoming_refs);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}