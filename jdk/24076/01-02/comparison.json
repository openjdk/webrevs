{"files":[{"patch":"@@ -149,2 +149,3 @@\n-  size_t reclaimable1 = ci1->_r->gc_efficiency();\n-  size_t reclaimable2 = ci2->_r->gc_efficiency();\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  size_t gc_efficiency1 = p->predict_gc_efficiency(ci1->_r);\n+  size_t gc_efficiency2 = p->predict_gc_efficiency(ci2->_r);\n@@ -152,1 +153,1 @@\n-  if (reclaimable1 > reclaimable2) {\n+  if (gc_efficiency1 > gc_efficiency2) {\n@@ -154,1 +155,1 @@\n-  } else if (reclaimable1 < reclaimable2) {\n+  } else if (gc_efficiency1 < gc_efficiency2) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -341,18 +341,0 @@\n-\n-double G1HeapRegion::total_based_on_incoming_refs_ms() {\n-\n-  G1Policy* p = G1CollectedHeap::heap()->policy();\n-\n-  double merge_scan_time_ms = p->predict_merge_scan_time(_incoming_refs); \/\/ We use the number of incoming references as an estimate for remset cards.\n-  double non_young_other_time_ms = p->predict_non_young_other_time_ms(1);\n-  double predicted_copy_time_ms = p->predict_region_copy_time_ms(this, false \/* for_young_only_phase *\/);\n-\n-  return merge_scan_time_ms +\n-         non_young_other_time_ms +\n-         predicted_copy_time_ms;\n-}\n-\n-double G1HeapRegion::gc_efficiency() {\n-  return reclaimable_bytes() \/ total_based_on_incoming_refs_ms();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -346,8 +346,0 @@\n-  \/\/ Total collection pause time if we use incoming references as an\n-  \/\/ estimate for remembered set cards.\n-  double total_based_on_incoming_refs_ms();\n-\n-  \/\/ GC efficiency for collecting this region based on the time estimate in\n-  \/\/ total_based_on_incoming_refs_ms.\n-  double gc_efficiency();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1110,0 +1110,9 @@\n+double G1Policy::predict_gc_efficiency(G1HeapRegion* hr) {\n+\n+  double total_based_on_incoming_refs_ms = predict_merge_scan_time(hr->incoming_refs()) + \/\/ We use the number of incoming references as an estimate for remset cards.\n+                                           predict_non_young_other_time_ms(1) +\n+                                           predict_region_copy_time_ms(hr, false \/* for_young_only_phase *\/);\n+\n+  return hr->reclaimable_bytes() \/ total_based_on_incoming_refs_ms;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -246,0 +246,4 @@\n+  \/\/ GC efficiency for collecting the region based on the time estimate for\n+  \/\/ merging and scanning incoming references.\n+  double predict_gc_efficiency(G1HeapRegion* hr);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}