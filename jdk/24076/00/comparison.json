{"files":[{"patch":"@@ -137,1 +137,1 @@\n-int G1CSetCandidateGroup::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CollectionSetCandidateInfo::compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -149,2 +149,2 @@\n-  size_t reclaimable1 = ci1->_r->reclaimable_bytes();\n-  size_t reclaimable2 = ci2->_r->reclaimable_bytes();\n+  size_t reclaimable1 = ci1->_r->gc_efficiency();\n+  size_t reclaimable2 = ci2->_r->gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+\n+  static int compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -109,2 +111,0 @@\n-  static int compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    void sort_by_reclaimable_bytes() {\n+    void sort_by_gc_efficiency() {\n@@ -106,1 +106,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CSetCandidateGroup::compare_reclaimble_bytes);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionSetCandidateInfo::compare_gc_efficiency);\n@@ -250,1 +250,1 @@\n-    _result.sort_by_reclaimable_bytes();\n+    _result.sort_by_gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1291,1 +1291,1 @@\n-        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(hr->hrm_index()));\n+        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(hr->hrm_index()), _cm->incoming_refs(hr->hrm_index()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -566,0 +566,2 @@\n+  size_t incoming_refs(uint region) const { return _region_mark_stats[region]._incoming_refs; }\n+\n@@ -955,0 +957,2 @@\n+  inline void inc_incoming_refs(oop const obj);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,0 +231,4 @@\n+inline void G1CMTask::inc_incoming_refs(oop const obj) {\n+  _mark_stats_cache.inc_incoming_refs(_g1h->addr_to_region(obj));\n+}\n+\n@@ -291,0 +295,4 @@\n+\n+  if (!G1HeapRegion::is_in_same_region(p, obj)) {\n+    inc_incoming_refs(obj);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  _incoming_refs = 0;\n@@ -242,0 +243,1 @@\n+  _incoming_refs(0),\n@@ -281,0 +283,1 @@\n+  _incoming_refs = 0;\n@@ -338,0 +341,18 @@\n+\n+double G1HeapRegion::total_based_on_incoming_refs_ms() {\n+\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+  double merge_scan_time_ms = p->predict_merge_scan_time(_incoming_refs); \/\/ We use _incoming_refs as an estimate for remset cards\n+  double non_young_other_time_ms = p->predict_non_young_other_time_ms(1);\n+  double predicted_copy_time_ms = p->predict_region_copy_time_ms(this, false \/* for_young_only_phase *\/);\n+\n+  return merge_scan_time_ms +\n+         non_young_other_time_ms +\n+         predicted_copy_time_ms;\n+}\n+\n+double G1HeapRegion::gc_efficiency() {\n+  return reclaimable_bytes() \/ total_based_on_incoming_refs_ms();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -240,0 +240,4 @@\n+  \/\/ Approximate number of references to this regions at the end of concurrent\n+  \/\/ marking. We we do not mark through all objects, so this is an estimate.\n+  size_t _incoming_refs;\n+\n@@ -342,0 +346,10 @@\n+  \/\/ Total collection pause time if we use incoming references as an\n+  \/\/ estimate for remembered set cards.\n+  double total_based_on_incoming_refs_ms();\n+\n+  \/\/ GC Efficiency for collecting this region based on the time estimate in\n+  \/\/ total_based_on_incoming_refs_ms.\n+  double gc_efficiency();\n+\n+  size_t incoming_refs() { return _incoming_refs; }\n+\n@@ -356,1 +370,1 @@\n-  inline void note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes);\n+  inline void note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes, size_t incoming_refs);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -159,0 +159,2 @@\n+  _incoming_refs = 0;\n+\n@@ -266,1 +268,1 @@\n-inline void G1HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes) {\n+inline void G1HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes, size_t incoming_refs) {\n@@ -271,0 +273,1 @@\n+    _incoming_refs = incoming_refs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  size_t _incoming_refs;\n@@ -46,0 +47,1 @@\n+    _incoming_refs = 0;\n@@ -47,2 +49,3 @@\n-  \/\/ Clear all members after a marking overflow. Nothing to do as the live words\n-  \/\/ are updated by the atomic mark. We do not remark objects after overflow.\n+  \/\/ Clear all members after a marking overflow. Only needs to clear the number of\n+  \/\/ incoming references as all objects will be rescanned, while the live words are\n+  \/\/ gathered whenever a thread can mark an object, which is synchronized.\n@@ -50,0 +53,1 @@\n+    _incoming_refs = 0;\n@@ -110,0 +114,5 @@\n+  void inc_incoming_refs(uint region_idx) {\n+    G1RegionMarkStatsCacheEntry* const cur = find_for_add(region_idx);\n+    cur->_stats._incoming_refs++;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+\n+  if (cur->_stats._incoming_refs != 0) {\n+    Atomic::add(&_target[cur->_region_idx]._incoming_refs, cur->_stats._incoming_refs);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}