{"files":[{"patch":"@@ -1601,0 +1601,3 @@\n+\n+        \/\/module readability is reflexive:\n+        msym.readModules.add(msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.modle)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8328481 8332236\n+ * @bug 8328481 8332236 8332890\n@@ -744,0 +744,56 @@\n+    @Test \/\/JDK-8332890\n+    public void testModuleInfoSelfImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          import module M;\n+                          module M {\n+                             exports p1 to M1;\n+                             exports p2;\n+                             exports p3 to M;\n+                             uses A;\n+                             uses B;\n+                             uses C;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package p1;\n+                          public class A {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package p2;\n+                          public class B {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package p3;\n+                          public class C {}\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n+                \"module-info.java:6:9: compiler.err.cant.resolve: kindname.class, A, , \",\n+                \"- compiler.note.preview.filename: module-info.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\",\n+                \"1 warning\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"}]}