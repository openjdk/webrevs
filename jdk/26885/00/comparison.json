{"files":[{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8359412\n+ * @summary Use the template framework library to generate random expressions.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/lib\/verify\/Verify.java\n+ * @run main compiler.igvn.ExpressionFuzzer\n+ *\/\n+\n+package compiler.igvn;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.Random;\n+import java.util.Collections;\n+import jdk.test.lib.Utils;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.Expression;\n+import compiler.lib.template_framework.library.Operations;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+import static compiler.lib.template_framework.library.CodeGenerationDataNameType.PRIMITIVE_TYPES;\n+\n+\/\/ We generate random Expressions from primitive type operators.\n+\/\/\n+\/\/ The goal is to generate random inputs with constrained TypeInt \/ TypeLong ranges \/ KnownBits,\n+\/\/ and then verify the output value, ranges and bits.\n+\/\/\n+\/\/ Should this test fail and make a lot of noise in the CI, you have two choices:\n+\/\/ - Problem-list this test: but other tests may also use the same broken operators.\n+\/\/ - Temporarily remove the operator from {@code Operations.PRIMITIVE_OPERATIONS}.\n+\/\/\n+\/\/ Future Work [FUTURE]:\n+\/\/ - Constrain also the unsigned bounds\n+\/\/ - Some basic IR tests to ensure that the constraints \/ checksum mechanics work.\n+\/\/   We may even have to add some IGVN optimizations to be able to better observe things right.\n+public class ExpressionFuzzer {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static record MethodArgument(String name, CodeGenerationDataNameType type) {}\n+    public static record StringPair(String s0, String s1) {}\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.igvn.templated.ExpressionFuzzerInnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ compiler.igvn.templated.InnterTest.main(new String[] {});\n+        comp.invoke(\"compiler.igvn.templated.ExpressionFuzzerInnerTest\", \"main\", new Object[] {new String[] {}});\n+    }\n+\n+    \/\/ Generate a Java source file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Generate a list of test methods.\n+        List<TemplateToken> tests = new ArrayList<>();\n+\n+        \/\/ We are going to use some random numbers in our tests, so import some good methods for that.\n+        tests.add(PrimitiveType.generateLibraryRNG());\n+\n+        \/\/ Create the body for the test. We use it twice: compiled and reference.\n+        \/\/ Execute the expression and catch expected Exceptions.\n+        var bodyTemplate = Template.make(\"expression\", \"arguments\", \"checksum\", (Expression expression, List<Object> arguments, String checksum) -> body(\n+            \"\"\"\n+            try {\n+            \"\"\",\n+            \"var val = \", expression.asToken(arguments), \";\\n\",\n+            \"return #checksum(val);\\n\",\n+            expression.info.exceptions.stream().map(exception ->\n+                \"} catch (\" + exception + \" e) { return e;\\n\"\n+            ).toList(),\n+            \"\"\"\n+            } finally {\n+                \/\/ Just so that javac is happy if there are no exceptions to catch.\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Machinery for the \"checksum\" method.\n+        \/\/\n+        \/\/ We want to do output verification. We don't just want to check if the output value is correct,\n+        \/\/ but also if the signed\/unsigned\/KnownBits are correct of the TypeInt and TypeLong. For this,\n+        \/\/ we add some comparisons. If we get the ranges\/bits wrong (too tight), then the comparisons\n+        \/\/ can wrongly constant fold, and we can detect that in the output array.\n+        List<StringPair> unsignedCmp = List.of(\n+            new StringPair(\"(val < \", \")\"),\n+            new StringPair(\"(val > \", \")\"),\n+            new StringPair(\"(val >= \", \")\"),\n+            new StringPair(\"(val <= \", \")\"),\n+            new StringPair(\"(val != \", \")\"),\n+            new StringPair(\"(val == \", \")\"),\n+            new StringPair(\"(val & \", \")\") \/\/ Extract bits\n+        );\n+\n+        List<StringPair> intCmp = List.of(\n+            new StringPair(\"(val < \", \")\"),\n+            new StringPair(\"(val > \", \")\"),\n+            new StringPair(\"(val >= \", \")\"),\n+            new StringPair(\"(val <= \", \")\"),\n+            new StringPair(\"(val != \", \")\"),\n+            new StringPair(\"(val == \", \")\"),\n+            new StringPair(\"(val & \", \")\"), \/\/ Extract bits\n+            new StringPair(\"(Integer.compareUnsigned(val, \", \") > 0)\"),\n+            new StringPair(\"(Integer.compareUnsigned(val, \", \") < 0)\"),\n+            new StringPair(\"(Integer.compareUnsigned(val, \", \") >= 0)\"),\n+            new StringPair(\"(Integer.compareUnsigned(val, \", \") <= 0)\")\n+        );\n+\n+        List<StringPair> longCmp = List.of(\n+            new StringPair(\"(val < \", \")\"),\n+            new StringPair(\"(val > \", \")\"),\n+            new StringPair(\"(val >= \", \")\"),\n+            new StringPair(\"(val <= \", \")\"),\n+            new StringPair(\"(val != \", \")\"),\n+            new StringPair(\"(val == \", \")\"),\n+            new StringPair(\"(val & \", \")\"), \/\/ Extract bits\n+            new StringPair(\"(Long.compareUnsigned(val, \", \") > 0)\"),\n+            new StringPair(\"(Long.compareUnsigned(val, \", \") < 0)\"),\n+            new StringPair(\"(Long.compareUnsigned(val, \", \") >= 0)\"),\n+            new StringPair(\"(Long.compareUnsigned(val, \", \") <= 0)\")\n+        );\n+\n+        var integralCmpTemplate = Template.make(\"type\", (CodeGenerationDataNameType type) -> {\n+            List<StringPair> cmps = switch(type.name()) {\n+                case \"char\" -> unsignedCmp;\n+                case \"byte\", \"short\", \"int\" -> intCmp;\n+                case \"long\" -> longCmp;\n+                default -> throw new RuntimeException(\"not handled: \" + type.name());\n+            };\n+            StringPair cmp = cmps.get(RANDOM.nextInt(cmps.size()));\n+            return body(\n+                \", \", cmp.s0(), type.con(), cmp.s1()\n+            );\n+        });\n+\n+        \/\/ Checksum method: returns not just the value, but also does some range \/ bit checks.\n+        \/\/                  This gives us enhanced verification on the range \/ bits of the result type.\n+        var checksumTemplate = Template.make(\"expression\", \"checksum\", (Expression expression, String checksum) -> body(\n+            let(\"returnType\", expression.returnType),\n+            \"\"\"\n+            @ForceInline\n+            public static Object #checksum(#returnType val) {\n+            \"\"\",\n+            \"return new Object[] {\",\n+            switch(expression.returnType.name()) {\n+                \/\/ The integral values have signed\/unsigned ranges and known bits.\n+                \/\/ Return val, but also some range and bits tests to see if those\n+                \/\/ ranges and bits are correct.\n+                case \"byte\", \"short\", \"char\", \"int\", \"long\" ->\n+                    List.of(\"val\", Collections.nCopies(20, integralCmpTemplate.asToken(expression.returnType)));\n+                \/\/ Float\/Double have no range, just return the value:\n+                case \"float\", \"double\" -> \"val\";\n+                \/\/ Check if the boolean constant folded:\n+                case \"boolean\" -> \"val, val == true, val == false\";\n+                default -> throw new RuntimeException(\"should only be primitive types\");\n+            }\n+            , \"};\\n\",\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ We need to prepare some random values to pass into the test method. We generate the values\n+        \/\/ once, and pass the same values into both the compiled and reference method.\n+        var valueTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+            \/\/\"#type #name = \", type.con(), \";\\n\"\n+            \"#type #name = \",\n+            (type instanceof PrimitiveType pt) ? pt.callLibraryRNG() : type.con(),\n+            \";\\n\"\n+        ));\n+\n+        \/\/ At the beginning of the compiled and reference test methods we receive the arguments,\n+        \/\/ which have their full bottom_type (e.g. TypeInt: int). We now constrain the ranges and\n+        \/\/ bits, for the types that allow it.\n+        \/\/\n+        \/\/ To ensure that both the compiled and reference method use the same constraint, we put\n+        \/\/ the computation in a ForceInline method.\n+        var constrainArgumentMethodTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+            \"\"\"\n+            @ForceInline\n+            public static #type constrain_#name(#type v) {\n+            \"\"\",\n+            switch(type.name()) {\n+                \/\/ These currently have no type ranges \/ bits.\n+                \/\/ Booleans do have an int-range, but restricting it would just make it constant, which\n+                \/\/ is not very useful: we would like to keep it variable here. We already mix in variable\n+                \/\/ arguments and constants in the testTemplate.\n+                case \"boolean\", \"float\", \"double\" -> \"return v;\\n\";\n+                case \"byte\", \"short\", \"char\", \"int\", \"long\" -> List.of(\n+                    \/\/ Sometimes constrain the signed range\n+                    \/\/   v = min(max(v, CON1), CON2)\n+                    (RANDOM.nextInt(2) == 0)\n+                    ? List.of(\"v = (#type)Math.min(Math.max(v, \", type.con(),\"), \", type.con() ,\");\\n\")\n+                    : List.of(),\n+                    \/\/ Sometimes constrain the bits:\n+                    \/\/   v = (v & CON1) | CON2\n+                    \/\/ Note:\n+                    \/\/   and (&): forces some bits to zero\n+                    \/\/   or  (|): forces some bits to one\n+                    (RANDOM.nextInt(2) == 0)\n+                    ? List.of(\"v = (#type)((v & \", type.con(),\") | \", type.con() ,\");\\n\")\n+                    : List.of(),\n+                    \/\/ FUTURE: we could also constrain the unsigned bounds.\n+                    \"return v;\\n\");\n+                default -> throw new RuntimeException(\"should only be primitive types\");\n+            },\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        var constrainArgumentTemplate = Template.make(\"name\", (String name) -> body(\n+            \"\"\"\n+            #name = constrain_#name(#name);\n+            \"\"\"\n+        ));\n+\n+        \/\/ The template that generates the whole test machinery needed for testing a given expression.\n+        \/\/ Generates:\n+        \/\/ - @Test method: generate arguments and call compiled and reference test with it.\n+        \/\/                 result verification (only if the result is known to be deterministic).\n+        \/\/\n+        \/\/ - instantiate compiled and reference test methods.\n+        \/\/ - instantiate argument constraint methods (constrains test method arguments types).\n+        \/\/ - instantiate checksum method (summarizes value and bounds\/bit checks).\n+        var testTemplate = Template.make(\"expression\", (Expression expression) -> {\n+            \/\/ Fix the arguments for both the compiled and reference method.\n+            \/\/ We have a mix of variable and constant inputs to the expression.\n+            \/\/ The variable inputs are passed as method arguments to the test methods.\n+            List<MethodArgument> methodArguments = new ArrayList<>();\n+            List<Object> expressionArguments = new ArrayList<>();\n+            for (CodeGenerationDataNameType type : expression.argumentTypes) {\n+                switch (RANDOM.nextInt(2)) {\n+                    case 0 -> {\n+                        String name = $(\"arg\" + methodArguments.size());\n+                        methodArguments.add(new MethodArgument(name, type));\n+                        expressionArguments.add(name);\n+                    }\n+                    default -> {\n+                        expressionArguments.add(type.con());\n+                    }\n+                }\n+            }\n+            return body(\n+                let(\"methodArguments\",\n+                    methodArguments.stream().map(ma -> ma.name).collect(Collectors.joining(\", \"))),\n+                let(\"methodArgumentsWithTypes\",\n+                    methodArguments.stream().map(ma -> ma.type + \" \" + ma.name).collect(Collectors.joining(\", \"))),\n+                \"\"\"\n+                @Test\n+                public static void $primitiveConTest() {\n+                    \/\/ In each iteration, generate new random values for the method arguments.\n+                \"\"\",\n+                methodArguments.stream().map(ma -> valueTemplate.asToken(ma.name, ma.type)).toList(),\n+                \"\"\"\n+                    Object v0 = ${primitiveConTest}_compiled(#methodArguments);\n+                    Object v1 = ${primitiveConTest}_reference(#methodArguments);\n+                \"\"\",\n+                expression.info.isResultDeterministic ? \"Verify.checkEQ(v0, v1);\\n\" : \"\/\/ could fail - don't verify.\\n\",\n+                \"\"\"\n+                }\n+\n+                @DontInline\n+                public static Object ${primitiveConTest}_compiled(#methodArgumentsWithTypes) {\n+                \"\"\",\n+                \/\/ The arguments now have the bottom_type. Constrain the ranges and bits.\n+                methodArguments.stream().map(ma -> constrainArgumentTemplate.asToken(ma.name)).toList(),\n+                \/\/ Generate the body with the expression, and calling the checksum.\n+                bodyTemplate.asToken(expression, expressionArguments, $(\"checksum\")),\n+                \"\"\"\n+                }\n+\n+                @DontCompile\n+                public static Object ${primitiveConTest}_reference(#methodArgumentsWithTypes) {\n+                \"\"\",\n+                methodArguments.stream().map(ma -> constrainArgumentTemplate.asToken(ma.name)).toList(),\n+                bodyTemplate.asToken(expression, expressionArguments, $(\"checksum\")),\n+                \"\"\"\n+                }\n+\n+                \"\"\",\n+                methodArguments.stream().map(ma -> constrainArgumentMethodTemplate.asToken(ma.name, ma.type)).toList(),\n+                checksumTemplate.asToken(expression, $(\"checksum\"))\n+            );\n+        });\n+\n+        \/\/ Generate expressions with the primitive types.\n+        for (PrimitiveType type : PRIMITIVE_TYPES) {\n+            for (int i = 0; i < 10; i++) {\n+                \/\/ The depth determines roughly how many operations are going to be used in the expression.\n+                int depth = RANDOM.nextInt(1, 20);\n+                Expression expression = Expression.nestRandomly(type, Operations.PRIMITIVE_OPERATIONS, depth);\n+                tests.add(testTemplate.asToken(expression));\n+            }\n+        }\n+\n+        \/\/ Create the test class, which runs all tests.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.igvn.templated\", \"ExpressionFuzzerInnerTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"compiler.lib.verify.*\",\n+                   \"java.util.Random\",\n+                   \"jdk.test.lib.Utils\",\n+                   \"compiler.lib.generators.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            tests);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+\n+\/**\n+ * {@link Expression}s model Java expressions, that have a list of arguments with specified\n+ * argument types, and an result with a specified result type. Once can {@link #make} a new\n+ * {@link Expression} or use existing ones from {@link Operations}.\n+ *\n+ * <p>\n+ * The {@link Expression}s are composable, they can be explicitly {@link nest}ed, or randomly\n+ * combined using {@link #nestRandomly}.\n+ *\n+ * <p>\n+ * Finally, they can be used in a {@link Template} as a {@link TemplateToken} by calling\n+ * {@link #asToken} with the required arguments.\n+ *\/\n+public class Expression {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/**\n+     * Specifies the return type of the {@link Expression}.\n+     *\/\n+    public final CodeGenerationDataNameType returnType;\n+\n+\n+    \/**\n+     * Specifies the types of the arguments.\n+     *\/\n+    public final List<CodeGenerationDataNameType> argumentTypes;\n+\n+    final List<String> strings;\n+\n+    \/**\n+     * Provides additional information about the {@link Expression}.\n+     *\/\n+    public final Info info;\n+\n+    private Expression(CodeGenerationDataNameType returnType,\n+                      List<CodeGenerationDataNameType> argumentTypes,\n+                      List<String> strings,\n+                      Info info) {\n+        if (argumentTypes.size() + 1 != strings.size()) {\n+            throw new RuntimeException(\"Must have one more string than argument.\");\n+        }\n+        this.returnType = returnType;\n+        this.argumentTypes = List.copyOf(argumentTypes);\n+        this.strings = List.copyOf(strings);\n+        this.info = info;\n+    }\n+\n+\n+    \/**\n+     * Specifies additional information for an {@link Expression}.\n+     *\/\n+    public static class Info {\n+        \/**\n+         * Set of exceptions the {@link Exception} could throw when executed.\n+         * By default, we assume that an {@link Expression} throws no exceptions.\n+         *\/\n+        public final Set<String> exceptions;\n+\n+        \/**\n+         * Specifies if the result of the {@link Expression} is guaranteed to\n+         * be deterministic. This allows exact result verification, for example\n+         * by comparing compiler and interpreter results. However, there are some\n+         * operations that do not always return the same exact result, which can\n+         * for example happen with {@code Float.floatToRawIntBits} in combination\n+         * with more than one {@code NaN} bit representations.\n+         * By default, we assume that an {@link Expression} is deterministic.\n+         *\/\n+        public final boolean isResultDeterministic;\n+\n+        \/**\n+         * Create a default {@link Info}.\n+         *\/\n+        public Info() {\n+            this.exceptions = Set.of();\n+            this.isResultDeterministic = true;\n+        }\n+\n+        private Info(Set<String> exceptions, boolean isResultDeterministic) {\n+            this.exceptions = Set.copyOf(exceptions);\n+            this.isResultDeterministic = isResultDeterministic;\n+        }\n+\n+        \/**\n+         * Creates a new {@link Info} with additional exceptions that the {@link Expression} could throw.\n+         *\n+         * @param exceptions the exceptions to be added.\n+         * @return a new {@link Info} instance with the added exceptions.\n+         *\/\n+        public Info withExceptions(Set<String> exceptions) {\n+            exceptions = Stream.concat(this.exceptions.stream(), exceptions.stream())\n+                               .collect(Collectors.toSet());\n+            return new Info(exceptions, this.isResultDeterministic);\n+        }\n+\n+        \/**\n+         * Creates a new {@link Info} that specifies that the {@link Exception} may return\n+         * indeterministic results, which prevents exact result verification.\n+         *\n+         * @return a new {@link Info} instance that specifies indeterministic results.\n+         *\/\n+        public Info withNondeterministicResult() {\n+            return new Info(this.exceptions, false);\n+        }\n+\n+        Info combineWith(Info other) {\n+            Info info = this.withExceptions(other.exceptions);\n+            if (!other.isResultDeterministic) {\n+                info = info.withNondeterministicResult();\n+            }\n+            return info;\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 1 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The last string, finishing the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1) {\n+        return new Expression(returnType, List.of(t0), List.of(s0, s1), new Info());\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 1 argument.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The last string, finishing the {@link Expression}.\n+     * @param info Additional information about the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  Info info) {\n+        return new Expression(returnType, List.of(t0), List.of(s0, s1), info);\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 2 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The last string, finishing the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2) {\n+        return new Expression(returnType, List.of(t0, t1), List.of(s0, s1, s2), new Info());\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 2 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The last string, finishing the {@link Expression}.\n+     * @param info Additional information about the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2,\n+                                  Info info) {\n+        return new Expression(returnType, List.of(t0, t1), List.of(s0, s1, s2), info);\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 3 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The third string, to be placed before {@code t2}.\n+     * @param t2 The type of the third argument.\n+     * @param s3 The last string, finishing the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2,\n+                                  CodeGenerationDataNameType t2,\n+                                  String s3) {\n+        return new Expression(returnType, List.of(t0, t1, t2), List.of(s0, s1, s2, s3), new Info());\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 3 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The third string, to be placed before {@code t2}.\n+     * @param t2 The type of the third argument.\n+     * @param s3 The last string, finishing the {@link Expression}.\n+     * @param info Additional information about the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2,\n+                                  CodeGenerationDataNameType t2,\n+                                  String s3,\n+                                  Info info) {\n+        return new Expression(returnType, List.of(t0, t1, t2), List.of(s0, s1, s2, s3), info);\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 4 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The third string, to be placed before {@code t2}.\n+     * @param t2 The type of the third argument.\n+     * @param s3 The fourth string, to be placed before {@code t3}.\n+     * @param t3 The type of the fourth argument.\n+     * @param s4 The last string, finishing the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2,\n+                                  CodeGenerationDataNameType t2,\n+                                  String s3,\n+                                  CodeGenerationDataNameType t3,\n+                                  String s4) {\n+        return new Expression(returnType, List.of(t0, t1, t2, t3), List.of(s0, s1, s2, s3, s4), new Info());\n+    }\n+\n+    \/**\n+     * Creates a new Espression with 4 arguments.\n+     *\n+     * @param returnType The return type of the {@link Expression}.\n+     * @param s0 The first string, to be placed before {@code t0}.\n+     * @param t0 The type of the first argument.\n+     * @param s1 The second string, to be placed before {@code t1}.\n+     * @param t1 The type of the second argument.\n+     * @param s2 The third string, to be placed before {@code t2}.\n+     * @param t2 The type of the third argument.\n+     * @param s3 The fourth string, to be placed before {@code t3}.\n+     * @param t3 The type of the fourth argument.\n+     * @param s4 The last string, finishing the {@link Expression}.\n+     * @param info Additional information about the {@link Expression}.\n+     * @return the new {@link Expression}.\n+     *\/\n+    public static Expression make(CodeGenerationDataNameType returnType,\n+                                  String s0,\n+                                  CodeGenerationDataNameType t0,\n+                                  String s1,\n+                                  CodeGenerationDataNameType t1,\n+                                  String s2,\n+                                  CodeGenerationDataNameType t2,\n+                                  String s3,\n+                                  CodeGenerationDataNameType t3,\n+                                  String s4,\n+                                  Info info) {\n+        return new Expression(returnType, List.of(t0, t1, t2, t3), List.of(s0, s1, s2, s3, s4), info);\n+    }\n+\n+    \/**\n+     * Creates a {@link TemplateToken} for the use in a {@link Template} by applying the\n+     * {@code arguments} to the {@link Expression}. It is the users responsibility to\n+     * ensure that the argument tokens match the required {@link #argumentTypes}.\n+     *\n+     * @param arguments the tokens to be passed as arguments into the {@link Expression}.\n+     * @return a {@link TemplateToken} representing the {@link Expression} with applied arguments,\n+     *         for the use in a {@link Template}.\n+     *\/\n+    public TemplateToken asToken(List<Object> arguments) {\n+        if (arguments.size() != argumentTypes.size()) {\n+            throw new IllegalArgumentException(\"Wrong number of arguments:\" +\n+                                               \" expected: \" + argumentTypes.size() +\n+                                               \" but got: \" + arguments.size() +\n+                                               \" for \" + this.toString());\n+        }\n+\n+        \/\/ List of tokens: interleave strings and arguments.\n+        List<Object> tokens = new ArrayList<>();\n+        for (int i = 0; i < argumentTypes.size(); i++) {\n+            tokens.add(strings.get(i));\n+            tokens.add(arguments.get(i));\n+        }\n+        tokens.add(strings.get(strings.size()-1));\n+\n+        var template = Template.make(() -> body(\n+            tokens\n+        ));\n+        return template.asToken();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(\"Expression[\");\n+\n+        for (int i = 0; i < this.argumentTypes.size(); i++) {\n+            sb.append(\"\\\"\");\n+            sb.append(this.strings.get(i));\n+            sb.append(\"\\\", \");\n+            sb.append(this.argumentTypes.get(i).toString());\n+            sb.append(\", \");\n+        }\n+        sb.append(\"\\\"\");\n+        sb.append(this.strings.get(this.strings.size()-1));\n+        sb.append(\"\\\"]\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Create a nested {@link Expression} with a specified {@code returnType} from a\n+     * set of {@code expressions}.\n+     *\n+     * @param returnType the type of the return value.\n+     * @param expressions the list of {@link Expression}s from which we sample to create\n+     *                    the nested {@link Expression}.\n+     * @param maxNumberOfUsedExpressions the maximal number of {@link Expression}s from the\n+     *                                   {@code expressions} are nested.\n+     * @return a new randomly nested {@link Expression}.\n+     *\/\n+    public static Expression nestRandomly(CodeGenerationDataNameType returnType,\n+                                          List<Expression> expressions,\n+                                          int maxNumberOfUsedExpressions) {\n+        List<Expression> filtered = expressions.stream().filter(e -> e.returnType.isSubtypeOf(returnType)).toList();\n+\n+        if (filtered.size() == 0) {\n+            throw new IllegalArgumentException(\"Found no exception with the specified returnType.\");\n+        }\n+\n+        int r = RANDOM.nextInt(filtered.size());\n+        Expression expression = filtered.get(r);\n+\n+        for (int i = 1; i < maxNumberOfUsedExpressions; i++) {\n+            expression = expression.nestRandomly(expressions);\n+        }\n+        return expression;\n+    }\n+\n+    \/**\n+     * Nests a random {@link Expression} from {@code nestingExpressions} into a random argument of\n+     * {@code this} {@link Expression}, ensuring compatibility of argument and return type.\n+     *\n+     * @param nestingExpressions list of expressions we sample from for the inner {@link Expression}.\n+     * @return a new nested {@link Expression}.\n+     *\/\n+    public Expression nestRandomly(List<Expression> nestingExpressions) {\n+        int argumentIndex = RANDOM.nextInt(this.argumentTypes.size());\n+        CodeGenerationDataNameType argumentType = this.argumentTypes.get(argumentIndex);\n+        List<Expression> filtered = nestingExpressions.stream().filter(e -> e.returnType.isSubtypeOf(argumentType)).toList();\n+\n+        if (filtered.size() == 0) {\n+            \/\/ Found no expression that has a matching returnType.\n+            return this;\n+        }\n+\n+        int r = RANDOM.nextInt(filtered.size());\n+        Expression expression = filtered.get(r);\n+\n+        return this.nest(argumentIndex, expression);\n+    }\n+\n+    \/**\n+     * Nests the {@code nestingExpression} into the specified {@code argumentIndex} of\n+     * {@code this} {@link Expression}.\n+     *\n+     * @param argumentIndex the index specifying at which argument of {@code this}\n+     *                      {@link Expression} we inser the {@code nestingExpression}.\n+     * @param nestingExpression the inner {@link Expression}.\n+     * @return a new nested {@link Expression}.\n+     *\/\n+    public Expression nest(int argumentIndex, Expression nestingExpression) {\n+        if (!nestingExpression.returnType.isSubtypeOf(this.argumentTypes.get(argumentIndex))) {\n+            throw new IllegalArgumentException(\"Cannot nest expressions because of mismatched types.\");\n+        }\n+\n+        List<CodeGenerationDataNameType> newArgumentTypes = new ArrayList<>();\n+        List<String> newStrings = new ArrayList<>();\n+        \/\/ s0 t0 s1 [S0 T0 S1 T1 S2] s2 t2 s3\n+        for (int i = 0; i < argumentIndex; i++) {\n+            newStrings.add(this.strings.get(i));\n+            newArgumentTypes.add(this.argumentTypes.get(i));\n+        }\n+        newStrings.add(this.strings.get(argumentIndex) +\n+                       nestingExpression.strings.get(0)); \/\/ concat s1 and S0\n+        newArgumentTypes.add(nestingExpression.argumentTypes.get(0));\n+        for (int i = 1; i < nestingExpression.argumentTypes.size(); i++) {\n+            newStrings.add(nestingExpression.strings.get(i));\n+            newArgumentTypes.add(nestingExpression.argumentTypes.get(i));\n+        }\n+        newStrings.add(nestingExpression.strings.get(nestingExpression.strings.size() - 1) +\n+                       this.strings.get(argumentIndex + 1)); \/\/ concat S2 and s2\n+        for (int i = argumentIndex+1; i < this.argumentTypes.size(); i++) {\n+            newArgumentTypes.add(this.argumentTypes.get(i));\n+            newStrings.add(this.strings.get(i+1));\n+        }\n+\n+        return new Expression(this.returnType, newArgumentTypes, newStrings, this.info.combineWith(nestingExpression.info));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Expression.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+\n+import static compiler.lib.template_framework.library.PrimitiveType.BYTES;\n+import static compiler.lib.template_framework.library.PrimitiveType.SHORTS;\n+import static compiler.lib.template_framework.library.PrimitiveType.CHARS;\n+import static compiler.lib.template_framework.library.PrimitiveType.INTS;\n+import static compiler.lib.template_framework.library.PrimitiveType.LONGS;\n+import static compiler.lib.template_framework.library.PrimitiveType.FLOATS;\n+import static compiler.lib.template_framework.library.PrimitiveType.DOUBLES;\n+import static compiler.lib.template_framework.library.PrimitiveType.BOOLEANS;\n+\n+\/**\n+ * This class provides various lists of {@link Expression}s, that represent Java operators or library\n+ * methods. For example, we represent arithmetic operations on primitive types.\n+ *\/\n+public final class Operations {\n+\n+    \/\/ private constructor to avoid instantiation.\n+    private Operations() {}\n+\n+    \/**\n+     * Provides a lits of operations on {@link PrimitiveType}s, such as arithmetic, logical,\n+     * and cast operations.\n+     *\/\n+    public static final List<Expression> PRIMITIVE_OPERATIONS = generatePrimitiveOperations();\n+\n+    private static List<Expression> generatePrimitiveOperations() {\n+        List<Expression> ops = new ArrayList<>();\n+\n+        Expression.Info withArithmeticException = new Expression.Info().withExceptions(Set.of(\"ArithmeticException\"));\n+        Expression.Info withNondeterministicResult = new Expression.Info().withNondeterministicResult();\n+\n+        \/\/ ------------ byte -------------\n+        ops.add(Expression.make(BYTES, \"(byte)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", INTS,     \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(BYTES, \"(byte)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(BYTES, \"(\", BOOLEANS, \"?\", BYTES, \":\", BYTES, \")\"));\n+\n+        \/\/ Arithmetic operations are not performned in byte, but rather promoted to int.\n+\n+        \/\/ ------------ Byte -------------\n+        ops.add(Expression.make(INTS, \"Byte.compare(\", BYTES, \", \", BYTES, \")\"));\n+        ops.add(Expression.make(INTS, \"Byte.compareUnsigned(\", BYTES, \", \", BYTES, \")\"));\n+        ops.add(Expression.make(INTS, \"Byte.toUnsignedInt(\", BYTES, \")\"));\n+        ops.add(Expression.make(LONGS, \"Byte.toUnsignedLong(\", BYTES, \")\"));\n+\n+        \/\/ ------------ char -------------\n+        ops.add(Expression.make(CHARS, \"(char)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", INTS,     \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(CHARS, \"(char)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(CHARS, \"(\", BOOLEANS, \"?\", CHARS, \":\", CHARS, \")\"));\n+\n+        \/\/ Arithmetic operations are not performned in char, but rather promoted to int.\n+\n+        \/\/ ------------ Character -------------\n+        ops.add(Expression.make(INTS, \"Character.compare(\", CHARS, \", \", CHARS, \")\"));\n+        ops.add(Expression.make(CHARS, \"Character.reverseBytes(\", CHARS, \")\"));\n+\n+        \/\/ ------------ short -------------\n+        ops.add(Expression.make(SHORTS, \"(short)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", INTS,     \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(SHORTS, \"(short)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(SHORTS, \"(\", BOOLEANS, \"?\", SHORTS, \":\", SHORTS, \")\"));\n+\n+        \/\/ Arithmetic operations are not performned in short, but rather promoted to int.\n+\n+        \/\/ ------------ Short -------------\n+        ops.add(Expression.make(INTS, \"Short.compare(\", SHORTS, \", \", SHORTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Short.compareUnsigned(\", SHORTS, \", \", SHORTS, \")\"));\n+        ops.add(Expression.make(SHORTS, \"Short.reverseBytes(\", SHORTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Short.toUnsignedInt(\", SHORTS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Short.toUnsignedLong(\", SHORTS, \")\"));\n+\n+        \/\/ ------------ int -------------\n+        ops.add(Expression.make(INTS, \"(int)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", INTS,     \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(INTS, \"(int)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(INTS, \"(\", BOOLEANS, \"?\", INTS, \":\", INTS, \")\"));\n+\n+        \/\/ Arithmetic operators\n+        ops.add(Expression.make(INTS, \"(-(\", INTS, \"))\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" + \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" - \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" * \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" \/ \",   INTS, \")\", withArithmeticException));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" % \",   INTS, \")\", withArithmeticException));\n+\n+        \/\/ Bitwise Operators (non short-circuit)\n+        ops.add(Expression.make(INTS, \"(~(\", INTS, \"))\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" & \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" | \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" ^ \",   INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" << \",  INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" >> \",  INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"(\", INTS, \" >>> \", INTS, \")\"));\n+\n+        \/\/ Relational \/ Comparison Operators\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" == \",   INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" != \",   INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" > \",    INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" < \",    INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" >= \",   INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", INTS, \" <= \",   INTS, \")\"));\n+\n+        \/\/ ------------ Integer -------------\n+        ops.add(Expression.make(INTS, \"Integer.bitCount(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.compare(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.compareUnsigned(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.compress(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.divideUnsigned(\", INTS, \", \", INTS, \")\", withArithmeticException));\n+        ops.add(Expression.make(INTS, \"Integer.expand(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.highestOneBit(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.lowestOneBit(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.max(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.min(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.numberOfLeadingZeros(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.numberOfTrailingZeros(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.remainderUnsigned(\", INTS, \", \", INTS, \")\", withArithmeticException));\n+        ops.add(Expression.make(INTS, \"Integer.reverse(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.reverseBytes(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.rotateLeft(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.rotateRight(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.signum(\", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Integer.sum(\", INTS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Integer.toUnsignedLong(\", INTS, \")\"));\n+\n+        \/\/ ------------ long -------------\n+        ops.add(Expression.make(LONGS, \"(long)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", INTS,     \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(LONGS, \"(long)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(LONGS, \"(\", BOOLEANS, \"?\", LONGS, \":\", LONGS, \")\"));\n+\n+        \/\/ Arithmetic operators\n+        ops.add(Expression.make(LONGS, \"(-(\", LONGS, \"))\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" + \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" - \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" * \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" \/ \",   LONGS, \")\", withArithmeticException));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" % \",   LONGS, \")\", withArithmeticException));\n+\n+        \/\/ Bitwise Operators (non short-circuit)\n+        ops.add(Expression.make(LONGS, \"(~(\", LONGS, \"))\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" & \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" | \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" ^ \",   LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" << \",  LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" >> \",  LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"(\", LONGS, \" >>> \", LONGS, \")\"));\n+\n+        \/\/ Relational \/ Comparison Operators\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" == \",   LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" != \",   LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" > \",    LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" < \",    LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" >= \",   LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", LONGS, \" <= \",   LONGS, \")\"));\n+\n+        \/\/ ------------ Long -------------\n+        ops.add(Expression.make(INTS, \"Long.bitCount(\", LONGS, \")\"));\n+        ops.add(Expression.make(INTS, \"Long.compare(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(INTS, \"Long.compareUnsigned(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.compress(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.divideUnsigned(\", LONGS, \", \", LONGS, \")\", withArithmeticException));\n+        ops.add(Expression.make(LONGS, \"Long.expand(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.highestOneBit(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.lowestOneBit(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.max(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.min(\", LONGS, \", \", LONGS, \")\"));\n+        ops.add(Expression.make(INTS, \"Long.numberOfLeadingZeros(\", LONGS, \")\"));\n+        ops.add(Expression.make(INTS, \"Long.numberOfTrailingZeros(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.remainderUnsigned(\", LONGS, \", \", LONGS, \")\", withArithmeticException));\n+        ops.add(Expression.make(LONGS, \"Long.reverse(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.reverseBytes(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.rotateLeft(\", LONGS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.rotateRight(\", LONGS, \", \", INTS, \")\"));\n+        ops.add(Expression.make(INTS, \"Long.signum(\", LONGS, \")\"));\n+        ops.add(Expression.make(LONGS, \"Long.sum(\", LONGS, \", \", LONGS, \")\"));\n+\n+        \/\/ ------------ float -------------\n+        ops.add(Expression.make(FLOATS, \"(float)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", INTS,     \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(FLOATS, \"(float)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(FLOATS, \"(\", BOOLEANS, \"?\", FLOATS, \":\", FLOATS, \")\"));\n+\n+        \/\/ Arithmetic operators\n+        ops.add(Expression.make(FLOATS, \"(-(\", FLOATS, \"))\"));\n+        ops.add(Expression.make(FLOATS, \"(\", FLOATS, \" + \",   FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"(\", FLOATS, \" - \",   FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"(\", FLOATS, \" * \",   FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"(\", FLOATS, \" \/ \",   FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"(\", FLOATS, \" % \",   FLOATS, \")\"));\n+\n+\n+        \/\/ Relational \/ Comparison Operators\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" == \", FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" != \", FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" > \",  FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" < \",  FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" >= \", FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", FLOATS, \" <= \", FLOATS, \")\"));\n+\n+        \/\/ ------------ Float -------------\n+        ops.add(Expression.make(INTS, \"Float.compare(\", FLOATS, \", \", FLOATS, \")\"));\n+        ops.add(Expression.make(INTS, \"Float.floatToIntBits(\", FLOATS, \")\"));\n+        ops.add(Expression.make(INTS, \"Float.floatToRawIntBits(\", FLOATS, \")\", withNondeterministicResult));\n+        \/\/ Note: there are multiple NaN values with different bit representations.\n+        ops.add(Expression.make(FLOATS, \"Float.float16ToFloat(\", SHORTS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"Float.intBitsToFloat(\", INTS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float.isFinite(\", FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float.isInfinite(\", FLOATS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float.isNaN(\", FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"Float.max(\", FLOATS, \", \", FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"Float.min(\", FLOATS, \", \", FLOATS, \")\"));\n+        ops.add(Expression.make(FLOATS, \"Float.sum(\", FLOATS, \", \", FLOATS, \")\"));\n+\n+        \/\/ ------------ double -------------\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", BYTES,    \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", SHORTS,   \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", CHARS,    \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", INTS,     \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", LONGS,    \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", FLOATS,   \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(double)(\", DOUBLES,  \")\"));\n+        \/\/ There is no cast from boolean.\n+\n+        ops.add(Expression.make(DOUBLES, \"(\", BOOLEANS, \"?\", DOUBLES, \":\", DOUBLES, \")\"));\n+\n+        \/\/ Arithmetic operators\n+        ops.add(Expression.make(DOUBLES, \"(-(\", DOUBLES, \"))\"));\n+        ops.add(Expression.make(DOUBLES, \"(\", DOUBLES, \" + \",   DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(\", DOUBLES, \" - \",   DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(\", DOUBLES, \" * \",   DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(\", DOUBLES, \" \/ \",   DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"(\", DOUBLES, \" % \",   DOUBLES, \")\"));\n+\n+        \/\/ Relational \/ Comparison Operators\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" == \", DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" != \", DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" > \",  DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" < \",  DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" >= \", DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", DOUBLES, \" <= \", DOUBLES, \")\"));\n+\n+        \/\/ ------------ Double -------------\n+        ops.add(Expression.make(INTS, \"Double.compare(\", DOUBLES, \", \", DOUBLES, \")\"));\n+        ops.add(Expression.make(LONGS, \"Double.doubleToLongBits(\", DOUBLES, \")\"));\n+        ops.add(Expression.make(LONGS, \"Double.doubleToRawLongBits(\", DOUBLES, \")\", withNondeterministicResult));\n+        \/\/ Note: there are multiple NaN values with different bit representations.\n+        ops.add(Expression.make(DOUBLES, \"Double.longBitsToDouble(\", LONGS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Double.isFinite(\", DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Double.isInfinite(\", DOUBLES, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Double.isNaN(\", DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"Double.max(\", DOUBLES, \", \", DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"Double.min(\", DOUBLES, \", \", DOUBLES, \")\"));\n+        ops.add(Expression.make(DOUBLES, \"Double.sum(\", DOUBLES, \", \", DOUBLES, \")\"));\n+\n+        \/\/ ------------ boolean -------------\n+        \/\/ There is no cast to boolean.\n+\n+        ops.add(Expression.make(BOOLEANS, \"(\", BOOLEANS, \"?\", BOOLEANS, \":\", BOOLEANS, \")\"));\n+\n+        \/\/ There are no boolean arithmetic operators\n+\n+        \/\/ Logical operators\n+        ops.add(Expression.make(BOOLEANS, \"(!(\", BOOLEANS, \"))\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", BOOLEANS, \" || \",   BOOLEANS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", BOOLEANS, \" && \",   BOOLEANS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"(\", BOOLEANS, \" ^ \",   BOOLEANS, \")\"));\n+\n+        \/\/ ------------ Boolean -------------\n+        ops.add(Expression.make(INTS, \"Boolean.compare(\", BOOLEANS, \", \", BOOLEANS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Boolean.logicalAnd(\", BOOLEANS, \", \", BOOLEANS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Boolean.logicalOr(\", BOOLEANS, \", \", BOOLEANS, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Boolean.logicalXor(\", BOOLEANS, \", \", BOOLEANS, \")\"));\n+\n+        \/\/ TODO: Math and other classes.\n+\n+        \/\/ Make sure the list is not modifiable.\n+        return List.copyOf(ops);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -34,0 +34,3 @@\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n@@ -151,0 +154,87 @@\n+\n+    \/**\n+     * Calls the corresponding pseudo random number generator from\n+     * {@link #generateLibraryRNG}, for the given type. Accordingly,\n+     * one must generate {@link #generateLibraryRNG} into the same\n+     * test if one wants to use this method.\n+     *\n+     * Note: if you simply need a compile time constant, then please\n+     * use {@link #con} instead.\n+     *\n+     * @return the token representing the method call to obtain a\n+     *         random value for the given type at runtime.\n+     *\/\n+    public Object callLibraryRNG() {\n+        return switch (kind) {\n+            case BYTE    -> \"LibraryRNG.nextByte()\";\n+            case SHORT   -> \"LibraryRNG.nextShort()\";\n+            case CHAR    -> \"LibraryRNG.nextChar()\";\n+            case INT     -> \"LibraryRNG.nextInt()\";\n+            case LONG    -> \"LibraryRNG.nextLong()\";\n+            case FLOAT   -> \"LibraryRNG.nextFloat()\";\n+            case DOUBLE  -> \"LibraryRNG.nextDouble()\";\n+            case BOOLEAN -> \"LibraryRNG.nextBoolean()\";\n+        };\n+    }\n+\n+    \/**\n+     * Generates the {@code LibraryRNG} class, which makes a set of pseudo\n+     * random number generators available, wrapping {@link Generators}. This\n+     * is supposed to be used in tandem with {@link #callLibraryRNG}.\n+     *\n+     * Note: you must ensure that all required imports are performed:\n+     *       {@code java.util.Random}\n+     *       {@code jdk.test.lib.Utils}\n+     *       {@code compiler.lib.generators.*}\n+     *\n+     * @return a TemplateToken that holds all the {@code LibraryRNG} class.\n+     *\/\n+    public static TemplateToken generateLibraryRNG() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            public static class LibraryRNG {\n+                private static final Random RANDOM = Utils.getRandomInstance();\n+                private static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+                private static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+                private static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+                private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+                private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+                private static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+                private static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+\n+                public static byte nextByte() {\n+                    return GEN_BYTE.next().byteValue();\n+                }\n+\n+                public static short nextShort() {\n+                    return GEN_SHORT.next().shortValue();\n+                }\n+\n+                public static char nextChar() {\n+                    return (char)GEN_CHAR.next().intValue();\n+                }\n+\n+                public static int nextInt() {\n+                    return GEN_INT.next();\n+                }\n+\n+                public static long nextLong() {\n+                    return GEN_LONG.next();\n+                }\n+\n+                public static float nextFloat() {\n+                    return GEN_FLOAT.next();\n+                }\n+\n+                public static double nextDouble() {\n+                    return GEN_DOUBLE.next();\n+                }\n+\n+                public static boolean nextBoolean() {\n+                    return RANDOM.nextBoolean();\n+                }\n+            }\n+            \"\"\"\n+        ));\n+        return template.asToken();\n+    };\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8359412\n+ * @summary Demonstrate the use of Expressions form the Template Library.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestExpressions\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Set;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import compiler.lib.template_framework.library.Expression;\n+import compiler.lib.template_framework.library.Operations;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+public class TestExpressions {\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnterTest.main(new String[] {});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+    }\n+\n+    \/\/ Generate a Java source file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Generate a list of test methods.\n+        List<TemplateToken> tests = new ArrayList<>();\n+\n+        \/\/ Create a test method that executes the expression, with constant arguments.\n+        var withConstantsTemplate = Template.make(\"expression\", (Expression expression) -> {\n+            \/\/ Create a token: fill the expression with a fixed set of constants.\n+            \/\/ We then use the same token with the same constants, once compiled and once not compiled.\n+            TemplateToken expressionToken = expression.asToken(expression.argumentTypes.stream().map(t -> t.con()).toList());\n+            return body(\n+                let(\"returnType\", expression.returnType),\n+                \"\"\"\n+                @Test\n+                public static void $primitiveConTest() {\n+                    #returnType v0 = ${primitiveConTest}_compiled();\n+                    #returnType v1 = ${primitiveConTest}_reference();\n+                    Verify.checkEQ(v0, v1);\n+                }\n+\n+                @DontInline\n+                public static #returnType ${primitiveConTest}_compiled() {\n+                \"\"\",\n+                \"return \", expressionToken, \";\\n\",\n+                \"\"\"\n+                }\n+\n+                @DontCompile\n+                public static #returnType ${primitiveConTest}_reference() {\n+                \"\"\",\n+                \"return \", expressionToken, \";\\n\",\n+                \"\"\"\n+                }\n+                \"\"\"\n+            );\n+        });\n+\n+        for (Expression operation : Operations.PRIMITIVE_OPERATIONS) {\n+            tests.add(withConstantsTemplate.asToken(operation));\n+        }\n+\n+        \/\/ Create the test class, which runs all tests.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"p.xyz\", \"InnerTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            tests);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -172,0 +172,42 @@\n+        \/\/ Test runtime random value generation with LibraryRNG\n+        \/\/ Runtime random number generation of a given primitive type can be very helpful\n+        \/\/ when writing tests that require random inputs.\n+        var libraryRNGWithTypeTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            \"\"\"\n+            {\n+                \/\/ Fill an array with 1_000 random values. Every type has at least 2 values,\n+                \/\/ so the chance that all values are the same is 2^-1_000 < 10^-300. This should\n+                \/\/ never happen, even with a relatively weak PRNG.\n+                #type[] a = new #type[1_000];\n+                for (int i = 0; i < a.length; i++) {\n+            \"\"\",\n+            \"       a[i] = \", type.callLibraryRNG(), \";\\n\",\n+            \"\"\"\n+                }\n+                boolean allSame = true;\n+                for (int i = 0; i < a.length; i++) {\n+                    if (a[i] != a[0]) {\n+                        allSame = false;\n+                        break;\n+                    }\n+                }\n+                if (allSame) { throw new RuntimeException(\"all values were the same for #type\"); }\n+            }\n+            \"\"\"\n+        ));\n+\n+        var libraryRNGTemplate = Template.make(() -> body(\n+            \/\/ Make sure we instantiate the LibraryRNG class.\n+            PrimitiveType.generateLibraryRNG(),\n+            \/\/ Now we can use it inside the test.\n+            \"\"\"\n+            public static void test_LibraryRNG() {\n+            \"\"\",\n+            CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(libraryRNGWithTypeTemplate::asToken).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        tests.put(\"test_LibraryRNG\", libraryRNGTemplate.asToken());\n+\n@@ -181,0 +223,5 @@\n+            \/\/ Imports for LibraryRNG\n+            import java.util.Random;\n+            import jdk.test.lib.Utils;\n+            import compiler.lib.generators.*;\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8359412\n+ * @summary Test template generation with Expressions.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestExpression\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.Expression;\n+\n+\/**\n+ * This tests the use of the {@link Expression} from the template library. This is\n+ * not a tutorial about how to use Expressions, rather we produce deterministic\n+ * output to be able to compare the generated strings to expected strings.\n+ *\n+ * If you are interested in how to use {@link Expression}s, see {@code examples\/TestExpressions.java}.\n+ *\/\n+public class TestExpression {\n+    \/\/ Interface for failing tests.\n+    interface FailingTest {\n+        void run();\n+    }\n+\n+    \/\/ We define our own types, so that we can check if subtyping works right.\n+    public record MyType(String name) implements CodeGenerationDataNameType {\n+        @Override\n+        public Object con() {\n+            return \"<\" + name() + \">\";\n+        }\n+\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MyType(String n) && name().startsWith(n);\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyType myTypeA  = new MyType(\"MyTypeA\");\n+    private static final MyType myTypeA1 = new MyType(\"MyTypeA1\");\n+    private static final MyType myTypeB  = new MyType(\"MyTypeB\");\n+\n+    public static void main(String[] args) {\n+        \/\/ The following tests all pass, i.e. have no errors during rendering.\n+        testAsToken();\n+        testNest();\n+        testNestRandomly();\n+        testInfo();\n+\n+        \/\/ The following tests should all fail, with an expected exception and message.\n+        expectIllegalArgumentException(() -> testFailingAsToken1(), \"Wrong number of arguments: expected: 2 but got: 1\");\n+        expectIllegalArgumentException(() -> testFailingAsToken2(), \"Wrong number of arguments: expected: 2 but got: 3\");\n+        expectIllegalArgumentException(() -> testFailingNest1(), \"Cannot nest expressions because of mismatched types.\");\n+    }\n+\n+    public static void testAsToken() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \"]\");\n+        Expression e2 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \"]\");\n+        Expression e3 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \",\", myTypeA1, \"]\");\n+        Expression e4 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \",\", myTypeA1, \",\", myTypeA, \"]\");\n+\n+        var template = Template.make(() -> body(\n+            \"xx\", e1.toString(), \"yy\\n\",\n+            \"xx\", e2.toString(), \"yy\\n\",\n+            \"xx\", e3.toString(), \"yy\\n\",\n+            \"xx\", e4.toString(), \"yy\\n\",\n+            \"xx\", e1.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e2.asToken(List.of(\"a\", \"b\")), \"yy\\n\",\n+            \"xx\", e3.asToken(List.of(\"a\", \"b\", \"c\")), \"yy\\n\",\n+            \"xx\", e4.asToken(List.of(\"a\", \"b\", \"c\", \"d\")), \"yy\\n\"\n+        ));\n+\n+        String expected =\n+            \"\"\"\n+            xxExpression[\"[\", MyTypeA, \"]\"]yy\n+            xxExpression[\"[\", MyTypeA, \",\", MyTypeB, \"]\"]yy\n+            xxExpression[\"[\", MyTypeA, \",\", MyTypeB, \",\", MyTypeA1, \"]\"]yy\n+            xxExpression[\"[\", MyTypeA, \",\", MyTypeB, \",\", MyTypeA1, \",\", MyTypeA, \"]\"]yy\n+            xx[a]yy\n+            xx[a,b]yy\n+            xx[a,b,c]yy\n+            xx[a,b,c,d]yy\n+            \"\"\";\n+        String code = template.render();\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFailingAsToken1() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \"]\");\n+        e1.asToken(List.of(\"a\"));\n+    }\n+\n+    public static void testFailingAsToken2() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \"]\");\n+        e1.asToken(List.of(\"a\", \"b\", \"c\"));\n+    }\n+\n+    public static void testNest() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \"]\");\n+        Expression e2 = Expression.make(myTypeA, \"[\", myTypeA, \",\", myTypeB, \"]\");\n+        Expression e3 = Expression.make(myTypeA1, \"[\", myTypeA, \"]\");\n+        Expression e4 = Expression.make(myTypeA, \"[\", myTypeA, \"x\", myTypeA, \"y\", myTypeA, \"z\", myTypeA, \"]\");\n+        Expression e5 = Expression.make(myTypeA, \"[\", myTypeA, \"u\", myTypeA, \"v\", myTypeA, \"w\", myTypeA, \"]\");\n+\n+        Expression e1e1 = e1.nest(0, e1);\n+        Expression e2e1 = e2.nest(0, e1);\n+        Expression e3e1 = e3.nest(0, e1);\n+        Expression e4e5 = e4.nest(1, e5);\n+\n+        var template = Template.make(() -> body(\n+            \"xx\", e1e1.toString(), \"yy\\n\",\n+            \"xx\", e2e1.toString(), \"yy\\n\",\n+            \"xx\", e3e1.toString(), \"yy\\n\",\n+            \"xx\", e4e5.toString(), \"yy\\n\",\n+            \"xx\", e1e1.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e2e1.asToken(List.of(\"a\", \"b\")), \"yy\\n\",\n+            \"xx\", e3e1.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e4e5.asToken(List.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\")), \"yy\\n\"\n+        ));\n+\n+        String expected =\n+            \"\"\"\n+            xxExpression[\"[[\", MyTypeA, \"]]\"]yy\n+            xxExpression[\"[[\", MyTypeA, \"],\", MyTypeB, \"]\"]yy\n+            xxExpression[\"[[\", MyTypeA, \"]]\"]yy\n+            xxExpression[\"[\", MyTypeA, \"x[\", MyTypeA, \"u\", MyTypeA, \"v\", MyTypeA, \"w\", MyTypeA, \"]y\", MyTypeA, \"z\", MyTypeA, \"]\"]yy\n+            xx[[a]]yy\n+            xx[[a],b]yy\n+            xx[[a]]yy\n+            xx[ax[bucvdwe]yfzg]yy\n+            \"\"\";\n+        String code = template.render();\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNestRandomly() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \"]\");\n+        Expression e2 = Expression.make(myTypeA, \"(\", myTypeA, \")\");\n+        Expression e3 = Expression.make(myTypeB, \"{\", myTypeA, \"}\");\n+        Expression e4 = Expression.make(myTypeA1, \"<\", myTypeA, \">\");\n+        Expression e5 = Expression.make(myTypeA, \"[\", myTypeB, \"]\");\n+\n+        Expression e1e2 = e1.nestRandomly(List.of(e2));\n+        Expression e1ex = e1.nestRandomly(List.of(e3, e2, e3));\n+        Expression e1e4 = e1.nestRandomly(List.of(e3, e4, e3));\n+        Expression e1ey = e1.nestRandomly(List.of(e3, e3));\n+\n+        \/\/ 5-deep nesting of e1\n+        Expression deep1 = Expression.nestRandomly(myTypeA, List.of(e1, e3), 5);\n+        \/\/ Alternating pattern\n+        Expression deep2 = Expression.nestRandomly(myTypeA, List.of(e5, e3), 5);\n+\n+        var template = Template.make(() -> body(\n+            \"xx\", e1e2.toString(), \"yy\\n\",\n+            \"xx\", e1ex.toString(), \"yy\\n\",\n+            \"xx\", e1e4.toString(), \"yy\\n\",\n+            \"xx\", e1ey.toString(), \"yy\\n\",\n+            \"xx\", deep1.toString(), \"yy\\n\",\n+            \"xx\", deep2.toString(), \"yy\\n\",\n+            \"xx\", e1e2.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e1ex.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e1e4.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", e1ey.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", deep1.asToken(List.of(\"a\")), \"yy\\n\",\n+            \"xx\", deep2.asToken(List.of(\"a\")), \"yy\\n\"\n+        ));\n+\n+        String expected =\n+            \"\"\"\n+            xxExpression[\"[(\", MyTypeA, \")]\"]yy\n+            xxExpression[\"[(\", MyTypeA, \")]\"]yy\n+            xxExpression[\"[<\", MyTypeA, \">]\"]yy\n+            xxExpression[\"[\", MyTypeA, \"]\"]yy\n+            xxExpression[\"[[[[[\", MyTypeA, \"]]]]]\"]yy\n+            xxExpression[\"[{[{[\", MyTypeB, \"]}]}]\"]yy\n+            xx[(a)]yy\n+            xx[(a)]yy\n+            xx[<a>]yy\n+            xx[a]yy\n+            xx[[[[[a]]]]]yy\n+            xx[{[{[a]}]}]yy\n+            \"\"\";\n+        String code = template.render();\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFailingNest1() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \"]\");\n+        Expression e2 = Expression.make(myTypeB, \"[\", myTypeA, \"]\");\n+        Expression e1e2 = e1.nest(0, e2);\n+    }\n+\n+    public static void testInfo() {\n+        Expression e1 = Expression.make(myTypeA, \"[\", myTypeA, \"]\");\n+        Expression e2 = Expression.make(myTypeA, \"(\", myTypeA, \")\");\n+        Expression e3 = Expression.make(myTypeA, \"<\", myTypeA, \">\", new Expression.Info().withExceptions(Set.of(\"E1\")));\n+        Expression e4 = Expression.make(myTypeA, \"+\", myTypeA, \"-\", new Expression.Info().withExceptions(Set.of(\"E2\")));\n+        Expression e5 = Expression.make(myTypeA, \"x\", myTypeA, \"y\", new Expression.Info().withNondeterministicResult());\n+        Expression e6 = Expression.make(myTypeA, \"u\", myTypeA, \"v\", new Expression.Info().withNondeterministicResult());\n+        checkInfo(e1, Set.of(), true);\n+        checkInfo(e2, Set.of(), true);\n+        checkInfo(e3, Set.of(\"E1\"), true);\n+        checkInfo(e4, Set.of(\"E2\"), true);\n+        checkInfo(e1.nest(0, e2), Set.of(), true);\n+        checkInfo(e2.nest(0, e1), Set.of(), true);\n+        checkInfo(e1.nest(0, e3), Set.of(\"E1\"), true);\n+        checkInfo(e3.nest(0, e1), Set.of(\"E1\"), true);\n+        checkInfo(e3.nest(0, e4), Set.of(\"E1\", \"E2\"), true);\n+        checkInfo(e4.nest(0, e3), Set.of(\"E1\", \"E2\"), true);\n+        checkInfo(e5, Set.of(), false);\n+        checkInfo(e6, Set.of(), false);\n+        checkInfo(e1.nest(0, e5), Set.of(), false);\n+        checkInfo(e5.nest(0, e1), Set.of(), false);\n+        checkInfo(e5.nest(0, e6), Set.of(), false);\n+        checkInfo(e4.nest(0, e3).nest(0, e5), Set.of(\"E1\", \"E2\"), false);\n+        checkInfo(e5.nest(0, e4).nest(0, e3), Set.of(\"E1\", \"E2\"), false);\n+        checkInfo(e3.nest(0, e5).nest(0, e4), Set.of(\"E1\", \"E2\"), false);\n+    }\n+\n+    public static void checkInfo(Expression e, Set<String> exceptions, boolean isResultDeterministic) {\n+        if (!e.info.exceptions.equals(exceptions) ||\n+            e.info.isResultDeterministic != isResultDeterministic) {\n+            throw new RuntimeException(\"Info not as expected.\");\n+        }\n+    }\n+\n+    public static void checkEQ(String code, String expected) {\n+        if (!code.equals(expected)) {\n+            System.out.println(\"\\\"\" + code + \"\\\"\");\n+            System.out.println(\"\\\"\" + expected + \"\\\"\");\n+            throw new RuntimeException(\"Template rendering mismatch!\");\n+        }\n+    }\n+\n+    public static void expectIllegalArgumentException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown IllegalArgumentException with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(IllegalArgumentException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestExpression.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"}]}