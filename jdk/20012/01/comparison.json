{"files":[{"patch":"@@ -69,3 +69,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -180,3 +177,9 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+  DEBUG_ONLY(_used = false;)\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (mask_size() > small_mask_limit) {\n+    assert(!Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n+           \"The bit mask should be allocated from the C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -402,5 +405,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n-  assert(from->has_valid_mask(),\n-    \"Cannot copy entry with an invalid mask\");\n+void InterpreterOopMap::copy_from(OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!_used, \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -408,5 +411,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -415,2 +418,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy((void *)_bit_mask, (void *)src->_bit_mask,\n@@ -419,11 +422,1 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n@@ -431,2 +424,1 @@\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -434,0 +426,1 @@\n+  DEBUG_ONLY(_used = true);\n@@ -515,1 +508,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -529,1 +522,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -630,1 +623,1 @@\n-    entry->resource_copy(tmp);\n+    entry->copy_from(tmp);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -43,3 +43,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -92,1 +93,1 @@\n-  bool _resource_allocate_bit_mask;\n+  bool           _used;\n@@ -131,0 +132,1 @@\n+  ~InterpreterOopMap();\n@@ -132,5 +134,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(OopMapCacheEntry* src);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -950,1 +950,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}