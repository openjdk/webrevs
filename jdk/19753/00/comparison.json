{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,9 @@\n+bool JVMCICompiler::is_intrinsic_supported(const methodHandle& method) {\n+  vmIntrinsics::ID id = method->intrinsic_id();\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  JavaThread* thread = JavaThread::current();\n+  JVMCIEnv jvmciEnv(thread, __FILE__, __LINE__);\n+  JVMCIRuntime* runtime = JVMCI::compiler_runtime(thread, false);\n+  return runtime->is_intrinsic_supported(&jvmciEnv, (jint) id);\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,0 +139,2 @@\n+  virtual bool is_intrinsic_supported(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -970,0 +970,25 @@\n+jboolean JVMCIEnv::call_HotSpotJVMCIRuntime_isIntrinsicSupported (JVMCIObject runtime, jint intrinsicIdentifier) {\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));\n+    jargs.push_int(intrinsicIdentifier);\n+    JavaValue result(T_BOOLEAN);\n+    JavaCalls::call_special(&result,\n+                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                            vmSymbols::isIntrinsicSupported_name(),\n+                            vmSymbols::int_bool_signature(), &jargs, CHECK_0);\n+    return result.get_jboolean();\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jboolean result = jni()->CallNonvirtualBooleanMethod(runtime.as_jobject(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::isIntrinsicSupported_method(),\n+                                                     intrinsicIdentifier);\n+    if (jni()->ExceptionCheck()) {\n+      return false;\n+    }\n+    return result;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -362,0 +362,2 @@\n+  jboolean call_HotSpotJVMCIRuntime_isIntrinsicSupported(JVMCIObject runtime, jint intrinsicIdentifier);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,1 @@\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isIntrinsicSupported, int_bool_signature) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2053,0 +2053,10 @@\n+bool JVMCIRuntime::is_intrinsic_supported(JVMCIEnv* JVMCIENV, jint id) {\n+  JVMCI_EXCEPTION_CONTEXT\n+\n+  JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);\n+  if (JVMCIENV->has_pending_exception()) {\n+    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+  }\n+  return JVMCIENV->call_HotSpotJVMCIRuntime_isIntrinsicSupported(receiver, id);\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -434,0 +434,3 @@\n+  \/\/ Determines if the intrinsic identified by `id` is supported by the JVMCI compiler.\n+  bool is_intrinsic_supported(JVMCIEnv* JVMCIENV, jint id);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+  template(isIntrinsicSupported_name,                             \"isIntrinsicSupported\")                                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -990,0 +990,6 @@\n+    @SuppressWarnings(\"try\")\n+    @VMEntryPoint\n+    private boolean isIntrinsicSupported(int intrinsicIdentifier) {\n+        return getCompiler().isIntrinsicSupported(intrinsicIdentifier);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,21 @@\n+    \/**\n+     * Gets the VM intrinsic description by its ID.\n+     *\/\n+    public VMIntrinsicMethod getIntrinsic(int intrinsicID) {\n+        if (intrinsicID >= 1 && intrinsicID <= vmIntrinsics.size()) {\n+            \/\/ valid intrinsicID starts from 1\n+            VMIntrinsicMethod intrinsic = vmIntrinsics.get(intrinsicID - 1);\n+            \/\/ We assume vmIntrinsics are sorted by ID\n+            if (intrinsic.id == intrinsicID) {\n+                return intrinsic;\n+            }\n+        }\n+        \/\/ Assumption failed, fall back to iteration\n+        for (VMIntrinsicMethod intrinsic : vmIntrinsics) {\n+            if (intrinsic.id == intrinsicID) {\n+                return intrinsic;\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigStore.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,11 @@\n+\n+    \/**\n+     * Determines if this compiler supports the {@code intrinsicIdentifier} intrinsic. The default\n+     * implementation of this method returns false as that is the effective answer given by a\n+     * {@link JVMCICompiler} before this method was added.\n+     *\n+     * @param intrinsicIdentifier intrinsic identifier defined in vmIntrinsics.hpp.\n+     *\/\n+    default boolean isIntrinsicSupported(int intrinsicIdentifier) {\n+        return false;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/runtime\/JVMCICompiler.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}