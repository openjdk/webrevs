{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include <fcntl.h>\n@@ -51,0 +52,15 @@\n+static int\n+markCloseOnExec(int fd)\n+{\n+    const int flags = fcntl(fd, F_GETFD);\n+    if (flags < 0) {\n+        return -1;\n+    }\n+    if ((flags & FD_CLOEXEC) == 0) {\n+        if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n+            return -1;\n+        }\n+    }\n+    return 0;\n+}\n+\n@@ -60,5 +76,4 @@\n-\/\/ Closes every file descriptor that is listed as a directory\n-\/\/ entry in \"\/proc\/self\/fd\" (or its equivalent). Standard\n-\/\/ input\/output\/error file descriptors will not be closed\n-\/\/ by this function. This function returns 0 on failure\n-\/\/ and 1 on success.\n+\/\/ Marks all file descriptors found in \/proc\/self\/fd with the\n+\/\/ FD_CLOEXEC flag to ensure they are automatically closed\n+\/\/ upon execution of a new program via exec(). This function\n+\/\/ returns -1 on failure and 0 on success.\n@@ -66,1 +81,1 @@\n-closeDescriptors(void)\n+markDescriptorsCloseOnExec(void)\n@@ -70,18 +85,1 @@\n-    \/* leave out standard input\/output\/error descriptors *\/\n-    int from_fd = STDERR_FILENO + 1;\n-\n-    \/* We're trying to close all file descriptors, but opendir() might\n-     * itself be implemented using a file descriptor, and we certainly\n-     * don't want to close that while it's in use.  We assume that if\n-     * opendir() is implemented using a file descriptor, then it uses\n-     * the lowest numbered file descriptor, just like open().  So\n-     * before calling opendir(), we close a couple explicitly, so that\n-     * opendir() can then use these lowest numbered closed file\n-     * descriptors afresh.\n-     *\n-     * WARNING: We are not allowed to return with a failure until after\n-     * these two closes are done. forkedChildProcess() relies on this. *\/\n-\n-    close(from_fd);          \/* for possible use by opendir() *\/\n-    close(from_fd + 1);      \/* another one for good luck *\/\n-    from_fd += 2; \/* leave out the 2 we just closed, which the opendir() may use *\/\n+    const int from_fd = STDERR_FILENO;\n@@ -90,2 +88,1 @@\n-    \/* set FD_DIR for AIX which does not understand '\/proc\/self' - it\n-     * requires the real process ID *\/\n+    \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n@@ -98,1 +95,1 @@\n-                       \" file descriptors to close for process %d\",\n+                       \" file descriptors to mark or close for process %d\",\n@@ -100,1 +97,1 @@\n-        return 0; \/\/ failure\n+        return -1; \/\/ failure\n@@ -103,0 +100,2 @@\n+    int dir_fd = dirfd(dp);\n+\n@@ -107,3 +106,5 @@\n-        const long fd = strtol(dirp->d_name, NULL, 10);\n-        if (fd <= INT_MAX && fd >= from_fd) {\n-            (void)close((int)fd);\n+        int fd = strtol(dirp->d_name, NULL, 10);\n+        if (fd <= INT_MAX && fd > from_fd && fd != dir_fd) {\n+            if (markCloseOnExec(fd) == -1) {\n+                (void)close((int)fd);\n+            }\n@@ -115,1 +116,1 @@\n-    return 1; \/\/ success\n+    return 0; \/\/ success\n@@ -118,3 +119,4 @@\n-\/\/ Does necessary housekeeping of a forked child process\n-\/\/ (like closing copied file descriptors) before\n-\/\/ execing the child process. This function never returns.\n+\/\/ Performs necessary housekeeping in the forked child process,\n+\/\/ such as marking copied file descriptors (except standard input\/output\/error)\n+\/\/ with FD_CLOEXEC to ensure they are closed during exec().\n+\/\/ This function never returns.\n@@ -124,3 +126,4 @@\n-    \/* Close all file descriptors that have been copied over\n-     * from the parent process due to fork(). *\/\n-    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+    \/* Mark all file descriptors (except standard input\/output\/error)\n+     * copied from the parent process with FD_CLOEXEC, so they are\n+     * closed automatically upon exec(). *\/\n+    if (markDescriptorsCloseOnExec() < 0) { \/* failed,  close the old way *\/\n@@ -134,4 +137,2 @@\n-        \/* Leave out standard input\/output\/error file descriptors. Also,\n-         * leave out STDERR_FILENO +1 and +2 since closeDescriptors()\n-         * already closed them, even when returning an error. *\/\n-        rlim_t i = STDERR_FILENO + 3;\n+        \/* leave out standard input\/output\/error file descriptors *\/\n+        rlim_t i = STDERR_FILENO + 1;\n@@ -140,1 +141,1 @@\n-                       \" %d file descriptors sequentially\", (max_fd - i + 1)));\n+                       \" %d file descriptors sequentially\", (max_fd - i)));\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"}]}