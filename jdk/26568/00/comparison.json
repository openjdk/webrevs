{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include <fcntl.h>\n@@ -60,5 +61,19 @@\n-\/\/ Closes every file descriptor that is listed as a directory\n-\/\/ entry in \"\/proc\/self\/fd\" (or its equivalent). Standard\n-\/\/ input\/output\/error file descriptors will not be closed\n-\/\/ by this function. This function returns 0 on failure\n-\/\/ and 1 on success.\n+int\n+markCloseOnExec(int fd)\n+{\n+    const int flags = fcntl(fd, F_GETFD);\n+    if (flags < 0) {\n+        return -1;\n+    }\n+    if ((flags & FD_CLOEXEC) == 0) {\n+        if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n+            return -1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+\/\/ Marks all file descriptors found in \/proc\/self\/fd with the\n+\/\/ FD_CLOEXEC flag to ensure they are automatically closed\n+\/\/ upon execution of a new program via exec(). This function\n+\/\/ returns 0 on failure and 1 on success.\n@@ -66,1 +81,1 @@\n-closeDescriptors(void)\n+markDescriptorsCloseOnExec(void)\n@@ -70,18 +85,1 @@\n-    \/* leave out standard input\/output\/error descriptors *\/\n-    int from_fd = STDERR_FILENO + 1;\n-\n-    \/* We're trying to close all file descriptors, but opendir() might\n-     * itself be implemented using a file descriptor, and we certainly\n-     * don't want to close that while it's in use.  We assume that if\n-     * opendir() is implemented using a file descriptor, then it uses\n-     * the lowest numbered file descriptor, just like open().  So\n-     * before calling opendir(), we close a couple explicitly, so that\n-     * opendir() can then use these lowest numbered closed file\n-     * descriptors afresh.\n-     *\n-     * WARNING: We are not allowed to return with a failure until after\n-     * these two closes are done. forkedChildProcess() relies on this. *\/\n-\n-    close(from_fd);          \/* for possible use by opendir() *\/\n-    close(from_fd + 1);      \/* another one for good luck *\/\n-    from_fd += 2; \/* leave out the 2 we just closed, which the opendir() may use *\/\n+    const int from_fd = STDERR_FILENO;\n@@ -90,2 +88,1 @@\n-    \/* set FD_DIR for AIX which does not understand '\/proc\/self' - it\n-     * requires the real process ID *\/\n+    \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n@@ -103,0 +100,2 @@\n+    int dir_fd = dirfd(dp);\n+\n@@ -107,3 +106,5 @@\n-        const long fd = strtol(dirp->d_name, NULL, 10);\n-        if (fd <= INT_MAX && fd >= from_fd) {\n-            (void)close((int)fd);\n+        int fd = strtol(dirp->d_name, NULL, 10);\n+        if (fd <= INT_MAX && fd > from_fd && fd != dir_fd) {\n+            if (markCloseOnExec(fd) == -1) {\n+                (void)close((int)fd);\n+            }\n@@ -126,1 +127,1 @@\n-    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+    if (markDescriptorsCloseOnExec() != 1) { \/* failed,  close the old way *\/\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"}]}