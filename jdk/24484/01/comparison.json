{"files":[{"patch":"@@ -1552,1 +1552,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -1560,1 +1559,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -1571,1 +1569,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -1578,1 +1575,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2035,1 +2031,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2046,1 +2041,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2054,1 +2048,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2064,1 +2057,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2166,1 +2158,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2229,1 +2220,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2243,1 +2233,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2251,1 +2240,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2262,1 +2250,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2269,1 +2256,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2279,1 +2265,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2286,1 +2271,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2296,1 +2280,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2303,1 +2286,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2310,1 +2292,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2321,1 +2302,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2328,1 +2308,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2335,1 +2314,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2342,1 +2320,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2555,1 +2532,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2566,1 +2542,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2574,1 +2549,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2584,1 +2558,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2856,1 +2829,0 @@\n-    NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2938,1 +2910,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"unsupported\");)\n@@ -2944,1 +2915,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"unsupported\");)\n@@ -2953,1 +2923,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -2962,1 +2931,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -2970,1 +2938,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -3406,1 +3373,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3413,1 +3379,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3421,1 +3386,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3431,1 +3395,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3441,1 +3404,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3448,1 +3410,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3458,1 +3419,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3468,1 +3428,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3475,1 +3434,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3920,1 +3878,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3931,1 +3888,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3942,1 +3898,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3953,1 +3908,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3961,1 +3915,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3969,1 +3922,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3989,1 +3941,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -3997,1 +3948,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4008,1 +3958,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4028,1 +3977,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4035,1 +3983,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4045,1 +3992,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4068,1 +4014,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4088,1 +4033,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4186,1 +4130,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4197,1 +4140,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4205,1 +4147,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4215,1 +4156,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -4678,1 +4618,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4692,1 +4631,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -4706,1 +4644,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4717,1 +4654,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -4898,1 +4834,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5046,1 +4981,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5095,1 +5029,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5200,1 +5133,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5266,1 +5198,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5352,1 +5283,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5359,1 +5289,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -5669,1 +5598,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -5896,1 +5824,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"must support\"));\n@@ -5912,1 +5839,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"must support\"));\n@@ -5920,1 +5846,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"must support\"));\n@@ -5928,1 +5853,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"must support\"));\n@@ -6005,1 +5929,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6016,1 +5939,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6024,1 +5946,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6037,1 +5958,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6047,1 +5967,0 @@\n-    NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6055,1 +5974,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6063,1 +5981,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6078,1 +5995,0 @@\n-    NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6095,1 +6011,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6110,1 +6025,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6124,1 +6038,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6141,1 +6054,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6237,1 +6149,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6248,1 +6159,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6255,1 +6165,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6266,1 +6175,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6273,1 +6181,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -6429,1 +6336,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -6436,1 +6342,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7137,1 +7042,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7145,1 +7049,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7156,1 +7059,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7167,1 +7069,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7188,1 +7089,0 @@\n-    NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7279,1 +7179,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7287,1 +7186,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7298,1 +7196,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7305,1 +7202,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7441,1 +7337,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7452,1 +7347,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7460,1 +7354,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7470,1 +7363,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -7862,1 +7754,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7870,1 +7761,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7882,1 +7772,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7925,1 +7814,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7933,1 +7821,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7976,1 +7863,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7984,1 +7870,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -7995,1 +7880,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8072,1 +7956,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8080,1 +7963,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8214,1 +8096,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8222,1 +8103,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8230,1 +8110,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -8237,1 +8116,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -8247,1 +8125,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8294,1 +8171,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8303,1 +8179,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8311,1 +8186,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8319,1 +8193,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -8326,1 +8199,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8337,1 +8209,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -8400,1 +8271,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8407,1 +8277,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8414,1 +8283,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8421,1 +8289,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8430,1 +8297,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8741,1 +8607,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8748,1 +8613,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8761,1 +8625,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8840,1 +8703,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8854,1 +8716,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -8955,1 +8816,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -8993,1 +8853,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -9006,1 +8865,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -9034,1 +8892,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\");)\n@@ -9072,1 +8929,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -9086,1 +8942,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -9441,1 +9296,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9449,1 +9303,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9457,1 +9310,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9465,1 +9317,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9472,1 +9323,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9479,1 +9329,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9496,1 +9345,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9536,1 +9384,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9544,1 +9391,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9554,1 +9400,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9563,1 +9408,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9570,1 +9414,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9577,1 +9420,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9649,1 +9491,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9657,1 +9498,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9667,1 +9507,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9674,1 +9513,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9730,1 +9568,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9833,1 +9670,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9848,1 +9684,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -9909,1 +9744,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -12543,1 +12377,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\");)\n@@ -12551,1 +12384,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\");)\n@@ -15565,1 +15397,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15572,1 +15403,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15582,1 +15412,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -15592,1 +15421,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15603,1 +15431,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15610,1 +15437,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15617,1 +15443,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n@@ -15963,2 +15788,0 @@\n-  \/\/ table D-1 says MMX\/SSE2\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -15971,2 +15794,0 @@\n-  \/\/ table D-1 says MMX\/SSE2\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":179,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  } else if ((UseSSE >= 1 && cur->type() == T_FLOAT) || (UseSSE >= 2 && cur->type() == T_DOUBLE)) {\n+  } else if (cur->type() == T_FLOAT || cur->type() == T_DOUBLE) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,10 +337,8 @@\n-    if (UseSSE >= 2) {\n-      int xmm_off = xmm_regs_as_doubles_off;\n-      for (int n = 0; n < FrameMap::nof_xmm_regs; n++) {\n-        if (n < xmm_bypass_limit) {\n-          VMReg xmm_name_0 = as_XMMRegister(n)->as_VMReg();\n-          map->set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);\n-          \/\/ %%% This is really a waste but we'll keep things as they were for now\n-          if (true) {\n-            map->set_callee_saved(VMRegImpl::stack2reg(xmm_off + 1 + num_rt_args), xmm_name_0->next());\n-          }\n+    int xmm_off = xmm_regs_as_doubles_off;\n+    for (int n = 0; n < FrameMap::nof_xmm_regs; n++) {\n+      if (n < xmm_bypass_limit) {\n+        VMReg xmm_name_0 = as_XMMRegister(n)->as_VMReg();\n+        map->set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);\n+        \/\/ %%% This is really a waste but we'll keep things as they were for now\n+        if (true) {\n+          map->set_callee_saved(VMRegImpl::stack2reg(xmm_off + 1 + num_rt_args), xmm_name_0->next());\n@@ -348,1 +346,0 @@\n-        xmm_off += 2;\n@@ -350,1 +347,1 @@\n-      assert(xmm_off == float_regs_as_doubles_off, \"incorrect number of xmm registers\");\n+      xmm_off += 2;\n@@ -352,0 +349,1 @@\n+    assert(xmm_off == float_regs_as_doubles_off, \"incorrect number of xmm registers\");\n@@ -372,13 +370,11 @@\n-    if (UseSSE >= 2) {\n-      \/\/ save XMM registers\n-      \/\/ XMM registers can contain float or double values, but this is not known here,\n-      \/\/ so always save them as doubles.\n-      \/\/ note that float values are _not_ converted automatically, so for float values\n-      \/\/ the second word contains only garbage data.\n-      int xmm_bypass_limit = FrameMap::get_num_caller_save_xmms();\n-      int offset = 0;\n-      for (int n = 0; n < xmm_bypass_limit; n++) {\n-        XMMRegister xmm_name = as_XMMRegister(n);\n-        __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);\n-        offset += 8;\n-      }\n+    \/\/ save XMM registers\n+    \/\/ XMM registers can contain float or double values, but this is not known here,\n+    \/\/ so always save them as doubles.\n+    \/\/ note that float values are _not_ converted automatically, so for float values\n+    \/\/ the second word contains only garbage data.\n+    int xmm_bypass_limit = FrameMap::get_num_caller_save_xmms();\n+    int offset = 0;\n+    for (int n = 0; n < xmm_bypass_limit; n++) {\n+      XMMRegister xmm_name = as_XMMRegister(n);\n+      __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);\n+      offset += 8;\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1135,1 +1135,0 @@\n-    assert(UseSSE > 0, \"required\");\n@@ -1143,1 +1142,0 @@\n-    assert(UseSSE > 1, \"required\");\n@@ -4111,1 +4109,1 @@\n-    if (UseAVX >= 2 && UseSSE >= 2) {\n+    if (UseAVX >= 2) {\n@@ -4258,1 +4256,1 @@\n-  if (UseAVX >= 2 && UseSSE >= 2) {\n+  if (UseAVX >= 2) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    __ load_float(src);\n+    __ movflt(xmm0, src);\n@@ -84,1 +84,1 @@\n-    __ load_double(src);\n+    __ movdbl(xmm0, src);\n@@ -187,1 +187,1 @@\n-    __ store_float(dst);\n+    __ movflt(dst, xmm0);\n@@ -191,1 +191,1 @@\n-    __ store_double(dst);\n+    __ movdbl(dst, xmm0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,25 +56,10 @@\n-    if (UseSSE >= 2) {\n-      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n-      __ subptr(rsp, xmm_size * 8);\n-      __ movdbl(Address(rsp, xmm_size * 0), xmm0);\n-      __ movdbl(Address(rsp, xmm_size * 1), xmm1);\n-      __ movdbl(Address(rsp, xmm_size * 2), xmm2);\n-      __ movdbl(Address(rsp, xmm_size * 3), xmm3);\n-      __ movdbl(Address(rsp, xmm_size * 4), xmm4);\n-      __ movdbl(Address(rsp, xmm_size * 5), xmm5);\n-      __ movdbl(Address(rsp, xmm_size * 6), xmm6);\n-      __ movdbl(Address(rsp, xmm_size * 7), xmm7);\n-    } else if (UseSSE >= 1) {\n-      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n-      __ subptr(rsp, xmm_size * 8);\n-      __ movflt(Address(rsp, xmm_size * 0), xmm0);\n-      __ movflt(Address(rsp, xmm_size * 1), xmm1);\n-      __ movflt(Address(rsp, xmm_size * 2), xmm2);\n-      __ movflt(Address(rsp, xmm_size * 3), xmm3);\n-      __ movflt(Address(rsp, xmm_size * 4), xmm4);\n-      __ movflt(Address(rsp, xmm_size * 5), xmm5);\n-      __ movflt(Address(rsp, xmm_size * 6), xmm6);\n-      __ movflt(Address(rsp, xmm_size * 7), xmm7);\n-    } else {\n-      __ push_FPU_state();\n-    }\n+    const int xmm_size = wordSize * 2;\n+    __ subptr(rsp, xmm_size * 8);\n+    __ movdbl(Address(rsp, xmm_size * 0), xmm0);\n+    __ movdbl(Address(rsp, xmm_size * 1), xmm1);\n+    __ movdbl(Address(rsp, xmm_size * 2), xmm2);\n+    __ movdbl(Address(rsp, xmm_size * 3), xmm3);\n+    __ movdbl(Address(rsp, xmm_size * 4), xmm4);\n+    __ movdbl(Address(rsp, xmm_size * 5), xmm5);\n+    __ movdbl(Address(rsp, xmm_size * 6), xmm6);\n+    __ movdbl(Address(rsp, xmm_size * 7), xmm7);\n@@ -86,25 +71,10 @@\n-    if (UseSSE >= 2) {\n-      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n-      __ movdbl(xmm0, Address(rsp, xmm_size * 0));\n-      __ movdbl(xmm1, Address(rsp, xmm_size * 1));\n-      __ movdbl(xmm2, Address(rsp, xmm_size * 2));\n-      __ movdbl(xmm3, Address(rsp, xmm_size * 3));\n-      __ movdbl(xmm4, Address(rsp, xmm_size * 4));\n-      __ movdbl(xmm5, Address(rsp, xmm_size * 5));\n-      __ movdbl(xmm6, Address(rsp, xmm_size * 6));\n-      __ movdbl(xmm7, Address(rsp, xmm_size * 7));\n-      __ addptr(rsp, xmm_size * 8);\n-    } else if (UseSSE >= 1) {\n-      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n-      __ movflt(xmm0, Address(rsp, xmm_size * 0));\n-      __ movflt(xmm1, Address(rsp, xmm_size * 1));\n-      __ movflt(xmm2, Address(rsp, xmm_size * 2));\n-      __ movflt(xmm3, Address(rsp, xmm_size * 3));\n-      __ movflt(xmm4, Address(rsp, xmm_size * 4));\n-      __ movflt(xmm5, Address(rsp, xmm_size * 5));\n-      __ movflt(xmm6, Address(rsp, xmm_size * 6));\n-      __ movflt(xmm7, Address(rsp, xmm_size * 7));\n-      __ addptr(rsp, xmm_size * 8);\n-    } else {\n-      __ pop_FPU_state();\n-    }\n+    const int xmm_size = wordSize * 2;\n+    __ movdbl(xmm0, Address(rsp, xmm_size * 0));\n+    __ movdbl(xmm1, Address(rsp, xmm_size * 1));\n+    __ movdbl(xmm2, Address(rsp, xmm_size * 2));\n+    __ movdbl(xmm3, Address(rsp, xmm_size * 3));\n+    __ movdbl(xmm4, Address(rsp, xmm_size * 4));\n+    __ movdbl(xmm5, Address(rsp, xmm_size * 5));\n+    __ movdbl(xmm6, Address(rsp, xmm_size * 6));\n+    __ movdbl(xmm7, Address(rsp, xmm_size * 7));\n+    __ addptr(rsp, xmm_size * 8);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":20,"deletions":50,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -420,2 +420,2 @@\n-    case ftos: load_float(val_addr);                break;\n-    case dtos: load_double(val_addr);               break;\n+    case ftos: movflt(xmm0, val_addr);              break;\n+    case dtos: movdbl(xmm0, val_addr);              break;\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2176,48 +2176,0 @@\n-void MacroAssembler::load_float(Address src) {\n-#ifdef _LP64\n-  movflt(xmm0, src);\n-#else\n-  if (UseSSE >= 1) {\n-    movflt(xmm0, src);\n-  } else {\n-    fld_s(src);\n-  }\n-#endif \/\/ LP64\n-}\n-\n-void MacroAssembler::store_float(Address dst) {\n-#ifdef _LP64\n-  movflt(dst, xmm0);\n-#else\n-  if (UseSSE >= 1) {\n-    movflt(dst, xmm0);\n-  } else {\n-    fstp_s(dst);\n-  }\n-#endif \/\/ LP64\n-}\n-\n-void MacroAssembler::load_double(Address src) {\n-#ifdef _LP64\n-  movdbl(xmm0, src);\n-#else\n-  if (UseSSE >= 2) {\n-    movdbl(xmm0, src);\n-  } else {\n-    fld_d(src);\n-  }\n-#endif \/\/ LP64\n-}\n-\n-void MacroAssembler::store_double(Address dst) {\n-#ifdef _LP64\n-  movdbl(dst, xmm0);\n-#else\n-  if (UseSSE >= 2) {\n-    movdbl(dst, xmm0);\n-  } else {\n-    fstp_d(dst);\n-  }\n-#endif \/\/ LP64\n-}\n-\n@@ -4189,7 +4141,0 @@\n-static int FPUSaveAreaSize = align_up(108, StackAlignmentInBytes); \/\/ 108 bytes needed for FPU state by fsave\/frstor\n-\n-#ifndef _LP64\n-static bool use_x87_registers() { return UseSSE < 2; }\n-#endif\n-static bool use_xmm_registers() { return UseSSE >= 1; }\n-\n@@ -4197,1 +4142,1 @@\n-static int xmm_save_size() { return UseSSE >= 2 ? sizeof(double) : sizeof(float); }\n+static int xmm_save_size() { return sizeof(double); }\n@@ -4200,5 +4145,1 @@\n-  if (UseSSE == 1) {\n-    masm->movflt(Address(rsp, offset), reg);\n-  } else {\n-    masm->movdbl(Address(rsp, offset), reg);\n-  }\n+  masm->movdbl(Address(rsp, offset), reg);\n@@ -4208,5 +4149,1 @@\n-  if (UseSSE == 1) {\n-    masm->movflt(reg, Address(rsp, offset));\n-  } else {\n-    masm->movdbl(reg, Address(rsp, offset));\n-  }\n+  masm->movdbl(reg, Address(rsp, offset));\n@@ -4216,2 +4153,1 @@\n-                                  bool save_fpu, int& gp_area_size,\n-                                  int& fp_area_size, int& xmm_area_size) {\n+                                  bool save_fpu, int& gp_area_size, int& xmm_area_size) {\n@@ -4221,6 +4157,1 @@\n-#ifdef _LP64\n-  fp_area_size = 0;\n-#else\n-  fp_area_size = (save_fpu && use_x87_registers()) ? FPUSaveAreaSize : 0;\n-#endif\n-  xmm_area_size = (save_fpu && use_xmm_registers()) ? xmm_registers.size() * xmm_save_size() : 0;\n+  xmm_area_size = save_fpu ? xmm_registers.size() * xmm_save_size() : 0;\n@@ -4228,1 +4159,1 @@\n-  return gp_area_size + fp_area_size + xmm_area_size;\n+  return gp_area_size + xmm_area_size;\n@@ -4237,1 +4168,0 @@\n-  int fp_area_size;\n@@ -4240,1 +4170,1 @@\n-                                               gp_area_size, fp_area_size, xmm_area_size);\n+                                               gp_area_size, xmm_area_size);\n@@ -4245,8 +4175,2 @@\n-#ifndef _LP64\n-  if (save_fpu && use_x87_registers()) {\n-    fnsave(Address(rsp, gp_area_size));\n-    fwait();\n-  }\n-#endif\n-  if (save_fpu && use_xmm_registers()) {\n-    push_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  if (save_fpu) {\n+    push_set(call_clobbered_xmm_registers(), gp_area_size);\n@@ -4264,1 +4188,0 @@\n-  int fp_area_size;\n@@ -4267,1 +4190,1 @@\n-                                               gp_area_size, fp_area_size, xmm_area_size);\n+                                               gp_area_size, xmm_area_size);\n@@ -4269,2 +4192,2 @@\n-  if (restore_fpu && use_xmm_registers()) {\n-    pop_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  if (restore_fpu) {\n+    pop_set(call_clobbered_xmm_registers(), gp_area_size);\n@@ -4272,5 +4195,0 @@\n-#ifndef _LP64\n-  if (restore_fpu && use_x87_registers()) {\n-    frstor(Address(rsp, gp_area_size));\n-  }\n-#endif\n@@ -6742,33 +6660,1 @@\n-  if (UseSSE < 2) {\n-    Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;\n-    \/\/ Fill 32-byte chunks\n-    subptr(count, 8 << shift);\n-    jcc(Assembler::less, L_check_fill_8_bytes);\n-    align(16);\n-\n-    BIND(L_fill_32_bytes_loop);\n-\n-    for (int i = 0; i < 32; i += 4) {\n-      movl(Address(to, i), value);\n-    }\n-\n-    addptr(to, 32);\n-    subptr(count, 8 << shift);\n-    jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);\n-    BIND(L_check_fill_8_bytes);\n-    addptr(count, 8 << shift);\n-    jccb(Assembler::zero, L_exit);\n-    jmpb(L_fill_8_bytes);\n-\n-    \/\/\n-    \/\/ length is too short, just fill qwords\n-    \/\/\n-    BIND(L_fill_8_bytes_loop);\n-    movl(Address(to, 0), value);\n-    movl(Address(to, 4), value);\n-    addptr(to, 8);\n-    BIND(L_fill_8_bytes);\n-    subptr(count, 1 << (shift + 1));\n-    jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);\n-    \/\/ fall through to fill 4 bytes\n-  } else {\n+  {\n@@ -6786,1 +6672,0 @@\n-      assert( UseSSE >= 2, \"supported cpu only\" );\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":128,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -517,16 +517,0 @@\n-  \/\/ Load float value from 'address'. If UseSSE >= 1, the value is loaded into\n-  \/\/ register xmm0. Otherwise, the value is loaded onto the FPU stack.\n-  void load_float(Address src);\n-\n-  \/\/ Store float value to 'address'. If UseSSE >= 1, the value is stored\n-  \/\/ from register xmm0. Otherwise, the value is stored from the FPU stack.\n-  void store_float(Address dst);\n-\n-  \/\/ Load double value from 'address'. If UseSSE >= 2, the value is loaded into\n-  \/\/ register xmm0. Otherwise, the value is loaded onto the FPU stack.\n-  void load_double(Address src);\n-\n-  \/\/ Store double value to 'address'. If UseSSE >= 2, the value is stored\n-  \/\/ from register xmm0. Otherwise, the value is stored from the FPU stack.\n-  void store_double(Address dst);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -654,1 +654,0 @@\n-#ifdef _LP64\n@@ -656,9 +655,0 @@\n-#else\n-  if  (UseSSE >= 2) {\n-    __ movdbl(Address(rsp, 0), xmm0);\n-  } else if (UseSSE == 1) {\n-    __ movflt(Address(rsp, 0), xmm0);\n-  } else {\n-    __ fst_d(Address(rsp, 0));\n-  }\n-#endif \/\/ LP64\n@@ -679,1 +669,0 @@\n-#ifdef _LP64\n@@ -681,9 +670,0 @@\n-#else\n-  if  (UseSSE >= 2) {\n-    __ movdbl(xmm0, Address(rsp, 0));\n-  } else if (UseSSE == 1) {\n-    __ movflt(xmm0, Address(rsp, 0));\n-  } else {\n-    __ fld_d(Address(rsp, 0));\n-  }\n-#endif \/\/ LP64\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -279,17 +279,12 @@\n-  if (UseSSE >= 1) {\n-    static float one = 1.0f, two = 2.0f;\n-    switch (value) {\n-    case 0:\n-      __ xorps(xmm0, xmm0);\n-      break;\n-    case 1:\n-      __ movflt(xmm0, ExternalAddress((address) &one), rscratch1);\n-      break;\n-    case 2:\n-      __ movflt(xmm0, ExternalAddress((address) &two), rscratch1);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-    }\n-  } else {\n+  static float one = 1.0f, two = 2.0f;\n+  switch (value) {\n+  case 0:\n+    __ xorps(xmm0, xmm0);\n+    break;\n+  case 1:\n+    __ movflt(xmm0, ExternalAddress((address) &one), rscratch1);\n+    break;\n+  case 2:\n+    __ movflt(xmm0, ExternalAddress((address) &two), rscratch1);\n+    break;\n+  default:\n@@ -297,0 +292,1 @@\n+    break;\n@@ -302,14 +298,9 @@\n-  if (UseSSE >= 2) {\n-    static double one = 1.0;\n-    switch (value) {\n-    case 0:\n-      __ xorpd(xmm0, xmm0);\n-      break;\n-    case 1:\n-      __ movdbl(xmm0, ExternalAddress((address) &one), rscratch1);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-    }\n-  } else {\n+  static double one = 1.0;\n+  switch (value) {\n+  case 0:\n+    __ xorpd(xmm0, xmm0);\n+    break;\n+  case 1:\n+    __ movdbl(xmm0, ExternalAddress((address) &one), rscratch1);\n+    break;\n+  default:\n@@ -317,0 +308,1 @@\n+    break;\n@@ -376,1 +368,1 @@\n-  __ load_float(Address(rcx, rbx, Address::times_ptr, base_offset));\n+  __ movflt(xmm0, Address(rcx, rbx, Address::times_ptr, base_offset));\n@@ -455,1 +447,1 @@\n-  __ load_double(Address(rcx, rbx, Address::times_ptr, base_offset));\n+  __ movdbl(xmm0, Address(rcx, rbx, Address::times_ptr, base_offset));\n@@ -509,1 +501,1 @@\n-      __ load_float(field);\n+      __ movflt(xmm0, field);\n@@ -564,1 +556,1 @@\n-      __ load_double(field);\n+      __ movdbl(xmm0, field);\n@@ -658,1 +650,1 @@\n-  __ load_float(faddress(rbx));\n+  __ movflt(xmm0, faddress(rbx));\n@@ -664,1 +656,1 @@\n-  __ load_double(daddress(rbx));\n+  __ movdbl(xmm0, daddress(rbx));\n@@ -695,1 +687,1 @@\n-  __ load_float(faddress(rbx));\n+  __ movflt(xmm0, faddress(rbx));\n@@ -701,1 +693,1 @@\n-  __ load_double(daddress(rbx));\n+  __ movdbl(xmm0, daddress(rbx));\n@@ -855,1 +847,1 @@\n-  __ load_float(faddress(n));\n+  __ movflt(xmm0, faddress(n));\n@@ -860,1 +852,1 @@\n-  __ load_double(daddress(n));\n+  __ movdbl(xmm0, daddress(n));\n@@ -962,1 +954,1 @@\n-  __ store_float(faddress(rbx));\n+  __ movflt(faddress(rbx), xmm0);\n@@ -968,1 +960,1 @@\n-  __ store_double(daddress(rbx));\n+  __ movdbl(daddress(rbx), xmm0);\n@@ -1044,1 +1036,1 @@\n-  \/\/ value is in UseSSE >= 1 ? xmm0 : ST(0)\n+  \/\/ value is in xmm0\n@@ -1057,1 +1049,1 @@\n-  \/\/ value is in UseSSE >= 2 ? xmm0 : ST(0)\n+  \/\/ value is in xmm0\n@@ -1173,1 +1165,1 @@\n-  __ store_float(faddress(n));\n+  __ movflt(faddress(n), xmm0);\n@@ -1178,1 +1170,1 @@\n-  __ store_double(daddress(n));\n+  __ movdbl(daddress(n), xmm0);\n@@ -1400,35 +1392,30 @@\n-  if (UseSSE >= 1) {\n-    switch (op) {\n-    case add:\n-      __ addss(xmm0, at_rsp());\n-      __ addptr(rsp, Interpreter::stackElementSize);\n-      break;\n-    case sub:\n-      __ movflt(xmm1, xmm0);\n-      __ pop_f(xmm0);\n-      __ subss(xmm0, xmm1);\n-      break;\n-    case mul:\n-      __ mulss(xmm0, at_rsp());\n-      __ addptr(rsp, Interpreter::stackElementSize);\n-      break;\n-    case div:\n-      __ movflt(xmm1, xmm0);\n-      __ pop_f(xmm0);\n-      __ divss(xmm0, xmm1);\n-      break;\n-    case rem:\n-      \/\/ On x86_64 platforms the SharedRuntime::frem method is called to perform the\n-      \/\/ modulo operation. The frem method calls the function\n-      \/\/ double fmod(double x, double y) in math.h. The documentation of fmod states:\n-      \/\/ \"If x or y is a NaN, a NaN is returned.\" without specifying what type of NaN\n-      \/\/ (signalling or quiet) is returned.\n-      __ movflt(xmm1, xmm0);\n-      __ pop_f(xmm0);\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem), 2);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-    }\n-  } else {\n+  switch (op) {\n+  case add:\n+    __ addss(xmm0, at_rsp());\n+    __ addptr(rsp, Interpreter::stackElementSize);\n+    break;\n+  case sub:\n+    __ movflt(xmm1, xmm0);\n+    __ pop_f(xmm0);\n+    __ subss(xmm0, xmm1);\n+    break;\n+  case mul:\n+    __ mulss(xmm0, at_rsp());\n+    __ addptr(rsp, Interpreter::stackElementSize);\n+    break;\n+  case div:\n+    __ movflt(xmm1, xmm0);\n+    __ pop_f(xmm0);\n+    __ divss(xmm0, xmm1);\n+    break;\n+  case rem:\n+    \/\/ On x86_64 platforms the SharedRuntime::frem method is called to perform the\n+    \/\/ modulo operation. The frem method calls the function\n+    \/\/ double fmod(double x, double y) in math.h. The documentation of fmod states:\n+    \/\/ \"If x or y is a NaN, a NaN is returned.\" without specifying what type of NaN\n+    \/\/ (signalling or quiet) is returned.\n+    __ movflt(xmm1, xmm0);\n+    __ pop_f(xmm0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem), 2);\n+    break;\n+  default:\n@@ -1436,0 +1423,1 @@\n+    break;\n@@ -1441,33 +1429,28 @@\n-  if (UseSSE >= 2) {\n-    switch (op) {\n-    case add:\n-      __ addsd(xmm0, at_rsp());\n-      __ addptr(rsp, 2 * Interpreter::stackElementSize);\n-      break;\n-    case sub:\n-      __ movdbl(xmm1, xmm0);\n-      __ pop_d(xmm0);\n-      __ subsd(xmm0, xmm1);\n-      break;\n-    case mul:\n-      __ mulsd(xmm0, at_rsp());\n-      __ addptr(rsp, 2 * Interpreter::stackElementSize);\n-      break;\n-    case div:\n-      __ movdbl(xmm1, xmm0);\n-      __ pop_d(xmm0);\n-      __ divsd(xmm0, xmm1);\n-      break;\n-    case rem:\n-      \/\/ Similar to fop2(), the modulo operation is performed using the\n-      \/\/ SharedRuntime::drem method on x86_64 platforms for the same reasons\n-      \/\/ as mentioned in fop2().\n-      __ movdbl(xmm1, xmm0);\n-      __ pop_d(xmm0);\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem), 2);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-    }\n-  } else {\n+  switch (op) {\n+  case add:\n+    __ addsd(xmm0, at_rsp());\n+    __ addptr(rsp, 2 * Interpreter::stackElementSize);\n+    break;\n+  case sub:\n+    __ movdbl(xmm1, xmm0);\n+    __ pop_d(xmm0);\n+    __ subsd(xmm0, xmm1);\n+    break;\n+  case mul:\n+    __ mulsd(xmm0, at_rsp());\n+    __ addptr(rsp, 2 * Interpreter::stackElementSize);\n+    break;\n+  case div:\n+    __ movdbl(xmm1, xmm0);\n+    __ pop_d(xmm0);\n+    __ divsd(xmm0, xmm1);\n+    break;\n+  case rem:\n+    \/\/ Similar to fop2(), the modulo operation is performed using the\n+    \/\/ SharedRuntime::drem method on x86_64 platforms for the same reasons\n+    \/\/ as mentioned in fop2().\n+    __ movdbl(xmm1, xmm0);\n+    __ pop_d(xmm0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem), 2);\n+    break;\n+  default:\n@@ -1475,0 +1458,1 @@\n+    break;\n@@ -1505,6 +1489,2 @@\n-  if (UseSSE >= 1) {\n-    static jlong *float_signflip  = double_quadword(&float_signflip_pool[1],  CONST64(0x8000000080000000),  CONST64(0x8000000080000000));\n-    __ xorps(xmm0, ExternalAddress((address) float_signflip), rscratch1);\n-  } else {\n-    ShouldNotReachHere();\n-  }\n+  static jlong *float_signflip  = double_quadword(&float_signflip_pool[1],  CONST64(0x8000000080000000),  CONST64(0x8000000080000000));\n+  __ xorps(xmm0, ExternalAddress((address) float_signflip), rscratch1);\n@@ -1515,7 +1495,3 @@\n-  if (UseSSE >= 2) {\n-    static jlong *double_signflip =\n-      double_quadword(&double_signflip_pool[1], CONST64(0x8000000000000000), CONST64(0x8000000000000000));\n-    __ xorpd(xmm0, ExternalAddress((address) double_signflip), rscratch1);\n-  } else {\n-    ShouldNotReachHere();\n-  }\n+  static jlong *double_signflip =\n+    double_quadword(&double_signflip_pool[1], CONST64(0x8000000000000000), CONST64(0x8000000000000000));\n+  __ xorpd(xmm0, ExternalAddress((address) double_signflip), rscratch1);\n@@ -1685,27 +1661,5 @@\n-  if ((is_float && UseSSE >= 1) ||\n-      (!is_float && UseSSE >= 2)) {\n-    Label done;\n-    if (is_float) {\n-      \/\/ XXX get rid of pop here, use ... reg, mem32\n-      __ pop_f(xmm1);\n-      __ ucomiss(xmm1, xmm0);\n-    } else {\n-      \/\/ XXX get rid of pop here, use ... reg, mem64\n-      __ pop_d(xmm1);\n-      __ ucomisd(xmm1, xmm0);\n-    }\n-    if (unordered_result < 0) {\n-      __ movl(rax, -1);\n-      __ jccb(Assembler::parity, done);\n-      __ jccb(Assembler::below, done);\n-      __ setb(Assembler::notEqual, rdx);\n-      __ movzbl(rax, rdx);\n-    } else {\n-      __ movl(rax, 1);\n-      __ jccb(Assembler::parity, done);\n-      __ jccb(Assembler::above, done);\n-      __ movl(rax, 0);\n-      __ jccb(Assembler::equal, done);\n-      __ decrementl(rax);\n-    }\n-    __ bind(done);\n+  Label done;\n+  if (is_float) {\n+    \/\/ XXX get rid of pop here, use ... reg, mem32\n+    __ pop_f(xmm1);\n+    __ ucomiss(xmm1, xmm0);\n@@ -1713,1 +1667,17 @@\n-    ShouldNotReachHere();\n+    \/\/ XXX get rid of pop here, use ... reg, mem64\n+    __ pop_d(xmm1);\n+    __ ucomisd(xmm1, xmm0);\n+  }\n+  if (unordered_result < 0) {\n+    __ movl(rax, -1);\n+    __ jccb(Assembler::parity, done);\n+    __ jccb(Assembler::below, done);\n+    __ setb(Assembler::notEqual, rdx);\n+    __ movzbl(rax, rdx);\n+  } else {\n+    __ movl(rax, 1);\n+    __ jccb(Assembler::parity, done);\n+    __ jccb(Assembler::above, done);\n+    __ movl(rax, 0);\n+    __ jccb(Assembler::equal, done);\n+    __ decrementl(rax);\n@@ -1715,0 +1685,1 @@\n+  __ bind(done);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":127,"deletions":156,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-  if (supports_fma() && UseSSE >= 2) { \/\/ Check UseSSE since FMA code uses SSE instructions\n+  if (supports_fma()) {\n@@ -1329,9 +1329,0 @@\n-#ifdef COMPILER2\n-  if (UseFPUForSpilling) {\n-    if (UseSSE < 2) {\n-      \/\/ Only supported with SSE2+\n-      FLAG_SET_DEFAULT(UseFPUForSpilling, false);\n-    }\n-  }\n-#endif\n-\n@@ -1340,5 +1331,1 @@\n-  if (UseSSE < 2) {\n-    \/\/ Vectors (in XMM) are only supported with SSE2+\n-    \/\/ SSE is always 2 on x64.\n-    max_vector_size = 0;\n-  } else if (UseAVX == 0 || !os_supports_avx_vectors()) {\n+  if (UseAVX == 0 || !os_supports_avx_vectors()) {\n@@ -1859,1 +1846,1 @@\n-  if (!UseFastStosb && UseSSE >= 2 && UseUnalignedLoadStores) {\n+  if (!UseFastStosb && UseUnalignedLoadStores) {\n@@ -1974,1 +1961,1 @@\n-    if (AllocatePrefetchStyle <= 0 || (UseSSE == 0 && !supports_3dnow_prefetch())) {\n+    if (AllocatePrefetchStyle <= 0) {\n@@ -1978,1 +1965,7 @@\n-      if (UseSSE == 0 && supports_3dnow_prefetch()) {\n+      if (AllocatePrefetchInstr == 0) {\n+        log->print(\"PREFETCHNTA\");\n+      } else if (AllocatePrefetchInstr == 1) {\n+        log->print(\"PREFETCHT0\");\n+      } else if (AllocatePrefetchInstr == 2) {\n+        log->print(\"PREFETCHT2\");\n+      } else if (AllocatePrefetchInstr == 3) {\n@@ -1980,10 +1973,0 @@\n-      } else if (UseSSE >= 1) {\n-        if (AllocatePrefetchInstr == 0) {\n-          log->print(\"PREFETCHNTA\");\n-        } else if (AllocatePrefetchInstr == 1) {\n-          log->print(\"PREFETCHT0\");\n-        } else if (AllocatePrefetchInstr == 2) {\n-          log->print(\"PREFETCHT2\");\n-        } else if (AllocatePrefetchInstr == 3) {\n-          log->print(\"PREFETCHW\");\n-        }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1371,5 +1371,0 @@\n-    case Op_AddReductionVL:\n-      if (UseSSE < 2) { \/\/ requires at least SSE2\n-        return false;\n-      }\n-      break;\n@@ -1559,10 +1554,0 @@\n-    case Op_SignumF:\n-      if (UseSSE < 1) {\n-        return false;\n-      }\n-      break;\n-    case Op_SignumD:\n-      if (UseSSE < 2) {\n-        return false;\n-      }\n-      break;\n@@ -1574,10 +1559,0 @@\n-    case Op_SqrtF:\n-      if (UseSSE < 1) {\n-        return false;\n-      }\n-      break;\n-    case Op_SqrtD:\n-      if (UseSSE < 2) {\n-        return false;\n-      }\n-      break;\n@@ -2176,1 +2151,0 @@\n-  if (UseSSE < 2) return 0;\n@@ -2886,1 +2860,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -2898,1 +2872,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -2910,1 +2884,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -2957,1 +2931,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -2969,1 +2943,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -2981,1 +2955,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3028,1 +3002,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3040,1 +3014,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3052,1 +3026,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3099,1 +3073,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3111,1 +3085,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3123,1 +3097,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3170,1 +3144,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3182,1 +3156,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3194,1 +3168,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3241,1 +3215,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3253,1 +3227,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3265,1 +3239,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3312,1 +3286,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3324,1 +3298,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3336,1 +3310,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3383,1 +3357,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3395,1 +3369,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3407,1 +3381,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3454,1 +3428,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3478,1 +3452,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3504,1 +3478,1 @@\n-  predicate((UseSSE>=1) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3527,1 +3501,1 @@\n-  predicate((UseSSE>=2) && (UseAVX == 0));\n+  predicate(UseAVX == 0);\n@@ -3554,1 +3528,0 @@\n-  predicate(UseSSE>=1);\n@@ -3566,1 +3539,0 @@\n-  predicate(UseSSE>=2);\n@@ -4488,1 +4460,1 @@\n-  predicate(UseSSE >= 2 && Matcher::is_non_long_integral_vector(n));\n+  predicate(Matcher::is_non_long_integral_vector(n));\n@@ -4568,1 +4540,1 @@\n-  predicate(UseSSE >= 2 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -6940,1 +6912,0 @@\n-      assert(UseSSE >= 2, \"required\");\n@@ -8314,1 +8285,0 @@\n-      assert(UseSSE >= 2, \"required\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":30,"deletions":60,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  enum { count = 3 IA32_ONLY( + 1 ) };\n+  enum { count = 3 };\n@@ -575,4 +575,4 @@\n-bool         dfa_shared_preds::_found[dfa_shared_preds::count] = { false,          false,           false               IA32_ONLY(COMMA false)  };\n-const char*  dfa_shared_preds::_type [dfa_shared_preds::count] = { \"int\",          \"jlong\",         \"intptr_t\"          IA32_ONLY(COMMA \"bool\") };\n-const char*  dfa_shared_preds::_var  [dfa_shared_preds::count] = { \"_n_get_int__\", \"_n_get_long__\", \"_n_get_intptr_t__\" IA32_ONLY(COMMA \"Compile__current____select_24_bit_instr__\") };\n-const char*  dfa_shared_preds::_pred [dfa_shared_preds::count] = { \"n->get_int()\", \"n->get_long()\", \"n->get_intptr_t()\" IA32_ONLY(COMMA \"Compile::current()->select_24_bit_instr()\") };\n+bool         dfa_shared_preds::_found[dfa_shared_preds::count] = { false,          false,           false               };\n+const char*  dfa_shared_preds::_type [dfa_shared_preds::count] = { \"int\",          \"jlong\",         \"intptr_t\"          };\n+const char*  dfa_shared_preds::_var  [dfa_shared_preds::count] = { \"_n_get_int__\", \"_n_get_long__\", \"_n_get_intptr_t__\" };\n+const char*  dfa_shared_preds::_pred [dfa_shared_preds::count] = { \"n->get_int()\", \"n->get_long()\", \"n->get_intptr_t()\" };\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1090,33 +1090,13 @@\n-    if (IA32_ONLY( (UseSSE == 1 && opr_type == T_FLOAT) || UseSSE >= 2 ) NOT_IA32( true )) {\n-      \/\/ SSE float instruction (T_DOUBLE only supported with SSE2)\n-      switch (op->code()) {\n-        case lir_cmp:\n-        case lir_add:\n-        case lir_sub:\n-        case lir_mul:\n-        case lir_div:\n-        {\n-          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n-          LIR_Op2* op2 = (LIR_Op2*)op;\n-          if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {\n-            assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), \"cannot mark second operand as stack if others are not in register\");\n-            return shouldHaveRegister;\n-          }\n-        }\n-        default:\n-          break;\n-      }\n-    } else {\n-      \/\/ FPU stack float instruction\n-      switch (op->code()) {\n-        case lir_add:\n-        case lir_sub:\n-        case lir_mul:\n-        case lir_div:\n-        {\n-          assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n-          LIR_Op2* op2 = (LIR_Op2*)op;\n-          if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {\n-            assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), \"cannot mark second operand as stack if others are not in register\");\n-            return shouldHaveRegister;\n-          }\n+    \/\/ SSE float instruction\n+    switch (op->code()) {\n+      case lir_cmp:\n+      case lir_add:\n+      case lir_sub:\n+      case lir_mul:\n+      case lir_div:\n+      {\n+        assert(op->as_Op2() != nullptr, \"must be LIR_Op2\");\n+        LIR_Op2* op2 = (LIR_Op2*)op;\n+        if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {\n+          assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), \"cannot mark second operand as stack if others are not in register\");\n+          return shouldHaveRegister;\n@@ -1124,2 +1104,0 @@\n-        default:\n-          break;\n@@ -1127,0 +1105,2 @@\n+      default:\n+        break;\n@@ -1287,10 +1267,6 @@\n-#ifdef X86\n-    if (UseSSE < 2) {\n-#endif \/\/ X86\n-      for (i = 0; i < FrameMap::nof_caller_save_fpu_regs; i++) {\n-        LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);\n-        assert(opr->is_valid() && opr->is_register(), \"FrameMap should not return invalid operands\");\n-        assert(reg_numHi(opr) == -1, \"missing addition of range for hi-register\");\n-        caller_save_registers[num_caller_save_registers++] = reg_num(opr);\n-      }\n-#ifdef X86\n+#ifndef X86\n+    for (i = 0; i < FrameMap::nof_caller_save_fpu_regs; i++) {\n+      LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);\n+      assert(opr->is_valid() && opr->is_register(), \"FrameMap should not return invalid operands\");\n+      assert(reg_numHi(opr) == -1, \"missing addition of range for hi-register\");\n+      caller_save_registers[num_caller_save_registers++] = reg_num(opr);\n@@ -1298,11 +1274,7 @@\n-#endif \/\/ X86\n-\n-#ifdef X86\n-    if (UseSSE > 0) {\n-      int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();\n-      for (i = 0; i < num_caller_save_xmm_regs; i ++) {\n-        LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);\n-        assert(opr->is_valid() && opr->is_register(), \"FrameMap should not return invalid operands\");\n-        assert(reg_numHi(opr) == -1, \"missing addition of range for hi-register\");\n-        caller_save_registers[num_caller_save_registers++] = reg_num(opr);\n-      }\n+#else\n+    int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();\n+    for (i = 0; i < num_caller_save_xmm_regs; i ++) {\n+      LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);\n+      assert(opr->is_valid() && opr->is_register(), \"FrameMap should not return invalid operands\");\n+      assert(reg_numHi(opr) == -1, \"missing addition of range for hi-register\");\n+      caller_save_registers[num_caller_save_registers++] = reg_num(opr);\n@@ -2155,10 +2127,3 @@\n-        if (UseSSE >= 1) {\n-          int last_xmm_reg = pd_last_xmm_reg;\n-#ifdef _LP64\n-          if (UseAVX < 3) {\n-            last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n-          }\n-#endif \/\/ LP64\n-          assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= last_xmm_reg, \"no xmm register\");\n-          assert(interval->assigned_regHi() == any_reg, \"must not have hi register\");\n-          return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);\n+        int last_xmm_reg = pd_last_xmm_reg;\n+        if (UseAVX < 3) {\n+          last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n@@ -2166,2 +2131,4 @@\n-#endif \/\/ X86\n-\n+        assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= last_xmm_reg, \"no xmm register\");\n+        assert(interval->assigned_regHi() == any_reg, \"must not have hi register\");\n+        return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);\n+#else\n@@ -2171,0 +2138,1 @@\n+#endif \/\/ !X86\n@@ -2174,11 +2142,4 @@\n-#ifdef X86\n-        if (UseSSE >= 2) {\n-          int last_xmm_reg = pd_last_xmm_reg;\n-#ifdef _LP64\n-          if (UseAVX < 3) {\n-            last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n-          }\n-#endif \/\/ LP64\n-          assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= last_xmm_reg, \"no xmm register\");\n-          assert(interval->assigned_regHi() == any_reg, \"must not have hi register (double xmm values are stored in one register)\");\n-          return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);\n+#if defined(X86)\n+        int last_xmm_reg = pd_last_xmm_reg;\n+        if (UseAVX < 3) {\n+          last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map \/ 2) - 1;\n@@ -2186,3 +2147,4 @@\n-#endif \/\/ X86\n-\n-#if defined(ARM32)\n+        assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= last_xmm_reg, \"no xmm register\");\n+        assert(interval->assigned_regHi() == any_reg, \"must not have hi register (double xmm values are stored in one register)\");\n+        LIR_Opr result = LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);\n+#elif defined(ARM32)\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":44,"deletions":82,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1017,2 +1017,0 @@\n-  IA32_ONLY( set_24_bit_selection_and_mode(true, false); )\n-\n@@ -4096,11 +4094,0 @@\n-#ifdef IA32\n-  \/\/ If original bytecodes contained a mixture of floats and doubles\n-  \/\/ check if the optimizer has made it homogeneous, item (3).\n-  if (UseSSE == 0 &&\n-      frc.get_float_count() > 32 &&\n-      frc.get_double_count() == 0 &&\n-      (10 * frc.get_call_count() < frc.get_float_count()) ) {\n-    set_24_bit_selection_and_mode(false, true);\n-  }\n-#endif \/\/ IA32\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1303,15 +1303,0 @@\n-#ifdef IA32\n- private:\n-  bool _select_24_bit_instr;   \/\/ We selected an instruction with a 24-bit result\n-  bool _in_24_bit_fp_mode;     \/\/ We are emitting instructions with 24-bit results\n-\n-  \/\/ Remember if this compilation changes hardware mode to 24-bit precision.\n-  void set_24_bit_selection_and_mode(bool selection, bool mode) {\n-    _select_24_bit_instr = selection;\n-    _in_24_bit_fp_mode   = mode;\n-  }\n-\n- public:\n-  bool select_24_bit_instr() const { return _select_24_bit_instr; }\n-  bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }\n-#endif \/\/ IA32\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"}]}