{"files":[{"patch":"@@ -29,2 +29,1 @@\n-#include \"gc\/serial\/serialHeap.hpp\"\n-#include \"gc\/serial\/tenuredGeneration.hpp\"\n+#include \"gc\/serial\/serialHeap.inline.hpp\"\n@@ -35,2 +34,1 @@\n-void CardTableRS::younger_refs_in_space_iterate(TenuredSpace* sp,\n-                                                OopIterateClosure* cl) {\n+void CardTableRS::scan_old_to_young_refs(TenuredSpace* sp) {\n@@ -41,1 +39,2 @@\n-    non_clean_card_iterate(sp, urasm, cl, this);\n+    OldGenScanClosure cl(SerialHeap::heap()->young_gen());\n+    non_clean_card_iterate(sp, urasm, &cl, this);\n@@ -228,1 +227,1 @@\n-                                OopIterateClosure* cl,\n+                                OldGenScanClosure* cl,\n@@ -239,1 +238,1 @@\n-                                         OopIterateClosure* cl,\n+                                         OldGenScanClosure* cl,\n@@ -270,1 +269,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class OldGenScanClosure;\n@@ -64,1 +65,1 @@\n-  void younger_refs_in_space_iterate(TenuredSpace* sp, OopIterateClosure* cl);\n+  void scan_old_to_young_refs(TenuredSpace* sp);\n@@ -91,1 +92,1 @@\n-                              OopIterateClosure* cl,\n+                              OldGenScanClosure* cl,\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,85 +64,0 @@\n-class ScavengeHelper {\n-  DefNewGeneration* _young_gen;\n-  HeapWord*         _young_gen_end;\n-public:\n-  ScavengeHelper(DefNewGeneration* young_gen) :\n-    _young_gen(young_gen),\n-    _young_gen_end(young_gen->reserved().end()) {}\n-\n-  bool is_in_young_gen(void* p) const {\n-    return p < _young_gen_end;\n-  }\n-\n-  template <typename T, typename Func>\n-  void try_scavenge(T* p, Func&& f) {\n-    T heap_oop = RawAccess<>::oop_load(p);\n-    \/\/ Should we copy the obj?\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop obj = CompressedOops::decode_not_null(heap_oop);\n-      if (is_in_young_gen(obj)) {\n-        assert(!_young_gen->to()->is_in_reserved(obj), \"Scanning field twice?\");\n-        oop new_obj = obj->is_forwarded() ? obj->forwardee()\n-                                          : _young_gen->copy_to_survivor_space(obj);\n-        RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n-\n-        \/\/ callback\n-        f(new_obj);\n-      }\n-    }\n-  }\n-};\n-\n-class InHeapScanClosure : public BasicOopIterateClosure {\n-  ScavengeHelper _helper;\n-protected:\n-  bool is_in_young_gen(void* p) const {\n-    return _helper.is_in_young_gen(p);\n-  }\n-\n-  template <typename T, typename Func>\n-  void try_scavenge(T* p, Func&& f) {\n-    _helper.try_scavenge(p, f);\n-  }\n-\n-  InHeapScanClosure(DefNewGeneration* young_gen) :\n-    BasicOopIterateClosure(young_gen->ref_processor()),\n-    _helper(young_gen) {}\n-};\n-\n-class OffHeapScanClosure : public OopClosure {\n-  ScavengeHelper _helper;\n-protected:\n-  bool is_in_young_gen(void* p) const {\n-    return _helper.is_in_young_gen(p);\n-  }\n-\n-  template <typename T, typename Func>\n-  void try_scavenge(T* p, Func&& f) {\n-    _helper.try_scavenge(p, f);\n-  }\n-\n-  OffHeapScanClosure(DefNewGeneration* young_gen) :  _helper(young_gen) {}\n-};\n-\n-class OldGenScanClosure : public InHeapScanClosure {\n-  CardTableRS* _rs;\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    assert(!is_in_young_gen(p), \"precondition\");\n-\n-    try_scavenge(p, [&] (oop new_obj) {\n-      \/\/ If p points to a younger generation, mark the card.\n-      if (is_in_young_gen(new_obj)) {\n-        _rs->inline_write_ref_field_gc(p);\n-      }\n-    });\n-  }\n-public:\n-  OldGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g),\n-    _rs(SerialHeap::heap()->rem_set()) {}\n-\n-  void do_oop(oop* p)       { do_oop_work(p); }\n-  void do_oop(narrowOop* p) { do_oop_work(p); }\n-};\n-\n@@ -788,1 +703,11 @@\n-    CLDScanClosure cld_scan_closure{this};\n+    CLDScanClosure cld_cl{this};\n+\n+    MarkingCodeBlobClosure code_cl(&root_cl,\n+                                   CodeBlobToOopClosure::FixRelocations,\n+                                   false \/* keepalive_nmethods *\/);\n+\n+    heap->process_roots(SerialHeap::SO_ScavengeCodeCache,\n+                        &root_cl,\n+                        &cld_cl,\n+                        &cld_cl,\n+                        &code_cl);\n@@ -790,3 +715,1 @@\n-    heap->young_process_roots(&root_cl,\n-                              &old_gen_cl,\n-                              &cld_scan_closure);\n+    _old_gen->scan_old_to_young_refs();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":12,"deletions":89,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -149,11 +149,0 @@\n-void SerialHeap::young_process_roots(OopClosure* root_closure,\n-                                     OopIterateClosure* old_gen_closure,\n-                                     CLDClosure* cld_closure) {\n-  MarkingCodeBlobClosure mark_code_closure(root_closure, CodeBlobToOopClosure::FixRelocations, false \/* keepalive nmethods *\/);\n-\n-  process_roots(SO_ScavengeCodeCache, root_closure,\n-                cld_closure, cld_closure, &mark_code_closure);\n-\n-  old_gen()->younger_refs_iterate(old_gen_closure);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -375,4 +375,0 @@\n-  void young_process_roots(OopClosure* root_closure,\n-                           OopIterateClosure* old_gen_closure,\n-                           CLDClosure* cld_closure);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,85 @@\n+class ScavengeHelper {\n+  DefNewGeneration* _young_gen;\n+  HeapWord*         _young_gen_end;\n+public:\n+  ScavengeHelper(DefNewGeneration* young_gen) :\n+    _young_gen(young_gen),\n+    _young_gen_end(young_gen->reserved().end()) {}\n+\n+  bool is_in_young_gen(void* p) const {\n+    return p < _young_gen_end;\n+  }\n+\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    T heap_oop = RawAccess<>::oop_load(p);\n+    \/\/ Should we copy the obj?\n+    if (!CompressedOops::is_null(heap_oop)) {\n+      oop obj = CompressedOops::decode_not_null(heap_oop);\n+      if (is_in_young_gen(obj)) {\n+        assert(!_young_gen->to()->is_in_reserved(obj), \"Scanning field twice?\");\n+        oop new_obj = obj->is_forwarded() ? obj->forwardee()\n+                                          : _young_gen->copy_to_survivor_space(obj);\n+        RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+\n+        \/\/ callback\n+        f(new_obj);\n+      }\n+    }\n+  }\n+};\n+\n+class InHeapScanClosure : public BasicOopIterateClosure {\n+  ScavengeHelper _helper;\n+protected:\n+  bool is_in_young_gen(void* p) const {\n+    return _helper.is_in_young_gen(p);\n+  }\n+\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    _helper.try_scavenge(p, f);\n+  }\n+\n+  InHeapScanClosure(DefNewGeneration* young_gen) :\n+    BasicOopIterateClosure(young_gen->ref_processor()),\n+    _helper(young_gen) {}\n+};\n+\n+class OffHeapScanClosure : public OopClosure {\n+  ScavengeHelper _helper;\n+protected:\n+  bool is_in_young_gen(void* p) const {\n+    return _helper.is_in_young_gen(p);\n+  }\n+\n+  template <typename T, typename Func>\n+  void try_scavenge(T* p, Func&& f) {\n+    _helper.try_scavenge(p, f);\n+  }\n+\n+  OffHeapScanClosure(DefNewGeneration* young_gen) :  _helper(young_gen) {}\n+};\n+\n+class OldGenScanClosure : public InHeapScanClosure {\n+  CardTableRS* _rs;\n+\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    assert(!is_in_young_gen(p), \"precondition\");\n+\n+    try_scavenge(p, [&] (oop new_obj) {\n+      \/\/ If p points to a younger generation, mark the card.\n+      if (is_in_young_gen(new_obj)) {\n+        _rs->inline_write_ref_field_gc(p);\n+      }\n+    });\n+  }\n+public:\n+  OldGenScanClosure(DefNewGeneration* g) : InHeapScanClosure(g),\n+                                           _rs(SerialHeap::heap()->rem_set()) {}\n+\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.inline.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -270,8 +270,2 @@\n-void TenuredGeneration::younger_refs_iterate(OopIterateClosure* blk) {\n-  \/\/ Apply \"cl->do_oop\" to (the address of) (exactly) all the ref fields in\n-  \/\/ \"sp\" that point into the young generation.\n-  \/\/ The iteration is only over objects allocated at the start of the\n-  \/\/ iterations; objects allocated as a result of applying the closure are\n-  \/\/ not included.\n-\n-  _rs->younger_refs_in_space_iterate(space(), blk);\n+void TenuredGeneration::scan_old_to_young_refs() {\n+  _rs->scan_old_to_young_refs(space());\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  void younger_refs_iterate(OopIterateClosure* blk);\n+  void scan_old_to_young_refs();\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}