{"files":[{"patch":"@@ -645,0 +645,32 @@\n+size_t ParallelCompactData::live_words_in_space(const MutableSpace* space,\n+                                                HeapWord** full_region_prefix_end) {\n+  size_t cur_region = addr_to_region_idx(space->bottom());\n+  const size_t end_region = addr_to_region_idx(region_align_up(space->top()));\n+  size_t live_words = 0;\n+  if (full_region_prefix_end == nullptr) {\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      live_words += _region_data[cur_region].data_size();\n+    }\n+  } else {\n+    bool first_set = false;\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      size_t live_words_in_region = _region_data[cur_region].data_size();\n+      if (!first_set && live_words_in_region < RegionSize) {\n+        *full_region_prefix_end = region_to_addr(cur_region);\n+        first_set = true;\n+      }\n+      live_words += live_words_in_region;\n+    }\n+    if (!first_set) {\n+      \/\/ All regions are full of live objs.\n+      assert(is_region_aligned(space->top()), \"inv\");\n+      *full_region_prefix_end = space->top();\n+    }\n+    assert(*full_region_prefix_end != nullptr, \"postcondition\");\n+    assert(is_region_aligned(*full_region_prefix_end), \"inv\");\n+    assert(*full_region_prefix_end >= space->bottom(), \"in-range\");\n+    assert(*full_region_prefix_end <= space->top(), \"in-range\");\n+  }\n+  return live_words;\n+}\n+\n@@ -985,44 +1017,2 @@\n-ParallelCompactData::RegionData*\n-PSParallelCompact::first_dead_space_region(const RegionData* beg,\n-                                           const RegionData* end)\n-{\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  ParallelCompactData& sd = summary_data();\n-  size_t left = sd.region(beg);\n-  size_t right = end > beg ? sd.region(end) - 1 : left;\n-\n-  \/\/ Binary search.\n-  while (left < right) {\n-    \/\/ Equivalent to (left + right) \/ 2, but does not overflow.\n-    const size_t middle = left + (right - left) \/ 2;\n-    RegionData* const middle_ptr = sd.region(middle);\n-    HeapWord* const dest = middle_ptr->destination();\n-    HeapWord* const addr = sd.region_to_addr(middle);\n-    assert(dest != nullptr, \"sanity\");\n-    assert(dest <= addr, \"must move left\");\n-\n-    if (middle > left && dest < addr) {\n-      right = middle - 1;\n-    } else if (middle < right && middle_ptr->data_size() == region_size) {\n-      left = middle + 1;\n-    } else {\n-      return middle_ptr;\n-    }\n-  }\n-  return sd.region(left);\n-}\n-\n-\/\/ Return the address of the end of the dense prefix, a.k.a. the start of the\n-\/\/ compacted region.  The address is always on a region boundary.\n-\/\/\n-\/\/ Completely full regions at the left are skipped, since no compaction can\n-\/\/ occur in those regions.  Then the maximum amount of dead wood to allow is\n-\/\/ computed, based on the density (amount live \/ capacity) of the generation;\n-\/\/ the region with approximately that amount of dead space to the left is\n-\/\/ identified as the limit region.  Regions between the last completely full\n-\/\/ region and the limit region are scanned and the one that has the best\n-\/\/ (maximum) reclaimed_ratio() is selected.\n-HeapWord*\n-PSParallelCompact::compute_dense_prefix(const SpaceId id,\n-                                        bool maximum_compaction)\n-{\n+HeapWord* PSParallelCompact::compute_dense_prefix_for_old_space(MutableSpace* old_space,\n+                                                                HeapWord* full_region_prefix_end) {\n@@ -1032,32 +1022,0 @@\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const top = space->top();\n-  HeapWord* const top_aligned_up = sd.region_align_up(top);\n-  HeapWord* const new_top = _space_info[id].new_top();\n-  HeapWord* const new_top_aligned_up = sd.region_align_up(new_top);\n-  HeapWord* const bottom = space->bottom();\n-  const RegionData* const beg_cp = sd.addr_to_region_ptr(bottom);\n-  const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-  const RegionData* const new_top_cp =\n-    sd.addr_to_region_ptr(new_top_aligned_up);\n-\n-  \/\/ Skip full regions at the beginning of the space--they are necessarily part\n-  \/\/ of the dense prefix.\n-  const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);\n-  assert(full_cp->destination() == sd.region_to_addr(full_cp) ||\n-         space->is_empty(), \"no dead space allowed to the left\");\n-  assert(full_cp->data_size() < region_size || full_cp == new_top_cp - 1,\n-         \"region must have dead space\");\n-\n-  \/\/ The gc number is saved whenever a maximum compaction is done, and used to\n-  \/\/ determine when the maximum compaction interval has expired.  This avoids\n-  \/\/ successive max compactions for different reasons.\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n-  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n-  const bool interval_ended = gcs_since_max > HeapMaximumCompactionInterval ||\n-    total_invocations == HeapFirstMaximumCompactionCount;\n-  if (maximum_compaction || full_cp == top_cp || interval_ended) {\n-    _maximum_compaction_gc_num = total_invocations;\n-    return sd.region_to_addr(full_cp);\n-  }\n-\n@@ -1065,1 +1023,1 @@\n-  const RegionData* const start_region = full_cp;\n+  const RegionData* const start_region = sd.addr_to_region_ptr(full_region_prefix_end);\n@@ -1068,1 +1026,1 @@\n-  const RegionData* const end_region = sd.addr_to_region_ptr(space->top());\n+  const RegionData* const end_region = sd.addr_to_region_ptr(old_space->top());\n@@ -1071,1 +1029,1 @@\n-  size_t max_waste = space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n+  size_t max_waste = old_space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n@@ -1084,2 +1042,2 @@\n-  assert(prefix_end >= sd.region_to_addr(full_cp), \"in-range\");\n-  assert(prefix_end <= space->top(), \"in-range\");\n+  assert(prefix_end >= full_region_prefix_end, \"in-range\");\n+  assert(prefix_end <= old_space->top(), \"in-range\");\n@@ -1089,13 +1047,0 @@\n-void PSParallelCompact::summarize_spaces_quick()\n-{\n-  for (unsigned int i = 0; i < last_space_id; ++i) {\n-    const MutableSpace* space = _space_info[i].space();\n-    HeapWord** nta = _space_info[i].new_top_addr();\n-    bool result = _summary_data.summarize(_space_info[i].split_info(),\n-                                          space->bottom(), space->top(), nullptr,\n-                                          space->bottom(), space->end(), nta);\n-    assert(result, \"space must fit into itself\");\n-    _space_info[i].set_dense_prefix(space->bottom());\n-  }\n-}\n-\n@@ -1126,0 +1071,6 @@\n+  assert(_summary_data.is_region_aligned(dense_prefix_end), \"precondition\");\n+  assert(dense_prefix_end <= space(id)->top(), \"precondition\");\n+  if (dense_prefix_end == space(id)->top()) {\n+    \/\/ Must not have single-word gap right before prefix-end\/top.\n+    return;\n+  }\n@@ -1150,50 +1101,0 @@\n-void\n-PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)\n-{\n-  assert(id < last_space_id, \"id out of range\");\n-  assert(_space_info[id].dense_prefix() == _space_info[id].space()->bottom(),\n-         \"should have been reset in summarize_spaces_quick()\");\n-\n-  const MutableSpace* space = _space_info[id].space();\n-  if (_space_info[id].new_top() != space->bottom()) {\n-    HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);\n-    _space_info[id].set_dense_prefix(dense_prefix_end);\n-\n-    \/\/ Recompute the summary data, taking into account the dense prefix.  If\n-    \/\/ every last byte will be reclaimed, then the existing summary data which\n-    \/\/ compacts everything can be left in place.\n-    if (!maximum_compaction && dense_prefix_end != space->bottom()) {\n-      \/\/ If dead space crosses the dense prefix boundary, it is (at least\n-      \/\/ partially) filled with a dummy object, marked live and added to the\n-      \/\/ summary data.  This simplifies the copy\/update phase and must be done\n-      \/\/ before the final locations of objects are determined, to prevent\n-      \/\/ leaving a fragment of dead space that is too small to fill.\n-      fill_dense_prefix_end(id);\n-\n-      \/\/ Compute the destination of each Region, and thus each object.\n-      _summary_data.summarize_dense_prefix(space->bottom(), dense_prefix_end);\n-      _summary_data.summarize(_space_info[id].split_info(),\n-                              dense_prefix_end, space->top(), nullptr,\n-                              dense_prefix_end, space->end(),\n-                              _space_info[id].new_top_addr());\n-    }\n-  }\n-\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const size_t region_size = ParallelCompactData::RegionSize;\n-    HeapWord* const dense_prefix_end = _space_info[id].dense_prefix();\n-    const size_t dp_region = _summary_data.addr_to_region_idx(dense_prefix_end);\n-    const size_t dp_words = pointer_delta(dense_prefix_end, space->bottom());\n-    HeapWord* const new_top = _space_info[id].new_top();\n-    const HeapWord* nt_aligned_up = _summary_data.region_align_up(new_top);\n-    const size_t cr_words = pointer_delta(nt_aligned_up, dense_prefix_end);\n-    log_develop_trace(gc, compaction)(\n-        \"id=%d cap=\" SIZE_FORMAT \" dp=\" PTR_FORMAT \" \"\n-        \"dp_region=\" SIZE_FORMAT \" \" \"dp_count=\" SIZE_FORMAT \" \"\n-        \"cr_count=\" SIZE_FORMAT \" \" \"nt=\" PTR_FORMAT,\n-        id, space->capacity_in_words(), p2i(dense_prefix_end),\n-        dp_region, dp_words \/ region_size,\n-        cr_words \/ region_size, p2i(new_top));\n-  }\n-}\n-\n@@ -1223,3 +1124,6 @@\n-void PSParallelCompact::summary_phase(bool maximum_compaction)\n-{\n-  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+bool PSParallelCompact::reassess_maximum_compaction(bool maximum_compaction,\n+                                                    size_t total_live_words,\n+                                                    MutableSpace* const old_space,\n+                                                    HeapWord* full_region_prefix_end) {\n+  \/\/ Check if all live objs are larger than old-gen.\n+  const bool is_old_gen_overflowing = (total_live_words > old_space->capacity_in_words());\n@@ -1227,2 +1131,6 @@\n-  \/\/ Quick summarization of each space into itself, to see how much is live.\n-  summarize_spaces_quick();\n+  \/\/ JVM flags\n+  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n+  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval\n+                              || total_invocations == HeapFirstMaximumCompactionCount;\n@@ -1230,3 +1138,3 @@\n-  log_develop_trace(gc, compaction)(\"summary phase:  after summarizing each space to self\");\n-  NOT_PRODUCT(print_region_ranges());\n-  NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));\n+  \/\/ If all regions in old-gen are full\n+  const bool is_region_full =\n+    full_region_prefix_end >= _summary_data.region_align_down(old_space->top());\n@@ -1234,5 +1142,3 @@\n-  \/\/ The amount of live data that will end up in old space (assuming it fits).\n-  size_t old_space_total_live = 0;\n-  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-    old_space_total_live += pointer_delta(_space_info[id].new_top(),\n-                                          _space_info[id].space()->bottom());\n+  if (maximum_compaction || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+    _maximum_compaction_gc_num = total_invocations;\n+    return true;\n@@ -1241,0 +1147,7 @@\n+  return false;\n+}\n+\n+void PSParallelCompact::summary_phase(bool maximum_compaction)\n+{\n+  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+\n@@ -1242,5 +1155,28 @@\n-  const size_t old_capacity = old_space->capacity_in_words();\n-  if (old_space_total_live > old_capacity) {\n-    \/\/ XXX - should also try to expand\n-    maximum_compaction = true;\n-  }\n+  {\n+    size_t total_live_words = 0;\n+    HeapWord* full_region_prefix_end = nullptr;\n+    {\n+      \/\/ old-gen\n+      size_t live_words = _summary_data.live_words_in_space(old_space,\n+                                                            &full_region_prefix_end);\n+      total_live_words += live_words;\n+    }\n+    \/\/ young-gen\n+    for (uint i = eden_space_id; i < last_space_id; ++i) {\n+      const MutableSpace* space = _space_info[i].space();\n+      size_t live_words = _summary_data.live_words_in_space(space);\n+      total_live_words += live_words;\n+      _space_info[i].set_new_top(space->bottom() + live_words);\n+      _space_info[i].set_dense_prefix(space->bottom());\n+    }\n+\n+    maximum_compaction = reassess_maximum_compaction(maximum_compaction,\n+                                                     total_live_words,\n+                                                     old_space,\n+                                                     full_region_prefix_end);\n+    HeapWord* dense_prefix_end =\n+      maximum_compaction ? full_region_prefix_end\n+                         : compute_dense_prefix_for_old_space(old_space,\n+                                                              full_region_prefix_end);\n+    SpaceId id = old_space_id;\n+    _space_info[id].set_dense_prefix(dense_prefix_end);\n@@ -1248,2 +1184,9 @@\n-  \/\/ Old generations.\n-  summarize_space(old_space_id, maximum_compaction);\n+    if (dense_prefix_end != old_space->bottom()) {\n+      fill_dense_prefix_end(id);\n+      _summary_data.summarize_dense_prefix(old_space->bottom(), dense_prefix_end);\n+    }\n+    _summary_data.summarize(_space_info[id].split_info(),\n+                            dense_prefix_end, old_space->top(), nullptr,\n+                            dense_prefix_end, old_space->end(),\n+                            _space_info[id].new_top_addr());\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":107,"deletions":164,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -409,0 +409,4 @@\n+\n+  size_t live_words_in_space(const MutableSpace* space,\n+                             HeapWord** full_region_prefix_end = nullptr);\n+\n@@ -938,0 +942,5 @@\n+  static bool reassess_maximum_compaction(bool maximum_compaction,\n+                                          size_t total_live_words,\n+                                          MutableSpace* const old_space,\n+                                          HeapWord* full_region_prefix_end);\n+\n@@ -941,10 +950,3 @@\n-  \/\/ Methods used to compute the dense prefix.\n-\n-  \/\/ Return a pointer to the first region in the range [beg, end) that is not\n-  \/\/ completely full.\n-  static RegionData* first_dead_space_region(const RegionData* beg,\n-                                             const RegionData* end);\n-\n-  \/\/ Compute the dense prefix for the designated space.\n-  static HeapWord* compute_dense_prefix(const SpaceId id,\n-                                        bool maximum_compaction);\n+  \/\/ Identify the dense-fix in the old-space to avoid moving much memory with little reclaimed.\n+  static HeapWord* compute_dense_prefix_for_old_space(MutableSpace* old_space,\n+                                                      HeapWord* full_region_prefix_end);\n@@ -956,2 +958,0 @@\n-  static void summarize_spaces_quick();\n-  static void summarize_space(SpaceId id, bool maximum_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}