{"files":[{"patch":"@@ -33,3 +33,3 @@\n- * VM, unlike the other methods.  The HotSpot VM checks, when loading a class,\n- * the consistency of recognized methods and {@code @IntrinsicCandidate}\n- * annotations, unless the {@code CheckIntrinsics} VM flag is disabled.\n+ * VM.  When a class is loading, the HotSpot VM checks the consistency of\n+ * recognized methods and {@code @IntrinsicCandidate} annotations, unless the\n+ * {@code CheckIntrinsics} VM flag is disabled.\n@@ -38,8 +38,8 @@\n- * The most frequently special treatment is intrinsification, which replaces a\n- * candidate method's body, bytecode or native, with handwritten platform\n- * assembly and\/or compiler IR.  (See {@code LibraryCallKit::try_to_inline} in\n- * {@code library_call.cpp} for logic that checks if an intrinsic is available\n- * and applicable at a given call site.)  Many Java library methods have\n- * properties that cannot be deduced by the compiler for optimization, or can\n- * utilize specific hardware instructions not modeled by the compiler IR, making\n- * intrinsics necessary.\n+ * Most frequently, the special treatment of an intrinsic is\n+ * <em>intrinsification<\/em>, which replaces a candidate method's body, bytecode\n+ * or native, with handwritten platform assembly and\/or compiler IR.  (See\n+ * {@code LibraryCallKit::try_to_inline} in {@code library_call.cpp} for logic\n+ * that checks if an intrinsic is available and applicable at a given call site.)\n+ * Many Java library methods have properties that cannot be deduced by the\n+ * compiler for optimization, or can utilize specific hardware instructions not\n+ * modeled by the compiler IR, making intrinsics necessary.\n@@ -47,2 +47,3 @@\n- * Intrinsification may never happen, or happen at any moment during execution.\n- * For example, the bytecodes of a candidate method may be executed by lower\n+ * During execution, intrinsification may happen and may be rolled back at any\n+ * moment; this loading and unloading process may happen zero to many times.\n+ * For example, the bytecode of a candidate method may be executed by lower\n@@ -50,1 +51,1 @@\n- * the bytecodes with specialized assembly code and\/or compiler IR.  Therefore,\n+ * the bytecode with specialized assembly code and\/or compiler IR.  Therefore,\n@@ -53,1 +54,1 @@\n- * (given the assumptions on the arguments hold).\n+ * (given that the assumptions on the arguments hold).\n@@ -57,2 +58,2 @@\n- * case) <strong>unsafe<\/strong> - they do not perform checks, but have\n- * assumptions on their arguments that can ensure type safety.  These\n+ * case) <strong>unsafe<\/strong> - it may not perform checks, but instead makes\n+ * assumptions on its arguments that type safety is ensured by callers.  These\n@@ -67,1 +68,1 @@\n- * and manipulating managed references in a way that prevents the GC from\n+ * and manipulating object references in a way that prevents the GC from\n@@ -91,0 +92,10 @@\n+ * <p>\n+ * Reasoning about such race conditions is difficult, but it is a necessary\n+ * skill when working with intrinsics that can observe racing shared variables.\n+ * One example of a tolerable race is a repeated read of a shared reference.\n+ * This only works if the algorithm takes no action based on the first read,\n+ * other than deciding to perform the second read; it must \"forget what it saw\"\n+ * in the first read.  This is why the array-mismatch intrinsics can sometimes\n+ * report a tentative search hit (maybe using vectorized code), which can then\n+ * be confirmed (by scalar code) as the caller makes a fresh and independent\n+ * observation.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"}]}