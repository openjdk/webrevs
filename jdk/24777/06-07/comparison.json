{"files":[{"patch":"@@ -30,76 +30,13 @@\n-\/**\n- * The {@code @IntrinsicCandidate} indicates that an annotated method is\n- * recognized by {@code vmIntrinsics.hpp} for special treatment by the HotSpot\n- * VM.  When a class is loading, the HotSpot VM checks the consistency of\n- * recognized methods and {@code @IntrinsicCandidate} annotations, unless the\n- * {@code CheckIntrinsics} VM flag is disabled.\n- *\n- * <h2 id=\"intrinsification\">Intrinsification<\/h2>\n- * Most frequently, the special treatment of an intrinsic is\n- * <em>intrinsification<\/em>, which replaces a candidate method's body, bytecode\n- * or native, with handwritten platform assembly and\/or compiler IR.  (See\n- * {@code LibraryCallKit::try_to_inline} in {@code library_call.cpp} for logic\n- * that checks if an intrinsic is available and applicable at a given call site.)\n- * Many Java library methods have properties that cannot be deduced by the\n- * compiler for optimization, or can utilize specific hardware instructions not\n- * modeled by the compiler IR, making intrinsics necessary.\n- * <p>\n- * During execution, intrinsification may happen and may be rolled back at any\n- * moment; this loading and unloading process may happen zero to many times.\n- * For example, the bytecode of a candidate method may be executed by lower\n- * compilation tiers of VM execution, while higher compilation tiers may replace\n- * the bytecode with specialized assembly code and\/or compiler IR.  Therefore,\n- * intrinsic implementors must ensure that non-bytecode execution has the same\n- * results as execution of the actual Java code in all application contexts\n- * (given that the assumptions on the arguments hold).\n- * <p>\n- * A candidate method should contain a minimal piece of Java code that should be\n- * replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\n- * case) <strong>unsafe<\/strong> - it may not perform checks, but instead makes\n- * assumptions on its arguments that type safety is ensured by callers.  These\n- * assumptions must be clearly documented on the candidate methods, and the\n- * callers are fully responsible for preventing any kind of type safety\n- * violation.  As long as these assumptions hold, readers can simply refer to\n- * the candidate method's Java code body for program behaviors.\n- * <blockquote style=\"font-size:smaller;\"><p id=\"unsafe-details\">\n- * Examples of type safety violations include: dereferencing a null pointer;\n- * accessing a field or method on an object which does not possess that field or\n- * method; accessing an element of an array not actually present in the array;\n- * and manipulating object references in a way that prevents the GC from\n- * managing them.\n- * <\/blockquote>\n- * <p id=\"validation\">\n- * To ensure type safety, candidate methods are typically private, and access to\n- * them are encapsulated by more accessible methods that perform argument\n- * validations.  Any validation must be done on values that are exclusively\n- * accessed by the current thread: shared fields must be read into local\n- * variables, and shared arrays must be copied to an exclusive copy, to ensure\n- * each shared location (a field or an array component) is accessed at most once.\n- * If a shared location is read multiple times for check and for use, race\n- * conditions may cause two reads to produce distinct values, known as TOCTOU\n- * (time of check and time of use), and the read for use may produce an illegal\n- * value.  Finally, the thread-exclusive validated values are passed to the\n- * candidate method.\n- * <blockquote style=\"font-size:smaller;\"><p id=\"racy-array\">\n- * For some highly optimized algorithms, it may be impractical to ensure that\n- * array data is read or written only once by the intrinsic.  If the caller of\n- * the intrinsic cannot guarantee that such array data is unshared, then the\n- * caller must also document the effects of any race condition.  (Such a race\n- * occurs when another thread writes the array data during the execution of the\n- * intrinsic.)  For example, the documentation can simply say that the result is\n- * undefined if a race happens.  However, race conditions must not lead to\n- * program failures or type safety breaches, as listed above.\n- * <p>\n- * Reasoning about such race conditions is difficult, but it is a necessary\n- * skill when working with intrinsics that can observe racing shared variables.\n- * One example of a tolerable race is a repeated read of a shared reference.\n- * This only works if the algorithm takes no action based on the first read,\n- * other than deciding to perform the second read; it must \"forget what it saw\"\n- * in the first read.  This is why the array-mismatch intrinsics can sometimes\n- * report a tentative search hit (maybe using vectorized code), which can then\n- * be confirmed (by scalar code) as the caller makes a fresh and independent\n- * observation.\n- * <\/blockquote>\n- *\n- * @since 16\n- *\/\n+\/\/\/ The `@IntrinsicCandidate` indicates that an annotated method is\n+\/\/\/ recognized by `vmIntrinsics.hpp` for special treatment by the HotSpot\n+\/\/\/ VM.  When a class is loading, the HotSpot VM checks the consistency of\n+\/\/\/ recognized methods and `@IntrinsicCandidate` annotations, unless the\n+\/\/\/ `CheckIntrinsics` VM flag is disabled.\n+\/\/\/\n+\/\/\/ Most frequently, the special treatment of an intrinsic is *intrinsification*,\n+\/\/\/ which replaces a candidate method's body, bytecode or native, with\n+\/\/\/ handwritten platform assembly and\/or compiler IR.  See\n+\/\/\/ <a href=\"..\/intrinsics.md\">intrinsics design document<\/a> for\n+\/\/\/ what intrinsics are and cautions for working with annotated methods.\n+\/\/\/\n+\/\/\/ @since 16\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":13,"deletions":76,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+<!--\r\n+\r\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\r\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+\r\n+This code is free software; you can redistribute it and\/or modify it\r\n+under the terms of the GNU General Public License version 2 only, as\r\n+published by the Free Software Foundation.  Oracle designates this\r\n+particular file as subject to the \"Classpath\" exception as provided\r\n+by Oracle in the LICENSE file that accompanied this code.\r\n+\r\n+This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+version 2 for more details (a copy is included in the LICENSE file that\r\n+accompanied this code).\r\n+\r\n+You should have received a copy of the GNU General Public License version\r\n+2 along with this work; if not, write to the Free Software Foundation,\r\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+\r\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+or visit www.oracle.com if you need additional information or have any\r\n+questions.\r\n+\r\n+-->\r\n+\r\n+# Intrinsification\r\n+Intrinsification replaces a candidate method's body, bytecode or native, with\r\n+handwritten platform assembly and\/or compiler IR.  (In `library_call.cpp`,\r\n+`LibraryCallKit::try_to_inline` checks if an intrinsic is available and\r\n+applicable at a given call site.)  Many Java library methods have properties\r\n+that cannot be deduced by the compiler for optimization, or can utilize specific\r\n+hardware instructions not modeled by the compiler IR, making intrinsics necessary.\r\n+\r\n+During execution, intrinsification may happen and may be rolled back at any\r\n+moment; this loading and unloading process may happen zero to many times.\r\n+For example, the bytecode of a candidate method may be executed by lower\r\n+compilation tiers of VM execution, while higher compilation tiers may replace\r\n+the bytecode with specialized assembly code and\/or compiler IR.  Therefore,\r\n+intrinsic implementors must ensure that non-bytecode execution has the same\r\n+results as execution of the actual Java code in all application contexts\r\n+(given that the assumptions on the arguments hold).\r\n+\r\n+A candidate method should contain a minimal piece of Java code that should be\r\n+replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\r\n+case) **unsafe** - it may not perform checks, but instead makes\r\n+assumptions on its arguments that type safety is ensured by callers.  These\r\n+assumptions must be clearly documented on the candidate methods, and the\r\n+callers are fully responsible for preventing any kind of type safety\r\n+violation.  As long as these assumptions hold, readers can simply refer to\r\n+the candidate method's Java code body for program behaviors.\r\n+\r\n+<a id=\"unsafe-details\" \/>\r\n+\r\n+> Examples of type safety violations include: dereferencing a null pointer;\r\n+> accessing a field or method on an object which does not possess that field or\r\n+> method; accessing an element of an array not actually present in the array;\r\n+> and manipulating object references in a way that prevents the GC from\r\n+> managing them.\r\n+\r\n+### Validation\r\n+To ensure type safety, candidate methods are typically private, and access to\r\n+them are encapsulated by more accessible methods that perform argument\r\n+validations.  Any validation must be done on values that are exclusively\r\n+accessed by the current thread: shared fields must be read into local\r\n+variables, and shared arrays must be copied to an exclusive copy, to ensure\r\n+each shared location (a field or an array component) is accessed at most once.\r\n+If a shared location is read multiple times for check and for use, race\r\n+conditions may cause two reads to produce distinct values, known as TOCTOU\r\n+(time of check and time of use), and the read for use may produce an illegal\r\n+value.  Finally, the thread-exclusive validated values are passed to the\r\n+candidate method.\r\n+\r\n+<a id=\"racy-array\" \/>\r\n+\r\n+> For some highly optimized algorithms, it may be impractical to ensure that\r\n+> array data is read or written only once by the intrinsic.  If the caller of\r\n+> the intrinsic cannot guarantee that such array data is unshared, then the\r\n+> caller must also document the effects of any race condition.  (Such a race\r\n+> occurs when another thread writes the array data during the execution of the\r\n+> intrinsic.)  For example, the documentation can simply say that the result is\r\n+> undefined if a race happens.  However, race conditions must not lead to\r\n+> program failures or type safety breaches, as listed above.\r\n+>\r\n+> Reasoning about such race conditions is difficult, but it is a necessary\r\n+> skill when working with intrinsics that can observe racing shared variables.\r\n+> One example of a tolerable race is a repeated read of a shared reference.\r\n+> This only works if the algorithm takes no action based on the first read,\r\n+> other than deciding to perform the second read; it must \"forget what it saw\"\r\n+> in the first read.  This is why the array-mismatch intrinsics can sometimes\r\n+> report a tentative search hit (maybe using vectorized code), which can then\r\n+> be confirmed (by scalar code) as the caller makes a fresh and independent\r\n+> observation.\r\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/intrinsics.md","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}