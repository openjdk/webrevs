{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,88 +31,58 @@\n- * The {@code @IntrinsicCandidate} annotation is specific to the\n- * HotSpot Virtual Machine. It indicates that an annotated method\n- * may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method\n- * is intrinsified if the HotSpot VM replaces the annotated method with hand-written\n- * assembly and\/or hand-written compiler IR -- a compiler intrinsic -- to improve\n- * performance. The {@code @IntrinsicCandidate} annotation is internal to the\n- * Java libraries and is therefore not supposed to have any relevance for application\n- * code.\n- *\n- * Maintainers of the Java libraries must consider the following when\n- * modifying methods annotated with {@code @IntrinsicCandidate}.\n- *\n- * <ul>\n- * <li>When modifying a method annotated with {@code @IntrinsicCandidate},\n- * the corresponding intrinsic code in the HotSpot VM implementation must be\n- * updated to match the semantics of the annotated method.<\/li>\n- * <li>For some annotated methods, the corresponding intrinsic may omit some low-level\n- * checks that would be performed as a matter of course if the intrinsic is implemented\n- * using Java bytecodes. This is because individual Java bytecodes implicitly check\n- * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}.\n- * If such a method is replaced by an intrinsic coded in assembly language, any\n- * checks performed as a matter of normal bytecode operation must be performed\n- * before entry into the assembly code. These checks must be performed, as\n- * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained\n- * by the intrinsic through those arguments. The checks may be deduced by inspecting\n- * the non-intrinsic Java code for the method, and determining exactly which exceptions\n- * may be thrown by the code, including undeclared implicit {@code RuntimeException}s.\n- * Therefore, depending on the data accesses performed by the intrinsic,\n- * the checks may include:\n- *\n- *  <ul>\n- *  <li>null checks on references<\/li>\n- *  <li>range checks on primitive values used as array indexes<\/li>\n- *  <li>other validity checks on primitive values (e.g., for divide-by-zero conditions)<\/li>\n- *  <li>store checks on reference values stored into arrays<\/li>\n- *  <li>array length checks on arrays indexed from within the intrinsic<\/li>\n- *  <li>reference casts (when formal parameters are {@code Object} or some other weak type)<\/li>\n- *  <\/ul>\n- *\n- * <\/li>\n- *\n- * <li>Note that the receiver value ({@code this}) is passed as a extra argument\n- * to all non-static methods. If a non-static method is an intrinsic, the receiver\n- * value does not need a null check, but (as stated above) any values loaded by the\n- * intrinsic from object fields must also be checked. As a matter of clarity, it is\n- * better to make intrinisics be static methods, to make the dependency on {@code this}\n- * clear. Also, it is better to explicitly load all required values from object\n- * fields before entering the intrinsic code, and pass those values as explicit arguments.\n- * First, this may be necessary for null checks (or other checks). Second, if the\n- * intrinsic reloads the values from fields and operates on those without checks,\n- * race conditions may be able to introduce unchecked invalid values into the intrinsic.\n- * If the intrinsic needs to store a value back to an object field, that value should be\n- * returned explicitly from the intrinsic; if there are multiple return values, coders\n- * should consider buffering them in an array. Removing field access from intrinsics\n- * not only clarifies the interface with between the JVM and JDK; it also helps decouple\n- * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic\n- * manages all field accesses, then intrinsics can be coded to be agnostic of object\n- * layouts.<\/li>\n- *\n- * Maintainers of the HotSpot VM must consider the following when modifying\n- * intrinsics.\n- *\n- * <ul>\n- * <li>When adding a new intrinsic, make sure that the corresponding method\n- * in the Java libraries is annotated with {@code @IntrinsicCandidate}\n- * and that all possible call sequences that result in calling the intrinsic contain\n- * the checks omitted by the intrinsic (if any).<\/li>\n- * <li>When modifying an existing intrinsic, the Java libraries must be updated\n- * to match the semantics of the intrinsic and to execute all checks omitted\n- * by the intrinsic (if any).<\/li>\n- * <\/ul>\n- *\n- * Persons not directly involved with maintaining the Java libraries or the\n- * HotSpot VM can safely ignore the fact that a method is annotated with\n- * {@code @IntrinsicCandidate}.\n- *\n- * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic\n- * are available on all platforms supported by the HotSpot VM. Furthermore,\n- * the availability of an intrinsic on a given platform depends on the\n- * configuration of the HotSpot VM (e.g., the set of VM flags enabled).\n- * Therefore, annotating a method with {@code @IntrinsicCandidate} does\n- * not guarantee that the marked method is intrinsified by the HotSpot VM.\n- *\n- * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks\n- * (when loading a class) that (1) all methods of that class that are also on\n- * the VM's list of intrinsics are annotated with {@code @IntrinsicCandidate}\n- * and that (2) for all methods of that class annotated with\n- * {@code @IntrinsicCandidate} there is an intrinsic in the list.\n+ * The {@code @IntrinsicCandidate} indicates that an annotated method is\n+ * recognized by {@code vmIntrinsics.hpp} and may be subject to intrinsification\n+ * by the HotSpot VM (see {@code LibraryCallKit::try_to_inline} in {@code\n+ * library_call.cpp}) if an intrinsic is available.  Intrinsification replaces a\n+ * candidate method's body, bytecode or native, with handwritten platform\n+ * assembly and\/or compiler IR.  Many Java library methods have properties that\n+ * cannot be deduced by the compiler for optimization, or can utilize specific\n+ * hardware instructions not modeled by the compiler IR, making intrinsics\n+ * necessary.\n+ * <p>\n+ * Intrinsification may never happen, or happen at any moment during execution.\n+ * For example, the bytecodes of a candidate method may be executed by lower\n+ * compilation tiers of VM execution, while higher compilation tiers may replace\n+ * the bytecodes with specialized assembly code and\/or compiler IR.  Therefore,\n+ * intrinsic implementors must ensure that non-bytecode execution has the same\n+ * results as execution of the actual Java code in all application contexts\n+ * (given the assumptions on the arguments hold).\n+ * <p>\n+ * A candidate method should contain a minimal piece of Java code that should be\n+ * replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\n+ * case) <strong>unsafe<\/strong> - they do not perform checks, but have\n+ * assumptions on their arguments that can ensure type safety.  These\n+ * assumptions must be clearly documented on the candidate methods, and the\n+ * callers are fully responsible for preventing any kind of type safety\n+ * violation.  As long as these assumptions hold, readers can simply refer to\n+ * the candidate method's Java code body for program behaviors.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"unsafe-details\">\n+ * Examples of type safety violations include: dereferencing a null pointer;\n+ * accessing a field or method on an object which does not possess that field or\n+ * method; accessing an element of an array not actually present in the array;\n+ * and manipulating managed references in a way that prevents the GC from\n+ * managing them.\n+ * <\/blockquote>\n+ * <p id=\"validation\">\n+ * To ensure type safety, candidate methods are typically private, and access to\n+ * them are encapsulated by more accessible methods that perform argument\n+ * validations.  Any validation must be done on values that are exclusively\n+ * accessed by the current thread: shared fields must be read into local\n+ * variables, and shared arrays must be copied to an exclusive copy, to ensure\n+ * each shared location (a field or an array component) is accessed exactly once.\n+ * If a shared location is read multiple times for check and for use, race\n+ * conditions may cause two reads to produce distinct values, known as TOCTOU\n+ * (time of check and time of use), and the read for use may produce an illegal\n+ * value.  Finally, the thread-exclusive validated values are passed to the\n+ * candidate method.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"racy-array\">\n+ * For some highly optimized algorithms, it may be impractical to ensure that\n+ * array data is read or written only once by the intrinsic.  If the caller of\n+ * the intrinsic cannot guarantee that such array data is unshared, then the\n+ * caller must also document the effects of any race condition.  (Such a race\n+ * occurs when another thread writes the array data during the execution of the\n+ * intrinsic.)  For example, the documentation can simply say that the result is\n+ * undefined if a race happens.  However, race conditions must not lead to\n+ * program failures or type safety breaches, as listed above.\n+ * <\/blockquote><p>\n+ * The HotSpot VM checks, when loading a class, the consistency of recognized\n+ * methods and {@code @IntrinsicCandidate} annotations, unless the {@code\n+ * CheckIntrinsics} VM flag is disabled.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":59,"deletions":89,"binary":false,"changes":148,"status":"modified"}]}