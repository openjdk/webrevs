{"files":[{"patch":"@@ -34,3 +34,6 @@\n- * library_call.cpp}) if an intrinsic is available. Intrinsification replaces a\n- * method's body, bytecode or native, with hand-written platform assembly and\/or\n- * compiler IR that may have different but compatible semantics from the original.\n+ * library_call.cpp}) if an intrinsic is available.  Intrinsification replaces a\n+ * candidate method's body, bytecode or native, with handwritten platform\n+ * assembly and\/or compiler IR.  Many Java library methods have properties that\n+ * cannot be deduced by the compiler for optimization, or can utilize specific\n+ * hardware instructions not modeled by the compiler IR, making intrinsics\n+ * necessary.\n@@ -38,17 +41,7 @@\n- * Many Java library functions have properties that cannot be deduced by the\n- * compiler for optimization, or can utilize specific hardware instructions not\n- * modeled by the compiler IR, making intrinsics necessary. However, due to the\n- * error-prone nature of platform assembly and compiler IR, intrinsics should be\n- * kept minimal, like locking sections - whatever can be done in Java code\n- * should be done in Java.\n- * <p>\n- * In best practice, intrinsic methods are usually private, unsafe, and\n- * static, and their encapsulating callers should perform validation checks.\n- * Any validation must be done on values that are exclusively accessed by the\n- * current thread: shared fields must be read into local variables, and shared\n- * arrays must be copied to an exclusive copy, to ensure each shared location\n- * (a field or an array component) is accessed exactly once. If a shared\n- * location is read multiple times for check and for use, race conditions may\n- * cause two reads to produce distinct values, known as TOCTOU (time of check\n- * and time of use), and the read for use may produce an illegal value. Finally,\n- * the thread-exclusive validated values are passed to the intrinsic methods.\n+ * Intrinsification may never happen, or happen at any moment during execution.\n+ * For example, the bytecodes of a candidate method may be executed by lower\n+ * compilation tiers of VM execution, while higher compilation tiers may replace\n+ * the bytecodes with specialized assembly code and\/or compiler IR.  Therefore,\n+ * intrinsic implementors must ensure that non-bytecode execution has the same\n+ * results as execution of the actual Java code in all application contexts\n+ * (given the assumptions on the arguments hold).\n@@ -56,0 +49,37 @@\n+ * A candidate method should contain a minimal piece of Java code that should be\n+ * replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\n+ * case) <strong>unsafe<\/strong> - they do not perform checks, but have\n+ * assumptions on their arguments that can ensure type safety.  These\n+ * assumptions must be clearly documented on the candidate methods, and the\n+ * callers are fully responsible for preventing any kind of type safety\n+ * violation.  As long as these assumptions hold, readers can simply refer to\n+ * the candidate method's Java code body for program behaviors.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"unsafe-details\">\n+ * Examples of type safety violations include: dereferencing a null pointer;\n+ * accessing a field or method on an object which does not possess that field or\n+ * method; accessing an element of an array not actually present in the array;\n+ * and manipulating managed references in a way that prevents the GC from\n+ * managing them.\n+ * <\/blockquote>\n+ * <p id=\"validation\">\n+ * To ensure type safety, candidate methods are typically private, and access to\n+ * them are encapsulated by more accessible methods that perform argument\n+ * validations.  Any validation must be done on values that are exclusively\n+ * accessed by the current thread: shared fields must be read into local\n+ * variables, and shared arrays must be copied to an exclusive copy, to ensure\n+ * each shared location (a field or an array component) is accessed exactly once.\n+ * If a shared location is read multiple times for check and for use, race\n+ * conditions may cause two reads to produce distinct values, known as TOCTOU\n+ * (time of check and time of use), and the read for use may produce an illegal\n+ * value.  Finally, the thread-exclusive validated values are passed to the\n+ * candidate method.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"racy-array\">\n+ * For some highly optimized algorithms, it may be impractical to ensure that\n+ * array data is read or written only once by the intrinsic.  If the caller of\n+ * the intrinsic cannot guarantee that such array data is unshared, then the\n+ * caller must also document the effects of any race condition.  (Such a race\n+ * occurs when another thread writes the array data during the execution of the\n+ * intrinsic.)  For example, the documentation can simply say that the result is\n+ * undefined if a race happens.  However, race conditions must not lead to\n+ * program failures or type safety breaches, as listed above.\n+ * <\/blockquote><p>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":50,"deletions":20,"binary":false,"changes":70,"status":"modified"}]}