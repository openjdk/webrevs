{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,88 +31,28 @@\n- * The {@code @IntrinsicCandidate} annotation is specific to the\n- * HotSpot Virtual Machine. It indicates that an annotated method\n- * may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method\n- * is intrinsified if the HotSpot VM replaces the annotated method with hand-written\n- * assembly and\/or hand-written compiler IR -- a compiler intrinsic -- to improve\n- * performance. The {@code @IntrinsicCandidate} annotation is internal to the\n- * Java libraries and is therefore not supposed to have any relevance for application\n- * code.\n- *\n- * Maintainers of the Java libraries must consider the following when\n- * modifying methods annotated with {@code @IntrinsicCandidate}.\n- *\n- * <ul>\n- * <li>When modifying a method annotated with {@code @IntrinsicCandidate},\n- * the corresponding intrinsic code in the HotSpot VM implementation must be\n- * updated to match the semantics of the annotated method.<\/li>\n- * <li>For some annotated methods, the corresponding intrinsic may omit some low-level\n- * checks that would be performed as a matter of course if the intrinsic is implemented\n- * using Java bytecodes. This is because individual Java bytecodes implicitly check\n- * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}.\n- * If such a method is replaced by an intrinsic coded in assembly language, any\n- * checks performed as a matter of normal bytecode operation must be performed\n- * before entry into the assembly code. These checks must be performed, as\n- * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained\n- * by the intrinsic through those arguments. The checks may be deduced by inspecting\n- * the non-intrinsic Java code for the method, and determining exactly which exceptions\n- * may be thrown by the code, including undeclared implicit {@code RuntimeException}s.\n- * Therefore, depending on the data accesses performed by the intrinsic,\n- * the checks may include:\n- *\n- *  <ul>\n- *  <li>null checks on references<\/li>\n- *  <li>range checks on primitive values used as array indexes<\/li>\n- *  <li>other validity checks on primitive values (e.g., for divide-by-zero conditions)<\/li>\n- *  <li>store checks on reference values stored into arrays<\/li>\n- *  <li>array length checks on arrays indexed from within the intrinsic<\/li>\n- *  <li>reference casts (when formal parameters are {@code Object} or some other weak type)<\/li>\n- *  <\/ul>\n- *\n- * <\/li>\n- *\n- * <li>Note that the receiver value ({@code this}) is passed as a extra argument\n- * to all non-static methods. If a non-static method is an intrinsic, the receiver\n- * value does not need a null check, but (as stated above) any values loaded by the\n- * intrinsic from object fields must also be checked. As a matter of clarity, it is\n- * better to make intrinisics be static methods, to make the dependency on {@code this}\n- * clear. Also, it is better to explicitly load all required values from object\n- * fields before entering the intrinsic code, and pass those values as explicit arguments.\n- * First, this may be necessary for null checks (or other checks). Second, if the\n- * intrinsic reloads the values from fields and operates on those without checks,\n- * race conditions may be able to introduce unchecked invalid values into the intrinsic.\n- * If the intrinsic needs to store a value back to an object field, that value should be\n- * returned explicitly from the intrinsic; if there are multiple return values, coders\n- * should consider buffering them in an array. Removing field access from intrinsics\n- * not only clarifies the interface with between the JVM and JDK; it also helps decouple\n- * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic\n- * manages all field accesses, then intrinsics can be coded to be agnostic of object\n- * layouts.<\/li>\n- *\n- * Maintainers of the HotSpot VM must consider the following when modifying\n- * intrinsics.\n- *\n- * <ul>\n- * <li>When adding a new intrinsic, make sure that the corresponding method\n- * in the Java libraries is annotated with {@code @IntrinsicCandidate}\n- * and that all possible call sequences that result in calling the intrinsic contain\n- * the checks omitted by the intrinsic (if any).<\/li>\n- * <li>When modifying an existing intrinsic, the Java libraries must be updated\n- * to match the semantics of the intrinsic and to execute all checks omitted\n- * by the intrinsic (if any).<\/li>\n- * <\/ul>\n- *\n- * Persons not directly involved with maintaining the Java libraries or the\n- * HotSpot VM can safely ignore the fact that a method is annotated with\n- * {@code @IntrinsicCandidate}.\n- *\n- * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic\n- * are available on all platforms supported by the HotSpot VM. Furthermore,\n- * the availability of an intrinsic on a given platform depends on the\n- * configuration of the HotSpot VM (e.g., the set of VM flags enabled).\n- * Therefore, annotating a method with {@code @IntrinsicCandidate} does\n- * not guarantee that the marked method is intrinsified by the HotSpot VM.\n- *\n- * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks\n- * (when loading a class) that (1) all methods of that class that are also on\n- * the VM's list of intrinsics are annotated with {@code @IntrinsicCandidate}\n- * and that (2) for all methods of that class annotated with\n- * {@code @IntrinsicCandidate} there is an intrinsic in the list.\n+ * The {@code @IntrinsicCandidate} indicates that an annotated method is\n+ * recognized by {@code vmIntrinsics.hpp} and may be subject to intrinsification\n+ * by the HotSpot VM (see {@code LibraryCallKit::try_to_inline} in {@code\n+ * library_call.cpp}) if an intrinsic is available. Intrinsification replaces a\n+ * method's body, bytecode or native, with hand-written platform assembly and\/or\n+ * compiler IR that may have different but compatible semantics from the original.\n+ * <p>\n+ * Many Java library functions have properties that cannot be deduced by the\n+ * compiler for optimization, or can utilize specific hardware instructions not\n+ * modeled by the compiler IR, making intrinsics necessary. However, due to the\n+ * error-prone nature of platform assembly and compiler IR, intrinsics should be\n+ * kept minimal, like locking sections - whatever can be done in Java code\n+ * should be done in Java.\n+ * <p>\n+ * In best practice, intrinsic methods are usually private, unsafe, and\n+ * static, and their encapsulating callers should perform validation checks.\n+ * Any validation must be done on values that are exclusively accessed by the\n+ * current thread: shared fields must be read into local variables, and shared\n+ * arrays must be copied to an exclusive copy, to ensure each shared location\n+ * (a field or an array component) is accessed exactly once. If a shared\n+ * location is read multiple times for check and for use, race conditions may\n+ * cause two reads to produce distinct values, known as TOCTOU (time of check\n+ * and time of use), and the read for use may produce an illegal value. Finally,\n+ * the thread-exclusive validated values are passed to the intrinsic methods.\n+ * <p>\n+ * The HotSpot VM checks, when loading a class, the consistency of recognized\n+ * methods and {@code @IntrinsicCandidate} annotations, unless the {@code\n+ * CheckIntrinsics} VM flag is disabled.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":29,"deletions":89,"binary":false,"changes":118,"status":"modified"}]}