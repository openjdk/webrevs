{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,8 +31,5 @@\n- * The {@code @IntrinsicCandidate} annotation is specific to the\n- * HotSpot Virtual Machine. It indicates that an annotated method\n- * may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method\n- * is intrinsified if the HotSpot VM replaces the annotated method with hand-written\n- * assembly and\/or hand-written compiler IR -- a compiler intrinsic -- to improve\n- * performance. The {@code @IntrinsicCandidate} annotation is internal to the\n- * Java libraries and is therefore not supposed to have any relevance for application\n- * code.\n+ * The {@code @IntrinsicCandidate} indicates that an annotated method is\n+ * recognized by {@code vmIntrinsics.hpp} for special treatment by the HotSpot\n+ * VM.  When a class is loading, the HotSpot VM checks the consistency of\n+ * recognized methods and {@code @IntrinsicCandidate} annotations, unless the\n+ * {@code CheckIntrinsics} VM flag is disabled.\n@@ -40,79 +37,66 @@\n- * Maintainers of the Java libraries must consider the following when\n- * modifying methods annotated with {@code @IntrinsicCandidate}.\n- *\n- * <ul>\n- * <li>When modifying a method annotated with {@code @IntrinsicCandidate},\n- * the corresponding intrinsic code in the HotSpot VM implementation must be\n- * updated to match the semantics of the annotated method.<\/li>\n- * <li>For some annotated methods, the corresponding intrinsic may omit some low-level\n- * checks that would be performed as a matter of course if the intrinsic is implemented\n- * using Java bytecodes. This is because individual Java bytecodes implicitly check\n- * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}.\n- * If such a method is replaced by an intrinsic coded in assembly language, any\n- * checks performed as a matter of normal bytecode operation must be performed\n- * before entry into the assembly code. These checks must be performed, as\n- * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained\n- * by the intrinsic through those arguments. The checks may be deduced by inspecting\n- * the non-intrinsic Java code for the method, and determining exactly which exceptions\n- * may be thrown by the code, including undeclared implicit {@code RuntimeException}s.\n- * Therefore, depending on the data accesses performed by the intrinsic,\n- * the checks may include:\n- *\n- *  <ul>\n- *  <li>null checks on references<\/li>\n- *  <li>range checks on primitive values used as array indexes<\/li>\n- *  <li>other validity checks on primitive values (e.g., for divide-by-zero conditions)<\/li>\n- *  <li>store checks on reference values stored into arrays<\/li>\n- *  <li>array length checks on arrays indexed from within the intrinsic<\/li>\n- *  <li>reference casts (when formal parameters are {@code Object} or some other weak type)<\/li>\n- *  <\/ul>\n- *\n- * <\/li>\n- *\n- * <li>Note that the receiver value ({@code this}) is passed as a extra argument\n- * to all non-static methods. If a non-static method is an intrinsic, the receiver\n- * value does not need a null check, but (as stated above) any values loaded by the\n- * intrinsic from object fields must also be checked. As a matter of clarity, it is\n- * better to make intrinisics be static methods, to make the dependency on {@code this}\n- * clear. Also, it is better to explicitly load all required values from object\n- * fields before entering the intrinsic code, and pass those values as explicit arguments.\n- * First, this may be necessary for null checks (or other checks). Second, if the\n- * intrinsic reloads the values from fields and operates on those without checks,\n- * race conditions may be able to introduce unchecked invalid values into the intrinsic.\n- * If the intrinsic needs to store a value back to an object field, that value should be\n- * returned explicitly from the intrinsic; if there are multiple return values, coders\n- * should consider buffering them in an array. Removing field access from intrinsics\n- * not only clarifies the interface with between the JVM and JDK; it also helps decouple\n- * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic\n- * manages all field accesses, then intrinsics can be coded to be agnostic of object\n- * layouts.<\/li>\n- *\n- * Maintainers of the HotSpot VM must consider the following when modifying\n- * intrinsics.\n- *\n- * <ul>\n- * <li>When adding a new intrinsic, make sure that the corresponding method\n- * in the Java libraries is annotated with {@code @IntrinsicCandidate}\n- * and that all possible call sequences that result in calling the intrinsic contain\n- * the checks omitted by the intrinsic (if any).<\/li>\n- * <li>When modifying an existing intrinsic, the Java libraries must be updated\n- * to match the semantics of the intrinsic and to execute all checks omitted\n- * by the intrinsic (if any).<\/li>\n- * <\/ul>\n- *\n- * Persons not directly involved with maintaining the Java libraries or the\n- * HotSpot VM can safely ignore the fact that a method is annotated with\n- * {@code @IntrinsicCandidate}.\n- *\n- * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic\n- * are available on all platforms supported by the HotSpot VM. Furthermore,\n- * the availability of an intrinsic on a given platform depends on the\n- * configuration of the HotSpot VM (e.g., the set of VM flags enabled).\n- * Therefore, annotating a method with {@code @IntrinsicCandidate} does\n- * not guarantee that the marked method is intrinsified by the HotSpot VM.\n- *\n- * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks\n- * (when loading a class) that (1) all methods of that class that are also on\n- * the VM's list of intrinsics are annotated with {@code @IntrinsicCandidate}\n- * and that (2) for all methods of that class annotated with\n- * {@code @IntrinsicCandidate} there is an intrinsic in the list.\n+ * <h2 id=\"intrinsification\">Intrinsification<\/h2>\n+ * Most frequently, the special treatment of an intrinsic is\n+ * <em>intrinsification<\/em>, which replaces a candidate method's body, bytecode\n+ * or native, with handwritten platform assembly and\/or compiler IR.  (See\n+ * {@code LibraryCallKit::try_to_inline} in {@code library_call.cpp} for logic\n+ * that checks if an intrinsic is available and applicable at a given call site.)\n+ * Many Java library methods have properties that cannot be deduced by the\n+ * compiler for optimization, or can utilize specific hardware instructions not\n+ * modeled by the compiler IR, making intrinsics necessary.\n+ * <p>\n+ * During execution, intrinsification may happen and may be rolled back at any\n+ * moment; this loading and unloading process may happen zero to many times.\n+ * For example, the bytecode of a candidate method may be executed by lower\n+ * compilation tiers of VM execution, while higher compilation tiers may replace\n+ * the bytecode with specialized assembly code and\/or compiler IR.  Therefore,\n+ * intrinsic implementors must ensure that non-bytecode execution has the same\n+ * results as execution of the actual Java code in all application contexts\n+ * (given that the assumptions on the arguments hold).\n+ * <p>\n+ * A candidate method should contain a minimal piece of Java code that should be\n+ * replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\n+ * case) <strong>unsafe<\/strong> - it may not perform checks, but instead makes\n+ * assumptions on its arguments that type safety is ensured by callers.  These\n+ * assumptions must be clearly documented on the candidate methods, and the\n+ * callers are fully responsible for preventing any kind of type safety\n+ * violation.  As long as these assumptions hold, readers can simply refer to\n+ * the candidate method's Java code body for program behaviors.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"unsafe-details\">\n+ * Examples of type safety violations include: dereferencing a null pointer;\n+ * accessing a field or method on an object which does not possess that field or\n+ * method; accessing an element of an array not actually present in the array;\n+ * and manipulating object references in a way that prevents the GC from\n+ * managing them.\n+ * <\/blockquote>\n+ * <p id=\"validation\">\n+ * To ensure type safety, candidate methods are typically private, and access to\n+ * them are encapsulated by more accessible methods that perform argument\n+ * validations.  Any validation must be done on values that are exclusively\n+ * accessed by the current thread: shared fields must be read into local\n+ * variables, and shared arrays must be copied to an exclusive copy, to ensure\n+ * each shared location (a field or an array component) is accessed at most once.\n+ * If a shared location is read multiple times for check and for use, race\n+ * conditions may cause two reads to produce distinct values, known as TOCTOU\n+ * (time of check and time of use), and the read for use may produce an illegal\n+ * value.  Finally, the thread-exclusive validated values are passed to the\n+ * candidate method.\n+ * <blockquote style=\"font-size:smaller;\"><p id=\"racy-array\">\n+ * For some highly optimized algorithms, it may be impractical to ensure that\n+ * array data is read or written only once by the intrinsic.  If the caller of\n+ * the intrinsic cannot guarantee that such array data is unshared, then the\n+ * caller must also document the effects of any race condition.  (Such a race\n+ * occurs when another thread writes the array data during the execution of the\n+ * intrinsic.)  For example, the documentation can simply say that the result is\n+ * undefined if a race happens.  However, race conditions must not lead to\n+ * program failures or type safety breaches, as listed above.\n+ * <p>\n+ * Reasoning about such race conditions is difficult, but it is a necessary\n+ * skill when working with intrinsics that can observe racing shared variables.\n+ * One example of a tolerable race is a repeated read of a shared reference.\n+ * This only works if the algorithm takes no action based on the first read,\n+ * other than deciding to perform the second read; it must \"forget what it saw\"\n+ * in the first read.  This is why the array-mismatch intrinsics can sometimes\n+ * report a tentative search hit (maybe using vectorized code), which can then\n+ * be confirmed (by scalar code) as the caller makes a fresh and independent\n+ * observation.\n+ * <\/blockquote>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":72,"deletions":88,"binary":false,"changes":160,"status":"modified"}]}