{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,92 +30,13 @@\n-\/**\n- * The {@code @IntrinsicCandidate} annotation is specific to the\n- * HotSpot Virtual Machine. It indicates that an annotated method\n- * may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method\n- * is intrinsified if the HotSpot VM replaces the annotated method with hand-written\n- * assembly and\/or hand-written compiler IR -- a compiler intrinsic -- to improve\n- * performance. The {@code @IntrinsicCandidate} annotation is internal to the\n- * Java libraries and is therefore not supposed to have any relevance for application\n- * code.\n- *\n- * Maintainers of the Java libraries must consider the following when\n- * modifying methods annotated with {@code @IntrinsicCandidate}.\n- *\n- * <ul>\n- * <li>When modifying a method annotated with {@code @IntrinsicCandidate},\n- * the corresponding intrinsic code in the HotSpot VM implementation must be\n- * updated to match the semantics of the annotated method.<\/li>\n- * <li>For some annotated methods, the corresponding intrinsic may omit some low-level\n- * checks that would be performed as a matter of course if the intrinsic is implemented\n- * using Java bytecodes. This is because individual Java bytecodes implicitly check\n- * for exceptions like {@code NullPointerException} and {@code ArrayStoreException}.\n- * If such a method is replaced by an intrinsic coded in assembly language, any\n- * checks performed as a matter of normal bytecode operation must be performed\n- * before entry into the assembly code. These checks must be performed, as\n- * appropriate, on all arguments to the intrinsic, and on other values (if any) obtained\n- * by the intrinsic through those arguments. The checks may be deduced by inspecting\n- * the non-intrinsic Java code for the method, and determining exactly which exceptions\n- * may be thrown by the code, including undeclared implicit {@code RuntimeException}s.\n- * Therefore, depending on the data accesses performed by the intrinsic,\n- * the checks may include:\n- *\n- *  <ul>\n- *  <li>null checks on references<\/li>\n- *  <li>range checks on primitive values used as array indexes<\/li>\n- *  <li>other validity checks on primitive values (e.g., for divide-by-zero conditions)<\/li>\n- *  <li>store checks on reference values stored into arrays<\/li>\n- *  <li>array length checks on arrays indexed from within the intrinsic<\/li>\n- *  <li>reference casts (when formal parameters are {@code Object} or some other weak type)<\/li>\n- *  <\/ul>\n- *\n- * <\/li>\n- *\n- * <li>Note that the receiver value ({@code this}) is passed as a extra argument\n- * to all non-static methods. If a non-static method is an intrinsic, the receiver\n- * value does not need a null check, but (as stated above) any values loaded by the\n- * intrinsic from object fields must also be checked. As a matter of clarity, it is\n- * better to make intrinisics be static methods, to make the dependency on {@code this}\n- * clear. Also, it is better to explicitly load all required values from object\n- * fields before entering the intrinsic code, and pass those values as explicit arguments.\n- * First, this may be necessary for null checks (or other checks). Second, if the\n- * intrinsic reloads the values from fields and operates on those without checks,\n- * race conditions may be able to introduce unchecked invalid values into the intrinsic.\n- * If the intrinsic needs to store a value back to an object field, that value should be\n- * returned explicitly from the intrinsic; if there are multiple return values, coders\n- * should consider buffering them in an array. Removing field access from intrinsics\n- * not only clarifies the interface with between the JVM and JDK; it also helps decouple\n- * the HotSpot and JDK implementations, since if JDK code before and after the intrinsic\n- * manages all field accesses, then intrinsics can be coded to be agnostic of object\n- * layouts.<\/li>\n- *\n- * Maintainers of the HotSpot VM must consider the following when modifying\n- * intrinsics.\n- *\n- * <ul>\n- * <li>When adding a new intrinsic, make sure that the corresponding method\n- * in the Java libraries is annotated with {@code @IntrinsicCandidate}\n- * and that all possible call sequences that result in calling the intrinsic contain\n- * the checks omitted by the intrinsic (if any).<\/li>\n- * <li>When modifying an existing intrinsic, the Java libraries must be updated\n- * to match the semantics of the intrinsic and to execute all checks omitted\n- * by the intrinsic (if any).<\/li>\n- * <\/ul>\n- *\n- * Persons not directly involved with maintaining the Java libraries or the\n- * HotSpot VM can safely ignore the fact that a method is annotated with\n- * {@code @IntrinsicCandidate}.\n- *\n- * The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic\n- * are available on all platforms supported by the HotSpot VM. Furthermore,\n- * the availability of an intrinsic on a given platform depends on the\n- * configuration of the HotSpot VM (e.g., the set of VM flags enabled).\n- * Therefore, annotating a method with {@code @IntrinsicCandidate} does\n- * not guarantee that the marked method is intrinsified by the HotSpot VM.\n- *\n- * If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks\n- * (when loading a class) that (1) all methods of that class that are also on\n- * the VM's list of intrinsics are annotated with {@code @IntrinsicCandidate}\n- * and that (2) for all methods of that class annotated with\n- * {@code @IntrinsicCandidate} there is an intrinsic in the list.\n- *\n- * @since 16\n- *\/\n+\/\/\/ The `@IntrinsicCandidate` indicates that an annotated method is\n+\/\/\/ recognized by `vmIntrinsics.hpp` for special treatment by the HotSpot\n+\/\/\/ VM.  When a class is loading, the HotSpot VM checks the consistency of\n+\/\/\/ recognized methods and `@IntrinsicCandidate` annotations, unless the\n+\/\/\/ `CheckIntrinsics` VM flag is disabled.\n+\/\/\/\n+\/\/\/ Most frequently, the special treatment of an intrinsic is *intrinsification*,\n+\/\/\/ which replaces a candidate method's body, bytecode or native, with\n+\/\/\/ handwritten platform assembly and\/or compiler IR.  See\n+\/\/\/ <a href=\"..\/intrinsics.md\">intrinsics design document<\/a> for\n+\/\/\/ what intrinsics are and cautions for working with annotated methods.\n+\/\/\/\n+\/\/\/ @since 16\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/IntrinsicCandidate.java","additions":14,"deletions":93,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+<!--\r\n+\r\n+Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\r\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+\r\n+This code is free software; you can redistribute it and\/or modify it\r\n+under the terms of the GNU General Public License version 2 only, as\r\n+published by the Free Software Foundation.  Oracle designates this\r\n+particular file as subject to the \"Classpath\" exception as provided\r\n+by Oracle in the LICENSE file that accompanied this code.\r\n+\r\n+This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+version 2 for more details (a copy is included in the LICENSE file that\r\n+accompanied this code).\r\n+\r\n+You should have received a copy of the GNU General Public License version\r\n+2 along with this work; if not, write to the Free Software Foundation,\r\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+\r\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+or visit www.oracle.com if you need additional information or have any\r\n+questions.\r\n+\r\n+-->\r\n+\r\n+# Intrinsification\r\n+Intrinsification replaces a candidate method's body, bytecode or native, with\r\n+handwritten platform assembly and\/or compiler IR.  (In `library_call.cpp`,\r\n+`LibraryCallKit::try_to_inline` checks if an intrinsic is available and\r\n+applicable at a given call site.)  Many Java library methods have properties\r\n+that cannot be deduced by the compiler for optimization, or can utilize specific\r\n+hardware instructions not modeled by the compiler IR, making intrinsics necessary.\r\n+\r\n+During execution, intrinsification may happen and may be rolled back at any\r\n+moment; this loading and unloading process may happen zero to many times.\r\n+For example, the bytecode of a candidate method may be executed by lower\r\n+compilation tiers of VM execution, while higher compilation tiers may replace\r\n+the bytecode with specialized assembly code and\/or compiler IR.  Therefore,\r\n+intrinsic implementors must ensure that non-bytecode execution has the same\r\n+results as execution of the actual Java code in all application contexts\r\n+(given that the assumptions on the arguments hold).\r\n+\r\n+A candidate method should contain a minimal piece of Java code that should be\r\n+replaced by an intrinsic wholesale.  The backing intrinsic is (in the common\r\n+case) **unsafe** - it may not perform checks, but instead makes\r\n+assumptions on its arguments that type safety is ensured by callers.  These\r\n+assumptions must be clearly documented on the candidate methods, and the\r\n+callers are fully responsible for preventing any kind of type safety\r\n+violation.  As long as these assumptions hold, readers can simply refer to\r\n+the candidate method's Java code body for program behaviors.\r\n+\r\n+<a id=\"unsafe-details\" \/>\r\n+\r\n+> Examples of type safety violations include: dereferencing a null pointer;\r\n+> accessing a field or method on an object which does not possess that field or\r\n+> method; accessing an element of an array not actually present in the array;\r\n+> and manipulating object references in a way that prevents the GC from\r\n+> managing them.\r\n+\r\n+### Validation\r\n+To ensure type safety, candidate methods are typically private, and access to\r\n+them are encapsulated by more accessible methods that perform argument\r\n+validations.  Any validation must be done on values that are exclusively\r\n+accessed by the current thread: shared fields must be read into local\r\n+variables, and shared arrays must be copied to an exclusive copy, to ensure\r\n+each shared location (a field or an array component) is accessed at most once.\r\n+If a shared location is read multiple times for check and for use, race\r\n+conditions may cause two reads to produce distinct values, known as TOCTOU\r\n+(time of check and time of use), and the read for use may produce an illegal\r\n+value.  Finally, the thread-exclusive validated values are passed to the\r\n+candidate method.\r\n+\r\n+<a id=\"racy-array\" \/>\r\n+\r\n+> For some highly optimized algorithms, it may be impractical to ensure that\r\n+> array data is read or written only once by the intrinsic.  If the caller of\r\n+> the intrinsic cannot guarantee that such array data is unshared, then the\r\n+> caller must also document the effects of any race condition.  (Such a race\r\n+> occurs when another thread writes the array data during the execution of the\r\n+> intrinsic.)  For example, the documentation can simply say that the result is\r\n+> undefined if a race happens.  However, race conditions must not lead to\r\n+> program failures or type safety breaches, as listed above.\r\n+>\r\n+> Reasoning about such race conditions is difficult, but it is a necessary\r\n+> skill when working with intrinsics that can observe racing shared variables.\r\n+> One example of a tolerable race is a repeated read of a shared reference.\r\n+> This only works if the algorithm takes no action based on the first read,\r\n+> other than deciding to perform the second read; it must \"forget what it saw\"\r\n+> in the first read.  This is why the array-mismatch intrinsics can sometimes\r\n+> report a tentative search hit (maybe using vectorized code), which can then\r\n+> be confirmed (by scalar code) as the caller makes a fresh and independent\r\n+> observation.\r\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/intrinsics.md","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}