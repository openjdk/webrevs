{"files":[{"patch":"@@ -1994,0 +1994,1 @@\n+\/\/ Note: vsrc and vtmp2 may match.\n@@ -2000,0 +2001,2 @@\n+  assert_different_registers(vtmp1, vsrc);\n+  assert_different_registers(vtmp1, vtmp2);\n@@ -2033,3 +2036,3 @@\n-          ins(vtmp2, D, vsrc, 0, 1);\n-          mulv(vtmp2, T4H, vtmp2, vsrc);\n-          ins(vtmp1, S, vtmp2, 0, 1);\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vsrc);\n+          ins(vtmp2, S, vtmp1, 0, 1);\n@@ -2087,0 +2090,21 @@\n+  unsigned vector_length = vector_length_in_bytes \/ type2aelembytes(bt);\n+\n+  auto do_recursive_folding_iteration =\n+      [&](FloatRegister vdst, FloatRegister vsrc, FloatRegister vtmp) {\n+        assert(vdst == vtmp || vdst == vsrc, \"unsupported combination of registers\");\n+        sve_gen_mask_imm(pgtmp, bt, vector_length \/ 2);\n+        \/\/ Shuffle the upper half elements of the register to the right.\n+        sve_movprfx(vtmp1, vsrc);\n+        sve_ext(vtmp1, vsrc, vector_length_in_bytes \/ 2);\n+        if (vdst == vtmp) {\n+          sve_mul(vdst, elemType_to_regVariant(bt), pgtmp, vsrc);\n+        } else if (vdst == vsrc) {\n+          sve_mul(vdst, elemType_to_regVariant(bt), pgtmp, vtmp);\n+        } else {\n+          ShouldNotReachHere();\n+        }\n+        vector_length_in_bytes = vector_length_in_bytes \/ 2;\n+        vector_length = vector_length \/ 2;\n+      };\n+\n+  do_recursive_folding_iteration(vtmp1, vsrc, vtmp1);\n@@ -2088,7 +2112,1 @@\n-    unsigned vector_length = vector_length_in_bytes \/ type2aelembytes(bt);\n-    sve_gen_mask_imm(pgtmp, bt, vector_length \/ 2);\n-    \/\/ Shuffle the upper half elements of the register to the right.\n-    sve_movprfx(vtmp1, vsrc);\n-    sve_ext(vtmp1, vsrc, vector_length_in_bytes \/ 2);\n-    sve_mul(vsrc, elemType_to_regVariant(bt), pgtmp, vtmp1);\n-    vector_length_in_bytes = vector_length_in_bytes \/ 2;\n+    do_recursive_folding_iteration(vtmp1, vtmp1, vtmp2);\n@@ -2097,1 +2115,1 @@\n-  reduce_mul_integral_le128b(dst, bt, isrc, vsrc, FloatRegister::neon_vl, vtmp1, vtmp2);\n+  reduce_mul_integral_le128b(dst, bt, isrc, vtmp1, FloatRegister::neon_vl, vtmp2, vtmp1);\n@@ -2109,10 +2127,21 @@\n-  switch (bt) {\n-  case T_FLOAT:\n-    fmuls(dst, fsrc, vsrc);\n-    ins(vtmp, S, vsrc, 0, 1);\n-    fmuls(dst, dst, vtmp);\n-    if (isQ) {\n-      ins(vtmp, S, vsrc, 0, 2);\n-      fmuls(dst, dst, vtmp);\n-      ins(vtmp, S, vsrc, 0, 3);\n-      fmuls(dst, dst, vtmp);\n+    switch(bt) {\n+      case T_FLOAT:\n+        fmuls(dst, fsrc, vsrc);\n+        ins(vtmp, S, vsrc, 0, 1);\n+        fmuls(dst, dst, vtmp);\n+        if (isQ) {\n+          ins(vtmp, S, vsrc, 0, 2);\n+          fmuls(dst, dst, vtmp);\n+          ins(vtmp, S, vsrc, 0, 3);\n+          fmuls(dst, dst, vtmp);\n+         }\n+        break;\n+      case T_DOUBLE:\n+        assert(isQ, \"unsupported\");\n+        fmuld(dst, fsrc, vsrc);\n+        ins(vtmp, D, vsrc, 0, 1);\n+        fmuld(dst, dst, vtmp);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n@@ -2120,11 +2149,0 @@\n-    break;\n-  case T_DOUBLE:\n-    assert(isQ, \"unsupported\");\n-    fmuld(dst, fsrc, vsrc);\n-    ins(vtmp, D, vsrc, 0, 1);\n-    fmuld(dst, dst, vtmp);\n-    break;\n-  default:\n-    assert(false, \"unsupported\");\n-    ShouldNotReachHere();\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":50,"deletions":32,"binary":false,"changes":82,"status":"modified"}]}