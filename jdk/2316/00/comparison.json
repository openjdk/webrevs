{"files":[{"patch":"@@ -75,0 +75,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -419,1 +420,1 @@\n-                        if ((ct.sym.flags_field & Flags.UNATTRIBUTED) != 0) {\n+                        if (ct.sym.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n@@ -1008,1 +1009,1 @@\n-        if (enclClass != null && (enclClass.flags_field & Flags.UNATTRIBUTED) != 0) {\n+        if (enclClass != null && enclClass.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -245,1 +246,1 @@\n-    long getSupplementaryFlags(ClassSymbol c) {\n+    void addSupplementaryFlags(ClassSymbol c) {\n@@ -247,1 +248,1 @@\n-            return 0;\n+            return ;\n@@ -254,12 +255,7 @@\n-        Long flags = supplementaryFlags.get(c.packge());\n-        if (flags == null) {\n-            long newFlags = 0;\n-            try {\n-                JRTIndex.CtSym ctSym = jrtIndex.getCtSym(c.packge().flatName());\n-                Profile minProfile = Profile.DEFAULT;\n-                if (ctSym.proprietary)\n-                    newFlags |= PROPRIETARY;\n-                if (ctSym.minProfile != null)\n-                    minProfile = Profile.lookup(ctSym.minProfile);\n-                if (profile != Profile.DEFAULT && minProfile.value > profile.value) {\n-                    newFlags |= NOT_IN_PROFILE;\n+        JRTIndex.CtSym extra = supplementaryFlags.computeIfAbsent(c.packge(),\n+                p -> {\n+                    try {\n+                        return jrtIndex.getCtSym(c.packge().flatName());\n+                    } catch (IOException ignore) {\n+                        return null;\n+                    }\n@@ -267,3 +263,8 @@\n-            } catch (IOException ignore) {\n-            }\n-            supplementaryFlags.put(c.packge(), flags = newFlags);\n+        );\n+        Profile minProfile = Profile.DEFAULT;\n+        if (extra.proprietary)\n+            c.setFlag(TypeSymbolFlags.PROPRIETARY);\n+        if (extra.minProfile != null)\n+            minProfile = Profile.lookup(extra.minProfile);\n+        if (profile != Profile.DEFAULT && minProfile.value > profile.value) {\n+            c.setFlag(TypeSymbolFlags.NOT_IN_PROFILE);\n@@ -271,1 +272,0 @@\n-        return flags;\n@@ -274,1 +274,1 @@\n-    private Map<PackageSymbol, Long> supplementaryFlags;\n+    private Map<PackageSymbol, JRTIndex.CtSym> supplementaryFlags;\n@@ -363,1 +363,1 @@\n-                    c.flags_field |= getSupplementaryFlags(c);\n+                    addSupplementaryFlags(c);\n@@ -457,1 +457,1 @@\n-        if ((p.flags_field & EXISTS) == 0)\n+        if (!p.isFlagSetNoComplete(TypeSymbolFlags.EXISTS))\n@@ -459,1 +459,1 @@\n-                q.flags_field |= EXISTS;\n+                ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n@@ -461,1 +461,1 @@\n-        int seen;\n+        TypeSymbolFlags seen;\n@@ -463,1 +463,1 @@\n-            seen = CLASS_SEEN;\n+            seen = TypeSymbolFlags.CLASS_SEEN;\n@@ -465,1 +465,1 @@\n-            seen = SOURCE_SEEN;\n+            seen = TypeSymbolFlags.SOURCE_SEEN;\n@@ -483,1 +483,1 @@\n-        } else if (!preferCurrent && c.classfile != null && (c.flags_field & seen) == 0) {\n+        } else if (!preferCurrent && c.classfile != null && !c.isFlagSetNoComplete(seen)) {\n@@ -488,1 +488,2 @@\n-            if ((c.flags_field & (CLASS_SEEN | SOURCE_SEEN)) != 0)\n+            if (c.isFlagSetNoComplete(TypeSymbolFlags.CLASS_SEEN) ||\n+                c.isFlagSetNoComplete(TypeSymbolFlags.SOURCE_SEEN))\n@@ -491,1 +492,1 @@\n-        c.flags_field |= seen;\n+        c.setFlag(seen);\n@@ -754,1 +755,1 @@\n-                                p.flags_field |= Flags.HAS_RESOURCE;\n+                                p.setFlag(TypeSymbolFlags.HAS_RESOURCE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        Assert.check(flags == 0);\n+        Assert.check((flags & (LAST_FLAT_BIT * 2 - 1)) == 0);\n@@ -116,0 +116,1 @@\n+    \/\/on all Symbols:\n@@ -120,98 +121,0 @@\n-    \/** Flag is set for a variable symbol if the variable's definition\n-     *  has an initializer part.\n-     *\/\n-    public static final int HASINIT          = 1<<18;\n-\n-    \/** Flag is set for compiler-generated anonymous method symbols\n-     *  that `own' an initializer block.\n-     *\/\n-    public static final int BLOCK            = 1<<20;\n-\n-    \/** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement\n-     *  an interface method (Miranda methods)).\n-     *\/\n-\n-    \/** Flag is set for nested classes that do not access instance members\n-     *  or `this' of an outer class and therefore don't need to be passed\n-     *  a this$n reference.  This value is currently set only for anonymous\n-     *  classes in superclass constructor calls.\n-     *  todo: use this value for optimizing away this$n parameters in\n-     *  other cases.\n-     *\/\n-    public static final int NOOUTERTHIS  = 1<<22;\n-\n-    \/** Flag is set for package symbols if a package has a member or\n-     *  directory and therefore exists.\n-     *\/\n-    public static final int EXISTS           = 1<<23;\n-\n-    \/** Flag is set for compiler-generated compound classes\n-     *  representing multiple variable bounds\n-     *\/\n-    public static final int COMPOUND     = 1<<24;\n-\n-    \/** Flag is set for class symbols if a class file was found for this class.\n-     *\/\n-    public static final int CLASS_SEEN   = 1<<25;\n-\n-    \/** Flag is set for class symbols if a source file was found for this\n-     *  class.\n-     *\/\n-    public static final int SOURCE_SEEN  = 1<<26;\n-\n-    \/* State flags (are reset during compilation).\n-     *\/\n-\n-    \/** Flag for class symbols is set and later re-set as a lock in\n-     *  Enter to detect cycles in the superclass\/superinterface\n-     *  relations.  Similarly for constructor call cycle detection in\n-     *  Attr.\n-     *\/\n-    public static final int LOCKED           = 1<<27;\n-\n-    \/** Flag for class symbols is set and later re-set to indicate that a class\n-     *  has been entered but has not yet been attributed.\n-     *\/\n-    public static final int UNATTRIBUTED = 1<<28;\n-\n-    \/** Flag for synthesized default constructors of anonymous classes.\n-     *\/\n-    public static final int ANONCONSTR   = 1<<29;\n-\n-    \/** Flag for class symbols to indicate it has been checked and found\n-     *  acyclic.\n-     *\/\n-    public static final int ACYCLIC          = 1<<30;\n-\n-    \/** Flag that marks bridge methods.\n-     *\/\n-    public static final long BRIDGE          = 1L<<31;\n-\n-    \/** Flag that marks formal parameters.\n-     *\/\n-    public static final long PARAMETER   = 1L<<33;\n-\n-    \/** Flag that marks varargs methods.\n-     *\/\n-    public static final long VARARGS   = 1L<<34;\n-\n-    \/** Flag for annotation type symbols to indicate it has been\n-     *  checked and found acyclic.\n-     *\/\n-    public static final long ACYCLIC_ANN      = 1L<<35;\n-\n-    \/** Flag that marks a generated default constructor.\n-     *\/\n-    public static final long GENERATEDCONSTR   = 1L<<36;\n-\n-    \/** Flag that marks a hypothetical method that need not really be\n-     *  generated in the binary, but is present in the symbol table to\n-     *  simplify checking for erasure clashes - also used for 292 poly sig methods.\n-     *\/\n-    public static final long HYPOTHETICAL   = 1L<<37;\n-\n-    \/**\n-     * Flag that marks an internal proprietary class.\n-     *\/\n-    public static final long PROPRIETARY = 1L<<38;\n-\n@@ -219,29 +122,1 @@\n-     * Flag that marks a multi-catch parameter.\n-     *\/\n-    public static final long UNION = 1L<<39;\n-\n-    \/**\n-     * Flags an erroneous TypeSymbol as viable for recovery.\n-     * TypeSymbols only.\n-     *\/\n-    public static final long RECOVERABLE = 1L<<40;\n-\n-    \/**\n-     * Flag that marks an 'effectively final' local variable.\n-     *\/\n-    public static final long EFFECTIVELY_FINAL = 1L<<41;\n-\n-    \/**\n-     * Flag that marks non-override equivalent methods with the same signature,\n-     * or a conflicting match binding (BindingSymbol).\n-     *\/\n-    public static final long CLASH = 1L<<42;\n-\n-    \/**\n-     * Flag that marks either a default method or an interface containing default methods.\n-     *\/\n-    public static final long DEFAULT = 1L<<43;\n-\n-    \/**\n-     * Flag that marks class as auxiliary, ie a non-public class following\n-     * the public class in a source file, that could block implicit compilation.\n+     * Flag to indicate the given symbol has a @Deprecated annotation.\n@@ -249,1 +124,1 @@\n-    public static final long AUXILIARY = 1L<<44;\n+    public static final long DEPRECATED_ANNOTATION = 1L<<18;\n@@ -252,1 +127,1 @@\n-     * Flag that marks that a symbol is not available in the current profile\n+     * Flag to indicate the given symbol has been deprecated and marked for removal.\n@@ -254,1 +129,1 @@\n-    public static final long NOT_IN_PROFILE = 1L<<45;\n+    public static final long DEPRECATED_REMOVAL = 1L<<19;\n@@ -257,1 +132,1 @@\n-     * Flag that indicates that an override error has been detected by Check.\n+     * Flag to indicate the API element in question is for a preview API.\n@@ -259,1 +134,1 @@\n-    public static final long BAD_OVERRIDE = 1L<<45;\n+    public static final long PREVIEW_API = 1L<<20; \/\/any Symbol kind\n@@ -262,1 +137,1 @@\n-     * Flag that indicates a signature polymorphic method (292).\n+     * Flag to indicate the API element in question is for a reflective preview API.\n@@ -264,1 +139,1 @@\n-    public static final long SIGNATURE_POLYMORPHIC = 1L<<46;\n+    public static final long PREVIEW_REFLECTIVE = 1L<<21; \/\/any Symbol kind\n@@ -266,2 +141,2 @@\n-    \/**\n-     * Flag that indicates that an inference variable is used in a 'throws' clause.\n+    \/\/classfile flags:\n+    \/** Flag that marks bridge methods.\n@@ -269,1 +144,1 @@\n-    public static final long THROWS = 1L<<47;\n+    public static final long BRIDGE          = 1L<<22;\n@@ -271,2 +146,1 @@\n-    \/**\n-     * Flag that marks potentially ambiguous overloads\n+    \/** Flag that marks formal parameters.\n@@ -274,1 +148,1 @@\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n+    public static final long PARAMETER   = 1L<<23;\n@@ -276,2 +150,1 @@\n-    \/**\n-     * Flag that marks a synthetic method body for a lambda expression\n+    \/** Flag that marks varargs methods.\n@@ -279,1 +152,1 @@\n-    public static final long LAMBDA_METHOD = 1L<<49;\n+    public static final long VARARGS   = 1L<<24;\n@@ -282,1 +155,1 @@\n-     * Flag to control recursion in TransTypes\n+     * Flag that marks either a default method or an interface containing default methods.\n@@ -284,1 +157,1 @@\n-    public static final long TYPE_TRANSLATED = 1L<<50;\n+    public static final long DEFAULT = 1L<<25;\n@@ -289,1 +162,1 @@\n-    public static final long MODULE = 1L<<51;\n+    public static final long MODULE = 1L<<26;\n@@ -291,22 +164,2 @@\n-    \/**\n-     * Flag to indicate the given ModuleSymbol is an automatic module.\n-     *\/\n-    public static final long AUTOMATIC_MODULE = 1L<<52; \/\/ModuleSymbols only\n-\n-    \/**\n-     * Flag to indicate the given PackageSymbol contains any non-.java and non-.class resources.\n-     *\/\n-    public static final long HAS_RESOURCE = 1L<<52; \/\/PackageSymbols only\n-\n-    \/**\n-     * Flag to indicate the given ParamSymbol has a user-friendly name filled.\n-     *\/\n-    public static final long NAME_FILLED = 1L<<52; \/\/ParamSymbols only\n-\n-    \/**\n-     * Flag to indicate the given ModuleSymbol is a system module.\n-     *\/\n-    public static final long SYSTEM_MODULE = 1L<<53;\n-\n-    \/**\n-     * Flag to indicate the given symbol has a @Deprecated annotation.\n+    \/\/used on trees:\n+    \/** Flag for synthesized default constructors of anonymous classes.\n@@ -314,1 +167,1 @@\n-    public static final long DEPRECATED_ANNOTATION = 1L<<54;\n+    public static final int ANONCONSTR   = 1<<27;\n@@ -317,1 +170,1 @@\n-     * Flag to indicate the given symbol has been deprecated and marked for removal.\n+     * Flag for synthesized default constructors of anonymous classes that have an enclosing expression.\n@@ -319,1 +172,1 @@\n-    public static final long DEPRECATED_REMOVAL = 1L<<55;\n+    public static final long ANONCONSTR_BASED = 1L<<28;\n@@ -321,2 +174,1 @@\n-    \/**\n-     * Flag to indicate the API element in question is for a preview API.\n+    \/** Flag that marks a generated default constructor.\n@@ -324,1 +176,1 @@\n-    public static final long PREVIEW_API = 1L<<56; \/\/any Symbol kind\n+    public static final long GENERATEDCONSTR   = 1L<<29;\n@@ -327,1 +179,1 @@\n-     * Flag for synthesized default constructors of anonymous classes that have an enclosing expression.\n+     * Flag to mark a record constructor as a compact one\n@@ -329,1 +181,1 @@\n-    public static final long ANONCONSTR_BASED = 1L<<57;\n+    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<30; \/\/ MethodSymbols only\n@@ -335,1 +187,1 @@\n-    public static final long BODY_ONLY_FINALIZE = 1L<<17; \/\/blocks only\n+    public static final long BODY_ONLY_FINALIZE = 1L<<31;\n@@ -337,0 +189,1 @@\n+    \/\/other:\n@@ -338,1 +191,2 @@\n-     * Flag to indicate the API element in question is for a preview API.\n+     * Flag to indicate that a class is a record. The flag is also used to mark fields that are\n+     * part of the state vector of a record and to mark the canonical constructor\n@@ -340,1 +194,1 @@\n-    public static final long PREVIEW_REFLECTIVE = 1L<<58; \/\/any Symbol kind\n+    public static final long RECORD = 1L<<32; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n@@ -342,2 +196,2 @@\n-    \/**\n-     * Flag to indicate the given variable is a match binding variable.\n+    \/** Flag is set for compiler-generated record members, it could be applied to\n+     *  accessors and fields\n@@ -345,1 +199,1 @@\n-    public static final long MATCH_BINDING = 1L<<59;\n+    public static final long GENERATED_MEMBER = 1L<<33; \/\/ MethodSymbols and VarSymbols\n@@ -348,1 +202,2 @@\n-     * A flag to indicate a match binding variable whose scope extends after the current statement.\n+     * Flag that marks non-override equivalent methods with the same signature,\n+     * or a conflicting match binding (BindingSymbol).\n@@ -350,1 +205,1 @@\n-    public static final long MATCH_BINDING_TO_OUTER = 1L<<60;\n+    public static final long CLASH = 1L<<34;\n@@ -352,3 +207,2 @@\n-    \/**\n-     * Flag to indicate that a class is a record. The flag is also used to mark fields that are\n-     * part of the state vector of a record and to mark the canonical constructor\n+    \/** Flag is set for compiler-generated anonymous method symbols\n+     *  that `own' an initializer block.\n@@ -356,1 +210,1 @@\n-    public static final long RECORD = 1L<<61; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n+    public static final long BLOCK            = 1L<<35;\n@@ -358,2 +212,2 @@\n-    \/**\n-     * Flag to mark a record constructor as a compact one\n+    \/** Flag is set for a variable symbol if the variable's definition\n+     *  has an initializer part.\n@@ -361,1 +215,1 @@\n-    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51; \/\/ MethodSymbols only\n+    public static final long HASINIT          = 1L<<36;\n@@ -364,6 +218,1 @@\n-     * Flag to mark a record field that was not initialized in the compact constructor\n-     *\/\n-    public static final long UNINITIALIZED_FIELD= 1L<<51; \/\/ VarSymbols only\n-\n-    \/** Flag is set for compiler-generated record members, it could be applied to\n-     *  accessors and fields\n+     * Flag that indicates that an inference variable is used in a 'throws' clause.\n@@ -371,1 +220,1 @@\n-    public static final int GENERATED_MEMBER = 1<<24; \/\/ MethodSymbols and VarSymbols\n+    public static final long THROWS = 1L<<37;\n@@ -376,1 +225,1 @@\n-    public static final long SEALED = 1L<<62; \/\/ ClassSymbols\n+    public static final long SEALED = 1L<<38; \/\/ ClassSymbols\n@@ -381,1 +230,7 @@\n-    public static final long NON_SEALED = 1L<<63; \/\/ ClassSymbols\n+    public static final long NON_SEALED = 1L<<39; \/\/ ClassSymbols\n+\n+    \/**\n+     * The last bit used by the \"flat\" flags above. Should be updated when a new\n+     * flag is added.\n+     *\/\n+    public static final long LAST_FLAT_BIT = NON_SEALED;\n@@ -454,0 +309,190 @@\n+    public enum TypeSymbolFlags {\n+        \/\/PackageSymbols:\n+        \/** Flag is set for package symbols if a package has a member or\n+         *  directory and therefore exists.\n+         *\/\n+        EXISTS,\n+\n+        \/**\n+         * Flag to indicate the given PackageSymbol contains any non-.java and non-.class resources.\n+         *\/\n+        HAS_RESOURCE,\n+\n+        \/\/ClassSymbols:\n+        \/** Flag is set for nested classes that do not access instance members\n+         *  or `this' of an outer class and therefore don't need to be passed\n+         *  a this$n reference.  This value is currently set only for anonymous\n+         *  classes in superclass constructor calls.\n+         *  todo: use this value for optimizing away this$n parameters in\n+         *  other cases.\n+         *\/\n+        NOOUTERTHIS,\n+\n+        \/** Flag is set for compiler-generated compound classes\n+         *  representing multiple variable bounds\n+         *\/\n+        COMPOUND,\n+\n+        \/** Flag is set for class symbols if a class file was found for this class.\n+         *\/\n+        CLASS_SEEN,\n+\n+        \/** Flag is set for class symbols if a source file was found for this\n+         *  class.\n+         *\/\n+        SOURCE_SEEN,\n+\n+        \/** Flag for class symbols is set and later re-set as a lock in\n+         *  Enter to detect cycles in the superclass\/superinterface\n+         *  relations.  Similarly for constructor call cycle detection in\n+         *  Attr.\n+         *\/\n+        LOCKED,\n+\n+        \/** Flag for class symbols is set and later re-set to indicate that a class\n+         *  has been entered but has not yet been attributed.\n+         *\/\n+        UNATTRIBUTED,\n+\n+        \/** Flag for class symbols to indicate it has been checked and found\n+         *  acyclic.\n+         *\/\n+        ACYCLIC,\n+\n+        \/** Flag for annotation type symbols to indicate it has been\n+         *  checked and found acyclic.\n+         *\/\n+        ACYCLIC_ANN,\n+\n+        \/**\n+         * Flag that marks an internal proprietary class.\n+         *\/\n+        PROPRIETARY,\n+\n+        \/**\n+         * Flag that marks class as auxiliary, ie a non-public class following\n+         * the public class in a source file, that could block implicit compilation.\n+         *\/\n+        AUXILIARY,\n+\n+        \/**\n+         * Flag to control recursion in TransTypes\n+         *\/\n+        TYPE_TRANSLATED,\n+\n+        \/**\n+         * Flag that marks that a symbol is not available in the current profile\n+         *\/\n+        NOT_IN_PROFILE,\n+\n+        \/**\n+         * Flags an erroneous TypeSymbol as viable for recovery.\n+         * TypeSymbols only.\n+         *\/\n+        RECOVERABLE,\n+\n+        \/\/ModuleSymbols:\n+        \/**\n+         * Flag to indicate the given ModuleSymbol is an automatic module.\n+         *\/\n+        AUTOMATIC_MODULE,\n+\n+        \/**\n+         * Flag to indicate the given ModuleSymbol is a system module.\n+         *\/\n+        SYSTEM_MODULE,\n+        ;\n+\n+        final long mask;\n+        private TypeSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+\n+    }\n+\n+    public enum MethodSymbolFlags {\n+        \/** Flag that marks a hypothetical method that need not really be\n+         *  generated in the binary, but is present in the symbol table to\n+         *  simplify checking for erasure clashes - also used for 292 poly sig methods.\n+         *\/\n+        HYPOTHETICAL,\n+\n+        \/**\n+         * Flag that indicates that an override error has been detected by Check.\n+         *\/\n+        BAD_OVERRIDE,\n+\n+        \/**\n+         * Flag that indicates a signature polymorphic method (292).\n+         *\/\n+        SIGNATURE_POLYMORPHIC,\n+\n+        \/**\n+         * Flag that marks potentially ambiguous overloads\n+         *\/\n+        POTENTIALLY_AMBIGUOUS,\n+\n+        \/**\n+         * Flag that marks a synthetic method body for a lambda expression\n+         *\/\n+        LAMBDA_METHOD,\n+\n+        \/** Flag for class symbols to indicate it has been checked and found\n+         *  acyclic.\n+         *\/\n+        ACYCLIC_CONSTRUCTOR,\n+\n+        \/** Flag for class symbols is set and later re-set as a lock in\n+         *  Enter to detect cycles in the superclass\/superinterface\n+         *  relations.  Similarly for constructor call cycle detection in\n+         *  Attr.\n+         *\/\n+        LOCKED_CONSTRUCTOR,\n+        ;\n+\n+        final long mask;\n+        private MethodSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+    }\n+\n+    public enum VarSymbolFlags {\n+        \/**\n+         * Flag that marks an 'effectively final' local variable.\n+         *\/\n+        EFFECTIVELY_FINAL,\n+\n+        \/**\n+         * Flag to indicate the given ParamSymbol has a user-friendly name filled.\n+         *\/\n+        NAME_FILLED,\n+\n+        \/**\n+         * Flag to indicate the given variable is a match binding variable.\n+         *\/\n+        MATCH_BINDING,\n+\n+        \/**\n+         * A flag to indicate a match binding variable whose scope extends after the current statement.\n+         *\/\n+        MATCH_BINDING_TO_OUTER,\n+\n+        \/**\n+         * Flag to mark a record field that was not initialized in the compact constructor\n+         *\/\n+        UNINITIALIZED_FIELD,\n+\n+        \/**\n+         * Flag that marks a multi-catch parameter.\n+         *\/\n+        UNION,\n+        ;\n+\n+        final long mask;\n+        private VarSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+    }\n@@ -469,1 +514,0 @@\n-        BRIDGE(Flags.BRIDGE),\n@@ -473,2 +517,0 @@\n-        HASINIT(Flags.HASINIT),\n-        BLOCK(Flags.BLOCK),\n@@ -477,28 +519,0 @@\n-        NOOUTERTHIS(Flags.NOOUTERTHIS),\n-        EXISTS(Flags.EXISTS),\n-        COMPOUND(Flags.COMPOUND),\n-        CLASS_SEEN(Flags.CLASS_SEEN),\n-        SOURCE_SEEN(Flags.SOURCE_SEEN),\n-        LOCKED(Flags.LOCKED),\n-        UNATTRIBUTED(Flags.UNATTRIBUTED),\n-        ANONCONSTR(Flags.ANONCONSTR),\n-        ACYCLIC(Flags.ACYCLIC),\n-        PARAMETER(Flags.PARAMETER),\n-        VARARGS(Flags.VARARGS),\n-        ACYCLIC_ANN(Flags.ACYCLIC_ANN),\n-        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n-        HYPOTHETICAL(Flags.HYPOTHETICAL),\n-        PROPRIETARY(Flags.PROPRIETARY),\n-        UNION(Flags.UNION),\n-        EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),\n-        CLASH(Flags.CLASH),\n-        AUXILIARY(Flags.AUXILIARY),\n-        NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),\n-        BAD_OVERRIDE(Flags.BAD_OVERRIDE),\n-        SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),\n-        THROWS(Flags.THROWS),\n-        LAMBDA_METHOD(Flags.LAMBDA_METHOD),\n-        TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),\n-        MODULE(Flags.MODULE),\n-        AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),\n-        SYSTEM_MODULE(Flags.SYSTEM_MODULE),\n@@ -507,4 +521,0 @@\n-        HAS_RESOURCE(Flags.HAS_RESOURCE),\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n-        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n-        NAME_FILLED(Flags.NAME_FILLED),\n@@ -513,2 +523,10 @@\n-        MATCH_BINDING(Flags.MATCH_BINDING),\n-        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n+\/\/<<<<<<< HEAD\n+        BRIDGE(Flags.BRIDGE),\n+        PARAMETER(Flags.PARAMETER),\n+        VARARGS(Flags.VARARGS),\n+        MODULE(Flags.MODULE),\n+        ANONCONSTR(Flags.ANONCONSTR),\n+        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n+        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n+        COMPACT_RECORD_CONSTRUCTOR(Flags.COMPACT_RECORD_CONSTRUCTOR),\n+        BODY_ONLY_FINALIZE(Flags.BODY_ONLY_FINALIZE),\n@@ -516,1 +534,11 @@\n-        RECOVERABLE(Flags.RECOVERABLE),\n+        GENERATED_MEMBER(Flags.GENERATED_MEMBER),\n+        CLASH(Flags.CLASH),\n+        BLOCK(Flags.BLOCK),\n+        HASINIT(Flags.HASINIT),\n+        THROWS(Flags.THROWS),\n+\/\/=======\n+\/\/        MATCH_BINDING(Flags.MATCH_BINDING),\n+\/\/        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n+\/\/        RECORD(Flags.RECORD),\n+\/\/        RECOVERABLE(Flags.RECOVERABLE),\n+\/\/>>>>>>> master\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":267,"deletions":239,"binary":false,"changes":506,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-            t.hasTag(CLASS) && (t.tsym.flags() & COMPOUND) != 0)\n+            t.hasTag(CLASS) && t.tsym.isFlagSet(TypeSymbolFlags.COMPOUND))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Kinds.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.function.Function;\n@@ -42,0 +41,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -331,1 +331,1 @@\n-                            msym.flags_field |= Flags.SYSTEM_MODULE;\n+                            msym.setFlag(TypeSymbolFlags.SYSTEM_MODULE);\n@@ -372,1 +372,1 @@\n-                    msym.flags_field |= Flags.AUTOMATIC_MODULE;\n+                    msym.setFlag(TypeSymbolFlags.AUTOMATIC_MODULE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ModuleFinder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-        if (sym.name.length() == 0 && (sym.flags() & COMPOUND) != 0) {\n+        if (sym.name.length() == 0 && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -96,1 +97,0 @@\n-\n@@ -369,0 +369,13 @@\n+    public boolean isFlagSet(TypeSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSetNoComplete(TypeSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSet(MethodSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSet(VarSymbolFlags flag) {\n+        return false;\n+    }\n+\n@@ -437,0 +450,5 @@\n+    public boolean isFinalOrEffectivellyFinal() {\n+        return isFinal() ||\n+                this.isFlagSet(VarSymbolFlags.EFFECTIVELY_FINAL);\n+    }\n+\n@@ -503,1 +521,1 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & INTERFACE) == 0 && !this.isFlagSet(TypeSymbolFlags.NOOUTERTHIS);\n@@ -634,1 +652,1 @@\n-                if ((sup.flags() & COMPOUND) != 0)\n+                if (sup.isFlagSet(TypeSymbolFlags.COMPOUND))\n@@ -828,0 +846,16 @@\n+        public boolean isFlagSet(TypeSymbolFlags flag) {\n+            return (flags() & flag.mask) != 0;\n+        }\n+\n+        public boolean isFlagSetNoComplete(TypeSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(TypeSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(TypeSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -1211,1 +1245,1 @@\n-            return (flags_field & EXISTS) != 0;\n+            return this.isFlagSetNoComplete(TypeSymbolFlags.EXISTS);\n@@ -1695,0 +1729,12 @@\n+        public boolean isFlagSet(VarSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(VarSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(VarSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -1709,1 +1755,1 @@\n-            } else if ((flags & MATCH_BINDING) != 0) {\n+            } else if (this.isFlagSet(VarSymbolFlags.MATCH_BINDING)) {\n@@ -1847,2 +1893,2 @@\n-            if ((flags_field & NAME_FILLED) == 0) {\n-                flags_field |= NAME_FILLED;\n+            if (!this.isFlagSet(VarSymbolFlags.NAME_FILLED)) {\n+                this.setFlag(VarSymbolFlags.NAME_FILLED);\n@@ -1869,1 +1915,2 @@\n-            super(flags | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n+            super(flags | Flags.HASINIT, name, type, owner);\n+            this.setFlag(VarSymbolFlags.MATCH_BINDING);\n@@ -1881,1 +1928,1 @@\n-            flags_field |= Flags.MATCH_BINDING_TO_OUTER;\n+            this.setFlag(VarSymbolFlags.MATCH_BINDING_TO_OUTER);\n@@ -1885,1 +1932,1 @@\n-            return (flags_field & Flags.MATCH_BINDING_TO_OUTER) != 0;\n+            return this.isFlagSet(VarSymbolFlags.MATCH_BINDING_TO_OUTER);\n@@ -1918,0 +1965,12 @@\n+        public boolean isFlagSet(MethodSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(MethodSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(MethodSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -2146,1 +2205,1 @@\n-            return (flags() & LAMBDA_METHOD) == LAMBDA_METHOD;\n+            return this.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":70,"deletions":11,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -370,1 +370,2 @@\n-        sym.flags_field = PUBLIC|ACYCLIC|ANNOTATION|INTERFACE;\n+        sym.flags_field = PUBLIC|ANNOTATION|INTERFACE;\n+        sym.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -451,1 +452,2 @@\n-        errSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.any, null, rootPackage);\n+        errSymbol = new ClassSymbol(PUBLIC|STATIC, names.any, null, rootPackage);\n+        errSymbol.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -454,1 +456,2 @@\n-        unknownSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.fromString(\"<any?>\"), null, rootPackage);\n+        unknownSymbol = new ClassSymbol(PUBLIC|STATIC, names.fromString(\"<any?>\"), null, rootPackage);\n+        unknownSymbol.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -473,1 +476,2 @@\n-        arrayClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Array, noSymbol);\n+        arrayClass = new ClassSymbol(PUBLIC, names.Array, noSymbol);\n+        arrayClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -476,1 +480,2 @@\n-        boundClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Bound, noSymbol);\n+        boundClass = new ClassSymbol(PUBLIC, names.Bound, noSymbol);\n+        boundClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -480,1 +485,2 @@\n-        methodClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Method, noSymbol);\n+        methodClass = new ClassSymbol(PUBLIC, names.Method, noSymbol);\n+        methodClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -484,1 +490,2 @@\n-        predefClass = new ClassSymbol(PUBLIC|ACYCLIC, names.empty, rootPackage);\n+        predefClass = new ClassSymbol(PUBLIC, names.empty, rootPackage);\n+        predefClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -550,1 +557,1 @@\n-            new MethodSymbol(PROTECTED|FINAL|HYPOTHETICAL,\n+            new MethodSymbol(PROTECTED|FINAL,\n@@ -555,0 +562,1 @@\n+        enumFinalFinalize.setFlag(MethodSymbolFlags.HYPOTHETICAL);\n@@ -802,1 +810,1 @@\n-        unnamedPackage.flags_field |= EXISTS;\n+        unnamedPackage.setFlag(TypeSymbolFlags.EXISTS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1051,1 +1051,1 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                if (sym.name.isEmpty() && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -1248,1 +1248,1 @@\n-            Assert.check((csym.flags() & COMPOUND) != 0);\n+            Assert.check(csym.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -2386,1 +2386,2 @@\n-            this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);\n+            this(new ClassSymbol(PUBLIC|STATIC, name, null, container), originalType);\n+            tsym.setFlag(TypeSymbolFlags.ACYCLIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2492,1 +2492,1 @@\n-            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,\n+            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC,\n@@ -2498,0 +2498,2 @@\n+        bc.setFlag(TypeSymbolFlags.COMPOUND);\n+        bc.setFlag(TypeSymbolFlags.ACYCLIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -808,1 +808,1 @@\n-            a.tsym.flags_field |= UNATTRIBUTED;\n+            a.tsym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -820,1 +820,1 @@\n-            a.tsym.flags_field &= ~UNATTRIBUTED;\n+            a.tsym.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -972,1 +972,1 @@\n-                    c.flags_field |= NOOUTERTHIS;\n+                    c.setFlag(TypeSymbolFlags.NOOUTERTHIS);\n@@ -1813,1 +1813,2 @@\n-                        c.param.sym.flags_field |= FINAL | UNION;\n+                        c.param.sym.flags_field |= FINAL;\n+                        c.param.sym.setFlag(VarSymbolFlags.UNION);\n@@ -4065,1 +4066,1 @@\n-                if ((symEnv.enclClass.sym.flags() & NOOUTERTHIS) != 0)\n+                if (symEnv.enclClass.sym.isFlagSet(TypeSymbolFlags.NOOUTERTHIS))\n@@ -4936,1 +4937,1 @@\n-            Assert.check((c.flags() & COMPOUND) != 0);\n+            Assert.check(c.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -4941,1 +4942,1 @@\n-            c.flags_field |= UNATTRIBUTED;\n+            c.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -5077,1 +5078,1 @@\n-        if ((c.flags_field & Flags.COMPOUND) == 0) {\n+        if (!c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND)) {\n@@ -5090,2 +5091,2 @@\n-        if ((c.flags_field & UNATTRIBUTED) != 0) {\n-            c.flags_field &= ~UNATTRIBUTED;\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n+            c.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -5210,1 +5211,2 @@\n-                    ((c.flags_field & (Flags.ENUM|Flags.COMPOUND)) == 0))\n+                    (c.flags_field & Flags.ENUM) == 0 &&\n+                    !c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND))\n@@ -5216,1 +5218,2 @@\n-                    ((c.flags_field & (Flags.ENUM | Flags.COMPOUND)) == 0)) {\n+                    (c.flags_field & Flags.ENUM) == 0 &&\n+                    !c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -209,1 +210,1 @@\n-        if ((sym.flags_field & Flags.RECOVERABLE) != 0 && env.info.attributionMode.recover()) {\n+        if (sym.isFlagSet(TypeSymbolFlags.RECOVERABLE) && env.info.attributionMode.recover()) {\n@@ -240,1 +241,1 @@\n-                    errSymbol.flags_field |= Flags.RECOVERABLE;\n+                    errSymbol.setFlag(TypeSymbolFlags.RECOVERABLE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-                    (sym.flags() & HYPOTHETICAL) != 0;\n+                        sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL);\n@@ -1035,1 +1035,1 @@\n-            } else if ((sym.flags() & (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {\n+            } else if ((sym.flags() & VARARGS) == VARARGS && !sym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n@@ -1769,1 +1769,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1781,1 +1781,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1798,1 +1798,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1821,1 +1821,1 @@\n-                m.flags_field |= BAD_OVERRIDE;\n+                m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1825,1 +1825,1 @@\n-                m.flags_field |= BAD_OVERRIDE;\n+                m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1841,1 +1841,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1959,1 +1959,1 @@\n-        if ((site.tsym.flags() & COMPOUND) != 0) {\n+        if (site.tsym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -2141,1 +2141,1 @@\n-            (s.flags() & BAD_OVERRIDE) == 0;\n+            !s.isFlagSet(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -2244,1 +2244,1 @@\n-            tree.sym.flags_field |= ACYCLIC;\n+            tree.sym.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2311,1 +2311,1 @@\n-            if ((c.flags_field & ACYCLIC) != 0)\n+            if (c.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC))\n@@ -2364,1 +2364,1 @@\n-        if  (t.hasTag(TYPEVAR) && (t.tsym.flags() & UNATTRIBUTED) != 0)\n+        if  (t.hasTag(TYPEVAR) && t.tsym.isFlagSet(TypeSymbolFlags.UNATTRIBUTED))\n@@ -2388,2 +2388,2 @@\n-        Symbol c = t.tsym;\n-        if ((c.flags_field & ACYCLIC) != 0) return true;\n+        TypeSymbol c = t.tsym;\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC)) return true;\n@@ -2391,1 +2391,1 @@\n-        if ((c.flags_field & LOCKED) != 0) {\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.LOCKED)) {\n@@ -2395,1 +2395,1 @@\n-                c.flags_field |= LOCKED;\n+                c.setFlag(TypeSymbolFlags.LOCKED);\n@@ -2410,1 +2410,1 @@\n-                c.flags_field &= ~LOCKED;\n+                c.clearFlag(TypeSymbolFlags.LOCKED);\n@@ -2414,2 +2414,2 @@\n-            complete = ((c.flags_field & UNATTRIBUTED) == 0) && c.isCompleted();\n-        if (complete) c.flags_field |= ACYCLIC;\n+            complete = !c.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED) && c.isCompleted();\n+        if (complete) c.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2428,1 +2428,1 @@\n-        c.flags_field |= ACYCLIC;\n+        c.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2677,2 +2677,2 @@\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n+                !msym1.isFlagSet(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS) &&\n+                !msym2.isFlagSet(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS)) {\n@@ -2712,2 +2712,2 @@\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n+                msym1.setFlag(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS);\n+                msym2.setFlag(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS);\n@@ -3536,1 +3536,1 @@\n-        if ((s.flags() & PROPRIETARY) != 0) {\n+        if (s.isFlagSet(TypeSymbolFlags.PROPRIETARY)) {\n@@ -3544,1 +3544,1 @@\n-        if (profile != Profile.DEFAULT && (s.flags() & NOT_IN_PROFILE) != 0) {\n+        if (profile != Profile.DEFAULT && s.isFlagSet(TypeSymbolFlags.NOT_IN_PROFILE)) {\n@@ -3581,1 +3581,1 @@\n-        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        Assert.check(!tree.sym.isFlagSetNoComplete(TypeSymbolFlags.LOCKED));\n@@ -3583,1 +3583,1 @@\n-            tree.sym.flags_field |= LOCKED;\n+            tree.sym.setFlag(TypeSymbolFlags.LOCKED);\n@@ -3590,2 +3590,2 @@\n-            tree.sym.flags_field &= ~LOCKED;\n-            tree.sym.flags_field |= ACYCLIC_ANN;\n+            tree.sym.clearFlag(TypeSymbolFlags.LOCKED);\n+            tree.sym.setFlag(TypeSymbolFlags.ACYCLIC_ANN);\n@@ -3596,1 +3596,1 @@\n-        if ((tsym.flags_field & ACYCLIC_ANN) != 0)\n+        if (tsym.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC_ANN))\n@@ -3598,1 +3598,1 @@\n-        if ((tsym.flags_field & LOCKED) != 0) {\n+        if (tsym.isFlagSetNoComplete(TypeSymbolFlags.LOCKED)) {\n@@ -3603,1 +3603,1 @@\n-            tsym.flags_field |= LOCKED;\n+            tsym.setFlag(TypeSymbolFlags.LOCKED);\n@@ -3610,2 +3610,2 @@\n-            tsym.flags_field &= ~LOCKED;\n-            tsym.flags_field |= ACYCLIC_ANN;\n+            tsym.clearFlag(TypeSymbolFlags.LOCKED);\n+            tsym.setFlag(TypeSymbolFlags.ACYCLIC_ANN);\n@@ -3637,1 +3637,1 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        Map<MethodSymbol,MethodSymbol> callMap = new HashMap<>();\n@@ -3644,2 +3644,3 @@\n-            if (TreeInfo.name(app.meth) == names._this) {\n-                callMap.put(meth.sym, TreeInfo.symbol(app.meth));\n+            Symbol invConstr = TreeInfo.symbol(app.meth);\n+            if (TreeInfo.name(app.meth) == names._this && invConstr != null && invConstr.kind == MTH) {\n+                callMap.put(meth.sym, (MethodSymbol) invConstr);\n@@ -3647,1 +3648,1 @@\n-                meth.sym.flags_field |= ACYCLIC;\n+                meth.sym.setFlag(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR);\n@@ -3652,1 +3653,1 @@\n-        Symbol[] ctors = new Symbol[0];\n+        MethodSymbol[] ctors = new MethodSymbol[0];\n@@ -3654,1 +3655,1 @@\n-        for (Symbol caller : ctors) {\n+        for (MethodSymbol caller : ctors) {\n@@ -3662,4 +3663,4 @@\n-    private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,\n-                                        Map<Symbol,Symbol> callMap) {\n-        if (ctor != null && (ctor.flags_field & ACYCLIC) == 0) {\n-            if ((ctor.flags_field & LOCKED) != 0) {\n+    private void checkCyclicConstructor(JCClassDecl tree, MethodSymbol ctor,\n+                                        Map<MethodSymbol,MethodSymbol> callMap) {\n+        if (ctor != null && !ctor.isFlagSet(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR)) {\n+            if (ctor.isFlagSet(MethodSymbolFlags.LOCKED_CONSTRUCTOR)) {\n@@ -3669,1 +3670,1 @@\n-                ctor.flags_field |= LOCKED;\n+                ctor.setFlag(MethodSymbolFlags.LOCKED_CONSTRUCTOR);\n@@ -3671,1 +3672,1 @@\n-                ctor.flags_field &= ~LOCKED;\n+                ctor.clearFlag(MethodSymbolFlags.LOCKED_CONSTRUCTOR);\n@@ -3673,1 +3674,1 @@\n-            ctor.flags_field |= ACYCLIC;\n+            ctor.setFlag(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR);\n@@ -3733,3 +3734,3 @@\n-                } else if ((sym.flags() & MATCH_BINDING) != 0 &&\n-                           (byName.flags() & MATCH_BINDING) != 0 &&\n-                           (byName.flags() & MATCH_BINDING_TO_OUTER) == 0) {\n+                } else if (sym.isFlagSet(VarSymbolFlags.MATCH_BINDING) &&\n+                           byName.isFlagSet(VarSymbolFlags.MATCH_BINDING) &&\n+                           !byName.isFlagSet(VarSymbolFlags.MATCH_BINDING_TO_OUTER)) {\n@@ -3848,1 +3849,1 @@\n-            (c.flags() & AUXILIARY) != 0 &&\n+            c.isFlagSet(TypeSymbolFlags.AUXILIARY) &&\n@@ -4056,1 +4057,1 @@\n-            || (check.sym.flags() & COMPOUND) != 0) {\n+            || check.sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -4215,1 +4216,1 @@\n-                    if ((current.flags() & Flags.AUTOMATIC_MODULE) != 0)\n+                    if (current.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE))\n@@ -4239,1 +4240,1 @@\n-            ((packge.flags() & Flags.HAS_RESOURCE) == 0)) {\n+            !packge.isFlagSet(TypeSymbolFlags.HAS_RESOURCE)) {\n@@ -4248,1 +4249,1 @@\n-        if ((rd.module.flags() & Flags.AUTOMATIC_MODULE) != 0) {\n+        if (rd.module.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-                    q.flags_field |= EXISTS;\n+                    ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n@@ -402,1 +402,1 @@\n-                q.flags_field |= EXISTS;\n+                ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1368,1 +1368,1 @@\n-                (sym.flags() & (FINAL | EFFECTIVELY_FINAL)) != 0 &&\n+                sym.isFinalOrEffectivellyFinal() &&\n@@ -1800,1 +1800,1 @@\n-                sym.flags_field |= EFFECTIVELY_FINAL;\n+                sym.setFlag(VarSymbolFlags.EFFECTIVELY_FINAL);\n@@ -1813,1 +1813,1 @@\n-                if ((sym.flags() & EFFECTIVELY_FINAL) != 0) {\n+                if (sym.isFlagSet(VarSymbolFlags.EFFECTIVELY_FINAL)) {\n@@ -1818,1 +1818,1 @@\n-                        sym.flags_field &= ~EFFECTIVELY_FINAL;\n+                        sym.clearFlag(VarSymbolFlags.EFFECTIVELY_FINAL);\n@@ -1825,1 +1825,1 @@\n-                        if ((sym.flags() & UNION) != 0) { \/\/multi-catch parameter\n+                        if (sym.isFlagSet(VarSymbolFlags.UNION)) { \/\/multi-catch parameter\n@@ -2071,1 +2071,1 @@\n-                if ((tree.sym.flags() & (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {\n+                if ((tree.sym.flags() & SYNTHETIC) == SYNTHETIC && !tree.sym.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD)) {\n@@ -2123,4 +2123,4 @@\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n+                                            \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                             *  in the compact constructor\n+                                             *\/\n+                                            var.setFlag(VarSymbolFlags.UNINITIALIZED_FIELD);\n@@ -2858,1 +2858,1 @@\n-                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0) {\n+                        if (!sym.isFinalOrEffectivellyFinal()) {\n@@ -2963,1 +2963,1 @@\n-                    if (var != null && (var.flags() & (FINAL | EFFECTIVELY_FINAL)) == 0) {\n+                    if (var != null && !var.isFinalOrEffectivellyFinal()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2199,1 +2199,1 @@\n-                translatedSym.flags_field = SYNTHETIC | LAMBDA_METHOD |\n+                translatedSym.flags_field = SYNTHETIC |\n@@ -2205,0 +2205,2 @@\n+                translatedSym.setFlag(MethodSymbolFlags.LAMBDA_METHOD);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2749,1 +2749,1 @@\n-                if ((field.flags_field & Flags.UNINITIALIZED_FIELD) != 0) {\n+                if (field.isFlagSet(VarSymbolFlags.UNINITIALIZED_FIELD)) {\n@@ -2758,1 +2758,1 @@\n-                    field.flags_field &= ~Flags.UNINITIALIZED_FIELD;\n+                    field.clearFlag(VarSymbolFlags.UNINITIALIZED_FIELD);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-            m.flags_field |= SIGNATURE_POLYMORPHIC;\n+            m.setFlag(MethodSymbolFlags.SIGNATURE_POLYMORPHIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-import static com.sun.tools.javac.code.Flags.UNATTRIBUTED;\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -376,1 +376,1 @@\n-                        patchesAutomaticModules |= (msym.flags_field & Flags.AUTOMATIC_MODULE) != 0;\n+                        patchesAutomaticModules |= msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE);\n@@ -465,1 +465,1 @@\n-                                if ((defaultModule.flags_field & Flags.AUTOMATIC_MODULE) == 0) {\n+                                if (!defaultModule.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -634,1 +634,1 @@\n-            } else if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {\n+            } else if (msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -711,1 +711,1 @@\n-            Set<RequiresFlag> flags = (ms.flags_field & Flags.AUTOMATIC_MODULE) != 0 ?\n+            Set<RequiresFlag> flags = ms.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE) ?\n@@ -731,1 +731,1 @@\n-                msym.flags_field |= UNATTRIBUTED;\n+                msym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -744,1 +744,1 @@\n-                    msym.flags_field &= ~UNATTRIBUTED;\n+                    msym.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -1254,1 +1254,1 @@\n-        Predicate<ModuleSymbol> systemModulePred = sym -> (sym.flags() & Flags.SYSTEM_MODULE) != 0;\n+        Predicate<ModuleSymbol> systemModulePred = sym -> sym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE);\n@@ -1363,1 +1363,1 @@\n-                m -> (m.flags_field & Flags.AUTOMATIC_MODULE) != 0;\n+                m -> m.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE);\n@@ -1401,1 +1401,1 @@\n-                if (!result.add(current) || current == syms.unnamedModule || ((current.flags_field & Flags.AUTOMATIC_MODULE) != 0))\n+                if (!result.add(current) || current == syms.unnamedModule || current.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE))\n@@ -1466,1 +1466,1 @@\n-        if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {\n+        if (msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -1489,1 +1489,1 @@\n-                    Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);\n+                    Assert.check(!msym.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE));\n@@ -1651,1 +1651,1 @@\n-            if (!allowAccessIntoSystem && (msym.flags() & Flags.SYSTEM_MODULE) != 0) {\n+            if (!allowAccessIntoSystem && msym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE)) {\n@@ -1731,1 +1731,1 @@\n-            if (!allowAccessIntoSystem && (msym.flags() & Flags.SYSTEM_MODULE) != 0) {\n+            if (!allowAccessIntoSystem && msym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE)) {\n@@ -1770,1 +1770,1 @@\n-                if ((current.flags() & Flags.AUTOMATIC_MODULE) != 0)\n+                if (current.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2751,1 +2751,1 @@\n-                    if ((msym.flags() & SIGNATURE_POLYMORPHIC) != 0) {\n+                    if (msym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n@@ -2802,1 +2802,1 @@\n-        long flags = ABSTRACT | HYPOTHETICAL |\n+        long flags = ABSTRACT |\n@@ -2804,1 +2804,1 @@\n-        Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {\n+        MethodSymbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {\n@@ -2810,0 +2810,1 @@\n+        msym.setFlag(MethodSymbolFlags.HYPOTHETICAL);\n@@ -3128,1 +3129,1 @@\n-            if ((msym.flags() & SIGNATURE_POLYMORPHIC) != 0) {\n+            if (msym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags.VarSymbolFlags;\n@@ -266,1 +267,1 @@\n-        if ((tree.sym.flags() & Flags.MATCH_BINDING) != 0) {\n+        if (tree.sym.isFlagSet(VarSymbolFlags.MATCH_BINDING)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -912,1 +912,1 @@\n-        if (myEnv == null || (c.flags_field & TYPE_TRANSLATED) != 0) {\n+        if (myEnv == null || c.isFlagSetNoComplete(TypeSymbolFlags.TYPE_TRANSLATED)) {\n@@ -915,1 +915,1 @@\n-        c.flags_field |= TYPE_TRANSLATED;\n+        c.setFlag(TypeSymbolFlags.TYPE_TRANSLATED);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-            Assert.check((sym.flags() & Flags.COMPOUND) == 0);\n+            Assert.check(!sym.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -197,0 +197,2 @@\n+            ClassSymbol csym = (ClassSymbol) sym;\n+\n@@ -198,1 +200,1 @@\n-            sym.flags_field |= UNATTRIBUTED;\n+            csym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -204,1 +206,1 @@\n-                queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));\n+                queue = completeClass.completeEnvs(List.of(typeEnvs.get(csym)));\n@@ -902,1 +904,1 @@\n-                sym.flags_field |= AUXILIARY;\n+                sym.setFlag(TypeSymbolFlags.AUXILIARY);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-                        c.flags_field |= AUXILIARY;\n+                        c.setFlag(TypeSymbolFlags.AUXILIARY);\n@@ -1427,4 +1427,6 @@\n-            if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())\n-                sym.flags_field |= PROPRIETARY;\n-            else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {\n-                if (profile != Profile.DEFAULT) {\n+            if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName()) {\n+                if (sym instanceof TypeSymbol) {\n+                    ((TypeSymbol) sym).setFlag(TypeSymbolFlags.PROPRIETARY);\n+                }\n+            } else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {\n+                if (profile != Profile.DEFAULT && sym instanceof TypeSymbol) {\n@@ -1435,1 +1437,1 @@\n-                                sym.flags_field |= NOT_IN_PROFILE;\n+                                ((TypeSymbol) sym).setFlag(TypeSymbolFlags.NOT_IN_PROFILE);\n@@ -2242,1 +2244,1 @@\n-            m.flags_field |= SIGNATURE_POLYMORPHIC;\n+            m.setFlag(MethodSymbolFlags.SIGNATURE_POLYMORPHIC);\n@@ -2393,1 +2395,1 @@\n-        long flags = PARAMETER;\n+        boolean nameFilled = false;\n@@ -2398,1 +2400,1 @@\n-            flags |= NAME_FILLED;\n+            nameFilled = true;\n@@ -2409,1 +2411,5 @@\n-        return new ParamSymbol(flags, argName, t, owner);\n+        ParamSymbol psym = new ParamSymbol(PARAMETER, argName, t, owner);\n+        if (nameFilled) {\n+            psym.setFlag(VarSymbolFlags.NAME_FILLED);\n+        }\n+        return psym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1474,1 +1474,1 @@\n-            if (sym.kind == MTH && (sym.flags() & HYPOTHETICAL) == 0)\n+            if (sym.kind == MTH && !sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL))\n@@ -1526,1 +1526,1 @@\n-        Assert.check((c.flags() & COMPOUND) == 0);\n+        Assert.check(!c.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -1567,1 +1567,1 @@\n-            case MTH: if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n+            case MTH: if (!sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL)) methodsCount++;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags.MethodSymbolFlags;\n@@ -2189,1 +2190,1 @@\n-                ((var.sym.owner.flags() & Flags.LAMBDA_METHOD) == 0 ||\n+                (!var.sym.owner.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -593,1 +594,1 @@\n-            return (msym.flags() & Flags.AUTOMATIC_MODULE) != 0;\n+            return msym.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Extern.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static com.sun.tools.javac.code.Flags.COMPOUND;\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -136,1 +136,1 @@\n-        if (sym.name.length() == 0 && (sym.flags() & COMPOUND) != 0) {\n+        if (sym.name.length() == 0 && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TypePrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.code:+open\n@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -63,0 +64,1 @@\n+import java.lang.reflect.Field;\n@@ -216,1 +218,2 @@\n-            flags &= ~(Flags.CLASS_SEEN | Flags.SOURCE_SEEN);\n+            flags &= ~(mask(TypeSymbolFlags.CLASS_SEEN) |\n+                       mask(TypeSymbolFlags.SOURCE_SEEN));\n@@ -229,0 +232,9 @@\n+    private static long mask(TypeSymbolFlags flag) {\n+        try {\n+            Field mask = TypeSymbolFlags.class.getDeclaredField(\"mask\");\n+            mask.setAccessible(true);\n+            return mask.getLong(flag);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex.getMessage(), ex);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/completionfailure\/NoAbortForBadClassFile.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -370,1 +371,2 @@\n-            ClassType ct = Class(Flags.COMPOUND);\n+            ClassType ct = Class();\n+            ct.tsym.setFlag(TypeSymbolFlags.COMPOUND);\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}