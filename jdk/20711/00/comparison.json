{"files":[{"patch":"@@ -73,0 +73,3 @@\n+doccheck = \\\n+    jdk\/javadoc\/doccheck\n+\n@@ -94,1 +97,2 @@\n-    :langtools_slow\n+    :langtools_slow \\\n+    :doccheck\n","filename":"test\/langtools\/TEST.groups","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import tools.FileChecker;\n+import tools.FileProcessor;\n+import tools.HtmlFileChecker;\n+import tools.checkers.BadCharacterChecker;\n+import tools.checkers.DocTypeChecker;\n+import tools.checkers.LinkChecker;\n+import tools.checkers.TidyChecker;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+\n+\/**\n+ * Takes a directory path under the generated documentation directory as input\n+ * and runs different {@link FileChecker file checkers} on it\n+ *\/\n+public class DocCheck {\n+    private static final Path ROOT_PATH = Path.of(System.getProperty(\"test.jdk\"));\n+    private List<Path> files;\n+\n+    @Before\n+    public void setUp() {\n+        Path root = Path.of(ROOT_PATH.getParent() + File.separator + \"docs\" + File.separator + System.getProperty(\"doccheck.dir\"));\n+        var fileTester = new FileProcessor();\n+        fileTester.processFiles(root);\n+        files = fileTester.getFiles();\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        ExecutorService executorService = Executors.newFixedThreadPool(4);\n+        List<Throwable> exceptions = new ArrayList<>();\n+\n+        try (\n+                TidyChecker tidy = new TidyChecker();\n+                BadCharacterChecker badChars = new BadCharacterChecker();\n+                HtmlFileChecker docChecker = new HtmlFileChecker(new DocTypeChecker());\n+                HtmlFileChecker htmlChecker = new HtmlFileChecker(new LinkChecker());\n+        ) {\n+            List<Future<?>> futures = new ArrayList<>();\n+            futures.add(executorService.submit(() -> {\n+                try {\n+                    tidy.checkFiles(files);\n+                } catch (RuntimeException e) {\n+                    synchronized (exceptions) {\n+                        exceptions.add(e);\n+                    }\n+                }\n+            }));\n+\n+            futures.add(executorService.submit(() -> {\n+                try {\n+                    docChecker.checkFiles(files);\n+                } catch (RuntimeException e) {\n+                    synchronized (exceptions) {\n+                        exceptions.add(e);\n+                    }\n+                }\n+            }));\n+\n+            futures.add(executorService.submit(() -> {\n+                try {\n+                    badChars.checkFiles(files);\n+                } catch (RuntimeException e) {\n+                    synchronized (exceptions) {\n+                        exceptions.add(e);\n+                    }\n+                }\n+            }));\n+\n+            futures.add(executorService.submit(() -> {\n+                try {\n+                    htmlChecker.checkFiles(files);\n+                } catch (RuntimeException e) {\n+                    synchronized (exceptions) {\n+                        exceptions.add(e);\n+                    }\n+                }\n+            }));\n+\n+            for (Future<?> future : futures) {\n+                try {\n+                    future.get();\n+                } catch (InterruptedException | ExecutionException e) {\n+                    synchronized (exceptions) {\n+                        exceptions.add(e);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Exception(\"Interrupted: \" + e);\n+        } finally {\n+            executorService.shutdown();\n+        }\n+\n+        if (!exceptions.isEmpty()) {\n+            throw new Exception(\"One or more HTML checkers failed: \" + exceptions);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/DocCheck.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337109\n+ * @summary Running Doccheck on generated HTML\n+ * @library \/test\/langtools\/jdk\/javadoc\/doccheck\/\n+ * @run junit\/othervm  -Ddoccheck.dir=jdk.javadoc DocCheck\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/modules\/DocCheck__jdk_javadoc.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.io.Closeable;\n+\n+\/**\n+ * Base class for {@link FileChecker file checkers} and\n+ *\/\n+public interface Checker extends Closeable {\n+\n+    \/**\n+     * Writes a report at the end of a run, to summarize the results of the\n+     * checking done by this checker.\n+     *\n+     *\/\n+    abstract void report();\n+\n+    abstract boolean isOK();\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/Checker.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public interface FileChecker extends Checker {\n+    void checkFiles(List<Path> files);\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/FileChecker.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FileProcessor {\n+    private final List<Path> files;\n+\n+    public FileProcessor() {\n+        files = new ArrayList<>();\n+    }\n+\n+    public List<Path> getFiles() {\n+        return files;\n+    }\n+\n+    public void processFiles(Path directory) {\n+        try {\n+            Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    if (file.toString().endsWith(\".html\"))\n+                        files.add(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/FileProcessor.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+\/**\n+ * Base class for HTML checkers.\n+ *\n+ * For details on HTML syntax and the terms used in this API, see\n+ * W3C <a href=\"https:\/\/www.w3.org\/TR\/html5\/syntax.html#syntax\">The HTML syntax<\/a>.\n+ *\/\n+public interface HtmlChecker extends Checker {\n+    \/**\n+     * Starts checking a new file,\n+     *\n+     * The file becomes the <em>current<\/em> file until {@link #endFile endFile}\n+     * is called.\n+     *\n+     * @param path the file.\n+     *\/\n+    void startFile(Path path);\n+\n+    \/**\n+     * Ends checking the current file.\n+     *\/\n+    void endFile();\n+\n+    \/**\n+     * Checks the content of a {@code <?xml ... ?>} declaration in the\n+     * current file.\n+     *\n+     * @param line  the line number on which the declaration was found\n+     * @param attrs the content of the declaration\n+     *\/\n+    void xml(int line, Map<String, String> attrs);\n+\n+    \/**\n+     * Checks the content of a {@code <!doctype ... >} declaration in the\n+     * current file.\n+     *\n+     * @param line    the line number on which the declaration was found\n+     * @param docType the content of the declaration\n+     *\/\n+    void docType(int line, String docType);\n+\n+    \/**\n+     * Checks the start of an HTML tag in the current file.\n+     *\n+     * @param line        the line number on which the start tag for an element was found\n+     * @param name        the name of the tag\n+     * @param attrs       the attributes of the tag\n+     * @param selfClosing whether or not the tag is self-closing\n+     *\/\n+    void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing);\n+\n+    \/**\n+     * Checks the end of an HTML tag in the current file.\n+     *\n+     * @param line the line number on which the end tag for an element was found\n+     * @param name the name of the tag\n+     *\/\n+    void endElement(int line, String name);\n+\n+    \/**\n+     * Checks the content appearing in between HTML tags.\n+     *\n+     * @param line    the line number on which the content was found\n+     * @param content the content\n+     *\/\n+    default void content(int line, String content) {\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/HtmlChecker.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Reads an HTML file, and calls a series of{@link HtmlChecker HTML checkers}\n+ * for the HTML constructs found therein.\n+ *\/\n+public class HtmlFileChecker implements FileChecker {\n+    private final CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n+            .onMalformedInput(CodingErrorAction.IGNORE)\n+            .onUnmappableCharacter(CodingErrorAction.IGNORE);\n+\n+    private final Log log;\n+    private final HtmlChecker htmlChecker;\n+    private Path path;\n+    private BufferedReader in;\n+    private int ch;\n+    private int lineNumber;\n+    private boolean inScript;\n+    private boolean xml;\n+    public HtmlFileChecker(HtmlChecker htmlChecker) {\n+        this.log = new Log();\n+        this.htmlChecker = htmlChecker;\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> files) {\n+        for (Path file : files) {\n+            read(file);\n+        }\n+    }\n+\n+    @Override\n+    public void report() {\n+        System.err.println(log);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+\/\/        report();\n+        htmlChecker.close();\n+    }\n+\n+    private void read(Path path) {\n+        try (BufferedReader r = new BufferedReader(\n+                new InputStreamReader(Files.newInputStream(path), decoder))) {\n+            this.path = path;\n+            this.in = r;\n+            StringBuilder content = new StringBuilder();\n+\n+            startFile(path);\n+            try {\n+                lineNumber = 1;\n+                xml = false;\n+                nextChar();\n+\n+                while (ch != -1) {\n+                    switch (ch) {\n+\n+                        case '<':\n+                            content(content.toString());\n+                            content.setLength(0);\n+                            html();\n+                            break;\n+\n+                        default:\n+                            content.append((char) ch);\n+                            if (ch == '\\n') {\n+                                content(content.toString());\n+                                content.setLength(0);\n+                            }\n+                            nextChar();\n+                    }\n+                }\n+            } finally {\n+                endFile();\n+            }\n+        } catch (IOException e) {\n+            log.log(path, lineNumber, e);\n+        } catch (Throwable t) {\n+            log.log(path, lineNumber, t);\n+            log.log(String.valueOf(t));\n+        }\n+    }\n+\n+    private void startFile(Path path) {\n+        htmlChecker.startFile(path);\n+    }\n+\n+    private void endFile() {\n+        htmlChecker.endFile();\n+    }\n+\n+    private void docType(String s) {\n+        htmlChecker.docType(lineNumber, s);\n+    }\n+\n+    private void startElement(String name, Map<String, String> attrs, boolean selfClosing) {\n+        htmlChecker.startElement(lineNumber, name, attrs, selfClosing);\n+    }\n+\n+    private void endElement(String name) {\n+        htmlChecker.endElement(lineNumber, name);\n+    }\n+\n+    private void content(String s) {\n+        htmlChecker.content(lineNumber, s);\n+    }\n+\n+    private void nextChar() throws IOException {\n+        ch = in.read();\n+        if (ch == '\\n')\n+            lineNumber++;\n+    }\n+\n+    \/**\n+     * Read the start or end of an HTML tag, or an HTML comment\n+     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     *\n+     * @throws IOException if there is a problem reading the file\n+     *\/\n+    protected void html() throws IOException {\n+        nextChar();\n+        if (isIdentifierStart((char) ch)) {\n+            String name = readIdentifier().toLowerCase(Locale.US);\n+            Map<String, String> attrs = htmlAttrs();\n+            if (attrs != null) {\n+                boolean selfClosing = false;\n+                if (ch == '\/') {\n+                    nextChar();\n+                    selfClosing = true;\n+                }\n+                if (ch == '>') {\n+                    nextChar();\n+                    startElement(name, attrs, selfClosing);\n+                    if (name.equals(\"script\")) {\n+                        inScript = true;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '\/') {\n+            nextChar();\n+            if (isIdentifierStart((char) ch)) {\n+                String name = readIdentifier().toLowerCase(Locale.US);\n+                skipWhitespace();\n+                if (ch == '>') {\n+                    nextChar();\n+                    endElement(name);\n+                    if (name.equals(\"script\")) {\n+                        inScript = false;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '!') {\n+            nextChar();\n+            if (ch == '-') {\n+                nextChar();\n+                if (ch == '-') {\n+                    nextChar();\n+                    while (ch != -1) {\n+                        int dash = 0;\n+                        while (ch == '-') {\n+                            dash++;\n+                            nextChar();\n+                        }\n+                        \/\/ Strictly speaking, a comment should not contain \"--\"\n+                        \/\/ so dash > 2 is an error, dash == 2 implies ch == '>'\n+                        \/\/ See http:\/\/www.w3.org\/TR\/html-markup\/syntax.html#syntax-comments\n+                        \/\/ for more details.\n+                        if (dash >= 2 && ch == '>') {\n+                            nextChar();\n+                            return;\n+                        }\n+\n+                        nextChar();\n+                    }\n+                }\n+            } else if (ch == '[') {\n+                nextChar();\n+                if (ch == 'C') {\n+                    nextChar();\n+                    if (ch == 'D') {\n+                        nextChar();\n+                        if (ch == 'A') {\n+                            nextChar();\n+                            if (ch == 'T') {\n+                                nextChar();\n+                                if (ch == 'A') {\n+                                    nextChar();\n+                                    if (ch == '[') {\n+                                        while (true) {\n+                                            nextChar();\n+                                            if (ch == ']') {\n+                                                nextChar();\n+                                                if (ch == ']') {\n+                                                    nextChar();\n+                                                    if (ch == '>') {\n+                                                        nextChar();\n+                                                        return;\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                StringBuilder sb = new StringBuilder();\n+                while (ch != -1 && ch != '>') {\n+                    sb.append((char) ch);\n+                    nextChar();\n+                }\n+                Pattern p = Pattern.compile(\"(?is)doctype\\\\s+html\\\\s?.*\");\n+                String s = sb.toString();\n+                if (p.matcher(s).matches()) {\n+                    xml = s.contains(\"XHTML\");\n+                    docType(s);\n+                    return;\n+                }\n+            }\n+        } else if (ch == '?') {\n+            nextChar();\n+            if (ch == 'x') {\n+                nextChar();\n+                if (ch == 'm') {\n+                    nextChar();\n+                    if (ch == 'l') {\n+                        \/\/Map<String, String> attrs = htmlAttrs();\n+                        if (ch == '?') {\n+                            nextChar();\n+                            if (ch == '>') {\n+                                nextChar();\n+                                xml = true;\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        if (!inScript) {\n+            log.log(path, lineNumber, \"bad html\");\n+        }\n+    }\n+\n+    \/**\n+     * Read a series of HTML attributes, terminated by {@literal > }.\n+     * Each attribute is of the form {@literal identifier[=value] }.\n+     * \"value\" may be unquoted, single-quoted, or double-quoted.\n+     *\/\n+    protected Map<String, String> htmlAttrs() throws IOException {\n+        Map<String, String> map = new LinkedHashMap<>();\n+        skipWhitespace();\n+\n+        while (isIdentifierStart((char) ch)) {\n+            String name = readAttributeName().toLowerCase(Locale.US);\n+            skipWhitespace();\n+            String value = null;\n+            if (ch == '=') {\n+                nextChar();\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    char quote = (char) ch;\n+                    nextChar();\n+                    StringBuilder sb = new StringBuilder();\n+                    while (ch != -1 && ch != quote) {\n+\/\/                            if (ch == '\\n') {\n+\/\/                                error(path, lineNumber, \"unterminated string\");\n+\/\/                                \/\/ No point trying to read more.\n+\/\/                                \/\/ In fact, all attrs get discarded by the caller\n+\/\/                                \/\/ and superseded by a malformed.html node because\n+\/\/                                \/\/ the html tag itself is not terminated correctly.\n+\/\/                                break loop;\n+\/\/                            }\n+                        sb.append((char) ch);\n+                        nextChar();\n+                    }\n+                    value = sb.toString() \/\/ hack to replace common entities\n+                            .replace(\"&lt;\", \"<\")\n+                            .replace(\"&gt;\", \">\")\n+                            .replace(\"&amp;\", \"&\");\n+                    nextChar();\n+                } else {\n+                    StringBuilder sb = new StringBuilder();\n+                    while (ch != -1 && !isUnquotedAttrValueTerminator((char) ch)) {\n+                        sb.append((char) ch);\n+                        nextChar();\n+                    }\n+                    value = sb.toString();\n+                }\n+                skipWhitespace();\n+            }\n+            map.put(name, value);\n+        }\n+\n+        return map;\n+    }\n+\n+    protected boolean isIdentifierStart(char ch) {\n+        return Character.isUnicodeIdentifierStart(ch);\n+    }\n+\n+    protected String readIdentifier() throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append((char) ch);\n+        nextChar();\n+        while (ch != -1 && Character.isUnicodeIdentifierPart(ch)) {\n+            sb.append((char) ch);\n+            nextChar();\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected String readAttributeName() throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append((char) ch);\n+        nextChar();\n+        while ((ch != -1 && Character.isUnicodeIdentifierPart(ch))\n+                || ch == '-'\n+                || (xml && ch == ':')) {\n+            sb.append((char) ch);\n+            nextChar();\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected boolean isWhitespace(char ch) {\n+        return Character.isWhitespace(ch);\n+    }\n+\n+    protected void skipWhitespace() throws IOException {\n+        while (isWhitespace((char) ch)) {\n+            nextChar();\n+        }\n+    }\n+\n+    protected boolean isUnquotedAttrValueTerminator(char ch) {\n+        switch (ch) {\n+            case '\\f':\n+            case '\\n':\n+            case '\\r':\n+            case '\\t':\n+            case ' ':\n+            case '\"':\n+            case '\\'':\n+            case '`':\n+            case '=':\n+            case '<':\n+            case '>':\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/HtmlFileChecker.java","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+\n+public class Log {\n+    private final ArrayList<String> errors;\n+\n+    private Path baseDir;\n+\n+    public Log() {\n+        errors = new ArrayList<>();\n+    }\n+\n+    public ArrayList<String> getErrors() {\n+        return errors;\n+    }\n+\n+    public void log(Path path, int line, String message, Object... args) {\n+        errors.add(formatErrorMessage(path, line, message, args));\n+    }\n+\n+\n+    public String formatErrorMessage(Path path, int line, String message, Object... args) {\n+        return path + \":\" + line + \": \" + formatErrorMessage(message, args);\n+    }\n+\n+    public String formatErrorMessage(Path path, int line, Throwable t) {\n+        return path + \":\" + line + \": \" + t;\n+    }\n+\n+    public String formatErrorMessage(Path path, Throwable t) {\n+        return path + \": \" + t;\n+    }\n+\n+\n+    public String formatErrorMessage(String message, Object... args) {\n+        return String.format(message, args);\n+    }\n+\n+    public void log(String message) {\n+        errors.add(message);\n+    }\n+\n+    public void log(Path path, int lineNumber, String s, int errorsOnLine) {\n+        log(formatErrorMessage(path, lineNumber, s, errorsOnLine));\n+    }\n+\n+    public void log(Path path, int line, Throwable t) {\n+        log(formatErrorMessage(path, line, t));\n+    }\n+\n+    public void log(Path path, Throwable t) {\n+        log(formatErrorMessage(path, t));\n+    }\n+\n+    public void log(String message, Object... args) {\n+        log(formatErrorMessage(message, args));\n+    }\n+\n+    public void setBaseDirectory(Path baseDir) {\n+        this.baseDir = baseDir.toAbsolutePath();\n+    }\n+\n+    public Path againstBaseDir(Path path) {\n+        return baseDir != null && path.startsWith(baseDir) ? baseDir.relativize(path) : path;\n+    }\n+\n+    public boolean noErrors() {\n+        return errors.isEmpty();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/Log.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools.checkers;\n+\n+import tools.FileChecker;\n+import tools.Log;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Checks the contents of an HTML file for bad\/unmappable characters.\n+ *\n+ * The file encoding is determined from the file contents.\n+ *\/\n+public class BadCharacterChecker implements FileChecker, AutoCloseable {\n+    private static final Pattern doctype = Pattern.compile(\"(?i)<!doctype html>\");\n+    private static final Pattern metaCharset = Pattern.compile(\"(?i)<meta\\\\s+charset=\\\"([^\\\"]+)\\\">\");\n+    private static final Pattern metaContentType = Pattern.compile(\"(?i)<meta\\\\s+http-equiv=\\\"Content-Type\\\"\\\\s+content=\\\"text\/html;charset=([^\\\"]+)\\\">\");\n+    private final Log errors;\n+    private int files = 0;\n+    private int badFiles = 0;\n+\n+    public BadCharacterChecker() {\n+        errors = new Log();\n+    }\n+\n+    public void checkFile(Path path) {\n+        files++;\n+        boolean ok = true;\n+        try (InputStream in = new BufferedInputStream(Files.newInputStream(path))) {\n+            CharsetDecoder d = getCharset(in).newDecoder()\n+                    .onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            BufferedReader r = new BufferedReader(new InputStreamReader(in, d));\n+            int lineNumber = 0;\n+            String line;\n+            try {\n+                while ((line = r.readLine()) != null) {\n+                    lineNumber++;\n+                    int errorsOnLine = 0;\n+                    for (int i = 0; i < line.length(); i++) {\n+                        char ch = line.charAt(i);\n+                        if (ch == 0xFFFD) {\n+                            errorsOnLine++;\n+                        }\n+                    }\n+                    if (errorsOnLine > 0) {\n+                        errors.log(path, lineNumber, \"found %d invalid characters\", errorsOnLine);\n+                        ok = false;\n+                    }\n+                }\n+            } catch (IOException e) {\n+                errors.log(path, lineNumber, e);\n+                ok = false;\n+\n+            }\n+        } catch (IOException e) {\n+            errors.log(path, e);\n+            ok = false;\n+        }\n+        if (!ok)\n+            badFiles++;\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> files) {\n+        for (Path file : files) {\n+            checkFile(file);\n+        }\n+    }\n+\n+    private Charset getCharset(InputStream in) throws IOException {\n+        CharsetDecoder initial = StandardCharsets.US_ASCII.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+\n+        in.mark(1024);\n+        try {\n+            BufferedReader r = new BufferedReader(new InputStreamReader(in, initial));\n+            char[] buf = new char[1024];\n+            int n = r.read(buf, 0, buf.length);\n+            String head = new String(buf, 0, n);\n+            boolean html5 = doctype.matcher(head).find();\n+            Matcher m1 = metaCharset.matcher(head);\n+            if (m1.find()) {\n+                return Charset.forName(m1.group(1));\n+            }\n+            Matcher m2 = metaContentType.matcher(head);\n+            if (m2.find()) {\n+                return Charset.forName(m2.group(1));\n+            }\n+            return html5 ? StandardCharsets.UTF_8 : StandardCharsets.ISO_8859_1;\n+        } finally {\n+            in.reset();\n+        }\n+    }\n+\n+    @Override\n+    public void report() {\n+        if (!errors.noErrors() && files > 0) {\n+            System.err.println(\"Bad characters found in the generated HTML\");\n+\n+            System.err.println(MessageFormat.format(\n+                    \"\"\"\n+                            Bad Characters Report\n+                            {0} files read\n+                                {1} files contained bad characters\"\n+                                {2} bad characters or other errors found\n+                            \"\"\",\n+                    files, badFiles, files));\n+\n+            for (String s : errors.getErrors()) {\n+                System.err.println(s);\n+            }\n+            throw new RuntimeException(\"Bad character found in the generated HTML\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return errors.noErrors();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        report();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/checkers\/BadCharacterChecker.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools.checkers;\n+\n+import tools.HtmlChecker;\n+import tools.Log;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Checks the DocType declared at the head of an HTML file.\n+ *\n+ * @see <a href=\"https:\/\/www.w3.org\/TR\/html5\/syntax.html#syntax-doctype\">\n+ * W3C HTML5 8.1.1 The DOCTYPE<\/a>\n+ *\/\n+public class DocTypeChecker implements HtmlChecker {\n+    private final Log log;\n+    private final Map<String, Integer> counts = new HashMap<>();\n+    private int html5;\n+    private int html5_legacy;\n+    private int xml;\n+    private int other;\n+\n+    private Path path;\n+\n+    public DocTypeChecker() {\n+        log = new Log();\n+    }\n+\n+    @Override\n+    public void startFile(Path path) {\n+        this.path = path;\n+    }\n+\n+    @Override\n+    public void endFile() {\n+    }\n+\n+    @Override\n+    public void xml(int line, Map<String, String> attrs) {\n+        xml++;\n+    }\n+\n+    @Override\n+    public void docType(int line, String docType) {\n+        if (docType.equalsIgnoreCase(\"doctype html\")) {\n+            html5++;\n+        } else {\n+            Pattern p = Pattern.compile(\"(?i)doctype\"\n+                    + \"\\\\s+html\"\n+                    + \"\\\\s+([a-z]+)\"\n+                    + \"\\\\s+\\\"([^\\\"]+)\\\"\"\n+                    + \"(?:\\\\s+\\\"([^\\\"]+)\\\")?\"\n+                    + \"\\\\s*\");\n+            Matcher m = p.matcher(docType);\n+            if (m.matches()) {\n+                \/\/ See http:\/\/www.w3.org\/tr\/html52\/syntax.html#the-doctype\n+                if (m.group(1).equalsIgnoreCase(\"system\")\n+                        && m.group(2).equals(\"about:legacy-compat\")) {\n+                    html5_legacy++;\n+                } else {\n+                    String version = m.group(2);\n+                    List<String> allowedVersions = List.of(\n+                            \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n+                    );\n+                    if (!allowedVersions.stream().anyMatch(v -> v.equals(version))) {\n+                        log.log(path, line, \"unexpected doctype: \" + version);\n+                    }\n+                    counts.put(version, counts.getOrDefault(version, 0) + 1);\n+                }\n+            } else {\n+                log.log(path, line, \"doctype not recognized: \" + docType);\n+                other++;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing) {\n+    }\n+\n+    @Override\n+    public void endElement(int line, String name) {\n+    }\n+\n+    @Override\n+    public void report() {\n+        log.log(\"DocType Report\");\n+        if (xml > 0) {\n+            log.log(\"%6d: XHTML%n\", xml);\n+        }\n+        if (html5 > 0) {\n+            log.log(\"%6d: HTML5%n\", html5);\n+        }\n+        if (html5_legacy > 0) {\n+            log.log(\"%6d: HTML5 (legacy)%n\", html5_legacy);\n+        }\n+\n+        Map<Integer, Set<String>> sortedCounts = new TreeMap<>(\n+                new Comparator<Integer>() {\n+                    @Override\n+                    public int compare(Integer o1, Integer o2) {\n+                        return o2.compareTo(o1);\n+                    }\n+                });\n+\n+        for (Map.Entry<String, Integer> e : counts.entrySet()) {\n+            String s = e.getKey();\n+            Integer n = e.getValue();\n+            Set<String> set = sortedCounts.get(n);\n+            if (set == null)\n+                sortedCounts.put(n, (set = new TreeSet<>()));\n+            set.add(s);\n+        }\n+\n+        for (Map.Entry<Integer, Set<String>> e : sortedCounts.entrySet()) {\n+            for (String p : e.getValue()) {\n+                log.log(\"%6d: %s%n\", e.getKey(), p);\n+            }\n+        }\n+\n+        if (other > 0) {\n+            log.log(\"%6d: other\/unrecognized%n\", other);\n+        }\n+\n+        for (var line : log.getErrors()) {\n+            System.err.println(line);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return counts.isEmpty() && (other == 0);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!isOK()) {\n+            report();\n+            throw new RuntimeException(\"Found HTML files with missing doctype declaration\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/checkers\/DocTypeChecker.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools.checkers;\n+\n+\n+import tools.HtmlChecker;\n+import tools.Log;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Checks the links defined by and referenced in HTML files.\n+ *\/\n+public class LinkChecker implements HtmlChecker {\n+    private final Log errors;\n+    private final Map<Path, IDTable> allFiles;\n+    private final Map<URI, IDTable> allURIs;\n+    private boolean checkInwardReferencesOnly;\n+    private int files;\n+    private int links;\n+    private int duplicateIds;\n+    private int missingFiles;\n+    private int missingIds;\n+    private int badSchemes;\n+    private Path currFile;\n+    private IDTable currTable;\n+    private boolean html5;\n+    private boolean xml;\n+    public LinkChecker() {\n+        this.errors = new Log();\n+        allFiles = new HashMap<>();\n+        allURIs = new HashMap<>();\n+    }\n+\n+    public void setCheckInwardReferencesOnly(boolean checkInwardReferencesOnly) {\n+        this.checkInwardReferencesOnly = checkInwardReferencesOnly;\n+    }\n+\n+    @Override\n+    public void startFile(Path path) {\n+        currFile = path.toAbsolutePath().normalize();\n+        currTable = allFiles.computeIfAbsent(currFile, p -> new IDTable(errors.againstBaseDir(p)));\n+        html5 = false;\n+        files++;\n+    }\n+\n+    @Override\n+    public void endFile() {\n+        currTable.check();\n+    }\n+\n+    public List<Path> getUncheckedFiles() {\n+        return allFiles.entrySet().stream()\n+                .filter(e -> !e.getValue().checked\n+                        && e.getKey().toString().endsWith(\".html\")\n+                        && Files.exists(e.getKey()))\n+                .map(e -> e.getKey())\n+                .collect(Collectors.toList());\n+    }\n+\n+    public List<Path> getMissingFiles() {\n+        return allFiles.entrySet().stream()\n+                .filter(e -> !Files.exists(e.getKey()))\n+                .map(e -> e.getKey()).toList();\n+    }\n+\n+    @Override\n+    public void xml(int line, Map<String, String> attrs) {\n+        xml = true;\n+    }\n+\n+    @Override\n+    public void docType(int line, String doctype) {\n+        html5 = doctype.matches(\"(?i)<\\\\?doctype\\\\s+html>\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"fallthrough\")\n+    public void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing) {\n+        switch (name) {\n+            case \"a\":\n+                String nameAttr = html5 ? null : attrs.get(\"name\");\n+                if (nameAttr != null) {\n+                    foundAnchor(line, nameAttr);\n+                }\n+                \/\/ fallthrough\n+            case \"link\":\n+                String href = attrs.get(\"href\");\n+                if (href != null && !checkInwardReferencesOnly) {\n+                    foundReference(line, href);\n+                }\n+                break;\n+        }\n+\n+        String idAttr = attrs.get(\"id\");\n+        if (idAttr != null) {\n+            foundAnchor(line, idAttr);\n+        }\n+    }\n+\n+    @Override\n+    public void endElement(int line, String name) {\n+    }\n+\n+    @Override\n+    public void content(int line, String content) {\n+        HtmlChecker.super.content(line, content);\n+    }\n+\n+    @Override\n+    public void report() {\n+        List<Path> pathList = getMissingFiles();\n+        errors.log(\"Link Checker Report\");\n+\n+        if (!pathList.isEmpty()) {\n+            errors.log(\"\");\n+            errors.log(\"Missing files: (\" + pathList.size() + \")\");\n+            pathList.stream()\n+                    .sorted()\n+                    .forEach(this::reportMissingFile);\n+        }\n+\n+        int anchors = 0;\n+        for (IDTable t : allFiles.values()) {\n+            anchors += t.map.values().stream()\n+                    .filter(e -> !e.getReferences().isEmpty())\n+                    .count();\n+        }\n+        for (IDTable t : allURIs.values()) {\n+            anchors += t.map.values().stream()\n+                    .filter(e -> !e.references.isEmpty())\n+                    .count();\n+        }\n+\n+        errors.log(\"Checked \" + files + \" files.\");\n+        errors.log(\"Found \" + links + \" references to \" + anchors + \" anchors \"\n+                + \"in \" + allFiles.size() + \" files and \" + allURIs.size() + \" other URIs.\");\n+        if (!pathList.isEmpty()) {\n+            errors.log(\"%6d missing files\", pathList.size());\n+        }\n+        if (duplicateIds > 0) {\n+            errors.log(\"%6d duplicate ids\", duplicateIds);\n+\n+        }\n+        if (missingIds > 0) {\n+            errors.log(\"%6d missing ids\", missingIds);\n+\n+        }\n+\n+        Map<String, Integer> hostCounts = new TreeMap<>(new HostComparator());\n+        for (URI uri : allURIs.keySet()) {\n+            String host = uri.getHost();\n+            if (host != null) {\n+                hostCounts.put(host, hostCounts.computeIfAbsent(host, h -> 0) + 1);\n+            }\n+        }\n+\n+        if (hostCounts.size() > 0) {\n+            errors.log(\"\");\n+            errors.log(\"Hosts\");\n+            hostCounts.forEach((h, n) -> errors.log(\"%6d %s\", n, h));\n+        }\n+\n+\n+        for (String message : errors.getErrors()) {\n+            System.err.println(message);\n+        }\n+\n+    }\n+\n+    private void reportMissingFile(Path file) {\n+        errors.log(errors.againstBaseDir(file).toString());\n+        IDTable table = allFiles.get(file);\n+        Set<Path> refs = new TreeSet<>();\n+        for (IDInfo id : table.map.values()) {\n+            if (id.references != null) {\n+                for (Position ref : id.references) {\n+                    refs.add(ref.path);\n+                }\n+            }\n+        }\n+        int n = 0;\n+        int MAX_REFS = 10;\n+        for (Path ref : refs) {\n+            errors.log(\"    in \" + errors.againstBaseDir(ref));\n+            if (++n == MAX_REFS) {\n+                errors.log(\"    ... and %d more\", refs.size() - n);\n+                break;\n+            }\n+        }\n+        missingFiles++;\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return duplicateIds == 0\n+                && missingIds == 0\n+                && missingFiles == 0\n+                && badSchemes == 0;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        report();\n+        if (!isOK()) {\n+            throw new RuntimeException(\n+                    \"LinkChecker encountered errors. Duplicate IDs: \"\n+                    + duplicateIds + \", Missing IDs: \" + missingIds\n+                    + \", Missing Files: \" + missingFiles + \", Bad Schemes: \" + badSchemes);\n+        }\n+    }\n+\n+    private void foundAnchor(int line, String name) {\n+        currTable.addID(line, name);\n+    }\n+\n+    private void foundReference(int line, String ref) {\n+        links++;\n+        try {\n+            URI uri = new URI(ref);\n+            if (uri.isAbsolute()) {\n+                foundReference(line, uri);\n+            } else {\n+                Path p;\n+                String uriPath = uri.getPath();\n+                if (uriPath == null || uriPath.isEmpty()) {\n+                    p = currFile;\n+                } else {\n+                    p = currFile.getParent().resolve(uriPath).normalize();\n+                }\n+                var fragment = uri.getFragment();\n+                if (fragment != null && !fragment.isEmpty()) {\n+                    foundReference(line, p, fragment);\n+                }\n+            }\n+        } catch (URISyntaxException e) {\n+            errors.log(currFile, line, \"invalid URI: \" + e);\n+        }\n+    }\n+\n+    private void foundReference(int line, Path p, String fragment) {\n+        IDTable t = allFiles.computeIfAbsent(p, key -> new IDTable(errors.againstBaseDir(key)));\n+        t.addReference(fragment, currFile, line);\n+    }\n+\n+    private void foundReference(int line, URI uri) {\n+        if (!isSchemeOK(uri.getScheme()) && !checkInwardReferencesOnly) {\n+            errors.log(currFile, line, \"bad scheme in URI\");\n+            badSchemes++;\n+        }\n+\n+        String fragment = uri.getRawFragment();\n+        if (fragment != null && !fragment.isEmpty()) {\n+            try {\n+                URI noFrag = new URI(uri.toString().replaceAll(\"#\\\\Q\" + fragment + \"\\\\E$\", \"\"));\n+                IDTable t = allURIs.computeIfAbsent(noFrag, IDTable::new);\n+                t.addReference(fragment, currFile, line);\n+            } catch (URISyntaxException e) {\n+                throw new Error(e);\n+            }\n+        }\n+    }\n+\n+    private boolean isSchemeOK(String uriScheme) {\n+        if (uriScheme == null) {\n+            return true;\n+        }\n+\n+        return switch (uriScheme) {\n+            case \"ftp\", \"http\", \"https\", \"javascript\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static class Position implements Comparable<Position> {\n+        Path path;\n+        int line;\n+\n+        Position(Path path, int line) {\n+            this.path = path;\n+            this.line = line;\n+        }\n+\n+        @Override\n+        public int compareTo(Position o) {\n+            int v = path.compareTo(o.path);\n+            return v != 0 ? v : Integer.compare(line, o.line);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            } else if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            } else {\n+                final Position other = (Position) obj;\n+                return Objects.equals(this.path, other.path)\n+                        && this.line == other.line;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(path) * 37 + line;\n+        }\n+    }\n+\n+    static class IDInfo {\n+        boolean declared;\n+        Set<Position> references;\n+\n+        Set<Position> getReferences() {\n+            return references == null ? Collections.emptySet() : references;\n+        }\n+    }\n+\n+    static class URIComparator implements Comparator<URI> {\n+        final HostComparator hostComparator = new HostComparator();\n+\n+        @Override\n+        public int compare(URI o1, URI o2) {\n+            if (o1.isOpaque() || o2.isOpaque()) {\n+                return o1.compareTo(o2);\n+            }\n+            String h1 = o1.getHost();\n+            String h2 = o2.getHost();\n+            String s1 = o1.getScheme();\n+            String s2 = o2.getScheme();\n+            if (h1 == null || h1.isEmpty() || s1 == null || s1.isEmpty()\n+                    || h2 == null || h2.isEmpty() || s2 == null || s2.isEmpty()) {\n+                return o1.compareTo(o2);\n+            }\n+            int v = hostComparator.compare(h1, h2);\n+            if (v != 0) {\n+                return v;\n+            }\n+            v = s1.compareTo(s2);\n+            if (v != 0) {\n+                return v;\n+            }\n+            return o1.compareTo(o2);\n+        }\n+    }\n+\n+    static class HostComparator implements Comparator<String> {\n+        @Override\n+        public int compare(String h1, String h2) {\n+            List<String> l1 = new ArrayList<>(Arrays.asList(h1.split(\"\\\\.\")));\n+            Collections.reverse(l1);\n+            String r1 = String.join(\".\", l1);\n+            List<String> l2 = new ArrayList<>(Arrays.asList(h2.split(\"\\\\.\")));\n+            Collections.reverse(l2);\n+            String r2 = String.join(\".\", l2);\n+            return r1.compareTo(r2);\n+        }\n+    }\n+\n+    class IDTable {\n+        private final Map<String, IDInfo> map = new HashMap<>();\n+        private final String pathOrURI;\n+        private boolean checked;\n+\n+        IDTable(Path path) {\n+            this.pathOrURI = path.toString();\n+        }\n+\n+        IDTable(URI uri) {\n+            this.pathOrURI = uri.toString();\n+        }\n+\n+        void addID(int line, String name) {\n+            if (checked) {\n+                throw new IllegalStateException(\"Adding ID after file has been\");\n+            }\n+            Objects.requireNonNull(name);\n+            IDInfo info = map.computeIfAbsent(name, _ -> new IDInfo());\n+            if (info.declared) {\n+                if (info.references != null || !checkInwardReferencesOnly) {\n+                    \/\/ don't report error if we're only checking inbound references\n+                    \/\/ and there are no references to this ID.\n+                    errors.log(currFile, line, \"name already declared: \" + name);\n+                    duplicateIds++;\n+                }\n+            } else {\n+                info.declared = true;\n+            }\n+        }\n+\n+        void addReference(String name, Path from, int line) {\n+            if (checked) {\n+                if (name != null) {\n+                    IDInfo id = map.get(name);\n+                    if (id == null || !id.declared) {\n+                        errors.log(from, line, \"id not found: \" + this.pathOrURI + \"#\" + name);\n+                    }\n+                }\n+            } else {\n+                IDInfo id = map.computeIfAbsent(name, x -> new IDInfo());\n+                if (id.references == null) {\n+                    id.references = new TreeSet<>();\n+                }\n+                id.references.add(new Position(from, line));\n+            }\n+        }\n+\n+        void check() {\n+            map.forEach((name, id) -> {\n+                if (name != null && !id.declared) {\n+                    \/\/log.error(currFile, 0, \"id not declared: \" + name);\n+                    for (Position ref : id.references) {\n+                        errors.log(ref.path, ref.line, \"id not found: \" + this.pathOrURI + \"#\" + name);\n+                    }\n+                    missingIds++;\n+                }\n+            });\n+            checked = true;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/checkers\/LinkChecker.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tools.checkers;\n+\n+\n+import tools.FileChecker;\n+import tools.Log;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TidyChecker implements FileChecker, AutoCloseable {\n+    private final Path TIDY;\n+    Map<Pattern, Integer> counts = new HashMap<>();\n+\n+    private Log errors;\n+    private Path path;\n+    private int files = 0;\n+    private int ok;\n+    private int warns;\n+    private int errs;\n+    private int css;\n+    private int overflow;\n+\n+    public TidyChecker() {\n+        TIDY = initTidy();\n+        errors = new Log();\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> sb) {\n+        files += sb.size();\n+        try {\n+            for (int i = 0; i < sb.size(); i += 1024) {\n+                List<String> command = new ArrayList<>();\n+                command.add(TIDY.toString());\n+                command.add(\"-q\");\n+                command.add(\"-e\");\n+                command.add(\"--gnu-emacs\");\n+                command.add(\"true\");\n+                List<Path> sublist = sb.subList(i, Math.min(i + 1024, sb.size()));\n+                for (Path path : sublist) {\n+                    command.add(path.toString());\n+                }\n+                Process p = new ProcessBuilder()\n+                        .command(command)\n+                        .redirectErrorStream(true)\n+                        .start();\n+                try (BufferedReader r =\n+                             new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8))) {\n+                    String line;\n+                    while ((line = r.readLine()) != null) {\n+                        checkLine(line);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private Path initTidy() {\n+        Path tidyExePath;\n+        String tidyProperty = System.getProperty(\"tidy\");\n+        if (tidyProperty != null) {\n+            tidyExePath = Path.of(tidyProperty);\n+            if (!Files.exists(tidyExePath)) {\n+                System.err.println(\"tidy not found: \" + tidyExePath);\n+            }\n+            if (!Files.isExecutable(tidyExePath)) {\n+                System.err.println(\"tidy not executable: \" + tidyExePath);\n+            }\n+        } else {\n+            boolean isWindows = System.getProperty(\"os.name\")\n+                    .toLowerCase(Locale.US)\n+                    .startsWith(\"windows\");\n+            String tidyExe = isWindows ? \"tidy.exe\" : \"tidy\";\n+            Optional<Path> p = Stream.of(System.getenv(\"PATH\")\n+                            .split(File.pathSeparator))\n+                    .map(Path::of)\n+                    .map(d -> d.resolve(tidyExe))\n+                    .filter(Files::exists)\n+                    .filter(Files::isExecutable)\n+                    .findFirst();\n+            if (p.isPresent()) {\n+                tidyExePath = p.get();\n+            } else {\n+                System.err.println(\"tidy not found on PATH\");\n+                return Path.of(\"tidy\"); \/\/non-null placeholder return; exception would be better\n+            }\n+        }\n+\n+        try {\n+            Process p = new ProcessBuilder()\n+                    .command(tidyExePath.toString(), \"-version\")\n+                    .redirectErrorStream(true)\n+                    .start();\n+            try (BufferedReader r =\n+                         new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8))) {\n+                List<String> lines = r.lines().collect(Collectors.toList());\n+                \/\/ Look for a line containing \"version\" and a dotted identifier beginning 5.\n+                \/\/ If not found, look for known old\/bad versions, to report in error message\n+                Pattern version = Pattern.compile(\"version.* [5678]\\\\.[0-9]+(\\\\.[0-9]+)\");\n+                if (lines.stream().noneMatch(line -> version.matcher(line).find())) {\n+                    Pattern oldVersion = Pattern.compile(\"2006\");  \/\/ 2006 implies old macOS version\n+                    String lineSep = System.lineSeparator();\n+                    String message = lines.stream().anyMatch(line -> oldVersion.matcher(line).find())\n+                            ? \"old version of 'tidy' found on the PATH\\n\"\n+                            : \"could not determine the version of 'tidy' on the PATH\\n\";\n+                    System.err.println(message + String.join(lineSep, lines));\n+                }\n+            }\n+        } catch (IOException e) {\n+            System.err.println(\"Could not execute 'tidy -version': \" + e);\n+        }\n+\n+        return tidyExePath;\n+    }\n+\n+    @Override\n+    public void report() {\n+        if (files > 0) {\n+            System.err.println(MessageFormat.format(\n+                    \"\"\"\n+                            Tidy report\n+                            {0} files read\n+                                {1} files had no errors or warnings\n+                                {2} files reported \"Not all warnings\/errors were shown.\"\n+                                {3} errors found\n+                                {4} warnings found\n+                                {5} recommendations to use CSS\n+\n+                                {6}% files with no errors or warnings\n+                                {7} average errors or warnings per file\n+                            \"\"\",\n+                    files, ok, overflow, errs, warns, css,\n+                    (ok * 100 \/ files),\n+                    ((errs + warns) * 1.0 \/ files)));\n+            System.err.println(\"Tidy found errors in the generated HTML\");\n+            if (!errors.noErrors()) {\n+                for (String s : errors.getErrors()) {\n+                    System.err.println(s);\n+                }\n+                throw new RuntimeException(\"Tidy found errors in the generated HTML\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return (ok == files)\n+                && (overflow == 0)\n+                && (errs == 0)\n+                && (warns == 0)\n+                && (css == 0);\n+    }\n+\n+    void checkLine(String line) {\n+        Matcher m;\n+        if (okPattern.matcher(line).matches()) {\n+            ok++;\n+        } else if ((m = countPattern.matcher(line)).matches()) {\n+            warns += Integer.parseInt(m.group(1));\n+            errs += Integer.parseInt(m.group(2));\n+            if (m.group(3) != null)\n+                overflow++;\n+        } else if ((m = countPattern2.matcher(line)).matches()) {\n+            warns += Integer.parseInt(m.group(1));\n+            errs += Integer.parseInt(m.group(2));\n+            if (m.group(3) != null)\n+                overflow++;\n+        } else if (guardPattern.matcher(line).matches()) {\n+            boolean found = false;\n+            for (Pattern p : patterns) {\n+                if (p.matcher(line).matches()) {\n+                    errors.log(\"%s\", line);\n+                    found = true;\n+                    count(p);\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                errors.log(path + \"unrecognized line: \" + line);\n+        } else if (cssPattern.matcher(line).matches()) {\n+            css++;\n+        }\n+    }\n+\n+    void count(Pattern p) {\n+        Integer i = counts.get(p);\n+        counts.put(p, (i == null) ? 1 : i + 1);\n+    }\n+\n+    @Override\n+    public void close() {\n+        report();\n+    }\n+    Pattern okPattern = Pattern.compile(\"No warnings or errors were found.\");\n+    Pattern countPattern = Pattern.compile(\"([0-9]+) warnings, ([0-9]+) errors were found!.*?(Not all warnings\/errors were shown.)?\");\n+    Pattern countPattern2 = Pattern.compile(\"Tidy found ([0-9]+) warning[s]? and ([0-9]+) error[s]?!.*?(Not all warnings\/errors were shown.)?\");\n+    Pattern cssPattern = Pattern.compile(\"You are recommended to use CSS.*\");\n+    Pattern guardPattern = Pattern.compile(\"(line [0-9]+ column [0-9]+ - |[^:]+:[0-9]+:[0-9]+: )(Error|Warning):.*\");\n+    Pattern[] patterns = {\n+            Pattern.compile(\".*Error: <.*> is not recognized!\"),\n+            Pattern.compile(\".*Error: missing quote mark for attribute value\"),\n+            Pattern.compile(\".*Warning: '<' \\\\+ '\/' \\\\+ letter not allowed here\"),\n+            Pattern.compile(\".*Warning: <.*> anchor \\\".*\\\" already defined\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" has invalid value \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" lacks value\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" lacks value\"),\n+            Pattern.compile(\".*Warning: <.*> attribute with missing trailing quote mark\"),\n+            Pattern.compile(\".*Warning: <.*> dropping value \\\".*\\\" for repeated attribute \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> inserting \\\".*\\\" attribute\"),\n+            Pattern.compile(\".*Warning: <.*> is probably intended as <\/.*>\"),\n+            Pattern.compile(\".*Warning: <.*> isn't allowed in <.*> elements\"),\n+            Pattern.compile(\".*Warning: <.*> lacks \\\".*\\\" attribute\"),\n+            Pattern.compile(\".*Warning: <.*> missing '>' for end of tag\"),\n+            Pattern.compile(\".*Warning: <.*> proprietary attribute \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> unexpected or duplicate quote mark\"),\n+            Pattern.compile(\".*Warning: <a> id and name attribute value mismatch\"),\n+            Pattern.compile(\".*Warning: <a> cannot copy name attribute to id\"),\n+            Pattern.compile(\".*Warning: <a> escaping malformed URI reference\"),\n+            Pattern.compile(\".*Warning: <blockquote> proprietary attribute \\\"pre\\\"\"),\n+            Pattern.compile(\".*Warning: discarding unexpected <.*>\"),\n+            Pattern.compile(\".*Warning: discarding unexpected <\/.*>\"),\n+            Pattern.compile(\".*Warning: entity \\\".*\\\" doesn't end in ';'\"),\n+            Pattern.compile(\".*Warning: inserting implicit <.*>\"),\n+            Pattern.compile(\".*Warning: inserting missing 'title' element\"),\n+            Pattern.compile(\".*Warning: missing <!DOCTYPE> declaration\"),\n+            Pattern.compile(\".*Warning: missing <.*>\"),\n+            Pattern.compile(\".*Warning: missing <\/.*> before <.*>\"),\n+            Pattern.compile(\".*Warning: nested emphasis <.*>\"),\n+            Pattern.compile(\".*Warning: plain text isn't allowed in <.*> elements\"),\n+            Pattern.compile(\".*Warning: removing whitespace preceding XML Declaration\"),\n+            Pattern.compile(\".*Warning: replacing <p> (by|with) <br>\"),\n+            Pattern.compile(\".*Warning: replacing invalid numeric character reference .*\"),\n+            Pattern.compile(\".*Warning: replacing obsolete element <xmp> with <pre>\"),\n+            Pattern.compile(\".*Warning: replacing unexpected .* (by|with) <\/.*>\"),\n+            Pattern.compile(\".*Warning: trimming empty <.*>\"),\n+            Pattern.compile(\".*Warning: unescaped & or unknown entity \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: unescaped & which should be written as &amp;\"),\n+            Pattern.compile(\".*Warning: using <br> in place of <p>\"),\n+            Pattern.compile(\".*Warning: <.*> element removed from HTML5\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" not allowed for HTML5\"),\n+            Pattern.compile(\".*Warning: The summary attribute on the <table> element is obsolete in HTML5\"),\n+            Pattern.compile(\".*Warning: replacing invalid UTF-8 bytes \\\\(char. code U\\\\+.*\\\\)\")\n+    };\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doccheck\/tools\/checkers\/TidyChecker.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"}]}