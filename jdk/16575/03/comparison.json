{"files":[{"patch":"@@ -3420,0 +3420,21 @@\n+void Assembler::evmovntdquq(Address dst, XMMRegister src, int vector_len) {\n+  \/\/ Unmasked instruction\n+  evmovntdquq(dst, k0, src, \/*merge*\/ true, vector_len);\n+}\n+\n+void Assembler::evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0xE7);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  void evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovntdquq(Address dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,0 +190,4 @@\n+  void arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp, Label& L_entry, Label& L_exit);\n+\n@@ -195,0 +199,5 @@\n+  void arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                            Register temp3, Register temp4, Register count,\n+                            XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                            XMMRegister xmm4, int shift);\n+\n@@ -202,0 +211,4 @@\n+  void copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1, XMMRegister xmm2,\n+                                XMMRegister xmm3, XMMRegister xmm4, bool conjoint, int shift,\n+                                 int offset = 0);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  const int large_threshold = 2621440; \/\/ 2.5 MB\n@@ -520,0 +521,1 @@\n+  Label L_copy_large, L_finish;\n@@ -580,0 +582,6 @@\n+    if (MaxVectorSize == 64) {\n+      __ movq(temp2, temp1);\n+      __ shlq(temp2, shift);\n+      __ cmpq(temp2, large_threshold);\n+      __ jcc(Assembler::greaterEqual, L_copy_large);\n+    }\n@@ -706,0 +714,1 @@\n+  __ BIND(L_finish);\n@@ -720,0 +729,5 @@\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_copy_large);\n+    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+    __ jmp(L_finish);\n+  }\n@@ -723,0 +737,64 @@\n+void StubGenerator::arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                                         Register temp3, Register temp4, Register count,\n+                                         XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                         XMMRegister xmm4, int shift) {\n+\n+  \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+  int loop_size[]        = { 256,     128,       64,      32};\n+  int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+  Label L_main_loop_large;\n+  Label L_tail_large;\n+  Label L_exit_large;\n+  Label L_entry_large;\n+  Label L_main_pre_loop_large;\n+  Label L_pre_main_post_large;\n+\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_entry_large);\n+\n+    __ BIND(L_pre_main_post_large);\n+    \/\/ Partial copy to make dst address 64 byte aligned.\n+    __ movq(temp2, to);\n+    __ andq(temp2, 63);\n+    __ jcc(Assembler::equal, L_main_pre_loop_large);\n+\n+    __ negptr(temp2);\n+    __ addq(temp2, 64);\n+    if (shift) {\n+      __ shrq(temp2, shift);\n+    }\n+    __ movq(temp3, temp2);\n+    copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0);\n+    __ movq(temp4, temp2);\n+    __ movq(temp1, count);\n+    __ subq(temp1, temp2);\n+\n+    __ cmpq(temp1, loop_size[shift]);\n+    __ jcc(Assembler::less, L_tail_large);\n+\n+    __ BIND(L_main_pre_loop_large);\n+    __ subq(temp1, loop_size[shift]);  \/\/ whay is this here\n+\n+    \/\/ Main loop with aligned copy block size of 256 bytes at 64 byte copy granularity.\n+    __ align32();\n+    __ BIND(L_main_loop_large);\n+    copy256_avx3(to, from, temp4, xmm1, xmm2, xmm3, xmm4, false, shift, 0);\n+    __ addptr(temp4, loop_size[shift]);\n+    __ subq(temp1, loop_size[shift]);\n+    __ jcc(Assembler::greater, L_main_loop_large);\n+    \/\/ fence needed because copy256_avx 3 uses non-temporal stores\n+    __ sfence();\n+\n+    __ addq(temp1, loop_size[shift]);\n+    \/\/ Zero length check.\n+    __ jcc(Assembler::lessEqual, L_exit_large);\n+    __ BIND(L_tail_large);\n+    \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+    __ cmpq(temp1, 0);\n+    __ jcc(Assembler::lessEqual, L_exit_large);\n+    arraycopy_avx3_special_cases_256(xmm1, k2, from, to, temp1, shift,\n+                                 temp4, temp3, L_entry_large, L_exit_large);\n+    __ BIND(L_exit_large);\n+  }\n+}\n@@ -968,0 +1046,52 @@\n+void StubGenerator::arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                                     Register to, Register count, int shift, Register index,\n+                                                     Register temp, Label& L_entry, Label& L_exit) {\n+  Label L_entry_64, L_entry_128, L_entry_192, L_entry_256;\n+\n+  int size_mat[][4] = {\n+  \/* T_BYTE *\/ {64, 128, 192, 256},\n+  \/* T_SHORT*\/ {32, 64 , 96 , 128},\n+  \/* T_INT  *\/ {16, 32 , 48 ,  64},\n+  \/* T_LONG *\/ { 8, 16 , 24 ,  32}\n+  };\n+\n+  if (MaxVectorSize == 64) {\n+    \/\/ Case A) Special case for length less than or equal to 64 bytes.\n+    __ BIND(L_entry_64);\n+    __ cmpq(count, size_mat[shift][0]);\n+    __ jccb(Assembler::greater, L_entry_128);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case B) Special case for length less than or equal to 128 bytes.\n+    __ BIND(L_entry_128);\n+    __ cmpq(count, size_mat[shift][1]);\n+    __ jccb(Assembler::greater, L_entry_192);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    __ subq(count, 64 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case C) Special case for length less than or equal to 192 bytes.\n+    __ BIND(L_entry_192);\n+    __ cmpq(count, size_mat[shift][2]);\n+    __ jcc(Assembler::greater, L_entry_256);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+    __ subq(count, 128 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case D) Special case for length less than or equal to 256 bytes.\n+    __ BIND(L_entry_256);\n+    __ cmpq(count, size_mat[shift][3]);\n+    __ jcc(Assembler::greater, L_entry);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 128, true);\n+    __ subq(count, 192 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 192, true);\n+    __ jmp(L_exit);\n+  }\n+}\n+\n@@ -1043,0 +1173,27 @@\n+void StubGenerator::copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1,\n+                                XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                bool conjoint, int shift, int offset) {\n+  if (MaxVectorSize == 64) {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ prefetcht0(Address(src, index, scale, offset + 0x200));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x240));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x280));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x2C0));\n+\n+    __ prefetcht0(Address(src, index, scale, offset + 0x400));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x440));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x480));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x4C0));\n+\n+    __ evmovdquq(xmm1, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm2, Address(src, index, scale, offset + 0x40), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm3, Address(src, index, scale, offset + 0x80), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm4, Address(src, index, scale, offset + 0xC0), Assembler::AVX_512bit);\n+\n+    __ evmovntdquq(Address(dst, index, scale, offset), xmm1, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x40), xmm2, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x80), xmm3, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0xC0), xmm4, Assembler::AVX_512bit);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -11,0 +11,2 @@\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayCriticalXorOpImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,0 +11,2 @@\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayElementsXorOpImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,0 +22,10 @@\n+    }\n+\n+    static final MethodHandle xor_op;\n+    static final Arena arena = Arena.ofConfined();\n+    MemorySegment srcBuf;\n+    MemorySegment dstBuf;\n+\n+    GetArrayForeignXorOpImpl(int len) {\n+        srcBuf = arena.allocate(len);\n+        dstBuf = arena.allocate(len);\n@@ -37,0 +47,8 @@\n+\n+    public void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len) {\n+        for (int i = 0; i < count; i++) {\n+            MemorySegment.copy(src, sOff, srcBuf, JAVA_BYTE, 0, len);\n+            MemorySegment.copy(dst, dOff, dstBuf, JAVA_BYTE, 0, len);\n+            MemorySegment.copy(srcBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpImpl.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -9,0 +9,3 @@\n+    public GetArrayRegionXorOpImpl() {\n+    }\n+\n@@ -11,0 +14,2 @@\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayRegionXorOpImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,0 +7,4 @@\n+<<<<<<< HEAD\n+    void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorOp.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,0 +8,4 @@\n+<<<<<<< HEAD\n+import org.openjdk.jmh.annotations.TearDown;\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -21,0 +25,4 @@\n+<<<<<<< HEAD\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+=======\n@@ -23,0 +31,1 @@\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -27,0 +36,4 @@\n+<<<<<<< HEAD\n+    int count;\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -45,0 +58,6 @@\n+<<<<<<< HEAD\n+        ELEMENTS,\n+        REGION,\n+        CRITICAL,\n+        FOREIGN;\n+=======\n@@ -52,0 +71,1 @@\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -56,0 +76,5 @@\n+<<<<<<< HEAD\n+        switch (sizeKind) {\n+            case SMALL:\n+                count = 1000;\n+=======\n@@ -84,0 +109,1 @@\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -89,0 +115,4 @@\n+<<<<<<< HEAD\n+                count = 50;\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -94,0 +124,4 @@\n+<<<<<<< HEAD\n+                count = 10;\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -102,0 +136,20 @@\n+<<<<<<< HEAD\n+        switch (arrayKind) {\n+            case CRITICAL:\n+                impl = new GetArrayCriticalXorOpImpl();\n+                break;\n+            case ELEMENTS:\n+                impl = new GetArrayElementsXorOpImpl();\n+                break;\n+            case REGION:\n+                impl = new GetArrayRegionXorOpImpl();\n+                break;\n+            case FOREIGN:\n+                impl = new GetArrayForeignXorOpImpl(alen);\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(arrayKind.toString());\n+        }\n+\n+=======\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -110,0 +164,11 @@\n+<<<<<<< HEAD\n+        impl.copy(count, src, off, dst, off, len);\n+        if (arrayKind != ArrayKind.CRITICAL && !verify(dst, off, off + len, (byte)0xaa)) {\n+            throw new IllegalStateException(\"Copy failed to verify\");\n+        }\n+        Arrays.fill(src, off, off + len, (byte)0xaa);\n+        Arrays.fill(dst, off, off + len, (byte)0x5a);\n+        impl.xor(src, off, dst, off, len);\n+        if (!verify(dst, off, off + len, (byte)0xf0)) {\n+            throw new IllegalStateException(\"Xor failed to verify\");\n+=======\n@@ -113,0 +178,1 @@\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n@@ -119,0 +185,10 @@\n+<<<<<<< HEAD\n+        for (int i = 0; i < count; ++i) {\n+            impl.xor(src, off, dst, off, len);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy() throws Throwable {\n+        impl.copy(count, src, off, dst, off, len);\n+=======\n@@ -120,0 +196,1 @@\n+>>>>>>> 9727f4bdddc071e6f59806087339f345405ab004\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -70,0 +70,55 @@\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayCriticalXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    for (int i = 0; i < count; i++) {\n+        sbuf = (*env)->GetPrimitiveArrayCritical(env, src, &sIsCopy);\n+        dbuf = (*env)->GetPrimitiveArrayCritical(env, dst, &dIsCopy);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dst, dbuf, JNI_ABORT);\n+        (*env)->ReleasePrimitiveArrayCritical(env, src, sbuf, 0);\n+        if (sIsCopy) {\n+            fprintf(stderr, \"SRC is copy - GetPrimitiveArrayCritical\\n\");\n+            fflush(stderr);\n+        }\n+        if (dIsCopy) {\n+            fprintf(stderr, \"DST is copy - GetPrimitiveArrayCritical\\n\");\n+            fflush(stderr);\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayElementsXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    for (int i = 0; i < count; i++) {\n+        dbuf = (*env)->GetByteArrayElements(env, dst, &dIsCopy);\n+        dbuf = (*env)->GetByteArrayElements(env, src, &sIsCopy);\n+        (*env)->ReleaseByteArrayElements(env, dst, dbuf, 0);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayRegionXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = malloc(len);\n+    jbyte *dbuf = malloc(len);\n+\n+    for (int i = 0; i < count; i++) {\n+        (*env)->GetByteArrayRegion(env, src, sOff, len, sbuf);\n+        (*env)->GetByteArrayRegion(env, dst, dOff, len, dbuf);\n+        (*env)->SetByteArrayRegion(env, dst, dOff, len, sbuf);\n+    }\n+\n+    free(dbuf);\n+    free(sbuf);\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/libjnitest.c","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"}]}