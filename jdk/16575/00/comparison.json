{"files":[{"patch":"@@ -3420,0 +3420,21 @@\n+void Assembler::evmovntdquq(Address dst, XMMRegister src, int vector_len) {\n+  \/\/ Unmasked instruction\n+  evmovntdquq(dst, k0, src, \/*merge*\/ true, vector_len);\n+}\n+\n+void Assembler::evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0xE7);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  void evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovntdquq(Address dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,0 +190,4 @@\n+  void arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp, Label& L_entry, Label& L_exit);\n+\n@@ -195,0 +199,5 @@\n+  void arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                            Register temp3, Register temp4, Register count,\n+                            XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                            XMMRegister xmm4, int shift);\n+\n@@ -202,0 +211,4 @@\n+  void copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1, XMMRegister xmm2,\n+                                XMMRegister xmm3, XMMRegister xmm4, bool conjoint, int shift,\n+                                 int offset = 0);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  const int large_threshold = 2621440; \/\/ 2.5 MB\n@@ -520,0 +521,1 @@\n+  Label L_copy_large, L_finish;\n@@ -580,0 +582,4 @@\n+    __ movq(temp2, temp1);\n+    __ shlq(temp2, shift);\n+    __ cmpq(temp2, large_threshold);\n+    __ jcc(Assembler::greaterEqual, L_copy_large);\n@@ -706,0 +712,1 @@\n+  __ BIND(L_finish);\n@@ -720,1 +727,3 @@\n-  return start;\n+  __ BIND(L_copy_large);\n+  arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+  __ jmp(L_finish);  return start;\n@@ -723,0 +732,62 @@\n+void StubGenerator::arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                                         Register temp3, Register temp4, Register count,\n+                                         XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                         XMMRegister xmm4, int shift) {\n+\n+  \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+  int loop_size[]        = { 256,     128,       64,      32};\n+  int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+  Label L_main_loop_large;\n+  Label L_tail_large;\n+  Label L_exit_large;\n+  Label L_entry_large;\n+  Label L_main_pre_loop_large;\n+  Label L_pre_main_post_large;\n+\n+  __ BIND(L_entry_large);\n+\n+  __ BIND(L_pre_main_post_large);\n+  \/\/ Partial copy to make dst address 64 byte aligned.\n+  __ movq(temp2, to);\n+  __ andq(temp2, 63);\n+  __ jcc(Assembler::equal, L_main_pre_loop_large);\n+\n+  __ negptr(temp2);\n+  __ addq(temp2, 64);\n+  if (shift) {\n+    __ shrq(temp2, shift);\n+  }\n+  __ movq(temp3, temp2);\n+  copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0);\n+  __ movq(temp4, temp2);\n+  __ movq(temp1, count);\n+  __ subq(temp1, temp2);\n+\n+  __ cmpq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::less, L_tail_large);\n+\n+  __ BIND(L_main_pre_loop_large);\n+  __ subq(temp1, loop_size[shift]);  \/\/ whay is this here\n+\n+  \/\/ Main loop with aligned copy block size of 256 bytes at 64 byte copy granularity.\n+  __ align32();\n+  __ BIND(L_main_loop_large);\n+  copy256_avx3(to, from, temp4, xmm1, xmm2, xmm3, xmm4, false, shift, 0);\n+  __ addptr(temp4, loop_size[shift]);\n+  __ subq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::greater, L_main_loop_large);\n+  \/\/ fence needed because copy256_avx 3 uses non-temporal stores\n+  __ sfence();\n+\n+  __ addq(temp1, loop_size[shift]);\n+  \/\/ Zero length check.\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  __ BIND(L_tail_large);\n+  \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+  __ cmpq(temp1, 0);\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  arraycopy_avx3_special_cases_256(xmm1, k2, from, to, temp1, shift,\n+                               temp4, temp3, L_entry_large, L_exit_large);\n+  __ BIND(L_exit_large);\n+}\n@@ -968,0 +1039,50 @@\n+void StubGenerator::arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                                     Register to, Register count, int shift, Register index,\n+                                                     Register temp, Label& L_entry, Label& L_exit) {\n+  Label L_entry_64, L_entry_128, L_entry_192, L_entry_256;\n+\n+  int size_mat[][4] = {\n+  \/* T_BYTE *\/ {64, 128, 192, 256},\n+  \/* T_SHORT*\/ {32, 64 , 96 , 128},\n+  \/* T_INT  *\/ {16, 32 , 48 ,  64},\n+  \/* T_LONG *\/ { 8, 16 , 24 ,  32}\n+  };\n+\n+  \/\/ Case A) Special case for length less than or equal to 64 bytes.\n+  __ BIND(L_entry_64);\n+  __ cmpq(count, size_mat[shift][0]);\n+  __ jccb(Assembler::greater, L_entry_128);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case B) Special case for length less than or equal to 128 bytes.\n+  __ BIND(L_entry_128);\n+  __ cmpq(count, size_mat[shift][1]);\n+  __ jccb(Assembler::greater, L_entry_192);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  __ subq(count, 64 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case C) Special case for length less than or equal to 192 bytes.\n+  __ BIND(L_entry_192);\n+  __ cmpq(count, size_mat[shift][2]);\n+  __ jcc(Assembler::greater, L_entry_256);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  __ subq(count, 128 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case D) Special case for length less than or equal to 256 bytes.\n+  __ BIND(L_entry_256);\n+  __ cmpq(count, size_mat[shift][3]);\n+  __ jcc(Assembler::greater, L_entry);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 128, true);\n+  __ subq(count, 192 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 192, true);\n+  __ jmp(L_exit);\n+}\n+\n@@ -1041,0 +1162,25 @@\n+}\n+\n+void StubGenerator::copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1,\n+                                XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                bool conjoint, int shift, int offset) {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ prefetcht0(Address(src, index, scale, offset + 0x200));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x240));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x280));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x2C0));\n+\n+    __ prefetcht0(Address(src, index, scale, offset + 0x400));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x440));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x480));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x4C0));\n+\n+    __ evmovdquq(xmm1, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm2, Address(src, index, scale, offset + 0x40), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm3, Address(src, index, scale, offset + 0x80), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm4, Address(src, index, scale, offset + 0xC0), Assembler::AVX_512bit);\n+\n+    __ evmovntdquq(Address(dst, index, scale, offset), xmm1, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x40), xmm2, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x80), xmm3, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0xC0), xmm4, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":147,"deletions":1,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayCriticalXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}PrimitiveArrayCritical to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayCriticalXorOpImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayElementsXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}ByteArrayElements to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayElementsXorOpImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+\/\/ import static java.lang.foreign.Linker.Option.isTrivial;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.OfBoolean;\n+import static java.lang.foreign.ValueLayout.OfByte;\n+import static java.lang.foreign.ValueLayout.OfDouble;\n+import static java.lang.foreign.ValueLayout.OfFloat;\n+import static java.lang.foreign.ValueLayout.OfInt;\n+import static java.lang.foreign.ValueLayout.OfLong;\n+import static java.lang.foreign.ValueLayout.OfShort;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayForeignXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func\/*, isTrivial()*\/);\n+    }\n+\n+    static final MethodHandle xor_op;\n+    static final Arena arena = Arena.ofConfined();\n+    MemorySegment srcBuf;\n+    MemorySegment dstBuf;\n+\n+    GetArrayForeignXorOpImpl(int len) {\n+        srcBuf = arena.allocate(len);\n+        dstBuf = arena.allocate(len);\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment srcBuf = arena.allocate(len);\n+            MemorySegment.copy(src, sOff, srcBuf, JAVA_BYTE, 0, len);\n+            MemorySegment dstBuf = arena.allocate(len);\n+            MemorySegment.copy(dst, dOff, dstBuf, JAVA_BYTE, 0, len);\n+            xor_op.invokeExact(srcBuf, dstBuf, len);\n+            MemorySegment.copy(dstBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+\n+    public void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len) {\n+        for (int i = 0; i < count; i++) {\n+            MemorySegment.copy(src, sOff, srcBuf, JAVA_BYTE, 0, len);\n+            MemorySegment.copy(dst, dOff, dstBuf, JAVA_BYTE, 0, len);\n+            MemorySegment.copy(srcBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpImpl.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayRegionXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    public GetArrayRegionXorOpImpl() {\n+    }\n+\n+    \/\/ Uses {Get|Set}ByteArrayRegion to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+\n+    public native void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayRegionXorOpImpl.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public interface XorOp {\n+\n+    void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable;\n+\n+    void copy(int count, byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorOp.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+\n+public class XorTest {\n+\n+    XorOp impl = null;\n+    int count;\n+    int alen;\n+    int off;\n+    int len;\n+    byte[] src, dst;\n+\n+    @Param\n+    SizeKind sizeKind;\n+\n+    @Param\n+    ArrayKind arrayKind;\n+\n+    public enum SizeKind {\n+        SMALL,\n+        MEDIUM,\n+        LARGE;\n+    }\n+\n+    public enum ArrayKind {\n+        ELEMENTS,\n+        REGION,\n+        CRITICAL,\n+        FOREIGN;\n+    }\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        switch (sizeKind) {\n+            case SMALL:\n+                count = 1000;\n+                alen = 1048576;             \/\/ 1 MB\n+                off = 1024 * 10;\n+                len = 1024 * 100;           \/\/ 100 KB\n+                break;\n+            case MEDIUM:\n+                count = 50;\n+                alen = 1048576 * 8;         \/\/ 8 MB\n+                off = 1048576 * 1;\n+                len = 1048576 * 2;          \/\/ 2 MB\n+                break;\n+            case LARGE:\n+                count = 10;\n+                alen = 1048576 * 100;       \/\/ 100 MB\n+                off = 1048576 * 5;\n+                len = 1048576 * 10;         \/\/ 10 MB\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(sizeKind.toString());\n+        }\n+\n+        switch (arrayKind) {\n+            case CRITICAL:\n+                impl = new GetArrayCriticalXorOpImpl();\n+                break;\n+            case ELEMENTS:\n+                impl = new GetArrayElementsXorOpImpl();\n+                break;\n+            case REGION:\n+                impl = new GetArrayRegionXorOpImpl();\n+                break;\n+            case FOREIGN:\n+                impl = new GetArrayForeignXorOpImpl(alen);\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(arrayKind.toString());\n+        }\n+\n+        src = new byte[alen];\n+        dst = new byte[alen];\n+        Arrays.fill(src, off, off + len, (byte)0xaa);\n+        Arrays.fill(dst, off, off + len, (byte)0x5a);\n+        check();\n+    }\n+\n+    void check() throws Throwable {\n+        impl.copy(count, src, off, dst, off, len);\n+        if (arrayKind != ArrayKind.CRITICAL && !verify(dst, off, off + len, (byte)0xaa)) {\n+            throw new IllegalStateException(\"Copy failed to verify\");\n+        }\n+        Arrays.fill(src, off, off + len, (byte)0xaa);\n+        Arrays.fill(dst, off, off + len, (byte)0x5a);\n+        impl.xor(src, off, dst, off, len);\n+        if (!verify(dst, off, off + len, (byte)0xf0)) {\n+            throw new IllegalStateException(\"Xor failed to verify\");\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void xor() throws Throwable {\n+        for (int i = 0; i < count; ++i) {\n+            impl.xor(src, off, dst, off, len);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy() throws Throwable {\n+        impl.copy(count, src, off, dst, off, len);\n+    }\n+\n+    static boolean verify(byte[] buf, int start, int end, byte val) {\n+        for (int i = start; i < end; ++i) {\n+            if (buf[i] != val)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+#include <stdlib.h>\n+#include <jni.h>\n+\n+void xor_op(jbyte *restrict src, jbyte *restrict dst, jint len);\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayCriticalXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayCriticalXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetPrimitiveArrayCritical(env, src, &sIsCopy);\n+    dbuf = (*env)->GetPrimitiveArrayCritical(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleasePrimitiveArrayCritical(env, dst, dbuf, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, src, sbuf, JNI_ABORT);\n+    if (sIsCopy) {\n+        fprintf(stderr, \"SRC is copy - GetPrimitiveArrayCritical\\n\");\n+        fflush(stderr);\n+    }\n+    if (dIsCopy) {\n+        fprintf(stderr, \"DST is copy - GetPrimitiveArrayCritical\\n\");\n+        fflush(stderr);\n+    }\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayElementsXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayElementsXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetByteArrayElements(env, src, &sIsCopy);\n+    dbuf = (*env)->GetByteArrayElements(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleaseByteArrayElements(env, dst, dbuf, 0);\n+    (*env)->ReleaseByteArrayElements(env, src, sbuf, JNI_ABORT);\n+    if (sIsCopy) {\n+        \/\/fprintf(stderr, \"SRC is copy - GetByteArrayElements\\n\");\n+        fflush(stderr);\n+    }\n+    if (dIsCopy) {\n+        \/\/fprintf(stderr, \"DST is copy - GetByteArrayElements\\n\");\n+        fflush(stderr);\n+    }\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayRegionXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayRegionXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+\n+    sbuf = malloc(len);\n+    dbuf = malloc(len);\n+\n+    (*env)->GetByteArrayRegion(env, src, sOff, len, sbuf);\n+    (*env)->GetByteArrayRegion(env, dst, dOff, len, dbuf);\n+    xor_op(sbuf, dbuf, len);\n+    (*env)->SetByteArrayRegion(env, dst, dOff, len, dbuf);\n+\n+    free(dbuf);\n+    free(sbuf);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayCriticalXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    for (int i = 0; i < count; i++) {\n+        sbuf = (*env)->GetPrimitiveArrayCritical(env, src, &sIsCopy);\n+        dbuf = (*env)->GetPrimitiveArrayCritical(env, dst, &dIsCopy);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dst, dbuf, JNI_ABORT);\n+        (*env)->ReleasePrimitiveArrayCritical(env, src, sbuf, 0);\n+        if (sIsCopy) {\n+            fprintf(stderr, \"SRC is copy - GetPrimitiveArrayCritical\\n\");\n+            fflush(stderr);\n+        }\n+        if (dIsCopy) {\n+            fprintf(stderr, \"DST is copy - GetPrimitiveArrayCritical\\n\");\n+            fflush(stderr);\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayElementsXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    for (int i = 0; i < count; i++) {\n+        dbuf = (*env)->GetByteArrayElements(env, dst, &dIsCopy);\n+        dbuf = (*env)->GetByteArrayElements(env, src, &sIsCopy);\n+        \/\/ (*env)->ReleaseByteArrayElements(env, dst, dbuf, JNI_ABORT);\n+        (*env)->ReleaseByteArrayElements(env, dst, dbuf, 0);\n+        if (sIsCopy) {\n+            \/\/fprintf(stderr, \"SRC is copy - GetByteArrayElements\\n\");\n+            \/\/ fflush(stderr);\n+        }\n+        if (dIsCopy) {\n+            \/\/fprintf(stderr, \"DST is copy - GetByteArrayElements\\n\");\n+            \/\/ fflush(stderr);\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayRegionXorOpImpl_copy\n+  (JNIEnv *env, jobject obj, jint count, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len)\n+{\n+    jbyte *sbuf = malloc(len);\n+    jbyte *dbuf = malloc(len);\n+\n+    for (int i = 0; i < count; i++) {\n+        (*env)->GetByteArrayRegion(env, src, sOff, len, sbuf);\n+        (*env)->GetByteArrayRegion(env, dst, dOff, len, dbuf);\n+        (*env)->SetByteArrayRegion(env, dst, dOff, len, sbuf);\n+    }\n+\n+    free(dbuf);\n+    free(sbuf);\n+}\n+\n+__attribute__((visibility(\"default\")))\n+void xor_op(jbyte *restrict src, jbyte *restrict dst, jint len)\n+{\n+    jint i;\n+\n+    for (i = 0; i < len; ++i) {\n+        dst[i] ^= src[i];\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/libjnitest.c","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}