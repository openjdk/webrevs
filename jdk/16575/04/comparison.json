{"files":[{"patch":"@@ -3420,0 +3420,21 @@\n+void Assembler::evmovntdquq(Address dst, XMMRegister src, int vector_len) {\n+  \/\/ Unmasked instruction\n+  evmovntdquq(dst, k0, src, \/*merge*\/ true, vector_len);\n+}\n+\n+void Assembler::evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0xE7);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  void evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovntdquq(Address dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,0 +190,4 @@\n+  void arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp, Label& L_entry, Label& L_exit);\n+\n@@ -195,0 +199,5 @@\n+  void arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                            Register temp3, Register temp4, Register count,\n+                            XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                            XMMRegister xmm4, int shift);\n+\n@@ -202,0 +211,4 @@\n+  void copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1, XMMRegister xmm2,\n+                                XMMRegister xmm3, XMMRegister xmm4, bool conjoint, int shift,\n+                                 int offset = 0);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  const int large_threshold = 2621440; \/\/ 2.5 MB\n@@ -520,0 +521,1 @@\n+  Label L_copy_large, L_finish;\n@@ -580,0 +582,6 @@\n+    if (MaxVectorSize == 64) {\n+      __ movq(temp2, temp1);\n+      __ shlq(temp2, shift);\n+      __ cmpq(temp2, large_threshold);\n+      __ jcc(Assembler::greaterEqual, L_copy_large);\n+    }\n@@ -706,0 +714,1 @@\n+  __ BIND(L_finish);\n@@ -720,0 +729,5 @@\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_copy_large);\n+    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+    __ jmp(L_finish);\n+  }\n@@ -723,0 +737,64 @@\n+void StubGenerator::arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                                         Register temp3, Register temp4, Register count,\n+                                         XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                         XMMRegister xmm4, int shift) {\n+\n+  \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+  int loop_size[]        = { 256,     128,       64,      32};\n+  int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+  Label L_main_loop_large;\n+  Label L_tail_large;\n+  Label L_exit_large;\n+  Label L_entry_large;\n+  Label L_main_pre_loop_large;\n+  Label L_pre_main_post_large;\n+\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_entry_large);\n+\n+    __ BIND(L_pre_main_post_large);\n+    \/\/ Partial copy to make dst address 64 byte aligned.\n+    __ movq(temp2, to);\n+    __ andq(temp2, 63);\n+    __ jcc(Assembler::equal, L_main_pre_loop_large);\n+\n+    __ negptr(temp2);\n+    __ addq(temp2, 64);\n+    if (shift) {\n+      __ shrq(temp2, shift);\n+    }\n+    __ movq(temp3, temp2);\n+    copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0);\n+    __ movq(temp4, temp2);\n+    __ movq(temp1, count);\n+    __ subq(temp1, temp2);\n+\n+    __ cmpq(temp1, loop_size[shift]);\n+    __ jcc(Assembler::less, L_tail_large);\n+\n+    __ BIND(L_main_pre_loop_large);\n+    __ subq(temp1, loop_size[shift]);  \/\/ whay is this here\n+\n+    \/\/ Main loop with aligned copy block size of 256 bytes at 64 byte copy granularity.\n+    __ align32();\n+    __ BIND(L_main_loop_large);\n+    copy256_avx3(to, from, temp4, xmm1, xmm2, xmm3, xmm4, false, shift, 0);\n+    __ addptr(temp4, loop_size[shift]);\n+    __ subq(temp1, loop_size[shift]);\n+    __ jcc(Assembler::greater, L_main_loop_large);\n+    \/\/ fence needed because copy256_avx 3 uses non-temporal stores\n+    __ sfence();\n+\n+    __ addq(temp1, loop_size[shift]);\n+    \/\/ Zero length check.\n+    __ jcc(Assembler::lessEqual, L_exit_large);\n+    __ BIND(L_tail_large);\n+    \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+    __ cmpq(temp1, 0);\n+    __ jcc(Assembler::lessEqual, L_exit_large);\n+    arraycopy_avx3_special_cases_256(xmm1, k2, from, to, temp1, shift,\n+                                 temp4, temp3, L_entry_large, L_exit_large);\n+    __ BIND(L_exit_large);\n+  }\n+}\n@@ -968,0 +1046,52 @@\n+void StubGenerator::arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                                     Register to, Register count, int shift, Register index,\n+                                                     Register temp, Label& L_entry, Label& L_exit) {\n+  Label L_entry_64, L_entry_128, L_entry_192, L_entry_256;\n+\n+  int size_mat[][4] = {\n+  \/* T_BYTE *\/ {64, 128, 192, 256},\n+  \/* T_SHORT*\/ {32, 64 , 96 , 128},\n+  \/* T_INT  *\/ {16, 32 , 48 ,  64},\n+  \/* T_LONG *\/ { 8, 16 , 24 ,  32}\n+  };\n+\n+  if (MaxVectorSize == 64) {\n+    \/\/ Case A) Special case for length less than or equal to 64 bytes.\n+    __ BIND(L_entry_64);\n+    __ cmpq(count, size_mat[shift][0]);\n+    __ jccb(Assembler::greater, L_entry_128);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case B) Special case for length less than or equal to 128 bytes.\n+    __ BIND(L_entry_128);\n+    __ cmpq(count, size_mat[shift][1]);\n+    __ jccb(Assembler::greater, L_entry_192);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    __ subq(count, 64 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case C) Special case for length less than or equal to 192 bytes.\n+    __ BIND(L_entry_192);\n+    __ cmpq(count, size_mat[shift][2]);\n+    __ jcc(Assembler::greater, L_entry_256);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+    __ subq(count, 128 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128, true);\n+    __ jmp(L_exit);\n+\n+    \/\/ Case D) Special case for length less than or equal to 256 bytes.\n+    __ BIND(L_entry_256);\n+    __ cmpq(count, size_mat[shift][3]);\n+    __ jcc(Assembler::greater, L_entry);\n+    copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+    copy64_avx(to, from, index, xmm, false, shift, 128, true);\n+    __ subq(count, 192 >> shift);\n+    copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 192, true);\n+    __ jmp(L_exit);\n+  }\n+}\n+\n@@ -1043,0 +1173,27 @@\n+void StubGenerator::copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1,\n+                                XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                bool conjoint, int shift, int offset) {\n+  if (MaxVectorSize == 64) {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ prefetcht0(Address(src, index, scale, offset + 0x200));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x240));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x280));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x2C0));\n+\n+    __ prefetcht0(Address(src, index, scale, offset + 0x400));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x440));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x480));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x4C0));\n+\n+    __ evmovdquq(xmm1, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm2, Address(src, index, scale, offset + 0x40), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm3, Address(src, index, scale, offset + 0x80), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm4, Address(src, index, scale, offset + 0xC0), Assembler::AVX_512bit);\n+\n+    __ evmovntdquq(Address(dst, index, scale, offset), xmm1, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x40), xmm2, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x80), xmm3, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0xC0), xmm4, Assembler::AVX_512bit);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark measuring aligned System.arraycopy.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class ArrayCopyAlignedLarge {\n+\n+    @Param({\"100000\", \"1000000\", \"2000000\", \"5000000\", \"10000000\"})\n+    int length;\n+\n+    int fromPos, toPos;\n+    byte[] fromByteArr, toByteArr;\n+\n+    @Setup\n+    public void setup() {\n+        \/\/ Both positions aligned\n+        fromPos = 0;\n+        toPos = 0;\n+\n+        fromByteArr = new byte[length];\n+        toByteArr = new byte[length];\n+    }\n+\n+    @Benchmark\n+    public void testByte() {\n+        System.arraycopy(fromByteArr, fromPos, toByteArr, toPos, length);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ArrayCopyAlignedLarge.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}