{"files":[{"patch":"@@ -1450,0 +1450,6 @@\n+    `report-on-exit=`*identifier*\n+    :   Specifies the name of the view to display when the Java Virtual Machine\n+        (JVM) shuts down. This option is not available if the disk option is set\n+        to false. For a list of available views, see `jfr help view`. By default,\n+        no report is generated.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.jfr.internal.query.Report;\n@@ -66,1 +67,0 @@\n-\n@@ -157,0 +157,4 @@\n+    synchronized boolean isInShutDown() {\n+        return this.inShutdown;\n+    }\n+\n@@ -177,0 +181,1 @@\n+        writeReports();\n@@ -188,0 +193,10 @@\n+    private void writeReports() {\n+        for (PlatformRecording recording : getRecordings()) {\n+            if (recording.isToDisk() && recording.getState() == RecordingState.STOPPED) {\n+                for (Report report : recording.getReports()) {\n+                    report.print(recording.getStartTime(), recording.getStopTime());\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.jfr.internal.query.Report;\n@@ -86,0 +87,1 @@\n+    private final List<Report> reports = new ArrayList<>();\n@@ -174,1 +176,4 @@\n-                close(); \/\/ remove if copied out\n+                boolean reportOnExit = recorder.isInShutDown() && !reports.isEmpty();\n+                if (!reportOnExit) {\n+                    close(); \/\/ remove if copied out, unless we are in shutdown and there are reports to report.\n+                }\n@@ -925,0 +930,8 @@\n+\n+    public void addReport(Report report) {\n+       reports.add(report);\n+    }\n+\n+    public List<Report> getReports() {\n+        return reports;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    private volatile boolean waitForChunks = true;\n@@ -112,0 +113,8 @@\n+    public final void setWaitForChunks(boolean wait) {\n+        waitForChunks = wait;\n+    }\n+\n+    protected final boolean getWaitForChunks() {\n+        return waitForChunks;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-                path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos, true);\n+                path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos, getWaitForChunks());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            ArgumentParser parser = new ArgumentParser(getArgumentInfos(), arg, delimiter);\n+            ArgumentParser parser = new ArgumentParser(getParseArguments(source), arg, delimiter);\n@@ -101,0 +101,4 @@\n+    protected Argument[] getParseArguments(String source) {\n+        return getArgumentInfos();\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+        configuration.verboseTimespan = true;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdQuery.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.Arrays;\n+import java.util.HashMap;\n@@ -54,0 +56,1 @@\n+import jdk.jfr.internal.query.Report;\n@@ -85,0 +88,1 @@\n+        List<String> reports = parser.getOption(\"report-on-exit\");\n@@ -159,0 +163,1 @@\n+        PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n@@ -171,1 +176,0 @@\n-                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n@@ -188,2 +192,1 @@\n-            PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);\n-            p.setFlushInterval(Duration.ofNanos(flush));\n+            pr.setFlushInterval(Duration.ofNanos(flush));\n@@ -204,0 +207,4 @@\n+        if (reports != null) {\n+            addReports(pr, reports);\n+        }\n+\n@@ -238,0 +245,14 @@\n+    \n+    \/\/ Add report-on-exit for -XX:StartFlightRecording\n+    @Override\n+    protected Argument[] getParseArguments(String source) {\n+        Argument[] argumentInfo = getArgumentInfos();;\n+        if (!\"internal\".equals(source)) {\n+            return argumentInfo;\n+        }\n+        Argument[] newArray = Arrays.copyOf(argumentInfo, argumentInfo.length + 1);\n+        newArray[argumentInfo.length] = new Argument(\"report-on-exit\",\n+                \"Display views on exit. See 'jfr help view' for available views to report.\",\n+                \"STRING SET\", false, true, null, true);\n+        return newArray;\n+    }\n@@ -251,0 +272,18 @@\n+    private void addReports(PlatformRecording recording, List<String> reportNames) throws DCmdException {\n+        if (!recording.isToDisk()) {\n+            throw new DCmdException(\"Option report-on-exit can only be used when recording to disk.\");\n+        }\n+        Map<String, Report> reportLookup = new HashMap<>();\n+        for (Report report : Report.getReports()) {\n+            reportLookup.put(report.name(), report);\n+        }\n+        for (String name : reportNames) {\n+            Report report = reportLookup.get(name);\n+            if (report != null) {\n+                recording.addReport(report);\n+            } else {\n+                throw new DCmdException(\"Unknown view '\" + name + \"' specified for report-on-exit. Use 'jfr help view' to see a list of available views.\");\n+            }\n+        }\n+    }\n+\n@@ -325,0 +364,1 @@\n+            \"$REPORT_ON_EXIT\", reportOnExit(),\n@@ -339,0 +379,1 @@\n+           \"$REPORT_ON_EXIT\", \"\",\n@@ -407,1 +448,1 @@\n-\n+                 $REPORT_ON_EXIT\n@@ -457,0 +498,11 @@\n+    }\n+\n+    private static String reportOnExit() {\n+        return\n+        \"\"\"\n+\n+          report-on-exit   Specifies the name of the view to display when the Java Virtual\n+                           Machine (JVM) shuts down. This option is not available if disk\n+                           the disk option is set to false. For a list of available views,\n+                           see 'jfr help view'. By default, no report is generated.\n+        \"\"\";\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":56,"deletions":4,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+        configuration.verboseTimespan = true;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-final class QueryRecording implements AutoCloseable {\n+public final class QueryRecording implements AutoCloseable {\n@@ -55,0 +55,10 @@\n+    public QueryRecording(Instant startTime, Instant endTime) throws IOException {\n+        this.recorder = PrivateAccess.getInstance().getPlatformRecorder();\n+        this.endTime = endTime;\n+        this.chunks = acquireChunks(startTime);\n+        if (chunks.isEmpty()) {\n+            throw new IOException(\"No recording data found on disk.\");\n+        }\n+        eventStream = makeStream(startTime);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,5 @@\n+    \/**\n+     * If the timespan of the table or form should be printed.\n+     *\/\n+    public boolean verboseTimespan;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Configuration.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-            if (configuration.startTime != null) {\n+            if (configuration.verboseTimespan) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.query;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.List;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.consumer.AbstractEventStream;\n+import jdk.jfr.internal.dcmd.QueryRecording;\n+import jdk.jfr.internal.util.Output.BufferedPrinter;\n+import jdk.jfr.internal.util.UserDataException;\n+import jdk.jfr.internal.util.UserSyntaxException;\n+\n+public record Report(String name) {\n+\n+    public static List<Report> getReports() {\n+        return ViewFile.getDefault().getViewConfigurations() .stream().map(view -> new Report(view.name())).toList();\n+    }\n+\n+    public void print(Instant startTime, Instant endTime) {\n+        Logger.log(LogTag.JFR, LogLevel.DEBUG, \"Writing report \" + name);\n+        BufferedPrinter output = new BufferedPrinter(System.out);\n+        try (QueryRecording qr = new QueryRecording(startTime, endTime)) {\n+            AbstractEventStream stream = (AbstractEventStream) qr.getStream();\n+            stream.setWaitForChunks(false);\n+            Configuration configuration = new Configuration();\n+            configuration.startTime = startTime;\n+            configuration.endTime = endTime;\n+            configuration.output = output;\n+            ViewPrinter printer = new ViewPrinter(configuration, stream);\n+            printer.execute(name);\n+            Logger.log(LogTag.JFR, LogLevel.DEBUG, \"Report \" + name + \" written successfully.\");\n+        } catch (IOException | UserDataException | UserSyntaxException e) {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"Error writing report \" + name + \" on exit: \" + e.getMessage());\n+        }\n+        output.flush();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Report.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,1 @@\n-        if (configuration.startTime != null) {\n+        if (configuration.verboseTimespan) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/ViewPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.startupargs;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main jdk.jfr.startupargs.TestStartReportOnExit\n+ *\/\n+public class TestStartReportOnExit {\n+\n+    public static void main(String[] args) throws Exception {\n+        testSingleReport();\n+        testMultipleReports();\n+        testMultipleRecordings();\n+        testUnstopped();\n+        testInvalidName();\n+        testWithDump();\n+        testWithMemory();\n+    }\n+\n+    private static void testSingleReport() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:report-on-exit=jvm-information\", \"-version\");\n+        expectJVMInformation(out);\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testMultipleReports() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:report-on-exit=jvm-information,report-on-exit=system-properties\", \"-version\");\n+        expectJVMInformation(out);\n+        expectSystemProperties(out);\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testMultipleRecordings() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:report-on-exit=jvm-information\", \"-XX:StartFlightRecording:report-on-exit=system-properties\", \"-version\");\n+        expectJVMInformation(out);\n+        expectSystemProperties(out);\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testUnstopped() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:delay=20h,report-on-exit=jvm-information\", \"-version\");\n+        out.shouldNotContain(\"JVM Information\");\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testInvalidName() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:report-on-exit=invalid\", \"-version\");\n+        out.shouldContain(\"Unknown view 'invalid' specified for report-on-exit\");\n+        out.shouldNotHaveExitValue(0);\n+    }\n+\n+    private static void testWithDump() throws Exception {\n+        Path path = Path.of(\"dump.jfr\").toAbsolutePath();\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:filename=\" + path.toString() + \",report-on-exit=jvm-information\", \"-version\");\n+        expectJVMInformation(out);\n+        out.shouldHaveExitValue(0);\n+        RecordingFile.readAllEvents(path);\n+    }\n+\n+    private static void testWithMemory() throws Exception {\n+        OutputAnalyzer out = launch(\"-XX:StartFlightRecording:report-on-exit=jvm-information,disk=false\", \"-version\");\n+        out.shouldContain(\"Option report-on-exit can only be used when recording to disk.\");\n+        out.shouldNotHaveExitValue(0);\n+    }\n+\n+    private static void expectJVMInformation(OutputAnalyzer out) throws Exception {\n+        out.shouldContain(\"JVM Information\");\n+        out.shouldContain(\"PID:\");\n+        out.shouldContain(\"Program Arguments:\");\n+    }\n+\n+    private static void expectSystemProperties(OutputAnalyzer out) throws Exception {\n+        out.shouldContain(\"System Properties at Startup\");\n+        out.shouldContain(\"java.vm.specification.name\");\n+    }\n+\n+    private static OutputAnalyzer launch(String... arguments) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(arguments);\n+        return ProcessTools.executeProcess(pb);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestStartReportOnExit.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}