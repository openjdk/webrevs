{"files":[{"patch":"@@ -2633,0 +2633,4 @@\n+\n+  if (handle_safefetch(exception_code, pc, (void*)exceptionInfo->ContextRecord)) {\n+    return EXCEPTION_CONTINUE_EXECUTION;\n+  }\n@@ -2635,4 +2639,0 @@\n-#else\n-  #error unknown architecture\n-#endif\n-  Thread* t = Thread::current_or_null_safe();\n@@ -2640,1 +2640,0 @@\n-#if defined(_M_AMD64)\n@@ -2653,0 +2652,2 @@\n+#else\n+  #error unknown architecture\n@@ -2663,0 +2664,1 @@\n+  Thread* t = Thread::current_or_null_safe();\n@@ -2693,1 +2695,0 @@\n-#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2696,1 +2697,0 @@\n-#endif\n@@ -2748,1 +2748,0 @@\n-#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2751,1 +2750,0 @@\n-#endif\n@@ -2811,8 +2809,1 @@\n-#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n-  if (exception_code != EXCEPTION_BREAKPOINT) {\n-    report_error(t, exception_code, pc, exception_record,\n-                 exceptionInfo->ContextRecord);\n-  }\n-#endif\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n+  bool should_report_error = (exception_code != EXCEPTION_BREAKPOINT);\n@@ -2820,3 +2811,0 @@\n-#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n-LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n@@ -2824,5 +2812,3 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Pc;\n-#elif defined(_M_AMD64)\n-  address pc = (address) exceptionInfo->ContextRecord->Rip;\n-#else\n-  #error unknown architecture\n+  should_report_error = should_report_error &&\n+                        FAILED(exception_code) &&\n+                        (exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION);\n@@ -2831,10 +2817,3 @@\n-  \/\/ Fast path for code part of the code cache\n-  if (CodeCache::low_bound() <= pc && pc < CodeCache::high_bound()) {\n-    return topLevelExceptionFilter(exceptionInfo);\n-  }\n-\n-  \/\/ If the exception occurred in the codeCache, pass control\n-  \/\/ to our normal exception handler.\n-  CodeBlob* cb = CodeCache::find_blob(pc);\n-  if (cb != nullptr) {\n-    return topLevelExceptionFilter(exceptionInfo);\n+  if (should_report_error) {\n+    report_error(t, exception_code, pc, exception_record,\n+                 exceptionInfo->ContextRecord);\n@@ -2845,1 +2824,0 @@\n-#endif\n@@ -4522,1 +4500,1 @@\n-  topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelVectoredExceptionFilter);\n+  topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelExceptionFilter);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":15,"deletions":37,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -153,0 +153,2 @@\n+\n+  static void context_set_pc(CONTEXT* uc, address pc);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"os_windows.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef SAFEFETCH_METHOD_STATIC_ASSEMBLY\n+\n+\/\/ SafeFetch handling, static assembly style:\n+\/\/\n+\/\/ SafeFetch32 and SafeFetchN are implemented via static assembly\n+\/\/ and live in os_cpu\/xx_xx\/safefetch_xx_xx.S\n+\n+extern \"C\" char _SafeFetch32_continuation[];\n+extern \"C\" char _SafeFetch32_fault[];\n+\n+#ifdef _LP64\n+extern \"C\" char _SafeFetchN_continuation[];\n+extern \"C\" char _SafeFetchN_fault[];\n+#endif \/\/ _LP64\n+\n+bool handle_safefetch(int exception_code, address pc, void* context) {\n+  CONTEXT* ctx = (CONTEXT*)context;\n+  if (exception_code == EXCEPTION_ACCESS_VIOLATION && ctx != nullptr) {\n+    if (pc == (address)_SafeFetch32_fault) {\n+      os::win32::context_set_pc(ctx, (address)_SafeFetch32_continuation);\n+      return true;\n+    }\n+#ifdef _LP64\n+    if (pc == (address)_SafeFetchN_fault) {\n+      os::win32::context_set_pc(ctx, (address)_SafeFetchN_continuation);\n+      return true;\n+    }\n+#endif\n+  }\n+  return false;\n+}\n+\n+#endif \/\/ SAFEFETCH_METHOD_STATIC_ASSEMBLY\n","filename":"src\/hotspot\/os\/windows\/safefetch_static_windows.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -118,0 +118,4 @@\n+void os::win32::context_set_pc(CONTEXT* uc, address pc) {\n+  uc->Pc = (intptr_t)pc;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+;\n+; Copyright (c) 2022 SAP SE. All rights reserved.\n+; Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+;\n+; This code is free software; you can redistribute it and\/or modify it\n+; under the terms of the GNU General Public License version 2 only, as\n+; published by the Free Software Foundation.\n+;\n+; This code is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; version 2 for more details (a copy is included in the LICENSE file that\n+; accompanied this code).\n+;\n+; You should have received a copy of the GNU General Public License version\n+; 2 along with this work; if not, write to the Free Software Foundation,\n+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+;\n+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+; or visit www.oracle.com if you need additional information or have any\n+; questions.\n+;\n+\n+    ; Support for int SafeFetch32(int* address, int defaultval);\n+    ;\n+    ;  x0 : address\n+    ;  w1 : defaultval\n+\n+    ; needed to align function start to 4 byte\n+    ALIGN  4\n+    EXPORT _SafeFetch32_fault\n+    EXPORT _SafeFetch32_continuation\n+    EXPORT SafeFetch32_impl\n+    AREA safefetch_text, CODE\n+\n+SafeFetch32_impl\n+_SafeFetch32_fault\n+    ldr w0, [x0]\n+    ret\n+\n+_SafeFetch32_continuation\n+    mov      x0, x1\n+    ret\n+\n+    ; Support for intptr_t SafeFetchN(intptr_t* address, intptr_t defaultval);\n+    ;\n+    ;  x0 : address\n+    ;  x1 : defaultval\n+\n+    ALIGN  4\n+    EXPORT _SafeFetchN_fault\n+    EXPORT _SafeFetchN_continuation\n+    EXPORT SafeFetchN_impl\n+\n+SafeFetchN_impl\n+_SafeFetchN_fault\n+    ldr      x0, [x0]\n+    ret\n+\n+_SafeFetchN_continuation\n+    mov      x0, x1\n+    ret\n+\n+    END\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/safefetch_windows_aarch64.S","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -34,2 +34,2 @@\n-#ifdef _WIN32\n-  \/\/ Windows uses Structured Exception Handling\n+#if defined(_WIN32) && !defined(_M_ARM64)\n+  \/\/ Windows x86_64 uses Structured Exception Handling\n","filename":"src\/hotspot\/share\/runtime\/safefetch.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-            Pattern.compile(\".*Internal Error \\\\(0x2a\\\\).*\")\n+            Pattern.compile(\".*Internal Error \\\\(0xdeadbeef\\\\).*\")\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/UncaughtNativeExceptionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-const DWORD EX_CODE = 42;\n+\/\/ Use an exception code that causes the Windows FAILED() macro to return true.\n+\/\/ Windows AArch64 uses vectored exception handling and therefore runs error\n+\/\/ reporting only for failed exception codes.\n+const DWORD EX_CODE = 0xdeadbeef;\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/libNativeException.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}