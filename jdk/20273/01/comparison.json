{"files":[{"patch":"@@ -3591,1 +3591,1 @@\n-        long len = (long) prefix.length() + suffix.length();\n+        int len = prefix.length() + suffix.length();\n@@ -3593,1 +3593,1 @@\n-            len += (long) (size - 1) * delimiter.length();\n+            len += (size - 1) * delimiter.length();\n@@ -3606,1 +3606,1 @@\n-        if (len < 0L || (len <<= coder) != (int) len) {\n+        if (len < 0L) {\n@@ -3609,1 +3609,1 @@\n-        byte[] value = StringConcatHelper.newArray(len);\n+        byte[] value = StringConcatHelper.newArray(len << coder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -46,82 +47,0 @@\n-    \/**\n-     * Return the coder for the character.\n-     * @param value character\n-     * @return      coder\n-     *\/\n-    static long coder(char value) {\n-        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n-    }\n-\n-    \/**\n-     * Check for overflow, throw exception on overflow.\n-     *\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @return            the given parameter value, if valid\n-     *\/\n-    private static long checkOverflow(long lengthCoder) {\n-        if ((int)lengthCoder >= 0) {\n-            return lengthCoder;\n-        }\n-        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, boolean value) {\n-        return checkOverflow(lengthCoder + (value ? 4 : 5));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, char value) {\n-        return checkOverflow(lengthCoder + 1) | coder(value);\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, int value) {\n-        return checkOverflow(lengthCoder + Integer.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, long value) {\n-        return checkOverflow(lengthCoder + Long.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, String value) {\n-        lengthCoder += value.length();\n-        if (value.coder() == String.UTF16) {\n-            lengthCoder |= UTF16;\n-        }\n-        return checkOverflow(lengthCoder);\n-    }\n-\n@@ -132,2 +51,2 @@\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n@@ -138,3 +57,2 @@\n-    static long prepend(long indexCoder, byte[] buf, boolean value) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n+    static int prepend(int index, byte coder, byte[] buf, boolean value) {\n+        if (coder == String.LATIN1) {\n@@ -153,1 +71,0 @@\n-            return index;\n@@ -167,1 +84,0 @@\n-            return index | UTF16;\n@@ -169,17 +85,1 @@\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n+        return index;\n@@ -192,2 +92,2 @@\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n@@ -198,3 +98,4 @@\n-    static long prepend(long indexCoder, byte[] buf, char value) {\n-        if (indexCoder < UTF16) {\n-            buf[(int)(--indexCoder)] = (byte) (value & 0xFF);\n+    static int prepend(int index, byte coder, byte[] buf, char value) {\n+        index--;\n+        if (coder == String.LATIN1) {\n+            buf[index] = (byte) (value & 0xFF);\n@@ -202,1 +103,1 @@\n-            StringUTF16.putChar(buf, (int)(--indexCoder), value);\n+            StringUTF16.putChar(buf, index, value);\n@@ -204,18 +105,1 @@\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, char value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n+        return index;\n@@ -228,2 +112,2 @@\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n@@ -234,3 +118,3 @@\n-    static long prepend(long indexCoder, byte[] buf, int value) {\n-        if (indexCoder < UTF16) {\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+    static int prepend(int index, byte coder, byte[] buf, int value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n@@ -238,1 +122,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return StringUTF16.getChars(value, index, buf);\n@@ -242,17 +126,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, int value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n@@ -263,2 +130,2 @@\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n@@ -269,3 +136,3 @@\n-    static long prepend(long indexCoder, byte[] buf, long value) {\n-        if (indexCoder < UTF16) {\n-            return StringLatin1.getChars(value, (int)indexCoder, buf);\n+    static int prepend(int index, byte coder, byte[] buf, long value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n@@ -273,1 +140,1 @@\n-            return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;\n+            return StringUTF16.getChars(value, index, buf);\n@@ -277,17 +144,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, long value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n@@ -298,2 +148,2 @@\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n@@ -304,43 +154,4 @@\n-    static long prepend(long indexCoder, byte[] buf, String value) {\n-        indexCoder -= value.length();\n-        if (indexCoder < UTF16) {\n-            value.getBytes(buf, (int)indexCoder, String.LATIN1);\n-        } else {\n-            value.getBytes(buf, (int)indexCoder, String.UTF16);\n-        }\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, String value, String prefix) {\n-        indexCoder = prepend(indexCoder, buf, value);\n-        indexCoder = prepend(indexCoder, buf, prefix);\n-        return indexCoder;\n-    }\n-\n-    \/**\n-     * Instantiates the String with given buffer and coder\n-     * @param buf           buffer to use\n-     * @param indexCoder    remaining index (should be zero) and coder\n-     * @return String       resulting string\n-     *\/\n-    static String newString(byte[] buf, long indexCoder) {\n-        \/\/ Use the private, non-copying constructor (unsafe!)\n-        if (indexCoder == LATIN1) {\n-            return new String(buf, String.LATIN1);\n-        } else if (indexCoder == UTF16) {\n-            return new String(buf, String.UTF16);\n-        } else {\n-            throw new InternalError(\"Storage is not completely initialized, \" +\n-                    (int)indexCoder + \" bytes left\");\n-        }\n+    static int prepend(int index, byte coder, byte[] buf, String value) {\n+        index -= value.length();\n+        value.getBytes(buf, index, coder);\n+        return index;\n@@ -418,4 +229,0 @@\n-    private static final long LATIN1 = (long)String.LATIN1 << 32;\n-\n-    private static final long UTF16 = (long)String.UTF16 << 32;\n-\n@@ -424,22 +231,0 @@\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder\n-     * information, then prepends the given suffix string at the end of the\n-     * byte array before returning it. The calling code must adjust the\n-     * indexCoder so that it's taken the coder of the suffix into account, but\n-     * subtracted the length of the suffix.\n-     *\n-     * @param suffix\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArrayWithSuffix(String suffix, long indexCoder) {\n-        byte[] buf = newArray(indexCoder + suffix.length());\n-        if (indexCoder < UTF16) {\n-            suffix.getBytes(buf, (int)indexCoder, String.LATIN1);\n-        } else {\n-            suffix.getBytes(buf, (int)indexCoder, String.UTF16);\n-        }\n-        return buf;\n-    }\n-\n@@ -453,3 +238,2 @@\n-    static byte[] newArray(long indexCoder) {\n-        byte coder = (byte)(indexCoder >> 32);\n-        int index = ((int)indexCoder) << coder;\n+    static byte[] newArray(int index, byte coder) {\n+        index = index << coder;\n@@ -476,2 +260,10 @@\n-    static long initialCoder() {\n-        return String.COMPACT_STRINGS ? LATIN1 : UTF16;\n+    static byte initialCoder() {\n+        return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n@@ -489,0 +281,3 @@\n+    static MethodHandles.Lookup lookup() {\n+        return MethodHandles.lookup();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":47,"deletions":252,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -2614,2 +2615,2 @@\n-            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n-                return StringConcatHelper.prepend(indexCoder, buf, value);\n+            public MethodHandles.Lookup stringConcatLookup() {\n+                return StringConcatHelper.lookup();\n@@ -2618,1 +2619,1 @@\n-            public long stringConcatInitialCoder() {\n+            public byte stringConcatInitialCoder() {\n@@ -2622,6 +2623,2 @@\n-            public long stringConcatMix(long lengthCoder, String constant) {\n-                return StringConcatHelper.mix(lengthCoder, constant);\n-            }\n-\n-            public long stringConcatMix(long lengthCoder, char value) {\n-                return StringConcatHelper.mix(lengthCoder, value);\n+            public int stringSize(int i) {\n+                return Integer.stringSize(i);\n@@ -2646,0 +2643,8 @@\n+            public byte stringCoder(char value) {\n+                return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -49,0 +50,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -373,0 +376,1 @@\n+        MethodHandle mh;\n@@ -374,4 +378,3 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n+            mh = generateMHInlineCopy(concatType, constantStrings);\n+            if (mh != null) {\n+                mh = mh.viewAsType(concatType, true);\n@@ -379,2 +382,1 @@\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n@@ -388,0 +390,1 @@\n+        return new ConstantCallSite(mh);\n@@ -503,277 +506,0 @@\n-        \/\/ else... fall-through to slow-path\n-\n-        \/\/ Create filters and obtain filtered parameter types. Filters would be used in the beginning\n-        \/\/ to convert the incoming arguments into the arguments we can process (e.g. Objects -> Strings).\n-        \/\/ The filtered argument type list is used all over in the combinators below.\n-\n-        Class<?>[] ptypes = mt.erase().parameterArray();\n-        MethodHandle[] objFilters = null;\n-        MethodHandle[] floatFilters = null;\n-        MethodHandle[] doubleFilters = null;\n-        for (int i = 0; i < ptypes.length; i++) {\n-            Class<?> cl = ptypes[i];\n-            \/\/ Use int as the logical type for subword integral types\n-            \/\/ (byte and short). char and boolean require special\n-            \/\/ handling so don't change the logical type of those\n-            ptypes[i] = promoteToIntType(ptypes[i]);\n-            \/\/ Object, float and double will be eagerly transformed\n-            \/\/ into a (non-null) String as a first step after invocation.\n-            \/\/ Set up to use String as the logical type for such arguments\n-            \/\/ internally.\n-            if (cl == Object.class) {\n-                if (objFilters == null) {\n-                    objFilters = new MethodHandle[ptypes.length];\n-                }\n-                objFilters[i] = objectStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == float.class) {\n-                if (floatFilters == null) {\n-                    floatFilters = new MethodHandle[ptypes.length];\n-                }\n-                floatFilters[i] = floatStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == double.class) {\n-                if (doubleFilters == null) {\n-                    doubleFilters = new MethodHandle[ptypes.length];\n-                }\n-                doubleFilters[i] = doubleStringifier();\n-                ptypes[i] = String.class;\n-            }\n-        }\n-\n-        \/\/ Start building the combinator tree. The tree \"starts\" with (<parameters>)String, and \"finishes\"\n-        \/\/ with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are\n-        \/\/ assembled bottom-up, which makes the code arguably hard to read.\n-\n-        \/\/ Drop all remaining parameter types, leave only helper arguments:\n-        MethodHandle mh = MethodHandles.dropArgumentsTrusted(newString(), 2, ptypes);\n-\n-        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n-        \/\/ their lengths and adjusting the encoded coder bit if needed\n-        long initialLengthCoder = INITIAL_CODER;\n-\n-        for (String constant : constants) {\n-            if (constant != null) {\n-                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constant);\n-            }\n-        }\n-\n-        \/\/ Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already\n-        \/\/ known from the combinators below. We are assembling the string backwards, so the index coded\n-        \/\/ into indexCoder is the *ending* index.\n-        mh = filterInPrependers(mh, constants, ptypes);\n-\n-        \/\/ Fold in byte[] instantiation at argument 0\n-        MethodHandle newArrayCombinator;\n-        if (suffix != null) {\n-            \/\/ newArray variant that deals with prepending any trailing constant\n-            \/\/\n-            \/\/ initialLengthCoder is adjusted to have the correct coder\n-            \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n-            \/\/ suffix to be encoded into indexCoder\n-            initialLengthCoder -= suffix.length();\n-            newArrayCombinator = newArrayWithSuffix(suffix);\n-        } else {\n-            newArrayCombinator = newArray();\n-        }\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1 \/\/ index\n-        );\n-\n-        \/\/ Start combining length and coder mixers.\n-        \/\/\n-        \/\/ Length is easy: constant lengths can be computed on the spot, and all non-constant\n-        \/\/ shapes have been either converted to Strings, or explicit methods for getting the\n-        \/\/ string length out of primitives are provided.\n-        \/\/\n-        \/\/ Coders are more interesting. Only Object, String and char arguments (and constants)\n-        \/\/ can have non-Latin1 encoding. It is easier to blindly convert constants to String,\n-        \/\/ and deduce the coder from there. Arguments would be either converted to Strings\n-        \/\/ during the initial filtering, or handled by specializations in MIXERS.\n-        \/\/\n-        \/\/ The method handle shape before all mixers are combined in is:\n-        \/\/   (long, <args>)String = (\"indexCoder\", <args>)\n-        \/\/\n-        \/\/ We will bind the initialLengthCoder value to the last mixer (the one that will be\n-        \/\/ executed first), then fold that in. This leaves the shape after all mixers are\n-        \/\/ combined in as:\n-        \/\/   (<args>)String = (<args>)\n-\n-        mh = filterAndFoldInMixers(mh, initialLengthCoder, ptypes);\n-\n-        \/\/ The method handle shape here is (<args>).\n-\n-        \/\/ Apply filters, converting the arguments:\n-        if (objFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, objFilters);\n-        }\n-        if (floatFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, floatFilters);\n-        }\n-        if (doubleFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, doubleFilters);\n-        }\n-\n-        return mh;\n-    }\n-\n-    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n-    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n-    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n-    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n-    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n-    private static MethodHandle filterInPrependers(MethodHandle mh, String[] constants, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        MethodHandle prepend;\n-        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n-            prepend = prepender(pos, constants, ptypes, 4);\n-            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        if (pos < ptypes.length) {\n-            int count = ptypes.length - pos;\n-            prepend = prepender(pos, constants, ptypes, count);\n-            argPositions = filterPrependArgPositions(argPositions, pos, count);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 2];\n-            argPositions[0] = 1; \/\/ indexCoder\n-            argPositions[1] = 0; \/\/ storage\n-        }\n-        int limit = count + 2;\n-        for (int i = 2; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-\n-    \/\/ We need one mixer per argument.\n-    private static MethodHandle filterAndFoldInMixers(MethodHandle mh, long initialLengthCoder, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n-            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n-            MethodHandle mix = mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            argPositions = filterMixerArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n-                    mix, argPositions);\n-        }\n-\n-        if (pos < ptypes.length) {\n-            \/\/ Mix in the last 1 to 4 parameters, insert the initialLengthCoder into the final mixer and\n-            \/\/ fold the result into the main combinator\n-            mh = foldInLastMixers(mh, initialLengthCoder, pos, ptypes, ptypes.length - pos);\n-        } else if (ptypes.length == 0) {\n-            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n-            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterMixerArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 1];\n-            argPositions[0] = 0; \/\/ indexCoder\n-        }\n-        int limit = count + 1;\n-        for (int i = 1; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-    private static MethodHandle foldInLastMixers(MethodHandle mh, long initialLengthCoder, int pos, Class<?>[] ptypes, int count) {\n-        MethodHandle mix = switch (count) {\n-            case 1 -> mixer(ptypes[pos]);\n-            case 2 -> mixer(ptypes[pos], ptypes[pos + 1]);\n-            case 3 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            case 4 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        };\n-        mix = MethodHandles.insertArguments(mix,0, initialLengthCoder);\n-        \/\/ apply selected arguments on the 1-4 arg mixer and fold in the result\n-        return switch (count) {\n-            case 1 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos);\n-            case 2 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos);\n-            case 3 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos);\n-            case 4 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos, 4 + pos);\n-            default -> throw new IllegalArgumentException();\n-        };\n-    }\n-\n-    \/\/ Simple prependers, single argument. May be used directly or as a\n-    \/\/ building block for complex prepender combinators.\n-    private static MethodHandle prepender(String prefix, Class<?> cl) {\n-        if (prefix == null || prefix.isEmpty()) {\n-            return noPrefixPrepender(cl);\n-        } else {\n-            return MethodHandles.insertArguments(\n-                    prepender(cl), 3, prefix);\n-        }\n-    }\n-\n-    private static MethodHandle prepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = PREPENDERS[idx];\n-        if (prepend == null) {\n-            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(long.class, long.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n-        if (prepend == null) {\n-            NO_PREFIX_PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(long.class, long.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static final int INT_IDX = 0,\n-            CHAR_IDX = 1,\n-            LONG_IDX = 2,\n-            BOOLEAN_IDX = 3,\n-            STRING_IDX = 4,\n-            TYPE_COUNT = 5;\n-    private static int classIndex(Class<?> cl) {\n-        if (cl == String.class)                          return STRING_IDX;\n-        if (cl == int.class)                             return INT_IDX;\n-        if (cl == boolean.class)                         return BOOLEAN_IDX;\n-        if (cl == char.class)                            return CHAR_IDX;\n-        if (cl == long.class)                            return LONG_IDX;\n-        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n-    }\n-\n-    \/\/ Constant argument lists used by the prepender MH builders\n-    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2 };\n-    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 3 };\n-    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 4 };\n-    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3 };\n-    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 4, 5 };\n-\n-    \/\/ Base MH for complex prepender combinators.\n-    private static @Stable MethodHandle PREPEND_BASE;\n-    private static MethodHandle prependBase() {\n-        MethodHandle base = PREPEND_BASE;\n-        if (base == null) {\n-            base = PREPEND_BASE = MethodHandles.dropArguments(\n-                    MethodHandles.identity(long.class), 1, byte[].class);\n-        }\n-        return base;\n-    }\n@@ -781,89 +507,1 @@\n-    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-\n-    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n-        if (prepend == null) {\n-            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n-                    MethodHandles.dropArguments(prependBase(), 2, cl, cl2);\n-        }\n-        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n-                PREPEND_FILTER_FIRST_ARGS);\n-        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n-                PREPEND_FILTER_SECOND_ARGS);\n-    }\n-\n-    private static MethodHandle prepender(int pos, String[] constants, Class<?>[] ptypes, int count) {\n-        \/\/ build the simple cases directly\n-        if (count == 1) {\n-            return prepender(constants[pos], ptypes[pos]);\n-        }\n-        if (count == 2) {\n-            return prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]);\n-        }\n-        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n-        MethodHandle prepend = prependBase();\n-        if (count == 3) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2]),\n-                    PREPEND_FILTER_THIRD_ARGS);\n-        } else if (count == 4) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2], constants[pos + 3], ptypes[pos + 3]),\n-                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        }\n-    }\n-\n-    \/\/ Constant argument lists used by the mixer MH builders\n-    private static final int[] MIX_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n-    private static final int[] MIX_FILTER_THIRD_ARGS  = new int[] { 0, 3 };\n-    private static final int[] MIX_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n-    private static MethodHandle mixer(Class<?> cl) {\n-        int index = classIndex(cl);\n-        MethodHandle mix = MIXERS[index];\n-        if (mix == null) {\n-            MIXERS[index] = mix = JLA.stringConcatHelper(\"mix\",\n-                    methodType(long.class, long.class, Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return mix;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_MIXERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle mix = DOUBLE_MIXERS[idx1][idx2];\n-        if (mix == null) {\n-            mix = mixer(cl);\n-            mix = MethodHandles.dropArguments(mix, 2, cl2);\n-            DOUBLE_MIXERS[idx1][idx2] = mix = MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                    mixer(cl2), MIX_FILTER_SECOND_ARGS);\n-        }\n-        return mix;\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3), MIX_FILTER_THIRD_ARGS);\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3, cl4);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3, cl4), MIX_FILTER_SECOND_PAIR_ARGS);\n+        return null;\n@@ -888,1 +526,1 @@\n-                    methodType(String.class, byte[].class, long.class));\n+                    methodType(String.class, byte[].class, byte.class));\n@@ -899,1 +537,1 @@\n-                    methodType(byte[].class, String.class, long.class));\n+                    methodType(byte[].class, String.class, int.class, byte.class));\n@@ -910,1 +548,1 @@\n-                    JLA.stringConcatHelper(\"newArray\", methodType(byte[].class, long.class));\n+                    JLA.stringConcatHelper(\"newArray\", methodType(byte[].class, int.class, byte.class));\n@@ -920,9 +558,0 @@\n-    private @Stable static MethodHandle OBJECT_STRINGIFIER;\n-    private static MethodHandle objectStringifier() {\n-        MethodHandle mh = OBJECT_STRINGIFIER;\n-        if (mh == null) {\n-            OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(\"stringOf\",\n-                    methodType(String.class, Object.class));\n-        }\n-        return mh;\n-    }\n@@ -1012,32 +641,0 @@\n-    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] PREPENDERS      = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] MIXERS          = new MethodHandle[TYPE_COUNT];\n-    private static final long INITIAL_CODER = JLA.stringConcatInitialCoder();\n-\n-    \/**\n-     * Promote integral types to int.\n-     *\/\n-    private static Class<?> promoteToIntType(Class<?> t) {\n-        \/\/ use int for subword integral types; still need special mixers\n-        \/\/ and prependers for char, boolean\n-        return t == byte.class || t == short.class ? int.class : t;\n-    }\n-\n-    \/**\n-     * Returns a stringifier for references and floats\/doubles only.\n-     * Always returns null for other primitives.\n-     *\n-     * @param t class to stringify\n-     * @return stringifier; null, if not available\n-     *\/\n-    private static MethodHandle stringifierFor(Class<?> t) {\n-        if (t == Object.class) {\n-            return objectStringifier();\n-        } else if (t == float.class) {\n-            return floatStringifier();\n-        } else if (t == double.class) {\n-            return doubleStringifier();\n-        }\n-        return null;\n-    }\n-\n@@ -1079,0 +676,20 @@\n+        static final ClassDesc STRING_CONCAT_HELPER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_byteArray = ClassDesc.ofDescriptor(\"[B\");\n+        static final MethodTypeDesc STRING_OFF = MethodTypeDesc.of(CD_String, CD_Object);\n+        static final MethodTypeDesc FLOAT_TO_STRING = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc DOUBLE_TO_STRING = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc TO_INT = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc INT_TO_INT = MethodTypeDesc.of(CD_int, CD_int);\n+        static final MethodTypeDesc LONG_TO_INT = MethodTypeDesc.of(CD_int, CD_long);\n+        static final MethodTypeDesc BOOLEAN_TO_INT = MethodTypeDesc.of(CD_int, CD_boolean);\n+        static final MethodTypeDesc TO_BYTE = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc CHAR_TO_BYTE = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc NEW_ARRAY = MethodTypeDesc.of(CD_byteArray, CD_int, CD_byte);\n+        static final MethodTypeDesc NEW_STRING = MethodTypeDesc.of(CD_void, CD_byteArray, CD_byte);\n+        static final MethodTypeDesc PREPEND_STRING = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_String);\n+        static final MethodTypeDesc PREPEND_INT = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_int);\n+        static final MethodTypeDesc PREPEND_LONG = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_long);\n+        static final MethodTypeDesc PREPEND_BOOLEAN = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_boolean);\n+        static final MethodTypeDesc PREPEND_CHAR = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_char);\n+\n+\n@@ -1155,0 +772,152 @@\n+\n+                public void acceptInlineCopy(CodeBuilder cb) {\n+                    int initalIndex = 0;\n+                    int initalCoder = JLA.stringConcatInitialCoder();\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            initalIndex += constant.length();\n+                            initalCoder |= JLA.stringCoder(constant);\n+                        }\n+                    }\n+\n+                    final int paramCount = args.parameterCount();\n+                    int[] paramSlots = new int[paramCount];\n+                    int[] paramStrings = new int[paramCount];\n+                    int strings = 0;\n+                    int argSlots = 0;\n+                    for (int i = 0; i < args.parameterCount(); i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = argSlots;\n+                        argSlots += kind.slotSize();\n+                        if (!directPrimive(cl)) {\n+                            paramStrings[i] = strings++;\n+                        }\n+                    }\n+\n+                    \/\/ string variants\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            cb.loadLocal(kind, paramSlots[i]);\n+                            if (cl == float.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Float, \"toString\", FLOAT_TO_STRING);\n+                            } else if (cl == double.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Double, \"toString\", DOUBLE_TO_STRING);\n+                            } else {\n+                                cb.invokestatic(STRING_CONCAT_HELPER, \"stringOf\", STRING_OFF);\n+                            }\n+                            cb.astore(argSlots + paramStrings[i]);\n+                        }\n+                    }\n+\n+                    int INIT_CODER = argSlots + strings;\n+                    int INIT_INDEX = argSlots + strings + 1;\n+                    int BUF = argSlots + strings + 2;\n+                    cb.loadConstant(initalCoder);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokevirtual(ConstantDescs.CD_String, \"coder\", TO_BYTE)\n+                              .ior();\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"stringCoder\", CHAR_TO_BYTE)\n+                              .ior();\n+                        }\n+                    }\n+                    cb.istore(INIT_CODER);\n+\n+                    cb.loadConstant(initalIndex);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        int pparamSlot = paramSlots[i];\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(ConstantDescs.CD_Integer, \"stringSize\", INT_TO_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(ConstantDescs.CD_Long, \"stringSize\", LONG_TO_INT);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"stringSize\", BOOLEAN_TO_INT);\n+                        } else if (cl == char.class) {\n+                            cb.iconst_1();\n+                        } else {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokevirtual(ConstantDescs.CD_String, \"length\", TO_INT);\n+                        }\n+                        cb.iadd();\n+                    }\n+                    cb.dup()\n+                      .istore(INIT_INDEX)\n+                      .iload(INIT_CODER).i2b()\n+                      .invokestatic(STRING_CONCAT_HELPER, \"newArray\", NEW_ARRAY)\n+                      .astore(BUF);\n+\n+                    if (constants[constants.length - 1] != null) {\n+                        cb.iload(INIT_INDEX)\n+                          .iload(INIT_CODER)\n+                          .aload(BUF)\n+                          .ldc(constants[constants.length - 1])\n+                          .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING)\n+                          .istore(INIT_INDEX);\n+                    }\n+                    \/\/ paramSlots\n+                    for (int i = paramCount - 1; i >= 0; i--) {\n+                        int paramSlot = paramSlots[i];\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+\n+                        cb.iload(INIT_INDEX)\n+                          .iload(INIT_CODER)\n+                          .aload(BUF);\n+\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_LONG);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_BOOLEAN);\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR);\n+                        } else {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING);\n+                        }\n+                        cb.istore(INIT_INDEX);\n+\n+                        if (constants[i] != null) {\n+                            cb.iload(INIT_INDEX)\n+                              .iload(INIT_CODER)\n+                              .aload(BUF)\n+                              .ldc(constants[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING)\n+                              .istore(INIT_INDEX);\n+                        }\n+                    }\n+\n+                    cb.new_(ConstantDescs.CD_String)\n+                      .dup()\n+                      .aload(BUF)\n+                      .iload(INIT_CODER)\n+                      .invokespecial(ConstantDescs.CD_String, \"<init>\", NEW_STRING)\n+                      .areturn();\n+                }\n+\n+                static boolean directPrimive(Class<?> cl) {\n+                    return cl == byte.class\n+                            || cl == short.class\n+                            || cl == int.class\n+                            || cl == long.class\n+                            || cl == boolean.class\n+                            || cl == char.class;\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":185,"deletions":416,"binary":false,"changes":601,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -435,6 +436,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\/\n-    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n-\n@@ -444,6 +439,1 @@\n-    long stringConcatInitialCoder();\n-\n-    \/**\n-     * Update lengthCoder for constant\n-     *\/\n-    long stringConcatMix(long lengthCoder, String constant);\n+    byte stringConcatInitialCoder();\n@@ -451,4 +441,1 @@\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     *\/\n-    long stringConcatMix(long lengthCoder, char value);\n+    MethodHandles.Lookup stringConcatLookup();\n@@ -468,0 +455,2 @@\n+    int stringSize(int i);\n+\n@@ -474,0 +463,3 @@\n+    byte stringCoder(char ch);\n+    byte stringCoder(String str);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"}]}