{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -381,3 +380,1 @@\n-            if (mh != null) {\n-                mh = mh.viewAsType(concatType, true);\n-            } else {\n+            if (mh == null) {\n@@ -386,0 +383,1 @@\n+            mh = mh.viewAsType(concatType, true);\n@@ -1091,8 +1089,0 @@\n-        \/**\n-         * Ensure a capacity in the initial StringBuilder to accommodate all\n-         * constants plus this factor times the number of arguments.\n-         *\/\n-        static final int ARGUMENT_SIZE_FACTOR = 4;\n-\n-        static final Set<Lookup.ClassOption> SET_OF_STRONG = Set.of(STRONG);\n-\n@@ -1106,0 +1096,1 @@\n+            MethodType erasedArgs = args.erase().changeReturnType(String.class);\n@@ -1113,1 +1104,1 @@\n-                                        ConstantUtils.methodTypeDesc(args),\n+                                        ConstantUtils.methodTypeDesc(erasedArgs),\n@@ -1115,1 +1106,1 @@\n-                                        generateMethod(constants, args));\n+                                        generateMethod(constants, erasedArgs));\n@@ -1118,1 +1109,1 @@\n-                var hiddenClass = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n+                var hiddenClass = lookup.makeHiddenClassDefiner(className, classBytes, Set.of(), DUMPER)\n@@ -1120,1 +1111,1 @@\n-                return lookup.findStatic(hiddenClass, METHOD_NAME, args);\n+                return lookup.findStatic(hiddenClass, METHOD_NAME, erasedArgs);\n@@ -1190,0 +1181,34 @@\n+\n+                        \/*\n+                         * Stringify by storing String variants in\n+                         * repurposed argument slots:\n+                         *\n+                         * arg0 = Float.toString(args0);\n+                         * arg1 = Double.toString(arg1);\n+                         * ...\n+                         * argN = StringConcatHelper.stringOf(argN);\n+                         *\n+                         *\n+                         *\/\n+                        if (needStringOf(cl)) {\n+                            ClassDesc classDesc;\n+                            MethodTypeDesc methodTypeDesc;\n+                            String methodName;\n+                            if (cl == float.class) {\n+                                classDesc = CD_Float;\n+                                methodName = \"toString\";\n+                                methodTypeDesc = FLOAT_TO_STRING;\n+                            } else if (cl == double.class) {\n+                                classDesc = CD_Double;\n+                                methodName = \"toString\";\n+                                methodTypeDesc = DOUBLE_TO_STRING;\n+                            } else {\n+                                classDesc = CD_StringConcatHelper;\n+                                methodName = \"stringOf\";\n+                                methodTypeDesc = OBJECT_TO_STRING;\n+                            }\n+\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(classDesc, methodName, methodTypeDesc)\n+                              .astore(paramSlots[i]);\n+                        }\n@@ -1195,44 +1220,0 @@\n-                    \/*\n-                     * store string variants:\n-                     *\n-                     * str0 = Float.toString(args(0));\n-                     * str1 = Double.toString(args(1));\n-                     * ...\n-                     * strN = StringConcatHelper.stringOf(args(N));\n-                     *\n-                     *\/\n-                    for (int i = 0, strings = 0; i < paramCount; i++) {\n-                        Class<?> cl = args.parameterType(i);\n-                        if (!needStringOf(cl)) {\n-                            continue;\n-                        }\n-\n-                        ClassDesc classDesc;\n-                        MethodTypeDesc methodTypeDesc;\n-                        String methodName;\n-                        if (cl == float.class) {\n-                            classDesc = CD_Float;\n-                            methodName = \"toString\";\n-                            methodTypeDesc = FLOAT_TO_STRING;\n-                        } else if (cl == double.class) {\n-                            classDesc = CD_Double;\n-                            methodName = \"toString\";\n-                            methodTypeDesc = DOUBLE_TO_STRING;\n-                        } else {\n-                            classDesc = CD_StringConcatHelper;\n-                            methodName = \"stringOf\";\n-                            methodTypeDesc = OBJECT_TO_STRING;\n-                        }\n-\n-                        \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n-                        int strLocalSlot = (cl == String.class)\n-                                ? paramSlots[i]\n-                                : bufSlot + (++strings);\n-                        cb.loadLocal(TypeKind.from(cl), paramSlots[i])\n-                          .invokestatic(classDesc, methodName, methodTypeDesc)\n-                          .astore(strLocalSlot);\n-                        if (cl != String.class) {\n-                            paramSlots[i] = strLocalSlot;\n-                        }\n-                    }\n-\n@@ -1252,1 +1233,0 @@\n-                        ClassDesc classDesc = CD_StringConcatHelper;\n@@ -1255,1 +1235,0 @@\n-                            classDesc = CD_Integer;\n@@ -1258,1 +1237,0 @@\n-                            classDesc = CD_Long;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":41,"deletions":63,"binary":false,"changes":104,"status":"modified"}]}