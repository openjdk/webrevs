{"files":[{"patch":"@@ -3591,1 +3591,1 @@\n-        int len = prefix.length() + suffix.length();\n+        long len = (long) prefix.length() + suffix.length();\n@@ -3593,1 +3593,1 @@\n-            len += (size - 1) * delimiter.length();\n+            len += (long) (size - 1) * delimiter.length();\n@@ -3606,1 +3606,1 @@\n-        if (len < 0L) {\n+        if (len < 0L || (len <<= coder) != (int) len) {\n@@ -3609,1 +3609,1 @@\n-        byte[] value = StringConcatHelper.newArray(len << coder);\n+        byte[] value = StringConcatHelper.newArray(len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -48,1 +47,83 @@\n-     * Prepends the stringly representation of boolean value into buffer,\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static long coder(char value) {\n+        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n+    }\n+\n+    \/**\n+     * Check for overflow, throw exception on overflow.\n+     *\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @return            the given parameter value, if valid\n+     *\/\n+    private static long checkOverflow(long lengthCoder) {\n+        if ((int)lengthCoder >= 0) {\n+            return lengthCoder;\n+        }\n+        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     *\/\n+    static long mix(long lengthCoder, boolean value) {\n+        return checkOverflow(lengthCoder + (value ? 4 : 5));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     *\/\n+    static long mix(long lengthCoder, char value) {\n+        return checkOverflow(lengthCoder + 1) | coder(value);\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     *\/\n+    static long mix(long lengthCoder, int value) {\n+        return checkOverflow(lengthCoder + Integer.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     *\/\n+    static long mix(long lengthCoder, long value) {\n+        return checkOverflow(lengthCoder + Long.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     *\/\n+    static long mix(long lengthCoder, String value) {\n+        lengthCoder += value.length();\n+        if (!value.isLatin1()) {\n+            lengthCoder |= UTF16;\n+        }\n+        return checkOverflow(lengthCoder);\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -51,2 +132,2 @@\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n@@ -55,0 +136,1 @@\n+     * @param prefix     a constant to prepend before value\n@@ -57,2 +139,3 @@\n-    static int prepend(int index, byte coder, byte[] buf, boolean value) {\n-        if (coder == String.LATIN1) {\n+    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n+        int index = (int)indexCoder;\n+        if (indexCoder < UTF16) {\n@@ -60,4 +143,5 @@\n-                buf[--index] = 'e';\n-                buf[--index] = 'u';\n-                buf[--index] = 'r';\n-                buf[--index] = 't';\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n@@ -65,5 +149,6 @@\n-                buf[--index] = 'e';\n-                buf[--index] = 's';\n-                buf[--index] = 'l';\n-                buf[--index] = 'a';\n-                buf[--index] = 'f';\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n@@ -71,0 +156,3 @@\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -73,4 +161,5 @@\n-                StringUTF16.putChar(buf, --index, 'e');\n-                StringUTF16.putChar(buf, --index, 'u');\n-                StringUTF16.putChar(buf, --index, 'r');\n-                StringUTF16.putChar(buf, --index, 't');\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n@@ -78,5 +167,6 @@\n-                StringUTF16.putChar(buf, --index, 'e');\n-                StringUTF16.putChar(buf, --index, 's');\n-                StringUTF16.putChar(buf, --index, 'l');\n-                StringUTF16.putChar(buf, --index, 'a');\n-                StringUTF16.putChar(buf, --index, 'f');\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n@@ -84,0 +174,3 @@\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -85,1 +178,0 @@\n-        return index;\n@@ -89,1 +181,1 @@\n-     * Prepends the stringly representation of char value into buffer,\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -92,2 +184,2 @@\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n@@ -95,1 +187,2 @@\n-     * @param value      char value to encode\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n@@ -98,4 +191,7 @@\n-    static int prepend(int index, byte coder, byte[] buf, char value) {\n-        index--;\n-        if (coder == String.LATIN1) {\n-            buf[index] = (byte) (value & 0xFF);\n+    static long prepend(long indexCoder, byte[] buf, char value, String prefix) {\n+        int index = (int)indexCoder;\n+        if (indexCoder < UTF16) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -103,1 +199,4 @@\n-            StringUTF16.putChar(buf, index, value);\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -105,1 +204,0 @@\n-        return index;\n@@ -109,1 +207,1 @@\n-     * Prepends the stringly representation of integer value into buffer,\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -112,2 +210,2 @@\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n@@ -115,1 +213,2 @@\n-     * @param value      integer value to encode\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n@@ -118,3 +217,7 @@\n-    static int prepend(int index, byte coder, byte[] buf, int value) {\n-        if (coder == String.LATIN1) {\n-            return StringLatin1.getChars(value, index, buf);\n+    static long prepend(long indexCoder, byte[] buf, int value, String prefix) {\n+        int index = (int)indexCoder;\n+        if (indexCoder < UTF16) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -122,1 +225,4 @@\n-            return StringUTF16.getChars(value, index, buf);\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -127,1 +233,1 @@\n-     * Prepends the stringly representation of long value into buffer,\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -130,2 +236,2 @@\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n@@ -133,1 +239,2 @@\n-     * @param value      long value to encode\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n@@ -136,3 +243,7 @@\n-    static int prepend(int index, byte coder, byte[] buf, long value) {\n-        if (coder == String.LATIN1) {\n-            return StringLatin1.getChars(value, index, buf);\n+    static long prepend(long indexCoder, byte[] buf, long value, String prefix) {\n+        int index = (int)indexCoder;\n+        if (indexCoder < UTF16) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n@@ -140,1 +251,4 @@\n-            return StringUTF16.getChars(value, index, buf);\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n@@ -145,1 +259,1 @@\n-     * Prepends the stringly representation of String value into buffer,\n+     * Prepends constant and the stringly representation of value into buffer,\n@@ -148,2 +262,2 @@\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n@@ -151,1 +265,2 @@\n-     * @param value      String value to encode\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n@@ -154,4 +269,31 @@\n-    static int prepend(int index, byte coder, byte[] buf, String value) {\n-        index -= value.length();\n-        value.getBytes(buf, index, coder);\n-        return index;\n+    static long prepend(long indexCoder, byte[] buf, String value, String prefix) {\n+        int index = ((int)indexCoder) - value.length();\n+        if (indexCoder < UTF16) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+            return index;\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+            return index | UTF16;\n+        }\n+    }\n+\n+    \/**\n+     * Instantiates the String with given buffer and coder\n+     * @param buf           buffer to use\n+     * @param indexCoder    remaining index (should be zero) and coder\n+     * @return String       resulting string\n+     *\/\n+    static String newString(byte[] buf, long indexCoder) {\n+        \/\/ Use the private, non-copying constructor (unsafe!)\n+        if (indexCoder == LATIN1) {\n+            return new String(buf, String.LATIN1);\n+        } else if (indexCoder == UTF16) {\n+            return new String(buf, String.UTF16);\n+        } else {\n+            throw new InternalError(\"Storage is not completely initialized, \" +\n+                    (int)indexCoder + \" bytes left\");\n+        }\n@@ -229,0 +371,4 @@\n+    private static final long LATIN1 = (long)String.LATIN1 << 32;\n+\n+    private static final long UTF16 = (long)String.UTF16 << 32;\n+\n@@ -231,0 +377,22 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param indexCoder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArrayWithSuffix(String suffix, long indexCoder) {\n+        byte[] buf = newArray(indexCoder + suffix.length());\n+        if (indexCoder < UTF16) {\n+            suffix.getBytes(buf, (int)indexCoder, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, (int)indexCoder, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n@@ -238,0 +406,13 @@\n+    static byte[] newArray(long indexCoder) {\n+        byte coder = (byte)(indexCoder >> 32);\n+        int index = ((int)indexCoder) << coder;\n+        return newArray(index);\n+    }\n+\n+    \/**\n+     * Allocates an uninitialized byte array based on the length\n+     * @param index\n+     * @param coder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n@@ -260,10 +441,2 @@\n-    static byte initialCoder() {\n-        return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n-    }\n-\n-    static int stringSize(boolean value) {\n-        return value ? 4 : 5;\n-    }\n-\n-    static byte stringCoder(char value) {\n-        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    static long initialCoder() {\n+        return String.COMPACT_STRINGS ? LATIN1 : UTF16;\n@@ -280,0 +453,125 @@\n+\n+    \/**\n+     * Prepends the stringly representation of boolean value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of char value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value) {\n+        index--;\n+        if (coder == String.LATIN1) {\n+            buf[index] = (byte) (value & 0xFF);\n+        } else {\n+            StringUTF16.putChar(buf, index, value);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of integer value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      integer value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of long value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of String value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value) {\n+        index -= value.length();\n+        value.getBytes(buf, index, coder);\n+        return index;\n+    }\n+\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":367,"deletions":69,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -2615,1 +2614,1 @@\n-            public byte stringConcatInitialCoder() {\n+            public long stringConcatInitialCoder() {\n@@ -2619,0 +2618,8 @@\n+            public long stringConcatMix(long lengthCoder, String constant) {\n+                return StringConcatHelper.mix(lengthCoder, constant);\n+            }\n+\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n@@ -2635,0 +2642,4 @@\n+            public byte stringInitialCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +50,0 @@\n-\n@@ -115,0 +113,1 @@\n+    private static final boolean GENERATE_INLINE_COPY;\n@@ -119,0 +118,3 @@\n+\n+        String generateInlineCopy = VM.getSavedProperty(\"java.lang.invoke.StringConcat.generateInlineCopy\");\n+        GENERATE_INLINE_COPY = generateInlineCopy != null ? \"true\".equalsIgnoreCase(generateInlineCopy) : true;\n@@ -376,1 +378,1 @@\n-        MethodHandle mh;\n+        MethodHandle mh = null;\n@@ -378,4 +380,7 @@\n-            mh = generateMHInlineCopy(concatType, constantStrings);\n-            if (mh != null) {\n-                mh = mh.viewAsType(concatType, true);\n-            } else {\n+            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+                if (mh != null) {\n+                    mh = mh.viewAsType(concatType, true);\n+                }\n+            }\n+            if (mh == null) {\n@@ -384,0 +389,1 @@\n+            return new ConstantCallSite(mh);\n@@ -390,1 +396,0 @@\n-        return new ConstantCallSite(mh);\n@@ -507,1 +512,369 @@\n-        return null;\n+        if (GENERATE_INLINE_COPY) {\n+            return null;\n+        }\n+\n+        \/\/ else... fall-through to slow-path\n+\n+        \/\/ Create filters and obtain filtered parameter types. Filters would be used in the beginning\n+        \/\/ to convert the incoming arguments into the arguments we can process (e.g. Objects -> Strings).\n+        \/\/ The filtered argument type list is used all over in the combinators below.\n+\n+        Class<?>[] ptypes = mt.erase().parameterArray();\n+        MethodHandle[] objFilters = null;\n+        MethodHandle[] floatFilters = null;\n+        MethodHandle[] doubleFilters = null;\n+        for (int i = 0; i < ptypes.length; i++) {\n+            Class<?> cl = ptypes[i];\n+            \/\/ Use int as the logical type for subword integral types\n+            \/\/ (byte and short). char and boolean require special\n+            \/\/ handling so don't change the logical type of those\n+            ptypes[i] = promoteToIntType(ptypes[i]);\n+            \/\/ Object, float and double will be eagerly transformed\n+            \/\/ into a (non-null) String as a first step after invocation.\n+            \/\/ Set up to use String as the logical type for such arguments\n+            \/\/ internally.\n+            if (cl == Object.class) {\n+                if (objFilters == null) {\n+                    objFilters = new MethodHandle[ptypes.length];\n+                }\n+                objFilters[i] = objectStringifier();\n+                ptypes[i] = String.class;\n+            } else if (cl == float.class) {\n+                if (floatFilters == null) {\n+                    floatFilters = new MethodHandle[ptypes.length];\n+                }\n+                floatFilters[i] = floatStringifier();\n+                ptypes[i] = String.class;\n+            } else if (cl == double.class) {\n+                if (doubleFilters == null) {\n+                    doubleFilters = new MethodHandle[ptypes.length];\n+                }\n+                doubleFilters[i] = doubleStringifier();\n+                ptypes[i] = String.class;\n+            }\n+        }\n+\n+        \/\/ Start building the combinator tree. The tree \"starts\" with (<parameters>)String, and \"finishes\"\n+        \/\/ with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are\n+        \/\/ assembled bottom-up, which makes the code arguably hard to read.\n+\n+        \/\/ Drop all remaining parameter types, leave only helper arguments:\n+        MethodHandle mh = MethodHandles.dropArgumentsTrusted(newString(), 2, ptypes);\n+\n+        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n+        \/\/ their lengths and adjusting the encoded coder bit if needed\n+        long initialLengthCoder = INITIAL_CODER;\n+\n+        for (String constant : constants) {\n+            if (constant != null) {\n+                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constant);\n+            }\n+        }\n+\n+        \/\/ Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already\n+        \/\/ known from the combinators below. We are assembling the string backwards, so the index coded\n+        \/\/ into indexCoder is the *ending* index.\n+        mh = filterInPrependers(mh, constants, ptypes);\n+\n+        \/\/ Fold in byte[] instantiation at argument 0\n+        MethodHandle newArrayCombinator;\n+        if (suffix == null || suffix.isEmpty()) {\n+            suffix = \"\";\n+        }\n+        \/\/ newArray variant that deals with prepending any trailing constant\n+        \/\/\n+        \/\/ initialLengthCoder is adjusted to have the correct coder\n+        \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n+        \/\/ suffix to be encoded into indexCoder\n+        initialLengthCoder -= suffix.length();\n+        newArrayCombinator = newArrayWithSuffix(suffix);\n+\n+        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n+                1 \/\/ index\n+        );\n+\n+        \/\/ Start combining length and coder mixers.\n+        \/\/\n+        \/\/ Length is easy: constant lengths can be computed on the spot, and all non-constant\n+        \/\/ shapes have been either converted to Strings, or explicit methods for getting the\n+        \/\/ string length out of primitives are provided.\n+        \/\/\n+        \/\/ Coders are more interesting. Only Object, String and char arguments (and constants)\n+        \/\/ can have non-Latin1 encoding. It is easier to blindly convert constants to String,\n+        \/\/ and deduce the coder from there. Arguments would be either converted to Strings\n+        \/\/ during the initial filtering, or handled by specializations in MIXERS.\n+        \/\/\n+        \/\/ The method handle shape before all mixers are combined in is:\n+        \/\/   (long, <args>)String = (\"indexCoder\", <args>)\n+        \/\/\n+        \/\/ We will bind the initialLengthCoder value to the last mixer (the one that will be\n+        \/\/ executed first), then fold that in. This leaves the shape after all mixers are\n+        \/\/ combined in as:\n+        \/\/   (<args>)String = (<args>)\n+\n+        mh = filterAndFoldInMixers(mh, initialLengthCoder, ptypes);\n+\n+        \/\/ The method handle shape here is (<args>).\n+\n+        \/\/ Apply filters, converting the arguments:\n+        if (objFilters != null) {\n+            mh = MethodHandles.filterArguments(mh, 0, objFilters);\n+        }\n+        if (floatFilters != null) {\n+            mh = MethodHandles.filterArguments(mh, 0, floatFilters);\n+        }\n+        if (doubleFilters != null) {\n+            mh = MethodHandles.filterArguments(mh, 0, doubleFilters);\n+        }\n+\n+        return mh;\n+    }\n+\n+    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n+    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n+    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n+    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n+    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n+    private static MethodHandle filterInPrependers(MethodHandle mh, String[] constants, Class<?>[] ptypes) {\n+        int pos;\n+        int[] argPositions = null;\n+        MethodHandle prepend;\n+        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n+            prepend = prepender(pos, constants, ptypes, 4);\n+            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n+        }\n+        if (pos < ptypes.length) {\n+            int count = ptypes.length - pos;\n+            prepend = prepender(pos, constants, ptypes, count);\n+            argPositions = filterPrependArgPositions(argPositions, pos, count);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n+        }\n+        return mh;\n+    }\n+\n+    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n+        if (argPositions == null || argPositions.length != count + 2) {\n+            argPositions = new int[count + 2];\n+            argPositions[0] = 1; \/\/ indexCoder\n+            argPositions[1] = 0; \/\/ storage\n+        }\n+        int limit = count + 2;\n+        for (int i = 2; i < limit; i++) {\n+            argPositions[i] = i + pos;\n+        }\n+        return argPositions;\n+    }\n+\n+\n+    \/\/ We need one mixer per argument.\n+    private static MethodHandle filterAndFoldInMixers(MethodHandle mh, long initialLengthCoder, Class<?>[] ptypes) {\n+        int pos;\n+        int[] argPositions = null;\n+        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n+            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n+            MethodHandle mix = mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            argPositions = filterMixerArgPositions(argPositions, pos, 4);\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n+                    mix, argPositions);\n+        }\n+\n+        if (pos < ptypes.length) {\n+            \/\/ Mix in the last 1 to 4 parameters, insert the initialLengthCoder into the final mixer and\n+            \/\/ fold the result into the main combinator\n+            mh = foldInLastMixers(mh, initialLengthCoder, pos, ptypes, ptypes.length - pos);\n+        } else if (ptypes.length == 0) {\n+            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n+            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n+        }\n+        return mh;\n+    }\n+\n+    static int[] filterMixerArgPositions(int[] argPositions, int pos, int count) {\n+        if (argPositions == null || argPositions.length != count + 2) {\n+            argPositions = new int[count + 1];\n+            argPositions[0] = 0; \/\/ indexCoder\n+        }\n+        int limit = count + 1;\n+        for (int i = 1; i < limit; i++) {\n+            argPositions[i] = i + pos;\n+        }\n+        return argPositions;\n+    }\n+\n+    private static MethodHandle foldInLastMixers(MethodHandle mh, long initialLengthCoder, int pos, Class<?>[] ptypes, int count) {\n+        MethodHandle mix = switch (count) {\n+            case 1 -> mixer(ptypes[pos]);\n+            case 2 -> mixer(ptypes[pos], ptypes[pos + 1]);\n+            case 3 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n+            case 4 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n+        };\n+        mix = MethodHandles.insertArguments(mix,0, initialLengthCoder);\n+        \/\/ apply selected arguments on the 1-4 arg mixer and fold in the result\n+        return switch (count) {\n+            case 1 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos);\n+            case 2 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos);\n+            case 3 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos, 3 + pos);\n+            case 4 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                    1 + pos, 2 + pos, 3 + pos, 4 + pos);\n+            default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n+    \/\/ Simple prependers, single argument. May be used directly or as a\n+    \/\/ building block for complex prepender combinators.\n+    private static MethodHandle prepender(String prefix, Class<?> cl) {\n+        if (prefix == null || prefix.isEmpty()) {\n+            return noPrefixPrepender(cl);\n+        } else {\n+            return MethodHandles.insertArguments(\n+                    prepender(cl), 3, prefix);\n+        }\n+    }\n+\n+    private static MethodHandle prepender(Class<?> cl) {\n+        int idx = classIndex(cl);\n+        MethodHandle prepend = PREPENDERS[idx];\n+        if (prepend == null) {\n+            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n+                    methodType(long.class, long.class, byte[].class,\n+                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n+        }\n+        return prepend;\n+    }\n+\n+    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n+        int idx = classIndex(cl);\n+        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n+        if (prepend == null) {\n+            NO_PREFIX_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(prepender(cl), 3, \"\");\n+        }\n+        return prepend;\n+    }\n+\n+    private static final int INT_IDX = 0,\n+            CHAR_IDX = 1,\n+            LONG_IDX = 2,\n+            BOOLEAN_IDX = 3,\n+            STRING_IDX = 4,\n+            TYPE_COUNT = 5;\n+    private static int classIndex(Class<?> cl) {\n+        if (cl == String.class)                          return STRING_IDX;\n+        if (cl == int.class)                             return INT_IDX;\n+        if (cl == boolean.class)                         return BOOLEAN_IDX;\n+        if (cl == char.class)                            return CHAR_IDX;\n+        if (cl == long.class)                            return LONG_IDX;\n+        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n+    }\n+\n+    \/\/ Constant argument lists used by the prepender MH builders\n+    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2 };\n+    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 3 };\n+    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 4 };\n+    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3 };\n+    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 4, 5 };\n+\n+    \/\/ Base MH for complex prepender combinators.\n+    private static @Stable MethodHandle PREPEND_BASE;\n+    private static MethodHandle prependBase() {\n+        MethodHandle base = PREPEND_BASE;\n+        if (base == null) {\n+            base = PREPEND_BASE = MethodHandles.dropArguments(\n+                    MethodHandles.identity(long.class), 1, byte[].class);\n+        }\n+        return base;\n+    }\n+\n+    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n+\n+    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n+        int idx1 = classIndex(cl);\n+        int idx2 = classIndex(cl2);\n+        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n+        if (prepend == null) {\n+            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n+                    MethodHandles.dropArguments(prependBase(), 2, cl, cl2);\n+        }\n+        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n+                PREPEND_FILTER_FIRST_ARGS);\n+        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n+                PREPEND_FILTER_SECOND_ARGS);\n+    }\n+\n+    private static MethodHandle prepender(int pos, String[] constants, Class<?>[] ptypes, int count) {\n+        \/\/ build the simple cases directly\n+        if (count == 1) {\n+            return prepender(constants[pos], ptypes[pos]);\n+        }\n+        if (count == 2) {\n+            return prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]);\n+        }\n+        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n+        MethodHandle prepend = prependBase();\n+        if (count == 3) {\n+            prepend = MethodHandles.dropArguments(prepend, 2,\n+                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n+            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n+                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n+            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants[pos + 2], ptypes[pos + 2]),\n+                    PREPEND_FILTER_THIRD_ARGS);\n+        } else if (count == 4) {\n+            prepend = MethodHandles.dropArguments(prepend, 2,\n+                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n+            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n+                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n+            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n+                    prepender(constants[pos + 2], ptypes[pos + 2], constants[pos + 3], ptypes[pos + 3]),\n+                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n+        }\n+    }\n+\n+    \/\/ Constant argument lists used by the mixer MH builders\n+    private static final int[] MIX_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n+    private static final int[] MIX_FILTER_THIRD_ARGS  = new int[] { 0, 3 };\n+    private static final int[] MIX_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n+    private static MethodHandle mixer(Class<?> cl) {\n+        int index = classIndex(cl);\n+        MethodHandle mix = MIXERS[index];\n+        if (mix == null) {\n+            MIXERS[index] = mix = JLA.stringConcatHelper(\"mix\",\n+                    methodType(long.class, long.class, Wrapper.asPrimitiveType(cl))).rebind();\n+        }\n+        return mix;\n+    }\n+\n+    private static final @Stable MethodHandle[][] DOUBLE_MIXERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2) {\n+        int idx1 = classIndex(cl);\n+        int idx2 = classIndex(cl2);\n+        MethodHandle mix = DOUBLE_MIXERS[idx1][idx2];\n+        if (mix == null) {\n+            mix = mixer(cl);\n+            mix = MethodHandles.dropArguments(mix, 2, cl2);\n+            DOUBLE_MIXERS[idx1][idx2] = mix = MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                    mixer(cl2), MIX_FILTER_SECOND_ARGS);\n+        }\n+        return mix;\n+    }\n+\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n+        MethodHandle mix = mixer(cl, cl2);\n+        mix = MethodHandles.dropArguments(mix, 3, cl3);\n+        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                mixer(cl3), MIX_FILTER_THIRD_ARGS);\n+    }\n+\n+    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n+        MethodHandle mix = mixer(cl, cl2);\n+        mix = MethodHandles.dropArguments(mix, 3, cl3, cl4);\n+        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n+                mixer(cl3, cl4), MIX_FILTER_SECOND_PAIR_ARGS);\n@@ -526,1 +899,1 @@\n-                    methodType(String.class, byte[].class, byte.class));\n+                    methodType(String.class, byte[].class, long.class));\n@@ -537,1 +910,1 @@\n-                    methodType(byte[].class, String.class, int.class, byte.class));\n+                    methodType(byte[].class, String.class, long.class));\n@@ -543,10 +916,0 @@\n-    private @Stable static MethodHandle NEW_ARRAY;\n-    private static MethodHandle newArray() {\n-        MethodHandle mh = NEW_ARRAY;\n-        if (mh == null) {\n-            NEW_ARRAY = mh =\n-                    JLA.stringConcatHelper(\"newArray\", methodType(byte[].class, int.class, byte.class));\n-        }\n-        return mh;\n-    }\n-\n@@ -558,0 +921,9 @@\n+    private @Stable static MethodHandle OBJECT_STRINGIFIER;\n+    private static MethodHandle objectStringifier() {\n+        MethodHandle mh = OBJECT_STRINGIFIER;\n+        if (mh == null) {\n+            OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(\"stringOf\",\n+                    methodType(String.class, Object.class));\n+        }\n+        return mh;\n+    }\n@@ -641,0 +1013,32 @@\n+    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n+    private static final @Stable MethodHandle[] PREPENDERS      = new MethodHandle[TYPE_COUNT];\n+    private static final @Stable MethodHandle[] MIXERS          = new MethodHandle[TYPE_COUNT];\n+    private static final long INITIAL_CODER = JLA.stringConcatInitialCoder();\n+\n+    \/**\n+     * Promote integral types to int.\n+     *\/\n+    private static Class<?> promoteToIntType(Class<?> t) {\n+        \/\/ use int for subword integral types; still need special mixers\n+        \/\/ and prependers for char, boolean\n+        return t == byte.class || t == short.class ? int.class : t;\n+    }\n+\n+    \/**\n+     * Returns a stringifier for references and floats\/doubles only.\n+     * Always returns null for other primitives.\n+     *\n+     * @param t class to stringify\n+     * @return stringifier; null, if not available\n+     *\/\n+    private static MethodHandle stringifierFor(Class<?> t) {\n+        if (t == Object.class) {\n+            return objectStringifier();\n+        } else if (t == float.class) {\n+            return floatStringifier();\n+        } else if (t == double.class) {\n+            return doubleStringifier();\n+        }\n+        return null;\n+    }\n+\n@@ -696,1 +1100,0 @@\n-\n@@ -713,0 +1116,1 @@\n+            boolean generateInlineCopy = GENERATE_INLINE_COPY && args.parameterCount() <= HIGH_ARITY_THRESHOLD;\n@@ -721,1 +1125,3 @@\n-                                        generateMethod(constants, args));\n+                                        generateInlineCopy\n+                                                ? generateInlineCopyMethod(constants, args)\n+                                                : generateMethod(constants, args));\n@@ -736,5 +1142,0 @@\n-                    if (args.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                        acceptInlineCopy(cb);\n-                        return;\n-                    }\n-\n@@ -778,0 +1179,2 @@\n+            };\n+        }\n@@ -779,1 +1182,4 @@\n-                public void acceptInlineCopy(CodeBuilder cb) {\n+        private static Consumer<CodeBuilder> generateInlineCopyMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n@@ -781,1 +1187,1 @@\n-                    int initalCoder = JLA.stringConcatInitialCoder();\n+                    int initalCoder = JLA.stringInitialCoder();\n@@ -831,2 +1237,2 @@\n-                                  .invokevirtual(ConstantDescs.CD_String, \"coder\", TO_BYTE)\n-                                  .ior();\n+                                        .invokevirtual(ConstantDescs.CD_String, \"coder\", TO_BYTE)\n+                                        .ior();\n@@ -836,2 +1242,2 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"stringCoder\", CHAR_TO_BYTE)\n-                              .ior();\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"stringCoder\", CHAR_TO_BYTE)\n+                                    .ior();\n@@ -849,1 +1255,1 @@\n-                              .invokestatic(ConstantDescs.CD_Integer, \"stringSize\", INT_TO_INT);\n+                                    .invokestatic(ConstantDescs.CD_Integer, \"stringSize\", INT_TO_INT);\n@@ -852,1 +1258,1 @@\n-                              .invokestatic(ConstantDescs.CD_Long, \"stringSize\", LONG_TO_INT);\n+                                    .invokestatic(ConstantDescs.CD_Long, \"stringSize\", LONG_TO_INT);\n@@ -855,1 +1261,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"stringSize\", BOOLEAN_TO_INT);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"stringSize\", BOOLEAN_TO_INT);\n@@ -860,1 +1266,1 @@\n-                              .invokevirtual(ConstantDescs.CD_String, \"length\", TO_INT);\n+                                    .invokevirtual(ConstantDescs.CD_String, \"length\", TO_INT);\n@@ -865,4 +1271,4 @@\n-                      .istore(indexSlot)\n-                      .iload(coderSlot)\n-                      .invokestatic(STRING_CONCAT_HELPER, \"newArray\", NEW_ARRAY)\n-                      .astore(bufSlot);\n+                            .istore(indexSlot)\n+                            .iload(coderSlot)\n+                            .invokestatic(STRING_CONCAT_HELPER, \"newArray\", NEW_ARRAY)\n+                            .astore(bufSlot);\n@@ -878,2 +1284,2 @@\n-                          .iload(coderSlot)\n-                          .aload(bufSlot);\n+                                .iload(coderSlot)\n+                                .aload(bufSlot);\n@@ -882,1 +1288,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_INT);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_INT);\n@@ -885,1 +1291,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_LONG);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_LONG);\n@@ -888,1 +1294,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_BOOLEAN);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_BOOLEAN);\n@@ -891,1 +1297,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR);\n@@ -895,1 +1301,1 @@\n-                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING);\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING);\n@@ -903,5 +1309,5 @@\n-                      .dup()\n-                      .aload(bufSlot)\n-                      .iload(coderSlot)\n-                      .invokespecial(ConstantDescs.CD_String, \"<init>\", NEW_STRING)\n-                      .areturn();\n+                            .dup()\n+                            .aload(bufSlot)\n+                            .iload(coderSlot)\n+                            .invokespecial(ConstantDescs.CD_String, \"<init>\", NEW_STRING)\n+                            .areturn();\n@@ -916,5 +1322,5 @@\n-                          .iload(coderSlot)\n-                          .aload(bufSlot)\n-                          .loadConstant((int) constant.charAt(0))\n-                          .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR)\n-                          .istore(indexSlot);\n+                                .iload(coderSlot)\n+                                .aload(bufSlot)\n+                                .loadConstant((int) constant.charAt(0))\n+                                .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR)\n+                                .istore(indexSlot);\n@@ -925,3 +1331,3 @@\n-                      .loadConstant(constant.length())\n-                      .isub()\n-                      .istore(indexSlot);\n+                            .loadConstant(constant.length())\n+                            .isub()\n+                            .istore(indexSlot);\n@@ -930,4 +1336,4 @@\n-                       .aload(bufSlot)\n-                       .iload(indexSlot)\n-                       .iload(coderSlot)\n-                       .invokevirtual(CD_String, \"getBytes\", STR_GET_BYTES);\n+                            .aload(bufSlot)\n+                            .iload(indexSlot)\n+                            .iload(coderSlot)\n+                            .invokevirtual(CD_String, \"getBytes\", STR_GET_BYTES);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":472,"deletions":66,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -439,1 +438,11 @@\n-    byte stringConcatInitialCoder();\n+    long stringConcatInitialCoder();\n+\n+    \/**\n+     * Update lengthCoder for constant\n+     *\/\n+    long stringConcatMix(long lengthCoder, String constant);\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n@@ -446,0 +455,5 @@\n+    byte stringInitialCoder();\n+\n+    byte stringCoder(char ch);\n+    byte stringCoder(String str);\n+\n@@ -459,3 +473,0 @@\n-    byte stringCoder(char ch);\n-    byte stringCoder(String str);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"}]}