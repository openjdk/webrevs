{"files":[{"patch":"@@ -412,0 +412,12 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length\n+     * @param index\n+     * @param coder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArray(int index, byte coder) {\n+        index = index << coder;\n+        return newArray(index);\n+    }\n+\n@@ -442,0 +454,124 @@\n+    \/**\n+     * Prepends the stringly representation of boolean value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of char value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value) {\n+        index--;\n+        if (coder == String.LATIN1) {\n+            buf[index] = (byte) (value & 0xFF);\n+        } else {\n+            StringUTF16.putChar(buf, index, value);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of integer value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      integer value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of long value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of String value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value) {\n+        index -= value.length();\n+        value.getBytes(buf, index, coder);\n+        return index;\n+    }\n+\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2642,0 +2642,12 @@\n+            public byte stringInitialCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(char value) {\n+                return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,1 +961,3 @@\n-                m.ensureTypeVisible(m.getDeclaringClass());\n+                if (allowedModes != LM_TRUSTED) {\n+                    m.ensureTypeVisible(m.getDeclaringClass());\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -112,0 +113,1 @@\n+    private static final boolean GENERATE_INLINE_COPY;\n@@ -116,0 +118,3 @@\n+\n+        String generateInlineCopy = VM.getSavedProperty(\"java.lang.invoke.StringConcat.generateInlineCopy\");\n+        GENERATE_INLINE_COPY = generateInlineCopy != null ? \"true\".equalsIgnoreCase(generateInlineCopy) : true;\n@@ -373,0 +378,1 @@\n+        MethodHandle mh = null;\n@@ -375,6 +381,4 @@\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+                if (mh != null) {\n+                    mh = mh.viewAsType(concatType, true);\n+                }\n@@ -382,0 +386,4 @@\n+            if (mh == null) {\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n+            }\n+            return new ConstantCallSite(mh);\n@@ -503,0 +511,5 @@\n+\n+        if (GENERATE_INLINE_COPY) {\n+            return null;\n+        }\n+\n@@ -1067,0 +1080,20 @@\n+        static final ClassDesc STRING_CONCAT_HELPER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_byteArray = ClassDesc.ofDescriptor(\"[B\");\n+        static final MethodTypeDesc STRING_OFF = MethodTypeDesc.of(CD_String, CD_Object);\n+        static final MethodTypeDesc FLOAT_TO_STRING = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc DOUBLE_TO_STRING = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc TO_INT = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc INT_TO_INT = MethodTypeDesc.of(CD_int, CD_int);\n+        static final MethodTypeDesc LONG_TO_INT = MethodTypeDesc.of(CD_int, CD_long);\n+        static final MethodTypeDesc BOOLEAN_TO_INT = MethodTypeDesc.of(CD_int, CD_boolean);\n+        static final MethodTypeDesc TO_BYTE = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc CHAR_TO_BYTE = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc NEW_ARRAY = MethodTypeDesc.of(CD_byteArray, CD_int, CD_byte);\n+        static final MethodTypeDesc NEW_STRING = MethodTypeDesc.of(CD_void, CD_byteArray, CD_byte);\n+        static final MethodTypeDesc PREPEND_STRING = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_String);\n+        static final MethodTypeDesc PREPEND_INT = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_int);\n+        static final MethodTypeDesc PREPEND_LONG = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_long);\n+        static final MethodTypeDesc PREPEND_BOOLEAN = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_boolean);\n+        static final MethodTypeDesc PREPEND_CHAR = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_char);\n+        static final MethodTypeDesc STR_GET_BYTES = MethodTypeDesc.of(CD_void, CD_byteArray, CD_int, CD_byte);\n+\n@@ -1080,1 +1113,2 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = MethodHandles.Lookup.IMPL_LOOKUP;\n+            String className = getClassName(String.class);\n@@ -1082,0 +1116,1 @@\n+            boolean generateInlineCopy = GENERATE_INLINE_COPY && args.parameterCount() <= HIGH_ARITY_THRESHOLD;\n@@ -1090,1 +1125,3 @@\n-                                        generateMethod(constants, args));\n+                                        generateInlineCopy\n+                                                ? generateInlineCopyMethod(constants, args)\n+                                                : generateMethod(constants, args));\n@@ -1093,4 +1130,3 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n+                var hiddenClass = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n+                        .defineClass(true, null);\n+                return lookup.findStatic(hiddenClass, METHOD_NAME, args);\n@@ -1146,0 +1182,184 @@\n+        private static Consumer<CodeBuilder> generateInlineCopyMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int initalIndex = 0;\n+                    int initalCoder = JLA.stringInitialCoder();\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            initalIndex += constant.length();\n+                            initalCoder |= JLA.stringCoder(constant);\n+                        }\n+                    }\n+\n+                    final int paramCount = args.parameterCount();\n+                    int[] paramSlots = new int[paramCount];\n+                    int[] paramStrings = new int[paramCount];\n+                    int strings = 0;\n+                    int argSlots = 0;\n+                    for (int i = 0; i < args.parameterCount(); i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = argSlots;\n+                        argSlots += kind.slotSize();\n+                        if (!directPrimive(cl)) {\n+                            paramStrings[i] = strings++;\n+                        }\n+                    }\n+\n+                    \/\/ string variants\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            cb.loadLocal(kind, paramSlots[i]);\n+                            if (cl == float.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Float, \"toString\", FLOAT_TO_STRING);\n+                            } else if (cl == double.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Double, \"toString\", DOUBLE_TO_STRING);\n+                            } else {\n+                                cb.invokestatic(STRING_CONCAT_HELPER, \"stringOf\", STRING_OFF);\n+                            }\n+                            cb.astore(argSlots + paramStrings[i]);\n+                        }\n+                    }\n+\n+                    int coderSlot = argSlots + strings;\n+                    int indexSlot = argSlots + strings + 1;\n+                    int bufSlot = argSlots + strings + 2;\n+                    cb.loadConstant(initalCoder);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            if (maybeUTF16(cl)) {\n+                                cb.aload(argSlots + paramStrings[i])\n+                                        .invokevirtual(ConstantDescs.CD_String, \"coder\", TO_BYTE)\n+                                        .ior();\n+                            }\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlots[i])\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"stringCoder\", CHAR_TO_BYTE)\n+                                    .ior();\n+                        }\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    cb.loadConstant(initalIndex);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        int pparamSlot = paramSlots[i];\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                                    .invokestatic(ConstantDescs.CD_Integer, \"stringSize\", INT_TO_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                                    .invokestatic(ConstantDescs.CD_Long, \"stringSize\", LONG_TO_INT);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"stringSize\", BOOLEAN_TO_INT);\n+                        } else if (cl == char.class) {\n+                            cb.iconst_1();\n+                        } else {\n+                            cb.aload(argSlots + paramStrings[i])\n+                                    .invokevirtual(ConstantDescs.CD_String, \"length\", TO_INT);\n+                        }\n+                        cb.iadd();\n+                    }\n+                    cb.dup()\n+                            .istore(indexSlot)\n+                            .iload(coderSlot)\n+                            .invokestatic(STRING_CONCAT_HELPER, \"newArray\", NEW_ARRAY)\n+                            .astore(bufSlot);\n+\n+                    prependConstant(cb, constants[constants.length - 1], bufSlot, indexSlot, coderSlot);\n+\n+                    for (int i = paramCount - 1; i >= 0; i--) {\n+                        int paramSlot = paramSlots[i];\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+\n+                        cb.iload(indexSlot)\n+                                .iload(coderSlot)\n+                                .aload(bufSlot);\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_LONG);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_BOOLEAN);\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR);\n+                        } else {\n+                            int strVarSlot = argSlots + paramStrings[i];\n+                            cb.aload(strVarSlot)\n+                                    .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING);\n+                        }\n+                        cb.istore(indexSlot);\n+\n+                        prependConstant(cb, constants[i], bufSlot, indexSlot, coderSlot);\n+                    }\n+\n+                    cb.new_(ConstantDescs.CD_String)\n+                            .dup()\n+                            .aload(bufSlot)\n+                            .iload(coderSlot)\n+                            .invokespecial(ConstantDescs.CD_String, \"<init>\", NEW_STRING)\n+                            .areturn();\n+                }\n+\n+                static void prependConstant(CodeBuilder cb, String constant, int bufSlot, int indexSlot, int coderSlot) {\n+                    if (constant == null) {\n+                        return;\n+                    }\n+                    if (constant.length() == 1) {\n+                        cb.iload(indexSlot)\n+                                .iload(coderSlot)\n+                                .aload(bufSlot)\n+                                .loadConstant((int) constant.charAt(0))\n+                                .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR)\n+                                .istore(indexSlot);\n+                        return;\n+                    }\n+\n+                    cb.iload(indexSlot)\n+                            .loadConstant(constant.length())\n+                            .isub()\n+                            .istore(indexSlot);\n+\n+                    cb.ldc(constant)\n+                            .aload(bufSlot)\n+                            .iload(indexSlot)\n+                            .iload(coderSlot)\n+                            .invokevirtual(CD_String, \"getBytes\", STR_GET_BYTES);\n+                }\n+\n+                static boolean directPrimive(Class<?> cl) {\n+                    return cl == byte.class\n+                            || cl == short.class\n+                            || cl == int.class\n+                            || cl == long.class\n+                            || cl == boolean.class\n+                            || cl == char.class;\n+                }\n+\n+                static boolean maybeUTF16(Class<?> cl) {\n+                    return cl != byte.class\n+                            && cl != short.class\n+                            && cl != int.class\n+                            && cl != long.class\n+                            && cl != boolean.class\n+                            && cl != Byte.class\n+                            && cl != Short.class\n+                            && cl != Integer.class\n+                            && cl != Long.class\n+                            && cl != Boolean.class;\n+                }\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":232,"deletions":12,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -455,0 +455,5 @@\n+    byte stringInitialCoder();\n+\n+    byte stringCoder(char ch);\n+    byte stringCoder(String str);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}