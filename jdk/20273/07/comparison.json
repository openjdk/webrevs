{"files":[{"patch":"@@ -442,0 +442,124 @@\n+    \/**\n+     * Prepends the stringly representation of boolean value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of char value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value) {\n+        index--;\n+        if (coder == String.LATIN1) {\n+            buf[index] = (byte) (value & 0xFF);\n+        } else {\n+            StringUTF16.putChar(buf, index, value);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of integer value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      integer value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of long value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value) {\n+        if (coder == String.LATIN1) {\n+            return StringLatin1.getChars(value, index, buf);\n+        } else {\n+            return StringUTF16.getChars(value, index, buf);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of String value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value) {\n+        index -= value.length();\n+        value.getBytes(buf, index, coder);\n+        return index;\n+    }\n+\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2642,0 +2642,12 @@\n+            public byte stringInitialCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(char value) {\n+                return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,1 +961,3 @@\n-                m.ensureTypeVisible(m.getDeclaringClass());\n+                if (allowedModes != LM_TRUSTED) {\n+                    m.ensureTypeVisible(m.getDeclaringClass());\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -112,0 +113,1 @@\n+    private static final boolean GENERATE_INLINE_COPY;\n@@ -116,0 +118,3 @@\n+\n+        String generateInlineCopy = VM.getSavedProperty(\"java.lang.invoke.StringConcat.generateInlineCopy\");\n+        GENERATE_INLINE_COPY = generateInlineCopy != null ? \"true\".equalsIgnoreCase(generateInlineCopy) : true;\n@@ -145,0 +150,5 @@\n+    @SuppressWarnings(\"removal\")\n+    private static boolean isGenerateInlineCopy() {\n+        return GENERATE_INLINE_COPY && System.getSecurityManager() == null;\n+    }\n+\n@@ -373,0 +383,1 @@\n+        MethodHandle mh = null;\n@@ -375,6 +386,7 @@\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+                if (mh != null) {\n+                    mh = mh.viewAsType(concatType, true);\n+                }\n+            }\n+            if (mh == null) {\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n@@ -382,0 +394,1 @@\n+            return new ConstantCallSite(mh);\n@@ -503,0 +516,5 @@\n+\n+        if (isGenerateInlineCopy()) {\n+            return null;\n+        }\n+\n@@ -1067,0 +1085,20 @@\n+        static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_byteArray = ClassDesc.ofDescriptor(\"[B\");\n+        static final MethodTypeDesc STRING_OFF = MethodTypeDesc.of(CD_String, CD_Object);\n+        static final MethodTypeDesc FLOAT_TO_STRING = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc DOUBLE_TO_STRING = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc TO_INT = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc INT_TO_INT = MethodTypeDesc.of(CD_int, CD_int);\n+        static final MethodTypeDesc LONG_TO_INT = MethodTypeDesc.of(CD_int, CD_long);\n+        static final MethodTypeDesc BOOLEAN_TO_INT = MethodTypeDesc.of(CD_int, CD_boolean);\n+        static final MethodTypeDesc TO_BYTE = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc CHAR_TO_BYTE = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc NEW_ARRAY = MethodTypeDesc.of(CD_byteArray, CD_int);\n+        static final MethodTypeDesc NEW_STRING = MethodTypeDesc.of(CD_void, CD_byteArray, CD_byte);\n+        static final MethodTypeDesc PREPEND_String = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_String);\n+        static final MethodTypeDesc PREPEND_int = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_int);\n+        static final MethodTypeDesc PREPEND_long = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_long);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_boolean);\n+        static final MethodTypeDesc PREPEND_char = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_char);\n+        static final MethodTypeDesc STR_GET_BYTES = MethodTypeDesc.of(CD_void, CD_byteArray, CD_int, CD_byte);\n+\n@@ -1080,1 +1118,2 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = MethodHandles.Lookup.IMPL_LOOKUP;\n+            String className = getClassName(String.class);\n@@ -1082,0 +1121,1 @@\n+            boolean generateInlineCopy = GENERATE_INLINE_COPY && args.parameterCount() <= HIGH_ARITY_THRESHOLD;\n@@ -1090,1 +1130,3 @@\n-                                        generateMethod(constants, args));\n+                                        generateInlineCopy\n+                                                ? generateInlineCopyMethod(constants, args)\n+                                                : generateMethod(constants, args));\n@@ -1093,4 +1135,3 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n+                var hiddenClass = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n+                        .defineClass(true, null);\n+                return lookup.findStatic(hiddenClass, METHOD_NAME, args);\n@@ -1146,0 +1187,212 @@\n+        private static Consumer<CodeBuilder> generateInlineCopyMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int initalIndex = 0;\n+                    int initalCoder = JLA.stringInitialCoder();\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            initalIndex += constant.length();\n+                            initalCoder |= JLA.stringCoder(constant);\n+                        }\n+                    }\n+\n+                    int paramCount = args.parameterCount();\n+\n+                    \/\/ Compute parameter and local string variable slots\n+                    int strings = 0;\n+                    int argSlots = 0;\n+                    int[] paramSlots = new int[paramCount];\n+                    \/\/ Types other than byte\/short\/int\/long\/boolean require a local variable to store\n+                    int[] paramStrLocalSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = argSlots;\n+                        argSlots += kind.slotSize();\n+                        if (needStringOf(cl)) {\n+                            paramStrLocalSlots[i] = strings++;\n+                        }\n+                    }\n+\n+                    \/*\n+                     * store string variants:\n+                     *\n+                     * str0 = Float.toString((float)args[0]);\n+                     * str1 = Double.toString((double)args[1]);\n+                     * ...\n+                     * strN = StringConcatHelper.stringOf(args(N));\n+                     *\n+                     *\/\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            cb.loadLocal(kind, paramSlots[i]);\n+                            if (cl == float.class) {\n+                                cb.invokestatic(CD_Float, \"toString\", FLOAT_TO_STRING);\n+                            } else if (cl == double.class) {\n+                                cb.invokestatic(CD_Double, \"toString\", DOUBLE_TO_STRING);\n+                            } else {\n+                                cb.invokestatic(CD_StringConcatHelper, \"stringOf\", STRING_OFF);\n+                            }\n+                            cb.astore(argSlots + paramStrLocalSlots[i]);\n+                        }\n+                    }\n+\n+                    int coderSlot = argSlots + strings;\n+                    int indexSlot = argSlots + strings + 1;\n+                    int bufSlot   = argSlots + strings + 2;\n+\n+                    \/*\n+                     * store init coder :\n+                     *\n+                     * coder = initalCoder;\n+                     * coder |= StringConcatHelper.stringCoder((char) args[1]);\n+                     * coder |= str0.coder();\n+                     *\n+                     *\/\n+                    cb.loadConstant(initalCoder);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(CD_StringConcatHelper, \"stringCoder\", CHAR_TO_BYTE)\n+                              .ior();\n+                        } else if (needStringOf(cl) && maybeUTF16(cl)) {\n+                            cb.aload(argSlots + paramStrLocalSlots[i])\n+                              .invokevirtual(CD_String, \"coder\", TO_BYTE)\n+                              .ior();\n+                        }\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    \/*\n+                     * store init index & allocate buffer :\n+                     *\n+                     * index = initalIndex;\n+                     * index += stringSize(args[0]);\n+                     * index += stringSize(args[i])\n+                     * ...\n+                     * buf = StringConcatHelper.newArray(index << coder)\n+                     *\n+                     *\/\n+                    cb.loadConstant(initalIndex);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        int pparamSlot = paramSlots[i];\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(CD_Integer, \"stringSize\", INT_TO_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(CD_Long, \"stringSize\", LONG_TO_INT);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"stringSize\", BOOLEAN_TO_INT);\n+                        } else if (cl == char.class) {\n+                            cb.iconst_1();\n+                        } else {\n+                            cb.aload(argSlots + paramStrLocalSlots[i])\n+                              .invokevirtual(CD_String, \"length\", TO_INT);\n+                        }\n+                        cb.iadd();\n+                    }\n+                    cb.dup()\n+                      .istore(indexSlot)\n+                      .iload(coderSlot)\n+                      .ishl()\n+                      .invokestatic(CD_StringConcatHelper, \"newArray\", NEW_ARRAY)\n+                      .astore(bufSlot);\n+\n+                    \/\/ prepend suffix\n+                    prependConstant(cb, constants[constants.length - 1], bufSlot, indexSlot, coderSlot);\n+\n+                    for (int i = paramCount - 1; i >= 0; i--) {\n+                        int paramSlot = paramSlots[i];\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+\n+                        \/\/ prepend arguments :\n+                        \/\/ StringConcatHelper.prepend(index, coder, buf, args[i])\n+                        cb.iload(indexSlot)\n+                          .iload(coderSlot)\n+                          .aload(bufSlot);\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_int);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_long);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_boolean);\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_char);\n+                        } else {\n+                            int strLocalSlot = argSlots + paramStrLocalSlots[i];\n+                            cb.aload(strLocalSlot)\n+                              .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_String);\n+                        }\n+                        cb.istore(indexSlot);\n+\n+                        \/\/ prepend prefix constant\n+                        prependConstant(cb, constants[i], bufSlot, indexSlot, coderSlot);\n+                    }\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, \"<init>\", NEW_STRING)\n+                      .areturn();\n+                }\n+\n+                static void prependConstant(CodeBuilder cb, String constant, int bufSlot, int indexSlot, int coderSlot) {\n+                    if (constant == null) {\n+                        return;\n+                    }\n+\n+                    if (constant.length() == 1) {\n+                        \/\/ StringConcatHelper.prepend(index, coder, buf, constant.charAt(0))\n+                        cb.iload(indexSlot)\n+                          .iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadConstant((int) constant.charAt(0))\n+                          .invokestatic(CD_StringConcatHelper, \"prepend\", PREPEND_char)\n+                          .istore(indexSlot);\n+                        return;\n+                    }\n+\n+                    \/\/ index -= constant.length()\n+                    cb.iload(indexSlot)\n+                      .loadConstant(constant.length())\n+                      .isub()\n+                      .istore(indexSlot);\n+\n+                    \/\/ constant.getBytes(buf, index, coder);\n+                    cb.ldc(constant)\n+                      .aload(bufSlot)\n+                      .iload(indexSlot)\n+                      .iload(coderSlot)\n+                      .invokevirtual(CD_String, \"getBytes\", STR_GET_BYTES);\n+                }\n+\n+                static boolean needStringOf(Class<?> cl) {\n+                    return cl != byte.class && cl != short.class   && cl != int.class\n+                        && cl != long.class && cl != boolean.class && cl != char.class;\n+                }\n+\n+                static boolean maybeUTF16(Class<?> cl) {\n+                    return cl != byte.class && cl != short.class && cl != int.class\n+                        && cl != long.class && cl != boolean.class\n+                        && cl != Byte.class && cl != Short.class && cl != Integer.class\n+                        && cl != Long.class && cl != Boolean.class;\n+                }\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":265,"deletions":12,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -455,0 +455,5 @@\n+    byte stringInitialCoder();\n+\n+    byte stringCoder(char ch);\n+    byte stringCoder(String str);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}