{"files":[{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.StringBuilder;\n+\n+import java.lang.invoke.*;\n+import java.lang.management.ManagementFactory;\n+\n+\/**\n+ * @test\n+ * @summary Test whether the hidden class unloading of StringConcatFactory works\n+ *\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all HiddenClassUnloading\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all -XX:-CompactStrings HiddenClassUnloading\n+ *\/\n+public class HiddenClassUnloading {\n+    public static void main(String[] args) throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        Class<?>[] types = new Class[] {\n+                int.class, long.class, double.class, float.class, char.class, boolean.class, String.class,\n+        };\n+        Object[] values = new Object[] {\n+                1, 1L, 1D, 1F, 'C', true, \"A\",\n+        };\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            int radix = types.length;\n+            String str = Integer.toString(i, radix);\n+            int length = str.length();\n+            String recipe = \"\\1\".repeat(length);\n+            Class<?>[] ptypes = new Class[length];\n+            Object[] pvalues = new Object[length];\n+            for (int j = 0; j < length; j++) {\n+                int index = Integer.parseInt(str.substring(j, j + 1), radix);\n+                ptypes[j] = types[index];\n+                pvalues[j] = values[index];\n+            }\n+            MethodType concatType = MethodType.methodType(String.class, ptypes);\n+            CallSite callSite = StringConcatFactory.makeConcatWithConstants(\n+                    lookup,\n+                    \"concat\",\n+                    concatType,\n+                    recipe,\n+                    new Object[0]\n+            );\n+            MethodHandle mh = callSite.dynamicInvoker();\n+            String result = switch (length) {\n+                case 1  -> (String) mh.invoke(pvalues[0]);\n+                case 2  -> (String) mh.invoke(pvalues[0], pvalues[1]);\n+                case 3  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2]);\n+                case 4  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3]);\n+                case 5  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3], pvalues[4]);\n+                case 6  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3], pvalues[4], pvalues[5]);\n+                case 7  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3], pvalues[4], pvalues[5], pvalues[6]);\n+                case 8  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3], pvalues[4], pvalues[5], pvalues[6], pvalues[7]);\n+                case 9  -> (String) mh.invoke(pvalues[0], pvalues[1], pvalues[2], pvalues[3], pvalues[4], pvalues[5], pvalues[6], pvalues[7], pvalues[8]);\n+                default -> throw new RuntimeException(\"length too large \" + length);\n+            };\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (int j = 0; j < pvalues.length; j++) {\n+                sb.append(pvalues[j]);\n+            }\n+            assertEquals(sb.toString(), result);\n+        }\n+\n+        long unloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+        if (unloadedClassCount == 0) {\n+            throw new RuntimeException(\"unloadedClassCount is zero\");\n+        }\n+    }\n+\n+    static void assertEquals(String expected, String actual) {\n+       if (!expected.equals(actual)) {\n+           StringBuilder sb = new StringBuilder();\n+           sb.append(\"Expected = \");\n+           sb.append(expected);\n+           sb.append(\", actual = \");\n+           sb.append(actual);\n+           throw new IllegalStateException(sb.toString());\n+       }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}