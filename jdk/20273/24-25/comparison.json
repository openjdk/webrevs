{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,18 @@\n+\n+    static class StringConcatBase {\n+        @Stable String[] constants;\n+        @Stable int length;\n+        @Stable byte coder;\n+        StringConcatBase(String[] constants) {\n+            int length = 0;\n+            byte coder = String.LATIN1;\n+            this.constants = constants;\n+            for (String c : constants) {\n+                length += c.length();\n+                coder |= c.coder();\n+            }\n+            this.length = length;\n+            this.coder = coder;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.util.ReferenceKey;\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -42,1 +44,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -45,0 +46,2 @@\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n@@ -47,0 +50,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +52,1 @@\n+import java.util.function.Supplier;\n@@ -433,1 +438,1 @@\n-                consts[oCount++] = acc.length() > 0 ? acc.toString() : null;\n+                consts[oCount++] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -449,1 +454,1 @@\n-        consts[oCount] = acc.length() > 0 ? acc.toString() : null;\n+        consts[oCount] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -483,2 +488,2 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n@@ -489,1 +494,1 @@\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n+            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n@@ -493,2 +498,2 @@\n-        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n+                && constants[0].isEmpty() && constants[1].isEmpty()) {\n@@ -1064,0 +1069,3 @@\n+        static final String LENGTH = \"length\";\n+        static final String CODER = \"coder\";\n+        static final String CONSTANTS = \"constants\";\n@@ -1067,0 +1075,1 @@\n+        static final ClassDesc CD_StringConcatBase = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n@@ -1068,1 +1077,2 @@\n-\n+        static final ClassDesc CD_Array_String       = ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\");\n+        static final MethodTypeDesc ARRAY_STRING_TO_VOID = MethodTypeDesc.of(CD_void, CD_Array_String);\n@@ -1076,0 +1086,2 @@\n+        static final MethodTypeDesc MTD_int     = MethodTypeDesc.of(CD_int);\n+\n@@ -1088,0 +1100,21 @@\n+        private static final Consumer<CodeBuilder> CONSTRUCTOR_BUILDER = new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cb) {\n+                int thisSlot = cb.receiverSlot();\n+                int constantsSlot = cb.parameterSlot(0);\n+                cb.aload(thisSlot);\n+                cb.aload(constantsSlot);\n+                cb.invokespecial(CD_StringConcatBase, INIT_NAME, ARRAY_STRING_TO_VOID, false);\n+                cb.return_();\n+            }\n+        };\n+\n+        static final ReferencedKeyMap<MethodType, SoftReference<MethodHandlePair>> CACHE =\n+                ReferencedKeyMap.create(true, true,\n+                        new Supplier<>() {\n+                            @Override\n+                            public Map<ReferenceKey<MethodType>, SoftReference<MethodHandlePair>> get() {\n+                                return new ConcurrentHashMap<>(64);\n+                            }\n+                        });\n+\n@@ -1092,12 +1125,1 @@\n-        private static MethodType erase(MethodType args) {\n-            var bootstrapClassLoader = String.class.getClassLoader();\n-            var paramTypes = args.parameterArray();\n-            boolean changed = false;\n-            for (int i = 0; i < paramTypes.length; ++i) {\n-                if (paramTypes[i].getClassLoader() != bootstrapClassLoader) {\n-                    paramTypes[i] = Object.class;\n-                    changed = true;\n-                }\n-            }\n-            return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n-        }\n+        private record MethodHandlePair(MethodHandle constructor, MethodHandle concatenator) { };\n@@ -1106,5 +1128,27 @@\n-            lookup         = MethodHandles.Lookup.IMPL_LOOKUP;\n-            var erasedArgs = erase(args);\n-            var className  = getClassName(String.class);\n-\n-            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n+            lookup = MethodHandles.Lookup.IMPL_LOOKUP;\n+            String className = \"java.lang.String$$StringConcat\";\n+            MethodType erasedArgs = args.erase().changeReturnType(String.class);\n+            for (int i = 0; i < erasedArgs.parameterCount(); i++) {\n+                Class<?> cl = erasedArgs.parameterType(i);\n+                \/\/ Use int as the logical type for subword integral types\n+                \/\/ (byte and short). char and boolean require special\n+                \/\/ handling so don't change the logical type of those\n+                if (cl == byte.class || cl == short.class) {\n+                    erasedArgs = erasedArgs.changeParameterType(i, int.class);\n+                }\n+            }\n+            final MethodType concatArgs = erasedArgs;\n+            SoftReference<MethodHandlePair> weakConstructorHandle = CACHE.get(concatArgs);\n+            if (weakConstructorHandle != null) {\n+                MethodHandlePair handlePair = weakConstructorHandle.get();\n+                if (handlePair != null) {\n+                    try {\n+                        var instance = handlePair.constructor.invoke(constants);\n+                        return handlePair.concatenator.bindTo(instance);\n+                    } catch (Throwable e) {\n+                        throw new StringConcatException(\"Exception while utilizing the hidden class\", e);\n+                    }\n+                }\n+            }\n+            ClassDesc concatClass = ConstantUtils.binaryNameToDesc(className);\n+            byte[] classBytes = ClassFile.of().build(concatClass,\n@@ -1114,1 +1158,7 @@\n-                            clb.withFlags(ClassFile.ACC_FINAL | ClassFile.ACC_SUPER | ClassFile.ACC_SYNTHETIC)\n+                            clb.withSuperclass(CD_StringConcatBase)\n+                                .withFlags(ClassFile.ACC_FINAL | ClassFile.ACC_SUPER | ClassFile.ACC_SYNTHETIC)\n+                                .withMethodBody(\"<init>\",\n+                                        ARRAY_STRING_TO_VOID,\n+                                        ClassFile.ACC_PRIVATE,\n+                                        CONSTRUCTOR_BUILDER\n+                                )\n@@ -1116,3 +1166,3 @@\n-                                        ConstantUtils.methodTypeDesc(erasedArgs),\n-                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n-                                        generateMethod(constants, erasedArgs));\n+                                        ConstantUtils.methodTypeDesc(concatArgs),\n+                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE,\n+                                        generateConcatMethod(concatClass, concatArgs));\n@@ -1123,2 +1173,7 @@\n-                return lookup.findStatic(hiddenClass, METHOD_NAME, erasedArgs);\n-            } catch (Exception e) {\n+\n+                MethodHandle constructorHandle = lookup.findConstructor(hiddenClass, MethodType.methodType(void.class, String[].class));\n+                var instance = hiddenClass.cast(constructorHandle.invoke(constants));\n+                MethodHandle handle = lookup.findVirtual(hiddenClass, METHOD_NAME, concatArgs);\n+                CACHE.put(concatArgs, new SoftReference<>(new MethodHandlePair(constructorHandle, handle)));\n+                return handle.bindTo(instance);\n+            } catch (Throwable e) {\n@@ -1140,3 +1195,11 @@\n-         * public static String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4, float arg5, double arg6, Object arg7) {\n-         *     String constant0, constant1, ..., constant8;\n-         *     int lengthCoder = ...;\n+         * class StringConcat extends java.lang.StringConcatHelper.StringConcatBase {\n+         *   \/\/ super class defines\n+         *   \/\/ String[] constants;\n+         *   \/\/ int length;\n+         *   \/\/ byte coder;\n+         *\n+         *   StringConcat(String[] constants) {\n+         *       super(constants);\n+         *   }\n+         *   String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4, float arg5, double arg6, Object arg7) {\n+         *     long lengthCoder = this.length + (this.coder << 32L);\n@@ -1153,1 +1216,1 @@\n-         *                   mix(mix(mix(mix(engthCoder,\n+         *                   mix(mix(mix(mix(lengthCoder,\n@@ -1157,1 +1220,1 @@\n-         *     String suffix = constant9;\n+         *     String suffix = constant[8];\n@@ -1163,4 +1226,4 @@\n-         *                        buf, str7, constant7), buf, str6, constant6),\n-         *                        buf, str5, constant5), buf, arg4, constant4),\n-         *                        buf, arg3, constant3), buf, arg2, constant2),\n-         *                        buf, arg1, constant1), buf, arg0, constant0);\n+         *                        buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                        buf, str5, constant[5]), buf, arg4, constant[4]),\n+         *                        buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                        buf, arg1, constant[1]), buf, arg0, constant[0]);\n@@ -1172,1 +1235,1 @@\n-        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+        private static Consumer<CodeBuilder> generateConcatMethod(ClassDesc concatClass, MethodType args) {\n@@ -1176,6 +1239,1 @@\n-                    long initalLengthCoder = JLA.stringConcatInitialCoder();\n-                    for (var constant : constants) {\n-                        if (constant != null) {\n-                            initalLengthCoder = JLA.stringConcatMix(initalLengthCoder, constant);\n-                        }\n-                    }\n+                    int paramCount = args.parameterCount();\n@@ -1183,5 +1241,3 @@\n-                    var paramCount = args.parameterCount();\n-\n-                    \/\/ Compute parameter and local string variable slots\n-                    int paramSlotsTotalSize = 0;\n-                    var paramSlots          = new int[paramCount];\n+                    \/\/ Compute parameter variable slots\n+                    int   nextSlot = 1;\n+                    int[] paramSlots          = new int[paramCount];\n@@ -1189,2 +1245,38 @@\n-                        paramSlots[i]        = paramSlotsTotalSize;\n-                        paramSlotsTotalSize += TypeKind.from(args.parameterType(i)).slotSize();\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = nextSlot;\n+                        nextSlot += kind.slotSize();\n+\n+                        \/*\n+                         * Stringify by storing String variants in\n+                         * repurposed argument slots:\n+                         *\n+                         * arg0 = Float.toString(args0);\n+                         * arg1 = Double.toString(arg1);\n+                         * ...\n+                         * argN = StringConcatHelper.stringOf(argN);\n+                         *\n+                         *\n+                         *\/\n+                        if (needStringOf(cl)) {\n+                            ClassDesc classDesc;\n+                            MethodTypeDesc methodTypeDesc;\n+                            String methodName;\n+                            if (cl == float.class) {\n+                                classDesc = CD_Float;\n+                                methodName = \"toString\";\n+                                methodTypeDesc = FLOAT_TO_STRING;\n+                            } else if (cl == double.class) {\n+                                classDesc = CD_Double;\n+                                methodName = \"toString\";\n+                                methodTypeDesc = DOUBLE_TO_STRING;\n+                            } else {\n+                                classDesc = CD_StringConcatHelper;\n+                                methodName = \"stringOf\";\n+                                methodTypeDesc = OBJECT_TO_STRING;\n+                            }\n+\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(classDesc, methodName, methodTypeDesc)\n+                              .astore(paramSlots[i]);\n+                        }\n@@ -1193,2 +1285,0 @@\n-                    int lengthCoderSlot = paramSlotsTotalSize;\n-                    int bufSlot         = paramSlotsTotalSize + TypeKind.from(long.class).slotSize();\n@@ -1196,43 +1286,3 @@\n-                    \/*\n-                     * store string variants:\n-                     *\n-                     * str0 = Float.toString(args(0));\n-                     * str1 = Double.toString(args(1));\n-                     * ...\n-                     * strN = StringConcatHelper.stringOf(args(N));\n-                     *\n-                     *\/\n-                    for (int i = 0, strings = 0; i < paramCount; i++) {\n-                        var cl = args.parameterType(i);\n-                        if (!needStringOf(cl)) {\n-                            continue;\n-                        }\n-\n-                        ClassDesc classDesc;\n-                        MethodTypeDesc methodTypeDesc;\n-                        String methodName;\n-                        if (cl == float.class) {\n-                            classDesc      = CD_Float;\n-                            methodName     = \"toString\";\n-                            methodTypeDesc = FLOAT_TO_STRING;\n-                        } else if (cl == double.class) {\n-                            classDesc      = CD_Double;\n-                            methodName     = \"toString\";\n-                            methodTypeDesc = DOUBLE_TO_STRING;\n-                        } else {\n-                            classDesc      = CD_StringConcatHelper;\n-                            methodName     = \"stringOf\";\n-                            methodTypeDesc = OBJECT_TO_STRING;\n-                        }\n-\n-                        \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n-                        int strLocalSlot = (cl == String.class)\n-                                ? paramSlots[i]\n-                                : bufSlot + (++strings);\n-                        cb.loadLocal(TypeKind.from(cl), paramSlots[i])\n-                          .invokestatic(classDesc, methodName, methodTypeDesc)\n-                          .astore(strLocalSlot);\n-                        if (cl != String.class) {\n-                            paramSlots[i] = strLocalSlot;\n-                        }\n-                    }\n+                    int lengthCoderSlot = nextSlot;\n+                    int bufSlot         = nextSlot + 2;\n+                    int constantsSlot   = nextSlot + 3;\n@@ -1247,1 +1297,10 @@\n-                    cb.loadConstant(initalLengthCoder);\n+                    cb.aload(0)\n+                      .getfield(concatClass, CODER, CD_byte)\n+                      .i2l()\n+                      .ldc(32)\n+                      .lshl()\n+                      .aload(0)\n+                      .getfield(concatClass, LENGTH, CD_int)\n+                      .i2l()\n+                      .ladd();\n+\n@@ -1269,1 +1328,0 @@\n-                    cb.lstore(lengthCoderSlot);\n@@ -1271,11 +1329,11 @@\n-                    var suffix = constants[constants.length - 1];\n-                    if (suffix == null) {\n-                        suffix = \"\";\n-                    }\n-                    if (!suffix.isEmpty()) {\n-                        \/\/ lengthCoder = lengthCoder - suffix.length()\n-                        cb.lload(lengthCoderSlot)\n-                          .ldc((long) suffix.length())\n-                          .lsub()\n-                          .lstore(lengthCoderSlot);\n-                    }\n+                    \/\/ lengthCoder = lengthCoder - suffix.length()\n+                    cb.aload(0)\n+                      .getfield(concatClass, CONSTANTS, CD_Array_String)\n+                      .astore(constantsSlot)\n+                      .aload(constantsSlot)\n+                      .ldc(paramCount)\n+                      .aaload()\n+                      .invokevirtual(CD_String, LENGTH, MTD_int)\n+                      .i2l()\n+                      .lsub()\n+                      .lstore(lengthCoderSlot);\n@@ -1287,1 +1345,3 @@\n-                    cb.ldc(suffix)\n+                    cb.aload(constantsSlot)\n+                      .ldc(paramCount)\n+                      .aaload()\n@@ -1315,4 +1375,0 @@\n-                        var constant = constants[i];\n-                        if (constant == null) {\n-                            constant = \"\";\n-                        }\n@@ -1321,1 +1377,3 @@\n-                          .ldc(constant)\n+                          .aload(constantsSlot)\n+                          .ldc(i)\n+                          .aaload()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":177,"deletions":119,"binary":false,"changes":296,"status":"modified"}]}