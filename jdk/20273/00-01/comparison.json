{"files":[{"patch":"@@ -47,51 +47,0 @@\n-    \/**\n-     * add value length into current length\n-     * @param length      String length\n-     * @param value       value to mix in\n-     * @return            new length\n-     *\/\n-    @ForceInline\n-    static int stringSize(int length, boolean value) {\n-        return length + (value ? 4 : 5);\n-    }\n-\n-    \/**\n-     * add value length into current length\n-     * @param length      String length\n-     * @param value       value to mix in\n-     * @return            new length\n-     *\/\n-    static int stringSize(int length, char value) {\n-        return length + 1;\n-    }\n-\n-    \/**\n-     * add value length into current length\n-     * @param length      String length\n-     * @param value       value to mix in\n-     * @return            new length\n-     *\/\n-    static int stringSize(int length, int value) {\n-        return length + Integer.stringSize(value);\n-    }\n-\n-    \/**\n-     * add value length into current length\n-     * @param length      String length\n-     * @param value       value to mix in\n-     * @return            new length\n-     *\/\n-    static int stringSize(int length, long value) {\n-        return length + Long.stringSize(value);\n-    }\n-\n-    \/**\n-     * add value length into current length\n-     * @param length      String length\n-     * @param value       value to mix in\n-     * @return            new length\n-     *\/\n-    static int stringSize(int length, String value) {\n-        return length + value.length();\n-    }\n-\n@@ -139,17 +88,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static int prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n-        index = prepend(index, coder, buf, value);\n-        index = prepend(index, coder, buf, prefix);\n-        return index;\n-    }\n-\n@@ -176,17 +108,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n-        index = prepend(index, coder, buf, value);\n-        index = prepend(index, coder, buf, prefix);\n-        return index;\n-    }\n-\n@@ -211,17 +126,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n-        index = prepend(index, coder, buf, value);\n-        index = prepend(index, coder, buf, prefix);\n-        return index;\n-    }\n-\n@@ -246,17 +144,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n-        index = prepend(index, coder, buf, value);\n-        index = prepend(index, coder, buf, prefix);\n-        return index;\n-    }\n-\n@@ -279,49 +160,0 @@\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param index      final char index in the buffer\n-     * @param coder      the coder of buf\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n-        index = prepend(index, coder, buf, value);\n-        index = prepend(index, coder, buf, prefix);\n-        return index;\n-    }\n-\n-    \/**\n-     * Instantiates the String with given buffer and coder\n-     * @param buf           buffer to use\n-     * @param indexCoder    remaining index (should be zero) and coder\n-     * @return String       resulting string\n-     *\/\n-    @ForceInline\n-    static String newString(byte[] buf, byte coder) {\n-        \/\/ Use the private, non-copying constructor (unsafe!)\n-        return new String(buf, coder);\n-    }\n-\n-    static byte stringCoder(byte coder, char value) {\n-        return StringLatin1.canEncode(value) ? coder : String.UTF16;\n-    }\n-\n-    static byte stringCoder(byte coder, int value) {\n-        return coder;\n-    }\n-\n-    static byte stringCoder(byte coder, long value) {\n-        return coder;\n-    }\n-\n-    static byte stringCoder(byte coder, boolean value) {\n-        return coder;\n-    }\n-\n-    static byte stringCoder(byte coder, String str) {\n-        return (byte) (coder | str.coder());\n-    }\n-\n@@ -399,18 +231,0 @@\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder\n-     * information, then prepends the given suffix string at the end of the\n-     * byte array before returning it. The calling code must adjust the\n-     * indexCoder so that it's taken the coder of the suffix into account, but\n-     * subtracted the length of the suffix.\n-     *\n-     * @param suffix\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArrayWithSuffix(String suffix, int index, byte coder) {\n-        byte[] buf = newArray((index + suffix.length()) << coder);\n-        suffix.getBytes(buf, index, coder);\n-        return buf;\n-    }\n-\n@@ -450,0 +264,8 @@\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n@@ -459,0 +281,3 @@\n+    static MethodHandles.Lookup lookup() {\n+        return MethodHandles.lookup();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":11,"deletions":186,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -2614,0 +2615,4 @@\n+            public MethodHandles.Lookup stringConcatLookup() {\n+                return StringConcatHelper.lookup();\n+            }\n+\n@@ -2618,0 +2623,4 @@\n+            public int stringSize(int i) {\n+                return Integer.stringSize(i);\n+            }\n+\n@@ -2634,0 +2643,4 @@\n+            public byte stringCoder(char value) {\n+                return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -374,0 +376,1 @@\n+        MethodHandle mh;\n@@ -375,4 +378,3 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n+            mh = generateMHInlineCopy(concatType, constantStrings);\n+            if (mh != null) {\n+                mh = mh.viewAsType(concatType, true);\n@@ -380,2 +382,1 @@\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n@@ -389,0 +390,1 @@\n+        return new ConstantCallSite(mh);\n@@ -504,186 +506,0 @@\n-        \/\/ else... fall-through to slow-path\n-\n-        \/\/ Create filters and obtain filtered parameter types. Filters would be used in the beginning\n-        \/\/ to convert the incoming arguments into the arguments we can process (e.g. Objects -> Strings).\n-        \/\/ The filtered argument type list is used all over in the combinators below.\n-\n-        Class<?>[] ptypes = mt.erase().parameterArray();\n-        MethodHandle[] objFilters = null;\n-        MethodHandle[] floatFilters = null;\n-        MethodHandle[] doubleFilters = null;\n-        for (int i = 0; i < ptypes.length; i++) {\n-            Class<?> cl = ptypes[i];\n-            \/\/ Use int as the logical type for subword integral types\n-            \/\/ (byte and short). char and boolean require special\n-            \/\/ handling so don't change the logical type of those\n-            ptypes[i] = promoteToIntType(ptypes[i]);\n-            \/\/ Object, float and double will be eagerly transformed\n-            \/\/ into a (non-null) String as a first step after invocation.\n-            \/\/ Set up to use String as the logical type for such arguments\n-            \/\/ internally.\n-            if (cl == Object.class) {\n-                if (objFilters == null) {\n-                    objFilters = new MethodHandle[ptypes.length];\n-                }\n-                objFilters[i] = objectStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == float.class) {\n-                if (floatFilters == null) {\n-                    floatFilters = new MethodHandle[ptypes.length];\n-                }\n-                floatFilters[i] = floatStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == double.class) {\n-                if (doubleFilters == null) {\n-                    doubleFilters = new MethodHandle[ptypes.length];\n-                }\n-                doubleFilters[i] = doubleStringifier();\n-                ptypes[i] = String.class;\n-            }\n-        }\n-\n-        \/\/ Start building the combinator tree. The tree \"starts\" with (<parameters>)String, and \"finishes\"\n-        \/\/ with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are\n-        \/\/ assembled bottom-up, which makes the code arguably hard to read.\n-\n-        \/\/ Drop all remaining parameter types, leave only helper arguments:\n-        MethodHandle mh = MethodHandles.dropArgumentsTrusted(newString(), 1, new Class<?>[]{int.class});\n-        mh = MethodHandles.dropArgumentsTrusted(mh, 3, ptypes);\n-\n-        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n-        \/\/ their lengths and adjusting the encoded coder bit if needed\n-        int initialCoder = INITIAL_CODER;\n-        int initialSize = 0;\n-\n-        for (String constant : constants) {\n-            if (constant != null) {\n-                initialSize += constant.length();\n-                initialCoder |= JLA.stringCoder(constant);\n-            }\n-        }\n-\n-        \/\/ size and coder in prependers. This happens when (byte[], int, byte) = (storage, index, coder) is already\n-        \/\/ known from the combinators below. We are assembling the string backwards, so the index coded\n-        \/\/ into indexCoder is the *ending* index.\n-        mh = filterInPrependers(mh, constants, ptypes);\n-\n-        \/\/ Fold in byte[] instantiation at argument 0\n-        MethodHandle newArrayCombinator;\n-        if (suffix != null) {\n-            \/\/ newArray variant that deals with prepending any trailing constant\n-            \/\/\n-            \/\/ initialLengthCoder is adjusted to have the correct coder\n-            \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n-            \/\/ suffix to be encoded into indexCoder\n-            initialSize -= suffix.length();\n-            newArrayCombinator = newArrayWithSuffix(suffix);\n-        } else {\n-            newArrayCombinator = newArray();\n-        }\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1, \/\/ index\n-                2  \/\/ coder\n-        );\n-\n-        \/\/ Start combining size and coder.\n-        \/\/\n-        \/\/ Length is easy: constant lengths can be computed on the spot, and all non-constant\n-        \/\/ shapes have been either converted to Strings, or explicit methods for getting the\n-        \/\/ string length out of primitives are provided.\n-        \/\/\n-        \/\/ Coders are more interesting. Only Object, String and char arguments (and constants)\n-        \/\/ can have non-Latin1 encoding. It is easier to blindly convert constants to String,\n-        \/\/ and deduce the coder from there. Arguments would be either converted to Strings\n-        \/\/ during the initial filtering, or handled by specializations in size and coder.\n-        \/\/\n-        \/\/ The method handle shape before all size and coder are combined in is:\n-        \/\/   (long, <args>)String = (\"indexCoder\", <args>)\n-        \/\/\n-        \/\/ We will bind the initialLengthCoder value to the last size and coder (the one that will be\n-        \/\/ executed first), then fold that in. This leaves the shape after all size and coder are\n-        \/\/ combined in as:\n-        \/\/   (<args>)String = (<args>)\n-\n-        mh = filterAndFoldInSizeCoders(mh, initialSize, (byte) initialCoder, ptypes);\n-\n-        \/\/ The method handle shape here is (<args>).\n-\n-        \/\/ Apply filters, converting the arguments:\n-        if (objFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, objFilters);\n-        }\n-        if (floatFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, floatFilters);\n-        }\n-        if (doubleFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, doubleFilters);\n-        }\n-\n-        return mh;\n-    }\n-\n-    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n-    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n-    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n-    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n-    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n-    private static MethodHandle filterInPrependers(MethodHandle mh, String[] constants, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        MethodHandle prepend;\n-        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n-            prepend = prepender(pos, constants, ptypes, 4);\n-            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        if (pos < ptypes.length) {\n-            int count = ptypes.length - pos;\n-            prepend = prepender(pos, constants, ptypes, count);\n-            argPositions = filterPrependArgPositions(argPositions, pos, count);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 3) {\n-            argPositions = new int[count + 3];\n-            argPositions[0] = 1; \/\/ index\n-            argPositions[1] = 2; \/\/ coder\n-            argPositions[2] = 0; \/\/ storage\n-        }\n-        int limit = count + 3;\n-        for (int i = 3; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-\n-    \/\/ We need one size and coder per argument.\n-    private static MethodHandle filterAndFoldInSizeCoders(MethodHandle mh, int initialSize, byte initialCoder, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n-            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n-            MethodHandle stringSize = stringSize(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            argPositions = filterSizeArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n-                    stringSize, argPositions);\n-\n-            MethodHandle stringCoder = stringCoder(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            argPositions = filterCoderArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1,\n-                    stringCoder, argPositions);\n-        }\n-\n-        if (pos < ptypes.length) {\n-            \/\/ size and coder in the last 1 to 4 parameters, insert the initialSize and initialCoder into the final size and coder and\n-            \/\/ fold the result into the main combinator\n-            mh = foldInLastSizeCoders(mh, initialSize, initialCoder, pos, ptypes, ptypes.length - pos);\n-        } else if (ptypes.length == 0) {\n-            \/\/ No size and coder (constants only concat), insert initialSize and initialCoder directly\n-            mh = MethodHandles.insertArguments(mh, 0, initialSize, initialCoder);\n-        }\n-        return mh;\n-    }\n@@ -691,271 +507,1 @@\n-    static int[] filterSizeArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 1];\n-            argPositions[0] = 0; \/\/ index\n-        }\n-        int limit = count + 1;\n-        for (int i = 1; i < limit; i++) {\n-            argPositions[i] = i + pos + 1;\n-        }\n-        return argPositions;\n-    }\n-\n-    static int[] filterCoderArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 1];\n-            argPositions[0] = 1; \/\/ coder\n-        }\n-        int limit = count + 1;\n-        for (int i = 1; i < limit; i++) {\n-            argPositions[i] = i + pos + 1;\n-        }\n-        return argPositions;\n-    }\n-\n-    private static MethodHandle foldInLastSizeCoders(MethodHandle mh, int initialLength, byte initalCoder, int pos, Class<?>[] ptypes, int count) {\n-        MethodHandle stringSize = switch (count) {\n-            case 1 -> stringSize(ptypes[pos]);\n-            case 2 -> stringSize(ptypes[pos], ptypes[pos + 1]);\n-            case 3 -> stringSize(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            case 4 -> stringSize(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        };\n-        stringSize = MethodHandles.insertArguments(stringSize, 0, initialLength);\n-\n-        MethodHandle coder = switch (count) {\n-            case 1 -> stringCoder(ptypes[pos]);\n-            case 2 -> stringCoder(ptypes[pos], ptypes[pos + 1]);\n-            case 3 -> stringCoder(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            case 4 -> stringCoder(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        };\n-        coder = MethodHandles.insertArguments(coder, 0, initalCoder);\n-\n-        \/\/ MethodHandles.identity(int.class)\n-        \/\/ apply selected arguments on the 1-4 arg size & coder and fold in the result\n-        switch (count) {\n-            case 1:\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, stringSize,\n-                        2 + pos);\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, coder,\n-                        1 + pos);\n-                break;\n-            case 2:\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, stringSize,\n-                        2 + pos, 3 + pos);\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, coder,\n-                        1 + pos, 2 + pos);\n-                break;\n-            case 3:\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, stringSize,\n-                        2 + pos, 3 + pos, 4 + pos);\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, coder,\n-                        1 + pos, 2 + pos, 3 + pos);\n-                break;\n-            case 4:\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, stringSize,\n-                        2 + pos, 3 + pos, 4 + pos, 5 + pos);\n-                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, coder,\n-                        1 + pos, 2 + pos, 3 + pos, 4 + pos);\n-                break;\n-            default:\n-                throw new IllegalArgumentException();\n-        };\n-\n-        return mh;\n-    }\n-\n-    \/\/ Simple prependers, single argument. May be used directly or as a\n-    \/\/ building block for complex prepender combinators.\n-    private static MethodHandle prepender(String prefix, Class<?> cl) {\n-        if (prefix == null || prefix.isEmpty()) {\n-            return noPrefixPrepender(cl);\n-        } else {\n-            return MethodHandles.insertArguments(\n-                    prepender(cl), 4, prefix);\n-        }\n-    }\n-\n-    private static MethodHandle prepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = PREPENDERS[idx];\n-        if (prepend == null) {\n-            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(int.class, int.class, byte.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n-        if (prepend == null) {\n-            NO_PREFIX_PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(int.class, int.class, byte.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static final int INT_IDX = 0,\n-            CHAR_IDX = 1,\n-            LONG_IDX = 2,\n-            BOOLEAN_IDX = 3,\n-            STRING_IDX = 4,\n-            TYPE_COUNT = 5;\n-    private static int classIndex(Class<?> cl) {\n-        if (cl == String.class)                          return STRING_IDX;\n-        if (cl == int.class)                             return INT_IDX;\n-        if (cl == boolean.class)                         return BOOLEAN_IDX;\n-        if (cl == char.class)                            return CHAR_IDX;\n-        if (cl == long.class)                            return LONG_IDX;\n-        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n-    }\n-\n-    \/\/ Constant argument lists used by the prepender MH builders\n-    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2, 3 };\n-    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 2, 4 };\n-    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 2, 5 };\n-    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3, 4 };\n-    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 2, 5, 6 };\n-\n-    \/\/ Base MH for complex prepender combinators.\n-    private static @Stable MethodHandle PREPEND_BASE;\n-    private static MethodHandle prependBase() {\n-        MethodHandle base = PREPEND_BASE;\n-        if (base == null) {\n-            base = PREPEND_BASE = MethodHandles.dropArguments(\n-                    MethodHandles.identity(int.class), 1, byte.class, byte[].class);\n-        }\n-        return base;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-\n-    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n-        if (prepend == null) {\n-            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n-                    MethodHandles.dropArguments(prependBase(), 3, cl, cl2);\n-        }\n-        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n-                PREPEND_FILTER_FIRST_ARGS);\n-        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n-                PREPEND_FILTER_SECOND_ARGS);\n-    }\n-\n-    private static MethodHandle prepender(int pos, String[] constants, Class<?>[] ptypes, int count) {\n-        \/\/ build the simple cases directly\n-        if (count == 1) {\n-            return prepender(constants[pos], ptypes[pos]);\n-        }\n-        if (count == 2) {\n-            return prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]);\n-        }\n-        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n-        MethodHandle prepend = prependBase();\n-        if (count == 3) {\n-            prepend = MethodHandles.dropArguments(prepend, 3,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2]),\n-                    PREPEND_FILTER_THIRD_ARGS);\n-        } else if (count == 4) {\n-            prepend = MethodHandles.dropArguments(prepend, 3,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2], constants[pos + 3], ptypes[pos + 3]),\n-                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        }\n-    }\n-\n-    \/\/ Constant argument lists used by the size MH builders\n-    private static final int[] SIZE_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n-    private static final int[] SIZE_FILTER_THIRD_ARGS = new int[] { 0, 3 };\n-    private static final int[] SIZE_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n-    private static MethodHandle stringSize(Class<?> cl) {\n-        int index = classIndex(cl);\n-        MethodHandle size = SIZERS[index];\n-        if (size == null) {\n-            SIZERS[index] = size = JLA.stringConcatHelper(\"stringSize\",\n-                    methodType(int.class, int.class, Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return size;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_SIZERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-    private static MethodHandle stringSize(Class<?> cl, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle sizer = DOUBLE_SIZERS[idx1][idx2];\n-        if (sizer == null) {\n-            sizer = stringSize(cl);\n-            sizer = MethodHandles.dropArguments(sizer, 2, cl2);\n-            DOUBLE_SIZERS[idx1][idx2] = sizer = MethodHandles.filterArgumentsWithCombiner(sizer, 0,\n-                    stringSize(cl2), SIZE_FILTER_SECOND_ARGS);\n-        }\n-        return sizer;\n-    }\n-\n-    private static MethodHandle stringSize(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n-        MethodHandle size = stringSize(cl, cl2);\n-        size = MethodHandles.dropArguments(size, 3, cl3);\n-        return MethodHandles.filterArgumentsWithCombiner(size, 0,\n-                stringSize(cl3), SIZE_FILTER_THIRD_ARGS);\n-    }\n-\n-    private static MethodHandle stringSize(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n-        MethodHandle size = stringSize(cl, cl2);\n-        size = MethodHandles.dropArguments(size, 3, cl3, cl4);\n-        return MethodHandles.filterArgumentsWithCombiner(size, 0,\n-                stringSize(cl3, cl4), SIZE_FILTER_SECOND_PAIR_ARGS);\n-    }\n-\n-    private @Stable static MethodHandle STRING_CODER;\n-    private static MethodHandle stringCoder(Class<?> cl) {\n-        int index = classIndex(cl);\n-        MethodHandle coder = CODERS[index];\n-        if (coder == null) {\n-            CODERS[index] = coder = JLA.stringConcatHelper(\"stringCoder\",\n-                    methodType(byte.class, byte.class, Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return coder;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_CODERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-    private static MethodHandle stringCoder(Class<?> cl, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle coder = DOUBLE_CODERS[idx1][idx2];\n-        if (coder == null) {\n-            coder = stringCoder(cl);\n-            coder = MethodHandles.dropArguments(coder, 2, cl2);\n-            DOUBLE_CODERS[idx1][idx2] = coder = MethodHandles.filterArgumentsWithCombiner(coder, 0,\n-                    stringCoder(cl2), SIZE_FILTER_SECOND_ARGS);\n-        }\n-        return coder;\n-    }\n-\n-    private static MethodHandle stringCoder(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n-        MethodHandle coder = stringCoder(cl, cl2);\n-        coder = MethodHandles.dropArguments(coder, 3, cl3);\n-        return MethodHandles.filterArgumentsWithCombiner(coder, 0,\n-                stringCoder(cl3), SIZE_FILTER_THIRD_ARGS);\n-    }\n-\n-    private static MethodHandle stringCoder(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n-        MethodHandle coder = stringCoder(cl, cl2);\n-        coder = MethodHandles.dropArguments(coder, 3, cl3, cl4);\n-        return MethodHandles.filterArgumentsWithCombiner(coder, 0,\n-                stringCoder(cl3, cl4), SIZE_FILTER_SECOND_PAIR_ARGS);\n+        return null;\n@@ -1012,9 +558,0 @@\n-    private @Stable static MethodHandle OBJECT_STRINGIFIER;\n-    private static MethodHandle objectStringifier() {\n-        MethodHandle mh = OBJECT_STRINGIFIER;\n-        if (mh == null) {\n-            OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(\"stringOf\",\n-                    methodType(String.class, Object.class));\n-        }\n-        return mh;\n-    }\n@@ -1104,33 +641,0 @@\n-    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] PREPENDERS           = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] SIZERS               = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] CODERS               = new MethodHandle[TYPE_COUNT];\n-    private static final int INITIAL_CODER = JLA.stringConcatInitialCoder();\n-\n-    \/**\n-     * Promote integral types to int.\n-     *\/\n-    private static Class<?> promoteToIntType(Class<?> t) {\n-        \/\/ use int for subword integral types; still need special sizer\n-        \/\/ and prependers for char, boolean\n-        return t == byte.class || t == short.class ? int.class : t;\n-    }\n-\n-    \/**\n-     * Returns a stringifier for references and floats\/doubles only.\n-     * Always returns null for other primitives.\n-     *\n-     * @param t class to stringify\n-     * @return stringifier; null, if not available\n-     *\/\n-    private static MethodHandle stringifierFor(Class<?> t) {\n-        if (t == Object.class) {\n-            return objectStringifier();\n-        } else if (t == float.class) {\n-            return floatStringifier();\n-        } else if (t == double.class) {\n-            return doubleStringifier();\n-        }\n-        return null;\n-    }\n-\n@@ -1172,0 +676,20 @@\n+        static final ClassDesc STRING_CONCAT_HELPER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_byteArray = ClassDesc.ofDescriptor(\"[B\");\n+        static final MethodTypeDesc STRING_OFF = MethodTypeDesc.of(CD_String, CD_Object);\n+        static final MethodTypeDesc FLOAT_TO_STRING = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc DOUBLE_TO_STRING = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc TO_INT = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc INT_TO_INT = MethodTypeDesc.of(CD_int, CD_int);\n+        static final MethodTypeDesc LONG_TO_INT = MethodTypeDesc.of(CD_int, CD_long);\n+        static final MethodTypeDesc BOOLEAN_TO_INT = MethodTypeDesc.of(CD_int, CD_boolean);\n+        static final MethodTypeDesc TO_BYTE = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc CHAR_TO_BYTE = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc NEW_ARRAY = MethodTypeDesc.of(CD_byteArray, CD_int, CD_byte);\n+        static final MethodTypeDesc NEW_STRING = MethodTypeDesc.of(CD_void, CD_byteArray, CD_byte);\n+        static final MethodTypeDesc PREPEND_STRING = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_String);\n+        static final MethodTypeDesc PREPEND_INT = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_int);\n+        static final MethodTypeDesc PREPEND_LONG = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_long);\n+        static final MethodTypeDesc PREPEND_BOOLEAN = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_boolean);\n+        static final MethodTypeDesc PREPEND_CHAR = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_char);\n+\n+\n@@ -1248,0 +772,152 @@\n+\n+                public void acceptInlineCopy(CodeBuilder cb) {\n+                    int initalIndex = 0;\n+                    int initalCoder = JLA.stringConcatInitialCoder();\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            initalIndex += constant.length();\n+                            initalCoder |= JLA.stringCoder(constant);\n+                        }\n+                    }\n+\n+                    final int paramCount = args.parameterCount();\n+                    int[] paramSlots = new int[paramCount];\n+                    int[] paramStrings = new int[paramCount];\n+                    int strings = 0;\n+                    int argSlots = 0;\n+                    for (int i = 0; i < args.parameterCount(); i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = argSlots;\n+                        argSlots += kind.slotSize();\n+                        if (!directPrimive(cl)) {\n+                            paramStrings[i] = strings++;\n+                        }\n+                    }\n+\n+                    \/\/ string variants\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            cb.loadLocal(kind, paramSlots[i]);\n+                            if (cl == float.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Float, \"toString\", FLOAT_TO_STRING);\n+                            } else if (cl == double.class) {\n+                                cb.invokestatic(ConstantDescs.CD_Double, \"toString\", DOUBLE_TO_STRING);\n+                            } else {\n+                                cb.invokestatic(STRING_CONCAT_HELPER, \"stringOf\", STRING_OFF);\n+                            }\n+                            cb.astore(argSlots + paramStrings[i]);\n+                        }\n+                    }\n+\n+                    int INIT_CODER = argSlots + strings;\n+                    int INIT_INDEX = argSlots + strings + 1;\n+                    int BUF = argSlots + strings + 2;\n+                    cb.loadConstant(initalCoder);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (!directPrimive(cl)) {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokevirtual(ConstantDescs.CD_String, \"coder\", TO_BYTE)\n+                              .ior();\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"stringCoder\", CHAR_TO_BYTE)\n+                              .ior();\n+                        }\n+                    }\n+                    cb.istore(INIT_CODER);\n+\n+                    cb.loadConstant(initalIndex);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        int pparamSlot = paramSlots[i];\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(ConstantDescs.CD_Integer, \"stringSize\", INT_TO_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(ConstantDescs.CD_Long, \"stringSize\", LONG_TO_INT);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, pparamSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"stringSize\", BOOLEAN_TO_INT);\n+                        } else if (cl == char.class) {\n+                            cb.iconst_1();\n+                        } else {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokevirtual(ConstantDescs.CD_String, \"length\", TO_INT);\n+                        }\n+                        cb.iadd();\n+                    }\n+                    cb.dup()\n+                      .istore(INIT_INDEX)\n+                      .iload(INIT_CODER).i2b()\n+                      .invokestatic(STRING_CONCAT_HELPER, \"newArray\", NEW_ARRAY)\n+                      .astore(BUF);\n+\n+                    if (constants[constants.length - 1] != null) {\n+                        cb.iload(INIT_INDEX)\n+                          .iload(INIT_CODER)\n+                          .aload(BUF)\n+                          .ldc(constants[constants.length - 1])\n+                          .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING)\n+                          .istore(INIT_INDEX);\n+                    }\n+                    \/\/ paramSlots\n+                    for (int i = paramCount - 1; i >= 0; i--) {\n+                        int paramSlot = paramSlots[i];\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+\n+                        cb.iload(INIT_INDEX)\n+                          .iload(INIT_CODER)\n+                          .aload(BUF);\n+\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_INT);\n+                        } else if (cl == long.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_LONG);\n+                        } else if (cl == boolean.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_BOOLEAN);\n+                        } else if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlot)\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_CHAR);\n+                        } else {\n+                            cb.aload(argSlots + paramStrings[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING);\n+                        }\n+                        cb.istore(INIT_INDEX);\n+\n+                        if (constants[i] != null) {\n+                            cb.iload(INIT_INDEX)\n+                              .iload(INIT_CODER)\n+                              .aload(BUF)\n+                              .ldc(constants[i])\n+                              .invokestatic(STRING_CONCAT_HELPER, \"prepend\", PREPEND_STRING)\n+                              .istore(INIT_INDEX);\n+                        }\n+                    }\n+\n+                    cb.new_(ConstantDescs.CD_String)\n+                      .dup()\n+                      .aload(BUF)\n+                      .iload(INIT_CODER)\n+                      .invokespecial(ConstantDescs.CD_String, \"<init>\", NEW_STRING)\n+                      .areturn();\n+                }\n+\n+                static boolean directPrimive(Class<?> cl) {\n+                    return cl == byte.class\n+                            || cl == short.class\n+                            || cl == int.class\n+                            || cl == long.class\n+                            || cl == boolean.class\n+                            || cl == char.class;\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":181,"deletions":505,"binary":false,"changes":686,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -440,0 +441,2 @@\n+    MethodHandles.Lookup stringConcatLookup();\n+\n@@ -452,0 +455,2 @@\n+    int stringSize(int i);\n+\n@@ -458,0 +463,1 @@\n+    byte stringCoder(char ch);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}