{"files":[{"patch":"@@ -425,0 +425,23 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param index\n+     * @param coder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArray(String suffix, int index, byte coder) {\n+        byte[] buf = newArray((index + suffix.length()) << coder);\n+        if (coder == String.LATIN1) {\n+            suffix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, index, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n@@ -442,0 +465,196 @@\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param the        coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param the        coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param the        coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      integer value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    @ForceInline\n+    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param the        coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    @ForceInline\n+    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param the        coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      string value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n+        index -= value.length();\n+        if (coder == String.LATIN1) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of String value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index      final char index in the buffer\n+     * @param coder      the coder of buf\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value) {\n+        index -= value.length();\n+        value.getBytes(buf, index, coder);\n+        return index;\n+    }\n+\n+    static int stringSize(boolean value) {\n+        return value ? 4 : 5;\n+    }\n+\n+    static int stringSize(int value) {\n+        return Integer.stringSize(value);\n+    }\n+\n+    static int stringSize(long value) {\n+        return Long.stringSize(value);\n+    }\n+\n+    static int stringSize(char value) {\n+        return 1;\n+    }\n+\n+    static int stringSize(String value) {\n+        return value.length();\n+    }\n+\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    static String stringOf(float value) {\n+        return Float.toString(value);\n+    }\n+\n+    static String stringOf(double value) {\n+        return Double.toString(value);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -2642,0 +2642,12 @@\n+            public byte stringInitialCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(char value) {\n+                return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,1 +961,3 @@\n-                m.ensureTypeVisible(m.getDeclaringClass());\n+                if (allowedModes != LM_TRUSTED) {\n+                    m.ensureTypeVisible(m.getDeclaringClass());\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -112,0 +113,1 @@\n+    private static final boolean GENERATE_INLINE_COPY;\n@@ -116,0 +118,3 @@\n+\n+        String generateInlineCopy = VM.getSavedProperty(\"java.lang.invoke.StringConcat.generateInlineCopy\");\n+        GENERATE_INLINE_COPY = generateInlineCopy != null ? \"true\".equalsIgnoreCase(generateInlineCopy) : true;\n@@ -145,0 +150,5 @@\n+    @SuppressWarnings(\"removal\")\n+    private static boolean isGenerateInlineCopy() {\n+        return GENERATE_INLINE_COPY && System.getSecurityManager() == null;\n+    }\n+\n@@ -373,0 +383,1 @@\n+        MethodHandle mh = null;\n@@ -375,6 +386,7 @@\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+                if (mh != null) {\n+                    mh = mh.viewAsType(concatType, true);\n+                }\n+            }\n+            if (mh == null) {\n+                mh = SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings);\n@@ -382,0 +394,1 @@\n+            return new ConstantCallSite(mh);\n@@ -503,0 +516,5 @@\n+\n+        if (isGenerateInlineCopy()) {\n+            return null;\n+        }\n+\n@@ -1067,0 +1085,22 @@\n+        static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_byteArray = ClassDesc.ofDescriptor(\"[B\");\n+        static final MethodTypeDesc OBJECT_TO_STRING = MethodTypeDesc.of(CD_String, CD_Object);\n+        static final MethodTypeDesc FLOAT_TO_STRING = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc DOUBLE_TO_STRING = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc TO_INT = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc INT_TO_INT = MethodTypeDesc.of(CD_int, CD_int);\n+        static final MethodTypeDesc LONG_TO_INT = MethodTypeDesc.of(CD_int, CD_long);\n+        static final MethodTypeDesc BOOLEAN_TO_INT = MethodTypeDesc.of(CD_int, CD_boolean);\n+        static final MethodTypeDesc CHAR_TO_INT = MethodTypeDesc.of(CD_int, CD_char);\n+        static final MethodTypeDesc STR_TO_INT = MethodTypeDesc.of(CD_int, CD_String);\n+        static final MethodTypeDesc TO_BYTE = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc CHAR_TO_BYTE = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc NEW_ARRAY = MethodTypeDesc.of(CD_byteArray, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc NEW_STRING = MethodTypeDesc.of(CD_void, CD_byteArray, CD_byte);\n+        static final MethodTypeDesc PREPEND_String = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_String, CD_String);\n+        static final MethodTypeDesc PREPEND_int = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_byteArray, CD_char, CD_String);\n+        static final MethodTypeDesc STR_GET_BYTES = MethodTypeDesc.of(CD_void, CD_byteArray, CD_int, CD_byte);\n+\n@@ -1080,1 +1120,2 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = MethodHandles.Lookup.IMPL_LOOKUP;\n+            String className = getClassName(String.class);\n@@ -1082,0 +1123,1 @@\n+            boolean generateInlineCopy = GENERATE_INLINE_COPY && args.parameterCount() <= HIGH_ARITY_THRESHOLD;\n@@ -1090,1 +1132,3 @@\n-                                        generateMethod(constants, args));\n+                                        generateInlineCopy\n+                                                ? generateInlineCopyMethod(constants, args)\n+                                                : generateMethod(constants, args));\n@@ -1093,4 +1137,3 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n+                var hiddenClass = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n+                        .defineClass(true, null);\n+                return lookup.findStatic(hiddenClass, METHOD_NAME, args);\n@@ -1146,0 +1189,236 @@\n+        \/**\n+         * Generate InlineCopy-based code. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringOf;\n+         * import static java.lang.StringConcatHelper.stringSize;\n+         * import static java.lang.StringConcatHelper.newArray;\n+         * import static java.lang.StringConcatHelper.prepend;\n+         *\n+         * public static String concat(int arg0, long arg1, boolean arg3, char arg4, String arg5, Object arg6, Object arg7) {\n+         *     String constant0, constant1, ..., constant8;\n+         *     int initCoder = ...;\n+         *     int initIndex = ...;\n+         *\n+         *     \/\/ String arg\n+         *     arg5 = stringOf(arg5);\n+         *\n+         *     \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+         *     var str0 = stringOf(arg6);\n+         *     var str1 = stringOf(arg7);\n+         *\n+         *     int coder = initCoder | stringCoder(arg4) | arg5.coder() | str0.coder() | str1.coder();\n+         *     int index = initIndex + stringSize(arg0) + stringSize(arg1) + stringSize(arg2) + stringSize(arg3)\n+         *                           + stringSize(arg4) + stringSize(arg5) + stringSize(str0) + stringSize(str1);\n+         *\n+         *     index -= constant8.length();\n+         *     byte[] buf = newArray(constant8, index, coder);\n+         *\n+         *     index = prepend(index, coder, buf, str1, constant7);\n+         *     index = prepend(index, coder, buf, str0, constant6);\n+         *     index = prepend(index, coder, buf, arg5, constant5);\n+         *     index = prepend(index, coder, buf, arg4, constant4);\n+         *     index = prepend(index, coder, buf, arg3, constant3);\n+         *     index = prepend(index, coder, buf, arg2, constant2);\n+         *     index = prepend(index, coder, buf, arg1, constant1);\n+         *     index = prepend(index, coder, buf, arg0, constant0);\n+         *\n+         *     return new String(buf, (byte) coder);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateInlineCopyMethod(String[] constants, MethodType args) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int initalIndex = 0;\n+                    int initalCoder = JLA.stringInitialCoder();\n+                    for (String constant : constants) {\n+                        if (constant != null) {\n+                            initalIndex += constant.length();\n+                            initalCoder |= JLA.stringCoder(constant);\n+                        }\n+                    }\n+\n+                    int paramCount = args.parameterCount();\n+\n+                    \/\/ Compute parameter and local string variable slots\n+                    int argSlots = 0;\n+                    int[] paramSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        paramSlots[i] = argSlots;\n+                        argSlots += kind.slotSize();\n+                    }\n+\n+                    int coderSlot = argSlots;\n+                    int indexSlot = argSlots + 1;\n+                    int bufSlot   = argSlots + 2;\n+\n+                    \/*\n+                     * store string variants:\n+                     *\n+                     * str0 = StringConcatHelper.stringOf(args(0));\n+                     * str1 = StringConcatHelper.stringOf(args(1));\n+                     * ...\n+                     * strN = StringConcatHelper.stringOf(args(N));\n+                     *\n+                     *\/\n+                    for (int i = 0, strings = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            MethodTypeDesc methodTypeDesc;\n+                            if (cl == float.class) {\n+                                methodTypeDesc = FLOAT_TO_STRING;\n+                            } else if (cl == double.class) {\n+                                methodTypeDesc = DOUBLE_TO_STRING;\n+                            } else {\n+                                methodTypeDesc = OBJECT_TO_STRING;\n+                            }\n+\n+                            \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+                            int strLocalSlot = (cl == String.class)\n+                                    ? paramSlots[i]\n+                                    : argSlots + 3 + (strings++);\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(CD_StringConcatHelper, \"stringOf\", methodTypeDesc)\n+                              .astore(strLocalSlot);\n+                            if (cl != String.class) {\n+                                paramSlots[i] = strLocalSlot;\n+                            }\n+                        }\n+                    }\n+\n+                    \/*\n+                     * store init coder :\n+                     *\n+                     * coder = initalCoder;\n+                     * coder |= StringConcatHelper.stringCoder((char) args[1]);\n+                     * coder |= str0.coder();\n+                     *\n+                     *\/\n+                    cb.loadConstant(initalCoder);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        if (cl == char.class) {\n+                            cb.loadLocal(kind, paramSlots[i])\n+                              .invokestatic(CD_StringConcatHelper, \"stringCoder\", CHAR_TO_BYTE)\n+                              .ior();\n+                        } else if (needStringOf(cl) && maybeUTF16(cl)) {\n+                            cb.aload(paramSlots[i])\n+                              .invokevirtual(CD_String, \"coder\", TO_BYTE)\n+                              .ior();\n+                        }\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    String suffix = constants[constants.length - 1];\n+                    if (suffix == null) {\n+                        suffix = \"\";\n+                    }\n+                    \/*\n+                     * store init index & allocate buffer :\n+                     *\n+                     * index = initalIndex + StringConcatHelper.stringSize(args[i]) + ...\n+                     * ...\n+                     *\n+                     *\/\n+                    cb.loadConstant(initalIndex);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+                        int paramSlot = paramSlots[i];\n+\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            methodTypeDesc = INT_TO_INT;\n+                        } else if (cl == long.class) {\n+                            methodTypeDesc = LONG_TO_INT;\n+                        } else if (cl == boolean.class) {\n+                            methodTypeDesc = BOOLEAN_TO_INT;\n+                        } else if (cl == char.class) {\n+                            methodTypeDesc = CHAR_TO_INT;\n+                        } else {\n+                            methodTypeDesc = STR_TO_INT;\n+                            kind = TypeKind.from(String.class);\n+                        }\n+                        cb.loadLocal(kind, paramSlot)\n+                          .invokestatic(CD_StringConcatHelper, \"stringSize\", methodTypeDesc)\n+                          .iadd();\n+                    }\n+                    cb.ldc(suffix.length())\n+                      .isub()\n+                      .istore(indexSlot);\n+\n+                    \/*\n+                     *  buf = StringConcatHelper.newArray(suffix, index, coder)\n+                     *\/\n+                    cb.ldc(suffix)\n+                      .iload(indexSlot)\n+                      .iload(coderSlot)\n+                      .invokestatic(CD_StringConcatHelper, \"newArray\", NEW_ARRAY)\n+                      .astore(bufSlot);\n+\n+                    for (int i = paramCount - 1; i >= 0; i--) {\n+                        int paramSlot = paramSlots[i];\n+                        Class<?> cl = args.parameterType(i);\n+                        TypeKind kind = TypeKind.from(cl);\n+\n+                        \/*\n+                         * prepend arguments :\n+                         * index = StringConcatHelper.prepend(index, coder, buf, args[i])\n+                         *\/\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == byte.class || cl == short.class || cl == int.class) {\n+                            methodTypeDesc = PREPEND_int;\n+                        } else if (cl == long.class) {\n+                            methodTypeDesc = PREPEND_long;\n+                        } else if (cl == boolean.class) {\n+                            methodTypeDesc = PREPEND_boolean;\n+                        } else if (cl == char.class) {\n+                            methodTypeDesc = PREPEND_char;\n+                        } else {\n+                            methodTypeDesc = PREPEND_String;\n+                            kind = TypeKind.from(String.class);\n+                        }\n+                        String constant = constants[i];\n+                        if (constant == null) {\n+                            constant = \"\";\n+                        }\n+                        cb.iload(indexSlot)\n+                          .iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadLocal(kind, paramSlot)\n+                          .ldc(constant)\n+                          .invokestatic(CD_StringConcatHelper, \"prepend\", methodTypeDesc)\n+                          .istore(indexSlot);\n+                    }\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, \"<init>\", NEW_STRING)\n+                      .areturn();\n+                }\n+\n+                static boolean needStringOf(Class<?> cl) {\n+                    return cl != byte.class && cl != short.class   && cl != int.class\n+                        && cl != long.class && cl != boolean.class && cl != char.class;\n+                }\n+\n+                static boolean maybeUTF16(Class<?> cl) {\n+                    return cl != byte.class && cl != short.class && cl != int.class\n+                        && cl != long.class && cl != boolean.class\n+                        && cl != Byte.class && cl != Short.class && cl != Integer.class\n+                        && cl != Long.class && cl != Boolean.class;\n+                }\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":291,"deletions":12,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -455,0 +455,5 @@\n+    byte stringInitialCoder();\n+\n+    byte stringCoder(char ch);\n+    byte stringCoder(String str);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}