{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/deferred.hpp\"\n@@ -52,1 +53,1 @@\n-MemBaseline MemTracker::_baseline;\n+Deferred<MemBaseline> MemTracker::_baseline;\n@@ -70,0 +71,1 @@\n+    _baseline.initialize();\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memBaseline.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"utilities\/deferred.hpp\"\n@@ -42,2 +44,0 @@\n-class MemBaseline;\n-\n@@ -264,1 +264,1 @@\n-    return _baseline;\n+    return *_baseline;\n@@ -317,1 +317,1 @@\n-  static MemBaseline      _baseline;\n+  static Deferred<MemBaseline>      _baseline;\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-MemoryFileTracker* MemoryFileTracker::Instance::_tracker = nullptr;\n+Deferred<MemoryFileTracker> MemoryFileTracker::Instance::_tracker;\n@@ -129,3 +129,2 @@\n-  _tracker = static_cast<MemoryFileTracker*>(os::malloc(sizeof(MemoryFileTracker), mtNMT));\n-  if (_tracker == nullptr) return false;\n-  new (_tracker) MemoryFileTracker(tracking_level == NMT_TrackingLevel::NMT_detail);\n+  bool is_detailed_mode = tracking_level == NMT_TrackingLevel::NMT_detail;\n+  _tracker.initialize(is_detailed_mode);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/deferred.hpp\"\n@@ -94,1 +95,1 @@\n-    static MemoryFileTracker* _tracker;\n+    static Deferred<MemoryFileTracker> _tracker;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_UTILITIES_STABLEVALUE_HPP\n+#define SHARE_UTILITIES_STABLEVALUE_HPP\n+\n+#include \"globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+\/\/ The purpose of this class is to defer initialization of a T to a later point in time,\n+\/\/ and then to never deallocate it. This is mainly useful for deferring the initialization of\n+\/\/ static fields in classes, in order to avoid \"Static Initialization Order Fiasco\".\n+template<typename T>\n+class Deferred {\n+  union {\n+    T _t;\n+  };\n+\n+  DEBUG_ONLY(bool _initialized);\n+\n+public:\n+  NONCOPYABLE(Deferred);\n+\n+  Deferred()\n+  DEBUG_ONLY(: _initialized(false)) {\n+    \/\/ Do not construct value, on purpose.\n+  }\n+\n+  ~Deferred() {\n+    \/\/ Do not destruct value, on purpose.\n+  }\n+\n+  T* get() {\n+    assert(_initialized, \"must be initialized before access\");\n+    return &_t;\n+  }\n+\n+  T& operator*() {\n+    return *get();\n+  }\n+\n+  T* operator->() {\n+    return get();\n+  }\n+\n+  template<typename... Ts>\n+  void initialize(Ts&... args) {\n+    assert(!_initialized, \"Double initialization forbidden\");\n+    DEBUG_ONLY(_initialized = true);\n+    using NCVP = std::add_pointer_t<std::remove_cv_t<T>>;\n+    ::new (const_cast<NCVP>(get())) T(args...);\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_STABLEVALUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/deferred.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}