{"files":[{"patch":"@@ -746,1 +746,1 @@\n-  \/* Thread.dump_to_file jcmd *\/                                                                                  \\\n+  \/* jcmd Thread.dump_to_file *\/                                                                                  \\\n@@ -750,0 +750,4 @@\n+                                                                                                                  \\\n+  \/* jcmd Thread.vthread_summary *\/                                                                               \\\n+  template(jdk_internal_vm_VThreadSummary,         \"jdk\/internal\/vm\/VThreadSummary\")                              \\\n+  template(print_name,                             \"print\")                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSummaryDCmd>(full_export, true, false));\n@@ -1081,1 +1082,0 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -1112,0 +1112,40 @@\n+  \/\/ copy the bytes to the output stream\n+  typeArrayOop ba = typeArrayOop(res);\n+  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n+  output()->print_raw((const char*)addr, ba->length());\n+}\n+\n+void VThreadSummaryDCmd::execute(DCmdSource source, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  Symbol* sym = vmSymbols::jdk_internal_vm_VThreadSummary();\n+  Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n+    output()->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ invoke VThreadSummary.print method\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  JavaCalls::call_static(&result,\n+                         k,\n+                         vmSymbols::print_name(),\n+                         vmSymbols::void_byte_array_signature(),\n+                         &args,\n+                         THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n+    output()->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ check that result is byte array\n+  oop res = cast_to_oop(result.get_jobject());\n+  assert(res->is_typeArray(), \"just checking\");\n+  assert(TypeArrayKlass::cast(res->klass())->element_type() == T_BYTE, \"just checking\");\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    return \"Print all threads with stacktraces.\";\n+    return \"Print all platform threads with stacktraces.\";\n@@ -939,0 +939,13 @@\n+class VThreadSummaryDCmd : public DCmd {\n+public:\n+  VThreadSummaryDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_summary\";\n+  }\n+  static const char* description() {\n+    return \"Print the virtual thread scheduler, timeout schedulers, I\/O pollers, and thread groupings.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -2429,0 +2430,4 @@\n+            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n+                return VirtualThread.delayedTaskSchedulers();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -195,0 +197,7 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used to support timed operations.\n+     *\/\n+    static Stream<ScheduledExecutorService> delayedTaskSchedulers() {\n+        return Arrays.stream(DELAYED_TASK_SCHEDULERS);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -599,0 +600,5 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used for virtual threads.\n+     *\/\n+    Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import sun.nio.ch.Poller;\n+\n+\/**\n+ * The implementation for the jcmd Thread.vthread_summary diagnostic command.\n+ *\/\n+public class VThreadSummary {\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/\/ maximum number of thread containers to print\n+    private static final int MAX_THREAD_CONTAINERS = 256;\n+\n+    private VThreadSummary() { }\n+\n+    \/**\n+     * Invoked by the VM to print virtual thread summary information.\n+     * @return the UTF-8 encoded information to print\n+     *\/\n+    private static byte[] print() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        \/\/ print virtual thread scheduler\n+        printSchedulers(sb);\n+        sb.append(System.lineSeparator());\n+\n+        \/\/ print I\/O pollers if initialized\n+        if (!U.shouldBeInitialized(Poller.class)) {\n+            printPollers(sb);\n+            sb.append(System.lineSeparator());\n+        }\n+\n+        return sb.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Print information on the virtual thread schedulers to given string builder.\n+     *\/\n+    private static void printSchedulers(StringBuilder sb) {\n+        sb.append(\"Virtual thread scheduler:\")\n+                .append(System.lineSeparator());\n+        sb.append(JLA.virtualThreadDefaultScheduler())\n+                .append(System.lineSeparator());\n+\n+        sb.append(System.lineSeparator());\n+\n+        sb.append(\"Timeout schedulers:\")\n+                .append(System.lineSeparator());\n+        var schedulers = JLA.virtualThreadDelayedTaskSchedulers().toList();\n+        for (int i = 0; i < schedulers.size(); i++) {\n+            sb.append('[')\n+                    .append(i)\n+                    .append(\"] \")\n+                    .append(schedulers.get(i))\n+                    .append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Print information on threads registered for I\/O to the given string builder.\n+     *\/\n+    private static void printPollers(StringBuilder sb) {\n+        Poller masterPoller = Poller.masterPoller();\n+        List<Poller> readPollers = Poller.readPollers();\n+        List<Poller> writePollers = Poller.writePollers();\n+\n+        if (masterPoller != null) {\n+            sb.append(\"Master I\/O poller:\")\n+                    .append(System.lineSeparator())\n+                    .append(masterPoller)\n+                    .append(System.lineSeparator());\n+            sb.append(System.lineSeparator());\n+        }\n+\n+        sb.append(\"Read I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, readPollers.size())\n+                .forEach(i -> sb.append('[')\n+                        .append(i)\n+                        .append(\"] \")\n+                        .append(readPollers.get(i))\n+                        .append(System.lineSeparator()));\n+        sb.append(System.lineSeparator());\n+\n+        sb.append(\"Write I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, writePollers.size())\n+                .forEach(i -> sb.append('[')\n+                        .append(i)\n+                        .append(\"] \")\n+                        .append(writePollers.get(i))\n+                        .append(System.lineSeparator()));\n+    }\n+\n+    \/**\n+     * Print the thread containers that don't have an owner to the given string builder.\n+     * The output will include the root container and all thread pools.\n+     *\n+     * In the future, this could be extended to support structured concurrency so that\n+     * it prints a tree of owned thread containers.\n+     *\/\n+    private static void printThreadContainers(StringBuilder sb) {\n+        sb.append(\"Thread groupings:\")\n+                .append(System.lineSeparator());\n+\n+        ThreadContainer root = ThreadContainers.root();\n+        printThreadContainer(root, sb);\n+\n+        int printed = 1;\n+        Iterator<ThreadContainer> iterator = root.children().iterator();\n+        while (iterator.hasNext() && printed < MAX_THREAD_CONTAINERS) {\n+            ThreadContainer container = iterator.next();\n+            if (container.owner() == null) {\n+                printThreadContainer(container, sb);\n+                printed++;\n+            }\n+        }\n+        if (iterator.hasNext()) {\n+            sb.append(\"<truncated ...>\")\n+                    .append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Print a thread container to the given string builder.\n+     *\/\n+    private static void printThreadContainer(ThreadContainer container, StringBuilder sb) {\n+        Map<Boolean, Long> threadCounts = container.threads()\n+                .collect(Collectors.partitioningBy(Thread::isVirtual, Collectors.counting()));\n+        long platformThreadCount = threadCounts.get(Boolean.FALSE);\n+        long virtualThreadCount = threadCounts.get(Boolean.TRUE);\n+        sb.append(container)\n+                .append(\" [platform threads = \")\n+                .append(platformThreadCount)\n+                .append(\", virtual threads = \")\n+                .append(virtualThreadCount)\n+                .append(\"]\")\n+                .append(System.lineSeparator());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VThreadSummary.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -277,0 +277,5 @@\n+    @Override\n+    public String toString() {\n+        return Objects.toIdentityString(this) + \" [registered = \" + map.size() + \"]\";\n+    }\n+\n@@ -284,5 +289,0 @@\n-    @Override\n-    public String toString() {\n-        return Objects.toIdentityString(this) + \" [registered = \" + registered() + \"]\";\n-    }\n-\n@@ -446,0 +446,21 @@\n+\n+    \/**\n+     * Return the master poller or null if there is no master poller.\n+     *\/\n+    public static Poller masterPoller() {\n+        return POLLERS.masterPoller();\n+    }\n+\n+    \/**\n+     * Return the list of read pollers.\n+     *\/\n+    public static List<Poller> readPollers() {\n+        return POLLERS.readPollers();\n+    }\n+\n+    \/**\n+     * Return the list of write pollers.\n+     *\/\n+    public static List<Poller> writePollers() {\n+        return POLLERS.writePollers();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -941,1 +941,1 @@\n-Prints all threads with stacktraces.\n+Prints all platform threads with stacktraces.\n@@ -960,0 +960,8 @@\n+\\f[V]Thread.vthread_summary\\f[R]\n+Print the virtual thread scheduler, timeout schedulers, I\/O pollers, and\n+thread groupings.\n+.RS\n+.PP\n+Impact: Low\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file \\\n+  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file jcmd.thread.vthread_summary \\\n@@ -64,0 +64,2 @@\n+jcmd.thread.vthread_summary.args=%p Thread.vthread_summary\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337199\n+ * @summary Basic test for jcmd Thread.vthread_summary\n+ * @requires vm.continuations\n+ * @modules jdk.jcmd\n+ * @library \/test\/lib\n+ * @run junit\/othervm VThreadSummaryTest\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.IntStream;\n+import java.lang.management.ManagementFactory;\n+import jdk.management.VirtualThreadSchedulerMXBean;\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class VThreadSummaryTest {\n+\n+    private OutputAnalyzer jcmd() {\n+        return new PidJcmdExecutor().execute(\"Thread.vthread_summary\");\n+    }\n+\n+    \/**\n+     * Test that output includes the default scheduler and timeout schedulers.\n+     *\/\n+    @Test\n+    void testSchedulers() {\n+        \/\/ ensure default scheduler are timeout schedulers are initialized\n+        Thread.startVirtualThread(() -> { });\n+\n+        jcmd().shouldContain(\"Virtual thread scheduler:\")\n+                .shouldContain(Objects.toIdentityString(defaultScheduler()))\n+                .shouldContain(\"Timeout schedulers:\")\n+                .shouldContain(\"[0] \" + ScheduledThreadPoolExecutor.class.getName());\n+    }\n+\n+    \/**\n+     * Test that the output includes the read and writer I\/O pollers.\n+     *\/\n+    @Test\n+    void testPollers() throws Exception {\n+        \/\/ do blocking I\/O op on a virtual thread to ensure poller mechanism is initialized\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                try (var listener = new ServerSocket()) {\n+                    InetAddress lb = InetAddress.getLoopbackAddress();\n+                    listener.bind(new InetSocketAddress(lb, 0));\n+                    listener.setSoTimeout(1000);\n+                    try (Socket s = listener.accept()) {\n+                        fail(\"Connection from \" + s.getRemoteSocketAddress());\n+                    } catch (SocketTimeoutException e) {\n+                        \/\/ expected\n+                    }\n+                }\n+                return null;\n+            }).get();\n+        }\n+\n+        jcmd().shouldContain(\"Read I\/O pollers:\")\n+                .shouldContain(\"Write I\/O pollers:\")\n+                .shouldContain(\"[0] sun.nio.ch\");\n+    }\n+\n+    \/**\n+     * Test that the output includes thread groupings.\n+     *\/\n+    \/\/@Test\n+    void testThreadGroupings() {\n+        \/\/ ensure common pool is initialized\n+        CompletableFuture.runAsync(() -> { });\n+\n+        try (var pool = Executors.newFixedThreadPool(1);\n+             var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+\n+            jcmd().shouldContain(\"<root>\")\n+                    .shouldContain(\"ForkJoinPool.commonPool\")\n+                    .shouldContain(Objects.toIdentityString(pool))\n+                    .shouldContain(Objects.toIdentityString(executor));\n+        }\n+    }\n+\n+    \/**\n+     * Test that output is truncated when there are too many thread groupings.\n+     *\/\n+    \/\/@Test\n+    void testTooManyThreadGroupings() {\n+        List<ExecutorService> executors = IntStream.range(0, 1000)\n+                .mapToObj(_ -> Executors.newCachedThreadPool())\n+                .toList();\n+        try {\n+            jcmd().shouldContain(\"<root>\")\n+                    .shouldContain(\"<truncated ...>\");\n+        } finally {\n+            executors.forEach(ExecutorService::close);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the virtual thread default scheduler. This implementation works by finding\n+     * all FJ worker threads and mapping them to their pool. VirtualThreadSchedulerMXBean\n+     * is used to temporarily changing target parallelism to an \"unique\" value, make it\n+     * possbile to find the right pool.\n+     *\/\n+    private ForkJoinPool defaultScheduler() {\n+        var done = new AtomicBoolean();\n+        Thread vthread = Thread.startVirtualThread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        var bean = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+        int parallelism = bean.getParallelism();\n+        try {\n+            bean.setParallelism(133);\n+            return Thread.getAllStackTraces()\n+                    .keySet()\n+                    .stream()\n+                    .filter(ForkJoinWorkerThread.class::isInstance)\n+                    .map(t -> ((ForkJoinWorkerThread) t).getPool())\n+                    .filter(p -> p.getParallelism() == 133)\n+                    .findAny()\n+                    .orElseThrow();\n+        } finally {\n+            bean.setParallelism(parallelism);\n+            done.set(true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/VThreadSummaryTest.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"}]}