{"files":[{"patch":"@@ -106,1 +106,1 @@\n-  inline void change_dirty_cards_to(size_t start_card_index, size_t num_cards, CardValue which);\n+  inline void change_dirty_cards_to(CardValue* start_card, CardValue* end_card, CardValue which);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,5 +75,3 @@\n-inline void G1CardTable::change_dirty_cards_to(size_t start_card_index, size_t num_cards, CardValue which) {\n-  CardValue* start = &_byte_map[start_card_index];\n-  CardValue* const end = start + num_cards;\n-  while (start < end) {\n-    CardValue value = *start;\n+inline void G1CardTable::change_dirty_cards_to(CardValue* start_card, CardValue* end_card, CardValue which) {\n+  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n+    CardValue value = *i_card;\n@@ -81,2 +79,2 @@\n-           \"Must have been dirty %d start \" PTR_FORMAT \" \" PTR_FORMAT, value, p2i(start), p2i(end));\n-    *start++ = which;\n+           \"Must have been dirty %d start \" PTR_FORMAT \" \" PTR_FORMAT, value, p2i(start_card), p2i(end_card));\n+    *i_card = which;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -483,101 +483,0 @@\n-\/\/ Helper class to scan and detect ranges of cards that need to be scanned on the\n-\/\/ card table.\n-class G1CardTableScanner : public StackObj {\n-public:\n-  typedef CardTable::CardValue CardValue;\n-\n-private:\n-  CardValue* const _base_addr;\n-\n-  CardValue* _cur_addr;\n-  CardValue* const _end_addr;\n-\n-  static const size_t ToScanMask = G1CardTable::g1_card_already_scanned;\n-  static const size_t ExpandedToScanMask = G1CardTable::WordAlreadyScanned;\n-\n-  bool cur_addr_aligned() const {\n-    return ((uintptr_t)_cur_addr) % sizeof(size_t) == 0;\n-  }\n-\n-  bool cur_card_is_dirty() const {\n-    CardValue value = *_cur_addr;\n-    return (value & ToScanMask) == 0;\n-  }\n-\n-  bool cur_word_of_cards_contains_any_dirty_card() const {\n-    assert(cur_addr_aligned(), \"Current address should be aligned\");\n-    size_t const value = *(size_t*)_cur_addr;\n-    return (~value & ExpandedToScanMask) != 0;\n-  }\n-\n-  bool cur_word_of_cards_all_dirty_cards() const {\n-    size_t const value = *(size_t*)_cur_addr;\n-    return value == G1CardTable::WordAllDirty;\n-  }\n-\n-  size_t get_and_advance_pos() {\n-    _cur_addr++;\n-    return pointer_delta(_cur_addr, _base_addr, sizeof(CardValue)) - 1;\n-  }\n-\n-public:\n-  G1CardTableScanner(CardValue* start_card, size_t size) :\n-    _base_addr(start_card),\n-    _cur_addr(start_card),\n-    _end_addr(start_card + size) {\n-\n-    assert(is_aligned(start_card, sizeof(size_t)), \"Unaligned start addr \" PTR_FORMAT, p2i(start_card));\n-    assert(is_aligned(size, sizeof(size_t)), \"Unaligned size \" SIZE_FORMAT, size);\n-  }\n-\n-  size_t find_next_dirty() {\n-    while (!cur_addr_aligned()) {\n-      if (cur_card_is_dirty()) {\n-        return get_and_advance_pos();\n-      }\n-      _cur_addr++;\n-    }\n-\n-    assert(cur_addr_aligned(), \"Current address should be aligned now.\");\n-    while (_cur_addr != _end_addr) {\n-      if (cur_word_of_cards_contains_any_dirty_card()) {\n-        for (size_t i = 0; i < sizeof(size_t); i++) {\n-          if (cur_card_is_dirty()) {\n-            return get_and_advance_pos();\n-          }\n-          _cur_addr++;\n-        }\n-        assert(false, \"Should not reach here given we detected a dirty card in the word.\");\n-      }\n-      _cur_addr += sizeof(size_t);\n-    }\n-    return get_and_advance_pos();\n-  }\n-\n-  size_t find_next_non_dirty() {\n-    assert(_cur_addr <= _end_addr, \"Not allowed to search for marks after area.\");\n-\n-    while (!cur_addr_aligned()) {\n-      if (!cur_card_is_dirty()) {\n-        return get_and_advance_pos();\n-      }\n-      _cur_addr++;\n-    }\n-\n-    assert(cur_addr_aligned(), \"Current address should be aligned now.\");\n-    while (_cur_addr != _end_addr) {\n-      if (!cur_word_of_cards_all_dirty_cards()) {\n-        for (size_t i = 0; i < sizeof(size_t); i++) {\n-          if (!cur_card_is_dirty()) {\n-            return get_and_advance_pos();\n-          }\n-          _cur_addr++;\n-        }\n-        assert(false, \"Should not reach here given we detected a non-dirty card in the word.\");\n-      }\n-      _cur_addr += sizeof(size_t);\n-    }\n-    return get_and_advance_pos();\n-  }\n-};\n-\n@@ -616,0 +515,2 @@\n+  using CardValue = CardTable::CardValue;\n+\n@@ -618,1 +519,0 @@\n-  G1BlockOffsetTable* _bot;\n@@ -639,1 +539,1 @@\n-  G1CardTable::CardValue _scanned_card_value;\n+  CardValue _scanned_card_value;\n@@ -653,2 +553,2 @@\n-  void do_claimed_block(uint const region_idx_for_card, size_t const first_card, size_t const num_cards) {\n-    HeapWord* const card_start = _bot->address_for_index_raw(first_card);\n+  void do_claimed_block(uint const region_idx_for_card, CardValue* first_card, size_t const num_cards) {\n+    HeapWord* const card_start = _ct->addr_for(first_card);\n@@ -675,5 +575,95 @@\n-  ALWAYSINLINE void do_card_block(uint const region_idx, size_t const first_card, size_t const num_cards) {\n-    _ct->change_dirty_cards_to(first_card, num_cards, _scanned_card_value);\n-    do_claimed_block(region_idx, first_card, num_cards);\n-    _blocks_scanned++;\n-  }\n+  class ClaimedChunk {\n+    using Word = size_t;\n+\n+    CardValue* const _start_card;\n+    CardValue* const _end_card;\n+\n+    static const size_t ExpandedToScanMask = G1CardTable::WordAlreadyScanned;\n+    static const size_t ToScanMask = G1CardTable::g1_card_already_scanned;\n+\n+    static bool is_card_dirty(const CardValue* const card) {\n+      return (*card & ToScanMask) == 0;\n+    }\n+\n+    static bool is_word_aligned(const void* const addr) {\n+      return ((uintptr_t)addr) % sizeof(Word) == 0;\n+    }\n+\n+    CardValue* find_first_dirty_card(CardValue* i_card) const {\n+      while (!is_word_aligned(i_card)) {\n+        if (is_card_dirty(i_card)) {\n+          return i_card;\n+        }\n+        i_card++;\n+      }\n+\n+      for (\/* empty *\/; i_card < _end_card; i_card += sizeof(Word)) {\n+        Word word_value = *reinterpret_cast<Word*>(i_card);\n+        bool has_dirty_cards_in_word = (~word_value & ExpandedToScanMask) != 0;\n+\n+        if (has_dirty_cards_in_word) {\n+          for (uint i = 0; i < sizeof(Word); ++i) {\n+            if (is_card_dirty(i_card)) {\n+              return i_card;\n+            }\n+            i_card++;\n+          }\n+          assert(false, \"should have early-returned\");\n+        }\n+      }\n+\n+      return _end_card;\n+    }\n+\n+    CardValue* find_first_non_dirty_card(CardValue* i_card) const {\n+      while (!is_word_aligned(i_card)) {\n+        if (!is_card_dirty(i_card)) {\n+          return i_card;\n+        }\n+        i_card++;\n+      }\n+\n+      for (\/* empty *\/; i_card < _end_card; i_card += sizeof(Word)) {\n+        Word word_value = *reinterpret_cast<Word*>(i_card);\n+        bool all_cards_dirty = (word_value == G1CardTable::WordAllDirty);\n+\n+        if (!all_cards_dirty) {\n+          for (uint i = 0; i < sizeof(Word); ++i) {\n+            if (!is_card_dirty(i_card)) {\n+              return i_card;\n+            }\n+            i_card++;\n+          }\n+          assert(false, \"should have early-returned\");\n+        }\n+      }\n+\n+      return _end_card;\n+    }\n+  public:\n+    ClaimedChunk(CardValue* const start_card, CardValue* const end_card) :\n+      _start_card(start_card),\n+      _end_card(end_card) {\n+        assert(is_word_aligned(start_card), \"precondition\");\n+        assert(is_word_aligned(end_card), \"precondition\");\n+      }\n+\n+    template<typename Func>\n+    void on_dirty_cards(Func&& f) {\n+      for (CardValue* cur_card = _start_card; cur_card < _end_card; \/* empty *\/) {\n+        CardValue* dirty_l = find_first_dirty_card(cur_card);\n+        CardValue* dirty_r = find_first_non_dirty_card(dirty_l);\n+\n+        assert(dirty_l <= dirty_r, \"inv\");\n+\n+        if (dirty_l == dirty_r) {\n+          assert(dirty_r == _end_card, \"finished the entire chunk\");\n+          return;\n+        }\n+\n+        f(dirty_l, dirty_r);\n+\n+        cur_card = dirty_r + 1;\n+      }\n+    }\n+  };\n@@ -695,16 +685,1 @@\n-      size_t const region_card_base_idx = ((size_t)region_idx << HeapRegion::LogCardsPerRegion) + claim.value();\n-      CardTable::CardValue* const base_addr = _ct->byte_for_index(region_card_base_idx);\n-\n-      G1CardTableScanner scan(base_addr, claim.size());\n-\n-      size_t first_scan_idx = scan.find_next_dirty();\n-      while (first_scan_idx != claim.size()) {\n-#ifdef ASSERT\n-        {\n-          CardTable::CardValue value = *_ct->byte_for_index(region_card_base_idx + first_scan_idx);\n-          assert(value == CardTable::dirty_card_val(), \"is %d at region %u idx \" SIZE_FORMAT, value, region_idx, first_scan_idx);\n-        }\n-#endif\n-\n-        size_t const last_scan_idx = scan.find_next_non_dirty();\n-        size_t const len = last_scan_idx - first_scan_idx;\n+      _chunks_claimed++;\n@@ -712,1 +687,1 @@\n-        do_card_block(region_idx, region_card_base_idx + first_scan_idx, len);\n+      size_t const region_card_base_idx = ((size_t)region_idx << HeapRegion::LogCardsPerRegion) + claim.value();\n@@ -714,3 +689,2 @@\n-        if (last_scan_idx == claim.size()) {\n-          break;\n-        }\n+      CardValue* const start_card = _ct->byte_for_index(region_card_base_idx);\n+      CardValue* const end_card = start_card + claim.size();\n@@ -718,3 +692,7 @@\n-        first_scan_idx = scan.find_next_dirty();\n-      }\n-      _chunks_claimed++;\n+      ClaimedChunk chunk{start_card, end_card};\n+      chunk.on_dirty_cards([&] (CardValue* dirty_l, CardValue* dirty_r) {\n+                             _ct->change_dirty_cards_to(dirty_l, dirty_r, _scanned_card_value);\n+                             size_t num_cards = dirty_r - dirty_l;\n+                             do_claimed_block(region_idx, dirty_l, num_cards);\n+                             _blocks_scanned++;\n+                           });\n@@ -732,1 +710,0 @@\n-    _bot(_g1h->bot()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":111,"deletions":134,"binary":false,"changes":245,"status":"modified"}]}