{"files":[{"patch":"@@ -550,16 +550,0 @@\n-  case vmIntrinsics::_getModifiers: {\n-    assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-    \/\/ Optimize for Foo.class.getModifier()\n-    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n-    if (c != nullptr && !c->value()->is_null_object()) {\n-      ciType* t = c->value()->java_mirror_type();\n-      if (t->is_klass()) {\n-        set_constant(t->as_klass()->modifier_flags());\n-      } else {\n-        assert(t->is_primitive_type(), \"should be a primitive type\");\n-        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-      }\n-    }\n-    break;\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -159,1 +159,0 @@\n-  case vmIntrinsics::_getModifiers:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1306,36 +1306,0 @@\n-\/\/ Example: Foo.class.getModifiers()\n-void LIRGenerator::do_getModifiers(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-  LIRItem receiver(x->argument_at(0), this);\n-  receiver.load_item();\n-  LIR_Opr result = rlock_result(x);\n-\n-  CodeEmitInfo* info = nullptr;\n-  if (x->needs_null_check()) {\n-    info = state_for(x);\n-  }\n-\n-  \/\/ While reading off the universal constant mirror is less efficient than doing\n-  \/\/ another branch and returning the constant answer, this branchless code runs into\n-  \/\/ much less risk of confusion for C1 register allocator. The choice of the universe\n-  \/\/ object here is correct as long as it returns the same modifiers we would expect\n-  \/\/ from the primitive class itself. See spec for Class.getModifiers that provides\n-  \/\/ the typed array klasses with similar modifiers as their component types.\n-\n-  Klass* univ_klass = Universe::byteArrayKlass();\n-  assert(univ_klass->modifier_flags() == (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC), \"Sanity\");\n-  LIR_Opr prim_klass = LIR_OprFact::metadataConst(univ_klass);\n-\n-  LIR_Opr recv_klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(receiver.result(), java_lang_Class::klass_offset(), T_ADDRESS), recv_klass, info);\n-\n-  \/\/ Check if this is a Java mirror of primitive type, and select the appropriate klass.\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(nullptr));\n-  __ cmove(lir_cond_equal, prim_klass, recv_klass, klass, T_ADDRESS);\n-\n-  \/\/ Get the answer.\n-  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_CHAR), result);\n-}\n-\n@@ -2960,1 +2924,0 @@\n-  case vmIntrinsics::_getModifiers:   do_getModifiers(x);  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,1 +258,0 @@\n-  void do_getModifiers(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-  \/\/ Fetch Klass::modifier_flags.\n+  \/\/ Fetch modifier flags.\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3750,5 +3750,0 @@\n-  \/\/ Initialize cached modifier_flags to support Class.getModifiers().\n-  \/\/ This must follow setting inner_class attributes.\n-  u2 computed_modifiers = this_klass->compute_modifier_flags();\n-  this_klass->set_modifier_flags(computed_modifiers);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -870,0 +870,1 @@\n+int java_lang_Class::_modifiers_offset;\n@@ -1063,0 +1064,4 @@\n+  \/\/ Set the modifiers flag.\n+  int computed_modifiers = k->compute_modifier_flags();\n+  set_modifiers(mirror(), computed_modifiers);\n+\n@@ -1358,0 +1363,1 @@\n+  set_modifiers(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n@@ -1496,1 +1502,2 @@\n-  macro(_signers_offset,             k, \"signers\",             object_array_signature, false);\n+  macro(_signers_offset,             k, \"signers\",             object_array_signature, false); \\\n+  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), int_signature,    false);\n@@ -1530,0 +1537,10 @@\n+int java_lang_Class::modifiers(oop the_class_mirror) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->int_field(_modifiers_offset);\n+}\n+\n+void java_lang_Class::set_modifiers(oop the_class_mirror, int value) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->int_field_put(_modifiers_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+  static int _modifiers_offset;\n@@ -340,0 +341,3 @@\n+  static int modifiers(oop java_class);\n+  static void set_modifiers(oop java_class, int value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,0 @@\n-  case vmIntrinsics::_getModifiers:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -307,2 +307,0 @@\n-  do_intrinsic(_getModifiers,             java_lang_Class,        getModifiers_name, void_int_signature,         F_RN)  \\\n-   do_name(     getModifiers_name,                               \"getModifiers\")                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -331,0 +331,6 @@\n+int Klass::modifier_flags() const {\n+  int mods = java_lang_Class::modifiers(java_mirror());\n+  assert(mods == compute_modifier_flags(), \"should be same\");\n+  return mods;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,3 +126,0 @@\n-  \/\/ Processed access flags, for use by Class.getModifiers.\n-  u2          _modifier_flags;\n-\n@@ -295,4 +292,0 @@\n-  \/\/ modifier flags\n-  u2 modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n-\n@@ -451,1 +444,0 @@\n-  static ByteSize modifier_flags_offset()        { return byte_offset_of(Klass, _modifier_flags); }\n@@ -761,0 +753,1 @@\n+  int modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -142,3 +142,0 @@\n-\n-  \/\/ Compute modifier flags after bottom_klass and element_klass are initialized.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,3 +90,0 @@\n-\n-  \/\/ Compute modifier flags.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  u2 compute_modifier_flags() const;\n+\n@@ -76,2 +78,0 @@\n-  u2 compute_modifier_flags() const;\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -752,1 +752,0 @@\n-  case vmIntrinsics::_getModifiers:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1702,2 +1702,0 @@\n-      if (flat->offset() == in_bytes(Klass::modifier_flags_offset()))\n-        alias_type(idx)->set_rewritable(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,1 +518,0 @@\n-  case vmIntrinsics::_getModifiers:\n@@ -3894,4 +3893,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n@@ -3977,5 +3972,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1975,6 +1975,0 @@\n-  if (tkls->offset() == in_bytes(Klass::modifier_flags_offset())) {\n-    \/\/ The field is Klass::_modifier_flags.  Return its (constant) value.\n-    \/\/ (Folds up the 2nd indirection in aClassConstant.getModifiers().)\n-    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n-    return TypeInt::make(klass->modifier_flags());\n-  }\n@@ -2464,1 +2458,1 @@\n-        \/\/ (Folds up the 1st indirection in aClassConstant.getModifiers().)\n+        \/\/ Fold up the load of the hidden field\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1300,16 +1300,0 @@\n-JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive type\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  debug_only(u2 computed_modifiers = k->compute_modifier_flags());\n-  assert(k->modifier_flags() == computed_modifiers, \"modifiers cache is OK\");\n-  return k->modifier_flags();\n-JVM_END\n-\n-\n-\/\/ Inner class reflection \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2720,2 +2720,1 @@\n-  JavaThread* current_thread  = JavaThread::current();\n-  jint result = 0;\n+  jint result = java_lang_Class::modifiers(k_mirror);\n@@ -2723,4 +2722,0 @@\n-    Klass* k = java_lang_Class::as_Klass(k_mirror);\n-    NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);\n-    result = k->modifier_flags();\n-\n@@ -2728,5 +2723,1 @@\n-    if (k->is_super()) {\n-      result |= JVM_ACC_SUPER;\n-    }\n-  } else {\n-    result = (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+    result |= JVM_ACC_SUPER;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, int mods) {\n@@ -244,0 +244,1 @@\n+        modifiers = mods;\n@@ -1003,0 +1004,1 @@\n+    private final transient int modifiers;  \/\/ Set by the VM\n@@ -1347,2 +1349,1 @@\n-    @IntrinsicCandidate\n-    public native int getModifiers();\n+    public int getModifiers() { return modifiers; }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            Class.class, Set.of(\"classLoader\", \"classData\"),\n+            Class.class, Set.of(\"classLoader\", \"classData\", \"modifiers\"),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-    {\"getModifiers\",     \"()I\",             (void *)&JVM_GetClassModifiers},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, int.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/ModuleSetAccessibleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, int.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/TrySetAccessibleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8210496\n+ * @bug 8210496 8346567\n@@ -58,0 +58,1 @@\n+            { Class.class, \"modifiers\" },\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/Filtering.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n@@ -38,0 +40,1 @@\n+@State(Scope.Benchmark)\n@@ -55,0 +58,35 @@\n+    \/**\n+     * Get modifiers for this class through reflection\n+     *\n+     * @return\n+     * @throws NoSuchMethodException\n+     *\/\n+    @Benchmark\n+    public int getModifiers() {\n+        return Clazz.class.getModifiers();\n+    }\n+\n+    Clazz[] clazzArray = new Clazz[1];\n+    @Benchmark\n+    public int getAppArrayModifiers() {\n+        return clazzArray.getClass().getModifiers();\n+    }\n+\n+    static final Clazz[] clazzArrayFinal = new Clazz[1];\n+    @Benchmark\n+    public int getAppArrayModifiersFinal() {\n+        return clazzArrayFinal.getClass().getModifiers();\n+    }\n+\n+    \/**\n+     * Get modifiers for an primitive array class through reflection\n+     *\n+     * @return\n+     * @throws NoSuchMethodException\n+     *\/\n+    @Benchmark\n+    public int getArrayModifiers() {\n+        return int[].class.getModifiers();\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Clazz.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"}]}