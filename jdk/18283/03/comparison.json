{"files":[{"patch":"@@ -1,548 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"os_posix.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-\n-#include <unistd.h>\n-#include <signal.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/un.h>\n-#include <sys\/stat.h>\n-\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n-\n-\/\/ The attach mechanism on Bsd uses a UNIX domain socket. An attach listener\n-\/\/ thread is created at startup or is created on-demand via a signal from\n-\/\/ the client tool. The attach listener creates a socket and binds it to a file\n-\/\/ in the filesystem. The attach listener then acts as a simple (single-\n-\/\/ threaded) server - it waits for a client to connect, reads the request,\n-\/\/ executes it, and returns the response to the client via the socket\n-\/\/ connection.\n-\/\/\n-\/\/ As the socket is a UNIX domain socket it means that only clients on the\n-\/\/ local machine can connect. In addition there are two other aspects to\n-\/\/ the security:\n-\/\/ 1. The well known file that the socket is bound to has permission 400\n-\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n-\/\/    obtain the credentials of client. We check that the effective uid\n-\/\/    of the client matches this process.\n-\n-\/\/ forward reference\n-class BsdAttachOperation;\n-\n-class BsdAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static BsdAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static BsdAttachOperation* dequeue();\n-};\n-\n-class BsdAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  BsdAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n-\/\/ statics\n-char BsdAttachListener::_path[UNIX_PATH_MAX];\n-bool BsdAttachListener::_has_path;\n-volatile int BsdAttachListener::_listener = -1;\n-bool BsdAttachListener::_atexit_registered = false;\n-\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n-\/\/ atexit hook to stop listener and unlink the file that it is\n-\/\/ bound too.\n-extern \"C\" {\n-  static void listener_cleanup() {\n-    int s = BsdAttachListener::listener();\n-    if (s != -1) {\n-      BsdAttachListener::set_listener(-1);\n-      ::shutdown(s, SHUT_RDWR);\n-      ::close(s);\n-    }\n-    if (BsdAttachListener::has_path()) {\n-      ::unlink(BsdAttachListener::path());\n-      BsdAttachListener::set_path(nullptr);\n-    }\n-  }\n-}\n-\n-\/\/ Initialization - create a listener socket and bind it to a file\n-\n-int BsdAttachListener::init() {\n-  char path[UNIX_PATH_MAX];          \/\/ socket file\n-  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n-  int listener;                      \/\/ listener socket (file descriptor)\n-\n-  \/\/ register function to cleanup\n-  if (!_atexit_registered) {\n-    _atexit_registered = true;\n-    ::atexit(listener_cleanup);\n-  }\n-\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n-  if (n < (int)UNIX_PATH_MAX) {\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n-  }\n-  if (n >= (int)UNIX_PATH_MAX) {\n-    return -1;\n-  }\n-\n-  \/\/ create the listener socket\n-  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n-  if (listener == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ bind socket\n-  struct sockaddr_un addr;\n-  memset((void *)&addr, 0, sizeof(addr));\n-  addr.sun_family = AF_UNIX;\n-  strcpy(addr.sun_path, initial_path);\n-  ::unlink(initial_path);\n-  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n-  if (res == -1) {\n-    ::close(listener);\n-    return -1;\n-  }\n-\n-  \/\/ put in listen mode, set permissions, and rename into place\n-  res = ::listen(listener, 5);\n-  if (res == 0) {\n-    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n-    if (res == 0) {\n-      \/\/ make sure the file is owned by the effective user and effective group\n-      \/\/ e.g. default behavior on mac is that new files inherit the group of\n-      \/\/ the directory that they are created in\n-      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n-      if (res == 0) {\n-        res = ::rename(initial_path, path);\n-      }\n-    }\n-  }\n-  if (res == -1) {\n-    ::close(listener);\n-    ::unlink(initial_path);\n-    return -1;\n-  }\n-  set_path(path);\n-  set_listener(listener);\n-\n-  return 0;\n-}\n-\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-BsdAttachOperation* BsdAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  size_t ver_str_len = os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != ver_str_len) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, msg_len);\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  BsdAttachOperation* op = new BsdAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n-\n-\/\/ Dequeue an operation\n-\/\/\n-\/\/ In the Bsd implementation there is only a single operation and clients\n-\/\/ cannot queue commands (except at the socket level).\n-\/\/\n-BsdAttachOperation* BsdAttachListener::dequeue() {\n-  for (;;) {\n-    int s;\n-\n-    \/\/ wait for client to connect\n-    struct sockaddr addr;\n-    socklen_t len = sizeof(addr);\n-    RESTARTABLE(::accept(listener(), &addr, &len), s);\n-    if (s == -1) {\n-      return nullptr;      \/\/ log a warning?\n-    }\n-\n-    \/\/ get the credentials of the peer and check the effective uid\/guid\n-    uid_t puid;\n-    gid_t pgid;\n-    if (::getpeereid(s, &puid, &pgid) != 0) {\n-      log_debug(attach)(\"Failed to get peer id\");\n-      ::close(s);\n-      continue;\n-    }\n-\n-    if (!os::Posix::matches_effective_uid_and_gid_or_root(puid, pgid)) {\n-      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\", puid, pgid,\n-              geteuid(), getegid());\n-      ::close(s);\n-      continue;\n-    }\n-\n-    \/\/ peer credential look okay so we read the request\n-    BsdAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n-      continue;\n-    } else {\n-      return op;\n-    }\n-  }\n-}\n-\n-\/\/ write the given buffer to the socket\n-int BsdAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n-\/\/ Complete an operation by sending the operation result and any result\n-\/\/ output to the client. At this time the socket is in blocking mode so\n-\/\/ potentially we can block if there is a lot of data and the client is\n-\/\/ non-responsive. For most operations this is a non-issue because the\n-\/\/ default send buffer is sufficient to buffer everything. In the future\n-\/\/ if there are operations that involves a very big reply then it the\n-\/\/ socket could be made non-blocking and a timeout could be used.\n-\n-void BsdAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  \/\/ write operation result\n-  char msg[32];\n-  int msg_len = os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = BsdAttachListener::write_fully(this->socket(), msg, msg_len);\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    BsdAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n-\n-  delete this;\n-}\n-\n-\n-\/\/ AttachListener functions\n-\n-AttachOperation* AttachListener::dequeue() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  AttachOperation* op = BsdAttachListener::dequeue();\n-\n-  return op;\n-}\n-\n-\/\/ Performs initialization at vm startup\n-\/\/ For BSD we remove any stale .java_pid file which could cause\n-\/\/ an attaching process to think we are ready to receive on the\n-\/\/ domain socket before we are properly initialized\n-\n-void AttachListener::vm_start() {\n-  char fn[UNIX_PATH_MAX];\n-  struct stat st;\n-  int ret;\n-\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n-\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == 0) {\n-    ret = ::unlink(fn);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n-    }\n-  }\n-}\n-\n-int AttachListener::pd_init() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  int ret_code = BsdAttachListener::init();\n-\n-  return ret_code;\n-}\n-\n-bool AttachListener::check_socket_file() {\n-  int ret;\n-  struct stat st;\n-  ret = stat(BsdAttachListener::path(), &st);\n-  if (ret == -1) { \/\/ need to restart attach listener.\n-    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n-                      BsdAttachListener::path());\n-\n-    listener_cleanup();\n-\n-    \/\/ wait to terminate current attach listener instance...\n-    {\n-      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n-      ThreadBlockInVM tbivm(JavaThread::current());\n-      while (AttachListener::transit_state(AL_INITIALIZING,\n-                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-        os::naked_yield();\n-      }\n-    }\n-    return is_init_trigger();\n-  }\n-  return false;\n-}\n-\n-\/\/ Attach Listener is started lazily except in the case when\n-\/\/ +ReduseSignalUsage is used\n-bool AttachListener::init_at_startup() {\n-  if (ReduceSignalUsage) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If the file .attach_pid<pid> exists in the working directory\n-\/\/ or \/tmp then this is the trigger to start the attach mechanism\n-bool AttachListener::is_init_trigger() {\n-  if (init_at_startup() || is_initialized()) {\n-    return false;               \/\/ initialized at startup or already initialized\n-  }\n-  char fn[PATH_MAX + 1];\n-  int ret;\n-  struct stat st;\n-  snprintf(fn, PATH_MAX + 1, \"%s\/.attach_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == -1) {\n-    log_debug(attach)(\"Failed to find attach file: %s\", fn);\n-  }\n-  if (ret == 0) {\n-    \/\/ simple check to avoid starting the attach mechanism when\n-    \/\/ a bogus non-root user creates the file\n-    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n-      init();\n-      log_trace(attach)(\"Attach triggered by %s\", fn);\n-      return true;\n-    } else {\n-      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ if VM aborts then remove listener\n-void AttachListener::abort() {\n-  listener_cleanup();\n-}\n-\n-void AttachListener::pd_data_dump() {\n-  os::signal_notify(SIGQUIT);\n-}\n-\n-void AttachListener::pd_detachall() {\n-  \/\/ do nothing for now\n-}\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":0,"deletions":548,"binary":false,"changes":548,"status":"deleted"},{"patch":"@@ -1,555 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"os_posix.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-\n-#include <unistd.h>\n-#include <signal.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <sys\/un.h>\n-#include <sys\/stat.h>\n-\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n-\n-\/\/ The attach mechanism on Linux uses a UNIX domain socket. An attach listener\n-\/\/ thread is created at startup or is created on-demand via a signal from\n-\/\/ the client tool. The attach listener creates a socket and binds it to a file\n-\/\/ in the filesystem. The attach listener then acts as a simple (single-\n-\/\/ threaded) server - it waits for a client to connect, reads the request,\n-\/\/ executes it, and returns the response to the client via the socket\n-\/\/ connection.\n-\/\/\n-\/\/ As the socket is a UNIX domain socket it means that only clients on the\n-\/\/ local machine can connect. In addition there are two other aspects to\n-\/\/ the security:\n-\/\/ 1. The well known file that the socket is bound to has permission 400\n-\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n-\/\/    obtain the credentials of client. We check that the effective uid\n-\/\/    of the client matches this process.\n-\n-\/\/ forward reference\n-class LinuxAttachOperation;\n-\n-class LinuxAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static LinuxAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static LinuxAttachOperation* dequeue();\n-};\n-\n-class LinuxAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  LinuxAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n-\/\/ statics\n-char LinuxAttachListener::_path[UNIX_PATH_MAX];\n-bool LinuxAttachListener::_has_path;\n-volatile int LinuxAttachListener::_listener = -1;\n-bool LinuxAttachListener::_atexit_registered = false;\n-\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n-\/\/ atexit hook to stop listener and unlink the file that it is\n-\/\/ bound too.\n-extern \"C\" {\n-  static void listener_cleanup() {\n-    int s = LinuxAttachListener::listener();\n-    if (s != -1) {\n-      LinuxAttachListener::set_listener(-1);\n-      ::shutdown(s, SHUT_RDWR);\n-      ::close(s);\n-    }\n-    if (LinuxAttachListener::has_path()) {\n-      ::unlink(LinuxAttachListener::path());\n-      LinuxAttachListener::set_path(nullptr);\n-    }\n-  }\n-}\n-\n-\/\/ Initialization - create a listener socket and bind it to a file\n-\n-int LinuxAttachListener::init() {\n-  char path[UNIX_PATH_MAX];          \/\/ socket file\n-  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n-  int listener;                      \/\/ listener socket (file descriptor)\n-\n-  static_assert(sizeof(off_t) == 8, \"Expected Large File Support in this file\");\n-\n-  \/\/ register function to cleanup\n-  if (!_atexit_registered) {\n-    _atexit_registered = true;\n-    ::atexit(listener_cleanup);\n-  }\n-\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n-  if (n < (int)UNIX_PATH_MAX) {\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n-  }\n-  if (n >= (int)UNIX_PATH_MAX) {\n-    return -1;\n-  }\n-\n-  \/\/ create the listener socket\n-  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n-  if (listener == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ bind socket\n-  struct sockaddr_un addr;\n-  memset((void *)&addr, 0, sizeof(addr));\n-  addr.sun_family = AF_UNIX;\n-  strcpy(addr.sun_path, initial_path);\n-  ::unlink(initial_path);\n-  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n-  if (res == -1) {\n-    ::close(listener);\n-    return -1;\n-  }\n-\n-  \/\/ put in listen mode, set permissions, and rename into place\n-  res = ::listen(listener, 5);\n-  if (res == 0) {\n-    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n-    if (res == 0) {\n-      \/\/ make sure the file is owned by the effective user and effective group\n-      \/\/ e.g. the group could be inherited from the directory in case the s bit is set\n-      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n-      if (res == 0) {\n-        res = ::rename(initial_path, path);\n-      }\n-    }\n-  }\n-  if (res == -1) {\n-    ::close(listener);\n-    ::unlink(initial_path);\n-    return -1;\n-  }\n-  set_path(path);\n-  set_listener(listener);\n-\n-  return 0;\n-}\n-\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-LinuxAttachOperation* LinuxAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != strlen(ver_str)) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  LinuxAttachOperation* op = new LinuxAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n-\n-\/\/ Dequeue an operation\n-\/\/\n-\/\/ In the Linux implementation there is only a single operation and clients\n-\/\/ cannot queue commands (except at the socket level).\n-\/\/\n-LinuxAttachOperation* LinuxAttachListener::dequeue() {\n-  for (;;) {\n-    int s;\n-\n-    \/\/ wait for client to connect\n-    struct sockaddr addr;\n-    socklen_t len = sizeof(addr);\n-    RESTARTABLE(::accept(listener(), &addr, &len), s);\n-    if (s == -1) {\n-      return nullptr;      \/\/ log a warning?\n-    }\n-\n-    \/\/ get the credentials of the peer and check the effective uid\/guid\n-    struct ucred cred_info;\n-    socklen_t optlen = sizeof(cred_info);\n-    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {\n-      log_debug(attach)(\"Failed to get socket option SO_PEERCRED\");\n-      ::close(s);\n-      continue;\n-    }\n-\n-    if (!os::Posix::matches_effective_uid_and_gid_or_root(cred_info.uid, cred_info.gid)) {\n-      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\",\n-              cred_info.uid, cred_info.gid, geteuid(), getegid());\n-      ::close(s);\n-      continue;\n-    }\n-\n-    \/\/ peer credential look okay so we read the request\n-    LinuxAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n-      continue;\n-    } else {\n-      return op;\n-    }\n-  }\n-}\n-\n-\/\/ write the given buffer to the socket\n-int LinuxAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n-\/\/ Complete an operation by sending the operation result and any result\n-\/\/ output to the client. At this time the socket is in blocking mode so\n-\/\/ potentially we can block if there is a lot of data and the client is\n-\/\/ non-responsive. For most operations this is a non-issue because the\n-\/\/ default send buffer is sufficient to buffer everything. In the future\n-\/\/ if there are operations that involves a very big reply then it the\n-\/\/ socket could be made non-blocking and a timeout could be used.\n-\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  \/\/ write operation result\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = LinuxAttachListener::write_fully(this->socket(), msg, strlen(msg));\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    LinuxAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n-\n-  delete this;\n-}\n-\n-\n-\/\/ AttachListener functions\n-\n-AttachOperation* AttachListener::dequeue() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  AttachOperation* op = LinuxAttachListener::dequeue();\n-\n-  return op;\n-}\n-\n-\/\/ Performs initialization at vm startup\n-\/\/ For Linux we remove any stale .java_pid file which could cause\n-\/\/ an attaching process to think we are ready to receive on the\n-\/\/ domain socket before we are properly initialized\n-\n-void AttachListener::vm_start() {\n-  char fn[UNIX_PATH_MAX];\n-  struct stat st;\n-  int ret;\n-\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n-\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == 0) {\n-    ret = ::unlink(fn);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n-    }\n-  }\n-}\n-\n-int AttachListener::pd_init() {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  int ret_code = LinuxAttachListener::init();\n-\n-  return ret_code;\n-}\n-\n-bool AttachListener::check_socket_file() {\n-  int ret;\n-  struct stat st;\n-  ret = stat(LinuxAttachListener::path(), &st);\n-  if (ret == -1) { \/\/ need to restart attach listener.\n-    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n-                      LinuxAttachListener::path());\n-\n-    listener_cleanup();\n-\n-    \/\/ wait to terminate current attach listener instance...\n-    {\n-      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n-      ThreadBlockInVM tbivm(JavaThread::current());\n-      while (AttachListener::transit_state(AL_INITIALIZING,\n-                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-        os::naked_yield();\n-      }\n-    }\n-    return is_init_trigger();\n-  }\n-  return false;\n-}\n-\n-\/\/ Attach Listener is started lazily except in the case when\n-\/\/ +ReduseSignalUsage is used\n-bool AttachListener::init_at_startup() {\n-  if (ReduceSignalUsage) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ If the file .attach_pid<pid> exists in the working directory\n-\/\/ or \/tmp then this is the trigger to start the attach mechanism\n-bool AttachListener::is_init_trigger() {\n-  if (init_at_startup() || is_initialized()) {\n-    return false;               \/\/ initialized at startup or already initialized\n-  }\n-  char fn[PATH_MAX + 1];\n-  int ret;\n-  struct stat st;\n-  os::snprintf_checked(fn, sizeof(fn), \".attach_pid%d\", os::current_process_id());\n-  RESTARTABLE(::stat(fn, &st), ret);\n-  if (ret == -1) {\n-    log_trace(attach)(\"Failed to find attach file: %s, trying alternate\", fn);\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n-             os::get_temp_directory(), os::current_process_id());\n-    RESTARTABLE(::stat(fn, &st), ret);\n-    if (ret == -1) {\n-      log_debug(attach)(\"Failed to find attach file: %s\", fn);\n-    }\n-  }\n-  if (ret == 0) {\n-    \/\/ simple check to avoid starting the attach mechanism when\n-    \/\/ a bogus non-root user creates the file\n-    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n-      init();\n-      log_trace(attach)(\"Attach triggered by %s\", fn);\n-      return true;\n-    } else {\n-      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ if VM aborts then remove listener\n-void AttachListener::abort() {\n-  listener_cleanup();\n-}\n-\n-void AttachListener::pd_data_dump() {\n-  os::signal_notify(SIGQUIT);\n-}\n-\n-void AttachListener::pd_detachall() {\n-  \/\/ do nothing for now\n-}\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":0,"deletions":555,"binary":false,"changes":555,"status":"deleted"},{"patch":"@@ -0,0 +1,585 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"os_posix.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <unistd.h>\n+#include <signal.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <sys\/un.h>\n+#include <sys\/stat.h>\n+\n+#if INCLUDE_SERVICES\n+#ifndef AIX\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+\/\/ The attach mechanism on Linux and BSD uses a UNIX domain socket. An attach\n+\/\/ listener thread is created at startup or is created on-demand via a signal\n+\/\/ from the client tool. The attach listener creates a socket and binds it to a\n+\/\/ file in the filesystem. The attach listener then acts as a simple (single-\n+\/\/ threaded) server - it waits for a client to connect, reads the request,\n+\/\/ executes it, and returns the response to the client via the socket\n+\/\/ connection.\n+\/\/\n+\/\/ As the socket is a UNIX domain socket it means that only clients on the\n+\/\/ local machine can connect. In addition there are two other aspects to\n+\/\/ the security:\n+\/\/ 1. The well known file that the socket is bound to has permission 400\n+\/\/ 2. When a client connect, the SO_PEERCRED socket option is used to\n+\/\/    obtain the credentials of client. We check that the effective uid\n+\/\/    of the client matches this process.\n+\n+\/\/ forward reference\n+class NixAttachOperation;\n+\n+class NixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ reads a request from the given connected socket\n+  static NixAttachOperation* read_request(int s);\n+\n+ public:\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, size_t len);\n+\n+  static NixAttachOperation* dequeue();\n+};\n+\n+class NixAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  NixAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+  }\n+};\n+\n+\/\/ statics\n+char NixAttachListener::_path[UNIX_PATH_MAX];\n+bool NixAttachListener::_has_path;\n+volatile int NixAttachListener::_listener = -1;\n+bool NixAttachListener::_atexit_registered = false;\n+\n+\/\/ Supporting class to help split a buffer into individual components\n+class ArgumentIterator : public StackObj {\n+ private:\n+  char* _pos;\n+  char* _end;\n+ public:\n+  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n+    _pos = arg_buffer;\n+    _end = _pos + arg_size - 1;\n+  }\n+  char* next() {\n+    if (*_pos == '\\0') {\n+      \/\/ advance the iterator if possible (null arguments)\n+      if (_pos < _end) {\n+        _pos += 1;\n+      }\n+      return nullptr;\n+    }\n+    char* res = _pos;\n+    char* next_pos = strchr(_pos, '\\0');\n+    if (next_pos < _end)  {\n+      next_pos++;\n+    }\n+    _pos = next_pos;\n+    return res;\n+  }\n+};\n+\n+\n+\/\/ atexit hook to stop listener and unlink the file that it is\n+\/\/ bound too.\n+extern \"C\" {\n+  static void listener_cleanup() {\n+    int s = NixAttachListener::listener();\n+    if (s != -1) {\n+      NixAttachListener::set_listener(-1);\n+      ::shutdown(s, SHUT_RDWR);\n+      ::close(s);\n+    }\n+    if (NixAttachListener::has_path()) {\n+      ::unlink(NixAttachListener::path());\n+      NixAttachListener::set_path(nullptr);\n+    }\n+  }\n+}\n+\n+\/\/ Initialization - create a listener socket and bind it to a file\n+\n+int NixAttachListener::init() {\n+  char path[UNIX_PATH_MAX];          \/\/ socket file\n+  char initial_path[UNIX_PATH_MAX];  \/\/ socket file during setup\n+  int listener;                      \/\/ listener socket (file descriptor)\n+\n+  static_assert(sizeof(off_t) == 8, \"Expected Large File Support in this file\");\n+\n+  \/\/ register function to cleanup\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n+\n+  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                   os::get_temp_directory(), os::current_process_id());\n+  if (n < (int)UNIX_PATH_MAX) {\n+    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+  }\n+  if (n >= (int)UNIX_PATH_MAX) {\n+    return -1;\n+  }\n+\n+  \/\/ create the listener socket\n+  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);\n+  if (listener == -1) {\n+    return -1;\n+  }\n+\n+  \/\/ bind socket\n+  struct sockaddr_un addr;\n+  memset((void *)&addr, 0, sizeof(addr));\n+  addr.sun_family = AF_UNIX;\n+  strcpy(addr.sun_path, initial_path);\n+  ::unlink(initial_path);\n+  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));\n+  if (res == -1) {\n+    ::close(listener);\n+    return -1;\n+  }\n+\n+  \/\/ put in listen mode, set permissions, and rename into place\n+  res = ::listen(listener, 5);\n+  if (res == 0) {\n+    RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);\n+    if (res == 0) {\n+      \/\/ make sure the file is owned by the effective user and effective group\n+      \/\/ e.g. the group could be inherited from the directory in case the s bit\n+      \/\/ is set. The default behavior on mac is that new files inherit the group\n+      \/\/ of the directory that they are created in.\n+      RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);\n+      if (res == 0) {\n+        res = ::rename(initial_path, path);\n+      }\n+    }\n+  }\n+  if (res == -1) {\n+    ::close(listener);\n+    ::unlink(initial_path);\n+    return -1;\n+  }\n+  set_path(path);\n+  set_listener(listener);\n+\n+  return 0;\n+}\n+\n+\/\/ Given a socket that is connected to a peer we read the request and\n+\/\/ create an AttachOperation. As the socket is blocking there is potential\n+\/\/ for a denial-of-service if the peer does not response. However this happens\n+\/\/ after the peer credentials have been checked and in the worst case it just\n+\/\/ means that the attach listener thread is blocked.\n+\/\/\n+NixAttachOperation* NixAttachListener::read_request(int s) {\n+  char ver_str[8];\n+  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n+\n+  \/\/ The request is a sequence of strings so we first figure out the\n+  \/\/ expected count and the maximum possible length of the request.\n+  \/\/ The request is:\n+  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n+  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n+  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n+  int expected_str_count = 2 + AttachOperation::arg_count_max;\n+  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n+    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n+\n+  char buf[max_len];\n+  int str_count = 0;\n+\n+  \/\/ Read until all (expected) strings have been read, the buffer is\n+  \/\/ full, or EOF.\n+\n+  size_t off = 0;\n+  size_t left = max_len;\n+\n+  do {\n+    ssize_t n;\n+    RESTARTABLE(read(s, buf+off, left), n);\n+    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n+    buf[max_len - 1] = '\\0';\n+    if (n == -1) {\n+      return nullptr;      \/\/ reset by peer or other error\n+    }\n+    if (n == 0) {\n+      break;\n+    }\n+    for (ssize_t i=0; i<n; i++) {\n+      if (buf[off+i] == 0) {\n+        \/\/ EOS found\n+        str_count++;\n+\n+        \/\/ The first string is <ver> so check it now to\n+        \/\/ check for protocol mismatch\n+        if (str_count == 1) {\n+          if ((strlen(buf) != strlen(ver_str)) ||\n+              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n+            char msg[32];\n+            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n+            write_fully(s, msg, strlen(msg));\n+            return nullptr;\n+          }\n+        }\n+      }\n+    }\n+    off += n;\n+    left -= n;\n+  } while (left > 0 && str_count < expected_str_count);\n+\n+  if (str_count != expected_str_count) {\n+    return nullptr;        \/\/ incomplete request\n+  }\n+\n+  \/\/ parse request\n+\n+  ArgumentIterator args(buf, (max_len)-left);\n+\n+  \/\/ version already checked\n+  char* v = args.next();\n+\n+  char* name = args.next();\n+  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n+    return nullptr;\n+  }\n+\n+  NixAttachOperation* op = new NixAttachOperation(name);\n+\n+  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n+    char* arg = args.next();\n+    if (arg == nullptr) {\n+      op->set_arg(i, nullptr);\n+    } else {\n+      if (strlen(arg) > AttachOperation::arg_length_max) {\n+        delete op;\n+        return nullptr;\n+      }\n+      op->set_arg(i, arg);\n+    }\n+  }\n+\n+  op->set_socket(s);\n+  return op;\n+}\n+\n+\/\/ Dequeue an operation\n+\/\/\n+\/\/ In the Linux and BSD implementations, there is only a single operation and\n+\/\/ clients cannot queue commands (except at the socket level).\n+\/\/\n+NixAttachOperation* NixAttachListener::dequeue() {\n+  for (;;) {\n+    int s;\n+\n+    \/\/ wait for client to connect\n+    struct sockaddr addr;\n+    socklen_t len = sizeof(addr);\n+    RESTARTABLE(::accept(listener(), &addr, &len), s);\n+    if (s == -1) {\n+      return nullptr;      \/\/ log a warning?\n+    }\n+\n+    \/\/ get the credentials of the peer and check the effective uid\/guid\n+#ifdef LINUX\n+    struct ucred cred_info;\n+    socklen_t optlen = sizeof(cred_info);\n+    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void *)&cred_info, &optlen) ==\n+        -1) {\n+      log_debug(attach)(\"Failed to get socket option SO_PEERCRED\");\n+      ::close(s);\n+      continue;\n+    }\n+\n+    if (!os::Posix::matches_effective_uid_and_gid_or_root(cred_info.uid,\n+                                                          cred_info.gid)) {\n+      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\",\n+                        cred_info.uid, cred_info.gid, geteuid(), getegid());\n+      ::close(s);\n+      continue;\n+    }\n+#endif\n+#ifdef BSD\n+    uid_t puid;\n+    gid_t pgid;\n+    if (::getpeereid(s, &puid, &pgid) != 0) {\n+      log_debug(attach)(\"Failed to get peer id\");\n+      ::close(s);\n+      continue;\n+    }\n+\n+    if (!os::Posix::matches_effective_uid_and_gid_or_root(puid, pgid)) {\n+      log_debug(attach)(\"euid\/egid check failed (%d\/%d vs %d\/%d)\", puid, pgid,\n+                        geteuid(), getegid());\n+      ::close(s);\n+      continue;\n+    }\n+#endif\n+\n+    \/\/ peer credential look okay so we read the request\n+    NixAttachOperation* op = read_request(s);\n+    if (op == nullptr) {\n+      ::close(s);\n+      continue;\n+    } else {\n+      return op;\n+    }\n+  }\n+}\n+\n+\/\/ write the given buffer to the socket\n+int NixAttachListener::write_fully(int s, char* buf, size_t len) {\n+  do {\n+    ssize_t n = ::write(s, buf, len);\n+    if (n == -1) {\n+      if (errno != EINTR) return -1;\n+    } else {\n+      buf += n;\n+      len -= n;\n+    }\n+  }\n+  while (len > 0);\n+  return 0;\n+}\n+\n+\/\/ Complete an operation by sending the operation result and any result\n+\/\/ output to the client. At this time the socket is in blocking mode so\n+\/\/ potentially we can block if there is a lot of data and the client is\n+\/\/ non-responsive. For most operations this is a non-issue because the\n+\/\/ default send buffer is sufficient to buffer everything. In the future\n+\/\/ if there are operations that involves a very big reply then it the\n+\/\/ socket could be made non-blocking and a timeout could be used.\n+\n+void NixAttachOperation::complete(jint result, bufferedStream* st) {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  \/\/ write operation result\n+  char msg[32];\n+  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n+  int rc = NixAttachListener::write_fully(this->socket(), msg, strlen(msg));\n+\n+  \/\/ write any result data\n+  if (rc == 0) {\n+    NixAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n+    ::shutdown(this->socket(), 2);\n+  }\n+\n+  \/\/ done\n+  ::close(this->socket());\n+\n+  delete this;\n+}\n+\n+\n+\/\/ AttachListener functions\n+\n+AttachOperation* AttachListener::dequeue() {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  AttachOperation* op = NixAttachListener::dequeue();\n+\n+  return op;\n+}\n+\n+\/\/ Performs initialization at vm startup\n+\/\/ For Linux and BSD we remove any stale .java_pid file which could cause\n+\/\/ an attaching process to think we are ready to receive on the\n+\/\/ domain socket before we are properly initialized\n+\n+void AttachListener::vm_start() {\n+  char fn[UNIX_PATH_MAX];\n+  struct stat st;\n+  int ret;\n+\n+  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+           os::get_temp_directory(), os::current_process_id());\n+  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+\n+  RESTARTABLE(::stat(fn, &st), ret);\n+  if (ret == 0) {\n+    ret = ::unlink(fn);\n+    if (ret == -1) {\n+      log_debug(attach)(\"Failed to remove stale attach pid file at %s\", fn);\n+    }\n+  }\n+}\n+\n+int AttachListener::pd_init() {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(thread);\n+\n+  int ret_code = NixAttachListener::init();\n+\n+  return ret_code;\n+}\n+\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat st;\n+  ret = stat(NixAttachListener::path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n+                      NixAttachListener::path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+    {\n+      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      while (AttachListener::transit_state(AL_INITIALIZING,\n+                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+        os::naked_yield();\n+      }\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n+\/\/ Attach Listener is started lazily except in the case when\n+\/\/ +ReduseSignalUsage is used\n+bool AttachListener::init_at_startup() {\n+  if (ReduceSignalUsage) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ If the file .attach_pid<pid> exists in the working directory\n+\/\/ or \/tmp then this is the trigger to start the attach mechanism\n+bool AttachListener::is_init_trigger() {\n+  if (init_at_startup() || is_initialized()) {\n+    return false;               \/\/ initialized at startup or already initialized\n+  }\n+  char fn[PATH_MAX + 1];\n+  int ret;\n+  struct stat st;\n+  os::snprintf_checked(fn, sizeof(fn), \".attach_pid%d\",\n+                       os::current_process_id());\n+  RESTARTABLE(::stat(fn, &st), ret);\n+  if (ret == -1) {\n+    log_trace(attach)(\"Failed to find attach file: %s, trying alternate\", fn);\n+    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n+             os::current_process_id());\n+    RESTARTABLE(::stat(fn, &st), ret);\n+    if (ret == -1) {\n+      log_debug(attach)(\"Failed to find attach file: %s\", fn);\n+    }\n+  }\n+  if (ret == 0) {\n+    \/\/ simple check to avoid starting the attach mechanism when\n+    \/\/ a bogus non-root user creates the file\n+    if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {\n+      init();\n+      log_trace(attach)(\"Attach triggered by %s\", fn);\n+      return true;\n+    } else {\n+      log_debug(attach)(\"File %s has wrong user id %d (vs %d). Attach is not triggered\", fn, st.st_uid, geteuid());\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ if VM aborts then remove listener\n+void AttachListener::abort() {\n+  listener_cleanup();\n+}\n+\n+void AttachListener::pd_data_dump() {\n+  os::signal_notify(SIGQUIT);\n+}\n+\n+void AttachListener::pd_detachall() {\n+  \/\/ do nothing for now\n+}\n+\n+#endif \/\/ !AIX\n+\n+#endif \/\/ INCLUDE_SERVICES\n","filename":"src\/hotspot\/os\/posix\/attachListener_nix.cpp","additions":585,"deletions":0,"binary":false,"changes":585,"status":"added"}]}