{"files":[{"patch":"@@ -398,7 +398,5 @@\n-                        for (;;) {\n-                            try {\n-                                result = current.get();\n-                                break;\n-                            } catch (InterruptedException ie) {\n-                                interrupted = true; \/\/ ignore for now, and restore later\n-                            }\n+                        try {\n+                            result = current.get();\n+                        } catch (InterruptedException ie) {\n+                            \/\/ Same behavior as parallel streams: wrap and rethrow\n+                            throw new RuntimeException(ie);\n@@ -433,1 +431,2 @@\n-                                    interrupted = true; \/\/ ignore, for now, and restore later\n+                                    \/\/ We ignore interrupts here because we cannot proceed\n+                                    \/\/ until all spawned threads have exited\n@@ -438,5 +437,0 @@\n-\n-                    \/\/ integrate(..) could be called from different threads each time\n-                    \/\/ so we need to restore the interrupt on the calling thread\n-                    if (interrupted)\n-                        Thread.currentThread().interrupt();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherers.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -27,0 +29,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -321,8 +324,4 @@\n-    @MethodSource(\"concurrencyConfigurations\")\n-    public void ignoresAndRestoresCallingThreadInterruption(ConcurrencyConfig cc) {\n-        final var limitTo = Math.max(cc.config().streamSize() \/ 2, 1);\n-\n-        final var expectedResult = cc.config().stream()\n-            .map(x -> x * x)\n-            .limit(limitTo)\n-            .toList();\n+    @MethodSource(\"small_atleast3_configurations\")\n+    public void abortsAndCleansUpOnCallingThreadInterruption(Config c) {\n+        \/\/ To keep track of virtual threads started\n+        final var vts = new ConcurrentLinkedQueue<Thread>();\n@@ -331,1 +330,1 @@\n-        Thread.currentThread().interrupt();\n+        final var currentThread = Thread.currentThread();\n@@ -333,7 +332,18 @@\n-        final var result = cc.config().stream()\n-            .gather(Gatherers.mapConcurrent(cc.concurrencyLevel(), x -> {\n-                LockSupport.parkNanos(10000); \/\/ 10 us\n-                return x * x;\n-            }))\n-            .limit(limitTo)\n-            .toList();\n+        \/\/ Assert we get an InterruptedException wrapped in a RuntimeException\n+        var exception =\n+            assertThrows(\n+                InterruptedException.class,\n+                () -> {\n+                    throw assertThrows(\n+                        RuntimeException.class,\n+                        () -> c.stream()\n+                            .gather(Gatherers.mapConcurrent(c.streamSize() \/ 2, x -> {\n+                                vts.offer(Thread.currentThread()); \/\/ Remember these for later\n+                                currentThread.interrupt(); \/\/ Make sure caller gets interrupted\n+                                LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(5));\n+                                return x * x;\n+                            }))\n+                            .toList()\n+                    ).getCause();\n+                }\n+            );\n@@ -341,2 +351,2 @@\n-        \/\/ Ensure calling thread remains interrupted\n-        assertEquals(true, Thread.interrupted());\n+        \/\/ Ensure calling thread interruption is cleared\n+        assertEquals(false, Thread.interrupted());\n@@ -344,1 +354,6 @@\n-        assertEquals(expectedResult, result);\n+        \/\/ Make sure we had at least one task thread\n+        assertNotEquals(null, vts.peek());\n+\n+        \/\/ Ensure all task threads were shut down\n+        for(Thread t = vts.poll();t != null; t = vts.poll())\n+            assertEquals(false, t.isAlive());\n","filename":"test\/jdk\/java\/util\/stream\/GatherersMapConcurrentTest.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"}]}