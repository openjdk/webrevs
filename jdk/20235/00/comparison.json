{"files":[{"patch":"@@ -634,0 +634,129 @@\n+\/\/ Generate stub for ghash process  blocks.\n+\/\/\n+\/\/ Arguments for generated stub:\n+\/\/      state:  R3_ARG1\n+\/\/      subkeyH:    R4_ARG2\n+\/\/      data: R5_ARG3\n+\/\/\n+address generate_ghash_processBlocks() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"ghash\");\n+  address start = __ function_entry();\n+\n+  \/\/ Registers for parameters\n+  Register state = R3_ARG1;                     \/\/ long[] state\n+  Register subkeyH = R4_ARG2;                   \/\/ long[] subH\n+  Register data = R5_ARG3;                      \/\/ byte[] data\n+  Register blocks = R6_ARG4;\n+  Register temp1 = R8;\n+  Register temp2 = R9;\n+  Register temp3 = R10;\n+  Register temp4 = R11;\n+  Register align = data;\n+  \/\/ Vector Registers\n+  VectorRegister vH = VR0;\n+  VectorSRegister vHS = VSR32;\n+  VectorRegister vX = VR1;\n+  VectorRegister vH_shift = VR2;\n+  VectorRegister vTmp1 = VR3;\n+  VectorRegister vTmp2 = VR4;\n+  VectorRegister vSwappedH = VR5;\n+  VectorRegister vTmp4 = VR6;\n+  VectorRegister loadOrder = VR7;\n+  VectorRegister vMSB = VR8;\n+  VectorRegister vLowerH = VR9;\n+  VectorRegister vHigherH = VR10;\n+  VectorRegister vZero = VR11;\n+  VectorRegister vConst1 = VR12;\n+  VectorRegister vConst7 = VR13;\n+  VectorRegister vConstC2 = VR14;\n+  VectorRegister vTmp3 = VR16;\n+  VectorRegister vTmp5 = VR17;\n+  VectorRegister vTmp6 = VR18;\n+  VectorRegister vTmp7 = VR19;\n+  VectorRegister vHigh = VR20;\n+  VectorRegister vLow = VR21;\n+  VectorRegister vPerm = VR22;\n+  VectorRegister vZero_Stored = VR23;\n+  VectorSRegister vZero_StoredS = VSR55;\n+  VectorRegister vMask = VR24;\n+  VectorRegister vS = VR25;\n+  VectorSRegister vXS = VSR33;\n+  Label L_end, L_aligned;\n+\n+  static const unsigned char perm_pattern[16] __attribute__((aligned(16))) = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+\n+  __ li(temp1, 0xc2);\n+  __ sldi(temp1, temp1, 56);\n+  \/\/ Load the vector from memory into vConstC2\n+  __ vxor(vConstC2, vConstC2, vConstC2);\n+  __ mtvrd(vConstC2, temp1);\n+  __ vxor(vZero, vZero, vZero);\n+  __ lxvd2x(vHS, subkeyH);\n+  __ lxvd2x(vZero_StoredS, state);\n+  \/\/ Operations to obtain lower and higher bytes of subkey H.\n+  __ vspltisb(vConst1, 1);\n+  __ vspltisb(vConst7, 7);\n+  __ vsldoi(vTmp4, vZero, vConst1, 1);          \/\/ 0x1\n+  __ vor(vTmp4, vConstC2, vTmp4);               \/\/ 0xC2...1\n+  __ vsplt(vMSB, 0, vH);                        \/\/ MSB of H\n+  __ vxor(vH_shift, vH_shift, vH_shift);\n+  __ vsl(vH_shift, vH, vConst1);                \/\/ Carry = H<<7\n+  __ vsrab(vMSB, vMSB, vConst7);\n+  __ vand(vMSB, vMSB, vTmp4);                   \/\/ Carry\n+  __ vxor(vTmp2, vH_shift, vMSB);\n+  __ vsldoi(vConstC2, vZero, vConstC2, 8);\n+  __ vsldoi(vSwappedH, vTmp2, vTmp2, 8);        \/\/ swap Lower and Higher Halves of subkey H\n+  __ vsldoi(vLowerH, vZero, vSwappedH, 8);      \/\/ H.L\n+  __ vsldoi(vHigherH, vSwappedH, vZero, 8);     \/\/ H.H\n+  __ vxor(vTmp1, vTmp1, vTmp1);\n+  __ vxor(vZero, vZero, vZero);\n+  __ mtctr(blocks);\n+  __ li(temp1, 0);\n+  __ load_const_optimized(temp2, (uintptr_t)&perm_pattern);\n+  __ lvx(loadOrder, temp2);\n+  \/\/ Performing Karatsuba multiplication in Galois fields\n+  Label loop;\n+  __ bind(loop);\n+    \/\/ Load immediate value 0 into temp\n+    __ vxor(vZero, vZero, vZero);\n+    __ li(temp1, 0);\n+    __ andi(temp1, data, 15);\n+    __ cmpwi(CCR0, temp1, 0);\n+    __ beq(CCR0, L_aligned);                      \/\/ Check if address is aligned (mask lower 4 bits)\n+    __ li(temp1, 0);\n+    __ lvx(vHigh, temp1, data);\n+    __ lvsl(vPerm, temp1, data);\n+    __ addi(data, data, 16);\n+    __ lvx(vLow, temp1, data);\n+    __ vec_perm(vX, vHigh, vLow, vPerm);\n+    __ subi(data, data, 16);\n+    __ b(L_end);\n+    __ bind(L_aligned);\n+    __ li(temp1, 0);\n+    __ lvx(vX, temp1, data);\n+    __ bind(L_end);\n+    __ vec_perm(vX, vX, vX, loadOrder);\n+    __ vxor(vX, vX, vZero_Stored);\n+      \/\/ Perform GCM multiplication\n+    __ vpmsumd(vTmp1, vLowerH, vX);             \/\/ L : Lower Half of subkey H\n+    __ vpmsumd(vTmp2, vSwappedH, vX);           \/\/ M : Combined halves of subkey H\n+    __ vpmsumd(vTmp3, vHigherH, vX);            \/\/ H :  Higher Half of subkeyH\n+    __ vpmsumd(vTmp4, vTmp1, vConstC2);         \/\/ reduction\n+    __ vsldoi(vTmp5, vTmp2, vZero, 8);          \/\/ mL : Extract the lower 64 bits of M\n+    __ vsldoi(vTmp6, vZero, vTmp2, 8);          \/\/ mH : Extract the higher 64 bits of M\n+    __ vxor(vTmp1, vTmp1, vTmp5);               \/\/ LL + LL : Combine L and mL (partial result for lower half)\n+    __ vxor(vTmp3, vTmp3, vTmp6);               \/\/ HH + HH : Combine H and mH (partial result for upper half)\n+    __ vsldoi(vTmp1, vTmp1, vTmp1, 8);          \/\/ swap\n+    __ vxor(vTmp1, vTmp1, vTmp4);               \/\/ reduction using  the reduction constant\n+    __ vsldoi(vTmp7, vTmp1, vTmp1, 8);          \/\/ swap\n+    __ vpmsumd(vTmp1, vTmp1, vConstC2);         \/\/ reduction using the reduction constant\n+    __ vxor(vTmp7, vTmp7, vTmp3);               \/\/ Combine the reduced Low and High products\n+    __ vxor(vZero, vTmp1, vTmp7);\n+    __ vmr(vZero_Stored, vZero);\n+    __ addi(data, data, 16);\n+    __ bdnz(loop);\n+  __ stxvd2x(vZero->to_vsr(), state);\n+  __ blr();                                     \/\/ Return from function\n+\n+  return start;\n+}\n@@ -4772,0 +4901,3 @@\n+    if (UseGHASHIntrinsics) {\n+      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -309,3 +309,2 @@\n-  if (UseGHASHIntrinsics) {\n-    warning(\"GHASH intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {\n+    FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}