{"files":[{"patch":"@@ -1552,1 +1552,1 @@\n-             * build a list of them to pass to as the exclude list.\n+             * build a list of them to pass as the exclude list.\n@@ -2120,1 +2120,1 @@\n-doPendingTasks(JNIEnv *env, ThreadNode *node)\n+doPendingTasks(JNIEnv *env, jthread thread, int pendingInterrupt, jobject pendingStop)\n@@ -2123,2 +2123,1 @@\n-     * Take care of any pending interrupts\/stops, and clear out\n-     * info on pending interrupts\/stops.\n+     * Take care of any pending interrupts\/stops.\n@@ -2126,1 +2125,1 @@\n-    if (node->pendingInterrupt) {\n+    if (pendingInterrupt) {\n@@ -2128,1 +2127,1 @@\n-                        (gdata->jvmti, node->thread);\n+                        (gdata->jvmti, thread);\n@@ -2132,1 +2131,0 @@\n-        node->pendingInterrupt = JNI_FALSE;\n@@ -2135,1 +2133,1 @@\n-    if (node->pendingStop != NULL) {\n+    if (pendingStop != NULL) {\n@@ -2137,1 +2135,1 @@\n-                        (gdata->jvmti, node->thread, node->pendingStop);\n+                        (gdata->jvmti, thread, pendingStop);\n@@ -2141,1 +2139,0 @@\n-        tossGlobalRef(env, &(node->pendingStop));\n@@ -2150,0 +2147,1 @@\n+    JNIEnv *env = getEnv();\n@@ -2154,19 +2152,5 @@\n-        eventHandler_lock(); \/* for proper lock order *\/\n-    }\n-    debugMonitorEnter(threadLock);\n-\n-    node = findRunningThread(thread);\n-    if (node == NULL) {\n-        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,\"thread list corrupted\");\n-    } else {\n-        JNIEnv *env;\n-\n-        env = getEnv();\n-        if (ei == EI_THREAD_END) {\n-            removeThread(env, node);\n-            node = NULL;   \/* has been freed *\/\n-        } else {\n-            \/* No point in doing this if the thread is about to die.*\/\n-            doPendingTasks(env, node);\n-            node->eventBag = eventBag;\n-            node->current_ei = 0;\n+        eventHandler_lock(); \/* for proper lock order - see removeThread() call below *\/\n+        debugMonitorEnter(threadLock);\n+        node = findRunningThread(thread);\n+        if (node == NULL) {\n+           EXIT_ERROR(AGENT_ERROR_NULL_POINTER,\"thread list corrupted\");\n@@ -2174,4 +2158,3 @@\n-    }\n-\n-    debugMonitorExit(threadLock);\n-    if (ei == EI_THREAD_END) {\n+        removeThread(env, node); \/\/ Grabs handlerLock, thus the reason for first grabbing it above.\n+        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n+        debugMonitorExit(threadLock);\n@@ -2179,0 +2162,23 @@\n+    } else {\n+        debugMonitorEnter(threadLock);\n+        node = findRunningThread(thread);\n+        if (node == NULL) {\n+            EXIT_ERROR(AGENT_ERROR_NULL_POINTER,\"thread list corrupted\");\n+        }\n+        \/* No need to do the following if the thread is about to die.*\/\n+        int pendingInterrupt = node->pendingInterrupt;\n+        jobject pendingStop = node->pendingStop;\n+        jthread thread = node->thread;\n+        node->pendingInterrupt = JNI_FALSE;\n+        node->pendingStop = NULL;\n+        node->eventBag = eventBag;\n+        node->current_ei = 0;\n+        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n+        \/\/ doPendingTasks() may do an upcall to java, and we don't want to hold any\n+        \/\/ locks when doing that. Thus we got all our node updates done first\n+        \/\/ and can now exit the threadLock.\n+        debugMonitorExit(threadLock);\n+        doPendingTasks(env, thread, pendingInterrupt, pendingStop);\n+        if (pendingStop != NULL) {\n+          tossGlobalRef(env, &pendingStop);\n+        }\n@@ -2222,5 +2228,0 @@\n-    ThreadNode *node;\n-    jvmtiError  error;\n-\n-    error = JVMTI_ERROR_NONE;\n-\n@@ -2229,16 +2230,1 @@\n-    debugMonitorEnter(threadLock);\n-\n-    node = findThread(&runningThreads, thread);\n-    if ((node == NULL) || !HANDLING_EVENT(node)) {\n-        error = JVMTI_FUNC_PTR(gdata->jvmti,InterruptThread)\n-                        (gdata->jvmti, thread);\n-    } else {\n-        \/*\n-         * Hold any interrupts until after the event is processed.\n-         *\/\n-        node->pendingInterrupt = JNI_TRUE;\n-    }\n-\n-    debugMonitorExit(threadLock);\n-\n-    return error;\n+    return JVMTI_FUNC_PTR(gdata->jvmti,InterruptThread)(gdata->jvmti, thread);\n@@ -2311,0 +2297,4 @@\n+\/*\n+ * Support for getting an interrupt in an application thread while doing\n+ * a debugMonitorWait().\n+ *\/\n@@ -2316,9 +2306,0 @@\n-    \/*\n-     * vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java seems to be the only code\n-     * that triggers this function. Is uses ThreadReference.Stop.\n-     *\n-     * Since ThreadReference.Stop is not supported for vthreads, we should never\n-     * get here with a vthread.\n-     *\/\n-    JDI_ASSERT(!isVThread(thread));\n-\n@@ -2327,4 +2308,3 @@\n-    node = findThread(&runningThreads, thread);\n-    if (node != NULL) {\n-        node->pendingInterrupt = JNI_TRUE;\n-    }\n+    node = findRunningThread(thread);\n+    JDI_ASSERT(node != NULL);\n+    node->pendingInterrupt = JNI_TRUE;\n@@ -2515,2 +2495,1 @@\n- * Returns the current thread, if the thread has generated at least\n- * one event, and has not generated a thread end event.\n+ * Returns the current thread.\n@@ -2521,11 +2500,2 @@\n-    jthread thread;\n-\n-    debugMonitorEnter(threadLock);\n-    {\n-        ThreadNode *node;\n-\n-        node = findThread(&runningThreads, NULL);\n-        thread = (node == NULL) ? NULL : node->thread;\n-    }\n-    debugMonitorExit(threadLock);\n-\n+    jthread thread = NULL;\n+    jvmtiError error = JVMTI_FUNC_PTR(gdata->jvmti,GetCurrentThread)(gdata->jvmti, &thread);\n@@ -2673,0 +2643,1 @@\n+    tty_message(\"\\tpendingInterrupt: %d\", node->pendingInterrupt);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":51,"deletions":80,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-java\/lang\/invoke\/MethodHandles\/CatchExceptionTest.java 8146623 generic-all\n+java\/lang\/invoke\/MethodHandles\/CatchExceptionTest.java          8146623 generic-all\n@@ -32,0 +32,1 @@\n+com\/sun\/jdi\/InterruptHangTest.java                              8306679,8043571 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @summary Debuggee is blocked,  looks like running\n+ * @summary Test interrupting debuggee with single stepping enable\n@@ -36,1 +36,3 @@\n- * @run driver InterruptHangTest\n+ * @run driver InterruptHangTest precise\n+ * @run driver InterruptHangTest aggressive\n+ * @run driver InterruptHangTest remote\n@@ -40,4 +42,20 @@\n- * Debuggee has two threads.  Debugger keeps stepping in\n- * the first thread.  The second thread keeps interrupting the first\n- * thread.  If a long time goes by with the debugger not getting\n- * a step event, the test fails.\n+ * The debuggee loops in the main thread while the debugger has single stepping\n+ * enabled for the debuggee's main thread. The main thread is repeatedly\n+ * interrupted while it is looping. If a long time goes by with the debugger\n+ * not getting a single step event, the test fails.\n+ *\n+ * Interrupts are generated in 3 difference modes:\n+ *   precise - The debuggee creates a 2nd thread that repeatedly calls\n+ *       Thread.interrupt() on the main thread, but does so in a controlled\n+ *       fashion that allows to test to verify that every interrupt is\n+ *       received and handled.\n+ *   aggressive - The debuggee creates a 2nd thread that repeatedly calls\n+ *       Thread.interrupt() on the main thread, but does so at a high pace\n+ *       and without any coordination with the main thread. Because of\n+ *       this it is not possible to account for all the interrupts since some\n+ *       might be done before the previous interrupt is handled.\n+ *   remote - Much like the \"aggressive\" mode, except interrupts are remotely\n+ *       generated by the debugger using ThreadReference.interrupt(). There\n+ *       is no \"precise\" mode for remotely generated interrupts since it is\n+ *       difficult to coordinate between the debugger and debuggee in a\n+ *       reasonable way.\n@@ -45,0 +63,1 @@\n+\n@@ -46,1 +65,8 @@\n-    public static String sync = \"sync\";\n+    static String sync = \"sync\";\n+    static int interruptsSent;\n+    static boolean remoteMode;\n+    static boolean preciseMode;\n+    static boolean aggressiveMode;\n+\n+    private final static int INTERRUPTS_EXPECTED = 200;\n+\n@@ -48,1 +74,2 @@\n-        int answer = 0;\n+        int answer = 0; \/\/ number of interrupts answered\n+\n@@ -50,1 +77,0 @@\n-        Thread interruptorThread = DebuggeeWrapper.newThread(new Interruptor(Thread.currentThread()));\n@@ -52,1 +78,13 @@\n-        synchronized(sync) {\n+        remoteMode = \"remote\".equals(args[0]);\n+        preciseMode = \"precise\".equals(args[0]);\n+        aggressiveMode = \"aggressive\".equals(args[0]);\n+\n+        if (!remoteMode && !preciseMode && !aggressiveMode) {\n+            throw new RuntimeException(\"Invalid first arg for debuggee: \" + args[0]);\n+        }\n+\n+        \/\/ Create the debuggee interruptor thread if needed.\n+        Thread interruptorThread;\n+        if (preciseMode) {\n+            interruptorThread =\n+                DebuggeeWrapper.newThread(new PreciseInterruptor(Thread.currentThread()));\n@@ -54,5 +92,6 @@\n-            try {\n-                sync.wait();\n-            } catch (InterruptedException ee) {\n-                System.out.println(\"Debuggee interruptee: interrupted before starting loop\");\n-            }\n+        } else if (aggressiveMode) {\n+            interruptorThread =\n+                DebuggeeWrapper.newThread(new AggressiveInterruptor(Thread.currentThread()));\n+            interruptorThread.start();\n+        } else {\n+            interruptorThread = null; \/\/ we are in \"remote\" interrupt mode\n@@ -62,2 +101,2 @@\n-        for (int ii = 0; ii < 200; ii++) {\n-            answer++;\n+        for (int ii = 0; ii < INTERRUPTS_EXPECTED; ii++) {\n+            boolean wasInterrupted = false;\n@@ -65,1 +104,1 @@\n-                \/\/ Give other thread a chance to run\n+                \/\/ Give other thread a chance to interrupt\n@@ -68,2 +107,30 @@\n-                System.out.println(\"Debuggee interruptee: interrupted at iteration: \"\n-                                   + ii);\n+                answer++;\n+                wasInterrupted = true;\n+                boolean isInterrupted = Thread.currentThread().isInterrupted();\n+                System.out.println(\"Debuggee interruptee(\" + ii + \"): isInterrupted(\" + isInterrupted + \")\");\n+                if (preciseMode) {\n+                    \/\/ When Thread.sleep() is interrupted, the interrupted status of the thread\n+                    \/\/ should remain cleared (since InterruptedException was thrown), and the\n+                    \/\/ the next interrupt won't come in until after the sync.notify() below.\n+                    \/\/ Note this is not true for the aggressive and remote modes since\n+                    \/\/ interrupts can come in at any time, even while we are handling\n+                    \/\/ an intrrupt.\n+                    if (isInterrupted) {\n+                        throw new RuntimeException(\"Thread should not have interrupted status set.\");\n+                    }\n+                    synchronized(InterruptHangTarg.sync) {\n+                        \/\/ Let the interruptor thread know it can start interrupting again\n+                        sync.notify();\n+                    }\n+                }\n+            }\n+            \/\/ Every Thread.sleep() call should get interrupted\n+            if (!wasInterrupted) {\n+                throw new RuntimeException(\"Thread was never interrupted during sleep: \" + ii);\n+            }\n+        }\n+\n+        if (interruptorThread != null) {\n+            synchronized(InterruptHangTarg.sync) {\n+                \/\/ Kill the interrupter thread\n+                interruptorThread.interrupt();\n@@ -72,2 +139,16 @@\n-        \/\/ Kill the interrupter thread\n-        interruptorThread.interrupt();\n+\n+        \/\/ Print how many times an interrupt was sent. When in remote mode, the RemoteInterruptor\n+        \/\/ is in a different process, so interruptsSent is not updated, therefore we don't\n+        \/\/ print it here. The RemoteInterruptor thread keeps its own count and prints\n+        \/\/ it before it exits.\n+        if (!remoteMode) {\n+            System.out.println(\"interrupts sent: \" + interruptsSent);\n+        }\n+\n+        \/\/ When in precise mode, make sure that every interrupt sent resulted in\n+        \/\/ an InterruptedException. Note the interruptor always ends up sending\n+        \/\/ one extra interrupt at the end.\n+        if (preciseMode && interruptsSent != answer + 1) {\n+            throw new RuntimeException(\"Too many interrupts sent. Sent: \" + interruptsSent +\n+                                       \". Expected to send: \" + answer + 1);\n+        }\n@@ -76,1 +157,0 @@\n-}\n@@ -78,4 +158,19 @@\n-class Interruptor implements Runnable {\n-    Thread interruptee;\n-    Interruptor(Thread interruptee) {\n-        this.interruptee = interruptee;\n+    static class AggressiveInterruptor implements Runnable {\n+        Thread interruptee;\n+        AggressiveInterruptor(Thread interruptee) {\n+            this.interruptee = interruptee;\n+        }\n+\n+        public void run() {\n+            while (true) {\n+                InterruptHangTarg.interruptsSent++;\n+                interruptee.interrupt();\n+                try {\n+                    Thread.sleep(5);\n+                } catch (InterruptedException ee) {\n+                    System.out.println(\"Debuggee Interruptor: finished after \" +\n+                                       InterruptHangTarg.interruptsSent + \" iterrupts\");\n+                    break;\n+                }\n+            }\n+        }\n@@ -84,3 +179,4 @@\n-    public void run() {\n-        synchronized(InterruptHangTarg.sync) {\n-            InterruptHangTarg.sync.notify();\n+    static class PreciseInterruptor implements Runnable {\n+        Thread interruptee;\n+        PreciseInterruptor(Thread interruptee) {\n+            this.interruptee = interruptee;\n@@ -89,10 +185,14 @@\n-        int ii = 0;\n-        while(true) {\n-            ii++;\n-            interruptee.interrupt();\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException ee) {\n-                System.out.println(\"Debuggee Interruptor: finished after \" +\n-                                   ii + \" iterrupts\");\n-                break;\n+        public void run() {\n+            synchronized(InterruptHangTarg.sync) {\n+                while (true) {\n+                    InterruptHangTarg.interruptsSent++;\n+                    interruptee.interrupt();\n+                    try {\n+                        \/\/ Wait until the interruptee has handled the interrupt\n+                        InterruptHangTarg.sync.wait();\n+                    } catch (InterruptedException ee) {\n+                        System.out.println(\"Debuggee Interruptor: finished after \" +\n+                                           InterruptHangTarg.interruptsSent + \" iterrupts\");\n+                        break;\n+                    }\n+                }\n@@ -100,1 +200,0 @@\n-\n@@ -108,0 +207,30 @@\n+    class RemoteInterruptor extends Thread {\n+        static int interruptsSent;\n+        ThreadReference interruptee;\n+\n+        RemoteInterruptor(ThreadReference interruptee) {\n+            this.interruptee = interruptee;\n+        }\n+\n+        public void run() {\n+            try {\n+                while (true) {\n+                    interruptee.interrupt();\n+                    interruptsSent++;\n+                    Thread.sleep(5);\n+                }\n+            } catch (InterruptedException ee) {\n+                println(\"RemoteInterruptor thread: Unexpected Interrupt\");\n+                throw new RuntimeException(ee);\n+            } catch (IllegalThreadStateException | VMDisconnectedException ee) {\n+                println(\"RemoteInterruptor thread: Got expected \" + ee.getClass().getSimpleName()\n+                        + \" after \" + interruptsSent + \" interrupts sent. Exiting.\");\n+            } catch (Throwable ee) {\n+                println(\"RemoteInterruptor thread: Got unexpected exception after \"\n+                        + interruptsSent + \" interrupts sent. Exiting with exception.\");\n+                ee.printStackTrace(System.out);\n+                throw new RuntimeException(ee);\n+            }\n+        }\n+    }\n+\n@@ -112,0 +241,1 @@\n+    static boolean remoteMode;\n@@ -118,0 +248,1 @@\n+        remoteMode = \"remote\".equals(args[0]);\n@@ -177,0 +308,10 @@\n+        Thread remoteInterruptorThread = null;\n+        if (remoteMode) {\n+            \/\/ Create a thread to call ThreadReference.interrupt() on the\n+            \/\/ debuggee main thread.\n+            remoteInterruptorThread = new RemoteInterruptor(mainThread);\n+            remoteInterruptorThread.setName(\"RemoteInterruptor\");\n+            remoteInterruptorThread.setDaemon(true);\n+            remoteInterruptorThread.start();\n+        }\n+\n@@ -180,1 +321,0 @@\n-\n@@ -182,0 +322,3 @@\n+        if (remoteInterruptorThread != null) {\n+            remoteInterruptorThread.join();\n+        }\n@@ -189,1 +332,1 @@\n-            println(\"InterruptHangTest: passed\");\n+            println(\"InterruptHangTest(\"+ args[0] + \"): passed\");\n@@ -191,1 +334,1 @@\n-            throw new Exception(\"InterruptHangTest: failed\");\n+            throw new Exception(\"InterruptHangTest(\"+ args[0] + \"): failed\");\n","filename":"test\/jdk\/com\/sun\/jdi\/InterruptHangTest.java","additions":188,"deletions":45,"binary":false,"changes":233,"status":"modified"}]}