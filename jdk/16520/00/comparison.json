{"files":[{"patch":"@@ -61,1 +61,1 @@\n-#include \"services\/heapDumperCompression.hpp\"\n+#include \"services\/heapDumperWriter.hpp\"\n@@ -70,314 +70,0 @@\n-\/*\n- * HPROF binary format - description copied from:\n- *   src\/share\/demo\/jvmti\/hprof\/hprof_io.c\n- *\n- *\n- *  header    \"JAVA PROFILE 1.0.2\" (0-terminated)\n- *\n- *  u4        size of identifiers. Identifiers are used to represent\n- *            UTF8 strings, objects, stack traces, etc. They usually\n- *            have the same size as host pointers.\n- * u4         high word\n- * u4         low word    number of milliseconds since 0:00 GMT, 1\/1\/70\n- * [record]*  a sequence of records.\n- *\n- *\n- * Record format:\n- *\n- * u1         a TAG denoting the type of the record\n- * u4         number of *microseconds* since the time stamp in the\n- *            header. (wraps around in a little more than an hour)\n- * u4         number of bytes *remaining* in the record. Note that\n- *            this number excludes the tag and the length field itself.\n- * [u1]*      BODY of the record (a sequence of bytes)\n- *\n- *\n- * The following TAGs are supported:\n- *\n- * TAG           BODY       notes\n- *----------------------------------------------------------\n- * HPROF_UTF8               a UTF8-encoded name\n- *\n- *               id         name ID\n- *               [u1]*      UTF8 characters (no trailing zero)\n- *\n- * HPROF_LOAD_CLASS         a newly loaded class\n- *\n- *                u4        class serial number (> 0)\n- *                id        class object ID\n- *                u4        stack trace serial number\n- *                id        class name ID\n- *\n- * HPROF_UNLOAD_CLASS       an unloading class\n- *\n- *                u4        class serial_number\n- *\n- * HPROF_FRAME              a Java stack frame\n- *\n- *                id        stack frame ID\n- *                id        method name ID\n- *                id        method signature ID\n- *                id        source file name ID\n- *                u4        class serial number\n- *                i4        line number. >0: normal\n- *                                       -1: unknown\n- *                                       -2: compiled method\n- *                                       -3: native method\n- *\n- * HPROF_TRACE              a Java stack trace\n- *\n- *               u4         stack trace serial number\n- *               u4         thread serial number\n- *               u4         number of frames\n- *               [id]*      stack frame IDs\n- *\n- *\n- * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC\n- *\n- *               u2         flags 0x0001: incremental vs. complete\n- *                                0x0002: sorted by allocation vs. live\n- *                                0x0004: whether to force a GC\n- *               u4         cutoff ratio\n- *               u4         total live bytes\n- *               u4         total live instances\n- *               u8         total bytes allocated\n- *               u8         total instances allocated\n- *               u4         number of sites that follow\n- *               [u1        is_array: 0:  normal object\n- *                                    2:  object array\n- *                                    4:  boolean array\n- *                                    5:  char array\n- *                                    6:  float array\n- *                                    7:  double array\n- *                                    8:  byte array\n- *                                    9:  short array\n- *                                    10: int array\n- *                                    11: long array\n- *                u4        class serial number (may be zero during startup)\n- *                u4        stack trace serial number\n- *                u4        number of bytes alive\n- *                u4        number of instances alive\n- *                u4        number of bytes allocated\n- *                u4]*      number of instance allocated\n- *\n- * HPROF_START_THREAD       a newly started thread.\n- *\n- *               u4         thread serial number (> 0)\n- *               id         thread object ID\n- *               u4         stack trace serial number\n- *               id         thread name ID\n- *               id         thread group name ID\n- *               id         thread group parent name ID\n- *\n- * HPROF_END_THREAD         a terminating thread.\n- *\n- *               u4         thread serial number\n- *\n- * HPROF_HEAP_SUMMARY       heap summary\n- *\n- *               u4         total live bytes\n- *               u4         total live instances\n- *               u8         total bytes allocated\n- *               u8         total instances allocated\n- *\n- * HPROF_HEAP_DUMP          denote a heap dump\n- *\n- *               [heap dump sub-records]*\n- *\n- *                          There are four kinds of heap dump sub-records:\n- *\n- *               u1         sub-record type\n- *\n- *               HPROF_GC_ROOT_UNKNOWN         unknown root\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_ROOT_THREAD_OBJ      thread object\n- *\n- *                          id         thread object ID  (may be 0 for a\n- *                                     thread newly attached through JNI)\n- *                          u4         thread sequence number\n- *                          u4         stack trace sequence number\n- *\n- *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root\n- *\n- *                          id         object ID\n- *                          id         JNI global ref ID\n- *\n- *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *                          u4         frame # in stack trace (-1 for empty)\n- *\n- *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *                          u4         frame # in stack trace (-1 for empty)\n- *\n- *               HPROF_GC_ROOT_NATIVE_STACK    Native stack\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *\n- *               HPROF_GC_ROOT_STICKY_CLASS    System class\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *\n- *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_CLASS_DUMP           dump of a class object\n- *\n- *                          id         class object ID\n- *                          u4         stack trace serial number\n- *                          id         super class object ID\n- *                          id         class loader object ID\n- *                          id         signers object ID\n- *                          id         protection domain object ID\n- *                          id         reserved\n- *                          id         reserved\n- *\n- *                          u4         instance size (in bytes)\n- *\n- *                          u2         size of constant pool\n- *                          [u2,       constant pool index,\n- *                           ty,       type\n- *                                     2:  object\n- *                                     4:  boolean\n- *                                     5:  char\n- *                                     6:  float\n- *                                     7:  double\n- *                                     8:  byte\n- *                                     9:  short\n- *                                     10: int\n- *                                     11: long\n- *                           vl]*      and value\n- *\n- *                          u2         number of static fields\n- *                          [id,       static field name,\n- *                           ty,       type,\n- *                           vl]*      and value\n- *\n- *                          u2         number of inst. fields (not inc. super)\n- *                          [id,       instance field name,\n- *                           ty]*      type\n- *\n- *               HPROF_GC_INSTANCE_DUMP        dump of a normal object\n- *\n- *                          id         object ID\n- *                          u4         stack trace serial number\n- *                          id         class object ID\n- *                          u4         number of bytes that follow\n- *                          [vl]*      instance field values (class, followed\n- *                                     by super, super's super ...)\n- *\n- *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array\n- *\n- *                          id         array object ID\n- *                          u4         stack trace serial number\n- *                          u4         number of elements\n- *                          id         array class ID\n- *                          [id]*      elements\n- *\n- *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array\n- *\n- *                          id         array object ID\n- *                          u4         stack trace serial number\n- *                          u4         number of elements\n- *                          u1         element type\n- *                                     4:  boolean array\n- *                                     5:  char array\n- *                                     6:  float array\n- *                                     7:  double array\n- *                                     8:  byte array\n- *                                     9:  short array\n- *                                     10: int array\n- *                                     11: long array\n- *                          [u1]*      elements\n- *\n- * HPROF_CPU_SAMPLES        a set of sample traces of running threads\n- *\n- *                u4        total number of samples\n- *                u4        # of traces\n- *               [u4        # of samples\n- *                u4]*      stack trace serial number\n- *\n- * HPROF_CONTROL_SETTINGS   the settings of on\/off switches\n- *\n- *                u4        0x00000001: alloc traces on\/off\n- *                          0x00000002: cpu sampling on\/off\n- *                u2        stack trace depth\n- *\n- *\n- * When the header is \"JAVA PROFILE 1.0.2\" a heap dump can optionally\n- * be generated as a sequence of heap dump segments. This sequence is\n- * terminated by an end record. The additional tags allowed by format\n- * \"JAVA PROFILE 1.0.2\" are:\n- *\n- * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment\n- *\n- *               [heap dump sub-records]*\n- *               The same sub-record types allowed by HPROF_HEAP_DUMP\n- *\n- * HPROF_HEAP_DUMP_END      denotes the end of a heap dump\n- *\n- *\/\n-\n-\n-\/\/ HPROF tags\n-\n-enum hprofTag : u1 {\n-  \/\/ top-level records\n-  HPROF_UTF8                    = 0x01,\n-  HPROF_LOAD_CLASS              = 0x02,\n-  HPROF_UNLOAD_CLASS            = 0x03,\n-  HPROF_FRAME                   = 0x04,\n-  HPROF_TRACE                   = 0x05,\n-  HPROF_ALLOC_SITES             = 0x06,\n-  HPROF_HEAP_SUMMARY            = 0x07,\n-  HPROF_START_THREAD            = 0x0A,\n-  HPROF_END_THREAD              = 0x0B,\n-  HPROF_HEAP_DUMP               = 0x0C,\n-  HPROF_CPU_SAMPLES             = 0x0D,\n-  HPROF_CONTROL_SETTINGS        = 0x0E,\n-\n-  \/\/ 1.0.2 record types\n-  HPROF_HEAP_DUMP_SEGMENT       = 0x1C,\n-  HPROF_HEAP_DUMP_END           = 0x2C,\n-\n-  \/\/ field types\n-  HPROF_ARRAY_OBJECT            = 0x01,\n-  HPROF_NORMAL_OBJECT           = 0x02,\n-  HPROF_BOOLEAN                 = 0x04,\n-  HPROF_CHAR                    = 0x05,\n-  HPROF_FLOAT                   = 0x06,\n-  HPROF_DOUBLE                  = 0x07,\n-  HPROF_BYTE                    = 0x08,\n-  HPROF_SHORT                   = 0x09,\n-  HPROF_INT                     = 0x0A,\n-  HPROF_LONG                    = 0x0B,\n-\n-  \/\/ data-dump sub-records\n-  HPROF_GC_ROOT_UNKNOWN         = 0xFF,\n-  HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,\n-  HPROF_GC_ROOT_JNI_LOCAL       = 0x02,\n-  HPROF_GC_ROOT_JAVA_FRAME      = 0x03,\n-  HPROF_GC_ROOT_NATIVE_STACK    = 0x04,\n-  HPROF_GC_ROOT_STICKY_CLASS    = 0x05,\n-  HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,\n-  HPROF_GC_ROOT_MONITOR_USED    = 0x07,\n-  HPROF_GC_ROOT_THREAD_OBJ      = 0x08,\n-  HPROF_GC_CLASS_DUMP           = 0x20,\n-  HPROF_GC_INSTANCE_DUMP        = 0x21,\n-  HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,\n-  HPROF_GC_PRIM_ARRAY_DUMP      = 0x23\n-};\n-\n@@ -390,335 +76,0 @@\n-\/\/ Supports I\/O operations for a dump\n-\/\/ Base class for dump and parallel dump\n-class AbstractDumpWriter : public CHeapObj<mtInternal> {\n- protected:\n-  enum {\n-    io_buffer_max_size = 1*M,\n-    dump_segment_header_size = 9\n-  };\n-\n-  char* _buffer;    \/\/ internal buffer\n-  size_t _size;\n-  size_t _pos;\n-\n-  bool _in_dump_segment; \/\/ Are we currently in a dump segment?\n-  bool _is_huge_sub_record; \/\/ Are we writing a sub-record larger than the buffer size?\n-  DEBUG_ONLY(size_t _sub_record_left;) \/\/ The bytes not written for the current sub-record.\n-  DEBUG_ONLY(bool _sub_record_ended;) \/\/ True if we have called the end_sub_record().\n-\n-  char* buffer() const                          { return _buffer; }\n-  size_t buffer_size() const                    { return _size; }\n-  void set_position(size_t pos)                 { _pos = pos; }\n-\n-  \/\/ Can be called if we have enough room in the buffer.\n-  void write_fast(const void* s, size_t len);\n-\n-  \/\/ Returns true if we have enough room in the buffer for 'len' bytes.\n-  bool can_write_fast(size_t len);\n-\n-  void write_address(address a);\n-\n- public:\n-  AbstractDumpWriter() :\n-    _buffer(nullptr),\n-    _size(io_buffer_max_size),\n-    _pos(0),\n-    _in_dump_segment(false) { }\n-\n-  \/\/ Total number of bytes written to the disk\n-  virtual julong bytes_written() const = 0;\n-  \/\/ Return non-null if error occurred\n-  virtual char const* error() const = 0;\n-\n-  size_t position() const                       { return _pos; }\n-  \/\/ writer functions\n-  virtual void write_raw(const void* s, size_t len);\n-  void write_u1(u1 x);\n-  void write_u2(u2 x);\n-  void write_u4(u4 x);\n-  void write_u8(u8 x);\n-  void write_objectID(oop o);\n-  void write_rootID(oop* p);\n-  void write_symbolID(Symbol* o);\n-  void write_classID(Klass* k);\n-  void write_id(u4 x);\n-\n-  \/\/ Start a new sub-record. Starts a new heap dump segment if needed.\n-  void start_sub_record(u1 tag, u4 len);\n-  \/\/ Ends the current sub-record.\n-  void end_sub_record();\n-  \/\/ Finishes the current dump segment if not already finished.\n-  void finish_dump_segment();\n-  \/\/ Flush internal buffer to persistent storage\n-  virtual void flush() = 0;\n-};\n-\n-void AbstractDumpWriter::write_fast(const void* s, size_t len) {\n-  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n-  assert(buffer_size() - position() >= len, \"Must fit\");\n-  debug_only(_sub_record_left -= len);\n-  memcpy(buffer() + position(), s, len);\n-  set_position(position() + len);\n-}\n-\n-bool AbstractDumpWriter::can_write_fast(size_t len) {\n-  return buffer_size() - position() >= len;\n-}\n-\n-\/\/ write raw bytes\n-void AbstractDumpWriter::write_raw(const void* s, size_t len) {\n-  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n-  debug_only(_sub_record_left -= len);\n-\n-  \/\/ flush buffer to make room.\n-  while (len > buffer_size() - position()) {\n-    assert(!_in_dump_segment || _is_huge_sub_record,\n-           \"Cannot overflow in non-huge sub-record.\");\n-    size_t to_write = buffer_size() - position();\n-    memcpy(buffer() + position(), s, to_write);\n-    s = (void*) ((char*) s + to_write);\n-    len -= to_write;\n-    set_position(position() + to_write);\n-    flush();\n-  }\n-\n-  memcpy(buffer() + position(), s, len);\n-  set_position(position() + len);\n-}\n-\n-\/\/ Makes sure we inline the fast write into the write_u* functions. This is a big speedup.\n-#define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \\\n-                                      else write_raw((p), (len)); } while (0)\n-\n-void AbstractDumpWriter::write_u1(u1 x) {\n-  WRITE_KNOWN_TYPE(&x, 1);\n-}\n-\n-void AbstractDumpWriter::write_u2(u2 x) {\n-  u2 v;\n-  Bytes::put_Java_u2((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 2);\n-}\n-\n-void AbstractDumpWriter::write_u4(u4 x) {\n-  u4 v;\n-  Bytes::put_Java_u4((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 4);\n-}\n-\n-void AbstractDumpWriter::write_u8(u8 x) {\n-  u8 v;\n-  Bytes::put_Java_u8((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 8);\n-}\n-\n-void AbstractDumpWriter::write_address(address a) {\n-#ifdef _LP64\n-  write_u8((u8)a);\n-#else\n-  write_u4((u4)a);\n-#endif\n-}\n-\n-void AbstractDumpWriter::write_objectID(oop o) {\n-  write_address(cast_from_oop<address>(o));\n-}\n-\n-void AbstractDumpWriter::write_rootID(oop* p) {\n-  write_address((address)p);\n-}\n-\n-void AbstractDumpWriter::write_symbolID(Symbol* s) {\n-  write_address((address)((uintptr_t)s));\n-}\n-\n-void AbstractDumpWriter::write_id(u4 x) {\n-#ifdef _LP64\n-  write_u8((u8) x);\n-#else\n-  write_u4(x);\n-#endif\n-}\n-\n-\/\/ We use java mirror as the class ID\n-void AbstractDumpWriter::write_classID(Klass* k) {\n-  write_objectID(k->java_mirror());\n-}\n-\n-void AbstractDumpWriter::finish_dump_segment() {\n-  if (_in_dump_segment) {\n-    assert(_sub_record_left == 0, \"Last sub-record not written completely\");\n-    assert(_sub_record_ended, \"sub-record must have ended\");\n-\n-    \/\/ Fix up the dump segment length if we haven't written a huge sub-record last\n-    \/\/ (in which case the segment length was already set to the correct value initially).\n-    if (!_is_huge_sub_record) {\n-      assert(position() > dump_segment_header_size, \"Dump segment should have some content\");\n-      Bytes::put_Java_u4((address) (buffer() + 5),\n-                         (u4) (position() - dump_segment_header_size));\n-    } else {\n-      \/\/ Finish process huge sub record\n-      \/\/ Set _is_huge_sub_record to false so the parallel dump writer can flush data to file.\n-      _is_huge_sub_record = false;\n-    }\n-\n-    _in_dump_segment = false;\n-    flush();\n-  }\n-}\n-\n-void AbstractDumpWriter::start_sub_record(u1 tag, u4 len) {\n-  if (!_in_dump_segment) {\n-    if (position() > 0) {\n-      flush();\n-    }\n-\n-    assert(position() == 0 && buffer_size() > dump_segment_header_size, \"Must be at the start\");\n-\n-    write_u1(HPROF_HEAP_DUMP_SEGMENT);\n-    write_u4(0); \/\/ timestamp\n-    \/\/ Will be fixed up later if we add more sub-records.  If this is a huge sub-record,\n-    \/\/ this is already the correct length, since we don't add more sub-records.\n-    write_u4(len);\n-    assert(Bytes::get_Java_u4((address)(buffer() + 5)) == len, \"Inconsistent size!\");\n-    _in_dump_segment = true;\n-    _is_huge_sub_record = len > buffer_size() - dump_segment_header_size;\n-  } else if (_is_huge_sub_record || (len > buffer_size() - position())) {\n-    \/\/ This object will not fit in completely or the last sub-record was huge.\n-    \/\/ Finish the current segment and try again.\n-    finish_dump_segment();\n-    start_sub_record(tag, len);\n-\n-    return;\n-  }\n-\n-  debug_only(_sub_record_left = len);\n-  debug_only(_sub_record_ended = false);\n-\n-  write_u1(tag);\n-}\n-\n-void AbstractDumpWriter::end_sub_record() {\n-  assert(_in_dump_segment, \"must be in dump segment\");\n-  assert(_sub_record_left == 0, \"sub-record not written completely\");\n-  assert(!_sub_record_ended, \"Must not have ended yet\");\n-  debug_only(_sub_record_ended = true);\n-}\n-\n-\/\/ Supports I\/O operations for a dump\n-\n-class DumpWriter : public AbstractDumpWriter {\n-private:\n-  FileWriter* _writer;\n-  AbstractCompressor* _compressor;\n-  size_t _bytes_written;\n-  char* _error;\n-  \/\/ Compression support\n-  char* _out_buffer;\n-  size_t _out_size;\n-  size_t _out_pos;\n-  char* _tmp_buffer;\n-  size_t _tmp_size;\n-\n-private:\n-  void do_compress();\n-\n-public:\n-  DumpWriter(const char* path, bool overwrite, AbstractCompressor* compressor);\n-  ~DumpWriter();\n-  julong bytes_written() const override        { return (julong) _bytes_written; }\n-  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n-  char const* error() const override           { return _error; }\n-  void set_error(const char* error)            { _error = (char*)error; }\n-  bool has_error() const                       { return _error != nullptr; }\n-  const char* get_file_path() const            { return _writer->get_file_path(); }\n-  AbstractCompressor* compressor()             { return _compressor; }\n-  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n-  bool is_overwrite() const                    { return _writer->is_overwrite(); }\n-  int get_fd() const                           { return _writer->get_fd(); }\n-\n-  void flush() override;\n-};\n-\n-DumpWriter::DumpWriter(const char* path, bool overwrite, AbstractCompressor* compressor) :\n-  AbstractDumpWriter(),\n-  _writer(new (std::nothrow) FileWriter(path, overwrite)),\n-  _compressor(compressor),\n-  _bytes_written(0),\n-  _error(nullptr),\n-  _out_buffer(nullptr),\n-  _out_size(0),\n-  _out_pos(0),\n-  _tmp_buffer(nullptr),\n-  _tmp_size(0) {\n-  _error = (char*)_writer->open_writer();\n-  if (_error == nullptr) {\n-    _buffer = (char*)os::malloc(io_buffer_max_size, mtInternal);\n-    if (compressor != nullptr) {\n-      _error = (char*)_compressor->init(io_buffer_max_size, &_out_size, &_tmp_size);\n-      if (_error == nullptr) {\n-        if (_out_size > 0) {\n-          _out_buffer = (char*)os::malloc(_out_size, mtInternal);\n-        }\n-        if (_tmp_size > 0) {\n-          _tmp_buffer = (char*)os::malloc(_tmp_size, mtInternal);\n-        }\n-      }\n-    }\n-  }\n-  \/\/ initialize internal buffer\n-  _pos = 0;\n-  _size = io_buffer_max_size;\n-}\n-\n-DumpWriter::~DumpWriter(){\n-  if (_buffer != nullptr) {\n-    os::free(_buffer);\n-  }\n-  if (_out_buffer != nullptr) {\n-    os::free(_out_buffer);\n-  }\n-  if (_tmp_buffer != nullptr) {\n-    os::free(_tmp_buffer);\n-  }\n-  if (_writer != NULL) {\n-    delete _writer;\n-  }\n-  _bytes_written = -1;\n-}\n-\n-\/\/ flush any buffered bytes to the file\n-void DumpWriter::flush() {\n-  if (_pos <= 0) {\n-    return;\n-  }\n-  if (has_error()) {\n-    _pos = 0;\n-    return;\n-  }\n-  char* result = nullptr;\n-  if (_compressor == nullptr) {\n-    result = (char*)_writer->write_buf(_buffer, _pos);\n-    _bytes_written += _pos;\n-  } else {\n-    do_compress();\n-    if (!has_error()) {\n-      result = (char*)_writer->write_buf(_out_buffer, _out_pos);\n-      _bytes_written += _out_pos;\n-    }\n-  }\n-  _pos = 0; \/\/ reset pos to make internal buffer available\n-\n-  if (result != nullptr) {\n-    set_error(result);\n-  }\n-}\n-\n-void DumpWriter::do_compress() {\n-  const char* msg = _compressor->compress(_buffer, _pos, _out_buffer, _out_size,\n-                                          _tmp_buffer, _tmp_size, &_out_pos);\n-\n-  if (msg != nullptr) {\n-    set_error(msg);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":1,"deletions":650,"binary":false,"changes":651,"status":"modified"},{"patch":"@@ -32,0 +32,314 @@\n+\/*\n+ * HPROF binary format - description copied from:\n+ *   src\/share\/demo\/jvmti\/hprof\/hprof_io.c\n+ *\n+ *\n+ *  header    \"JAVA PROFILE 1.0.2\" (0-terminated)\n+ *\n+ *  u4        size of identifiers. Identifiers are used to represent\n+ *            UTF8 strings, objects, stack traces, etc. They usually\n+ *            have the same size as host pointers.\n+ * u4         high word\n+ * u4         low word    number of milliseconds since 0:00 GMT, 1\/1\/70\n+ * [record]*  a sequence of records.\n+ *\n+ *\n+ * Record format:\n+ *\n+ * u1         a TAG denoting the type of the record\n+ * u4         number of *microseconds* since the time stamp in the\n+ *            header. (wraps around in a little more than an hour)\n+ * u4         number of bytes *remaining* in the record. Note that\n+ *            this number excludes the tag and the length field itself.\n+ * [u1]*      BODY of the record (a sequence of bytes)\n+ *\n+ *\n+ * The following TAGs are supported:\n+ *\n+ * TAG           BODY       notes\n+ *----------------------------------------------------------\n+ * HPROF_UTF8               a UTF8-encoded name\n+ *\n+ *               id         name ID\n+ *               [u1]*      UTF8 characters (no trailing zero)\n+ *\n+ * HPROF_LOAD_CLASS         a newly loaded class\n+ *\n+ *                u4        class serial number (> 0)\n+ *                id        class object ID\n+ *                u4        stack trace serial number\n+ *                id        class name ID\n+ *\n+ * HPROF_UNLOAD_CLASS       an unloading class\n+ *\n+ *                u4        class serial_number\n+ *\n+ * HPROF_FRAME              a Java stack frame\n+ *\n+ *                id        stack frame ID\n+ *                id        method name ID\n+ *                id        method signature ID\n+ *                id        source file name ID\n+ *                u4        class serial number\n+ *                i4        line number. >0: normal\n+ *                                       -1: unknown\n+ *                                       -2: compiled method\n+ *                                       -3: native method\n+ *\n+ * HPROF_TRACE              a Java stack trace\n+ *\n+ *               u4         stack trace serial number\n+ *               u4         thread serial number\n+ *               u4         number of frames\n+ *               [id]*      stack frame IDs\n+ *\n+ *\n+ * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC\n+ *\n+ *               u2         flags 0x0001: incremental vs. complete\n+ *                                0x0002: sorted by allocation vs. live\n+ *                                0x0004: whether to force a GC\n+ *               u4         cutoff ratio\n+ *               u4         total live bytes\n+ *               u4         total live instances\n+ *               u8         total bytes allocated\n+ *               u8         total instances allocated\n+ *               u4         number of sites that follow\n+ *               [u1        is_array: 0:  normal object\n+ *                                    2:  object array\n+ *                                    4:  boolean array\n+ *                                    5:  char array\n+ *                                    6:  float array\n+ *                                    7:  double array\n+ *                                    8:  byte array\n+ *                                    9:  short array\n+ *                                    10: int array\n+ *                                    11: long array\n+ *                u4        class serial number (may be zero during startup)\n+ *                u4        stack trace serial number\n+ *                u4        number of bytes alive\n+ *                u4        number of instances alive\n+ *                u4        number of bytes allocated\n+ *                u4]*      number of instance allocated\n+ *\n+ * HPROF_START_THREAD       a newly started thread.\n+ *\n+ *               u4         thread serial number (> 0)\n+ *               id         thread object ID\n+ *               u4         stack trace serial number\n+ *               id         thread name ID\n+ *               id         thread group name ID\n+ *               id         thread group parent name ID\n+ *\n+ * HPROF_END_THREAD         a terminating thread.\n+ *\n+ *               u4         thread serial number\n+ *\n+ * HPROF_HEAP_SUMMARY       heap summary\n+ *\n+ *               u4         total live bytes\n+ *               u4         total live instances\n+ *               u8         total bytes allocated\n+ *               u8         total instances allocated\n+ *\n+ * HPROF_HEAP_DUMP          denote a heap dump\n+ *\n+ *               [heap dump sub-records]*\n+ *\n+ *                          There are four kinds of heap dump sub-records:\n+ *\n+ *               u1         sub-record type\n+ *\n+ *               HPROF_GC_ROOT_UNKNOWN         unknown root\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_ROOT_THREAD_OBJ      thread object\n+ *\n+ *                          id         thread object ID  (may be 0 for a\n+ *                                     thread newly attached through JNI)\n+ *                          u4         thread sequence number\n+ *                          u4         stack trace sequence number\n+ *\n+ *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root\n+ *\n+ *                          id         object ID\n+ *                          id         JNI global ref ID\n+ *\n+ *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *                          u4         frame # in stack trace (-1 for empty)\n+ *\n+ *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *                          u4         frame # in stack trace (-1 for empty)\n+ *\n+ *               HPROF_GC_ROOT_NATIVE_STACK    Native stack\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *\n+ *               HPROF_GC_ROOT_STICKY_CLASS    System class\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *\n+ *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_CLASS_DUMP           dump of a class object\n+ *\n+ *                          id         class object ID\n+ *                          u4         stack trace serial number\n+ *                          id         super class object ID\n+ *                          id         class loader object ID\n+ *                          id         signers object ID\n+ *                          id         protection domain object ID\n+ *                          id         reserved\n+ *                          id         reserved\n+ *\n+ *                          u4         instance size (in bytes)\n+ *\n+ *                          u2         size of constant pool\n+ *                          [u2,       constant pool index,\n+ *                           ty,       type\n+ *                                     2:  object\n+ *                                     4:  boolean\n+ *                                     5:  char\n+ *                                     6:  float\n+ *                                     7:  double\n+ *                                     8:  byte\n+ *                                     9:  short\n+ *                                     10: int\n+ *                                     11: long\n+ *                           vl]*      and value\n+ *\n+ *                          u2         number of static fields\n+ *                          [id,       static field name,\n+ *                           ty,       type,\n+ *                           vl]*      and value\n+ *\n+ *                          u2         number of inst. fields (not inc. super)\n+ *                          [id,       instance field name,\n+ *                           ty]*      type\n+ *\n+ *               HPROF_GC_INSTANCE_DUMP        dump of a normal object\n+ *\n+ *                          id         object ID\n+ *                          u4         stack trace serial number\n+ *                          id         class object ID\n+ *                          u4         number of bytes that follow\n+ *                          [vl]*      instance field values (class, followed\n+ *                                     by super, super's super ...)\n+ *\n+ *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array\n+ *\n+ *                          id         array object ID\n+ *                          u4         stack trace serial number\n+ *                          u4         number of elements\n+ *                          id         array class ID\n+ *                          [id]*      elements\n+ *\n+ *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array\n+ *\n+ *                          id         array object ID\n+ *                          u4         stack trace serial number\n+ *                          u4         number of elements\n+ *                          u1         element type\n+ *                                     4:  boolean array\n+ *                                     5:  char array\n+ *                                     6:  float array\n+ *                                     7:  double array\n+ *                                     8:  byte array\n+ *                                     9:  short array\n+ *                                     10: int array\n+ *                                     11: long array\n+ *                          [u1]*      elements\n+ *\n+ * HPROF_CPU_SAMPLES        a set of sample traces of running threads\n+ *\n+ *                u4        total number of samples\n+ *                u4        # of traces\n+ *               [u4        # of samples\n+ *                u4]*      stack trace serial number\n+ *\n+ * HPROF_CONTROL_SETTINGS   the settings of on\/off switches\n+ *\n+ *                u4        0x00000001: alloc traces on\/off\n+ *                          0x00000002: cpu sampling on\/off\n+ *                u2        stack trace depth\n+ *\n+ *\n+ * When the header is \"JAVA PROFILE 1.0.2\" a heap dump can optionally\n+ * be generated as a sequence of heap dump segments. This sequence is\n+ * terminated by an end record. The additional tags allowed by format\n+ * \"JAVA PROFILE 1.0.2\" are:\n+ *\n+ * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment\n+ *\n+ *               [heap dump sub-records]*\n+ *               The same sub-record types allowed by HPROF_HEAP_DUMP\n+ *\n+ * HPROF_HEAP_DUMP_END      denotes the end of a heap dump\n+ *\n+ *\/\n+\n+\n+\/\/ HPROF tags\n+\n+enum hprofTag : u1 {\n+  \/\/ top-level records\n+  HPROF_UTF8                    = 0x01,\n+  HPROF_LOAD_CLASS              = 0x02,\n+  HPROF_UNLOAD_CLASS            = 0x03,\n+  HPROF_FRAME                   = 0x04,\n+  HPROF_TRACE                   = 0x05,\n+  HPROF_ALLOC_SITES             = 0x06,\n+  HPROF_HEAP_SUMMARY            = 0x07,\n+  HPROF_START_THREAD            = 0x0A,\n+  HPROF_END_THREAD              = 0x0B,\n+  HPROF_HEAP_DUMP               = 0x0C,\n+  HPROF_CPU_SAMPLES             = 0x0D,\n+  HPROF_CONTROL_SETTINGS        = 0x0E,\n+\n+  \/\/ 1.0.2 record types\n+  HPROF_HEAP_DUMP_SEGMENT       = 0x1C,\n+  HPROF_HEAP_DUMP_END           = 0x2C,\n+\n+  \/\/ field types\n+  HPROF_ARRAY_OBJECT            = 0x01,\n+  HPROF_NORMAL_OBJECT           = 0x02,\n+  HPROF_BOOLEAN                 = 0x04,\n+  HPROF_CHAR                    = 0x05,\n+  HPROF_FLOAT                   = 0x06,\n+  HPROF_DOUBLE                  = 0x07,\n+  HPROF_BYTE                    = 0x08,\n+  HPROF_SHORT                   = 0x09,\n+  HPROF_INT                     = 0x0A,\n+  HPROF_LONG                    = 0x0B,\n+\n+  \/\/ data-dump sub-records\n+  HPROF_GC_ROOT_UNKNOWN         = 0xFF,\n+  HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,\n+  HPROF_GC_ROOT_JNI_LOCAL       = 0x02,\n+  HPROF_GC_ROOT_JAVA_FRAME      = 0x03,\n+  HPROF_GC_ROOT_NATIVE_STACK    = 0x04,\n+  HPROF_GC_ROOT_STICKY_CLASS    = 0x05,\n+  HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,\n+  HPROF_GC_ROOT_MONITOR_USED    = 0x07,\n+  HPROF_GC_ROOT_THREAD_OBJ      = 0x08,\n+  HPROF_GC_CLASS_DUMP           = 0x20,\n+  HPROF_GC_INSTANCE_DUMP        = 0x21,\n+  HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,\n+  HPROF_GC_PRIM_ARRAY_DUMP      = 0x23\n+};\n+\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":314,"deletions":0,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"runtime\/os.hpp\"\n-#include \"services\/heapDumperCompression.hpp\"\n-#include \"utilities\/zipLibrary.hpp\"\n-\n-\n-char const* FileWriter::open_writer() {\n-  assert(_fd < 0, \"Must not already be open\");\n-\n-  _fd = os::create_binary_file(_path, _overwrite);\n-\n-  if (_fd < 0) {\n-    return os::strerror(errno);\n-  }\n-\n-  return nullptr;\n-}\n-\n-FileWriter::~FileWriter() {\n-  if (_fd >= 0) {\n-    ::close(_fd);\n-    _fd = -1;\n-  }\n-}\n-\n-char const* FileWriter::write_buf(char* buf, ssize_t size) {\n-  assert(_fd >= 0, \"Must be open\");\n-  assert(size > 0, \"Must write at least one byte\");\n-\n-  if (!os::write(_fd, buf, (size_t)size)) {\n-    return os::strerror(errno);\n-  }\n-\n-  return nullptr;\n-}\n-\n-char const* GZipCompressor::init(size_t block_size, size_t* needed_out_size,\n-                                 size_t* needed_tmp_size) {\n-  _block_size = block_size;\n-  _is_first = true;\n-  char const* result = ZipLibrary::init_params(block_size, needed_out_size,\n-                                               needed_tmp_size, _level);\n-  *needed_out_size += 1024; \/\/ Add extra space for the comment in the first chunk.\n-  return result;\n-}\n-\n-char const* GZipCompressor::compress(char* in, size_t in_size, char* out, size_t out_size,\n-                                     char* tmp, size_t tmp_size, size_t* compressed_size) {\n-  char const* msg = nullptr;\n-  if (_is_first) {\n-    char buf[128];\n-    \/\/ Write the block size used as a comment in the first gzip chunk, so the\n-    \/\/ code used to read it later can make a good choice of the buffer sizes it uses.\n-    jio_snprintf(buf, sizeof(buf), \"HPROF BLOCKSIZE=\" SIZE_FORMAT, _block_size);\n-    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, buf, &msg);\n-    _is_first = false;\n-  } else {\n-    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, nullptr, &msg);\n-  }\n-\n-  return msg;\n-}\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_HEAPDUMPERCOMPRESSION_HPP\n-#define SHARE_SERVICES_HEAPDUMPERCOMPRESSION_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-\n-\n-\/\/ Interface for a compression  implementation.\n-class AbstractCompressor : public CHeapObj<mtInternal> {\n-public:\n-  virtual ~AbstractCompressor() { }\n-\n-  \/\/ Initializes the compressor. Returns a static error message in case of an error.\n-  \/\/ Otherwise initializes the needed out and tmp size for the given block size.\n-  virtual char const* init(size_t block_size, size_t* needed_out_size,\n-                           size_t* needed_tmp_size) = 0;\n-\n-  \/\/ Does the actual compression. Returns null on success and a static error\n-  \/\/ message otherwise. Sets the 'compressed_size'.\n-  virtual char const* compress(char* in, size_t in_size, char* out, size_t out_size,\n-                               char* tmp, size_t tmp_size, size_t* compressed_size) = 0;\n-};\n-\n-\/\/ Interface for a writer implementation.\n-class AbstractWriter : public CHeapObj<mtInternal> {\n-public:\n-  virtual ~AbstractWriter() { }\n-\n-  \/\/ Opens the writer. Returns null on success and a static error message otherwise.\n-  virtual char const* open_writer() = 0;\n-\n-  \/\/ Does the write. Returns null on success and a static error message otherwise.\n-  virtual char const* write_buf(char* buf, ssize_t size) = 0;\n-};\n-\n-\n-\/\/ A writer for a file.\n-class FileWriter : public AbstractWriter {\n-private:\n-  char const* _path;\n-  bool _overwrite;\n-  int _fd;\n-\n-public:\n-  FileWriter(char const* path, bool overwrite) : _path(path), _overwrite(overwrite), _fd(-1) { }\n-\n-  ~FileWriter();\n-\n-  \/\/ Opens the writer. Returns null on success and a static error message otherwise.\n-  virtual char const* open_writer();\n-\n-  \/\/ Does the write. Returns null on success and a static error message otherwise.\n-  virtual char const* write_buf(char* buf, ssize_t size);\n-\n-  const char* get_file_path() { return _path; }\n-\n-  bool is_overwrite() const { return _overwrite; }\n-\n-  int get_fd() const {return _fd; }\n-};\n-\n-\n-\/\/ A compressor using the gzip format.\n-class GZipCompressor : public AbstractCompressor {\n-private:\n-  int _level;\n-  size_t _block_size;\n-  bool _is_first;\n-\n-public:\n-  GZipCompressor(int level) : _level(level), _block_size(0), _is_first(false) {\n-  }\n-\n-  virtual char const* init(size_t block_size, size_t* needed_out_size,\n-                           size_t* needed_tmp_size);\n-\n-  virtual char const* compress(char* in, size_t in_size, char* out, size_t out_size,\n-                               char* tmp, size_t tmp_size, size_t* compressed_size);\n-};\n-\n-#endif \/\/ SHARE_SERVICES_HEAPDUMPERCOMPRESSION_HPP\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.hpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/heapDumperWriter.hpp\"\n+#include \"utilities\/zipLibrary.hpp\"\n+\n+\n+char const* FileWriter::open_writer() {\n+  assert(_fd < 0, \"Must not already be open\");\n+\n+  _fd = os::create_binary_file(_path, _overwrite);\n+\n+  if (_fd < 0) {\n+    return os::strerror(errno);\n+  }\n+\n+  return nullptr;\n+}\n+\n+FileWriter::~FileWriter() {\n+  if (_fd >= 0) {\n+    ::close(_fd);\n+    _fd = -1;\n+  }\n+}\n+\n+char const* FileWriter::write_buf(char* buf, ssize_t size) {\n+  assert(_fd >= 0, \"Must be open\");\n+  assert(size > 0, \"Must write at least one byte\");\n+\n+  if (!os::write(_fd, buf, (size_t)size)) {\n+    return os::strerror(errno);\n+  }\n+\n+  return nullptr;\n+}\n+\n+char const* GZipCompressor::init(size_t block_size, size_t* needed_out_size,\n+                                 size_t* needed_tmp_size) {\n+  _block_size = block_size;\n+  _is_first = true;\n+  char const* result = ZipLibrary::init_params(block_size, needed_out_size,\n+                                               needed_tmp_size, _level);\n+  *needed_out_size += 1024; \/\/ Add extra space for the comment in the first chunk.\n+  return result;\n+}\n+\n+char const* GZipCompressor::compress(char* in, size_t in_size, char* out, size_t out_size,\n+                                     char* tmp, size_t tmp_size, size_t* compressed_size) {\n+  char const* msg = nullptr;\n+  if (_is_first) {\n+    char buf[128];\n+    \/\/ Write the block size used as a comment in the first gzip chunk, so the\n+    \/\/ code used to read it later can make a good choice of the buffer sizes it uses.\n+    jio_snprintf(buf, sizeof(buf), \"HPROF BLOCKSIZE=\" SIZE_FORMAT, _block_size);\n+    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, buf, &msg);\n+    _is_first = false;\n+  } else {\n+    *compressed_size = ZipLibrary::compress(in, in_size, out, out_size, tmp, tmp_size, _level, nullptr, &msg);\n+  }\n+\n+  return msg;\n+}\n+\n+\/\/ Abstract heap dump writer\n+\n+void AbstractDumpWriter::write_fast(const void* s, size_t len) {\n+  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n+  assert(buffer_size() - position() >= len, \"Must fit\");\n+  debug_only(_sub_record_left -= len);\n+  memcpy(buffer() + position(), s, len);\n+  set_position(position() + len);\n+}\n+\n+bool AbstractDumpWriter::can_write_fast(size_t len) {\n+  return buffer_size() - position() >= len;\n+}\n+\n+\/\/ write raw bytes\n+void AbstractDumpWriter::write_raw(const void* s, size_t len) {\n+  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n+  debug_only(_sub_record_left -= len);\n+\n+  \/\/ flush buffer to make room.\n+  while (len > buffer_size() - position()) {\n+    assert(!_in_dump_segment || _is_huge_sub_record,\n+           \"Cannot overflow in non-huge sub-record.\");\n+    size_t to_write = buffer_size() - position();\n+    memcpy(buffer() + position(), s, to_write);\n+    s = (void*) ((char*) s + to_write);\n+    len -= to_write;\n+    set_position(position() + to_write);\n+    flush();\n+  }\n+\n+  memcpy(buffer() + position(), s, len);\n+  set_position(position() + len);\n+}\n+\n+\/\/ Makes sure we inline the fast write into the write_u* functions. This is a big speedup.\n+#define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \\\n+                                      else write_raw((p), (len)); } while (0)\n+\n+void AbstractDumpWriter::write_u1(u1 x) {\n+  WRITE_KNOWN_TYPE(&x, 1);\n+}\n+\n+void AbstractDumpWriter::write_u2(u2 x) {\n+  u2 v;\n+  Bytes::put_Java_u2((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 2);\n+}\n+\n+void AbstractDumpWriter::write_u4(u4 x) {\n+  u4 v;\n+  Bytes::put_Java_u4((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 4);\n+}\n+\n+void AbstractDumpWriter::write_u8(u8 x) {\n+  u8 v;\n+  Bytes::put_Java_u8((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 8);\n+}\n+\n+void AbstractDumpWriter::write_address(address a) {\n+#ifdef _LP64\n+  write_u8((u8)a);\n+#else\n+  write_u4((u4)a);\n+#endif\n+}\n+\n+void AbstractDumpWriter::write_objectID(oop o) {\n+  write_address(cast_from_oop<address>(o));\n+}\n+\n+void AbstractDumpWriter::write_rootID(oop* p) {\n+  write_address((address)p);\n+}\n+\n+void AbstractDumpWriter::write_symbolID(Symbol* s) {\n+  write_address((address)((uintptr_t)s));\n+}\n+\n+void AbstractDumpWriter::write_id(u4 x) {\n+#ifdef _LP64\n+  write_u8((u8) x);\n+#else\n+  write_u4(x);\n+#endif\n+}\n+\n+\/\/ We use java mirror as the class ID\n+void AbstractDumpWriter::write_classID(Klass* k) {\n+  write_objectID(k->java_mirror());\n+}\n+\n+void AbstractDumpWriter::finish_dump_segment() {\n+  if (_in_dump_segment) {\n+    assert(_sub_record_left == 0, \"Last sub-record not written completely\");\n+    assert(_sub_record_ended, \"sub-record must have ended\");\n+\n+    \/\/ Fix up the dump segment length if we haven't written a huge sub-record last\n+    \/\/ (in which case the segment length was already set to the correct value initially).\n+    if (!_is_huge_sub_record) {\n+      assert(position() > dump_segment_header_size, \"Dump segment should have some content\");\n+      Bytes::put_Java_u4((address) (buffer() + 5),\n+                         (u4) (position() - dump_segment_header_size));\n+    } else {\n+      \/\/ Finish process huge sub record\n+      \/\/ Set _is_huge_sub_record to false so the parallel dump writer can flush data to file.\n+      _is_huge_sub_record = false;\n+    }\n+\n+    _in_dump_segment = false;\n+    flush();\n+  }\n+}\n+\n+void AbstractDumpWriter::start_sub_record(u1 tag, u4 len) {\n+  if (!_in_dump_segment) {\n+    if (position() > 0) {\n+      flush();\n+    }\n+\n+    assert(position() == 0 && buffer_size() > dump_segment_header_size, \"Must be at the start\");\n+\n+    write_u1(HPROF_HEAP_DUMP_SEGMENT);\n+    write_u4(0); \/\/ timestamp\n+    \/\/ Will be fixed up later if we add more sub-records.  If this is a huge sub-record,\n+    \/\/ this is already the correct length, since we don't add more sub-records.\n+    write_u4(len);\n+    assert(Bytes::get_Java_u4((address)(buffer() + 5)) == len, \"Inconsistent size!\");\n+    _in_dump_segment = true;\n+    _is_huge_sub_record = len > buffer_size() - dump_segment_header_size;\n+  } else if (_is_huge_sub_record || (len > buffer_size() - position())) {\n+    \/\/ This object will not fit in completely or the last sub-record was huge.\n+    \/\/ Finish the current segment and try again.\n+    finish_dump_segment();\n+    start_sub_record(tag, len);\n+\n+    return;\n+  }\n+\n+  debug_only(_sub_record_left = len);\n+  debug_only(_sub_record_ended = false);\n+\n+  write_u1(tag);\n+}\n+\n+void AbstractDumpWriter::end_sub_record() {\n+  assert(_in_dump_segment, \"must be in dump segment\");\n+  assert(_sub_record_left == 0, \"sub-record not written completely\");\n+  assert(!_sub_record_ended, \"Must not have ended yet\");\n+  debug_only(_sub_record_ended = true);\n+}\n+\n+\/\/ Heap dump writer\n+DumpWriter::DumpWriter(const char* path, bool overwrite, AbstractCompressor* compressor) :\n+  AbstractDumpWriter(),\n+  _writer(new (std::nothrow) FileWriter(path, overwrite)),\n+  _compressor(compressor),\n+  _bytes_written(0),\n+  _error(nullptr),\n+  _out_buffer(nullptr),\n+  _out_size(0),\n+  _out_pos(0),\n+  _tmp_buffer(nullptr),\n+  _tmp_size(0) {\n+  _error = (char*)_writer->open_writer();\n+  if (_error == nullptr) {\n+    _buffer = (char*)os::malloc(io_buffer_max_size, mtInternal);\n+    if (compressor != nullptr) {\n+      _error = (char*)_compressor->init(io_buffer_max_size, &_out_size, &_tmp_size);\n+      if (_error == nullptr) {\n+        if (_out_size > 0) {\n+          _out_buffer = (char*)os::malloc(_out_size, mtInternal);\n+        }\n+        if (_tmp_size > 0) {\n+          _tmp_buffer = (char*)os::malloc(_tmp_size, mtInternal);\n+        }\n+      }\n+    }\n+  }\n+  \/\/ initialize internal buffer\n+  _pos = 0;\n+  _size = io_buffer_max_size;\n+}\n+\n+DumpWriter::~DumpWriter(){\n+  if (_buffer != nullptr) {\n+    os::free(_buffer);\n+  }\n+  if (_out_buffer != nullptr) {\n+    os::free(_out_buffer);\n+  }\n+  if (_tmp_buffer != nullptr) {\n+    os::free(_tmp_buffer);\n+  }\n+  if (_writer != NULL) {\n+    delete _writer;\n+  }\n+  _bytes_written = -1;\n+}\n+\n+\/\/ flush any buffered bytes to the file\n+void DumpWriter::flush() {\n+  if (_pos <= 0) {\n+    return;\n+  }\n+  if (has_error()) {\n+    _pos = 0;\n+    return;\n+  }\n+  char* result = nullptr;\n+  if (_compressor == nullptr) {\n+    result = (char*)_writer->write_buf(_buffer, _pos);\n+    _bytes_written += _pos;\n+  } else {\n+    do_compress();\n+    if (!has_error()) {\n+      result = (char*)_writer->write_buf(_out_buffer, _out_pos);\n+      _bytes_written += _out_pos;\n+    }\n+  }\n+  _pos = 0; \/\/ reset pos to make internal buffer available\n+\n+  if (result != nullptr) {\n+    set_error(result);\n+  }\n+}\n+\n+void DumpWriter::do_compress() {\n+  const char* msg = _compressor->compress(_buffer, _pos, _out_buffer, _out_size,\n+                                          _tmp_buffer, _tmp_size, &_out_pos);\n+\n+  if (msg != nullptr) {\n+    set_error(msg);\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/heapDumperWriter.cpp","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_HEAPDUMPERWRITER_HPP\n+#define SHARE_SERVICES_HEAPDUMPERWRITER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+\n+\/\/ Interface for a compression implementation.\n+class AbstractCompressor : public CHeapObj<mtInternal> {\n+public:\n+  virtual ~AbstractCompressor() { }\n+\n+  \/\/ Initializes the compressor. Returns a static error message in case of an error.\n+  \/\/ Otherwise initializes the needed out and tmp size for the given block size.\n+  virtual char const* init(size_t block_size, size_t* needed_out_size,\n+                           size_t* needed_tmp_size) = 0;\n+\n+  \/\/ Does the actual compression. Returns null on success and a static error\n+  \/\/ message otherwise. Sets the 'compressed_size'.\n+  virtual char const* compress(char* in, size_t in_size, char* out, size_t out_size,\n+                               char* tmp, size_t tmp_size, size_t* compressed_size) = 0;\n+};\n+\n+\/\/ Interface for a writer implementation.\n+class AbstractWriter : public CHeapObj<mtInternal> {\n+public:\n+  virtual ~AbstractWriter() { }\n+\n+  \/\/ Opens the writer. Returns null on success and a static error message otherwise.\n+  virtual char const* open_writer() = 0;\n+\n+  \/\/ Does the write. Returns null on success and a static error message otherwise.\n+  virtual char const* write_buf(char* buf, ssize_t size) = 0;\n+};\n+\n+\n+\/\/ A writer for a file.\n+class FileWriter : public AbstractWriter {\n+private:\n+  char const* _path;\n+  bool _overwrite;\n+  int _fd;\n+\n+public:\n+  FileWriter(char const* path, bool overwrite) : _path(path), _overwrite(overwrite), _fd(-1) { }\n+\n+  ~FileWriter();\n+\n+  \/\/ Opens the writer. Returns null on success and a static error message otherwise.\n+  virtual char const* open_writer();\n+\n+  \/\/ Does the write. Returns null on success and a static error message otherwise.\n+  virtual char const* write_buf(char* buf, ssize_t size);\n+\n+  const char* get_file_path() { return _path; }\n+\n+  bool is_overwrite() const { return _overwrite; }\n+\n+  int get_fd() const {return _fd; }\n+};\n+\n+\n+\/\/ A compressor using the gzip format.\n+class GZipCompressor : public AbstractCompressor {\n+private:\n+  int _level;\n+  size_t _block_size;\n+  bool _is_first;\n+\n+public:\n+  GZipCompressor(int level) : _level(level), _block_size(0), _is_first(false) {\n+  }\n+\n+  virtual char const* init(size_t block_size, size_t* needed_out_size,\n+                           size_t* needed_tmp_size);\n+\n+  virtual char const* compress(char* in, size_t in_size, char* out, size_t out_size,\n+                               char* tmp, size_t tmp_size, size_t* compressed_size);\n+};\n+\n+\/\/ Supports I\/O operations for a dump\n+class AbstractDumpWriter : public CHeapObj<mtInternal> {\n+ protected:\n+  enum {\n+    io_buffer_max_size = 1*M,\n+    dump_segment_header_size = 9\n+  };\n+\n+  char* _buffer;    \/\/ internal buffer\n+  size_t _size;\n+  size_t _pos;\n+\n+  bool _in_dump_segment; \/\/ Are we currently in a dump segment?\n+  bool _is_huge_sub_record; \/\/ Are we writing a sub-record larger than the buffer size?\n+  DEBUG_ONLY(size_t _sub_record_left;) \/\/ The bytes not written for the current sub-record.\n+  DEBUG_ONLY(bool _sub_record_ended;) \/\/ True if we have called the end_sub_record().\n+\n+  char* buffer() const                          { return _buffer; }\n+  size_t buffer_size() const                    { return _size; }\n+  void set_position(size_t pos)                 { _pos = pos; }\n+\n+  \/\/ Can be called if we have enough room in the buffer.\n+  void write_fast(const void* s, size_t len);\n+\n+  \/\/ Returns true if we have enough room in the buffer for 'len' bytes.\n+  bool can_write_fast(size_t len);\n+\n+  void write_address(address a);\n+\n+ public:\n+  AbstractDumpWriter() :\n+    _buffer(nullptr),\n+    _size(io_buffer_max_size),\n+    _pos(0),\n+    _in_dump_segment(false) { }\n+\n+  \/\/ Total number of bytes written to the disk\n+  virtual julong bytes_written() const = 0;\n+  \/\/ Return non-null if error occurred\n+  virtual char const* error() const = 0;\n+\n+  size_t position() const                       { return _pos; }\n+  \/\/ writer functions\n+  virtual void write_raw(const void* s, size_t len);\n+  void write_u1(u1 x);\n+  void write_u2(u2 x);\n+  void write_u4(u4 x);\n+  void write_u8(u8 x);\n+  void write_objectID(oop o);\n+  void write_rootID(oop* p);\n+  void write_symbolID(Symbol* o);\n+  void write_classID(Klass* k);\n+  void write_id(u4 x);\n+\n+  \/\/ Start a new sub-record. Starts a new heap dump segment if needed.\n+  void start_sub_record(u1 tag, u4 len);\n+  \/\/ Ends the current sub-record.\n+  void end_sub_record();\n+  \/\/ Finishes the current dump segment if not already finished.\n+  void finish_dump_segment();\n+  \/\/ Flush internal buffer to persistent storage\n+  virtual void flush() = 0;\n+};\n+\n+\/\/ Supports I\/O operations for a dump\n+\n+class DumpWriter : public AbstractDumpWriter {\n+private:\n+  FileWriter* _writer;\n+  AbstractCompressor* _compressor;\n+  size_t _bytes_written;\n+  char* _error;\n+  \/\/ Compression support\n+  char* _out_buffer;\n+  size_t _out_size;\n+  size_t _out_pos;\n+  char* _tmp_buffer;\n+  size_t _tmp_size;\n+\n+private:\n+  void do_compress();\n+\n+public:\n+  DumpWriter(const char* path, bool overwrite, AbstractCompressor* compressor);\n+  ~DumpWriter();\n+  julong bytes_written() const override        { return (julong) _bytes_written; }\n+  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n+  char const* error() const override           { return _error; }\n+  void set_error(const char* error)            { _error = (char*)error; }\n+  bool has_error() const                       { return _error != nullptr; }\n+  const char* get_file_path() const            { return _writer->get_file_path(); }\n+  AbstractCompressor* compressor()             { return _compressor; }\n+  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n+  bool is_overwrite() const                    { return _writer->is_overwrite(); }\n+  int get_fd() const                           { return _writer->get_fd(); }\n+\n+  void flush() override;\n+};\n+\n+#endif \/\/ SHARE_SERVICES_HEAPDUMPERWRITER_HPP\n","filename":"src\/hotspot\/share\/services\/heapDumperWriter.hpp","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}