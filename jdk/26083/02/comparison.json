{"files":[{"patch":"@@ -294,1 +294,1 @@\n-  const JvmtiAgentList::Iterator it =JvmtiAgentList::java_agents();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::java_agents();\n@@ -303,1 +303,1 @@\n-static void send_native_agent_events(const JvmtiAgentList::Iterator& it) {\n+static void send_native_agent_events(JvmtiAgentList::Iterator& it) {\n@@ -314,1 +314,1 @@\n-  const JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n+  JvmtiAgentList::Iterator native_agents_it = JvmtiAgentList::native_agents();\n@@ -316,1 +316,1 @@\n-  const JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n+  JvmtiAgentList::Iterator xrun_agents_it = JvmtiAgentList::xrun_agents();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -85,1 +86,1 @@\n-  return _next;\n+  return Atomic::load(&_next);\n@@ -89,1 +90,1 @@\n-  _next = agent;\n+  return Atomic::store(&_next, agent);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-JvmtiAgent* JvmtiAgentList::_list = nullptr;\n+JvmtiAgent* JvmtiAgentList::_head = nullptr;\n@@ -64,19 +64,1 @@\n-static inline JvmtiAgent* head(JvmtiAgent** list) {\n-  assert(list != nullptr, \"invariant\");\n-  return Atomic::load_acquire(list);\n-}\n-\n-\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations.\n-\/\/ Especially during initial loading of agents, there exist an order requirement to iterate oldest -> newest.\n-\/\/ Our concurrent storage linked-list is newest -> oldest.\n-\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n-JvmtiAgentList::Iterator::Iterator(JvmtiAgent** list, Filter filter) :\n-  _stack(new GrowableArrayCHeap<JvmtiAgent*, mtServiceability>(16)), _filter(filter) {\n-  JvmtiAgent* next = head(list);\n-  while (next != nullptr) {\n-    next = select(next);\n-    if (next != nullptr) {\n-      _stack->push(next);\n-      next = next->next();\n-    }\n-  }\n+JvmtiAgentList::Iterator::Iterator(JvmtiAgent* head, Filter filter) : _filter(filter), _next(select(head)) {\n@@ -86,7 +68,1 @@\n-  assert(_stack != nullptr, \"invariant\");\n-  return _stack->is_nonempty();\n-}\n-\n-const JvmtiAgent* JvmtiAgentList::Iterator::next() const {\n-  assert(has_next(), \"invariant\");\n-  return _stack->pop();\n+  return _next != nullptr;\n@@ -96,1 +72,5 @@\n-  return const_cast<JvmtiAgent*>(const_cast<const Iterator*>(this)->next());\n+  assert(_next != nullptr, \"must be\");\n+  JvmtiAgent* result = _next;\n+  _next = select(_next->_next);\n+  return result;\n+\n@@ -100,1 +80,1 @@\n-  return Iterator(&_list, Iterator::NOT_XRUN);\n+  return Iterator(head(), Iterator::NOT_XRUN);\n@@ -104,1 +84,1 @@\n-  return Iterator(&_list, Iterator::JAVA);\n+  return Iterator(head(), Iterator::JAVA);\n@@ -108,1 +88,1 @@\n-  return Iterator(&_list, Iterator::NATIVE);\n+  return Iterator(head(), Iterator::NATIVE);\n@@ -112,1 +92,1 @@\n-  return Iterator(&_list, Iterator::XRUN);\n+  return Iterator(head(), Iterator::XRUN);\n@@ -116,1 +96,1 @@\n-  return Iterator(&_list, Iterator::ALL);\n+  return Iterator(head(), Iterator::ALL);\n@@ -121,5 +101,16 @@\n-  JvmtiAgent* next;\n-  do {\n-    next = head(&_list);\n-    agent->set_next(next);\n-  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+\n+  \/\/ address of the pointer to add new agent (&_head when the list is empty or &agent->_next of the last agent in the list)\n+  JvmtiAgent** tail_ptr = &_head;\n+  while (true) {\r\n+    JvmtiAgent* next = Atomic::load(tail_ptr);\r\n+    if (next == nullptr) {\r\n+      \/\/ *tail_ptr == nullptr here\n+      if (Atomic::cmpxchg(tail_ptr, (JvmtiAgent*)nullptr, agent) != nullptr) {\r\n+        \/\/ another thread added an agent, reload next from tail_ptr\r\n+        continue;\r\n+      }\r\n+      \/\/ successfully set, exit\r\n+      break;\r\n+    }\r\n+    tail_ptr = &next->_next;\r\n+  }\r\n@@ -146,0 +137,4 @@\n+JvmtiAgent* JvmtiAgentList::head() {\n+  return Atomic::load_acquire(&_head);\n+}\n+\n@@ -286,1 +281,1 @@\n-  _list = nullptr; \/\/ Pretend that no agents have been added.\n+  _head = nullptr; \/\/ Pretend that no agents have been added.\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":34,"deletions":39,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"nmt\/memTag.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -34,1 +32,1 @@\n-\/\/ Maintains a single cas linked-list of JvmtiAgents.\n+\/\/ Maintains thread-safe linked list of JvmtiAgents.\n@@ -36,1 +34,0 @@\n-  friend class Iterator;\n@@ -49,1 +46,0 @@\n-    GrowableArrayCHeap<JvmtiAgent*, mtServiceability>* _stack;\n@@ -51,2 +47,3 @@\n-    Iterator() : _stack(nullptr), _filter(ALL) {}\n-    Iterator(JvmtiAgent** list, Filter filter);\n+    JvmtiAgent* _next;\n+    Iterator(): _filter(ALL), _next(nullptr) {}\n+    Iterator(JvmtiAgent* head, Filter filter);\n@@ -57,2 +54,0 @@\n-    const JvmtiAgent* next() const NOT_JVMTI_RETURN_(nullptr);\n-    ~Iterator() { delete _stack; }\n@@ -62,1 +57,3 @@\n-  static JvmtiAgent* _list;\n+  static JvmtiAgent* _head;\n+\n+  static JvmtiAgent* head();\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1128,1 +1128,1 @@\n-  const JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}