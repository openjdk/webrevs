{"files":[{"patch":"@@ -6480,1 +6480,1 @@\n-void C2_MacroAssembler::load_nklass_compact_c2(Register dst, Address src) {\n+void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Address src) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,1 +508,1 @@\n-  void load_nklass_compact_c2(Register dst, Address src);\n+  void load_narrow_klass_compact_c2(Register dst, Address src);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/arrayOop.hpp\"\n@@ -163,0 +164,3 @@\n+static void copy_to_stack(Register haystack, Register haystack_len, bool isU, Register tmp,\n+                          XMMRegister xtmp, MacroAssembler *_masm);\n+\n@@ -398,1 +402,1 @@\n-  __ ja_b(L_bigSwitchTop);\n+  __ ja(L_bigSwitchTop);\n@@ -404,1 +408,1 @@\n-  \/\/       at least 16 bytes of header preceeding the haystack pointer.\n+  \/\/       at least 8 bytes of header preceeding the haystack pointer.\n@@ -406,1 +410,1 @@\n-  \/\/ This means that we're copying up to 15 bytes of the header onto the stack along\n+  \/\/ This means that we're copying up to 7 bytes of the header onto the stack along\n@@ -410,3 +414,0 @@\n-    Label L_moreThan16, L_adjustHaystack;\n-\n-    const Register index = rax;\n@@ -414,19 +415,1 @@\n-\n-    \/\/ Only a single vector load\/store of either 16 or 32 bytes\n-    __ cmpq(haystack_len, 0x10);\n-    __ ja_b(L_moreThan16);\n-\n-    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n-    __ movdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x10));\n-    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n-    __ jmpb(L_adjustHaystack);\n-\n-    __ bind(L_moreThan16);\n-    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n-    __ vmovdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x20));\n-    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n-\n-    \/\/ Point the haystack at the correct location of the first byte of the \"real\" haystack on the stack\n-    __ bind(L_adjustHaystack);\n-    __ subq(index, haystack_len);\n-    __ leaq(haystack, Address(rsp, index, Address::times_1));\n+    copy_to_stack(haystack, haystack_len, false, rax, XMM_TMP1, _masm);\n@@ -1586,28 +1569,2 @@\n-  {\n-    Label L_adjustHaystack, L_moreThan16;\n-\n-    \/\/ Copy haystack to stack (haystack <= 32 bytes)\n-    __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n-    __ cmpq(haystack_len, isU ? 0x8 : 0x10);\n-    __ ja_b(L_moreThan16);\n-\n-    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n-    __ movdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x10));\n-    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n-    __ jmpb(L_adjustHaystack);\n-\n-    __ bind(L_moreThan16);\n-    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n-    __ vmovdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x20));\n-    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n-\n-    __ bind(L_adjustHaystack);\n-    __ subptr(tmp, haystack_len);\n-\n-    if (isU) {\n-      \/\/ For UTF-16, lengths are half\n-      __ subptr(tmp, haystack_len);\n-    }\n-    \/\/ Point the haystack to the stack\n-    __ leaq(haystack, Address(rsp, tmp, Address::times_1));\n-  }\n+  __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+  copy_to_stack(haystack, haystack_len, isU, tmp, XMM0, _masm);\n@@ -1675,0 +1632,80 @@\n+\n+\n+\/\/ Copy the small (< 32 byte) haystack to the stack.  Allows for vector reads without page fault\n+\/\/ Only done for small haystacks\n+\/\/ NOTE: This code assumes that the haystack points to a java array type AND there are\n+\/\/       at least 8 bytes of header preceeding the haystack pointer.\n+\/\/ We're copying up to 7 bytes of the header onto the stack along with the haystack bytes.\n+\/\/ After the copy completes, we adjust the haystack pointer\n+\/\/ to the valid haystack bytes on the stack.\n+\/\/\n+\/\/ Copy haystack array elements to stack at region\n+\/\/ (COPIED_HAYSTACK_STACK_OFFSET - COPIED_HAYSTACK_STACK_OFFSET+63) with the following conditions:\n+\/\/   It may copy up to 7 bytes that precede the array\n+\/\/   It doesn't read beyond the end of the array\n+\/\/   There are atleast 31 bytes of stack region beyond the end of array\n+\/\/ Inputs:\n+\/\/   haystack - Address of haystack\n+\/\/   haystack_len - Number of elements in haystack\n+\/\/   isU - Boolean indicating if each element is Latin1 or UTF16\n+\/\/   tmp, xtmp - Scratch registers\n+\/\/ Output:\n+\/\/   haystack - Address of copied string on stack\n+\n+static void copy_to_stack(Register haystack, Register haystack_len, bool isU,\n+                          Register tmp, XMMRegister xtmp, MacroAssembler *_masm) {\n+  Label L_moreThan8, L_moreThan16, L_moreThan24, L_adjustHaystack;\n+\n+  assert(arrayOopDesc::base_offset_in_bytes(isU ? T_CHAR : T_BYTE) >= 8,\n+         \"Needs at least 8 bytes preceding the array body\");\n+\n+  \/\/ Copy haystack to stack (haystack <= 32 bytes)\n+  int scale = isU ? 2 : 1; \/\/ bytes per char\n+  Address::ScaleFactor addrScale = isU ? Address::times_2 : Address::times_1;\n+\n+  __ cmpq(haystack_len, 16\/scale);\n+  __ ja_b(L_moreThan16);\n+\n+  __ cmpq(haystack_len, 8\/scale);\n+  __ ja_b(L_moreThan8);\n+  \/\/ haystack length <= 8 bytes, copy 8 bytes upto haystack end reading at most 7 bytes into the header\n+  __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 8);\n+  __ movq(xtmp, Address(haystack, haystack_len, addrScale, -8));\n+  __ movq(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xtmp);\n+  __ jmpb(L_adjustHaystack);\n+\n+  __ bind(L_moreThan8);\n+  \/\/ haystack length > 8 and <=16 bytes, copy 16 bytes upto haystack end reading at most 7 bytes into the header\n+  __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 16);\n+  __ movdqu(xtmp, Address(haystack, haystack_len, addrScale, -16));\n+  __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xtmp);\n+  __ jmpb(L_adjustHaystack);\n+\n+  __ bind(L_moreThan16);\n+  __ cmpq(haystack_len, 24\/scale);\n+  __ ja_b(L_moreThan24);\n+  \/\/ haystack length > 16 and <=24 bytes, copy 24 bytes upto haystack end reading at most 7 bytes into the header\n+  __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 24);\n+  __ movdqu(xtmp, Address(haystack, haystack_len, addrScale, -24));\n+  __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xtmp);\n+  __ movq(xtmp, Address(haystack, haystack_len, addrScale, -8));\n+  __ movq(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET + 16), xtmp);\n+  __ jmpb(L_adjustHaystack);\n+\n+  __ bind(L_moreThan24);\n+  \/\/ haystack length > 24 and < 32 bytes, copy 32 bytes upto haystack end reading at most 7 bytes into the header\n+  __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 32);\n+  __ vmovdqu(xtmp, Address(haystack, haystack_len, addrScale, -32));\n+  __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xtmp);\n+\n+  __ bind(L_adjustHaystack);\n+  __ subptr(tmp, haystack_len);\n+\n+  if (isU) {\n+    __ subptr(tmp, haystack_len);\n+  }\n+\n+  \/\/ Point the haystack to the stack\n+  __ leaq(haystack, Address(rsp, tmp, Address::times_1));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":90,"deletions":53,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -1372,1 +1372,1 @@\n-    load_nklass_compact(temp, receiver);\n+    load_narrow_klass_compact(temp, receiver);\n@@ -5684,1 +5684,1 @@\n-void MacroAssembler::load_nklass_compact(Register dst, Register src) {\n+void MacroAssembler::load_narrow_klass_compact(Register dst, Register src) {\n@@ -5696,1 +5696,1 @@\n-    load_nklass_compact(dst, src);\n+    load_narrow_klass_compact(dst, src);\n@@ -5726,1 +5726,1 @@\n-    load_nklass_compact(tmp, obj);\n+    load_narrow_klass_compact(tmp, obj);\n@@ -5742,2 +5742,2 @@\n-    load_nklass_compact(tmp1, obj1);\n-    load_nklass_compact(tmp2, obj2);\n+    load_narrow_klass_compact(tmp1, obj1);\n+    load_narrow_klass_compact(tmp2, obj2);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-  void load_nklass_compact(Register dst, Register src);\n+  void load_narrow_klass_compact(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4389,1 +4389,1 @@\n-  format %{ \"load_nklass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n+  format %{ \"load_narrow_klass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n@@ -4391,1 +4391,1 @@\n-    __ load_nklass_compact_c2($dst$$Register, $mem$$Address);\n+    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$Address);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}