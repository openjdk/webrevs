{"files":[{"patch":"@@ -692,1 +692,3 @@\n-             test \"x$OPENJDK_TARGET_CPU\" != \"xaarch64\"; then\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xaarch64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xppc64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xppc64le\"; then\n","filename":"make\/autoconf\/jdk-options.m4","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1979,10 +1979,1 @@\n-      if (UseCompressedClassPointers) {\n-        \/\/ We don't need decode because we just need to compare.\n-        __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);\n-        __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-        __ cmpw(CCR0, tmp, tmp2);\n-      } else {\n-        __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);\n-        __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-        __ cmpd(CCR0, tmp, tmp2);\n-      }\n+      __ cmp_klasses_from_objects(CCR0, src, dst, tmp, tmp2);\n@@ -2111,19 +2102,5 @@\n-    if (UseCompressedClassPointers) {\n-      \/\/ Tmp holds the default type. It currently comes uncompressed after the\n-      \/\/ load of a constant, so encode it.\n-      __ encode_klass_not_null(tmp);\n-      \/\/ Load the raw value of the dst klass, since we will be comparing\n-      \/\/ uncompressed values directly.\n-      __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-      __ cmpw(CCR0, tmp, tmp2);\n-      if (basic_type != T_OBJECT) {\n-        __ bne(CCR0, halt);\n-        \/\/ Load the raw value of the src klass.\n-        __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);\n-        __ cmpw(CCR0, tmp, tmp2);\n-        __ beq(CCR0, known_ok);\n-      } else {\n-        __ beq(CCR0, known_ok);\n-        __ cmpw(CCR0, src, dst);\n-        __ beq(CCR0, known_ok);\n-      }\n+    __ cmp_klass(CCR0, dst, tmp, R11_scratch1, R12_scratch2);\n+    if (basic_type != T_OBJECT) {\n+      __ bne(CCR0, halt);\n+      __ cmp_klass(CCR0, src, tmp, R11_scratch1, R12_scratch2);\n+      __ beq(CCR0, known_ok);\n@@ -2131,13 +2108,3 @@\n-      __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-      __ cmpd(CCR0, tmp, tmp2);\n-      if (basic_type != T_OBJECT) {\n-        __ bne(CCR0, halt);\n-        \/\/ Load the raw value of the src klass.\n-        __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);\n-        __ cmpd(CCR0, tmp, tmp2);\n-        __ beq(CCR0, known_ok);\n-      } else {\n-        __ beq(CCR0, known_ok);\n-        __ cmpd(CCR0, src, dst);\n-        __ beq(CCR0, known_ok);\n-      }\n+      __ beq(CCR0, known_ok);\n+      __ cmpw(CCR0, src, dst);\n+      __ beq(CCR0, known_ok);\n@@ -2720,6 +2687,1 @@\n-  if (UseCompressedClassPointers) {\n-    __ lwz(result, oopDesc::klass_offset_in_bytes(), obj);\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ld(result, oopDesc::klass_offset_in_bytes(), obj);\n-  }\n+  __ load_klass(result, obj);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":48,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -200,3 +200,10 @@\n-  load_const_optimized(t1, (intx)markWord::prototype().value());\n-  std(t1, oopDesc::mark_offset_in_bytes(), obj);\n-  store_klass(obj, klass);\n+\n+  if (UseCompactObjectHeaders) {\n+    ld(t1, in_bytes(Klass::prototype_header_offset()), klass);\n+    std(t1, oopDesc::mark_offset_in_bytes(), obj);\n+  } else {\n+    load_const_optimized(t1, (intx)markWord::prototype().value());\n+    std(t1, oopDesc::mark_offset_in_bytes(), obj);\n+    store_klass(obj, klass);\n+  }\n+\n@@ -205,1 +212,1 @@\n-  } else if (UseCompressedClassPointers) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,9 @@\n+void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Register obj, int disp) {\n+  \/\/ Note: Don't clobber obj anywhere in that method!\n+\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead.\n+  ld(dst, disp - oopDesc::klass_offset_in_bytes(), obj);\n+  srdi(dst, dst, markWord::klass_shift);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  void load_narrow_klass_compact_c2(Register dst, Register obj, int disp);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1221,0 +1221,3 @@\n+\n+  if (UseCompactObjectHeaders) num_ins++;\n+\n@@ -1248,1 +1251,3 @@\n-    if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_narrow_klass_compact(tmp1, receiver);\n+    } else if (UseCompressedClassPointers) {\n@@ -3242,0 +3247,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -3251,0 +3257,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -3256,1 +3263,1 @@\n-    stw(val, oopDesc::klass_gap_offset_in_bytes(), dst_oop); \/\/ klass gap if compressed\n+    stw(val, oopDesc::klass_gap_offset_in_bytes(), dst_oop);\n@@ -3297,1 +3304,4 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+    decode_klass_not_null(dst);\n+  } else if (UseCompressedClassPointers) {\n@@ -3299,2 +3309,1 @@\n-    \/\/ Attention: no null check here!\n-    decode_klass_not_null(dst, dst);\n+    decode_klass_not_null(dst);\n@@ -3306,0 +3315,43 @@\n+\/\/ Loads the obj's Klass* into dst.\n+\/\/ Preserves all registers (incl src, rscratch1 and rscratch2).\n+\/\/ Input:\n+\/\/ src - the oop we want to load the klass from.\n+\/\/ dst - output nklass.\n+void MacroAssembler::load_narrow_klass_compact(Register dst, Register src) {\n+  assert(UseCompactObjectHeaders, \"expects UseCompactObjectHeaders\");\n+  ld(dst, oopDesc::mark_offset_in_bytes(), src);\n+  srdi(dst, dst, markWord::klass_shift);\n+}\n+\n+void MacroAssembler::cmp_klass(ConditionRegister dst, Register obj, Register klass, Register tmp, Register tmp2) {\n+  assert_different_registers(obj, klass, tmp);\n+  if (UseCompressedClassPointers) {\n+    if (UseCompactObjectHeaders) {\n+      load_narrow_klass_compact(tmp, obj);\n+    } else {\n+      lwz(tmp, oopDesc::klass_offset_in_bytes(), obj);\n+    }\n+    Register encoded_klass = encode_klass_not_null(tmp2, klass);\n+    cmpw(dst, tmp, encoded_klass);\n+  } else {\n+    ld(tmp, oopDesc::klass_offset_in_bytes(), obj);\n+    cmpd(dst, tmp, klass);\n+  }\n+}\n+\n+void MacroAssembler::cmp_klasses_from_objects(ConditionRegister dst, Register obj1, Register obj2, Register tmp1, Register tmp2) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(tmp1, obj1);\n+    load_narrow_klass_compact(tmp2, obj2);\n+    cmpw(dst, tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    lwz(tmp1, oopDesc::klass_offset_in_bytes(), obj1);\n+    lwz(tmp2, oopDesc::klass_offset_in_bytes(), obj2);\n+    cmpw(dst, tmp1, tmp2);\n+  } else {\n+    ld(tmp1, oopDesc::klass_offset_in_bytes(), obj1);\n+    ld(tmp2, oopDesc::klass_offset_in_bytes(), obj2);\n+    cmpd(dst, tmp1, tmp2);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":57,"deletions":5,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -760,0 +760,3 @@\n+  void load_narrow_klass_compact(Register dst, Register src);\n+  void cmp_klass(ConditionRegister dst, Register obj, Register klass, Register tmp, Register tmp2);\n+  void cmp_klasses_from_objects(ConditionRegister dst, Register obj1, Register obj2, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5503,0 +5503,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -5511,0 +5512,14 @@\n+instruct loadNKlassCompactHeaders(iRegNdst dst, memory mem) %{\n+  match(Set dst (LoadNKlass mem));\n+  predicate(UseCompactObjectHeaders);\n+  ins_cost(MEMORY_REF_COST);\n+\n+  format %{ \"load_narrow_klass_compact $dst, $mem \\t\/\/ compressed class ptr\" %}\n+  size(8);\n+  ins_encode %{\n+    assert($mem$$index$$Register == R0, \"must not have indexed address: %s[%s]\", $mem$$base$$Register.name(), $mem$$index$$Register.name());\n+    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$base$$Register, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3843,2 +3843,3 @@\n-      __ addi(Rinstance_size, Rinstance_size, 7 - (int)sizeof(oopDesc));\n-      __ addi(Rbase, RallocatedObject, sizeof(oopDesc));\n+      int header_size = oopDesc::header_size() * HeapWordSize;\n+      __ addi(Rinstance_size, Rinstance_size, 7 - header_size);\n+      __ addi(Rbase, RallocatedObject, header_size);\n@@ -3854,6 +3855,9 @@\n-    __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n-    __ std(Rscratch, oopDesc::mark_offset_in_bytes(), RallocatedObject);\n-\n-    \/\/ Init klass.\n-    __ store_klass_gap(RallocatedObject);\n-    __ store_klass(RallocatedObject, RinstanceKlass, Rscratch); \/\/ klass (last for cms)\n+    if (UseCompactObjectHeaders) {\n+      __ ld(Rscratch, in_bytes(Klass::prototype_header_offset()), RinstanceKlass);\n+      __ std(Rscratch, oopDesc::mark_offset_in_bytes(), RallocatedObject);\n+    } else {\n+      __ load_const_optimized(Rscratch, markWord::prototype().value(), R0);\n+      __ std(Rscratch, oopDesc::mark_offset_in_bytes(), RallocatedObject);\n+      __ store_klass_gap(RallocatedObject);\n+      __ store_klass(RallocatedObject, RinstanceKlass, Rscratch);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"}]}