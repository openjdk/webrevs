{"files":[{"patch":"@@ -42,0 +42,3 @@\n+    static int oopDesc_klass_offset_in_bytes;\n+    static int arrayOopDesc_length_offset_in_bytes;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+int CompilerToVM::Data::oopDesc_klass_offset_in_bytes;\n+int CompilerToVM::Data::arrayOopDesc_length_offset_in_bytes;\n@@ -151,0 +153,3 @@\n+  oopDesc_klass_offset_in_bytes = oopDesc::klass_offset_in_bytes();\n+  arrayOopDesc_length_offset_in_bytes = arrayOopDesc::length_offset_in_bytes();\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+  static_field(CompilerToVM::Data,             oopDesc_klass_offset_in_bytes,          int)                                          \\\n+  static_field(CompilerToVM::Data,             arrayOopDesc_length_offset_in_bytes,    int)                                          \\\n+                                                                                                                                     \\\n@@ -797,0 +800,1 @@\n+  declare_constant(markWord::klass_shift)                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -334,2 +334,2 @@\n-      \/\/ NOTE: The only place where this is used with compact headers is\n-      \/\/ the C2 compiler, and even there we don't use it to access the (narrow)Klass*\n+      \/\/ NOTE: The only places where this is used with compact headers are the C2\n+      \/\/ compiler and JVMCI, and even there we don't use it to access the (narrow)Klass*\n@@ -337,1 +337,1 @@\n-      \/\/ of LoadNKlass instructions. This value could be any value that is not a valid\n+      \/\/ containing Klass* info. This value could be any value that is not a valid\n@@ -339,1 +339,1 @@\n-      \/\/ partially loaded from C2.\n+      \/\/ partially loaded from C2 and JVMCI.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    final int hubOffset = getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n+    final int klassOffsetInBytes = getFieldValue(\"CompilerToVM::Data::oopDesc_klass_offset_in_bytes\", Integer.class, \"int\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,1 +194,5 @@\n-        return runtime().compilerToVm.getResolvedJavaType(object, runtime().getConfig().hubOffset, false);\n+        \/\/ HotSpot tests if the offset is oopDesc::klass_offset_in_bytes() and returns\n+        \/\/ the object type accordingly. When UseCompactClassPointers is enabled,\n+        \/\/ oopDesc::klass_offset_in_bytes() will return an offset halfway into the\n+        \/\/ object's markWord as a placeholder referring to the klass pointer.\n+        return runtime().compilerToVm.getResolvedJavaType(object, runtime().getConfig().klassOffsetInBytes, false);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/SharedLibraryJVMCIReflection.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}