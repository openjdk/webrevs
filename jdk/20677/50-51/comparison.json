{"files":[{"patch":"@@ -695,1 +695,2 @@\n-             test \"x$OPENJDK_TARGET_CPU\" != \"xriscv64\"; then\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xriscv64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xs390x\"; then\n","filename":"make\/autoconf\/jdk-options.m4","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2032,2 +2032,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2097,7 +2095,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ z_l(tmp, src_klass_addr);\n-        __ z_c(tmp, dst_klass_addr);\n-      } else {\n-        __ z_lg(tmp, src_klass_addr);\n-        __ z_cg(tmp, dst_klass_addr);\n-      }\n+      __ cmp_klasses_from_objects(src, dst, tmp, Z_R1_scratch);\n@@ -2237,2 +2229,1 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }\n-      else                                    { __ z_cg(tmp, dst_klass_addr); }\n+      __ cmp_klass(tmp, dst, Z_R1_scratch);\n@@ -2240,2 +2231,2 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, src_klass_addr); }\n-      else                                    { __ z_cg(tmp, src_klass_addr); }\n+\n+      __ cmp_klass(tmp, src, Z_R1_scratch);\n@@ -2244,2 +2235,1 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }\n-      else                                    { __ z_cg(tmp, dst_klass_addr); }\n+      __ cmp_klass(tmp, dst, Z_R1_scratch);\n@@ -2740,6 +2730,1 @@\n-  if (UseCompressedClassPointers) {\n-    __ z_llgf(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ z_lg(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  __ load_klass(result, obj);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -176,3 +176,8 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t.\n-  load_const_optimized(t1, (intx)markWord::prototype().value());\n-  z_stg(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  if (UseCompactObjectHeaders) {\n+    z_lg(t1, Address(klass, in_bytes(Klass::prototype_header_offset())));\n+    z_stg(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  } else {\n+    load_const_optimized(t1, (intx)markWord::prototype().value());\n+    z_stg(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    store_klass(klass, obj, t1);\n+  }\n@@ -183,1 +188,1 @@\n-  } else if (UseCompressedClassPointers) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -186,1 +191,0 @@\n-  store_klass(klass, obj, t1);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,0 +45,7 @@\n+void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Address src) {\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead.\n+  z_lg(dst, src.plus_disp(-oopDesc::klass_offset_in_bytes()));\n+  z_srlg(dst, dst, markWord::klass_shift); \/\/ TODO: could be z_sra\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  void load_narrow_klass_compact_c2(Register dst, Address src);\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2163,1 +2163,10 @@\n-  return 30 + (ImplicitNullChecks ? 0 : 6);\n+  int ic_size = 24;\n+  if (!ImplicitNullChecks) {\n+    ic_size += 6;\n+  }\n+  if (UseCompactObjectHeaders) {\n+    ic_size += 12;\n+  } else {\n+    ic_size += 6; \/\/ either z_llgf or z_lg\n+  }\n+  return ic_size;\n@@ -2184,1 +2193,3 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(R1_scratch, R2_receiver);\n+  } else if (UseCompressedClassPointers) {\n@@ -4067,0 +4078,46 @@\n+\/\/ Loads the obj's Klass* into dst.\n+\/\/ Input:\n+\/\/ src - the oop we want to load the klass from.\n+\/\/ dst - output nklass.\n+void MacroAssembler::load_narrow_klass_compact(Register dst, Register src) {\n+  BLOCK_COMMENT(\"load_narrow_klass_compact {\");\n+  assert(UseCompactObjectHeaders, \"expects UseCompactObjectHeaders\");\n+  z_lg(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  z_srlg(dst, dst, markWord::klass_shift);\n+  BLOCK_COMMENT(\"} load_narrow_klass_compact\");\n+}\n+\n+void MacroAssembler::cmp_klass(Register klass, Register obj, Register tmp) {\n+  BLOCK_COMMENT(\"cmp_klass {\");\n+  assert_different_registers(obj, klass, tmp);\n+  if (UseCompactObjectHeaders) {\n+    assert(tmp != noreg, \"required\");\n+    assert_different_registers(klass, obj, tmp);\n+    load_narrow_klass_compact(tmp, obj);\n+    z_cr(klass, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    z_c(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    z_cg(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+  BLOCK_COMMENT(\"} cmp_klass\");\n+}\n+\n+void MacroAssembler::cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2) {\n+  BLOCK_COMMENT(\"cmp_klasses_from_objects {\");\n+  if (UseCompactObjectHeaders) {\n+    assert(tmp1 != noreg && tmp2 != noreg, \"required\");\n+    assert_different_registers(obj1, obj2, tmp1, tmp2);\n+    load_narrow_klass_compact(tmp1, obj1);\n+    load_narrow_klass_compact(tmp2, obj2);\n+    z_cr(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    z_l(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    z_c(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    z_lg(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    z_cg(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+  }\n+  BLOCK_COMMENT(\"} cmp_klasses_from_objects\");\n+}\n+\n@@ -4068,1 +4125,4 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(klass, src_oop);\n+    decode_klass_not_null(klass);\n+  } else if (UseCompressedClassPointers) {\n@@ -4070,1 +4130,0 @@\n-    \/\/ Attention: no null check here!\n@@ -4078,0 +4137,1 @@\n+  assert(!UseCompactObjectHeaders, \"Don't use with compact headers\");\n@@ -4089,0 +4149,1 @@\n+  assert(!UseCompactObjectHeaders, \"Don't use with compact headers\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -806,0 +806,7 @@\n+  void load_narrow_klass_compact(Register dst, Register src);\n+  \/\/ Compares the Klass pointer of an object to a given Klass (which might be narrow,\n+  \/\/ depending on UseCompressedClassPointers).\n+  void cmp_klass(Register klass, Register obj, Register tmp);\n+  \/\/ Compares the Klass pointer of two objects obj1 and obj2. Result is in the condition flags.\n+  \/\/ Uses tmp1 and tmp2 as temporary registers.\n+  void cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4413,0 +4413,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -4422,0 +4423,15 @@\n+instruct loadNKlassCompactHeaders(iRegN dst, memory mem, flagsReg cr) %{\n+  match(Set dst (LoadNKlass mem));\n+  predicate(UseCompactObjectHeaders);\n+  effect(KILL cr);\n+  ins_cost(MEMORY_REF_COST);\n+  format %{ \"load_narrow_klass_compact $dst,$mem \\t# compressed class ptr\" %}\n+  \/\/ TODO: size()\n+  ins_encode %{\n+    __ block_comment(\"load_narrow_klass_compact_c2 {\");\n+    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$Address);\n+    __ block_comment(\"} load_narrow_klass_compact\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3955,1 +3955,6 @@\n-      __ z_aghi(Rsize, (int)-sizeof(oopDesc)); \/\/ Subtract header size, set CC.\n+      if (UseCompactObjectHeaders) {\n+        assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n+        __ z_aghi(Rsize, (int)-oopDesc::base_offset_in_bytes());\n+      } else {\n+        __ z_aghi(Rsize, (int)-sizeof(oopDesc)); \/\/ Subtract header size, set CC.\n+      }\n@@ -3967,1 +3972,5 @@\n-      __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);\n+      if (UseCompactObjectHeaders) {\n+        __ add2reg(RobjectFields, oopDesc::base_offset_in_bytes(), RallocatedObject);\n+      } else {\n+        __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);\n+      }\n@@ -3973,5 +3982,9 @@\n-    __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n-                   (long)markWord::prototype().value());\n-\n-    __ store_klass_gap(Rzero, RallocatedObject);  \/\/ Zero klass gap for compressed oops.\n-    __ store_klass(iklass, RallocatedObject);     \/\/ Store klass last.\n+    if (UseCompactObjectHeaders) {\n+      __ z_lg(tmp, Address(iklass, in_bytes(Klass::prototype_header_offset())));\n+      __ z_stg(tmp, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),\n+                     (long) markWord::prototype().value());\n+      __ store_klass_gap(Rzero, RallocatedObject);  \/\/ Zero klass gap for compressed oops.\n+      __ store_klass(iklass, RallocatedObject);     \/\/ Store klass last.\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"}]}