{"files":[{"patch":"@@ -6451,1 +6451,1 @@\n-instruct loadNKlassCompactHeaders(iRegNNoSp dst, indirect mem)\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory mem)\n@@ -6459,1 +6459,1 @@\n-    __ load_nklass_compact_c2($dst$$Register, $mem$$Register);\n+    __ load_nklass_compact_c2($dst$$Register, $mem$$base$$Register, $mem$$index$$Register, $mem$$scale, $mem$$disp);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2561,1 +2561,3 @@\n-void C2_MacroAssembler::load_nklass_compact_c2(Register dst, Register src) {\n+void C2_MacroAssembler::load_nklass_compact_c2(Register dst, Register obj, Register index, int scale, int disp) {\n+  \/\/ Note: Don't clobber obj anywhere in that method!\n+\n@@ -2564,2 +2566,12 @@\n-  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp.\n-  ldr(dst, Address(src, -oopDesc::klass_offset_in_bytes()));\n+  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp. However, sometimes C2\n+  \/\/ combines decoding of a compressed oop and the load of the narrow Klass. When that happens,\n+  \/\/ we get the heapBase in obj, and the narrowOop+klass_offset_in_bytes\/sizeof(narrowOop) in index.\n+  \/\/ When that happens, we need to lea the address into a single register, and subtract the\n+  \/\/ klass_offset_in_bytes, to get the address of the mark-word.\n+  int offset = oopDesc::mark_offset_in_bytes() + disp - oopDesc::klass_offset_in_bytes();\n+  if (index == noreg) {\n+    ldr(dst, Address(obj, offset));\n+  } else {\n+    lea(dst, Address(obj, index, Address::lsl(scale)));\n+    ldr(dst, Address(dst, offset));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  void load_nklass_compact_c2(Register dst, Register src);\n+  void load_nklass_compact_c2(Register dst, Register obj, Register index, int scale, int disp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  if (have_class_space_arena() && class_space_arena()->contains(bl) &&\n+  if (Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr) &&\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  void deallocate_and_check(MetaBlock bl, bool is_class) {\n+  void deallocate_and_check(MetaBlock bl) {\n@@ -303,1 +303,1 @@\n-    tester.deallocate_and_check(bl1, true);\n+    tester.deallocate_and_check(bl1);\n@@ -308,1 +308,0 @@\n-    EXPECT_EQ(bl3, bl1); \/\/ should have gotten the same block back from freelist\n@@ -316,1 +315,1 @@\n-    tester.deallocate_and_check(bl5, false);\n+    tester.deallocate_and_check(bl5);\n@@ -377,1 +376,1 @@\n-          tester.deallocate_and_check(life_allocations[slot].bl, life_allocations[slot].is_class);\n+          tester.deallocate_and_check(life_allocations[slot].bl);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_clms.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}