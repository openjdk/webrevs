{"files":[{"patch":"@@ -2309,1 +2309,1 @@\n-      __ cmp_klass(src, dst, tmp, rscratch1);\n+      __ cmp_klasses_from_objects(src, dst, tmp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2565,8 +2565,2 @@\n-  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n-  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp. However, sometimes C2\n-  \/\/ combines decoding of a compressed oop and the load of the narrow Klass. When that happens,\n-  \/\/ we get the heapBase in obj, and the narrowOop+klass_offset_in_bytes\/sizeof(narrowOop) in index.\n-  \/\/ When that happens, we need to lea the address into a single register, and subtract the\n-  \/\/ klass_offset_in_bytes, to get the address of the mark-word.\n-  int offset = oopDesc::mark_offset_in_bytes() + disp - oopDesc::klass_offset_in_bytes();\n-  ldr(dst, Address(obj, offset));\n+  \/\/ obj-start, so that we can load from the object's mark-word instead.\n+  ldr(dst, Address(obj, disp - oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4916,2 +4916,2 @@\n-void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {\n-  assert_different_registers(oop, trial_klass, tmp);\n+void MacroAssembler::cmp_klass(Register obj, Register klass, Register tmp) {\n+  assert_different_registers(obj, klass, tmp);\n@@ -4920,1 +4920,1 @@\n-      load_nklass_compact(tmp, oop);\n+      load_nklass_compact(tmp, obj);\n@@ -4922,1 +4922,1 @@\n-      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+      ldrw(tmp, Address(obj, oopDesc::klass_offset_in_bytes()));\n@@ -4925,1 +4925,1 @@\n-      cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n+      cmp(klass, tmp, LSL, CompressedKlassPointers::shift());\n@@ -4930,1 +4930,1 @@\n-      cmpw(trial_klass, tmp);\n+      cmpw(klass, tmp);\n@@ -4935,1 +4935,1 @@\n-    ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    ldr(tmp, Address(obj, oopDesc::klass_offset_in_bytes()));\n@@ -4937,1 +4937,1 @@\n-  cmp(trial_klass, tmp);\n+  cmp(klass, tmp);\n@@ -4940,1 +4940,1 @@\n-void MacroAssembler::cmp_klass(Register src, Register dst, Register tmp1, Register tmp2) {\n+void MacroAssembler::cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2) {\n@@ -4942,2 +4942,2 @@\n-    load_nklass_compact(tmp1, src);\n-    load_nklass_compact(tmp2, dst);\n+    load_nklass_compact(tmp1, obj1);\n+    load_nklass_compact(tmp2,  obj2);\n@@ -4946,2 +4946,2 @@\n-    ldrw(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n-    ldrw(tmp2, Address(dst, oopDesc::klass_offset_in_bytes()));\n+    ldrw(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    ldrw(tmp2, Address(obj2, oopDesc::klass_offset_in_bytes()));\n@@ -4950,2 +4950,2 @@\n-    ldr(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n-    ldr(tmp2, Address(dst, oopDesc::klass_offset_in_bytes()));\n+    ldr(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    ldr(tmp2, Address(obj2, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -881,2 +881,2 @@\n-  void cmp_klass(Register oop, Register trial_klass, Register tmp);\n-  void cmp_klass(Register src, Register dst, Register tmp1, Register tmp2);\n+  void cmp_klass(Register obj, Register klass, Register tmp);\n+  void cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3241,1 +3241,1 @@\n-      __ cmp_klass(src, dst, tmp, tmp2);\n+      __ cmp_klasses_from_objects(src, dst, tmp, tmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5692,1 +5692,0 @@\n-  BLOCK_COMMENT(\"load_klass\");\n@@ -5723,1 +5722,0 @@\n-  BLOCK_COMMENT(\"cmp_klass 1\");\n@@ -5726,0 +5724,2 @@\n+    assert(tmp != noreg, \"need tmp\");\n+    assert_different_registers(klass, obj, tmp);\n@@ -5737,2 +5737,1 @@\n-void MacroAssembler::cmp_klass(Register src, Register dst, Register tmp1, Register tmp2) {\n-  BLOCK_COMMENT(\"cmp_klass 2\");\n+void MacroAssembler::cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2) {\n@@ -5742,3 +5741,3 @@\n-    assert_different_registers(src, dst, tmp1, tmp2);\n-    load_nklass_compact(tmp1, src);\n-    load_nklass_compact(tmp2, dst);\n+    assert_different_registers(obj1, obj2, tmp1, tmp2);\n+    load_nklass_compact(tmp1, obj1);\n+    load_nklass_compact(tmp2, obj2);\n@@ -5747,2 +5746,2 @@\n-    movl(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n-    cmpl(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+    movl(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    cmpl(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n@@ -5752,2 +5751,2 @@\n-    movptr(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n-    cmpptr(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+    movptr(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    cmpptr(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  void cmp_klass(Register klass, Register dst, Register tmp);\n+  void cmp_klass(Register klass, Register obj, Register tmp);\n@@ -376,1 +376,1 @@\n-  \/\/ Compares the Klass pointer of two objects o1 and o2. Result is in the condition flags.\n+  \/\/ Compares the Klass pointer of two objects obj1 and obj2. Result is in the condition flags.\n@@ -378,1 +378,1 @@\n-  void cmp_klass(Register src, Register dst, Register tmp1, Register tmp2);\n+  void cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4388,1 +4388,1 @@\n-  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  format %{ \"load_nklass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,9 +223,2 @@\n-bool CollectedHeap::is_oop(oop object) const {\n-  if (!is_object_aligned(object)) {\n-    return false;\n-  }\n-\n-  if (!is_in(object)) {\n-    return false;\n-  }\n-\n+bool klass_is_sane(oop object) {\n+  Klass* klass;\n@@ -240,4 +233,5 @@\n-      Klass* klass = mark.klass();\n-      if (!Metaspace::contains(mark.klass_without_asserts())) {\n-        return false;\n-      }\n+      klass = mark.klass_without_asserts();\n+    } else {\n+      \/\/ We can't access the Klass*. We optimistically assume that\n+      \/\/ it is ok. This happens very rarely.\n+      klass = nullptr;\n@@ -245,1 +239,16 @@\n-  } else if (!Metaspace::contains(object->klass_without_asserts())) {\n+  } else {\n+    klass = object->klass_without_asserts();\n+  }\n+  return klass == nullptr || Metaspace::contains(klass);\n+}\n+\n+bool CollectedHeap::is_oop(oop object) const {\n+  if (!is_object_aligned(object)) {\n+    return false;\n+  }\n+\n+  if (!is_in(object)) {\n+    return false;\n+  }\n+\n+  if (!klass_is_sane(object)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1972,7 +1972,2 @@\n-  if (UseCompactObjectHeaders) {\n-    if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n-      \/\/ The field is Klass::_prototype_header.  Return its (constant) value.\n-      assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n-      return TypeX::make(klass->prototype_header());\n-    }\n-  }\n+  assert(!UseCompactObjectHeaders || tkls->offset() != in_bytes(Klass::prototype_header_offset()),\n+         \"must not happen\");\n@@ -2253,3 +2248,5 @@\n-  Node* alloc = is_new_object_mark_load();\n-  if (!UseCompactObjectHeaders && alloc != nullptr) {\n-    return TypeX::make(markWord::prototype().value());\n+  if (!UseCompactObjectHeaders) {\n+    Node* alloc = is_new_object_mark_load();\n+    if (alloc != nullptr) {\n+      return TypeX::make(markWord::prototype().value());\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"}]}