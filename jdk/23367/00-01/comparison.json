{"files":[{"patch":"@@ -323,1 +323,2 @@\n-    if (result == nullptr) {\n+    assert(result == nullptr, \"inv\");\n+    {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-DEBUG_ONLY(uint64_t GCLocker::_debug_count;)\n+DEBUG_ONLY(uint64_t GCLocker::_verify_in_cr_count;)\n@@ -72,1 +72,1 @@\n-  DEBUG_ONLY(_debug_count = 0;)\n+  DEBUG_ONLY(_verify_in_cr_count = 0;)\n@@ -106,1 +106,1 @@\n-  \/\/ Matching the storestore in GCLocker::exit\n+  \/\/ Matching the storestore in GCLocker::exit.\n@@ -108,1 +108,1 @@\n-  assert(Atomic::load(&_debug_count) == 0, \"inv\");\n+  assert(Atomic::load(&_verify_in_cr_count) == 0, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,12 @@\n+\/\/ GCLocker provides synchronization between the garbage collector (GC) and\n+\/\/ threads using JNI critical APIs. When threads enter a critical region (CR),\n+\/\/ certain GC implementations may suspend garbage collection until all such\n+\/\/ threads have exited.\n+\/\/\n+\/\/ Threads that need to trigger a GC should use the `block()` and `unblock()`\n+\/\/ APIs. `block()` will block the caller and prevent new threads from entering\n+\/\/ the CR.\n+\/\/\n+\/\/ Threads entering or exiting a CR must call the `enter` and `exit` APIs to\n+\/\/ ensure proper synchronization with the GC.\n+\n@@ -37,1 +49,2 @@\n-  static uint64_t _debug_count;\n+  \/\/ Debug-only: to track the number of java threads in critical-region.\n+  static uint64_t _verify_in_cr_count;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    DEBUG_ONLY(Atomic::add(&_debug_count, (uint64_t)1);)\n+    DEBUG_ONLY(Atomic::add(&_verify_in_cr_count, (uint64_t)1);)\n@@ -55,2 +55,2 @@\n-    Atomic::add(&_debug_count, (uint64_t)-1);\n-    \/\/ Matching the loadload in GCLocker::block\n+    Atomic::add(&_verify_in_cr_count, (uint64_t)-1);\n+    \/\/ Matching the loadload in GCLocker::block.\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -361,4 +361,0 @@\n-\n-#if INCLUDE_JFR\n-\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-\/\/ In case a GC locker is active and the need for a GC is already signaled,\n-\/\/ we want to skip this GC attempt altogether, without doing a futile\n-\/\/ safepoint operation.\n@@ -96,3 +93,0 @@\n-  if (!skip && GCLocker::is_active()) {\n-    skip = Universe::heap()->is_maximal_no_gc();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1244,5 +1244,0 @@\n-  <Event name=\"GCLocker\" category=\"Java Virtual Machine, GC, Detailed\" label=\"GC Locker\" startTime=\"true\" thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"uint\" name=\"lockCount\" label=\"Lock Count\" description=\"The number of Java threads in a critical section when the GC locker is started\" \/>\n-    <Field type=\"uint\" name=\"stallCount\" label=\"Stall Count\" description=\"The number of Java threads stalled by the GC locker\" \/>\n-  <\/Event>\n-\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -901,6 +901,0 @@\n-    <event name=\"jdk.GCLocker\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">1 s<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -901,6 +901,0 @@\n-    <event name=\"jdk.GCLocker\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">100 ms<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -174,2 +174,0 @@\n-vmTestbase\/gc\/lock\/jni\/jnilock002\/TestDescription.java 8192647 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-    public static final String GCLocker = PREFIX + \"GCLocker\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}