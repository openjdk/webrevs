{"files":[{"patch":"@@ -1876,1 +1876,1 @@\n-  } else if (cause == GCCause::_gc_locker || cause == GCCause::_wb_young_gc\n+  } else if (cause == GCCause::_wb_young_gc\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+  GCLocker::initialize();\n@@ -291,1 +292,0 @@\n-  uint gclocker_stalled_count = 0;\n@@ -321,27 +321,0 @@\n-\n-      if (gclocker_stalled_count > GCLockerRetryAllocationCount) {\n-        return nullptr;\n-      }\n-\n-      \/\/ Failed to allocate without a gc.\n-      if (GCLocker::is_active_and_needs_gc()) {\n-        \/\/ If this thread is not in a jni critical section, we stall\n-        \/\/ the requestor until the critical section has cleared and\n-        \/\/ GC allowed. When the critical section clears, a GC is\n-        \/\/ initiated by the last thread exiting the critical section; so\n-        \/\/ we retry the allocation sequence from the beginning of the loop,\n-        \/\/ rather than causing more, now probably unnecessary, GC attempts.\n-        JavaThread* jthr = JavaThread::current();\n-        if (!jthr->in_critical()) {\n-          MutexUnlocker mul(Heap_lock);\n-          GCLocker::stall_until_clear();\n-          gclocker_stalled_count += 1;\n-          continue;\n-        } else {\n-          if (CheckJNICalls) {\n-            fatal(\"Possible deadlock due to allocating while\"\n-                  \" in jni critical section\");\n-          }\n-          return nullptr;\n-        }\n-      }\n@@ -350,2 +323,2 @@\n-    if (result == nullptr) {\n-      \/\/ Generate a VM operation\n+    assert(result == nullptr, \"inv\");\n+    {\n@@ -361,7 +334,0 @@\n-        \/\/ If GC was locked out during VM operation then retry allocation\n-        \/\/ and\/or stall as necessary.\n-        if (op.gc_locked()) {\n-          assert(op.result() == nullptr, \"must be null if gc_locked() is true\");\n-          continue;  \/\/ retry and\/or stall as necessary\n-        }\n-\n@@ -419,2 +385,2 @@\n-  if (!should_alloc_in_eden(size) || GCLocker::is_active_and_needs_gc()) {\n-    \/\/ Size is too big for eden, or gc is locked out.\n+  if (!should_alloc_in_eden(size)) {\n+    \/\/ Size is too big for eden.\n@@ -428,3 +394,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n-  }\n@@ -449,5 +412,0 @@\n-  GCLocker::check_active_before_gc();\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    return expand_heap_and_allocate(size, is_tlab);\n-  }\n-\n@@ -547,4 +505,0 @@\n-  if (GCLocker::should_discard(cause, gc_count)) {\n-    return;\n-  }\n-\n@@ -565,12 +519,0 @@\n-\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      GCLocker::stall_until_clear();\n-    }\n-  }\n-}\n-\n-void ParallelScavengeHeap::try_collect_at_safepoint(bool full) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n@@ -578,1 +520,0 @@\n-  collect_at_safepoint(full);\n@@ -892,1 +833,1 @@\n-  GCLocker::lock_critical(thread);\n+  GCLocker::enter(thread);\n@@ -896,1 +837,1 @@\n-  GCLocker::unlock_critical(thread);\n+  GCLocker::exit(thread);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -98,2 +98,0 @@\n-  void collect_at_safepoint(bool full);\n-\n@@ -201,1 +199,1 @@\n-  void try_collect_at_safepoint(bool full);\n+  void collect_at_safepoint(bool full);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,3 +220,0 @@\n-  if (success && GCLocker::is_active_and_needs_gc()) {\n-    log_debug(gc)(\"Garbage collection disabled, expanded heap instead\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -996,4 +996,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,4 +46,0 @@\n-\n-  if (_result == nullptr && GCLocker::is_active_and_needs_gc()) {\n-    set_gc_locked();\n-  }\n@@ -53,1 +49,1 @@\n-  return (cause != GCCause::_gc_locker) && (cause != GCCause::_wb_young_gc)\n+  return (cause != GCCause::_wb_young_gc)\n@@ -67,1 +63,1 @@\n-  heap->try_collect_at_safepoint(_full);\n+  heap->collect_at_safepoint(_full);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -370,12 +370,0 @@\n-  \/\/ Do not attempt an expand-to-the reserve size.  The\n-  \/\/ request should properly observe the maximum size of\n-  \/\/ the generation so an expand-to-reserve should be\n-  \/\/ unnecessary.  Also a second call to expand-to-reserve\n-  \/\/ value potentially can cause an undue expansion.\n-  \/\/ For example if the first expand fail for unknown reasons,\n-  \/\/ but the second succeeds and expands the heap to its maximum\n-  \/\/ value.\n-  if (GCLocker::is_active()) {\n-    log_debug(gc)(\"Garbage collection disabled, expanded heap instead\");\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  GCLocker::initialize();\n@@ -170,1 +171,1 @@\n-  GCLocker::lock_critical(thread);\n+  GCLocker::enter(thread);\n@@ -174,1 +175,1 @@\n-  GCLocker::unlock_critical(thread);\n+  GCLocker::exit(thread);\n@@ -285,1 +286,0 @@\n-\/\/ . gc locker is occupied (jni critical section)\n@@ -290,1 +290,0 @@\n-         || GCLocker::is_active_and_needs_gc()\n@@ -309,3 +308,1 @@\n-HeapWord* SerialHeap::mem_allocate_work(size_t size,\n-                                        bool is_tlab) {\n-\n+HeapWord* SerialHeap::mem_allocate_work(size_t size, bool is_tlab) {\n@@ -315,2 +312,1 @@\n-  for (uint try_count = 1, gclocker_stalled_count = 0; \/* return or throw *\/; try_count += 1) {\n-\n+  for (uint try_count = 1; \/* return or throw *\/; try_count += 1) {\n@@ -340,39 +336,0 @@\n-      if (GCLocker::is_active_and_needs_gc()) {\n-        if (is_tlab) {\n-          return nullptr;  \/\/ Caller will retry allocating individual object.\n-        }\n-        if (!is_maximal_no_gc()) {\n-          \/\/ Try and expand heap to satisfy request.\n-          result = expand_heap_and_allocate(size, is_tlab);\n-          \/\/ Result could be null if we are out of space.\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-\n-        if (gclocker_stalled_count > GCLockerRetryAllocationCount) {\n-          return nullptr; \/\/ We didn't get to do a GC and we didn't get any memory.\n-        }\n-\n-        \/\/ If this thread is not in a jni critical section, we stall\n-        \/\/ the requestor until the critical section has cleared and\n-        \/\/ GC allowed. When the critical section clears, a GC is\n-        \/\/ initiated by the last thread exiting the critical section; so\n-        \/\/ we retry the allocation sequence from the beginning of the loop,\n-        \/\/ rather than causing more, now probably unnecessary, GC attempts.\n-        JavaThread* jthr = JavaThread::current();\n-        if (!jthr->in_critical()) {\n-          MutexUnlocker mul(Heap_lock);\n-          \/\/ Wait for JNI critical section to be exited\n-          GCLocker::stall_until_clear();\n-          gclocker_stalled_count += 1;\n-          continue;\n-        } else {\n-          if (CheckJNICalls) {\n-            fatal(\"Possible deadlock due to allocating while\"\n-                  \" in jni critical section\");\n-          }\n-          return nullptr;\n-        }\n-      }\n-\n@@ -387,4 +344,0 @@\n-      if (op.gc_locked()) {\n-         assert(result == nullptr, \"must be null if gc_locked() is true\");\n-         continue;  \/\/ Retry and\/or stall as necessary.\n-      }\n@@ -400,2 +353,2 @@\n-          log_warning(gc, ergo)(\"SerialHeap::mem_allocate_work retries %d times,\"\n-                                \" size=%zu %s\", try_count, size, is_tlab ? \"(TLAB)\" : \"\");\n+      log_warning(gc, ergo)(\"SerialHeap::mem_allocate_work retries %d times,\"\n+                            \" size=%zu %s\", try_count, size, is_tlab ? \"(TLAB)\" : \"\");\n@@ -520,10 +473,0 @@\n-  GCLocker::check_active_before_gc();\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    \/\/ GC locker is active; instead of a collection we will attempt\n-    \/\/ to expand the heap, if there's room for expansion.\n-    if (!is_maximal_no_gc()) {\n-      result = expand_heap_and_allocate(size, is_tlab);\n-    }\n-    return result;   \/\/ Could be null if we are out of space.\n-  }\n-\n@@ -553,1 +496,1 @@\n-    do_full_collection_no_gc_locker(clear_all_soft_refs);\n+    do_full_collection(clear_all_soft_refs);\n@@ -635,8 +578,0 @@\n-void SerialHeap::try_collect_at_safepoint(bool full) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n-  }\n-  collect_at_safepoint(full);\n-}\n-\n@@ -654,1 +589,1 @@\n-  do_full_collection_no_gc_locker(clear_soft_refs);\n+  do_full_collection(clear_soft_refs);\n@@ -672,4 +607,0 @@\n-  if (GCLocker::should_discard(cause, gc_count_before)) {\n-    return;\n-  }\n-\n@@ -677,1 +608,0 @@\n-                           || (cause == GCCause::_gc_locker)\n@@ -686,1 +616,0 @@\n-\n@@ -698,5 +627,0 @@\n-\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      GCLocker::stall_until_clear();\n-    }\n@@ -707,7 +631,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return;\n-  }\n-  do_full_collection_no_gc_locker(clear_all_soft_refs);\n-}\n-\n-void SerialHeap::do_full_collection_no_gc_locker(bool clear_all_soft_refs) {\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":9,"deletions":92,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -111,3 +111,0 @@\n-  void do_full_collection_no_gc_locker(bool clear_all_soft_refs);\n-\n-  void collect_at_safepoint(bool full);\n@@ -150,1 +147,1 @@\n-  void try_collect_at_safepoint(bool full);\n+  void collect_at_safepoint(bool full);\n@@ -260,2 +257,1 @@\n-  HeapWord* mem_allocate_work(size_t size,\n-                              bool is_tlab);\n+  HeapWord* mem_allocate_work(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-\n-  if (_result == nullptr && GCLocker::is_active_and_needs_gc()) {\n-    set_gc_locked();\n-  }\n@@ -42,1 +38,1 @@\n-  gch->try_collect_at_safepoint(_full);\n+  gch->collect_at_safepoint(_full);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,3 +103,0 @@\n-  if (success && GCLocker::is_active_and_needs_gc()) {\n-    log_trace(gc, heap)(\"Garbage collection disabled, expanded heap instead\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n+#include \"gc\/shared\/gcLocker.hpp\"\n@@ -353,26 +353,0 @@\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If the GCLocker is active, just expand and allocate.\n-      \/\/ If that does not succeed, wait if this thread is not\n-      \/\/ in a critical section itself.\n-      result = loader_data->metaspace_non_null()->expand_and_allocate(word_size, mdtype);\n-      if (result != nullptr) {\n-        return result;\n-      }\n-      JavaThread* jthr = JavaThread::current();\n-      if (!jthr->in_critical()) {\n-        \/\/ Wait for JNI critical section to be exited\n-        GCLocker::stall_until_clear();\n-        \/\/ The GC invoked by the last thread leaving the critical\n-        \/\/ section will be a young collection and a full collection\n-        \/\/ is (currently) needed for unloading classes so continue\n-        \/\/ to the next iteration to get a full GC.\n-        continue;\n-      } else {\n-        if (CheckJNICalls) {\n-          fatal(\"Possible deadlock due to allocating while\"\n-                \" in jni critical section\");\n-        }\n-        return nullptr;\n-      }\n-    }\n-\n@@ -381,2 +355,2 @@\n-      gc_count      = Universe::heap()->total_collections();\n-      full_gc_count = Universe::heap()->total_full_collections();\n+      gc_count      = total_collections();\n+      full_gc_count = total_full_collections();\n@@ -392,1 +366,0 @@\n-    VMThread::execute(&op);\n@@ -394,5 +367,1 @@\n-    \/\/ If GC was locked out, try again. Check before checking success because the\n-    \/\/ prologue could have succeeded and the GC still have been locked out.\n-    if (op.gc_locked()) {\n-      continue;\n-    }\n+    VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":4,"deletions":35,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-    case _gc_locker:\n-      return \"GCLocker Initiated GC\";\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    _gc_locker,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -37,4 +39,0 @@\n-volatile jint GCLocker::_jni_lock_count = 0;\n-volatile bool GCLocker::_needs_gc       = false;\n-unsigned int GCLocker::_total_collections = 0;\n-\n@@ -49,1 +47,3 @@\n-    _start = Ticks::now();\n+    if (log_is_enabled(Debug, gc, jni)) {\n+      _start = Ticks::now();\n+    }\n@@ -62,3 +62,2 @@\n-#ifdef ASSERT\n-volatile jint GCLocker::_debug_jni_lock_count = 0;\n-#endif\n+Monitor* GCLocker::_lock;\n+volatile bool GCLocker::_is_gc_request_pending;\n@@ -66,0 +65,1 @@\n+DEBUG_ONLY(uint64_t GCLocker::_verify_in_cr_count;)\n@@ -67,20 +67,12 @@\n-#ifdef ASSERT\n-void GCLocker::verify_critical_count() {\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, \"must agree\");\n-    int count = 0;\n-    \/\/ Count the number of threads with critical operations in progress\n-    JavaThreadIteratorWithHandle jtiwh;\n-    for (; JavaThread *thr = jtiwh.next(); ) {\n-      if (thr->in_critical()) {\n-        count++;\n-      }\n-    }\n-    if (_jni_lock_count != count) {\n-      log_error(gc, verify)(\"critical counts don't match: %d != %d\", _jni_lock_count, count);\n-      jtiwh.rewind();\n-      for (; JavaThread *thr = jtiwh.next(); ) {\n-        if (thr->in_critical()) {\n-          log_error(gc, verify)(PTR_FORMAT \" in_critical %d\", p2i(thr), thr->in_critical());\n-        }\n-      }\n+void GCLocker::initialize() {\n+  assert(Heap_lock != nullptr, \"inv\");\n+  _lock = Heap_lock;\n+  _is_gc_request_pending = false;\n+\n+  DEBUG_ONLY(_verify_in_cr_count = 0;)\n+}\n+\n+bool GCLocker::is_active() {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *cur = jtiwh.next(); \/* empty *\/) {\n+    if (cur->in_critical()) {\n+      return true;\n@@ -88,1 +80,0 @@\n-    assert(_jni_lock_count == count, \"must be equal\");\n@@ -90,0 +81,1 @@\n+  return false;\n@@ -92,5 +84,3 @@\n-\/\/ In debug mode track the locking state at all times\n-void GCLocker::increment_debug_jni_lock_count() {\n-  assert(_debug_jni_lock_count >= 0, \"bad value\");\n-  Atomic::inc(&_debug_jni_lock_count);\n-}\n+void GCLocker::block() {\n+  assert(_lock->is_locked(), \"precondition\");\n+  assert(Atomic::load(&_is_gc_request_pending) == false, \"precondition\");\n@@ -98,5 +88,1 @@\n-void GCLocker::decrement_debug_jni_lock_count() {\n-  assert(_debug_jni_lock_count > 0, \"bad value\");\n-  Atomic::dec(&_debug_jni_lock_count);\n-}\n-#endif\n+  GCLockerTimingDebugLogger logger(\"Thread blocked to start GC.\");\n@@ -104,7 +90,1 @@\n-void GCLocker::log_debug_jni(const char* msg) {\n-  Log(gc, jni) log;\n-  if (log.is_debug()) {\n-    ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n-    log.debug(\"%s Thread \\\"%s\\\" %d locked.\", msg, Thread::current()->name(), _jni_lock_count);\n-  }\n-}\n+  Atomic::store(&_is_gc_request_pending, true);\n@@ -112,3 +92,7 @@\n-bool GCLocker::is_at_safepoint() {\n-  return SafepointSynchronize::is_at_safepoint();\n-}\n+  \/\/ The _is_gc_request_pending and _jni_active_critical (inside\n+  \/\/ in_critical()) variables form a Dekker duality. On the GC side, the\n+  \/\/ _is_gc_request_pending is set and _jni_active_critical is subsequently\n+  \/\/ loaded. For Java threads, the opposite is true, just like a Dekker lock.\n+  \/\/ That's why there is a fence to order the accesses involved in the Dekker\n+  \/\/ synchronization.\n+  OrderAccess::fence();\n@@ -116,10 +100,2 @@\n-bool GCLocker::check_active_before_gc() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"only read at safepoint\");\n-  if (is_active() && !_needs_gc) {\n-    verify_critical_count();\n-    _needs_gc = true;\n-    GCLockerTracer::start_gc_locker(_jni_lock_count);\n-    log_debug_jni(\"Setting _needs_gc.\");\n-  }\n-  return is_active();\n-}\n+  JavaThread* java_thread = JavaThread::current();\n+  ThreadBlockInVM tbivm(java_thread);\n@@ -127,11 +103,5 @@\n-void GCLocker::stall_until_clear() {\n-  assert(!JavaThread::current()->in_critical(), \"Would deadlock\");\n-  MonitorLocker ml(JNICritical_lock);\n-\n-  if (needs_gc()) {\n-    GCLockerTracer::inc_stall_count();\n-    log_debug_jni(\"Allocation failed. Thread stalled by JNI critical section.\");\n-    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n-    \/\/ Wait for _needs_gc to be cleared\n-    while (needs_gc()) {\n-      ml.wait();\n+  \/\/ Wait for threads leaving critical section\n+  SpinYield spin_yield;\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *cur = jtiwh.next(); \/* empty *\/) {\n+    while (cur->in_critical()) {\n+      spin_yield.wait();\n@@ -140,1 +110,0 @@\n-}\n@@ -142,3 +111,5 @@\n-bool GCLocker::should_discard(GCCause::Cause cause, uint total_collections) {\n-  return (cause == GCCause::_gc_locker) &&\n-         (_total_collections != total_collections);\n+#ifdef ASSERT\n+  \/\/ Matching the storestore in GCLocker::exit.\n+  OrderAccess::loadload();\n+  assert(Atomic::load(&_verify_in_cr_count) == 0, \"inv\");\n+#endif\n@@ -147,22 +118,5 @@\n-void GCLocker::jni_lock(JavaThread* thread) {\n-  assert(!thread->in_critical(), \"shouldn't currently be in a critical region\");\n-  MonitorLocker ml(JNICritical_lock);\n-  \/\/ Block entering threads if there's a pending GC request.\n-  if (needs_gc()) {\n-    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n-    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n-    while (needs_gc()) {\n-      \/\/ There's at least one thread that has not left the critical region (CR)\n-      \/\/ completely. When that last thread (no new threads can enter CR due to the\n-      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-      \/\/ to false and wakes up all blocked threads.\n-      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-      \/\/ in the code, but it's too strong; it's possible that the last thread\n-      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-      \/\/ a GCCause::_gc_locker GC.\n-      ml.wait();\n-    }\n-  }\n-  thread->enter_critical();\n-  _jni_lock_count++;\n-  increment_debug_jni_lock_count();\n+void GCLocker::unblock() {\n+  assert(_lock->is_locked(), \"precondition\");\n+  assert(Atomic::load(&_is_gc_request_pending) == true, \"precondition\");\n+\n+  Atomic::store(&_is_gc_request_pending, false);\n@@ -171,16 +125,3 @@\n-void GCLocker::jni_unlock(JavaThread* thread) {\n-  assert(thread->in_last_critical(), \"should be exiting critical region\");\n-  MutexLocker mu(JNICritical_lock);\n-  _jni_lock_count--;\n-  decrement_debug_jni_lock_count();\n-  log_debug_jni(\"Thread exiting critical region.\");\n-  thread->exit_critical();\n-  if (needs_gc() && !is_active_internal()) {\n-    \/\/ We're the last thread out. Request a GC.\n-    \/\/ Capture the current total collections, to allow detection of\n-    \/\/ other collections that make this one unnecessary.  The value of\n-    \/\/ total_collections() is only changed at a safepoint, so there\n-    \/\/ must not be a safepoint between the lock becoming inactive and\n-    \/\/ getting the count, else there may be unnecessary GCLocker GCs.\n-    _total_collections = Universe::heap()->total_collections();\n-    GCLockerTracer::report_gc_locker();\n+void GCLocker::enter_slow(JavaThread* thread) {\n+  GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+  while (true) {\n@@ -188,4 +129,3 @@\n-      \/\/ Must give up the lock while at a safepoint\n-      MutexUnlocker munlock(JNICritical_lock);\n-      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n-      Universe::heap()->collect(GCCause::_gc_locker);\n+      \/\/ There is a pending gc request and _lock is locked. Wait for the\n+      \/\/ completion of a gc. It's enough to do an empty locker section.\n+      MutexLocker locker(_lock);\n@@ -193,2 +133,11 @@\n-    _needs_gc = false;\n-    JNICritical_lock->notify_all();\n+\n+    thread->enter_critical();\n+\n+    \/\/ Same as fast path.\n+    OrderAccess::fence();\n+\n+    if (!Atomic::load(&_is_gc_request_pending)) {\n+      return;\n+    }\n+\n+    thread->exit_critical();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":67,"deletions":118,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -30,7 +30,13 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class JavaThread;\n-\n-\/\/ The direct lock\/unlock calls do not force a collection if an unlock\n-\/\/ decrements the count to zero. Avoid calling these if at all possible.\n+#include \"runtime\/mutex.hpp\"\n+\n+\/\/ GCLocker provides synchronization between the garbage collector (GC) and\n+\/\/ threads using JNI critical APIs. When threads enter a critical region (CR),\n+\/\/ certain GC implementations may suspend garbage collection until all such\n+\/\/ threads have exited.\n+\/\/\n+\/\/ Threads that need to trigger a GC should use the `block()` and `unblock()`\n+\/\/ APIs. `block()` will block the caller and prevent new threads from entering\n+\/\/ the CR.\n+\/\/\n+\/\/ Threads entering or exiting a CR must call the `enter` and `exit` APIs to\n+\/\/ ensure proper synchronization with the GC.\n@@ -39,9 +45,2 @@\n- private:\n-  \/\/ The _jni_lock_count keeps track of the number of threads that are\n-  \/\/ currently in a critical region.  It's only kept up to date when\n-  \/\/ _needs_gc is true.  The current value is computed during\n-  \/\/ safepointing and decremented during the slow path of GCLocker\n-  \/\/ unlocking.\n-  static volatile jint _jni_lock_count;  \/\/ number of jni active instances.\n-  static volatile bool _needs_gc;        \/\/ heap is filling, we need a GC\n-  static uint _total_collections;        \/\/ value for _gc_locker collection\n+  static Monitor* _lock;\n+  static volatile bool _is_gc_request_pending;\n@@ -50,3 +49,2 @@\n-  \/\/ This lock count is updated for all operations and is used to\n-  \/\/ validate the jni_lock_count that is computed during safepoints.\n-  static volatile jint _debug_jni_lock_count;\n+  \/\/ Debug-only: to track the number of java threads in critical-region.\n+  static uint64_t _verify_in_cr_count;\n@@ -54,0 +52,1 @@\n+  static void enter_slow(JavaThread* thread);\n@@ -55,45 +54,2 @@\n-  \/\/ At a safepoint, visit all threads and count the number of active\n-  \/\/ critical sections.  This is used to ensure that all active\n-  \/\/ critical sections are exited before a new one is started.\n-  static void verify_critical_count() NOT_DEBUG_RETURN;\n-\n-  static void jni_lock(JavaThread* thread);\n-  static void jni_unlock(JavaThread* thread);\n-\n-  static bool is_active_internal() {\n-    verify_critical_count();\n-    return _jni_lock_count > 0;\n-  }\n-\n-  static void log_debug_jni(const char* msg);\n-\n-  static bool is_at_safepoint();\n-\n- public:\n-  \/\/ Accessors\n-  static bool is_active() {\n-    assert(GCLocker::is_at_safepoint(), \"only read at safepoint\");\n-    return is_active_internal();\n-  }\n-  static bool needs_gc()       { return _needs_gc;                        }\n-\n-  \/\/ Shorthand\n-  static bool is_active_and_needs_gc() {\n-    \/\/ Use is_active_internal since _needs_gc can change from true to\n-    \/\/ false outside of a safepoint, triggering the assert in\n-    \/\/ is_active.\n-    return needs_gc() && is_active_internal();\n-  }\n-\n-  \/\/ In debug mode track the locking state at all times\n-  static void increment_debug_jni_lock_count() NOT_DEBUG_RETURN;\n-  static void decrement_debug_jni_lock_count() NOT_DEBUG_RETURN;\n-\n-  \/\/ Set the current lock count\n-  static void set_jni_lock_count(int count) {\n-    _jni_lock_count = count;\n-    verify_critical_count();\n-  }\n-\n-  \/\/ Sets _needs_gc if is_active() is true. Returns is_active().\n-  static bool check_active_before_gc();\n+public:\n+  static void initialize();\n@@ -101,5 +57,2 @@\n-  \/\/ Return true if the designated collection is a GCLocker request\n-  \/\/ that should be discarded.  Returns true if cause == GCCause::_gc_locker\n-  \/\/ and the given total collection value indicates a collection has been\n-  \/\/ done since the GCLocker request was made.\n-  static bool should_discard(GCCause::Cause cause, uint total_collections);\n+  \/\/ To query current GCLocker state. Can become outdated if called outside a safepoint.\n+  static bool is_active();\n@@ -107,7 +60,3 @@\n-  \/\/ Stalls the caller (who should not be in a jni critical section)\n-  \/\/ until needs_gc() clears. Note however that needs_gc() may be\n-  \/\/ set at a subsequent safepoint and\/or cleared under the\n-  \/\/ JNICritical_lock, so the caller may not safely assert upon\n-  \/\/ return from this method that \"!needs_gc()\" since that is\n-  \/\/ not a stable predicate.\n-  static void stall_until_clear();\n+  \/\/ For use by Java threads requesting GC.\n+  static void block();\n+  static void unblock();\n@@ -115,35 +64,3 @@\n-  \/\/ The following two methods are used for JNI critical regions.\n-  \/\/ If we find that we failed to perform a GC because the GCLocker\n-  \/\/ was active, arrange for one as soon as possible by allowing\n-  \/\/ all threads in critical regions to complete, but not allowing\n-  \/\/ other critical regions to be entered. The reasons for that are:\n-  \/\/ 1) a GC request won't be starved by overlapping JNI critical\n-  \/\/    region activities, which can cause unnecessary OutOfMemory errors.\n-  \/\/ 2) even if allocation requests can still be satisfied before GC locker\n-  \/\/    becomes inactive, for example, in tenured generation possibly with\n-  \/\/    heap expansion, those allocations can trigger lots of safepointing\n-  \/\/    attempts (ineffective GC attempts) and require Heap_lock which\n-  \/\/    slow down allocations tremendously.\n-  \/\/\n-  \/\/ Note that critical regions can be nested in a single thread, so\n-  \/\/ we must allow threads already in critical regions to continue.\n-  \/\/\n-  \/\/ JNI critical regions are the only participants in this scheme\n-  \/\/ because they are, by spec, well bounded while in a critical region.\n-  \/\/\n-  \/\/ Each of the following two method is split into a fast path and a\n-  \/\/ slow path. JNICritical_lock is only grabbed in the slow path.\n-  \/\/ _needs_gc is initially false and every java thread will go\n-  \/\/ through the fast path, which simply increments or decrements the\n-  \/\/ current thread's critical count.  When GC happens at a safepoint,\n-  \/\/ GCLocker::is_active() is checked. Since there is no safepoint in\n-  \/\/ the fast path of lock_critical() and unlock_critical(), there is\n-  \/\/ no race condition between the fast path and GC. After _needs_gc\n-  \/\/ is set at a safepoint, every thread will go through the slow path\n-  \/\/ after the safepoint.  Since after a safepoint, each of the\n-  \/\/ following two methods is either entered from the method entry and\n-  \/\/ falls into the slow path, or is resumed from the safepoints in\n-  \/\/ the method, which only exist in the slow path. So when _needs_gc\n-  \/\/ is set, the slow path is always taken, till _needs_gc is cleared.\n-  inline static void lock_critical(JavaThread* thread);\n-  inline static void unlock_critical(JavaThread* thread);\n+  \/\/ For use by Java threads entering\/leaving critical-region.\n+  inline static void enter(JavaThread* thread);\n+  inline static void exit(JavaThread* thread);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":28,"deletions":111,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n-void GCLocker::lock_critical(JavaThread* thread) {\n+void GCLocker::enter(JavaThread* thread) {\n+  assert(thread == JavaThread::current(), \"Must be this thread\");\n+\n@@ -34,5 +36,9 @@\n-    if (needs_gc()) {\n-      \/\/ jni_lock call calls enter_critical under the lock so that the\n-      \/\/ global lock count and per thread count are in agreement.\n-      jni_lock(thread);\n-      return;\n+    thread->enter_critical();\n+\n+    \/\/ Matching the fence in GCLocker::block.\n+    OrderAccess::fence();\n+\n+    if (Atomic::load(&_is_gc_request_pending)) {\n+      thread->exit_critical();\n+      \/\/ slow-path\n+      enter_slow(thread);\n@@ -40,1 +46,4 @@\n-    increment_debug_jni_lock_count();\n+\n+    DEBUG_ONLY(Atomic::add(&_verify_in_cr_count, (uint64_t)1);)\n+  } else {\n+    thread->enter_critical();\n@@ -42,1 +51,0 @@\n-  thread->enter_critical();\n@@ -45,1 +53,4 @@\n-void GCLocker::unlock_critical(JavaThread* thread) {\n+void GCLocker::exit(JavaThread* thread) {\n+  assert(thread == JavaThread::current(), \"Must be this thread\");\n+\n+#ifdef ASSERT\n@@ -47,7 +58,3 @@\n-    if (needs_gc()) {\n-      \/\/ jni_unlock call calls exit_critical under the lock so that\n-      \/\/ the global lock count and per thread count are in agreement.\n-      jni_unlock(thread);\n-      return;\n-    }\n-    decrement_debug_jni_lock_count();\n+    Atomic::add(&_verify_in_cr_count, (uint64_t)-1);\n+    \/\/ Matching the loadload in GCLocker::block.\n+    OrderAccess::storestore();\n@@ -55,0 +62,2 @@\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -215,15 +215,0 @@\n-class GCLockerTracer : public AllStatic {\n-#if INCLUDE_JFR\n-private:\n-  static Ticks _needs_gc_start_timestamp;\n-  static volatile jint _jni_lock_count;\n-  static volatile jint _stall_count;\n-#endif\n-\n-  static bool is_started() NOT_JFR_RETURN_(false);\n-\n-public:\n-  static void start_gc_locker(jint jni_lock_count) NOT_JFR_RETURN();\n-  static void inc_stall_count() NOT_JFR_RETURN();\n-  static void report_gc_locker() NOT_JFR_RETURN();\n-};\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -361,46 +361,0 @@\n-\n-#if INCLUDE_JFR\n-Ticks GCLockerTracer::_needs_gc_start_timestamp;\n-volatile jint GCLockerTracer::_jni_lock_count = 0;\n-volatile jint GCLockerTracer::_stall_count = 0;\n-\n-bool GCLockerTracer::is_started() {\n-  return _needs_gc_start_timestamp != Ticks();\n-}\n-\n-void GCLockerTracer::start_gc_locker(const jint jni_lock_count) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n-  assert(!is_started(), \"sanity\");\n-  assert(_jni_lock_count == 0, \"sanity\");\n-  assert(_stall_count == 0, \"sanity\");\n-  if (EventGCLocker::is_enabled()) {\n-    _needs_gc_start_timestamp.stamp();\n-    _jni_lock_count = jni_lock_count;\n-  }\n-}\n-\n-void GCLockerTracer::inc_stall_count() {\n-  if (is_started()) {\n-    _stall_count++;\n-  }\n-}\n-\n-void GCLockerTracer::report_gc_locker() {\n-  if (is_started()) {\n-    EventGCLocker event(UNTIMED);\n-    if (event.should_commit()) {\n-      event.set_starttime(_needs_gc_start_timestamp);\n-      event.set_endtime(_needs_gc_start_timestamp);\n-      event.set_lockCount(_jni_lock_count);\n-      event.set_stallCount(_stall_count);\n-      event.commit();\n-    }\n-    \/\/ reset\n-    _needs_gc_start_timestamp = Ticks();\n-    _jni_lock_count = 0;\n-    _stall_count = 0;\n-\n-    assert(!is_started(), \"sanity\");\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-\/\/ In case a GC locker is active and the need for a GC is already signaled,\n-\/\/ we want to skip this GC attempt altogether, without doing a futile\n-\/\/ safepoint operation.\n@@ -96,5 +93,0 @@\n-  if (!skip && GCLocker::is_active_and_needs_gc()) {\n-    skip = Universe::heap()->is_maximal_no_gc();\n-    assert(!(skip && (_gc_cause == GCCause::_gc_locker)),\n-           \"GCLocker cannot be active when initiating GC\");\n-  }\n@@ -125,0 +117,3 @@\n+    if (UseSerialGC || UseParallelGC) {\n+      GCLocker::block();\n+    }\n@@ -132,0 +127,3 @@\n+  if (UseSerialGC || UseParallelGC) {\n+    GCLocker::unblock();\n+  }\n@@ -262,4 +260,0 @@\n-\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    set_gc_locked();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  bool           _gc_locked;               \/\/ will be set if gc was locked\n@@ -126,2 +125,0 @@\n-    _gc_locked = false;\n-\n@@ -151,3 +148,0 @@\n-  void set_gc_locked() { _gc_locked = true; }\n-  bool gc_locked() const  { return _gc_locked; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-  product(uintx, GCLockerRetryAllocationCount, 2, DIAGNOSTIC,               \\\n-          \"Number of times to retry allocations when \"                      \\\n-          \"blocked by the GC locker\")                                       \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1244,5 +1244,0 @@\n-  <Event name=\"GCLocker\" category=\"Java Virtual Machine, GC, Detailed\" label=\"GC Locker\" startTime=\"true\" thread=\"true\" stackTrace=\"true\">\n-    <Field type=\"uint\" name=\"lockCount\" label=\"Lock Count\" description=\"The number of Java threads in a critical section when the GC locker is started\" \/>\n-    <Field type=\"uint\" name=\"stallCount\" label=\"Stall Count\" description=\"The number of Java threads stalled by the GC locker\" \/>\n-  <\/Event>\n-\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -2647,8 +2646,0 @@\n-WB_ENTRY(void, WB_LockCritical(JNIEnv* env, jobject wb))\n-  GCLocker::lock_critical(thread);\n-WB_END\n-\n-WB_ENTRY(void, WB_UnlockCritical(JNIEnv* env, jobject wb))\n-  GCLocker::unlock_critical(thread);\n-WB_END\n-\n@@ -2995,2 +2986,0 @@\n-  {CC\"lockCritical\",    CC\"()V\",                      (void*)&WB_LockCritical},\n-  {CC\"unlockCritical\",  CC\"()V\",                      (void*)&WB_UnlockCritical},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-Monitor* JNICritical_lock             = nullptr;\n@@ -342,1 +341,0 @@\n-  MUTEX_DEFL(JNICritical_lock               , PaddedMonitor, AdapterHandlerLibrary_lock); \/\/ used for JNI critical regions\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-extern Monitor* JNICritical_lock;                \/\/ a lock used while entering and exiting JNI critical regions, allows GC to sometimes get in\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -411,3 +411,0 @@\n-  \/\/ Update the count of active JNI critical regions\n-  GCLocker::set_jni_lock_count(_current_jni_active_count);\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  _gc_locker (\"GCLocker Initiated GC\"),\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GCCause.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -901,6 +901,0 @@\n-    <event name=\"jdk.GCLocker\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">1 s<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -901,6 +901,0 @@\n-    <event name=\"jdk.GCLocker\">\n-      <setting name=\"enabled\">true<\/setting>\n-      <setting name=\"threshold\">100 ms<\/setting>\n-      <setting name=\"stackTrace\">true<\/setting>\n-    <\/event>\n-\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-gc\/stress\/gclocker\/TestExcessGCLockerCollections.java 8229120 generic-all\n@@ -173,2 +172,0 @@\n-vmTestbase\/gc\/lock\/jni\/jnilock002\/TestDescription.java 8192647 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.stress.gclocker;\n-\n-\/*\n- * @test TestExcessGCLockerCollections\n- * @bug 8048556\n- * @summary Check for GC Locker initiated GCs that immediately follow another\n- * GC and so have very little needing to be collected.\n- * @requires vm.gc != \"Z\"\n- * @requires vm.gc != \"Epsilon\"\n- * @requires vm.gc != \"Shenandoah\"\n- * @requires vm.gc != \"G1\"\n- * @requires vm.gc != null\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @run driver\/timeout=1000 gc.stress.gclocker.TestExcessGCLockerCollections 300 4 2\n- *\/\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import java.util.zip.Deflater;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-class TestExcessGCLockerCollectionsAux {\n-    static private final int LARGE_MAP_SIZE = 64 * 1024;\n-\n-    static private final int MAP_ARRAY_LENGTH = 4;\n-    static private final int MAP_SIZE = 1024;\n-\n-    static private final int BYTE_ARRAY_LENGTH = 128 * 1024;\n-\n-    static private void println(String str) { System.out.println(str); }\n-\n-    static private volatile boolean keepRunning = true;\n-\n-    static Map<Integer,String> populateMap(int size) {\n-        Map<Integer,String> map = new HashMap<Integer,String>();\n-        for (int i = 0; i < size; i += 1) {\n-            Integer keyInt = Integer.valueOf(i);\n-            String valStr = \"value is [\" + i + \"]\";\n-            map.put(keyInt,valStr);\n-        }\n-        return map;\n-    }\n-\n-    static private class AllocatingWorker implements Runnable {\n-        private final Object[] array = new Object[MAP_ARRAY_LENGTH];\n-        private int arrayIndex = 0;\n-\n-        private void doStep() {\n-            Map<Integer,String> map = populateMap(MAP_SIZE);\n-            array[arrayIndex] = map;\n-            arrayIndex = (arrayIndex + 1) % MAP_ARRAY_LENGTH;\n-        }\n-\n-        public void run() {\n-            while (keepRunning) {\n-                doStep();\n-            }\n-        }\n-    }\n-\n-    static private class JNICriticalWorker implements Runnable {\n-        private int count;\n-\n-        private void doStep() {\n-            byte[] inputArray = new byte[BYTE_ARRAY_LENGTH];\n-            for (int i = 0; i < inputArray.length; i += 1) {\n-                inputArray[i] = (byte) (count + i);\n-            }\n-\n-            Deflater deflater = new Deflater();\n-            deflater.setInput(inputArray);\n-            deflater.finish();\n-\n-            byte[] outputArray = new byte[2 * inputArray.length];\n-            deflater.deflate(outputArray);\n-\n-            count += 1;\n-        }\n-\n-        public void run() {\n-            while (keepRunning) {\n-                doStep();\n-            }\n-        }\n-    }\n-\n-    static public Map<Integer,String> largeMap;\n-\n-    static public void main(String args[]) {\n-        long durationSec = Long.parseLong(args[0]);\n-        int allocThreadNum = Integer.parseInt(args[1]);\n-        int jniCriticalThreadNum = Integer.parseInt(args[2]);\n-\n-        println(\"Running for \" + durationSec + \" secs\");\n-\n-        largeMap = populateMap(LARGE_MAP_SIZE);\n-\n-        println(\"Starting \" + allocThreadNum + \" allocating threads\");\n-        for (int i = 0; i < allocThreadNum; i += 1) {\n-            new Thread(new AllocatingWorker()).start();\n-        }\n-\n-        println(\"Starting \" + jniCriticalThreadNum + \" jni critical threads\");\n-        for (int i = 0; i < jniCriticalThreadNum; i += 1) {\n-            new Thread(new JNICriticalWorker()).start();\n-        }\n-\n-        try {\n-            Thread.sleep(durationSec * 1000L);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Test Failure, did not expect an InterruptedException\", e);\n-        }\n-\n-        println(\"Done.\");\n-        keepRunning = false;\n-    }\n-}\n-\n-public class TestExcessGCLockerCollections {\n-    private static final String locker =\n-        \"\\\\[gc\\\\s*\\\\] .* \\\\(GCLocker Initiated GC\\\\)\";\n-    private static final String ANY_LOCKER = locker + \" [1-9][0-9]*M\";\n-    private static final String BAD_LOCKER = locker + \" [1-9][0-9]?M\";\n-\n-    private static final String[] COMMON_OPTIONS = new String[] {\n-        \"-Xmx1G\", \"-Xms1G\", \"-Xmn256M\", \"-Xlog:gc,gc+ergo*=debug,gc+ergo+cset=trace:x.log\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyAfterGC\"};\n-\n-    public static void main(String args[]) throws Exception {\n-        if (args.length < 3) {\n-            System.out.println(\"usage: TestExcessGCLockerCollectionsAux\" +\n-                               \" <duration sec> <alloc threads>\" +\n-                               \" <jni critical threads>\");\n-            throw new RuntimeException(\"Invalid arguments\");\n-        }\n-\n-        ArrayList<String> finalArgs = new ArrayList<String>();\n-        finalArgs.addAll(Arrays.asList(COMMON_OPTIONS));\n-        finalArgs.add(TestExcessGCLockerCollectionsAux.class.getName());\n-        finalArgs.addAll(Arrays.asList(args));\n-\n-        \/\/ GC and other options obtained from test framework.\n-        OutputAnalyzer output = ProcessTools.executeTestJava(finalArgs);\n-        output.shouldHaveExitValue(0);\n-        \/\/System.out.println(\"------------- begin stdout ----------------\");\n-        \/\/System.out.println(output.getStdout());\n-        \/\/System.out.println(\"------------- end stdout ----------------\");\n-        output.stdoutShouldMatch(ANY_LOCKER);\n-        output.stdoutShouldNotMatch(BAD_LOCKER);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestExcessGCLockerCollections.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -42,2 +42,1 @@\n-        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\",\n-                             \"CodeCache GC Threshold\"};\n+        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"CodeCache GC Threshold\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithParallelOld.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"GCLocker Initiated GC\",\n-                             \"CodeCache GC Threshold\"};\n+        String[] gcCauses = {\"Allocation Failure\", \"System.gc()\", \"CodeCache GC Threshold\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithSerial.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test TestGCLockerEvent\n- * @requires vm.flagless\n- * @requires vm.hasJFR\n- * @requires vm.gc.Serial | vm.gc.Parallel\n- * @requires vm.gc != null\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx32m -Xms32m -Xmn12m jdk.jfr.event.gc.detailed.TestGCLockerEvent\n- *\/\n-\n-package jdk.jfr.event.gc.detailed;\n-\n-import static jdk.test.lib.Asserts.assertTrue;\n-\n-import java.util.concurrent.CountDownLatch;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestGCLockerEvent {\n-\n-    private static final String EVENT_NAME = EventNames.GCLocker;\n-\n-    private static final int CRITICAL_THREAD_COUNT = 4;\n-\n-    private static final CountDownLatch LOCK_COUNT_SIGNAL = new CountDownLatch(CRITICAL_THREAD_COUNT);\n-\n-    private static final CountDownLatch UNLOCK_SIGNAL = new CountDownLatch(1);\n-\n-    private static final CountDownLatch UNLOCK_COUNT_SIGNAL = new CountDownLatch(CRITICAL_THREAD_COUNT);\n-\n-    private static final String CRITICAL_THREAD_NAME_PREFIX = \"Critical Thread \";\n-\n-    private static final int STALL_THREAD_COUNT = 8;\n-\n-    private static final CountDownLatch STALL_COUNT_SIGNAL = new CountDownLatch(STALL_THREAD_COUNT);\n-\n-    private static final int LOOP = 32;\n-\n-    private static final int M = 1024 * 1024;\n-\n-    public static void main(String[] args) throws Exception {\n-        var recording = new Recording();\n-        recording.enable(EVENT_NAME);\n-        recording.start();\n-\n-        startCriticalThreads();\n-        LOCK_COUNT_SIGNAL.await();\n-        startStallThreads();\n-        STALL_COUNT_SIGNAL.await();\n-\n-        \/\/ Wait threads to be stalled\n-        Thread.sleep(1500);\n-\n-        UNLOCK_SIGNAL.countDown();\n-        UNLOCK_COUNT_SIGNAL.await();\n-        recording.stop();\n-\n-        \/\/ Verify recording\n-        var all = Events.fromRecording(recording);\n-        Events.hasEvents(all);\n-        var event = all.getFirst();\n-\n-        assertTrue(Events.isEventType(event, EVENT_NAME));\n-        Events.assertField(event, \"lockCount\").equal(CRITICAL_THREAD_COUNT);\n-        Events.assertField(event, \"stallCount\").atLeast(STALL_THREAD_COUNT);\n-        assertTrue(event.getThread().getJavaName().startsWith(CRITICAL_THREAD_NAME_PREFIX));\n-\n-        recording.close();\n-    }\n-\n-    private static void startCriticalThreads() {\n-        for (var i = 0; i < CRITICAL_THREAD_COUNT; i++) {\n-            new Thread(() -> {\n-                try {\n-                    WhiteBox.getWhiteBox().lockCritical();\n-                    LOCK_COUNT_SIGNAL.countDown();\n-\n-                    UNLOCK_SIGNAL.await();\n-                    WhiteBox.getWhiteBox().unlockCritical();\n-                    UNLOCK_COUNT_SIGNAL.countDown();\n-                } catch (InterruptedException ex) {\n-                }\n-            }, CRITICAL_THREAD_NAME_PREFIX + i).start();\n-        }\n-    }\n-\n-    private static void startStallThreads() {\n-        var ts = new Thread[STALL_THREAD_COUNT];\n-        for (var i = 0; i < STALL_THREAD_COUNT; i++) {\n-            ts[i] = new Thread(() -> {\n-                STALL_COUNT_SIGNAL.countDown();\n-                for (int j = 0; j < LOOP; j++) {\n-                    byte[] bytes = new byte[M];\n-                }\n-            });\n-        }\n-        for (Thread t : ts) {\n-            t.start();\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestGCLockerEvent.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -154,1 +154,0 @@\n-    public static final String GCLocker = PREFIX + \"GCLocker\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -789,4 +789,0 @@\n-  public native void lockCritical();\n-\n-  public native void unlockCritical();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}