{"files":[{"patch":"@@ -119,0 +119,6 @@\n+        \/\/ A selection of trivial and common reflection operations\n+        var instance = HelloClasslist.class.getConstructor().newInstance();\n+        HelloClasslist.class.getMethod(\"staticMethod_V\").invoke(null);\n+        var obj = HelloClasslist.class.getMethod(\"staticMethod_L_L\", Object.class).invoke(null, instance);\n+        HelloClasslist.class.getField(\"field\").get(instance);\n+\n@@ -129,0 +135,4 @@\n+    public HelloClasslist() {}\n+\n+    public String field = \"someValue\";\n+\n@@ -131,0 +141,2 @@\n+    public static Object staticMethod_L_L(Object o) { return o; }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/HelloClasslist.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+      holder->is_in_package(\"java\/lang\/reflect\") || holder->is_in_package(\"jdk\/internal\/reflect\") ||\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -375,1 +376,1 @@\n-        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n+        return forName(className, caller);\n@@ -378,0 +379,6 @@\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(String className, Class<?> caller)\n+            throws ClassNotFoundException {\n+        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n+    }\n@@ -459,0 +466,14 @@\n+        }\n+        return forName(name, initialize, loader, caller);\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(String name, boolean initialize, ClassLoader loader, Class<?> caller)\n+            throws ClassNotFoundException\n+    {\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            \/\/ Reflective call to get caller class is only needed if a security manager\n+            \/\/ is present.  Avoid the overhead of making this call otherwise.\n@@ -463,1 +484,1 @@\n-                        SecurityConstants.GET_CLASSLOADER_PERMISSION);\n+                            SecurityConstants.GET_CLASSLOADER_PERMISSION);\n@@ -526,0 +547,12 @@\n+        Class<?> caller = null;\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            caller = Reflection.getCallerClass();\n+        }\n+        return forName(module, name, caller);\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @SuppressWarnings(\"removal\")\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(Module module, String name, Class<?> caller) {\n@@ -532,1 +565,0 @@\n-            Class<?> caller = Reflection.getCallerClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -1618,3 +1619,7 @@\n-        Class<? extends ClassLoader> callerClass =\n-            Reflection.getCallerClass().asSubclass(ClassLoader.class);\n-        return ParallelLoaders.register(callerClass);\n+        return registerAsParallelCapable(Reflection.getCallerClass());\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static boolean registerAsParallelCapable(Class<?> caller) {\n+        return ParallelLoaders.register(caller.asSubclass(ClassLoader.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.misc.VM;\n@@ -40,1 +39,0 @@\n-import java.lang.reflect.Constructor;\n@@ -49,0 +47,1 @@\n+import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n@@ -51,0 +50,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -60,1 +60,0 @@\n-    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n@@ -109,1 +108,1 @@\n-        MethodType classDataMType = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n+        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n@@ -230,37 +229,7 @@\n-        if (factoryType.parameterCount() == 0) {\n-            \/\/ In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,\n-            \/\/ unless we've suppressed eager initialization\n-            if (disableEagerInitialization) {\n-                try {\n-                    return new ConstantCallSite(caller.findStaticGetter(innerClass, LAMBDA_INSTANCE_FIELD,\n-                            factoryType.returnType()));\n-                } catch (ReflectiveOperationException e) {\n-                    throw new LambdaConversionException(\n-                            \"Exception finding \" +  LAMBDA_INSTANCE_FIELD + \" static field\", e);\n-                }\n-            } else {\n-                @SuppressWarnings(\"removal\")\n-                final Constructor<?>[] ctrs = AccessController.doPrivileged(\n-                        new PrivilegedAction<>() {\n-                            @Override\n-                            public Constructor<?>[] run() {\n-                                Constructor<?>[] ctrs = innerClass.getDeclaredConstructors();\n-                                if (ctrs.length == 1) {\n-                                    \/\/ The lambda implementing inner class constructor is private, set\n-                                    \/\/ it accessible (by us) before creating the constant sole instance\n-                                    ctrs[0].setAccessible(true);\n-                                }\n-                                return ctrs;\n-                            }\n-                        });\n-                if (ctrs.length != 1) {\n-                    throw new LambdaConversionException(\"Expected one lambda constructor for \"\n-                            + innerClass.getCanonicalName() + \", got \" + ctrs.length);\n-                }\n-\n-                try {\n-                    Object inst = ctrs[0].newInstance();\n-                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n-                } catch (ReflectiveOperationException e) {\n-                    throw new LambdaConversionException(\"Exception instantiating lambda object\", e);\n-                }\n+        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+            try {\n+                return new ConstantCallSite(caller.findStaticGetter(innerClass, LAMBDA_INSTANCE_FIELD,\n+                                                                    factoryType.returnType()));\n+            } catch (ReflectiveOperationException e) {\n+                throw new LambdaConversionException(\n+                        \"Exception finding \" + LAMBDA_INSTANCE_FIELD + \" static field\", e);\n@@ -271,1 +240,7 @@\n-                return new ConstantCallSite(mh.asType(factoryType));\n+                if (factoryType.parameterCount() == 0) {\n+                    \/\/ In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance\n+                    Object inst = mh.asType(methodType(Object.class)).invokeExact();\n+                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n+                } else {\n+                    return new ConstantCallSite(mh.asType(factoryType));\n+                }\n@@ -274,0 +249,2 @@\n+            } catch (Throwable e) {\n+                throw new LambdaConversionException(\"Exception instantiating lambda object\", e);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":19,"deletions":42,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.Set;\n@@ -319,1 +320,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile)\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of())\n@@ -379,1 +380,1 @@\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandleNatives\",\n+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\",\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n@@ -53,0 +55,1 @@\n+import java.util.Set;\n@@ -60,0 +63,1 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1033,0 +1037,1 @@\n+        private static MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n@@ -1045,0 +1050,34 @@\n+\n+            MemberName member = mh.internalMemberName();\n+            if (member != null) {\n+                \/\/ Look up the CSM adapter method with the same method name\n+                \/\/ but with an additional caller class parameter.  If present,\n+                \/\/ bind the adapter's method handle with the lookup class as\n+                \/\/ the caller class argument\n+                MemberName csmAdapter = IMPL_LOOKUP.resolveOrNull(member.getReferenceKind(),\n+                        new MemberName(member.getDeclaringClass(),\n+                                       member.getName(),\n+                                       member.getMethodType().appendParameterTypes(Class.class),\n+                                       member.getReferenceKind()));\n+                if (csmAdapter != null) {\n+                    assert !csmAdapter.isCallerSensitive();\n+                    MethodHandle dmh = DirectMethodHandle.make(csmAdapter);\n+                    dmh = MethodHandles.insertArguments(dmh, dmh.type().parameterCount() - 1, hostClass);\n+                    dmh = new WrappedMember(dmh, mh.type(), member, mh.isInvokeSpecial(), hostClass);\n+                    return dmh;\n+                }\n+            }\n+\n+            \/\/ If no adapter method for CSM with an additional Class parameter\n+            \/\/ is present, then inject an invoker class that is the caller\n+            \/\/ invoking the method handle of the CSM\n+            try {\n+                return bindCallerWithInjectedInvoker(mh, hostClass);\n+            } catch (ReflectiveOperationException ex) {\n+                throw uncaughtException(ex);\n+            }\n+        }\n+\n+        private static MethodHandle bindCallerWithInjectedInvoker(MethodHandle mh, Class<?> hostClass)\n+                throws ReflectiveOperationException\n+        {\n@@ -1048,1 +1087,1 @@\n-            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);\n+            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass).invoker();\n@@ -1052,2 +1091,1 @@\n-        private static MethodHandle makeInjectedInvoker(Class<?> targetClass) {\n-            try {\n+        private static Class<?> makeInjectedInvoker(Class<?> targetClass) {\n@@ -1067,2 +1105,2 @@\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE)\n-                        .defineClass(true);\n+                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE))\n+                        .defineClass(true, targetClass);\n@@ -1070,4 +1108,1 @@\n-                return IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n-            } catch (ReflectiveOperationException ex) {\n-                throw uncaughtException(ex);\n-            }\n+                return invokerClass;\n@@ -1076,3 +1111,4 @@\n-        private static ClassValue<MethodHandle> CV_makeInjectedInvoker = new ClassValue<MethodHandle>() {\n-            @Override protected MethodHandle computeValue(Class<?> hostClass) {\n-                return makeInjectedInvoker(hostClass);\n+        private static ClassValue<InjectedInvokerHolder> CV_makeInjectedInvoker = new ClassValue<>() {\n+            @Override\n+            protected InjectedInvokerHolder computeValue(Class<?> hostClass) {\n+                return new InjectedInvokerHolder(makeInjectedInvoker(hostClass));\n@@ -1082,0 +1118,61 @@\n+        \/*\n+         * Returns a method handle of an invoker class injected for reflection\n+         * implementation use with the following signature:\n+         *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+         *\n+         * Method::invoke on a caller-sensitive method will call\n+         * MethodAccessorImpl::invoke(Object, Object[]) through reflect_invoke_V\n+         *     target.csm(args)\n+         *     NativeMethodAccesssorImpl::invoke(target, args)\n+         *     MethodAccessImpl::invoke(target, args)\n+         *     InjectedInvoker::reflect_invoke_V(vamh, target, args);\n+         *     method::invoke(target, args)\n+         *     p.Foo::m\n+         *\n+         * An injected invoker class is a hidden class which has the same\n+         * defining class loader, runtime package, and protection domain\n+         * as the given caller class.\n+         *\/\n+        static MethodHandle reflectiveInvoker(Class<?> caller) {\n+            return BindCaller.CV_makeInjectedInvoker.get(caller).reflectInvoker();\n+        }\n+\n+        private static final class InjectedInvokerHolder {\n+            private final Class<?> invokerClass;\n+            \/\/ lazily resolved and cached DMH(s) of invoke_V methods\n+            private MethodHandle invoker;\n+            private MethodHandle reflectInvoker;\n+\n+            private InjectedInvokerHolder(Class<?> invokerClass) {\n+                this.invokerClass = invokerClass;\n+            }\n+\n+            private MethodHandle invoker() {\n+                var mh = invoker;\n+                if (mh == null) {\n+                    try {\n+                        invoker = mh = IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n+                    } catch (Error | RuntimeException ex) {\n+                        throw ex;\n+                    } catch (Throwable ex) {\n+                        throw new InternalError(ex);\n+                    }\n+                }\n+                return mh;\n+            }\n+\n+            private MethodHandle reflectInvoker() {\n+                var mh = reflectInvoker;\n+                if (mh == null) {\n+                    try {\n+                        reflectInvoker = mh = IMPL_LOOKUP.findStatic(invokerClass, \"reflect_invoke_V\", REFLECT_INVOKER_MT);\n+                    } catch (Error | RuntimeException ex) {\n+                        throw ex;\n+                    } catch (Throwable ex) {\n+                        throw new InternalError(ex);\n+                    }\n+                }\n+                return mh;\n+            }\n+        }\n+\n@@ -1118,0 +1215,2 @@\n+            } catch (Error|RuntimeException ex) {\n+                throw ex;\n@@ -1154,0 +1253,1 @@\n+            \/\/     \/* this is used to wrap DMH(s) of caller-sensitive methods *\/\n@@ -1158,0 +1258,6 @@\n+            \/\/     \/* this is used in caller-sensitive reflective method accessor *\/\n+            \/\/     @Hidden\n+            \/\/     static Object reflect_invoke_V(MethodHandle vamh, Object target, Object[] args) throws Throwable {\n+            \/\/        return vamh.invokeExact(target, args);\n+            \/\/     }\n+            \/\/ }\n@@ -1160,0 +1266,16 @@\n+            {\n+                var mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n+                        \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+                        null, null);\n+\n+                mv.visitCode();\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitVarInsn(ALOAD, 1);\n+                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n+                        \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n+                mv.visitInsn(ARETURN);\n+                mv.visitMaxs(2, 2);\n+                mv.visitEnd();\n+\n+                cw.visitEnd();\n+            }\n@@ -1161,14 +1283,14 @@\n-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n-                          \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                          null, null);\n-\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                               \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(2, 2);\n-            mv.visitEnd();\n-\n-            cw.visitEnd();\n+            {\n+                var mv = cw.visitMethod(ACC_STATIC, \"reflect_invoke_V\",\n+                        \"(Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+                        null, null);\n+                mv.visitCode();\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitVarInsn(ALOAD, 1);\n+                mv.visitVarInsn(ALOAD, 2);\n+                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n+                        \"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n+                mv.visitInsn(ARETURN);\n+                mv.visitMaxs(3, 3);\n+                mv.visitEnd();\n+            }\n@@ -1506,0 +1628,42 @@\n+\n+\n+            @Override\n+            public MethodHandle unreflectConstructor(Constructor<?> ctor) throws IllegalAccessException {\n+                return IMPL_LOOKUP.unreflectConstructor(ctor);\n+            }\n+\n+            @Override\n+            public MethodHandle unreflectField(Field field, boolean isSetter) throws IllegalAccessException {\n+                return isSetter ? IMPL_LOOKUP.unreflectSetter(field) : IMPL_LOOKUP.unreflectGetter(field);\n+            }\n+\n+            @Override\n+            public MethodHandle findVirtual(Class<?> defc, String name, MethodType type) throws IllegalAccessException {\n+                try {\n+                    return IMPL_LOOKUP.findVirtual(defc, name, type);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+\n+            @Override\n+            public MethodHandle findStatic(Class<?> defc, String name, MethodType type) throws IllegalAccessException {\n+                try {\n+                    return IMPL_LOOKUP.findStatic(defc, name, type);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+\n+            @Override\n+            public MethodHandle reflectiveInvoker(Class<?> caller) {\n+                Objects.requireNonNull(caller);\n+                return BindCaller.reflectiveInvoker(caller);\n+            }\n+\n+            @Override\n+            public Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize) {\n+                \/\/ skip name and access flags validation\n+                return caller.makeHiddenClassDefiner(name, bytes, Set.of()).defineClassAsLookup(initialize, classData);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":190,"deletions":26,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.VM;\n@@ -38,1 +37,0 @@\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -251,0 +249,1 @@\n+        VM.setJavaLangInvokeInited();\n@@ -670,2 +669,1 @@\n-        return mem.getName().equals(\"getContextClassLoader\") &&\n-            canBeCalledVirtual(mem, java.lang.Thread.class);\n+        return mem.getName().equals(\"getContextClassLoader\") && canBeCalledVirtual(mem, java.lang.Thread.class);\n@@ -681,12 +679,0 @@\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    \/*\n-     * Returns the class data set by the VM in the Class::classData field.\n-     *\n-     * This is also invoked by LambdaForms as it cannot use condy via\n-     * MethodHandles.classData due to bootstrapping issue.\n-     *\/\n-    static Object classData(Class<?> c) {\n-        UNSAFE.ensureClassInitialized(c);\n-        return JLA.classData(c);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -66,0 +67,1 @@\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -67,0 +69,1 @@\n+import static java.lang.invoke.MethodHandleStatics.newInternalError;\n@@ -120,2 +123,4 @@\n-     * This reflected$lookup method is the alternate implementation of\n-     * the lookup method when being invoked by reflection.\n+     * This lookup method is the alternate implementation of\n+     * the lookup method with a leading caller class argument which is\n+     * non-caller-sensitive.  This method is only invoked by reflection\n+     * and method handle.\n@@ -123,3 +128,2 @@\n-    @CallerSensitive\n-    private static Lookup reflected$lookup() {\n-        Class<?> caller = Reflection.getCallerClass();\n+    @CallerSensitiveAdapter\n+    private static Lookup lookup(Class<?> caller) {\n@@ -127,1 +131,1 @@\n-            throw newIllegalArgumentException(\"illegal lookupClass: \"+caller);\n+            throw newInternalError(\"calling lookup() reflectively is not supported: \"+caller);\n@@ -332,1 +336,1 @@\n-         Object classdata = MethodHandleNatives.classData(caller.lookupClass());\n+         Object classdata = classData(caller.lookupClass());\n@@ -344,0 +348,11 @@\n+    \/*\n+     * Returns the class data set by the VM in the Class::classData field.\n+     *\n+     * This is also invoked by LambdaForms as it cannot use condy via\n+     * MethodHandles::classData due to bootstrapping issue.\n+     *\/\n+    static Object classData(Class<?> c) {\n+        UNSAFE.ensureClassInitialized(c);\n+        return SharedSecrets.getJavaLangAccess().classData(c);\n+    }\n+\n@@ -2362,1 +2377,1 @@\n-         * from the given bytes.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given name.\n@@ -2366,1 +2381,2 @@\n-         * @return ClassDefiner that defines a hidden class of the given bytes.\n+         * @param options class options\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n@@ -2368,1 +2384,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options) {\n@@ -2370,1 +2386,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), Set.of(), false);\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.misc.VM;\n@@ -66,7 +67,5 @@\n-    @Stable\n-    private Class<T>            clazz;\n-    private int                 slot;\n-    private Class<?>[]          parameterTypes;\n-    private Class<?>[]          exceptionTypes;\n-    @Stable\n-    private int                 modifiers;\n+    private final Class<T>            clazz;\n+    private final int                 slot;\n+    private final Class<?>[]          parameterTypes;\n+    private final Class<?>[]          exceptionTypes;\n+    private final int                 modifiers;\n@@ -74,1 +73,1 @@\n-    private transient String    signature;\n+    private final transient String    signature;\n@@ -77,2 +76,2 @@\n-    private byte[]              annotations;\n-    private byte[]              parameterAnnotations;\n+    private final byte[]              annotations;\n+    private final byte[]              parameterAnnotations;\n@@ -495,3 +494,0 @@\n-        if ((clazz.getModifiers() & Modifier.ENUM) != 0)\n-            throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");\n-\n@@ -537,0 +533,1 @@\n+\n@@ -545,0 +542,4 @@\n+            \/\/ Ensure the declaring class is not an Enum class.\n+            if ((clazz.getModifiers() & Modifier.ENUM) != 0)\n+                throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");\n+\n@@ -546,1 +547,3 @@\n-            setConstructorAccessor(tmp);\n+            \/\/ set the constructor accessor only if it's not using native implementation\n+            if (VM.isJavaLangInvokeInited())\n+                setConstructorAccessor(tmp);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -68,4 +68,2 @@\n-\n-    @Stable\n-    private Class<?>            clazz;\n-    private int                 slot;\n+    private final Class<?>            clazz;\n+    private final int                 slot;\n@@ -74,6 +72,4 @@\n-    private String              name;\n-    @Stable\n-    private Class<?>            type;\n-    @Stable\n-    private int                 modifiers;\n-    private boolean             trustedFinal;\n+    private final String              name;\n+    private final Class<?>            type;\n+    private final int                 modifiers;\n+    private final boolean             trustedFinal;\n@@ -81,1 +77,1 @@\n-    private transient String    signature;\n+    private final transient String    signature;\n@@ -84,1 +80,1 @@\n-    private byte[]              annotations;\n+    private final byte[]              annotations;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.misc.VM;\n@@ -30,0 +31,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -70,3 +72,2 @@\n-    @Stable\n-    private Class<?>            clazz;\n-    private int                 slot;\n+    private final Class<?>            clazz;\n+    private final int                 slot;\n@@ -75,6 +76,5 @@\n-    private String              name;\n-    private Class<?>            returnType;\n-    private Class<?>[]          parameterTypes;\n-    private Class<?>[]          exceptionTypes;\n-    @Stable\n-    private int                 modifiers;\n+    private final String              name;\n+    private final Class<?>            returnType;\n+    private final Class<?>[]          parameterTypes;\n+    private final Class<?>[]          exceptionTypes;\n+    private final int                 modifiers;\n@@ -82,1 +82,1 @@\n-    private transient String              signature;\n+    private final transient String    signature;\n@@ -85,3 +85,3 @@\n-    private byte[]              annotations;\n-    private byte[]              parameterAnnotations;\n-    private byte[]              annotationDefault;\n+    private final byte[]              annotations;\n+    private final byte[]              parameterAnnotations;\n+    private final byte[]              annotationDefault;\n@@ -556,2 +556,1 @@\n-        throws IllegalAccessException, IllegalArgumentException,\n-           InvocationTargetException\n+        throws IllegalAccessException, InvocationTargetException\n@@ -559,0 +558,36 @@\n+        boolean callerSensitive = isCallerSensitive();\n+        Class<?> caller = null;\n+        if (!override || callerSensitive) {\n+            caller = Reflection.getCallerClass();\n+        }\n+\n+        \/\/ Reflection::getCallerClass filters all subclasses of\n+        \/\/ jdk.internal.reflect.MethodAccessorImpl and Method::invoke(Object, Object[])\n+        \/\/ Should not call Method::invoke(Object, Object[], Class) here\n+        if (!override) {\n+            checkAccess(caller, clazz,\n+                    Modifier.isStatic(modifiers) ? null : obj.getClass(),\n+                    modifiers);\n+        }\n+        MethodAccessor ma = methodAccessor;             \/\/ read @Stable\n+        if (ma == null) {\n+            ma = acquireMethodAccessor();\n+        }\n+\n+        return callerSensitive ? ma.invoke(obj, args, caller) : ma.invoke(obj, args);\n+    }\n+\n+    \/**\n+     * This is to support MethodHandle calling caller-sensitive Method::invoke\n+     * that may invoke a caller-sensitive method in order to get the original caller\n+     * class (not the injected invoker).\n+     *\n+     * If this adapter is not presented, MethodHandle invoking Method::invoke\n+     * will get an invoker class, a hidden nestmate of the original caller class,\n+     * that becomes the caller class invoking Method::invoke.\n+     *\/\n+    @CallerSensitiveAdapter\n+    private Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalAccessException, InvocationTargetException\n+    {\n+        boolean callerSensitive = isCallerSensitive();\n@@ -560,1 +595,0 @@\n-            Class<?> caller = Reflection.getCallerClass();\n@@ -565,1 +599,1 @@\n-        MethodAccessor ma = methodAccessor;             \/\/ read volatile\n+        MethodAccessor ma = methodAccessor;             \/\/ read @Stable\n@@ -569,1 +603,11 @@\n-        return ma.invoke(obj, args);\n+\n+        return callerSensitive ? ma.invoke(obj, args, caller) : ma.invoke(obj, args);\n+    }\n+\n+    @Stable private Boolean callerSensitive;       \/\/ lazily initialize\n+    private boolean isCallerSensitive() {\n+        Boolean cs = callerSensitive;\n+        if (cs == null) {\n+            callerSensitive = cs = Reflection.isCallerSensitive(this);\n+        }\n+        return cs;\n@@ -675,2 +719,4 @@\n-            tmp = reflectionFactory.newMethodAccessor(this);\n-            setMethodAccessor(tmp);\n+            tmp = reflectionFactory.newMethodAccessor(this, isCallerSensitive());\n+            \/\/ set the method accessor only if it's not using native implementation\n+            if (VM.isJavaLangInvokeInited())\n+                setMethodAccessor(tmp);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -33,0 +34,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n@@ -142,0 +145,39 @@\n+\n+    \/**\n+     * Produces a method handle unreflecting from a {@code Constructor} with\n+     * the trusted lookup\n+     *\/\n+    MethodHandle unreflectConstructor(Constructor<?> ctor) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a method handle unreflecting from a {@code Field} with\n+     * the trusted lookup\n+     *\/\n+    MethodHandle unreflectField(Field field, boolean isSetter) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a method handle of a virtual method with the trusted lookup.\n+     *\/\n+    MethodHandle findVirtual(Class<?> defc, String name, MethodType type) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a method handle of a static method with the trusted lookup.\n+     *\/\n+    MethodHandle findStatic(Class<?> defc, String name, MethodType type) throws IllegalAccessException;\n+\n+    \/**\n+     * Returns a method handle of an invoker class injected for core reflection\n+     * implementation with the following signature:\n+     *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+     *\n+     * The invoker class is a hidden class which has the same\n+     * defining class loader, runtime package, and protection domain\n+     * as the given caller class.\n+     *\/\n+    MethodHandle reflectiveInvoker(Class<?> caller);\n+\n+    \/**\n+     * Defines a hidden class of the given name and bytes with class data.\n+     * The given bytes is trusted.\n+     *\/\n+    Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.text.NumberFormat;\n@@ -37,1 +36,1 @@\n-\n+import jdk.internal.vm.annotation.Stable;\n@@ -94,1 +93,13 @@\n-        return VM.initLevel() >= MODULE_SYSTEM_INITED;\n+        return initLevel >= MODULE_SYSTEM_INITED;\n+    }\n+\n+    private static @Stable boolean javaLangInvokeInited;\n+    public static void setJavaLangInvokeInited() {\n+        if (javaLangInvokeInited) {\n+            throw new InternalError(\"java.lang.invoke already inited\");\n+        }\n+        javaLangInvokeInited = true;\n+    }\n+\n+    public static boolean isJavaLangInvokeInited() {\n+        return javaLangInvokeInited;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Utility methods used by DirectMethodHandleAccessor and DirectConstructorImpl\n+ *\/\n+public class AccessorUtils {\n+    static boolean isIllegalArgument(Class<?> accessorType, RuntimeException e) {\n+        StackTraceElement[] stackTrace = e.getStackTrace();\n+        if (stackTrace.length == 0) {\n+            return false;       \/\/ would this happen?\n+        }\n+\n+        int i = 0;\n+        StackTraceElement frame = stackTrace[0];\n+        if ((frame.getClassName().equals(\"java.lang.Class\") && frame.getMethodName().equals(\"cast\"))\n+                || (frame.getClassName().equals(\"java.util.Objects\") && frame.getMethodName().equals(\"requiresNonNull\"))) {\n+            \/\/ skip Class::cast and Objects::requireNonNull from top frame\n+            i++;\n+        }\n+        for (; i < stackTrace.length; i++) {\n+            frame = stackTrace[i];\n+            String cname = frame.getClassName();\n+            if (cname.equals(accessorType.getName())) {\n+                \/\/ it's illegal argument if this exception is thrown from implClass\n+                return true;\n+            }\n+            if (frame.getModuleName() == null || !frame.getModuleName().equals(\"java.base\")) {\n+                \/\/ if this exception is thrown from a unnamed module or non java.base module\n+                \/\/ it's not IAE as it's thrown from the reflective method\n+                return false;\n+            }\n+            int index = cname.lastIndexOf(\".\");\n+            String pn = index > 0 ? cname.substring(0, index) : \"\";\n+            if (!IMPL_PACKAGES.contains(pn)) {\n+                \/\/ exception thrown from java.base but not from reflection internals\n+                return false;\n+            }\n+            if ((accessorType == DirectMethodHandleAccessor.class\n+                    && cname.startsWith(DirectConstructorHandleAccessor.class.getName()))\n+                || (accessorType == DirectConstructorHandleAccessor.class\n+                        && cname.startsWith(DirectMethodHandleAccessor.class.getName()))) {\n+                \/\/ thrown from another reflection accessor impl class\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static final Set<String> IMPL_PACKAGES = Set.of(\n+            \"java.lang.reflect\",\n+            \"java.lang.invoke\",\n+            \"jdk.internal.reflect\",\n+            \"sun.invoke.util\"\n+    );\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorUtils.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+\/**\n+ * A method annotated @CallerSensitiveAdapter is an adapter method corresponding\n+ * to a caller-sensitive method, which is annotated with @CallerSensitive.\n+ *\n+ * A caller-sensitive adapter is private and has the same name as its\n+ * corresponding caller-sensitive method with a trailing caller class parameter.\n+ *\n+ * When a caller-sensitive method is invoked via Method::invoke or MethodHandle\n+ * the core reflection and method handle implementation will find if\n+ * an @CallerSensitiveAdapter method for that CSM is present. If present,\n+ * the runtime will invoke the adapter method with the caller class\n+ * argument instead. This special calling sequence ensures that the same caller\n+ * class is passed to a caller-sensitive method via Method::invoke,\n+ * MethodHandle::invokeExact, or a mix of these methods.\n+ *\n+ * For example, CSM::returnCallerClass is a caller-sensitive method\n+ * with an adapter method:\n+ * {@code\n+ * class CSM {\n+ *     @CallerSensitive\n+ *     static Class<?> returnCallerClass() {\n+ *         return returnCallerClass(Reflection.getCallerClass());\n+ *     }\n+ *     @CallerSensitiveAdapter\n+ *     private static Class<?> returnCallerClass(Class<?> caller) {\n+ *         return caller;\n+ *     }\n+ * }\n+ *\n+ * class Test {\n+ *     void test() throws Throwable {\n+ *         \/\/ calling CSM::returnCallerClass via reflection\n+ *         var csm = CSM.class.getMethod(\"returnCallerClass\");\n+ *         \/\/ expect Foo to be the caller class\n+ *         var caller = csm.invoke(null);\n+ *         assert(caller == Test.class);\n+ *     }\n+ *     void test2() throws Throwable {\n+ *         \/\/ method handle for Method::invoke\n+ *         MethodHandle mh = MethodHandles.lookup().findVirtual(Method.class, \"invoke\",\n+ *                                  methodType(Object.class, Object.class, Object[].class));\n+ *         var csm = CSM.class.getMethod(\"returnCallerClass\");\n+ *         \/\/ invoke Method::invoke via method handle and the target method\n+ *         \/\/ being invoked reflectively is CSM::returnCallerClass\n+ *         var caller = mh.invoke(csm, null, null);\n+ *         assert(caller == Test.class);\n+ *     }\n+ * }\n+ * }\n+ *\n+ *\n+ * Both CSM::returnCallerClass and Method::invoke can have an adapter method\n+ * with a caller-class parameter defined. Test::test calls CSM::returnCallerClass\n+ * via Method::invoke which does the stack walking to find the caller's class.\n+ * It will pass the caller's class directly to the adapter method for\n+ * CSM::returnCallerClass.\n+ *\n+ * Similarly, Test::test2 invokes the method handle of Method::invoke to\n+ * call CSM::returnCallerClass reflectively.  In that case, MethodHandle::invokeExact\n+ * uses the lookup class of the Lookup object producing the method handle\n+ * as the caller's class, so no stack walking involved. The lookup class is Test.\n+ * It will invoke the adapter method of Method::invoke with Test as the caller's\n+ * class, which in turn invokes the adapter method of CSM::returnCallerClass\n+ * with Test as the caller. The calling sequence eliminates the need for\n+ * multiple stack walks when a caller-sensitive method is invoked reflectively.\n+ *\n+ * For caller-sensitive methods that require an exact caller class, the adapter\n+ * method must be defined for correctness. {@link java.lang.invoke.MethodHandles#lookup()}\n+ * and {@link ClassLoader#registerAsParallelCapable()} are the only two methods\n+ * in the JDK that need the exact caller class.\n+ *\n+ * On the other hand, for caller-sensitive methods that use the caller's class\n+ * for access checks or security permission checks, i.e., based on its runtime\n+ * package, defining loader, or protection domain, the adapter method is optional.\n+ *\/\n+@Retention(RetentionPolicy.CLASS)\n+@Target({METHOD})\n+public @interface CallerSensitiveAdapter {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/CallerSensitiveAdapter.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * MethodAccessor adapter for caller-sensitive methods which have\n+ * an alternate non-CSM method with the same method name but an additional\n+ * caller class argument.\n+ *\n+ * When a caller-sensitive method is called,\n+ * Method::invoke(Object target, Object[] args, Class<?> caller) will\n+ * be invoked with the caller class.  If an adapter is present,\n+ * the adapter method with the caller class parameter will be called\n+ * instead.\n+ *\/\n+class CsMethodAccessorAdapter extends MethodAccessorImpl {\n+    private final Method csmAdapter;\n+    private final MethodAccessor accessor;\n+\n+    CsMethodAccessorAdapter(Method method, Method csmAdapter, MethodAccessor accessor) {\n+        assert Reflection.isCallerSensitive(method) && !Reflection.isCallerSensitive(csmAdapter);\n+        this.csmAdapter = csmAdapter;\n+        this.accessor = accessor;\n+    }\n+\n+    @Override\n+    public Object invoke(Object obj, Object[] args)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        throw new InternalError(\"caller-sensitive method invoked without explicit caller: \" + csmAdapter);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @Hidden\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        Object[] newArgs = new Object[args == null ? 1 : args.length + 1];\n+        newArgs[0] = caller;\n+        if (args != null) {\n+            System.arraycopy(args, 0, newArgs, 1, args.length);\n+        }\n+        return accessor.invoke(obj, newArgs);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/CsMethodAccessorAdapter.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DelegatingConstructorAccessorImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    @Stable private final MethodAccessorImpl initialDelegate;\n+    private final MethodAccessorImpl initialDelegate;\n@@ -41,1 +41,2 @@\n-    @Stable private  MethodAccessorImpl altDelegate;\n+    @Stable\n+    private MethodAccessorImpl altDelegate;\n@@ -54,0 +55,7 @@\n+    @Override\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException\n+    {\n+        return delegate().invoke(obj, args, caller);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DelegatingMethodAccessorImpl.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n+\n+class DirectConstructorHandleAccessor extends ConstructorAccessorImpl {\n+    static ConstructorAccessorImpl constructorAccessor(Constructor<?> ctor, MethodHandle target) {\n+        return new DirectConstructorHandleAccessor(ctor, target);\n+    }\n+\n+    static ConstructorAccessorImpl nativeAccessor(Constructor<?> ctor) {\n+        return new NativeAccessor(ctor);\n+    }\n+\n+    private static final int PARAM_COUNT_MASK = 0x00FF;\n+    private static final int NONZERO_BIT = 0x8000_0000;\n+\n+    private final int paramFlags;\n+    private final MethodHandle target;\n+\n+    DirectConstructorHandleAccessor(Constructor<?> ctor, MethodHandle target) {\n+        this.paramFlags = (ctor.getParameterCount() & PARAM_COUNT_MASK) | NONZERO_BIT;\n+        this.target = target;\n+    }\n+\n+    @Override\n+    public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+        int argc = args != null ? args.length : 0;\n+        \/\/ only check argument count for specialized forms\n+        int paramCount = paramFlags & PARAM_COUNT_MASK;\n+        if (paramCount <= SPECIALIZED_PARAM_COUNT && argc != paramCount) {\n+            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n+        }\n+        try {\n+            return invokeImpl(args);\n+        } catch (ClassCastException|WrongMethodTypeException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(\"argument type mismatch\", e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    private boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectConstructorHandleAccessor.class, ex);\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    Object invokeImpl(Object[] args) throws Throwable {\n+        return switch (paramFlags & PARAM_COUNT_MASK) {\n+            case 0 -> target.invokeExact();\n+            case 1 -> target.invokeExact(args[0]);\n+            case 2 -> target.invokeExact(args[0], args[1]);\n+            case 3 -> target.invokeExact(args[0], args[1], args[2]);\n+            default -> target.invokeExact(args);\n+        };\n+    }\n+\n+    \/**\n+     * Invoke the constructor via native VM reflection\n+     *\/\n+    static class NativeAccessor extends ConstructorAccessorImpl {\n+        private final Constructor<?> ctor;\n+        NativeAccessor(Constructor<?> ctor) {\n+            this.ctor = ctor;\n+        }\n+\n+        @Override\n+        public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+            return newInstance0(ctor, args);\n+        }\n+        private static native Object newInstance0(Constructor<?> c, Object[] args)\n+                    throws InstantiationException, InvocationTargetException;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectConstructorHandleAccessor.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.LazyStaticHolder.JLIA;\n+\n+class DirectMethodHandleAccessor extends MethodAccessorImpl {\n+    \/**\n+     * Creates a MethodAccessorImpl for a non-native and non-caller-sensitive method.\n+     *\/\n+    static MethodAccessorImpl methodAccessor(Method method, MethodHandle target) {\n+        assert !Modifier.isNative(method.getModifiers()) && !Reflection.isCallerSensitive(method);\n+\n+        return new DirectMethodHandleAccessor(method, target, false);\n+    }\n+\n+    \/**\n+     * Creates a MethodAccessorImpl for a caller-sensitive method.\n+     *\/\n+    static MethodAccessorImpl callerSensitiveMethodAccessor(Method method, MethodHandle dmh) {\n+        assert Reflection.isCallerSensitive(method);\n+        return new DirectMethodHandleAccessor(method, dmh, false);\n+    }\n+\n+    \/**\n+     * Creates MethodAccessorImpl for the adapter method for a caller-sensitive method.\n+     * The given target method handle is the adapter method with the additional caller class\n+     * parameter.\n+     *\/\n+    static MethodAccessorImpl callerSensitiveAdapter(Method original, MethodHandle target) {\n+        assert Reflection.isCallerSensitive(original);\n+\n+        \/\/ for CSM adapter method with the additional caller class parameter\n+        \/\/ creates the adaptive method accessor only.\n+        return new DirectMethodHandleAccessor(original, target, true);\n+    }\n+\n+    \/**\n+     * Creates MethodAccessorImpl that invokes the given method via VM native reflection\n+     * support.  This is used for native methods.  It can be used for java methods\n+     * during early VM startup.\n+     *\/\n+    static MethodAccessorImpl nativeAccessor(Method method, boolean callerSensitive) {\n+        return callerSensitive ? new NativeAccessor(method, findCSMethodAdapter(method))\n+                               : new NativeAccessor(method);\n+    }\n+\n+    private static final int PARAM_COUNT_MASK = 0x00FF;\n+    private static final int HAS_CALLER_PARAM_BIT = 0x0100;\n+    private static final int IS_STATIC_BIT = 0x0200;\n+    private static final int NONZERO_BIT = 0x8000_0000;\n+\n+    private final Class<?> declaringClass;\n+    private final int paramFlags;\n+    private final MethodHandle target;\n+\n+    DirectMethodHandleAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        this.declaringClass = method.getDeclaringClass();\n+        this.paramFlags = (method.getParameterCount() & PARAM_COUNT_MASK) |\n+                          (hasCallerParameter ? HAS_CALLER_PARAM_BIT : 0) |\n+                          (Modifier.isStatic(method.getModifiers()) ? IS_STATIC_BIT : 0) |\n+                          NONZERO_BIT;\n+        this.target = target;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+        if ((paramFlags & IS_STATIC_BIT) == 0) {\n+            checkReceiver(obj);\n+        }\n+        checkArgumentCount(paramFlags & PARAM_COUNT_MASK, args);\n+        try {\n+            return invokeImpl(obj, args);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n+        if ((paramFlags & IS_STATIC_BIT) == 0) {\n+            checkReceiver(obj);\n+        }\n+        checkArgumentCount(paramFlags & PARAM_COUNT_MASK, args);\n+        try {\n+            return invokeImpl(obj, args, caller);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    private Object invokeImpl(Object obj, Object[] args) throws Throwable {\n+        return switch (paramFlags & PARAM_COUNT_MASK) {\n+            case 0 -> target.invokeExact(obj);\n+            case 1 -> target.invokeExact(obj, args[0]);\n+            case 2 -> target.invokeExact(obj, args[0], args[1]);\n+            case 3 -> target.invokeExact(obj, args[0], args[1], args[2]);\n+            default -> target.invokeExact(obj, args);\n+        };\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    private Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        if ((paramFlags & HAS_CALLER_PARAM_BIT) > 0) {\n+            \/\/ caller-sensitive method is invoked through method with caller parameter\n+            return switch (paramFlags & PARAM_COUNT_MASK) {\n+                case 0 -> target.invokeExact(obj, caller);\n+                case 1 -> target.invokeExact(obj, args[0], caller);\n+                case 2 -> target.invokeExact(obj, args[0], args[1], caller);\n+                case 3 -> target.invokeExact(obj, args[0], args[1], args[2], caller);\n+                default -> target.invokeExact(obj, args, caller);\n+            };\n+        } else {\n+            \/\/ caller-sensitive method is invoked through a per-caller invoker while\n+            \/\/ the target MH is always spreading the args\n+            var invoker = JLIA.reflectiveInvoker(caller);\n+            try {\n+                \/\/ invoke the target method handle via an invoker\n+                return invoker.invokeExact(target, obj, args);\n+            } catch (IllegalArgumentException e) {\n+                throw new InvocationTargetException(e);\n+            }\n+        }\n+    }\n+\n+    private boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectMethodHandleAccessor.class, ex);\n+    }\n+\n+    private void checkReceiver(Object o) {\n+        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n+        if (!declaringClass.isAssignableFrom(o.getClass())) {\n+            throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n+        }\n+    }\n+\n+    \/**\n+     * Invoke the method via native VM reflection\n+     *\/\n+    static class NativeAccessor extends MethodAccessorImpl {\n+        private final Method method;\n+        private final Method csmAdapter;\n+        private final boolean callerSensitive;\n+        NativeAccessor(Method method) {\n+            assert !Reflection.isCallerSensitive(method);\n+            this.method = method;\n+            this.csmAdapter = null;\n+            this.callerSensitive = false;\n+        }\n+\n+        NativeAccessor(Method method, Method csmAdapter) {\n+            assert Reflection.isCallerSensitive(method);\n+            this.method = method;\n+            this.csmAdapter = csmAdapter;\n+            this.callerSensitive = true;\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+            assert csmAdapter == null;\n+            return invoke0(method, obj, args);\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n+            assert callerSensitive;\n+\n+            if (csmAdapter != null) {\n+                Object[] newArgs = new Object[csmAdapter.getParameterCount()];\n+                newArgs[0] = caller;\n+                if (args != null) {\n+                    System.arraycopy(args, 0, newArgs, 1, args.length);\n+                }\n+                return invoke0(csmAdapter, obj, newArgs);\n+            } else {\n+                assert VM.isJavaLangInvokeInited();\n+                try {\n+                    return ReflectiveInvoker.invoke(methodAccessorInvoker(), caller, obj, args);\n+                } catch (InvocationTargetException|RuntimeException|Error e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n+\n+        public Object invokeViaReflectiveInvoker(Object obj, Object[] args) throws InvocationTargetException {\n+            return invoke0(method, obj, args);\n+        }\n+\n+        \/*\n+         * A method handle to invoke Reflective::Invoker\n+         *\/\n+        private MethodHandle maInvoker;\n+        private MethodHandle methodAccessorInvoker() {\n+            MethodHandle invoker = maInvoker;\n+            if (invoker == null) {\n+                maInvoker = invoker = ReflectiveInvoker.bindTo(this);\n+            }\n+            return invoker;\n+        }\n+\n+        private static native Object invoke0(Method m, Object obj, Object[] args);\n+\n+        static class ReflectiveInvoker {\n+            \/**\n+             * Return a method handle for NativeAccessor::invoke bound to the given accessor object\n+             *\/\n+            static MethodHandle bindTo(NativeAccessor accessor) {\n+                return NATIVE_ACCESSOR_INVOKE.bindTo(accessor);\n+            }\n+\n+            \/*\n+             * When Method::invoke on a caller-sensitive method is to be invoked\n+             * and no adapter method with an additional caller class argument is defined,\n+             * the caller-sensitive method must be invoked via an invoker injected\n+             * which has the following signature:\n+             *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+             *\n+             * The stack frames calling the method `csm` through reflection will\n+             * look like this:\n+             *     obj.csm(args)\n+             *     NativeAccessor::invoke(obj, args)\n+             *     InjectedInvoker::reflect_invoke_V(vamh, obj, args);\n+             *     method::invoke(obj, args)\n+             *     p.Foo::m\n+             *\n+             * An injected invoker class is a hidden class which has the same\n+             * defining class loader, runtime package, and protection domain\n+             * as the given caller class.\n+             *\n+             * The caller-sensitive method will call Reflection::getCallerClass\n+             * to get the caller class.\n+             *\/\n+            static Object invoke(MethodHandle target, Class<?> caller, Object obj, Object[] args)\n+                    throws InvocationTargetException\n+            {\n+                var reflectInvoker = JLIA.reflectiveInvoker(caller);\n+                try {\n+                    return reflectInvoker.invokeExact(target, obj, args);\n+                } catch (InvocationTargetException | RuntimeException | Error e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            static final JavaLangInvokeAccess JLIA;\n+            static final MethodHandle NATIVE_ACCESSOR_INVOKE;\n+            static {\n+                try {\n+                    JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+                    NATIVE_ACCESSOR_INVOKE = MethodHandles.lookup().findVirtual(NativeAccessor.class, \"invoke\",\n+                            genericMethodType(1, true));\n+                } catch (NoSuchMethodException|IllegalAccessException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkArgumentCount(int paramCount, Object[] args) {\n+        \/\/ only check argument count for specialized forms\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) return;\n+\n+        int argc = args != null ? args.length : 0;\n+        if (argc != paramCount) {\n+            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n+        }\n+    }\n+\n+    \/**\n+     * Returns an adapter for caller-sensitive method if present.\n+     * Otherwise, null.\n+     *\n+     * A trusted method can define an adapter method for a caller-sensitive method `foo`\n+     * with an additional caller class argument that will be invoked reflectively.\n+     *\/\n+    private static Method findCSMethodAdapter(Method method) {\n+        if (!Reflection.isCallerSensitive(method)) return null;\n+\n+        int paramCount = method.getParameterCount();\n+        Class<?>[] ptypes = new Class<?>[paramCount+1];\n+        ptypes[paramCount] = Class.class;\n+        System.arraycopy(method.getParameterTypes(), 0, ptypes, 0, paramCount);\n+        try {\n+            return method.getDeclaringClass().getDeclaredMethod(method.getName(), ptypes);\n+        } catch (NoSuchMethodException ex) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -31,0 +29,1 @@\n+import java.lang.reflect.Modifier;\n@@ -38,1 +37,0 @@\n-    @Stable\n@@ -116,0 +114,163 @@\n+\n+\n+    protected void ensureObj(Object o) {\n+        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n+        if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+            throwSetIllegalArgumentException(o);\n+        }\n+    }\n+\n+    private String getQualifiedFieldName() {\n+        return field.getDeclaringClass().getName() + \".\" +field.getName();\n+    }\n+\n+    protected IllegalArgumentException newGetIllegalArgumentException(String type) {\n+        return new IllegalArgumentException(\n+                \"Attempt to get \"+field.getType().getName()+\" field \\\"\" +\n+                        getQualifiedFieldName() + \"\\\" with illegal data type conversion to \"+type\n+        );\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(String attemptedType,\n+                                                         String attemptedValue)\n+            throws IllegalAccessException {\n+        throw new IllegalAccessException(getSetMessage(attemptedType, attemptedValue));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(Object o) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(o != null ? o.getClass().getName() : \"\", \"\");\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(boolean z) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"boolean\", Boolean.toString(z));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(char b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"char\", Character.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(byte b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"byte\", Byte.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(short b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"short\", Short.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(int i) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"int\", Integer.toString(i));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(long i) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"long\", Long.toString(i));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(float f) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"float\", Float.toString(f));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(double f) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"double\", Double.toString(f));\n+    }\n+\n+    protected IllegalArgumentException newGetBooleanIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"boolean\");\n+    }\n+\n+    protected IllegalArgumentException newGetByteIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"byte\");\n+    }\n+\n+    protected IllegalArgumentException newGetCharIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"char\");\n+    }\n+\n+    protected IllegalArgumentException newGetShortIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"short\");\n+    }\n+\n+    protected IllegalArgumentException newGetIntIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"int\");\n+    }\n+\n+    protected IllegalArgumentException newGetLongIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"long\");\n+    }\n+\n+    protected IllegalArgumentException newGetFloatIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"float\");\n+    }\n+\n+    protected IllegalArgumentException newGetDoubleIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"double\");\n+    }\n+\n+    protected String getSetMessage(String attemptedType, String attemptedValue) {\n+        String err = \"Can not set\";\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" to \";\n+        if (!attemptedValue.isEmpty()) {\n+            err += \"(\" + attemptedType + \")\" + attemptedValue;\n+        } else {\n+            if (!attemptedType.isEmpty())\n+                err += attemptedType;\n+            else\n+                err += \"null value\";\n+        }\n+        return err;\n+    }\n+\n+    protected String getMessage(boolean getter, String attemptedType) {\n+        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" on \" + attemptedType;\n+        return err;\n+    }\n+\n+    protected void throwSetIllegalArgumentException(String attemptedType,\n+                                                    String attemptedValue) {\n+        throw new IllegalArgumentException(getSetMessage(attemptedType,attemptedValue));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(Object o) {\n+        throwSetIllegalArgumentException(o != null ? o.getClass().getName() : \"\", \"\");\n+    }\n+\n+    protected void throwSetIllegalArgumentException(boolean b) {\n+        throwSetIllegalArgumentException(\"boolean\", Boolean.toString(b));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(byte b) {\n+        throwSetIllegalArgumentException(\"byte\", Byte.toString(b));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(char c) {\n+        throwSetIllegalArgumentException(\"char\", Character.toString(c));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(short s) {\n+        throwSetIllegalArgumentException(\"short\", Short.toString(s));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(int i) {\n+        throwSetIllegalArgumentException(\"int\", Integer.toString(i));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(long l) {\n+        throwSetIllegalArgumentException(\"long\", Long.toString(l));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(float f) {\n+        throwSetIllegalArgumentException(\"float\", Float.toString(f));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(double d) {\n+        throwSetIllegalArgumentException(\"double\", Double.toString(d));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":165,"deletions":4,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-\/** Generator for sun.reflect.MethodAccessor and\n-    sun.reflect.ConstructorAccessor objects using bytecodes to\n+\/** Generator for jdk.internal.reflect.MethodAccessor and\n+    jdk.internal.reflect.ConstructorAccessor objects using bytecodes to\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        return invoke(obj, args);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.LazyStaticHolder.*;\n+\n+final class MethodHandleAccessorFactory {\n+    \/**\n+     * Creates a MethodAccessor for the given reflected method.\n+     *\n+     * If the given method is called before the java.lang.invoke initialization\n+     * or the given method is a native method, it will use the native VM reflection\n+     * support.\n+     *\n+     * If the given method is a caller-sensitive method and the corresponding\n+     * caller-sensitive adapter with the caller class parameter is present,\n+     * it will use the method handle of the caller-sensitive adapter.\n+     *\n+     * Otherwise, it will use the direct method handle of the given method.\n+     *\n+     * @see CallerSensitive\n+     * @see CallerSensitiveAdapter\n+     *\/\n+    static MethodAccessorImpl newMethodAccessor(Method method, boolean callerSensitive) {\n+        if (useNativeAccessor(method)) {\n+            return DirectMethodHandleAccessor.nativeAccessor(method, callerSensitive);\n+        }\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(method.getDeclaringClass());\n+\n+        try {\n+            if (callerSensitive) {\n+                var dmh = findCallerSensitiveAdapter(method);\n+                if (dmh != null) {\n+                    return DirectMethodHandleAccessor.callerSensitiveAdapter(method, dmh);\n+                }\n+            }\n+            var dmh = getDirectMethod(method, callerSensitive);\n+            if (callerSensitive) {\n+                return DirectMethodHandleAccessor.callerSensitiveMethodAccessor(method, dmh);\n+            } else {\n+                return DirectMethodHandleAccessor.methodAccessor(method, dmh);\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a ConstructorAccessor for the given reflected constructor.\n+     *\n+     * If a given constructor is called before the java.lang.invoke initialization,\n+     * it will use the native VM reflection support.\n+     *\n+     * Otherwise, it will use the direct method handle of the given constructor.\n+     *\/\n+    static ConstructorAccessorImpl newConstructorAccessor(Constructor<?> ctor) {\n+        if (useNativeAccessor(ctor)) {\n+            return DirectConstructorHandleAccessor.nativeAccessor(ctor);\n+        }\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(ctor.getDeclaringClass());\n+\n+        try {\n+            MethodHandle mh = JLIA.unreflectConstructor(ctor);\n+            int paramCount = mh.type().parameterCount();\n+            MethodHandle target = mh.asFixedArity();\n+            MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n+            if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+                \/\/ spread the parameters only for the non-specialized case\n+                target = target.asSpreader(Object[].class, paramCount);\n+            }\n+            target = target.asType(mtype);\n+            return DirectConstructorHandleAccessor.constructorAccessor(ctor, target);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a FieldAccessor for the given reflected field.\n+     *\n+     * Limitation: Field access via core reflection is only supported after\n+     * java.lang.invoke completes initialization.\n+     * java.lang.invoke initialization starts soon after System::initPhase1\n+     * and method handles are ready for use when initPhase2 begins.\n+     * During early VM startup (initPhase1), fields can be accessed directly\n+     * from the VM or through JNI.\n+     *\/\n+    static FieldAccessorImpl newFieldAccessor(Field field, boolean isReadOnly) {\n+        if (!VM.isJavaLangInvokeInited()) {\n+            throw new InternalError(field.getDeclaringClass().getName() + \"::\" + field.getName() +\n+                    \" cannot be accessed reflectively before java.lang.invoke is initialized\");\n+        }\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(field.getDeclaringClass());\n+\n+        try {\n+            \/\/ the declaring class of the field has been initialized\n+            var getter = JLIA.unreflectField(field, false);\n+            var setter = isReadOnly ? null : JLIA.unreflectField(field, true);\n+            Class<?> type = field.getType();\n+            if (type == Boolean.TYPE) {\n+                return MethodHandleBooleanFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Byte.TYPE) {\n+                return MethodHandleByteFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Short.TYPE) {\n+                return MethodHandleShortFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Character.TYPE) {\n+                return MethodHandleCharacterFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Integer.TYPE) {\n+                return MethodHandleIntegerFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Long.TYPE) {\n+                return MethodHandleLongFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Float.TYPE) {\n+                return MethodHandleFloatFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else if (type == Double.TYPE) {\n+                return MethodHandleDoubleFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            } else {\n+                return MethodHandleObjectFieldAccessorImpl.fieldAccessor(field, getter, setter, isReadOnly);\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static MethodHandle getDirectMethod(Method method, boolean callerSensitive) throws IllegalAccessException {\n+        var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+        var isStatic = Modifier.isStatic(method.getModifiers());\n+        var dmh = isStatic ? JLIA.findStatic(method.getDeclaringClass(), method.getName(), mtype)\n+                                        : JLIA.findVirtual(method.getDeclaringClass(), method.getName(), mtype);\n+        if (callerSensitive) {\n+            \/\/ the reflectiveInvoker for caller-sensitive method expects the same signature\n+            \/\/ as Method::invoke i.e. (Object, Object[])Object\n+            return makeTarget(dmh, isStatic, false);\n+        }\n+        return makeSpecializedTarget(dmh, isStatic, false);\n+    }\n+\n+    \/**\n+     * Finds the method handle of a caller-sensitive adapter for the given\n+     * caller-sensitive method.  It has the same name as the given method\n+     * with a trailing caller class parameter.\n+     *\n+     * @see CallerSensitiveAdapter\n+     *\/\n+    private static MethodHandle findCallerSensitiveAdapter(Method method) throws IllegalAccessException {\n+        String name = method.getName();\n+        \/\/ append a Class parameter\n+        MethodType mtype = methodType(method.getReturnType(), method.getParameterTypes())\n+                                .appendParameterTypes(Class.class);\n+        boolean isStatic = Modifier.isStatic(method.getModifiers());\n+\n+        MethodHandle dmh = isStatic ? JLIA.findStatic(method.getDeclaringClass(), name, mtype)\n+                                    : JLIA.findVirtual(method.getDeclaringClass(), name, mtype);\n+        return dmh != null ? makeSpecializedTarget(dmh, isStatic, true) : null;\n+    }\n+\n+    \/**\n+     * Transform the given dmh to a specialized target method handle.\n+     *\n+     * If {@code hasCallerParameter} parameter is true, transform the method handle\n+     * of this method type: {@code (Object, Object[], Class)Object} for the default\n+     * case.\n+     *\n+     * If {@code hasCallerParameter} parameter is false, transform the method handle\n+     * of this method type: {@code (Object, Object[])Object} for the default case.\n+     *\n+     * If the number of formal arguments is small, use a method type specialized\n+     * the number of formal arguments is 0, 1, and 2, for example, the method type\n+     * of a static method with one argument can be: {@code (Object)Object}\n+     *\n+     * If it's a static method, there is no leading Object parameter.\n+     *\n+     * @apiNote\n+     * This implementation avoids using MethodHandles::catchException to help\n+     * cold startup performance since this combination is very costly to setup.\n+     *\n+     * @param dmh DirectMethodHandle\n+     * @param isStatic whether given dmh represents static method or not\n+     * @param hasCallerParameter whether given dmh represents a method with an\n+     *                         additional caller Class parameter\n+     * @return transformed dmh to be used as a target in direct method accessors\n+     *\/\n+    static MethodHandle makeSpecializedTarget(MethodHandle dmh, boolean isStatic, boolean hasCallerParameter) {\n+        MethodHandle target = dmh.asFixedArity();\n+\n+        \/\/ number of formal arguments to the original method (not the adapter)\n+        \/\/ If it is a non-static method, it has a leading `this` argument.\n+        \/\/ Also do not count the caller class argument\n+        int paramCount = dmh.type().parameterCount() - (isStatic ? 0 : 1) - (hasCallerParameter ? 1 : 0);\n+        MethodType mtype = specializedMethodType(isStatic, hasCallerParameter, paramCount);\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+            int spreadArgPos = isStatic ? 0 : 1;\n+            target = target.asSpreader(spreadArgPos, Object[].class, paramCount);\n+        }\n+        if (isStatic) {\n+            \/\/ add leading 'this' parameter to static method which is then ignored\n+            target = MethodHandles.dropArguments(target, 0, Object.class);\n+        }\n+        return target.asType(mtype);\n+    }\n+\n+    \/\/ specialize for number of formal arguments <= 3 to avoid spreader\n+    static final int SPECIALIZED_PARAM_COUNT = 3;\n+    static MethodType specializedMethodType(boolean isStatic, boolean hasCallerParameter, int paramCount) {\n+        return switch (paramCount) {\n+            case 0 -> hasCallerParameter ? methodType(Object.class, Object.class, Class.class)\n+                                         : genericMethodType(1);\n+            case 1 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(2);\n+            case 2 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(3);\n+            case 3 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(4);\n+            default -> hasCallerParameter ? methodType(Object.class, Object.class, Object[].class, Class.class)\n+                                          : genericMethodType(1, true);\n+        };\n+    }\n+\n+    static MethodType specializedMethodTypeForConstructor(int paramCount) {\n+        return switch (paramCount) {\n+            case 0 ->  genericMethodType(0);\n+            case 1 ->  genericMethodType(1);\n+            case 2 ->  genericMethodType(2);\n+            case 3 ->  genericMethodType(3);\n+            default -> genericMethodType(0, true);\n+        };\n+    }\n+\n+    \/**\n+     * Transforms the given dmh into a target method handle with the method type\n+     * {@code (Object, Object[])Object} or {@code (Object, Class, Object[])Object}\n+     *\/\n+    static MethodHandle makeTarget(MethodHandle dmh, boolean isStatic, boolean hasCallerParameter) {\n+        MethodType mtype = hasCallerParameter\n+                                ? methodType(Object.class, Object.class, Object[].class, Class.class)\n+                                : genericMethodType(1, true);\n+        \/\/ number of formal arguments\n+        int paramCount = dmh.type().parameterCount() - (isStatic ? 0 : 1) - (hasCallerParameter ? 1 : 0);\n+        int spreadArgPos = isStatic ? 0 : 1;\n+        MethodHandle target = dmh.asFixedArity().asSpreader(spreadArgPos, Object[].class, paramCount);\n+        if (isStatic) {\n+            \/\/ add leading 'this' parameter to static method which is then ignored\n+            target = MethodHandles.dropArguments(target, 0, Object.class);\n+        }\n+        return target.asType(mtype);\n+    }\n+\n+    \/**\n+     * Ensures the given class is initialized.  If this is called from <clinit>,\n+     * this method returns but defc's class initialization is not completed.\n+     *\/\n+    static void ensureClassInitialized(Class<?> defc) {\n+        if (UNSAFE.shouldBeInitialized(defc)) {\n+            UNSAFE.ensureClassInitialized(defc);\n+        }\n+    }\n+\n+    \/*\n+     * Returns true if NativeAccessor should be used.\n+     *\/\n+    private static boolean useNativeAccessor(Executable member) {\n+        if (!VM.isJavaLangInvokeInited())\n+            return true;\n+\n+        if (Modifier.isNative(member.getModifiers()))\n+            return true;\n+\n+        if (ReflectionFactory.useNativeAccessorOnly())  \/\/ for testing only\n+            return true;\n+\n+        \/\/ MethodHandle::withVarargs on a member with varargs modifier bit set\n+        \/\/ verifies that the last parameter of the member must be an array type.\n+        \/\/ The JVMS does not require the last parameter descriptor of the method descriptor\n+        \/\/ is an array type if the ACC_VARARGS flag is set in the access_flags item.\n+        \/\/ Hence the reflection implementation does not check the last parameter type\n+        \/\/ if ACC_VARARGS flag is set.  Workaround this by invoking through\n+        \/\/ the native accessor.\n+        int paramCount = member.getParameterCount();\n+        if (member.isVarArgs() &&\n+                (paramCount == 0 || !(member.getParameterTypes()[paramCount-1].isArray()))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/*\n+     * Delay initializing these static fields until java.lang.invoke is fully initialized.\n+     *\/\n+    static class LazyStaticHolder {\n+        static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+    }\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleBooleanFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(boolean.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, boolean.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(boolean.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, boolean.class));\n+            }\n+        }\n+        return new MethodHandleBooleanFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleBooleanFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Boolean.valueOf(getBoolean(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        ensureObj(obj);\n+        try {\n+            if (isStatic()) {\n+                return (boolean) getter.invokeExact();\n+            } else {\n+                return (boolean) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        throw newGetDoubleIllegalArgumentException();\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly()) {\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Boolean b) {\n+            setBoolean(obj, b.booleanValue());\n+        } else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly()) {\n+            throwFinalFieldIllegalAccessException(z);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(z);\n+            } else {\n+                setter.invokeExact(obj, z);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleByteFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(byte.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, byte.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(byte.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, byte.class));\n+            }\n+        }\n+        return new MethodHandleByteFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleByteFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Byte.valueOf(getByte(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (byte) getter.invokeExact();\n+            } else {\n+                return (byte) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly()) {\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setByte(obj, b.byteValue());\n+        } else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly()) {\n+            throwFinalFieldIllegalAccessException(b);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(b);\n+            } else {\n+                setter.invokeExact(obj, b);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleCharacterFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(char.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, char.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(char.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, char.class));\n+            }\n+        }\n+        return new MethodHandleCharacterFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleCharacterFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Character.valueOf(getChar(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (char) getter.invokeExact();\n+            } else {\n+                return (char) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Character c) {\n+            setChar(obj, c.charValue());\n+        } else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(c);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(c);\n+            } else {\n+                setter.invokeExact(obj, c);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleDoubleFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(double.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, double.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(double.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, double.class));\n+            }\n+        }\n+        return new MethodHandleDoubleFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleDoubleFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Double.valueOf(getDouble(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (double) getter.invokeExact();\n+            } else {\n+                return (double) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setDouble(obj, b.byteValue());\n+        }\n+        else if (value instanceof Short s) {\n+            setDouble(obj, s.shortValue());\n+        }\n+        else if (value instanceof Character c) {\n+            setDouble(obj, c.charValue());\n+        }\n+        else if (value instanceof Integer i) {\n+            setDouble(obj, i.intValue());\n+        }\n+        else if (value instanceof Long l) {\n+            setDouble(obj, l.longValue());\n+        }\n+        else if (value instanceof Float f) {\n+            setDouble(obj, f.floatValue());\n+        }\n+        else if (value instanceof Double d) {\n+            setDouble(obj, d.doubleValue());\n+        }\n+        else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(d);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(d);\n+            } else {\n+                setter.invokeExact(obj, d);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Field;\n+\n+abstract class MethodHandleFieldAccessorImpl extends FieldAccessorImpl {\n+    private static final int IS_READ_ONLY_BIT = 0x0001;\n+    private static final int IS_STATIC_BIT = 0x0002;\n+    private static final int NONZERO_BIT = 0x8000;\n+\n+    private final int fieldFlags;\n+    protected final MethodHandle getter;\n+    protected final MethodHandle setter;\n+\n+    protected MethodHandleFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field);\n+        this.fieldFlags = (isReadOnly ? IS_READ_ONLY_BIT : 0) |\n+                          (isStatic ? IS_STATIC_BIT : 0) |\n+                          NONZERO_BIT;\n+        this.getter = getter;\n+        this.setter = setter;\n+    }\n+\n+    protected final boolean isReadOnly() {\n+        return (fieldFlags & IS_READ_ONLY_BIT) == IS_READ_ONLY_BIT;\n+    }\n+\n+    protected final boolean isStatic() {\n+        return (fieldFlags & IS_STATIC_BIT) == IS_STATIC_BIT;\n+    }\n+\n+    protected final void ensureObj(Object o) {\n+        if (!isStatic()) {\n+            \/\/ for compatibility, check the receiver object first\n+            \/\/ throw NullPointerException if o is null\n+            if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+                throwSetIllegalArgumentException(o);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * IllegalArgumentException because Field::get on the specified object, which\n+     * is not an instance of the class or interface declaring the underlying method\n+     *\/\n+    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n+        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    }\n+\n+    \/**\n+     * IllegalArgumentException because Field::set on the specified object, which\n+     * is not an instance of the class or interface declaring the underlying method\n+     *\/\n+    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n+        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    }\n+\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFieldAccessorImpl.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleFloatFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(float.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, float.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(float.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, float.class));\n+            }\n+        }\n+        return new MethodHandleFloatFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleFloatFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Float.valueOf(getFloat(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (float) getter.invokeExact();\n+            } else {\n+                return (float) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getFloat(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setFloat(obj, b.byteValue());\n+        }\n+        else if (value instanceof Short s) {\n+            setFloat(obj, s.shortValue());\n+        }\n+        else if (value instanceof Character c) {\n+            setFloat(obj, c.charValue());\n+        }\n+        else if (value instanceof Integer i) {\n+            setFloat(obj, i.intValue());\n+        }\n+        else if (value instanceof Long l) {\n+            setFloat(obj, l.longValue());\n+        }\n+        else if (value instanceof Float f) {\n+            setFloat(obj, f.floatValue());\n+        }\n+        else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(f);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(f);\n+            } else {\n+                setter.invokeExact(obj, f);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleIntegerFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(int.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, int.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(int.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, int.class));\n+            }\n+        }\n+        return new MethodHandleIntegerFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleIntegerFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Integer.valueOf(getInt(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (int) getter.invokeExact();\n+            } else {\n+                return (int) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setInt(obj, b.byteValue());\n+        }\n+        else if (value instanceof Short s) {\n+            setInt(obj, s.shortValue());\n+        }\n+        else if (value instanceof Character c) {\n+            setInt(obj, c.charValue());\n+        }\n+        else if (value instanceof Integer i) {\n+            setInt(obj, i.intValue());\n+        }\n+        else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(i);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(i);\n+            } else {\n+                setter.invokeExact(obj, i);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleLongFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(long.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, long.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(long.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, long.class));\n+            }\n+        }\n+        return new MethodHandleLongFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleLongFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Long.valueOf(getLong(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (long) getter.invokeExact();\n+            } else {\n+                return (long) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getLong(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getLong(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setLong(obj, b.byteValue());\n+        }\n+        else if (value instanceof Short s) {\n+            setLong(obj, s.shortValue());\n+        }\n+        else if (value instanceof Character c) {\n+            setLong(obj, c.charValue());\n+        }\n+        else if (value instanceof Integer i) {\n+            setLong(obj, i.intValue());\n+        }\n+        else if (value instanceof Long l) {\n+            setLong(obj, l.longValue());\n+        }\n+        else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(l);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(l);\n+            } else {\n+                setter.invokeExact(obj, l);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleObjectFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(Object.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, Object.class));\n+            }\n+        }\n+        return new MethodHandleObjectFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleObjectFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    @Override\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        try {\n+            return isStatic() ? getter.invokeExact() : getter.invokeExact(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        throw newGetDoubleIllegalArgumentException();\n+    }\n+\n+    @Override\n+    public void set(Object obj, Object value) throws IllegalAccessException {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(value);\n+            } else {\n+                setter.invokeExact(obj, value);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+class MethodHandleShortFieldAccessorImpl extends MethodHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly) {\n+        boolean isStatic = Modifier.isStatic(field.getModifiers());\n+        if (isStatic) {\n+            getter = getter.asType(MethodType.methodType(short.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, short.class));\n+            }\n+        } else {\n+            getter = getter.asType(MethodType.methodType(short.class, Object.class));\n+            if (setter != null) {\n+                setter = setter.asType(MethodType.methodType(void.class, Object.class, short.class));\n+            }\n+        }\n+        return new MethodHandleShortFieldAccessorImpl(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    MethodHandleShortFieldAccessorImpl(Field field, MethodHandle getter, MethodHandle setter, boolean isReadOnly, boolean isStatic) {\n+        super(field, getter, setter, isReadOnly, isStatic);\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Short.valueOf(getShort(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        try {\n+            if (isStatic()) {\n+                return (short) getter.invokeExact();\n+            } else {\n+                return (short) getter.invokeExact(obj);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+\n+        if (value instanceof Byte b) {\n+            setShort(obj, b.byteValue());\n+        }\n+        else if (value instanceof Short s) {\n+            setShort(obj, s.shortValue());\n+        }\n+        else {\n+            throwSetIllegalArgumentException(value);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setShort(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly()) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(s);\n+        }\n+        try {\n+            if (isStatic()) {\n+                setter.invokeExact(s);\n+            } else {\n+                setter.invokeExact(obj, s);\n+            }\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-        \/\/ We can't inflate a constructor belonging to a vm-anonymous class\n+        \/\/ We can't inflate a constructor belonging to a hidden class\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeConstructorAccessorImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        \/\/ We can't inflate methods belonging to vm-anonymous classes because\n+        \/\/ We can't inflate methods belonging to hidden classes because\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeMethodAccessorImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,9 @@\n+    \/\/\n+    \/\/ New implementation uses direct invocation of method handles\n+    private static final int METHOD_MH_ACCESSOR      = 0x1;\n+    private static final int FIELD_MH_ACCESSOR       = 0x2;\n+    private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n+\n+    private static int     useDirectMethodHandle = ALL_MH_ACCESSORS;\n+    private static boolean useNativeAccessorOnly = false;  \/\/ for testing only\n+\n@@ -140,18 +149,0 @@\n-    \/**\n-     * Returns an alternate reflective Method instance for the given method\n-     * intended for reflection to invoke, if present.\n-     *\n-     * A trusted method can define an alternate implementation for a method `foo`\n-     * by defining a method named \"reflected$foo\" that will be invoked\n-     * reflectively.\n-     *\/\n-    private static Method findMethodForReflection(Method method) {\n-        String altName = \"reflected$\" + method.getName();\n-        try {\n-           return method.getDeclaringClass()\n-                        .getDeclaredMethod(altName, method.getParameterTypes());\n-        } catch (NoSuchMethodException ex) {\n-            return null;\n-        }\n-    }\n-\n@@ -184,1 +175,5 @@\n-        return UnsafeFieldAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        if (useFieldHandleAccessor()) {\n+            return MethodHandleAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        } else {\n+            return UnsafeFieldAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        }\n@@ -187,1 +182,1 @@\n-    public MethodAccessor newMethodAccessor(Method method) {\n+    public MethodAccessor newMethodAccessor(Method method, boolean callerSensitive) {\n@@ -190,7 +185,0 @@\n-        if (Reflection.isCallerSensitive(method)) {\n-            Method altMethod = findMethodForReflection(method);\n-            if (altMethod != null) {\n-                method = altMethod;\n-            }\n-        }\n-\n@@ -203,8 +191,2 @@\n-        if (noInflation && !method.getDeclaringClass().isHidden()) {\n-            return new MethodAccessorGenerator().\n-                generateMethod(method.getDeclaringClass(),\n-                               method.getName(),\n-                               method.getParameterTypes(),\n-                               method.getReturnType(),\n-                               method.getExceptionTypes(),\n-                               method.getModifiers());\n+        if (useMethodHandleAccessor()) {\n+            return MethodHandleAccessorFactory.newMethodAccessor(method, callerSensitive);\n@@ -212,2 +194,6 @@\n-            NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method);\n-            return acc.getParent();\n+            if (noInflation && !method.getDeclaringClass().isHidden()) {\n+                return generateMethodAccessor(method);\n+            } else {\n+                NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method);\n+                return acc.getParent();\n+            }\n@@ -217,0 +203,14 @@\n+    \/**\n+     * Generate the MethodAccessor that invokes the given method with\n+     * bytecode invocation.\n+     *\/\n+    static MethodAccessorImpl generateMethodAccessor(Method method) {\n+        return (MethodAccessorImpl)new MethodAccessorGenerator()\n+                .generateMethod(method.getDeclaringClass(),\n+                                method.getName(),\n+                                method.getParameterTypes(),\n+                                method.getReturnType(),\n+                                method.getExceptionTypes(),\n+                                method.getModifiers());\n+    }\n+\n@@ -235,14 +235,2 @@\n-        \/\/ Bootstrapping issue: since we use Class.newInstance() in\n-        \/\/ the ConstructorAccessor generation process, we have to\n-        \/\/ break the cycle here.\n-        if (Reflection.isSubclassOf(declaringClass,\n-                                    ConstructorAccessorImpl.class)) {\n-            return new BootstrapConstructorAccessorImpl(c);\n-        }\n-\n-        if (noInflation && !c.getDeclaringClass().isHidden()) {\n-            return new MethodAccessorGenerator().\n-                generateConstructor(c.getDeclaringClass(),\n-                                    c.getParameterTypes(),\n-                                    c.getExceptionTypes(),\n-                                    c.getModifiers());\n+        if (useMethodHandleAccessor()) {\n+            return MethodHandleAccessorFactory.newConstructorAccessor(c);\n@@ -250,2 +238,17 @@\n-            NativeConstructorAccessorImpl acc = new NativeConstructorAccessorImpl(c);\n-            return acc.getParent();\n+            \/\/ Bootstrapping issue: since we use Class.newInstance() in\n+            \/\/ the ConstructorAccessor generation process, we have to\n+            \/\/ break the cycle here.\n+            if (Reflection.isSubclassOf(declaringClass, ConstructorAccessorImpl.class)) {\n+                return new BootstrapConstructorAccessorImpl(c);\n+            }\n+\n+            if (noInflation && !c.getDeclaringClass().isHidden()) {\n+                return new MethodAccessorGenerator().\n+                        generateConstructor(c.getDeclaringClass(),\n+                                            c.getParameterTypes(),\n+                                            c.getExceptionTypes(),\n+                                            c.getModifiers());\n+            } else {\n+                NativeConstructorAccessorImpl acc = new NativeConstructorAccessorImpl(c);\n+                return acc.getParent();\n+            }\n@@ -626,0 +629,16 @@\n+    static boolean noInflation() {\n+        return noInflation;\n+    }\n+\n+    static boolean useMethodHandleAccessor() {\n+        return (useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n+    }\n+\n+    static boolean useFieldHandleAccessor() {\n+        return (useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n+    }\n+\n+    static boolean useNativeAccessorOnly() {\n+        return useNativeAccessorOnly;\n+    }\n+\n@@ -655,0 +674,14 @@\n+        val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+        if (val != null) {\n+            if (val.equals(\"false\")) {\n+                useDirectMethodHandle = 0;\n+            } else if (val.equals(\"methods\")) {\n+                useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+            } else if (val.equals(\"fields\")) {\n+                useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+            }\n+        }\n+        val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+        if (val != null && val.equals(\"true\")) {\n+            useNativeAccessorOnly = true;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":86,"deletions":53,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -43,1 +42,0 @@\n-    @Stable\n@@ -49,1 +47,3 @@\n-        if (Modifier.isStatic(field.getModifiers()))\n+        int mods = field.getModifiers();\n+        this.isFinal = Modifier.isFinal(mods);\n+        if (Modifier.isStatic(mods))\n@@ -53,1 +53,0 @@\n-        isFinal = Modifier.isFinal(field.getModifiers());\n@@ -55,152 +54,0 @@\n-\n-    protected void ensureObj(Object o) {\n-        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n-        if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n-            throwSetIllegalArgumentException(o);\n-        }\n-    }\n-\n-    private String getQualifiedFieldName() {\n-      return field.getDeclaringClass().getName() + \".\" +field.getName();\n-    }\n-\n-    protected IllegalArgumentException newGetIllegalArgumentException(String type) {\n-        return new IllegalArgumentException(\n-          \"Attempt to get \"+field.getType().getName()+\" field \\\"\" +\n-          getQualifiedFieldName() + \"\\\" with illegal data type conversion to \"+type\n-        );\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(String attemptedType,\n-                                                         String attemptedValue)\n-                                                         throws IllegalAccessException {\n-        throw new IllegalAccessException(getSetMessage(attemptedType, attemptedValue));\n-\n-    }\n-    protected void throwFinalFieldIllegalAccessException(Object o) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(o != null ? o.getClass().getName() : \"\", \"\");\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(boolean z) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"boolean\", Boolean.toString(z));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(char b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"char\", Character.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(byte b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"byte\", Byte.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(short b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"short\", Short.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(int i) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"int\", Integer.toString(i));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(long i) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"long\", Long.toString(i));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(float f) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"float\", Float.toString(f));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(double f) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"double\", Double.toString(f));\n-    }\n-\n-    protected IllegalArgumentException newGetBooleanIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"boolean\");\n-    }\n-\n-    protected IllegalArgumentException newGetByteIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"byte\");\n-    }\n-\n-    protected IllegalArgumentException newGetCharIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"char\");\n-    }\n-\n-    protected IllegalArgumentException newGetShortIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"short\");\n-    }\n-\n-    protected IllegalArgumentException newGetIntIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"int\");\n-    }\n-\n-    protected IllegalArgumentException newGetLongIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"long\");\n-    }\n-\n-    protected IllegalArgumentException newGetFloatIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"float\");\n-    }\n-\n-    protected IllegalArgumentException newGetDoubleIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"double\");\n-    }\n-\n-    protected String getSetMessage(String attemptedType, String attemptedValue) {\n-        String err = \"Can not set\";\n-        if (Modifier.isStatic(field.getModifiers()))\n-            err += \" static\";\n-        if (isFinal)\n-            err += \" final\";\n-        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" to \";\n-        if (!attemptedValue.isEmpty()) {\n-            err += \"(\" + attemptedType + \")\" + attemptedValue;\n-        } else {\n-            if (!attemptedType.isEmpty())\n-                err += attemptedType;\n-            else\n-                err += \"null value\";\n-        }\n-        return err;\n-    }\n-\n-    protected void throwSetIllegalArgumentException(String attemptedType,\n-                                                    String attemptedValue) {\n-        throw new IllegalArgumentException(getSetMessage(attemptedType,attemptedValue));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(Object o) {\n-        throwSetIllegalArgumentException(o != null ? o.getClass().getName() : \"\", \"\");\n-    }\n-\n-    protected void throwSetIllegalArgumentException(boolean b) {\n-        throwSetIllegalArgumentException(\"boolean\", Boolean.toString(b));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(byte b) {\n-        throwSetIllegalArgumentException(\"byte\", Byte.toString(b));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(char c) {\n-        throwSetIllegalArgumentException(\"char\", Character.toString(c));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(short s) {\n-        throwSetIllegalArgumentException(\"short\", Short.toString(s));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(int i) {\n-        throwSetIllegalArgumentException(\"int\", Integer.toString(i));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(long l) {\n-        throwSetIllegalArgumentException(\"long\", Long.toString(l));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(float f) {\n-        throwSetIllegalArgumentException(\"float\", Float.toString(f));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(double d) {\n-        throwSetIllegalArgumentException(\"double\", Double.toString(d));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":4,"deletions":157,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.lang.reflect.Modifier;\n-import java.security.AccessController;\n@@ -33,3 +31,0 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -49,1 +44,0 @@\n-    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeStaticFieldAccessorImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"jdk_internal_reflect_DirectMethodHandleAccessor_NativeAccessor.h\"\n+#include \"jdk_internal_reflect_DirectConstructorHandleAccessor_NativeAccessor.h\"\n@@ -41,0 +43,11 @@\n+\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectMethodHandleAccessor_00024NativeAccessor_invoke0\n+(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)\n+{\n+    return JVM_InvokeMethod(env, m, obj, args);\n+}\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectConstructorHandleAccessor_00024NativeAccessor_newInstance0\n+(JNIEnv *env, jclass unused, jobject c, jobjectArray args)\n+{\n+    return JVM_NewInstanceFromConstructor(env, c, args);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/NativeAccessors.c","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -717,0 +718,1 @@\n+    @CallerSensitiveAdapter\n@@ -791,0 +793,1 @@\n+    @CallerSensitiveAdapter\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Logger.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -650,0 +651,1 @@\n+    @CallerSensitiveAdapter\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/DriverManager.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8265795 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8265795 generic-all\n+vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java 8265796  generic-all\n+\n+#############################################################################\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run testng\/othervm -Dsun.reflect.noInflation=true ShowReflectionTargetTest\n+ * @run testng\/othervm -Dsun.reflect.noInflation=true -Djdk.reflect.useDirectMethodHandle=false ShowReflectionTargetTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ShowReflectionTargetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2201,1 +2201,3 @@\n-        testMethodDepth = 8;\n+        \/\/ the method depth in debuggee is 11 as it includes all hidden frames\n+        \/\/ the expected method depth is 6 excluding 5 hidden frames\n+        testMethodDepth = 11-5;\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,3 +85,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"), \/\/ non-public class\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"), \/\/ non-public class\n@@ -141,3 +139,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -164,3 +160,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -171,3 +165,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -199,3 +191,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main NativeMethod\n+ * @run main\/othervm\/native -Xcheck:jni NativeMethod\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Method;\n@@ -47,5 +46,2 @@\n-    void test() throws Exception {\n-        \/\/ invoke via reflection that includes native methods\n-        Method m = NativeMethod.class.getDeclaredMethod(\"walk\");\n-        m.invoke(this);\n-    }\n+    \/\/ this native method will invoke NativeMethod::walk method\n+    public native void test();\n@@ -53,1 +49,1 @@\n-    void walk() {\n+    public void walk() {\n@@ -60,0 +56,7 @@\n+        \/\/ find NativeMethod::test native frame\n+        nativeFrames.stream().filter(f -> f.isNativeMethod()\n+                                            && f.getClassName().equals(\"NativeMethod\")\n+                                            && f.getMethodName().equals(\"test\"))\n+                    .findFirst()\n+                    .orElseThrow(() -> new RuntimeException(\"NativeMethod::test native method not found\"));\n+\n@@ -65,1 +68,0 @@\n-\n@@ -72,0 +74,4 @@\n+\n+    static {\n+        System.loadLibrary(\"nativeMethod\");\n+    }\n","filename":"test\/jdk\/java\/lang\/StackWalker\/NativeMethod.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -103,9 +103,6 @@\n-            \"5: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\" +\n-            \"6: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\\n\" +\n-            \"7: java.base\/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\" +\n-            \"8: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n-            \"9: VerifyStackTrace$1.run(VerifyStackTrace.java:220)\\n\" +\n-            \"10: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n-            \"11: VerifyStackTrace.test(VerifyStackTrace.java:229)\\n\" +\n-            \"12: VerifyStackTrace.main(VerifyStackTrace.java:185)\\n\";\n-\n+            \"5: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:94)\\n\" +\n+            \"6: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n+            \"7: VerifyStackTrace$1.run(VerifyStackTrace.java:220)\\n\" +\n+            \"8: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n+            \"9: VerifyStackTrace.test(VerifyStackTrace.java:229)\\n\" +\n+            \"10: VerifyStackTrace.main(VerifyStackTrace.java:185)\\n\";\n@@ -133,16 +130,18 @@\n-            \"1: VerifyStackTrace.lambda$test$1(VerifyStackTrace.java:213)\\n\" +\n-            \"2: VerifyStackTrace$$Lambda$1\/0x00000007c0089430.run(Unknown Source)\\n\" +\n-            \"3: VerifyStackTrace$Handle.execute(VerifyStackTrace.java:149)\\n\" +\n-            \"4: java.base\/java.lang.invoke.LambdaForm$DMH\/0x00000007c008a830.invokeVirtual_LL_V(LambdaForm$DMH)\\n\" +\n-            \"5: java.base\/java.lang.invoke.LambdaForm$MH\/0x00000007c008a830.invoke_MT(LambdaForm$MH)\\n\" +\n-            \"6: VerifyStackTrace$Handle.run(VerifyStackTrace.java:162)\\n\" +\n-            \"7: VerifyStackTrace.invoke(VerifyStackTrace.java:192)\\n\" +\n-            \"8: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\" +\n-            \"9: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\\n\" +\n-            \"10: java.base\/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\" +\n-            \"11: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n-            \"12: VerifyStackTrace$1.run(VerifyStackTrace.java:222)\\n\" +\n-            \"13: java.base\/java.security.AccessController.executePrivileged(AccessController.java:759)\\n\" +\n-            \"14: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n-            \"15: VerifyStackTrace.test(VerifyStackTrace.java:231)\\n\" +\n-            \"16: VerifyStackTrace.main(VerifyStackTrace.java:188)\\n\";\n+            \"1: VerifyStackTrace.lambda$test$1(VerifyStackTrace.java:280)\\n\" +\n+            \"2: VerifyStackTrace$$Lambda$1\/0x0000000801001848.run(Unknown Source)\\n\" +\n+            \"3: VerifyStackTrace$Handle.execute(VerifyStackTrace.java:206)\\n\" +\n+            \"4: java.base\/java.lang.invoke.DirectMethodHandle$Holder.invokeVirtual(DirectMethodHandle$Holder)\\n\" +\n+            \"5: java.base\/java.lang.invoke.LambdaForm$MH\/0x0000000801004800.invoke_MT(LambdaForm$MH)\\n\" +\n+            \"6: VerifyStackTrace$Handle.run(VerifyStackTrace.java:219)\\n\" +\n+            \"7: VerifyStackTrace.invoke(VerifyStackTrace.java:259)\\n\" +\n+            \"8: java.base\/java.lang.invoke.LambdaForm$DMH\/0x0000000801002000.invokeStatic(LambdaForm$DMH)\\n\" +\n+            \"9: java.base\/java.lang.invoke.LambdaForm$MH\/0x0000000801003000.invoke(LambdaForm$MH)\\n\" +\n+            \"10: java.base\/java.lang.invoke.Invokers$Holder.invokeExact_MT(Invokers$Holder)\\n\" +\n+            \"11: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(DirectMethodHandleAccessor.java:211)\\n\" +\n+            \"12: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:122)\\n\" +\n+            \"13: java.base\/java.lang.reflect.Method.invoke(Method.java:573)\\n\" +\n+            \"14: VerifyStackTrace$1.run(VerifyStackTrace.java:292)\\n\" +\n+            \"15: java.base\/java.security.AccessController.executePrivileged(AccessController.java:753)\\n\" +\n+            \"16: java.base\/java.security.AccessController.doPrivileged(AccessController.java:312)\\n\" +\n+            \"17: VerifyStackTrace.test(VerifyStackTrace.java:301)\\n\" +\n+            \"18: VerifyStackTrace.main(VerifyStackTrace.java:254)\\n\";\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static jclass test_class;\n+static jmethodID mid;\n+static jint current_jni_version = JNI_VERSION_10;\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved) {\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    (*vm)->GetEnv(vm, (void **) &env, current_jni_version);\n+\n+    cl = (*env)->FindClass(env, \"NativeMethod\");\n+    test_class = (*env)->NewGlobalRef(env, cl);\n+    mid = (*env)->GetMethodID(env, test_class, \"walk\", \"()V\");\n+\n+    return current_jni_version;\n+}\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    test\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_NativeMethod_test(JNIEnv *env, jobject obj) {\n+    (*env)->CallVoidMethod(env, obj, mid);\n+\n+    if ((*env)->ExceptionCheck(env)) {\n+        (*env)->ExceptionDescribe(env);\n+        (*env)->FatalError(env, \"Exception thrown\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StackWalker\/libnativeMethod.c","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @run testng\/othervm CallerSensitiveMethodHandle\n+ * @summary Check Lookup findVirtual, findStatic and unreflect behavior with\n+ *          caller sensitive methods with focus on AccessibleObject.setAccessible\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Field;\n+\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n+public class CallerSensitiveMethodHandle {\n+    private static int field = 0;\n+    @Test\n+    public void privateField() throws Throwable {\n+        Lookup l = MethodHandles.lookup();\n+        Field f = CallerSensitiveMethodHandle.class.getDeclaredField(\"field\");\n+        MethodHandle mh = l.findVirtual(Field.class, \"setInt\", methodType(void.class, Object.class, int.class));\n+        int newValue = 5;\n+        mh.invokeExact(f, (Object) null, newValue);\n+        assertTrue(field == newValue);\n+    }\n+\n+    @Test\n+    public void lookupItself() throws Throwable {\n+        Lookup lookup = MethodHandles.lookup();\n+        MethodHandle MH_lookup2 = lookup.findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup2 = (Lookup) MH_lookup2.invokeExact();\n+        System.out.println(lookup2 + \" original lookup class \" + lookup.lookupClass());\n+        assertTrue(lookup2.lookupClass() == lookup.lookupClass());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveMethodHandle.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MethodHandle::invokeExact and MethodHandle::invoke throws\n+ *          UnsupportedOperationException when called via Method::invoke\n+ * @run testng test.java.lang.invoke.MethodHandleInvokeUOE\n+ *\/\n+\n+package test.java.lang.invoke;\n+\n+import org.testng.*;\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import static java.lang.invoke.MethodType.*;\n+\n+public class MethodHandleInvokeUOE {\n+    @Test\n+    public void testInvokeExact() throws Throwable {\n+        Class<?> clz = MethodHandle.class;\n+        String mname = \"invokeExact\";\n+        Method m = clz.getDeclaredMethod(mname, Object[].class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(clz, mname, methodType(Object.class, Object[].class));\n+        try {\n+            m.invoke(mh, new Object[1]);\n+        } catch (InvocationTargetException e) {\n+            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                        + e.getCause().getClass().getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testInvoke() throws Throwable {\n+        Class<?> clz = MethodHandle.class;\n+        String mname = \"invoke\";\n+        Method m = clz.getDeclaredMethod(mname, Object[].class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(clz, mname, methodType(Object.class, Object[].class));\n+        try {\n+            m.invoke(mh, new Object[1]);\n+        } catch (InvocationTargetException e) {\n+            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                        + e.getCause().getClass().getName(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleInvokeUOE.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8196830 8235351\n+ * @bug 8196830 8235351 8257874\n@@ -358,0 +358,34 @@\n+    \/**\n+     * Field::getInt and Field::setInt are caller-sensitive methods.\n+     * Test access to private field.\n+     *\/\n+    private static int privateField = 0;\n+    @Test\n+    public void testPrivateField() throws Throwable {\n+        Field f = CallerSensitiveAccess.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, int.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setInt\", mtype);\n+        mh.invokeExact(f, (Object)null, 5);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getInt\", MethodType.methodType(int.class, Object.class));\n+        int value = (int)mh.invokeExact(f, (Object)null);\n+        assertTrue(value == 5);\n+    }\n+\n+    private static class Inner {\n+        private static boolean privateField = false;\n+    }\n+\n+    @Test\n+    public void testInnerPrivateField() throws Throwable {\n+        Field f = Inner.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, boolean.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setBoolean\", mtype);\n+        mh.invokeExact(f, (Object)null, true);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getBoolean\", MethodType.methodType(boolean.class, Object.class));\n+        boolean value = (boolean)mh.invokeExact(f, (Object)null);\n+        assertTrue(value);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/CallerSensitiveAccess.java","additions":35,"deletions":1,"binary":false,"changes":36,"previous_filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveAccess.java","status":"renamed"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @library src\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build java.base\/java.util.CSM csm\/*\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest sm\n+ * @summary Test proper caller class is bound to method handle for caller-sensitive method\n+ *\/\n+public class Main {\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/Main.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.CSM;\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+import java.security.Permissions;\n+import java.security.Policy;\n+import java.security.ProtectionDomain;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * This test invokes caller-sensitive methods via static reference,\n+ * reflection, MethodHandle, lambda.  If there is no alternate implementation\n+ * of a CSM with a trailing caller class parameter, when a CSM is invoked\n+ * via method handle, an invoker class is injected as the caller class\n+ * which is defined by the same defining class loader, in the same runtime\n+ * package, and protection domain as the lookup class.\n+ *\/\n+public class MethodInvokeTest {\n+    static final Policy DEFAULT_POLICY = Policy.getPolicy();\n+    private static final String CALLER_METHOD = \"caller\";\n+    private static final String CALLER_NO_ALT_METHOD = \"callerNoAlternateImpl\";\n+\n+    public static void main(String... args) throws Throwable {\n+        boolean sm = args.length > 0 && args[0].equals(\"sm\");\n+        System.err.format(\"Test %s security manager.%n\",\n+                          sm ? \"with\" : \"without\");\n+        if (sm) {\n+            setupSecurityManager();\n+        }\n+\n+        MethodInvokeTest test = new MethodInvokeTest();\n+        \/\/ test static call to java.util.CSM::caller\n+        test.staticMethodCall();\n+        \/\/ test java.lang.reflect.Method call\n+        test.reflectMethodCall();\n+        \/\/ test java.lang.invoke.MethodHandle\n+        test.invokeMethodHandle();\n+        \/\/ test method ref\n+        test.lambda();\n+    }\n+\n+    static void setupSecurityManager() {\n+        PermissionCollection perms = new Permissions();\n+        perms.add(new RuntimePermission(\"getStackWalkerWithClassReference\"));\n+        Policy.setPolicy(new Policy() {\n+            @Override\n+            public boolean implies(ProtectionDomain domain, Permission p) {\n+                return perms.implies(p) || DEFAULT_POLICY.implies(domain, p);\n+            }\n+        });\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    void staticMethodCall() {\n+        checkCaller(java.util.CSM.caller(), MethodInvokeTest.class, true);\n+        checkCaller(java.util.CSM.callerNoAlternateImpl(), MethodInvokeTest.class, false);\n+    }\n+\n+    void reflectMethodCall() throws Throwable {\n+        \/\/ zero-arg caller method\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller1.class, true);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller2.class, true);\n+        \/\/ 4-arg caller method\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD, Object.class, Object.class, Object.class, Object.class),\n+                                   new Object[] { null, null, null, null}), Caller1.class, true);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD, Object.class, Object.class, Object.class, Object.class),\n+                                   new Object[] { null, null, null, null}), Caller2.class, true);\n+\n+        \/\/ Reflection::getCallerClass will return the injected invoker class as the caller\n+        checkInjectedInvoker(Caller1.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller1.class);\n+        checkInjectedInvoker(Caller2.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller2.class);\n+    }\n+\n+    void invokeMethodHandle() throws Throwable {\n+        checkCaller(Caller1.invokeExact(CALLER_METHOD), Caller1.class, true);\n+        checkCaller(Caller2.invokeExact(CALLER_METHOD), Caller2.class, true);\n+\n+        checkInjectedInvoker(Caller1.invokeExact(CALLER_NO_ALT_METHOD), Caller1.class);\n+        checkInjectedInvoker(Caller2.invokeExact(CALLER_NO_ALT_METHOD), Caller2.class);\n+    }\n+\n+    void lambda() {\n+        CSM caller = LambdaTest.caller.get();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+\n+        caller = LambdaTest.caller();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+    }\n+\n+    static class Caller1 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invoke(Method csm, Object[] args) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null, args);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class Caller2 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invoke(Method csm, Object[] args) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null, args);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class LambdaTest {\n+        static Supplier<CSM> caller = java.util.CSM::caller;\n+\n+        static CSM caller() {\n+            return caller.get();\n+        }\n+\n+        \/*\n+         * The class calling the caller-sensitive method is the lambda proxy class\n+         * generated for LambdaTest.\n+         *\/\n+        static void checkLambdaProxyClass(CSM csm) {\n+            Class<?> caller = csm.caller;\n+            assertTrue(caller.isHidden(), caller + \" should be a hidden class\");\n+            assertEquals(caller.getModule(), LambdaTest.class.getModule());\n+\n+            int index = caller.getName().indexOf('\/');\n+            String cn = caller.getName().substring(0, index);\n+            assertTrue(cn.startsWith(LambdaTest.class.getName() + \"$$Lambda$\"), caller + \" should be a lambda proxy class\");\n+        }\n+    }\n+    static void checkCaller(CSM csm, Class<?> expected, boolean adapter) {\n+        assertEquals(csm.caller, expected);\n+        assertEquals(csm.adapter, adapter);\n+        \/\/ verify no invoker class injected\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c == expected) break;\n+\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                throw new RuntimeException(\"should not have any invoker class injected\");\n+        }\n+    }\n+\n+    \/*\n+     * The class calling the direct method handle of the caller-sensitive class\n+     * is the InjectedInvoker class generated for the given caller.\n+     *\/\n+    static void checkInjectedInvoker(CSM csm, Class<?> expected) {\n+        Class<?> invoker = csm.caller;\n+        assertTrue(invoker.isHidden(), invoker + \" should be a hidden class\");\n+        assertEquals(invoker.getModule(), expected.getModule());\n+        assertEquals(csm.adapter, false);\n+\n+        int index = invoker.getName().indexOf('\/');\n+        String cn = invoker.getName().substring(0, index);\n+        assertEquals(cn, expected.getName() + \"$$InjectedInvoker\");\n+\n+        \/\/ check the invoker class on the stack\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                break;\n+\n+            if (c == expected)\n+                throw new RuntimeException(\"no invoker class found before the expected caller class\");\n+        }\n+    }\n+\n+    static void assertTrue(boolean value, String msg) {\n+        if (!value) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+    static void assertEquals(Object o1, Object o2) {\n+        if (!o1.equals(o2)) {\n+            throw new RuntimeException(o1 + \" != \" + o2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/jdk\/test\/MethodInvokeTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module csm {\n+    exports jdk.test;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n+import jdk.internal.reflect.Reflection;\n+\n+import static java.lang.StackWalker.Option.*;\n+\n+public class CSM {\n+    public final Class<?> caller;\n+    public final List<StackFrame> stackFrames;\n+    public final boolean adapter;\n+    CSM(Class<?> caller, boolean adapter) {\n+        this.caller = caller;\n+        StackWalker sw = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES));\n+        this.stackFrames = sw.walk(Stream::toList);\n+        this.adapter = adapter;\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass except if this method is called\n+     * via method handle.\n+     *\/\n+    @CallerSensitive\n+    public static CSM caller() {\n+        return caller(Reflection.getCallerClass());\n+    }\n+\n+    \/**\n+     * If caller() is invoked via method handle, this alternate method is\n+     * called instead.  The caller class would be the lookup class.\n+     *\/\n+    @CallerSensitiveAdapter\n+    private static CSM caller(Class<?> caller) {\n+        return new CSM(caller, true);\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass.\n+     *\/\n+    @CallerSensitive\n+    public static CSM callerNoAlternateImpl() {\n+        return new CSM(Reflection.getCallerClass(), false);\n+    }\n+\n+    @CallerSensitive\n+    public static CSM caller(Object o1, Object o2, Object o3, Object o4) {\n+        return caller(o1, o2, o3, o4, Reflection.getCallerClass());\n+    }\n+\n+    \/**\n+     * If caller() is invoked via method handle, this alternate method is\n+     * called instead.  The caller class would be the lookup class.\n+     *\/\n+    @CallerSensitiveAdapter\n+    private static CSM caller(Object o1, Object o2, Object o3, Object o4, Class<?> caller) {\n+        return new CSM(caller, true);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/src\/java.base\/java\/util\/CSM.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @run testng\/othervm ChainedLookupTest\n+ * @summary Test MethodHandles.lookup method to produce the Lookup object with\n+ *          proper lookup class if invoked through reflection and method handle.\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Method;\n+\n+import org.testng.annotations.Test;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n+public class ChainedLookupTest {\n+    \/**\n+     * Direct call to MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void staticLookup() throws Throwable {\n+        Lookup lookup =  lookup();\n+        test(lookup, \"Lookup produced via direct call to MethodHandles.lookup()\");\n+    }\n+\n+    \/**\n+     * Reflective Method::invoke on MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void methodInvoke() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+        Lookup lookup = (Lookup) m.invoke(null);\n+        test(lookup, \"Lookup produced via reflective call\");\n+    }\n+\n+    \/**\n+     * Invoke Method::invoke on MethodHandles::lookup via MethodHandle\n+     *\/\n+    @Test\n+    public void methodInvokeViaMethodHandle() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+\n+        MethodHandle mh = lookup().findVirtual(Method.class, \"invoke\",\n+                                               methodType(Object.class, Object.class, Object[].class));\n+        Lookup lookup = (Lookup)mh.invoke(m, (Object)null, (Object[])null);\n+        test(lookup, \"Lookup produced via Method::invoke via MethodHandle\");\n+    }\n+\n+    \/**\n+     * Invoke MethodHandle on MethodHandles::lookup via Method::invoke\n+     *\/\n+    \/\/ @Test\n+    public void methodHandleViaReflection() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+\n+        Method m =  MethodHandle.class.getMethod(\"invoke\", Object[].class);\n+\n+        \/\/ should this throw UnsupportedOperationException per MethodHandle::invoke spec?\n+        lookup = (Lookup)m.invoke(MH_lookup);\n+        test(lookup, \"Lookup produced via MethodHandle::invoke via Method::invoke\");\n+    }\n+\n+    \/**\n+     * MethodHandle::invokeExact on MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void methodHandle() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        test(lookup, \"Lookup produced via MethodHandle\");\n+    }\n+\n+    \/**\n+     * MethodHandles::unreflect the reflective Method representing MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void unreflect() throws Throwable {\n+        MethodHandle MH_lookup = lookup().unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        test(lookup, \"Lookup produced via unreflect MethodHandle\");\n+    }\n+\n+    \/**\n+     * Use the Lookup object returned from MethodHandle::invokeExact on MethodHandles::lookup\n+     * to look up MethodHandle representing MethodHandles::lookup and then invoking it.\n+     *\/\n+    @Test\n+    public void chainedMethodHandle() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        MethodHandle MH_lookup2 = lookup.unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup2 = (Lookup) MH_lookup2.invokeExact();\n+        test(lookup2, \"Lookup produced via a chained call to MethodHandle\");\n+    }\n+\n+    void test(Lookup lookup, String msg) throws Throwable {\n+        assertTrue(lookup.lookupClass() == ChainedLookupTest.class);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+\n+        MethodHandle mh = lookup.findStatic(lookup.lookupClass(), \"say\", methodType(void.class, String.class));\n+        mh.invokeExact(msg);\n+    }\n+\n+    private static void say(String msg) {\n+        System.out.println(msg);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ChainedLookupTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -55,3 +55,1 @@\n-        if (!lookupMethod.getName().equals(\"lookup\")) {\n-            throw new RuntimeException(\"Unexpected name: \" + lookupMethod.getName());\n-        }\n+        assertEquals(lookupMethod.getName(), \"lookup\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ReflectiveLookupTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            if (!(e.getCause() instanceof IllegalArgumentException)) {\n+            if (!(e.getCause() instanceof InternalError)) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/java.base\/java\/lang\/LookupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm ChainedReflection\n+ * @summary Test Method::invoke and Constructor::newInstance chained calls that\n+ *          should wrap NPE in InvocationTargetException properly\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Optional;\n+\n+import org.testng.annotations.Test;\n+\n+public class ChainedReflection {\n+    public ChainedReflection() {}\n+\n+    ChainedReflection(Void dummy) throws ReflectiveOperationException {\n+        Method m = ChainedReflection.class.getMethod(\"throwNPE\");\n+        try {\n+            m.invoke(null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (t instanceof NullPointerException npe) {\n+                throw npe;\n+            } else {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+\n+    public static void throwNPE() {\n+        throw new NullPointerException();\n+    }\n+\n+    \/*\n+     * Wrap a NullPointerException with a new NullPointerException\n+     *\/\n+    public static void npe() throws ReflectiveOperationException {\n+        NullPointerException cause;\n+        try {\n+            Optional.of(null);\n+            throw new RuntimeException(\"NPE not thrown\");\n+        } catch (NullPointerException e) {\n+            cause = e;\n+        }\n+        Class<?> c = NullPointerException.class;\n+        Constructor<?> ctor = c.getConstructor();\n+        NullPointerException npe = (NullPointerException) ctor.newInstance();\n+        npe.initCause(cause);\n+        throw npe;\n+    }\n+\n+    \/**\n+     * Tests the target method being invoked via core reflection that\n+     * throws NullPointerException allocated via Constructor::newInstance.\n+     * The newly allocated NPE thrown by the target method should be\n+     * wrapped by InvocationTargetException.\n+     *\/\n+    @Test\n+    public void methodCallNewInstance() throws ReflectiveOperationException {\n+        Method m = ChainedReflection.class.getMethod(\"npe\");\n+        try {\n+            m.invoke(null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (!(t instanceof NullPointerException)) {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+\n+    \/**\n+     * Tests a constructor C calling the method \"throwNPE\" that throws\n+     * a new instance of NullPointerException.\n+     * C::newInstance should wrap NullPointerException thrown by\n+     * Method::invoke on \"throwNPE\"  by InvocationTargetException.\n+     *\/\n+    @Test\n+    public void ctorCallMethodInvoke() throws ReflectiveOperationException {\n+        Constructor<?> ctor = ChainedReflection.class.getDeclaredConstructor(Void.class);\n+        try {\n+            ctor.newInstance((Void)null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (!(t instanceof NullPointerException)) {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/ChainedReflection.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -90,4 +90,4 @@\n-        testUnsafeStaticFieldAccessors();\n-        testUnsafeQualifiedStaticFieldAccessors();\n-        testUnsafeFieldAccessors();\n-        testUnsafeQualifiedFieldAccessors();\n+        testStaticFieldAccessors();\n+        testStaticVolatileFieldAccessors();\n+        testFieldAccessors();\n+        testVolatileFieldAccessors();\n@@ -96,1 +96,1 @@\n-    private static void testUnsafeStaticFieldAccessors() {\n+    private static void testStaticFieldAccessors() {\n@@ -100,1 +100,1 @@\n-    private static void testUnsafeQualifiedStaticFieldAccessors() {\n+    private static void testStaticVolatileFieldAccessors() {\n@@ -104,1 +104,1 @@\n-    private static void testUnsafeFieldAccessors() {\n+    private static void testFieldAccessors() {\n@@ -108,1 +108,1 @@\n-    private static void testUnsafeQualifiedFieldAccessors() {\n+    private static void testVolatileFieldAccessors() {\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/TestFieldReflectValueOf.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6824466\n+ * @modules java.base\/jdk.internal.reflect\n+ * @summary Test compliance of ConstructorAccessor, FieldAccessor, MethodAccessor implementations\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=true -Dsun.reflect.inflationThreshold=1 -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.reflect\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=true -Djdk.reflect.noInflation=true -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.reflect\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=false -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\n+\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.FieldAccessor;\n+import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.reflect.ReflectionFactory;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class MethodHandleAccessorsTest {\n+\n+    public static void public_static_V() {}\n+\n+    public static int public_static_I() { return 42; }\n+\n+    public void public_V() {}\n+\n+    public int public_I() { return 42; }\n+\n+    public static void public_static_I_V(int i) {}\n+\n+    public static int public_static_I_I(int i) { return i; }\n+\n+    public void public_I_V(int i) {}\n+\n+    public int public_I_I(int i) { return i; }\n+\n+    private static void private_static_V() {}\n+\n+    private static int private_static_I() { return 42; }\n+\n+    private void private_V() {}\n+\n+    private int private_I() { return 42; }\n+\n+    private static void private_static_I_V(int i) {}\n+\n+    private static int private_static_I_I(int i) { return i; }\n+\n+    private void private_I_V(int i) {}\n+\n+    private int private_I_I(int i) { return i; }\n+\n+    public static int varargs(int... values) {\n+        int sum = 0;\n+        for (int i : values) sum += i;\n+        return sum;\n+\n+    }\n+    public static int varargs_primitive(int first, int... rest) {\n+        int sum = first;\n+        if (rest != null) {\n+            sum *= 100;\n+            for (int i : rest) sum += i;\n+        }\n+        return sum;\n+    }\n+\n+    public static String varargs_object(String first, String... rest) {\n+        StringBuilder sb = new StringBuilder(first);\n+        if (rest != null) {\n+            sb.append(Stream.of(rest).collect(Collectors.joining(\",\", \"[\", \"]\")));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static final class Public {\n+        public static final int STATIC_FINAL = 1;\n+        private final int i;\n+        private final String s;\n+\n+        public Public() {\n+            this.i = 0;\n+            this.s = null;\n+        }\n+\n+        public Public(int i) {\n+            this.i = i;\n+            this.s = null;\n+        }\n+\n+        public Public(String s) {\n+            this.i = 0;\n+            this.s = s;\n+        }\n+\n+        public Public(int first, int... rest) {\n+            this(varargs_primitive(first, rest));\n+        }\n+\n+        public Public(String first, String... rest) {\n+            this(varargs_object(first, rest));\n+        }\n+\n+        public Public(RuntimeException exc) {\n+            throw exc;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Public other = (Public) o;\n+            return i == other.i &&\n+                   Objects.equals(s, other.s);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(i, s);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Public{\" +\n+                   \"i=\" + i +\n+                   \", s='\" + s + '\\'' +\n+                   '}';\n+        }\n+    }\n+\n+    static final class Private {\n+        private final int i;\n+\n+        private Private() {\n+            this.i = 0;\n+        }\n+\n+        private Private(int i) {\n+            this.i = i;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Private other = (Private) o;\n+            return i == other.i;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(i);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Private{\" +\n+                   \"i=\" + i +\n+                   '}';\n+        }\n+    }\n+\n+    static final class Thrower {\n+        public Thrower(RuntimeException exc) {\n+            throw exc;\n+        }\n+        public static void throws_exception(RuntimeException exc) {\n+            throw exc;\n+        }\n+    }\n+\n+    public static abstract class Abstract {\n+        public Abstract() {\n+        }\n+    }\n+\n+    \/**\n+     * Tests if MethodAccessor::invoke implementation returns the expected\n+     * result or exceptions.\n+     *\/\n+    static void doTestAccessor(Method m, MethodAccessor ma, Object target, Object[] args,\n+                               Object expectedReturn, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = ma.invoke(target, args);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + m + \", invoked with target: \" + target + \", args: \" + Arrays.toString(args));\n+\n+        chechResult(ret, expectedReturn, exc, expectedExceptions);\n+    }\n+\n+    \/**\n+     * Tests if ConstructorAccessor::newInstance implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Constructor c, ConstructorAccessor ca, Object[] args,\n+                               Object expectedReturn, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = ca.newInstance(args);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + c + \", invoked with args: \" + Arrays.toString(args));\n+        chechResult(ret, expectedReturn, exc, expectedExceptions);\n+    }\n+\n+    \/**\n+     * Tests if FieldAccessor::get implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Field f, FieldAccessor fa, Object target,\n+                               Object expectedValue, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = fa.get(target);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + f + \", invoked with target: \" + target + \", value: \" + ret);\n+        chechResult(ret, expectedValue, exc, expectedExceptions);\n+\n+    }\n+\n+    \/**\n+     * Tests if FieldAccessor::set implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Field f, FieldAccessor fa, Object target, Object oldValue,\n+                               Object newValue, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+            try {\n+                fa.set(target, newValue);\n+                exc = null;\n+                ret = fa.get(target);\n+            } catch (Throwable e) {\n+                ret = null;\n+                exc = e;\n+            }\n+            System.out.println(\"\\n\" + f + \", invoked with target: \" + target + \", value: \" + ret);\n+            chechResult(ret, newValue, exc, expectedExceptions);\n+    }\n+\n+    static void chechResult(Object ret, Object expectedReturn, Throwable exc, Throwable... expectedExceptions) {\n+        if (exc != null) {\n+            checkException(exc, expectedExceptions);\n+        } else if (expectedExceptions.length > 0) {\n+            fail(exc, expectedExceptions);\n+        } else if (!Objects.equals(ret, expectedReturn)) {\n+            throw new AssertionError(\"Expected return:\\n \" + expectedReturn + \"\\ngot:\\n \" + ret);\n+        } else {\n+            System.out.println(\"    Got expected return: \" + ret);\n+        }\n+    }\n+\n+    static void checkException(Throwable exc, Throwable... expectedExceptions) {\n+        boolean match = false;\n+        for (Throwable expected : expectedExceptions) {\n+            if (exceptionMatches(exc, expected)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        if (match) {\n+            System.out.println(\"    Got expected exception: \" + exc);\n+            if (exc.getCause() != null) {\n+                System.out.println(\"                with cause: \" + exc.getCause());\n+            }\n+        } else {\n+            fail(exc, expectedExceptions);\n+        }\n+    }\n+\n+    static boolean exceptionMatches(Throwable exc, Throwable expected) {\n+        return expected.getClass().isInstance(exc) &&\n+                (Objects.equals(expected.getMessage(), exc.getMessage()) ||\n+                        (exc.getMessage() != null && expected.getMessage() != null &&\n+                         exc.getMessage().startsWith(expected.getMessage()))) &&\n+                (expected.getCause() == null || exceptionMatches(exc.getCause(), expected.getCause()));\n+    }\n+\n+    static void fail(Throwable thrownException, Throwable... expectedExceptions) {\n+        String msg;\n+        if (thrownException == null) {\n+            msg = \"No exception thrown but there were expected exceptions (see suppressed)\";\n+        } else if (expectedExceptions.length == 0) {\n+            msg = \"Exception thrown (see cause) but there were no expected exceptions\";\n+        } else {\n+            msg = \"Exception thrown (see cause) but expected exceptions were different (see suppressed)\";\n+        }\n+        AssertionError error = new AssertionError(msg, thrownException);\n+        Stream.of(expectedExceptions).forEach(error::addSuppressed);\n+        throw error;\n+    }\n+\n+    static void doTest(Method m, Object target, Object[] args, Object expectedReturn, Throwable... expectedException) {\n+        MethodAccessor ma = ReflectionFactory.getReflectionFactory().newMethodAccessor(m, Reflection.isCallerSensitive(m));\n+        try {\n+            doTestAccessor(m, ma, target, args, expectedReturn, expectedException);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(ma.getClass().getName() + \" for method: \" + m + \" test failure\", e);\n+        }\n+    }\n+\n+    static void doTest(Constructor c, Object[] args, Object expectedReturn, Throwable... expectedExceptions) {\n+        ConstructorAccessor ca = ReflectionFactory.getReflectionFactory().newConstructorAccessor(c);\n+        try {\n+            doTestAccessor(c, ca, args, expectedReturn, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(ca.getClass().getName() + \" for constructor: \" + c + \" test failure\", e);\n+        }\n+    }\n+    static void doTest(Field f, Object target, Object expectedValue, Throwable... expectedExceptions) {\n+        FieldAccessor fa = ReflectionFactory.getReflectionFactory().newFieldAccessor(f, false);\n+        try {\n+            doTestAccessor(f, fa, target, expectedValue, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(fa.getClass().getName() + \" for field: \" + f + \" test failure\", e);\n+        }\n+    }\n+    static void doTest(Field f, Object target, Object oldValue, Object newValue, Throwable... expectedExceptions) {\n+        FieldAccessor fa = ReflectionFactory.getReflectionFactory().newFieldAccessor(f, true);\n+        try {\n+            doTestAccessor(f, fa, target, oldValue, newValue, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(fa.getClass().getName() + \" for field: \" + f + \" test failure\", e);\n+        }\n+    }\n+\n+    private static final Throwable[] noException = new Throwable[0];\n+    private static final Throwable[] mismatched_argument_type = new Throwable[] {\n+            new IllegalArgumentException(\"argument type mismatch\")\n+    };\n+    private static final Throwable[] mismatched_target_type = new Throwable[] {\n+            new IllegalArgumentException(\"argument type mismatch\"),\n+            new IllegalArgumentException(\"object is not an instance of declaring class\"),\n+    };\n+    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get final\")\n+    };\n+    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set final\")\n+    };\n+    private static final Throwable[] wrong_argument_count_no_details = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\")\n+    };\n+    private static final Throwable[] wrong_argument_count = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\"),\n+            new IllegalArgumentException(\"array is not of length 1\")\n+    };\n+    private static final Throwable[] null_argument = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\"),\n+            new IllegalArgumentException(\"null array reference\")\n+    };\n+    private static final Throwable[] null_argument_value = new Throwable[] {\n+            new IllegalArgumentException()\n+    };\n+    private static final Throwable[] null_argument_value_npe = new Throwable[] {\n+            new IllegalArgumentException(\"java.lang.NullPointerException\"),\n+            new NullPointerException()\n+    };\n+    private static final Throwable[] null_target = new Throwable[] {\n+            new NullPointerException()\n+    };\n+    private static final Throwable[] wrapped_npe_no_msg = new Throwable[]{\n+            new InvocationTargetException(new NullPointerException())\n+    };\n+    private static final Throwable[] wrapped_npe = new Throwable[]{\n+            new InvocationTargetException(new NullPointerException(\"NPE\"))\n+    };\n+    private static final Throwable[] wrapped_cce = new Throwable[]{\n+            new InvocationTargetException(new ClassCastException(\"CCE\"))\n+    };\n+    private static final Throwable[] wrapped_iae = new Throwable[]{\n+            new InvocationTargetException(new IllegalArgumentException(\"IAE\"))\n+    };\n+\n+\n+    @DataProvider(name = \"testNoArgMethods\")\n+    private Object[][] testNoArgMethods() {\n+        MethodHandleAccessorsTest inst = new MethodHandleAccessorsTest();\n+        Object[] emptyArgs = new Object[]{};\n+        return new Object[][] {\n+             new Object[] {\"public_static_V\",   null, emptyArgs, null, noException},\n+             new Object[] {\"public_static_V\",   null, null, null, noException},\n+             new Object[] {\"public_static_I\",   null, emptyArgs, 42, noException},\n+             new Object[] {\"public_static_I\",   null, null, 42, noException},\n+             new Object[] {\"public_V\",          inst, emptyArgs, null, noException},\n+             new Object[] {\"public_V\",          inst, null, null, noException},\n+             new Object[] {\"public_I\",          inst, emptyArgs, 42, noException},\n+             new Object[] {\"public_I\",          inst, null, 42, noException},\n+             new Object[] {\"private_static_V\",  null, emptyArgs, null, noException},\n+             new Object[] {\"private_static_I\",  null, emptyArgs, 42, noException},\n+             new Object[] {\"private_V\",         inst, emptyArgs, null, noException},\n+             new Object[] {\"private_I\",         inst, emptyArgs, 42, noException},\n+             new Object[] {\"public_V\",          null, null, null, null_target},\n+        };\n+    }\n+\n+    @DataProvider(name = \"testOneArgMethods\")\n+    private Object[][] testOneArgMethods() {\n+        MethodHandleAccessorsTest inst = new MethodHandleAccessorsTest();\n+        Object wrongInst = new Object();\n+        boolean newImpl = Boolean.getBoolean(\"jdk.reflect.useDirectMethodHandle\");\n+        return new Object[][]{\n+            new Object[] {\"public_static_I_V\",  int.class, null, new Object[]{12}, null, noException},\n+            new Object[] {\"public_static_I_I\",  int.class, null, new Object[]{12}, 12, noException},\n+            new Object[] {\"public_I_V\",         int.class, inst, new Object[]{12}, null, noException},\n+            new Object[] {\"public_I_I\",         int.class, inst, new Object[]{12}, 12, noException},\n+            new Object[] {\"private_static_I_V\", int.class, null, new Object[]{12}, null, noException},\n+            new Object[] {\"private_static_I_I\", int.class, null, new Object[]{12}, 12, noException},\n+            new Object[] {\"private_I_V\",        int.class, inst, new Object[]{12}, null, noException},\n+            new Object[] {\"private_I_I\",        int.class, inst, new Object[]{12}, 12, noException},\n+\n+            new Object[] {\"public_static_I_I\", int.class, null, new Object[]{\"a\"}, null, mismatched_argument_type},\n+            new Object[] {\"public_I_I\",        int.class, inst, new Object[]{\"a\"}, null, mismatched_argument_type},\n+            new Object[] {\"public_static_I_I\", int.class, null, new Object[]{12, 13}, null,\n+                          newImpl ? wrong_argument_count_no_details : wrong_argument_count},\n+            new Object[] {\"public_I_I\",        int.class, inst, new Object[]{12, 13}, null,\n+                          newImpl ? wrong_argument_count_no_details : wrong_argument_count},\n+            new Object[] {\"public_I_I\",        int.class, wrongInst, new Object[]{12}, 12, mismatched_target_type},\n+            new Object[] {\"public_I_I\",        int.class, null, new Object[]{12}, 12, null_target},\n+\n+            new Object[] {\"public_static_I_V\", int.class, null, null, null,\n+                          newImpl ? wrong_argument_count_no_details : null_argument},\n+            new Object[] {\"public_static_I_V\", int.class, null, new Object[]{null}, null,\n+                          newImpl ? null_argument_value_npe : null_argument_value},\n+            new Object[] {\"public_I_I\",        int.class, inst, null, null, null_argument},\n+\n+            new Object[] {\"public_I_I\", int.class, inst, new Object[]{null}, null,\n+                          newImpl ? null_argument_value_npe : null_argument_value},\n+        };\n+    }\n+\n+    @DataProvider(name = \"testMethodsWithVarargs\")\n+    private Object[][] testMethodsWithVarargs() {\n+        Class<?>[] paramTypes = new Class<?>[] { int[].class };\n+        Class<?>[] I_paramTypes = new Class<?>[] { int.class, int[].class };\n+        Class<?>[] L_paramTypes = new Class<?>[] { String.class, String[].class };\n+        return new Object[][]{\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{new int[]{1, 2, 3}}, 6, noException},\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{new int[]{}}, 0, noException},\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{null}, 0, wrapped_npe_no_msg},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, new int[]{2, 3}}, 105, noException},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, new int[]{}}, 100, noException},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, null}, 1, noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", new String[]{\"b\", \"c\"}}, \"a[b,c]\", noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", new String[]{}}, \"a[]\", noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", null}, \"a\", noException},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testNoArgMethods\")\n+    public void testNoArgMethod(String methodname, Object target, Object[] args,\n+                                Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"testOneArgMethods\")\n+    public void testOneArgMethod(String methodname, Class<?> paramType, Object target, Object[] args,\n+                                 Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname, paramType), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"testMethodsWithVarargs\")\n+    public void testMethodsWithVarargs(String methodname, Class<?>[] paramTypes, Object target, Object[] args,\n+                                       Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname, paramTypes), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @DataProvider(name = \"testConstructors\")\n+    private Object[][] testConstructors() {\n+        return new Object[][]{\n+                new Object[]{null, new Object[]{}, new Public(), noException},\n+                new Object[]{null, null, new Public(), noException},\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{12}, new Public(12), noException},\n+                new Object[]{new Class<?>[]{String.class}, new Object[]{\"a\"}, new Public(\"a\"), noException},\n+\n+\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, new int[]{2, 3}}, new Public(105), noException},\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, new int[]{}}, new Public(100), noException},\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, null}, new Public(1), noException},\n+\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", new String[]{\"b\", \"c\"}}, new Public(\"a[b,c]\"), noException},\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", new String[]{}}, new Public(\"a[]\"), noException},\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", null}, new Public(\"a\"), noException},\n+\n+                \/\/ test ConstructorAccessor exceptions thrown\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{\"a\"}, null, mismatched_argument_type},\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{12, 13}, null, wrong_argument_count},\n+                new Object[]{new Class<?>[]{int.class}, null, null, null_argument},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new NullPointerException(\"NPE\")}, null, wrapped_npe},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new IllegalArgumentException(\"IAE\")}, null, wrapped_iae},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new ClassCastException(\"CCE\")}, null, wrapped_cce},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testConstructors\")\n+    public void testPublicConstructors(Class<?>[] paramTypes, Object[] args, Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(Public.class.getDeclaredConstructor(paramTypes), args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test\n+    public void testOtherConstructors() throws Exception {\n+        doTest(Private.class.getDeclaredConstructor(), new Object[]{}, new Private());\n+        doTest(Private.class.getDeclaredConstructor(), null, new Private());\n+        doTest(Private.class.getDeclaredConstructor(int.class), new Object[]{12}, new Private(12));\n+\n+        doTest(Abstract.class.getDeclaredConstructor(), null, null, new InstantiationException());\n+    }\n+\n+    @DataProvider(name = \"throwException\")\n+    private Object[][] throwException() {\n+        return new Object[][]{\n+                new Object[] {new NullPointerException(\"NPE\"), wrapped_npe},\n+                new Object[] {new IllegalArgumentException(\"IAE\"), wrapped_iae},\n+                new Object[] {new ClassCastException(\"CCE\"), wrapped_cce},\n+        };\n+    }\n+\n+    \/*\n+     * Test Method::invoke and Constructor::newInstance to wrap NPE\/CCE\/IAE\n+     * thrown by the member\n+     *\/\n+    @Test(dataProvider = \"throwException\")\n+    public void testInvocationTargetException(Throwable ex, Throwable[] expectedExpections) throws Exception {\n+        Object[] args = new Object[] { ex };\n+        \/\/ test static method\n+        doTest(Thrower.class.getDeclaredMethod(\"throws_exception\", RuntimeException.class), null, args, null, expectedExpections);\n+        \/\/ test constructor\n+        doTest(Thrower.class.getDeclaredConstructor(RuntimeException.class), args, null, expectedExpections);\n+    }\n+\n+    @Test\n+    public void testLambdaProxyClass() throws Exception {\n+        \/\/ test MethodAccessor on methods declared by hidden classes\n+        IntUnaryOperator intUnaryOp = i -> i;\n+        Method applyAsIntMethod = intUnaryOp.getClass().getDeclaredMethod(\"applyAsInt\", int.class);\n+        doTest(applyAsIntMethod, intUnaryOp, new Object[]{12}, 12);\n+    }\n+\n+    @DataProvider(name = \"readAccess\")\n+    private Object[][] readAccess() {\n+        boolean newImpl = Boolean.getBoolean(\"jdk.reflect.useDirectMethodHandle\");\n+        return new Object[][]{\n+                new Object[]{\"i\", new Public(100), 100, noException},\n+                new Object[]{\"s\", new Public(\"test\"), \"test\", noException},\n+                new Object[]{\"s\", new Object(), \"test\",\n+                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n+                new Object[]{\"s\", null, \"test\", null_target},\n+        };\n+    }\n+    @DataProvider(name = \"writeAccess\")\n+    private Object[][] writeAccess() {\n+        return new Object[][]{\n+                new Object[]{\"i\", new Public(100), 100, 200, noException},\n+                new Object[]{\"s\", new Public(\"test\"), \"test\", \"newValue\", noException},\n+                \/\/ ## no exception thrown\n+                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n+                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n+                new Object[]{\"s\", null, \"test\", \"dummy\", null_target},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"readAccess\")\n+    public void testFieldReadAccess(String name, Object target, Object expectedValue, Throwable[] expectedExpections) throws Exception {\n+        Field f = Public.class.getDeclaredField(name);\n+        f.setAccessible(true);\n+        doTest(f, target, expectedValue, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"writeAccess\")\n+    public void testFieldWriteAccess(String name, Object target, Object oldValue, Object newValue, Throwable[] expectedExpections) throws Exception {\n+        Field f = Public.class.getDeclaredField(name);\n+        f.setAccessible(true);\n+        doTest(f, target, oldValue, newValue, expectedExpections);\n+    }\n+\n+    \/\/ test static final field with read-only access\n+    @Test\n+    public void testStaticFinalFields() throws Exception {\n+        Field f = Public.class.getDeclaredField(\"STATIC_FINAL\");\n+        doTest(f, new Public(), 1, noException);\n+\n+        try {\n+            f.setInt(null, 100);\n+        } catch (IllegalAccessException e) { }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271820\n+ * @library \/test\/lib\/\n+ * @modules jdk.compiler\n+ * @build CustomLoaderTest jdk.test.lib.compiler.CompilerUtils\n+ * @run testng\/othervm CustomLoaderTest\n+ * @run testng\/othervm -Dsun.reflect.noInflation=true CustomLoaderTest\n+ *\n+ * @summary Test method whose parameter types and return type are not visible to the caller.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class CustomLoaderTest {\n+    private static final Path CLASSES = Paths.get(\"classes\");\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        String src = System.getProperty(\"test.src\", \".\");\n+        String classpath = System.getProperty(\"test.classes\", \".\");\n+        boolean rc = CompilerUtils.compile(Paths.get(src, \"ReflectTest.java\"), CLASSES, \"-cp\", classpath);\n+        if (!rc) {\n+            throw new RuntimeException(\"fail compilation\");\n+        }\n+        try {\n+            Class<?> p = Class.forName(\"ReflectTest$P\");\n+            fail(\"should not be visible to this loader\");\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        TestLoader loader1 = new TestLoader();\n+        TestLoader loader2 = new TestLoader();\n+        Method m1 = loader1.findMethod();\n+        Method m2 = loader2.findMethod();\n+\n+        assertTrue(m1.getDeclaringClass() != m2.getDeclaringClass());\n+\n+        assertTrue(m1.getDeclaringClass() == loader1.c);\n+        assertTrue(m2.getDeclaringClass() == loader2.c);\n+\n+        Object o1 = m1.invoke(loader1.c.newInstance(), loader1.p.newInstance(), loader1.q.newInstance());\n+        Object o2 = m2.invoke(loader2.c.newInstance(), loader2.p.newInstance(), loader2.q.newInstance());\n+\n+        assertTrue(o1.getClass() != o2.getClass());\n+        assertTrue(o1.getClass() == loader1.r);\n+        assertTrue(o2.getClass() == loader2.r);\n+    }\n+\n+    static class TestLoader extends URLClassLoader {\n+        static URL[] toURLs() {\n+            try {\n+                return new URL[]{ CLASSES.toUri().toURL() };\n+            } catch (MalformedURLException e) {\n+                throw new Error(e);\n+            }\n+        }\n+        static AtomicInteger counter = new AtomicInteger(0);\n+\n+        final Class<?> c;\n+        final Class<?> p;\n+        final Class<?> q;\n+        final Class<?> r;\n+        TestLoader() throws ClassNotFoundException {\n+            super(\"testloader-\" + counter.getAndIncrement(), toURLs(), ClassLoader.getPlatformClassLoader());\n+            this.c = Class.forName(\"ReflectTest\", true, this);\n+            this.p = Class.forName(\"ReflectTest$P\", true, this);\n+            this.q = Class.forName(\"ReflectTest$Q\", true, this);\n+            this.r = Class.forName(\"ReflectTest$R\", true, this);\n+        }\n+\n+        Method findMethod() throws ReflectiveOperationException {\n+            return c.getMethod(\"m\", p, q);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/callerCache\/CustomLoaderTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ReflectTest {\n+     public static class P {\n+     }\n+     public static class Q {\n+     }\n+     public static class R {\n+     }\n+\n+     public R m(P p, Q q) {\n+         return new R();\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/callerCache\/ReflectTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build Initializer Test ExceptionInClassInitialization\n+ * @run main ExceptionInClassInitialization\n+ * @summary ensure InvoacationTargetException thrown due to the initialization of\n+ *          the declaring class wrapping with the proper cause\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ExceptionInClassInitialization {\n+    public static void main(String... argv) throws ReflectiveOperationException {\n+        Class<?> c = Class.forName(\"Initializer\");\n+        testExecMethod(c);\n+        testFieldAccess(c);\n+    }\n+\n+    static void testExecMethod(Class<?> cls) throws ReflectiveOperationException {\n+        try {\n+            cls.getDeclaredMethod(\"execMethod\").invoke(null);\n+            throw new RuntimeException(\"InvocationTargetException not thrown\");\n+        } catch (InvocationTargetException e) {\n+            \/\/ InvocationTargetException wraps the exception that was thrown while reflection.\n+            Throwable t = e.getCause();\n+            if (t instanceof ExceptionInInitializerError eiie) {\n+                if (eiie.getCause() instanceof MyException) {\n+                    return;\n+                }\n+                throw new RuntimeException(\"ExceptionInInitializerError due to other exception than MyException!\", eiie);\n+            }\n+            throw new RuntimeException(\"InvocationTargetException was thrown not due to error while initialization!\", e);\n+        }\n+    }\n+\n+    static void testFieldAccess(Class<?> cls) throws ReflectiveOperationException {\n+        try {\n+            cls.getDeclaredMethod(\"fieldAccess\").invoke(null);\n+            throw new RuntimeException(\"InvocationTargetException not thrown\");\n+        } catch (InvocationTargetException e) {\n+            \/\/ the class initialization was run and failed.  NoClassDefFoundError\n+            \/\/ should be thrown in this second attempt.\n+            Throwable t = e.getCause();\n+            if (t instanceof NoClassDefFoundError ncdfe) {\n+                t = t.getCause();\n+                if (t instanceof ExceptionInInitializerError eiie) {\n+                    return;\n+                }\n+            }\n+            throw new RuntimeException(\"InvocationTargetException was thrown not due to error while initialization!\", e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/classInitialization\/ExceptionInClassInitialization.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class Initializer {\n+    static void fieldAccess() throws Throwable {\n+        Class<?> testedClass = Class.forName(\"Test\", false, Initializer.class.getClassLoader());\n+        testedClass.getDeclaredField(\"field\").set(testedClass, 1);\n+    }\n+\n+    static void execMethod() throws Throwable {\n+        Class<?> testedClass = Class.forName(\"Test\", false, Initializer.class.getClassLoader());\n+        testedClass.getDeclaredMethod(\"method\").invoke(null);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/classInitialization\/Initializer.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class MyException extends RuntimeException {}\n+\n+class SuperTest {\n+    static {\n+        if (true) {\n+            throw new MyException();\n+        }\n+    }\n+}\n+\n+class Test extends SuperTest {\n+\n+    static int field = 0;\n+\n+    static void method() {};\n+\n+    static {\n+        if (true) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/classInitialization\/Test.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+\n+import static com.sun.tools.classfile.AccessFlags.ACC_PRIVATE;\n@@ -36,0 +38,1 @@\n+import java.util.Arrays;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -40,0 +44,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -65,7 +70,15 @@\n-      Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n-             \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n-             \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n-             \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n-      );\n+        Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n+               \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n+               \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n+        );\n+\n+    \/\/ These non-static non-final methods must not have @CallerSensitiveAdapter\n+    \/\/ methods that takes an additional caller class parameter.\n+    private static Set<String> UNSUPPORTED_VIRTUAL_METHODS =\n+        Set.of(\"java\/io\/ObjectStreamField#getType (Ljava\/lang\/Class;)Ljava\/lang\/Class;\",\n+               \"java\/lang\/Thread#getContextClassLoader (Ljava\/lang\/Class;)Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields (Ljava\/lang\/Class;)[Ljava\/lang\/reflect\/Field;\"\n+        );\n@@ -87,0 +100,8 @@\n+\n+        \/\/ check if all csm methods with a trailing Class parameter are supported\n+        checkCSMs.csmWithCallerParameter.values().stream()\n+                 .flatMap(Set::stream)\n+                 .forEach(m -> {\n+                     if (UNSUPPORTED_VIRTUAL_METHODS.contains(m))\n+                         throw new RuntimeException(\"Unsupported alternate csm adapter: \" + m);\n+                 });\n@@ -90,0 +111,2 @@\n+    private final Map<String, Set<String>> csmWithCallerParameter = new ConcurrentHashMap<>();\n+\n@@ -132,3 +155,1 @@\n-                    String name = String.format(\"%s#%s %s\", cf.getName(),\n-                                                m.getName(cf.constant_pool),\n-                                                m.descriptor.getValue(cf.constant_pool));\n+                    String name = methodSignature(cf, m);\n@@ -143,0 +164,9 @@\n+\n+                    \/\/ find the adapter implementation for CSM with the caller parameter\n+                    if (!csmWithCallerParameter.containsKey(cf.getName())) {\n+                        Set<String> methods = Arrays.stream(cf.methods)\n+                                                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n+                                                    .map(m0 -> methodSignature(cf, m0))\n+                                                    .collect(Collectors.toSet());\n+                        csmWithCallerParameter.put(cf.getName(), methods);\n+                    }\n@@ -150,0 +180,48 @@\n+    private static String methodSignature(ClassFile cf, Method m) {\n+        try {\n+            return String.format(\"%s#%s %s\", cf.getName(),\n+                                 m.getName(cf.constant_pool),\n+                                 m.descriptor.getValue(cf.constant_pool));\n+        } catch (ConstantPoolException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static boolean csmWithCallerParameter(ClassFile cf, Method csm, Method m) {\n+        ConstantPool cp = cf.constant_pool;\n+        try {\n+            int csmParamCount = csm.descriptor.getParameterCount(cp);\n+            int paramCount = m.descriptor.getParameterCount(cp);\n+            \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n+            if (!(csm.getName(cp).equals(m.getName(cp)) &&\n+                    paramCount == (csmParamCount+1) &&\n+                    m.descriptor.getReturnType(cp).equals(csm.descriptor.getReturnType(cp)))) {\n+                return false;\n+            }\n+            \/\/ the descriptor of the adapter method must have the parameters\n+            \/\/ of the caller-sensitive method and an additional Class parameter\n+            String csmDesc = csm.descriptor.getParameterTypes(cp);\n+            String desc = m.descriptor.getParameterTypes(cp);\n+            int index = desc.indexOf(\", java.lang.Class)\");\n+            if (index == -1) {\n+                index = desc.indexOf(\"java.lang.Class)\");\n+                if (index == -1) return false;\n+            }\n+            String s = desc.substring(0, index) + \")\";\n+            if (s.equals(csmDesc)) {\n+                if (!m.access_flags.is(ACC_PRIVATE)) {\n+                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                            methodSignature(cf, csm) + \" must be private\");\n+                }\n+                if (!isCallerSensitiveAdapter(m, cp)) {\n+                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                            methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n+                }\n+                return true;\n+            }\n+        } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n+            throw new RuntimeException(e);\n+        }\n+        return false;\n+    }\n+\n@@ -152,0 +230,2 @@\n+    private static final String CALLER_SENSITIVE_ADAPTER_ANNOTATION\n+        = \"Ljdk\/internal\/reflect\/CallerSensitiveAdapter;\";\n@@ -170,0 +250,17 @@\n+    private static boolean isCallerSensitiveAdapter(Method m, ConstantPool cp)\n+            throws ConstantPoolException\n+    {\n+        RuntimeAnnotations_attribute attr =\n+                (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n+        if (attr != null) {\n+            for (int i = 0; i < attr.annotations.length; i++) {\n+                Annotation ann = attr.annotations[i];\n+                String annType = cp.getUTF8Value(ann.type_index);\n+                if (CALLER_SENSITIVE_ADAPTER_ANNOTATION.equals(annType)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":108,"deletions":11,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,6 @@\n+import static java.lang.System.out;\n+\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n@@ -27,0 +33,19 @@\n+\n+    public Class<?> missingCallerSensitiveAnnotation() {\n+        return jdk.internal.reflect.Reflection.getCallerClass();\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public Class<?> getCallerClass() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    private Class<?> getCallerClass(Class<?> caller) {\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n@@ -28,3 +53,5 @@\n-    public ClassLoader getCallerLoader() {\n-        Class<?> c = jdk.internal.reflect.Reflection.getCallerClass();\n-        return c.getClassLoader();\n+    public static Class<?> getCallerClassStatic() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n@@ -33,3 +60,29 @@\n-    public ClassLoader missingCallerSensitiveAnnotation() {\n-        Class<?> c = jdk.internal.reflect.Reflection.getCallerClass();\n-        return c.getClassLoader();\n+    private static Class<?> getCallerClassStatic(Class<?> caller) {\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public Class<?> getCallerClassNoAlt() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public static Class<?> getCallerClassStaticNoAlt() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    private static Function<Stream<StackWalker.StackFrame>, String> toStackTrace() {\n+        return frames -> frames\n+            .takeWhile(\n+                frame -> !frame.getClassName().equals(\"GetCallerClassTest\") ||\n+                         !frame.getMethodName().equals(\"main\"))\n+            .map(Object::toString)\n+            .collect(Collectors.joining(\"\\n  \", \"  \", \"\\n\"));\n@@ -38,0 +91,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/GetCallerClass.java","additions":61,"deletions":7,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- *          be called by methods annotated with CallerSensitive\n+ *          be called by system methods annotated with CallerSensitive plus\n+ *          test reflective and method handle based invocation of caller-sensitive\n+ *          methods with or without the CSM adapter method\n@@ -32,1 +34,28 @@\n- * @run main\/othervm -Xbootclasspath\/a:bcp GetCallerClassTest\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=true GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify the new NativeAccessor\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=true -Djdk.reflect.useNativeAccessorOnly=true GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify NativeMethodAccessorImpl\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=false -Dsun.reflect.noInflation=false GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify the old generated MethodAccessor\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=false -Dsun.reflect.noInflation=true GetCallerClassTest\n@@ -36,0 +65,4 @@\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -41,4 +74,3 @@\n-    private final GetCallerClass gcc;   \/\/ boot.GetCallerClass is in bootclasspath\n-    GetCallerClassTest() {\n-        this.gcc = new GetCallerClass();\n-    }\n+    \/\/ boot.GetCallerClass is in bootclasspath\n+    private static final Class<GetCallerClass> gccCl = GetCallerClass.class;\n+    private final GetCallerClass gcc = new GetCallerClass();\n@@ -48,2 +80,1 @@\n-        \/\/ ensure methods are annotated with @CallerSensitive\n-        ensureAnnotationPresent(boot.GetCallerClass.class, \"getCallerLoader\", true);\n+        \/\/ ensure methods are annotated with @CallerSensitive and verify Reflection.isCallerSensitive()\n@@ -51,2 +82,8 @@\n-        \/\/ call Reflection.getCallerClass from bootclasspath with and without @CS\n-        gcct.testCallerSensitiveMethods();\n+\n+        ensureAnnotationPresent(gccCl, \"getCallerClass\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassStatic\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassNoAlt\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassStaticNoAlt\", true);\n+\n+        \/\/ call Reflection.getCallerClass from bootclasspath without @CS\n+        gcct.testMissingCallerSensitiveAnnotation();\n@@ -55,0 +92,8 @@\n+        \/\/ call Reflection.getCallerClass from bootclasspath with @CS\n+        gcct.testCallerSensitiveMethods();\n+        \/\/ call @CS methods using reflection\n+        gcct.testCallerSensitiveMethodsUsingReflection();\n+        \/\/ call @CS methods using method handles\n+        gcct.testCallerSensitiveMethodsUsingMethodHandles();\n+        \/\/ call @CS methods using reflection but call Method.invoke with a method handle\n+        gcct.testCallerSensitiveMethodsUsingMethodHandlesAndReflection();\n@@ -70,1 +115,2 @@\n-    private void testCallerSensitiveMethods() {\n+    private void testMissingCallerSensitiveAnnotation() {\n+        System.out.println(\"\\ntestMissingCallerSensitiveAnnotation...\");\n@@ -72,4 +118,0 @@\n-            ClassLoader cl = gcc.getCallerLoader();\n-            if (cl != GetCallerClassTest.class.getClassLoader()) {\n-                throw new RuntimeException(\"mismatched class loader\");\n-            }\n@@ -77,1 +119,1 @@\n-            throw new RuntimeException(\"getCallerLoader not marked with @CallerSensitive\");\n+            throw new RuntimeException(\"shouldn't have succeeded\");\n@@ -79,9 +121,4 @@\n-            StackTraceElement[] stackTrace = e.getStackTrace();\n-            checkStackTrace(stackTrace, e);\n-            if (!stackTrace[1].getClassName().equals(GetCallerClass.class.getName()) ||\n-                !stackTrace[1].getMethodName().equals(\"missingCallerSensitiveAnnotation\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n-            }\n-            if (!stackTrace[2].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[2].getMethodName().equals(\"testCallerSensitiveMethods\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            if (e.getMessage().startsWith(\"CallerSensitive annotation expected\")) {\n+                System.out.println(\"Expected error: \" + e.getMessage());\n+            } else {\n+                throw e;\n@@ -89,1 +126,0 @@\n-            System.out.println(\"Expected error: \" + e.getMessage());\n@@ -95,0 +131,1 @@\n+        System.out.println(\"\\ntestNonSystemMethod...\");\n@@ -97,1 +134,1 @@\n-            throw new RuntimeException(\"@CallerSensitive testNonSystemMethods not supported\");\n+            throw new RuntimeException(\"shouldn't have succeeded\");\n@@ -99,9 +136,4 @@\n-            StackTraceElement[] stackTrace = e.getStackTrace();\n-            checkStackTrace(stackTrace, e);\n-            if (!stackTrace[1].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[1].getMethodName().equals(\"testNonSystemMethod\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n-            }\n-            if (!stackTrace[2].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[2].getMethodName().equals(\"main\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            if (e.getMessage().startsWith(\"CallerSensitive annotation expected\")) {\n+                System.out.println(\"Expected error: \" + e.getMessage());\n+            } else {\n+                throw e;\n@@ -109,1 +141,0 @@\n-            System.out.println(\"Expected error: \" + e.getMessage());\n@@ -113,3 +144,42 @@\n-    private void checkStackTrace(StackTraceElement[] stackTrace, Error e) {\n-        if (stackTrace.length < 3) {\n-            throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+    private void testCallerSensitiveMethods() {\n+        System.out.println();\n+        Class<?> caller;\n+\n+        caller = gcc.getCallerClass();\n+        if (caller != GetCallerClassTest.class) {\n+            throw new RuntimeException(\"mismatched caller: \" + caller);\n+        }\n+\n+        caller = GetCallerClass.getCallerClassStatic();\n+        if (caller != GetCallerClassTest.class) {\n+            throw new RuntimeException(\"mismatched caller: \" + caller);\n+        }\n+    }\n+\n+    private void testCallerSensitiveMethodsUsingReflection() {\n+        System.out.println();\n+\n+        try {\n+            Class<?> caller;\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClass\").invoke(gcc);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassStatic\").invoke(null);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassNoAlt\").invoke(gcc);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassStaticNoAlt\").invoke(null);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+        } catch (ReflectiveOperationException|SecurityException e) {\n+            throw new RuntimeException(e);\n@@ -117,0 +187,19 @@\n+    }\n+\n+    private void testCallerSensitiveMethodsUsingMethodHandles() {\n+        System.out.println();\n+\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodType mt = MethodType.methodType(Class.class);\n+            Class<?> caller;\n+\n+            caller = (Class<?>) lookup.findVirtual(gccCl, \"getCallerClass\", mt).invokeExact(gcc);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) lookup.findStatic(gccCl, \"getCallerClassStatic\", mt).invokeExact();\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n@@ -118,3 +207,13 @@\n-        if (!stackTrace[0].getClassName().equals(\"jdk.internal.reflect.Reflection\") ||\n-            !stackTrace[0].getMethodName().equals(\"getCallerClass\")) {\n-            throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            caller = (Class<?>) lookup.findVirtual(gccCl, \"getCallerClassNoAlt\", mt).invokeExact(gcc);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) lookup.findStatic(gccCl, \"getCallerClassStaticNoAlt\", mt).invokeExact();\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n@@ -122,0 +221,21 @@\n+    }\n+\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    private void testCallerSensitiveMethodsUsingMethodHandlesAndReflection() {\n+        \/\/ In the old implementation, the caller returned is java.lang.invoke.Method\n+        \/\/ since it looks up the caller through stack walking.\n+        \/\/ The new implementation uses the special calling sequence and Method::invoke\n+        \/\/ defines an adapter method such that the stack walking is done only once\n+        \/\/ using the same caller class.\n+        String s = System.getProperty(\"jdk.reflect.useDirectMethodHandle\", \"true\");\n+        boolean newImpl = Boolean.valueOf(s);\n+        Class<?> expectedCaller = newImpl ? GetCallerClassTest.class : Method.class;\n+\n+        System.out.println();\n+        try {\n+            MethodHandle methodInvokeMh = MethodHandles\n+                .lookup()\n+                .findVirtual(Method.class, \"invoke\", MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            Class<?> caller;\n@@ -123,0 +243,36 @@\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClass\"), gcc, EMPTY_ARRAY);\n+            if (caller != expectedCaller) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassStatic\"), null, EMPTY_ARRAY);\n+            if (caller != expectedCaller) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassNoAlt\"), gcc, EMPTY_ARRAY);\n+            if (newImpl) {\n+                if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            } else {\n+                if (caller != expectedCaller) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassStaticNoAlt\"), null, EMPTY_ARRAY);\n+            if (newImpl) {\n+                if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            } else {\n+                if (caller != expectedCaller) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            }\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -125,0 +281,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/GetCallerClassTest.java","additions":201,"deletions":44,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -81,1 +81,3 @@\n-            assertFalse(hasHiddenStackFrame(visibleEvent), \"Hidden frame in visible event: \" + visibleEvent);\n+\n+            \/\/ Temporary disable this test until JDK-8272064 is resolved.\n+            \/\/ assertFalse(hasHiddenStackFrame(visibleEvent), \"Hidden frame in visible event: \" + visibleEvent);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestHiddenMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+                        new StackTraceElement(\"java.lang.Class\", \"forName\", \"Class.java\", -2),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-@Fork(value = 30, warmups = 10)\n+@Fork(value = 10, warmups = 0)\n@@ -124,1 +124,4 @@\n-    public void invokeMethods(Blackhole bh) throws ReflectiveOperationException {\n+    public void invokeMethods() throws ReflectiveOperationException {\n+        \/\/ As this is testing warmup, JITs are unlikely to progress to the\n+        \/\/ point where the lack of a blackhole might lead to DCE. Omitting it\n+        \/\/ makes it easier to test this code minimal use of JMH code\n@@ -126,1 +129,1 @@\n-            bh.consume(m.invoke(null, arg));\n+            m.invoke(null, arg);\n@@ -129,0 +132,10 @@\n+\n+    \/**\n+     * Runs invokeMethods once without any JMH interaction, acting as an\n+     * independent startup benchmark.\n+     *\/\n+    public static void main(String ... args) throws Exception {\n+        var coldstart = new ReflectionColdstartBenchmark();\n+        coldstart.setup();\n+        coldstart.invokeMethods();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionColdstartBenchmark.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -32,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -46,3 +48,3 @@\n- *     <li>Const - Method\/Field is constant-foldable<\/li>\n- *     <li>Var - Method\/Field is single-instance but not constant-foldable<\/li>\n- *     <li>Poly - multiple Method\/Field instances used at single call-site<\/li>\n+ *     <li>Const - Constructor\/Method\/Field is constant-foldable<\/li>\n+ *     <li>Var - Constructor\/Method\/Field is single-instance but not constant-foldable<\/li>\n+ *     <li>Poly - multiple Constructor\/Method\/Field instances used at single call-site<\/li>\n@@ -81,2 +83,2 @@\n-            staticMethodConst = staticMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumStatic\", int.class, int.class);\n-            instanceMethodConst = instanceMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumInstance\", int.class, int.class);\n+            staticMethodConst = staticMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumStatic\", Integer.class, Integer.class);\n+            instanceMethodConst = instanceMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumInstance\", Integer.class, Integer.class);\n@@ -271,1 +273,1 @@\n-    private int a, b;\n+    private Integer a, b;\n@@ -279,0 +281,3 @@\n+    \/\/ @Param({\"true\", \"false\"})\n+    private boolean polluteProfile = true;\n+\n@@ -285,0 +290,30 @@\n+\n+        if (polluteProfile) {\n+            try {\n+                Constructor ctor = ReflectionSpeedBenchmark.class.getDeclaredConstructor(Integer.class);\n+                Method test1 = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"test1\", Object.class);\n+                Method test2 = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"test2\", Object.class, Object.class);\n+                Field f = ReflectionSpeedBenchmark.class.getDeclaredField(\"testField\");\n+                for (int i = 0; i < 20_000; i++) {\n+                    invokeHelper2(staticMethodVar, null, a, b);\n+                    invokeHelper2(instanceMethodVar, this, a, b);\n+                    invokeHelper2(test2, null, a, b);\n+                    invokeHelper1(staticMethodsPoly[i & (staticMethodsPoly.length - 1)], instance, o);\n+                    invokeHelper1(instanceMethodsPoly[i & (instanceMethodsPoly.length - 1)], instance, o);\n+                    invokeHelper1(test1, null, a);\n+\n+                    newInstanceHelper(constructorVar, constructorArgs);\n+                    int index = i & (constructorsPoly.length - 1);\n+                    newInstanceHelper(constructorsPoly[index], constructorsArgsPoly[index]);\n+                    newInstanceHelper(ctor, new Object[]{a});\n+\n+                    getIntHelper(staticFieldVar, null);\n+                    getIntHelper(instanceFieldVar, this);\n+                    getDoubleHelper(f, null);\n+                    getHelper(staticFieldsPoly[i & (staticFieldsPoly.length - 1)], null);\n+                    getHelper(instanceFieldsPoly[i & (instanceFieldsPoly.length - 1)], instance);\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                 throw new InternalError(e);\n+            }\n+        }\n@@ -287,2 +322,2 @@\n-    public static int sumStatic(int a, int b) {\n-        return a + b;\n+    public static Integer sumStatic(Integer a, Integer b) {\n+        return a; \/\/ a + b;\n@@ -291,2 +326,2 @@\n-    public int sumInstance(int a, int b) {\n-        return a + b;\n+    public Integer sumInstance(Integer a, Integer b) {\n+        return a; \/\/ a + b;\n@@ -297,0 +332,7 @@\n+    public ReflectionSpeedBenchmark() {}\n+\n+    \/\/ used for polluting the profile\n+    private ReflectionSpeedBenchmark(Integer a) {}\n+    static void test1(Object a) {}\n+    static void test2(Object a, Object b) {}\n+    static double testField;\n@@ -299,0 +341,28 @@\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object invokeHelper1(Method m, Object recv, Object arg1) throws InvocationTargetException, IllegalAccessException {\n+        return m.invoke(recv, arg1);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object invokeHelper2(Method m, Object recv, Object arg1, Object arg2) throws InvocationTargetException, IllegalAccessException {\n+        return m.invoke(recv, arg1, arg2);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object newInstanceHelper(Constructor ctor, Object[] args) throws InvocationTargetException, IllegalAccessException, InstantiationException {\n+        return ctor.newInstance(args);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static int getIntHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.getInt(recv);\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static double getDoubleHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.getDouble(recv);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object getHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.get(recv);\n+    }\n@@ -301,1 +371,1 @@\n-    public int staticMethodConst() {\n+    public Object staticMethodConst() {\n@@ -303,1 +373,1 @@\n-            return (Integer) staticMethodConst.invoke(null, a, b);\n+            return invokeHelper2(staticMethodConst, null, a, b);\n@@ -310,1 +380,1 @@\n-    public int instanceMethodConst() {\n+    public Object instanceMethodConst() {\n@@ -312,1 +382,1 @@\n-            return (Integer) instanceMethodConst.invoke(this, a, b);\n+            return invokeHelper2(instanceMethodConst, this, a, b);\n@@ -319,1 +389,1 @@\n-    public int staticMethodVar() {\n+    public Object staticMethodVar() {\n@@ -321,1 +391,1 @@\n-            return (Integer) staticMethodVar.invoke(null, a, b);\n+            return invokeHelper2(staticMethodVar, null, a, b);\n@@ -328,1 +398,1 @@\n-    public int instanceMethodVar() {\n+    public Object instanceMethodVar() {\n@@ -330,1 +400,1 @@\n-            return (Integer) instanceMethodVar.invoke(this, a, b);\n+            return invokeHelper2(instanceMethodVar, this, a, b);\n@@ -339,1 +409,1 @@\n-            return staticMethodsPoly[nextRnd() & (staticMethodsPoly.length - 1)].invoke(null, o);\n+            return invokeHelper1(staticMethodsPoly[nextRnd() & (staticMethodsPoly.length - 1)], null, o);\n@@ -348,1 +418,1 @@\n-            return instanceMethodsPoly[nextRnd() & (instanceMethodsPoly.length - 1)].invoke(instance, o);\n+            return invokeHelper1(instanceMethodsPoly[nextRnd() & (instanceMethodsPoly.length - 1)], instance, o);\n@@ -359,1 +429,1 @@\n-            return staticFieldConst.getInt(null);\n+            return getIntHelper(staticFieldConst, null);\n@@ -368,1 +438,1 @@\n-            return instanceFieldConst.getInt(this);\n+            return getIntHelper(instanceFieldConst, this);\n@@ -377,1 +447,1 @@\n-            return staticFieldVar.getInt(null);\n+            return getIntHelper(staticFieldVar, null);\n@@ -386,1 +456,1 @@\n-            return instanceFieldVar.getInt(this);\n+            return getIntHelper(instanceFieldVar, this);\n@@ -395,1 +465,1 @@\n-            return staticFieldsPoly[nextRnd() & (staticFieldsPoly.length - 1)].get(null);\n+            return getHelper(staticFieldsPoly[nextRnd() & (staticFieldsPoly.length - 1)], null);\n@@ -404,1 +474,1 @@\n-            return instanceFieldsPoly[nextRnd() & (instanceFieldsPoly.length - 1)].get(instance);\n+            return getHelper(instanceFieldsPoly[nextRnd() & (instanceFieldsPoly.length - 1)], instance);\n@@ -415,1 +485,1 @@\n-            return constructorConst.newInstance(constructorArgs);\n+            return newInstanceHelper(constructorConst, constructorArgs);\n@@ -424,1 +494,1 @@\n-            return constructorVar.newInstance(constructorArgs);\n+            return newInstanceHelper(constructorVar, constructorArgs);\n@@ -434,1 +504,1 @@\n-            return constructorsPoly[i].newInstance(constructorsArgsPoly[i]);\n+            return newInstanceHelper(constructorsPoly[i], constructorsArgsPoly[i]);\n@@ -439,1 +509,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionSpeedBenchmark.java","additions":100,"deletions":30,"binary":false,"changes":130,"status":"modified"}]}