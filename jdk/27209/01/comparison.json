{"files":[{"patch":"@@ -82,1 +82,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n@@ -3744,4 +3744,1 @@\n-int reflect_ConstantPool::_oop_offset;\n-\n-#define CONSTANTPOOL_FIELDS_DO(macro) \\\n-  macro(_oop_offset, k, \"constantPoolOop\", object_signature, false)\n+int reflect_ConstantPool::_vmholder_offset;\n@@ -3751,2 +3748,2 @@\n-  \/\/ The field is called ConstantPool* in the sun.reflect.ConstantPool class.\n-  CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  \/\/ The field is injected and called Object vmholder in the jdk.internal.reflect.ConstantPool class.\n+  CONSTANTPOOL_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -3757,1 +3754,1 @@\n-  CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+  CONSTANTPOOL_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -3910,0 +3907,1 @@\n+  assert(_vmholder_offset != 0, \"Uninitialized vmholder\");\n@@ -3912,1 +3910,1 @@\n-  reflect->obj_field_put(_oop_offset, mirror);\n+  reflect->obj_field_put(_vmholder_offset, mirror);\n@@ -3916,1 +3914,2 @@\n-  oop mirror = reflect->obj_field(_oop_offset);\n+  assert(_vmholder_offset != 0, \"Uninitialized vmholder\");\n+  oop mirror = reflect->obj_field(_vmholder_offset);\n@@ -5557,1 +5556,0 @@\n-  FilteredFieldsMap::initialize();  \/\/ must be done after computing offsets.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -939,0 +939,3 @@\n+#define CONSTANTPOOL_INJECTED_FIELDS(macro)                             \\\n+  macro(reflect_ConstantPool, vmholder, object_signature, false)\n+\n@@ -943,2 +946,3 @@\n-  \/\/ offsets at run-time.\n-  static int _oop_offset;\n+  \/\/ offsets at run-time. This field is the oop offset for the\n+  \/\/ actual constant pool, previously called constantPoolOop.\n+  static int _vmholder_offset;\n@@ -956,1 +960,0 @@\n-  static int oop_offset() { CHECK_INIT(_oop_offset); }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-  STACKCHUNK_INJECTED_FIELDS(macro)\n+  STACKCHUNK_INJECTED_FIELDS(macro)         \\\n+  CONSTANTPOOL_INJECTED_FIELDS(macro)\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -71,1 +72,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -2844,1 +2844,1 @@\n-  FilteredJavaFieldStream flds(ik);\n+  JavaFieldStream flds(ik);\n@@ -2846,1 +2846,1 @@\n-  int result_count = flds.field_count();\n+  int result_count = ik->java_fields_count();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -432,2 +432,2 @@\n-    FilteredJavaFieldStream fld(interfaces->at(i));\n-    count += fld.field_count();\n+    count += interfaces->at(i)->java_fields_count();\n+\n@@ -455,2 +455,1 @@\n-    FilteredJavaFieldStream super_fld(super_klass);\n-    index += super_fld.field_count();\n+    index += super_klass->java_fields_count();\n@@ -459,1 +458,1 @@\n-  for (FilteredJavaFieldStream fld(ik); !fld.done(); fld.next(), index++) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next(), index++) {\n@@ -482,2 +481,1 @@\n-    FilteredJavaFieldStream fld(klass);\n-    total_field_number += fld.field_count();\n+    total_field_number += klass->java_fields_count();\n@@ -487,2 +485,2 @@\n-    FilteredJavaFieldStream fld(klass);\n-    int start_index = total_field_number - fld.field_count();\n+    JavaFieldStream fld(klass);\n+    int start_index = total_field_number - klass->java_fields_count();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"oops\/instanceKlass.inline.hpp\"\n-#include \"runtime\/reflectionUtils.hpp\"\n-\n-\n-GrowableArray<FilteredField*> *FilteredFieldsMap::_filtered_fields =\n-  new (mtServiceability) GrowableArray<FilteredField*>(3, mtServiceability);\n-\n-\n-void FilteredFieldsMap::initialize() {\n-  int offset = reflect_ConstantPool::oop_offset();\n-  _filtered_fields->append(new FilteredField(vmClasses::reflect_ConstantPool_klass(), offset));\n-}\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_REFLECTIONUTILS_HPP\n-#define SHARE_RUNTIME_REFLECTIONUTILS_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"oops\/fieldStreams.inline.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/reflection.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-class FilteredField : public CHeapObj<mtInternal>  {\n- private:\n-  Klass* _klass;\n-  int    _field_offset;\n-\n- public:\n-  FilteredField(Klass* klass, int field_offset) {\n-    _klass = klass;\n-    _field_offset = field_offset;\n-  }\n-  Klass* klass() { return _klass; }\n-  int  field_offset() { return _field_offset; }\n-};\n-\n-class FilteredFieldsMap : AllStatic {\n- private:\n-  static GrowableArray<FilteredField *> *_filtered_fields;\n- public:\n-  static void initialize();\n-  static bool is_filtered_field(Klass* klass, int field_offset) {\n-    for (int i=0; i < _filtered_fields->length(); i++) {\n-      if (klass == _filtered_fields->at(i)->klass() &&\n-        field_offset == _filtered_fields->at(i)->field_offset()) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-  static int  filtered_fields_count(Klass* klass, bool local_only) {\n-    int nflds = 0;\n-    for (int i=0; i < _filtered_fields->length(); i++) {\n-      if (local_only && klass == _filtered_fields->at(i)->klass()) {\n-        nflds++;\n-      } else if (klass->is_subtype_of(_filtered_fields->at(i)->klass())) {\n-        nflds++;\n-      }\n-    }\n-    return nflds;\n-  }\n-};\n-\n-\/\/ Iterate over Java fields filtering fields like reflection does.\n-class FilteredJavaFieldStream : public JavaFieldStream {\n-private:\n-  InstanceKlass* _klass;\n-  int  _filtered_fields_count;\n-  bool has_filtered_field() const { return (_filtered_fields_count > 0); }\n-  void skip_filtered_fields() {\n-    if (has_filtered_field()) {\n-      while (!done() && FilteredFieldsMap::is_filtered_field((Klass*)_klass, offset())) {\n-        JavaFieldStream::next();\n-      }\n-    }\n-  }\n-\n-public:\n-  FilteredJavaFieldStream(InstanceKlass* klass)\n-    : JavaFieldStream(klass),\n-      _klass(klass),\n-      _filtered_fields_count(FilteredFieldsMap::filtered_fields_count(klass, true))\n-  {\n-    \/\/ skip filtered fields at the beginning\n-    skip_filtered_fields();\n-  }\n-  int field_count() const {\n-    return _klass->java_fields_count() - _filtered_fields_count;\n-  }\n-  void next() {\n-    JavaFieldStream::next();\n-    skip_filtered_fields();\n-  }\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_REFLECTIONUTILS_HPP\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -109,7 +109,0 @@\n-  static {\n-      Reflection.registerFieldsToFilter(ConstantPool.class, Set.of(\"constantPoolOop\"));\n-  }\n-\n-  \/\/ HotSpot-internal constant pool object (set by the VM, name known to the VM)\n-  private Object constantPoolOop;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstantPool.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -952,3 +952,0 @@\n-        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) && f.getName().equals(\"constantPoolOop\")) {\n-            return true;\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}