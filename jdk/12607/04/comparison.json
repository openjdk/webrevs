{"files":[{"patch":"@@ -94,1 +94,1 @@\n-  if (is_fully_available()) {\n+  if (is_in_use()) {\n@@ -475,1 +475,1 @@\n-  if (is_fully_available()) {\n+  if (is_in_use()) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,7 +68,1 @@\n-  static bool are_archived_strings_available() {\n-    return is_loaded() || closed_regions_mapped();\n-  }\n-  static bool are_archived_mirrors_available() {\n-    return is_fully_available();\n-  }\n-  static bool is_fully_available() {\n+  static bool is_in_use() {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-    if (CompressedOops::is_null(o) || !ArchiveHeapLoader::is_fully_available()) {\n+    if (CompressedOops::is_null(o) || !ArchiveHeapLoader::is_in_use()) {\n@@ -323,1 +323,1 @@\n-      assert(ArchiveHeapLoader::is_fully_available(), \"must be\");\n+      assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n@@ -328,1 +328,1 @@\n-    if (dumptime_oop == 0 || !ArchiveHeapLoader::is_fully_available()) {\n+    if (dumptime_oop == 0 || !ArchiveHeapLoader::is_in_use()) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  if (ArchiveHeapLoader::is_fully_available()) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n@@ -381,2 +381,0 @@\n-  init_seen_objects_table();\n-\n@@ -407,1 +405,1 @@\n-      guarantee(success, \"scratch mirrors should not point to any unachivable objects\");\n+      guarantee(success, \"scratch mirrors must point to only archivable objects\");\n@@ -428,0 +426,1 @@\n+}\n@@ -429,1 +428,8 @@\n-  delete_seen_objects_table();\n+void HeapShared::archive_strings() {\n+  oop shared_strings_array = StringTable::init_shared_table(_dumped_interned_strings);\n+  bool success = archive_reachable_objects_from(1, _default_subgraph_info, shared_strings_array, \/*is_closed_archive=*\/ false);\n+  \/\/ We must succeed because:\n+  \/\/ - _dumped_interned_strings do not contain any large strings.\n+  \/\/ - StringTable::init_shared_table() doesn't create any large arrays.\n+  assert(success, \"shared strings array must not point to arrays or strings that are too large to archive\");\n+  StringTable::set_shared_strings_array_index(append_root(shared_strings_array));\n@@ -504,1 +510,1 @@\n-  if (!ArchiveHeapLoader::is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n@@ -559,1 +565,0 @@\n-  StringTable::write_shared_table(_dumped_interned_strings);\n@@ -567,8 +572,7 @@\n-    if (!ArchiveHeapWriter::is_string_too_large_to_archive(s)) {\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info,\n-                                                    s, \/*is_closed_archive=*\/true);\n-      assert(success, \"must be\");\n-      \/\/ Prevent string deduplication from changing the value field to\n-      \/\/ something not in the archive.\n-      java_lang_String::set_deduplication_forbidden(s);\n-    }\n+    assert(!ArchiveHeapWriter::is_string_too_large_to_archive(s), \"large strings must have been filtered\");\n+    bool success = archive_reachable_objects_from(1, _default_subgraph_info,\n+                                                  s, \/*is_closed_archive=*\/true);\n+    assert(success, \"string must be short enough to be archived\");\n+    \/\/ Prevent string deduplication from changing the value field to\n+    \/\/ something not in the archive.\n+    java_lang_String::set_deduplication_forbidden(s);\n@@ -592,0 +596,8 @@\n+void HeapShared::copy_special_open_objects() {\n+  \/\/ Archive special objects that do not belong to any subgraphs\n+  init_seen_objects_table();\n+  archive_java_mirrors();\n+  archive_strings();\n+  delete_seen_objects_table();\n+}\n+\n@@ -595,1 +607,1 @@\n-  archive_java_mirrors();\n+  copy_special_open_objects();\n@@ -864,1 +876,1 @@\n-      assert(ArchiveHeapLoader::is_fully_available(), \"must be\");\n+      assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n@@ -924,1 +936,1 @@\n-  if (!ArchiveHeapLoader::is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n@@ -957,1 +969,1 @@\n-  if (!ArchiveHeapLoader::is_fully_available()) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -347,0 +347,1 @@\n+  static void archive_strings();\n@@ -367,0 +368,1 @@\n+  static void copy_special_open_objects();\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,0 +804,1 @@\n+  StringTable::allocate_shared_strings_array(CHECK);\n@@ -1440,3 +1441,0 @@\n-  \/\/ Initialize the run-time symbol table.\n-  SymbolTable::create_table();\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -892,1 +892,1 @@\n-    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::is_in_use()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -75,6 +76,11 @@\n-inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {\n-  assert(ArchiveHeapLoader::are_archived_strings_available(), \"sanity\");\n-  if (UseCompressedOops) {\n-    assert(sizeof(narrowOop) == sizeof(offset), \"must be\");\n-    narrowOop v = CompressedOops::narrow_oop_cast(offset);\n-    return ArchiveHeapLoader::decode_from_archive(v);\n+bool StringTable::_is_two_dimensional_shared_strings_array = false;\n+OopHandle StringTable::_shared_strings_array;\n+int StringTable::_shared_strings_array_root_index;\n+\n+inline oop StringTable::read_string_from_compact_hashtable(address base_address, u4 index) {\n+  assert(ArchiveHeapLoader::is_in_use(), \"sanity\");\n+  objArrayOop array = (objArrayOop)(_shared_strings_array.resolve());\n+  oop s;\n+\n+  if (!_is_two_dimensional_shared_strings_array) {\n+    s = array->obj_at((int)index);\n@@ -82,7 +88,4 @@\n-    assert(!ArchiveHeapLoader::is_loaded(), \"Pointer relocation for uncompressed oops is unimplemented\");\n-    intptr_t dumptime_oop = (uintptr_t)offset;\n-    assert(dumptime_oop != 0, \"null strings cannot be interned\");\n-    intptr_t runtime_oop = dumptime_oop +\n-                           (intptr_t)FileMapInfo::current_info()->header()->heap_begin() +\n-                           (intptr_t)ArchiveHeapLoader::mapped_heap_delta();\n-    return (oop)cast_to_oop(runtime_oop);\n+    int primary_index = index >> _secondary_array_index_bits;\n+    int secondary_index = index & _secondary_array_index_mask;\n+    objArrayOop secondary = (objArrayOop)array->obj_at(primary_index);\n+    s = secondary->obj_at(secondary_index);\n@@ -90,0 +93,3 @@\n+\n+  assert(java_lang_String::is_instance(s), \"must be\");\n+  return s;\n@@ -94,1 +100,1 @@\n-  read_string_from_compact_hashtable,\n+  StringTable::read_string_from_compact_hashtable,\n@@ -227,0 +233,6 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (ArchiveHeapLoader::is_in_use()) {\n+    _shared_strings_array = OopHandle(Universe::vm_global(), HeapShared::get_root(_shared_strings_array_root_index));\n+  }\n+#endif\n@@ -758,11 +770,7 @@\n-class EncodeSharedStringsAsOffsets : StackObj {\n-  CompactHashtableWriter* _writer;\n-private:\n-  u4 compute_delta(oop s) {\n-    HeapWord* start = G1CollectedHeap::heap()->reserved().start();\n-    intx offset = ((address)(void*)s) - ((address)(void*)start);\n-    assert(offset >= 0, \"must be\");\n-    if (offset > 0xffffffff) {\n-      fatal(\"too large\");\n-    }\n-    return (u4)offset;\n+\/\/ This is called BEFORE we enter the CDS safepoint. We can allocate heap objects.\n+\/\/ This should be called when we know no more strings will be added (which will be easy\n+\/\/ to guarantee because CDS runs with a single Java thread. See JDK-8253495.)\n+void StringTable::allocate_shared_strings_array(TRAPS) {\n+  assert(DumpSharedSpaces, \"must be\");\n+  if (_items_count > (size_t)max_jint) {\n+    fatal(\"Too many strings to be archived: \" SIZE_FORMAT, _items_count);\n@@ -770,12 +778,23 @@\n-public:\n-  EncodeSharedStringsAsOffsets(CompactHashtableWriter* writer) : _writer(writer) {}\n-  bool do_entry(oop s, bool value_ignored) {\n-    assert(s != nullptr, \"sanity\");\n-    assert(!ArchiveHeapWriter::is_string_too_large_to_archive(s), \"must be\");\n-    oop req_s = ArchiveHeapWriter::source_obj_to_requested_obj(s);\n-    assert(req_s != nullptr, \"must have been archived\");\n-    unsigned int hash = java_lang_String::hash_code(s);\n-    if (UseCompressedOops) {\n-      _writer->add(hash, CompressedOops::narrow_oop_value(req_s));\n-    } else {\n-      _writer->add(hash, compute_delta(req_s));\n+\n+  int total = (int)_items_count;\n+  size_t single_array_size = objArrayOopDesc::object_size(total);\n+\n+  log_info(cds)(\"allocated string table for %d strings\", total);\n+\n+  if (!ArchiveHeapWriter::is_too_large_to_archive(single_array_size)) {\n+    \/\/ The entire table can fit in a single array\n+    objArrayOop array = oopFactory::new_objArray(vmClasses::Object_klass(), total, CHECK);\n+    _shared_strings_array = OopHandle(Universe::vm_global(), array);\n+    log_info(cds)(\"string table array (single level) length = %d\", total);\n+  } else {\n+    \/\/ Split the table in two levels of arrays.\n+    int primary_array_length = (total + _secondary_array_max_length - 1) \/ _secondary_array_max_length;\n+    size_t primary_array_size = objArrayOopDesc::object_size(primary_array_length);\n+    size_t secondary_array_size = objArrayOopDesc::object_size(_secondary_array_max_length);\n+\n+    if (ArchiveHeapWriter::is_too_large_to_archive(secondary_array_size)) {\n+      \/\/ This can only happen if you have an extremely large number of classes that\n+      \/\/ refer to more than 16384 * 16384 = 26M interned strings! Not a practical concern\n+      \/\/ but bail out for safety.\n+      log_error(cds)(\"Too many strings to be archived: \" SIZE_FORMAT, _items_count);\n+      os::_exit(1);\n@@ -783,1 +802,24 @@\n-    return true; \/\/ keep iterating\n+\n+    objArrayOop primary = oopFactory::new_objArray(vmClasses::Object_klass(), primary_array_length, CHECK);\n+    objArrayHandle primaryHandle(THREAD, primary);\n+    _shared_strings_array = OopHandle(Universe::vm_global(), primary);\n+\n+    log_info(cds)(\"string table array (primary) length = %d\", primary_array_length);\n+    for (int i = 0; i < primary_array_length; i++) {\n+      int len;\n+      if (total > _secondary_array_max_length) {\n+        len = _secondary_array_max_length;\n+      } else {\n+        len = total;\n+      }\n+      total -= len;\n+\n+      objArrayOop secondary = oopFactory::new_objArray(vmClasses::Object_klass(), len, CHECK);\n+      primaryHandle()->obj_at_put(i, secondary);\n+\n+      log_info(cds)(\"string table array (secondary)[%d] length = %d\", i, len);\n+      assert(!ArchiveHeapWriter::is_too_large_to_archive(secondary), \"sanity\");\n+    }\n+\n+    assert(total == 0, \"must be\");\n+    _is_two_dimensional_shared_strings_array = true;\n@@ -785,1 +827,1 @@\n-};\n+}\n@@ -787,2 +829,27 @@\n-\/\/ Write the _shared_table (a CompactHashtable) into the CDS archive file.\n-void StringTable::write_shared_table(const DumpedInternedStrings* dumped_interned_strings) {\n+#ifndef PRODUCT\n+void StringTable::verify_secondary_array_index_bits() {\n+  int max;\n+  for (max = 1; ; max++) {\n+    size_t next_size = objArrayOopDesc::object_size(1 << (max + 1));\n+    if (ArchiveHeapWriter::is_too_large_to_archive(next_size)) {\n+      break;\n+    }\n+  }\n+  \/\/ Currently max is 17 for +UseCompressedOops, 16 for -UseCompressedOops.\n+  \/\/ When we add support for Shenandoah (which has a smaller mininum region size than G1),\n+  \/\/ max will become 15\/14.\n+  \/\/\n+  \/\/ We use _secondary_array_index_bits==14 as that will be the eventual value, and will\n+  \/\/ make testing easier.\n+  assert(_secondary_array_index_bits <= max,\n+         \"_secondary_array_index_bits (%d) must be smaller than max possible value (%d)\",\n+         _secondary_array_index_bits, max);\n+}\n+#endif \/\/ PRODUCT\n+\n+\/\/ This is called AFTER we enter the CDS safepoint.\n+\/\/\n+\/\/ For each shared string:\n+\/\/ [1] Store it into _shared_strings_array. Encode its position as a 32-bit index.\n+\/\/ [2] Store the index and hashcode into _shared_table.\n+oop StringTable::init_shared_table(const DumpedInternedStrings* dumped_interned_strings) {\n@@ -790,0 +857,3 @@\n+  objArrayOop array = (objArrayOop)(_shared_strings_array.resolve());\n+\n+  verify_secondary_array_index_bits();\n@@ -794,5 +864,23 @@\n-  \/\/ Encode the strings in the CompactHashtable using offsets -- we know that the\n-  \/\/ strings will not move during runtime because they are inside the G1 closed\n-  \/\/ archive region.\n-  EncodeSharedStringsAsOffsets offset_finder(&writer);\n-  dumped_interned_strings->iterate(&offset_finder);\n+  int index = 0;\n+  auto copy_into_array = [&] (oop string, bool value_ignored) {\n+    unsigned int hash = java_lang_String::hash_code(string);\n+    writer.add(hash, index);\n+\n+    if (!_is_two_dimensional_shared_strings_array) {\n+      assert(index < array->length(), \"no strings should have been added\");\n+      array->obj_at_put(index, string);\n+    } else {\n+      int primary_index = index >> _secondary_array_index_bits;\n+      int secondary_index = index & _secondary_array_index_mask;\n+\n+      assert(primary_index < array->length(), \"no strings should have been added\");\n+      objArrayOop secondary = (objArrayOop)array->obj_at(primary_index);\n+\n+      assert(secondary != nullptr && secondary->is_objArray(), \"must be\");\n+      assert(secondary_index < secondary->length(), \"no strings should have been added\");\n+      secondary->obj_at_put(secondary_index, string);\n+    }\n+\n+    index ++;\n+  };\n+  dumped_interned_strings->iterate_all(copy_into_array);\n@@ -801,0 +889,6 @@\n+\n+  return array;\n+}\n+\n+void StringTable::set_shared_strings_array_index(int root_index) {\n+  _shared_strings_array_root_index = root_index;\n@@ -809,1 +903,1 @@\n-  } else if (!ArchiveHeapLoader::are_archived_strings_available()) {\n+  } else if (!ArchiveHeapLoader::is_in_use()) {\n@@ -813,0 +907,2 @@\n+  soc->do_bool(&_is_two_dimensional_shared_strings_array);\n+  soc->do_u4((u4*)(&_shared_strings_array_root_index));\n@@ -814,38 +910,0 @@\n-\n-class SharedStringTransfer {\n-  JavaThread* _current;\n-public:\n-  SharedStringTransfer(JavaThread* current) : _current(current) {}\n-\n-  void do_value(oop string) {\n-    JavaThread* THREAD = _current;\n-    ExceptionMark rm(THREAD);\n-    HandleMark hm(THREAD);\n-    StringTable::intern(string, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      \/\/ The archived constant pools contains strings that must be in the interned string table.\n-      \/\/ If we fail here, it means the VM runs out of memory during bootstrap, so there's no point\n-      \/\/ of trying to recover from here.\n-      vm_exit_during_initialization(\"Failed to transfer shared strings to interned string table\");\n-    }\n-  }\n-};\n-\n-\/\/ If the CDS archive heap is loaded (not mapped) into the old generation,\n-\/\/ it's possible for the shared strings to move due to full GC, making the\n-\/\/ _shared_table invalid. Therefore, we proactively copy all the shared\n-\/\/ strings into the _local_table, which can deal with oop relocation.\n-void StringTable::transfer_shared_strings_to_local_table() {\n-  assert(ArchiveHeapLoader::is_loaded(), \"must be\");\n-  EXCEPTION_MARK;\n-\n-  \/\/ Reset _shared_table so that during the transfer, StringTable::intern()\n-  \/\/ will not look up from there. Instead, it will create a new entry in\n-  \/\/ _local_table for each element in shared_table_copy.\n-  SharedStringTable shared_table_copy = _shared_table;\n-  _shared_table.reset();\n-\n-  SharedStringTransfer transfer(THREAD);\n-  shared_table_copy.iterate(&transfer);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":143,"deletions":85,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -107,0 +108,31 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static inline oop read_string_from_compact_hashtable(address base_address, u4 index);\n+\n+private:\n+  static bool _is_two_dimensional_shared_strings_array;\n+  static OopHandle _shared_strings_array;\n+  static int _shared_strings_array_root_index;\n+\n+  \/\/ All the shared strings are referenced through _shared_strings_array to keep them alive.\n+  \/\/ Each shared string is stored as a 32-bit index in ::_shared_table. The index\n+  \/\/ is interpreted in two ways:\n+  \/\/\n+  \/\/ [1] _is_two_dimensional_shared_strings_array = false: _shared_strings_array is an Object[].\n+  \/\/     Each shared string is stored as _shared_strings_array[index]\n+  \/\/\n+  \/\/ [2] _is_two_dimensional_shared_strings_array = true: _shared_strings_array is an Object[][]\n+  \/\/     This happens when there are too many elements in the shared table. We store them\n+  \/\/     using two levels of objArrays, such that none of the arrays are too big for\n+  \/\/     ArchiveHeapWriter::is_too_large_to_archive(). In this case, the index is splited into two\n+  \/\/     parts. Each shared string is stored as _shared_strings_array[primary_index][secondary_index]:\n+  \/\/\n+  \/\/           [bits 31 .. 14][ bits 13 .. 0  ]\n+  \/\/            primary_index  secondary_index\n+  const static int _secondary_array_index_bits = 14;\n+  const static int _secondary_array_max_length = 1 << _secondary_array_index_bits;\n+  const static int _secondary_array_index_mask = _secondary_array_max_length - 1;\n+\n+  \/\/ make sure _secondary_array_index_bits is not too big\n+  static void verify_secondary_array_index_bits() PRODUCT_RETURN;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+\n@@ -112,1 +144,3 @@\n-  static void write_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void allocate_shared_strings_array(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  static oop init_shared_table(const DumpedInternedStrings* dumped_interned_strings) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static void set_shared_strings_array_index(int root_index) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -114,1 +148,0 @@\n-  static void transfer_shared_strings_to_local_table() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n@@ -458,1 +458,1 @@\n-        ArchiveHeapLoader::are_archived_mirrors_available() &&\n+        ArchiveHeapLoader::is_in_use() &&\n@@ -815,4 +815,1 @@\n-    \/\/ system dictionary, symbol table, etc.).  After that, access to\n-    \/\/ the file (other than the mapped regions) is no longer needed, and\n-    \/\/ the file is closed. Closing the file does not affect the\n-    \/\/ currently mapped regions.\n+    \/\/ system dictionary, symbol table, etc.)\n@@ -820,9 +817,0 @@\n-    StringTable::create_table();\n-    if (ArchiveHeapLoader::is_loaded()) {\n-      StringTable::transfer_shared_strings_to_local_table();\n-    }\n-  } else\n-#endif\n-  {\n-    SymbolTable::create_table();\n-    StringTable::create_table();\n@@ -830,2 +818,0 @@\n-\n-#if INCLUDE_CDS\n@@ -837,0 +823,3 @@\n+  SymbolTable::create_table();\n+  StringTable::create_table();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-    if (ArchiveHeapLoader::is_fully_available() &&\n+    if (ArchiveHeapLoader::is_in_use() &&\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-    if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n+    if (ArchiveHeapLoader::is_in_use()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver\/timeout=500 SharedStringsStress\n+ * @run driver\/timeout=650 SharedStringsStress\n@@ -55,1 +55,4 @@\n-            for (int i=0; i<200000; i++) {\n+            \/\/ Create enough entries to require the shared string\n+            \/\/ table to split into two levels of Object arrays. See\n+            \/\/ StringTable::allocate_shared_table() in HotSpot.\n+            for (int i=0; i<260000; i++) {\n@@ -94,0 +97,3 @@\n+            dumpOutput.shouldContain(\"string table array (primary)\");\n+            dumpOutput.shouldContain(\"string table array (secondary)\");\n+\n@@ -95,1 +101,1 @@\n-                TestCommon.concat(vmOptionsPrefix, \"HelloString\"));\n+                TestCommon.concat(vmOptionsPrefix, \"-Xlog:cds\", \"HelloString\"));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}