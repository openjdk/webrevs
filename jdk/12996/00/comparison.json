{"files":[{"patch":"@@ -328,1 +328,1 @@\n-        if (constantValue instanceof ClassDesc value) {\n+        if (constantValue instanceof ClassDesc value && !value.isPrimitive()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031\n+ * @summary Testing that primitive class descs are encoded properly as loadable constants.\n+ * @run testng PrimitiveClassConstantTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import jdk.internal.classfile.Classfile;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+\n+public final class PrimitiveClassConstantTest {\n+\n+    @Test\n+    public void test() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(Classfile.build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(\"<init>\", MethodTypeDesc.of(CD_void), ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, \"<init>\", MethodTypeDesc.of(CD_void));\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.constantInstruction(CD_int);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        Assert.assertSame(t.get(), int.class);\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}