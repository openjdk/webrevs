{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : ClassWriter.maskToAccessFlagsIgnoreUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -38,0 +39,1 @@\n+import java.util.EnumMap;\n@@ -39,0 +41,1 @@\n+import java.util.Map;\n@@ -420,1 +423,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsIgnoreUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -449,1 +452,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsIgnoreUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -481,1 +484,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsIgnoreUnknown(m.flags()))\n@@ -564,1 +567,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsIgnoreUnknown(m.flags())) {\n@@ -798,10 +801,2 @@\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-    }\n-\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n+        return getModifiers(flagsIgnoreUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -818,1 +813,1 @@\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofClass(mask)));\n@@ -822,1 +817,1 @@\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofMethod(mask)));\n@@ -826,1 +821,1 @@\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofField(mask)));\n@@ -843,33 +838,14 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n+    static Set<AccessFlag> flagsIgnoreUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsIgnoreUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    static Set<AccessFlag> maskToAccessFlagsIgnoreUnknown(int mask, AccessFlag.Location location) {\n+        return AccessFlag.maskToAccessFlags(mask & LOCATION_MASKS.get(location), location);\n+    }\n+\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n@@ -877,0 +853,11 @@\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":37,"deletions":50,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8333748\n+ * @summary javap should not fail if reserved access flag bits are set to 1\n+ * @library \/tools\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ * @enablePreview\n+ * @run junit UndefinedAccessFlagTest\n+ *\/\n+\n+import toolbox.JavapTask;\n+import toolbox.ToolBox;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.classfile.ClassFile.*;\n+\n+public class UndefinedAccessFlagTest {\n+\n+    final ToolBox toolBox = new ToolBox();\n+\n+    @Test\n+    void test() throws Throwable {\n+        var cf = of();\n+        ClassModel cm;\n+        try (var is = UndefinedAccessFlagTest.class.getResourceAsStream(\n+            \"\/UndefinedAccessFlagTest$SampleInnerClass.class\"\n+        )) {\n+            cm = cf.parse(is.readAllBytes());\n+        }\n+        var bytes = cf.transform(cm, (cb, ce) -> {\n+            switch (ce) {\n+                case AccessFlags flags -> cb.withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f -> cb.transformField(f, (fb, fe) -> {\n+                    if (fe instanceof AccessFlags flags) {\n+                        fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                    } else {\n+                        fb.with(fe);\n+                    }\n+                });\n+                case MethodModel m -> cb.transformMethod(m, (mb, me) -> {\n+                    if (me instanceof AccessFlags flags) {\n+                        mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                    } else {\n+                        mb.with(me);\n+                    }\n+                });\n+                case InnerClassesAttribute attr -> {\n+                    cb.with(InnerClassesAttribute.of(attr.classes().stream()\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .toList()));\n+                }\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+        Files.write(Path.of(\"transformed.class\"), bytes);\n+\n+        new JavapTask(toolBox)\n+            .classes(\"transformed.class\")\n+            .options(\"-c\", \"-p\", \"-v\")\n+            .run();\n+    }\n+\n+    static class SampleInnerClass {\n+        String field;\n+        void method() {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}