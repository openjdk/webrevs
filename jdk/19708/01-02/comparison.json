{"files":[{"patch":"@@ -211,1 +211,1 @@\n-                        for (var flag : ClassWriter.maskToAccessFlagsIgnoreUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,6 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -41,0 +47,20 @@\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n+        }\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n+    }\n+\n@@ -49,0 +75,14 @@\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+        try {\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        } catch (IllegalArgumentException ex) {\n+            mask &= LOCATION_MASKS.get(location);\n+            report(ex);\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.AccessFlag;\n@@ -39,1 +38,0 @@\n-import java.util.EnumMap;\n@@ -41,1 +39,0 @@\n-import java.util.Map;\n@@ -423,1 +420,1 @@\n-        writeModifiers(flagsIgnoreUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -452,1 +449,1 @@\n-                    flagsIgnoreUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -484,1 +481,1 @@\n-        for (var f : flagsIgnoreUnknown(m.flags()))\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -567,1 +564,1 @@\n-            for (var f : flagsIgnoreUnknown(m.flags())) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -800,2 +797,2 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(flagsIgnoreUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n@@ -812,2 +809,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofClass(mask)));\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -816,2 +813,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofMethod(mask)));\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -820,2 +817,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, flagsIgnoreUnknown(AccessFlags.ofField(mask)));\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -838,28 +835,0 @@\n-    static Set<AccessFlag> flagsIgnoreUnknown(AccessFlags flags) {\n-        return maskToAccessFlagsIgnoreUnknown(flags.flagsMask(), flags.location());\n-    }\n-\n-    static Set<AccessFlag> maskToAccessFlagsIgnoreUnknown(int mask, AccessFlag.Location location) {\n-        return AccessFlag.maskToAccessFlags(mask & LOCATION_MASKS.get(location), location);\n-    }\n-\n-    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n-\n-    static {\n-        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n-        for (var loc : AccessFlag.Location.values()) {\n-            map.put(loc, 0);\n-        }\n-\n-        for (var flag : AccessFlag.values()) {\n-            for (var loc : flag.locations()) {\n-                map.compute(loc, (_, v) -> v | flag.mask());\n-            }\n-        }\n-\n-        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n-        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n-\n-        LOCATION_MASKS = map;\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":12,"deletions":43,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -34,0 +36,1 @@\n+import toolbox.Task;\n@@ -36,2 +39,0 @@\n-import org.junit.jupiter.api.Test;\n-\n@@ -48,0 +49,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -53,2 +55,7 @@\n-    @Test\n-    void test() throws Throwable {\n+    enum TestLocation {\n+        CLASS, FIELD, METHOD, INNER_CLASS\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestLocation.class)\n+    void test(TestLocation location) throws Throwable {\n@@ -64,17 +71,20 @@\n-                case AccessFlags flags -> cb.withFlags(flags.flagsMask() | ACC_PRIVATE);\n-                case FieldModel f -> cb.transformField(f, (fb, fe) -> {\n-                    if (fe instanceof AccessFlags flags) {\n-                        fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n-                    } else {\n-                        fb.with(fe);\n-                    }\n-                });\n-                case MethodModel m -> cb.transformMethod(m, (mb, me) -> {\n-                    if (me instanceof AccessFlags flags) {\n-                        mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n-                    } else {\n-                        mb.with(me);\n-                    }\n-                });\n-                case InnerClassesAttribute attr -> {\n-                    cb.with(InnerClassesAttribute.of(attr.classes().stream()\n+                case AccessFlags flags when location == TestLocation.CLASS -> cb\n+                    .withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f when location == TestLocation.FIELD -> cb\n+                    .transformField(f, (fb, fe) -> {\n+                        if (fe instanceof AccessFlags flags) {\n+                            fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                        } else {\n+                            fb.with(fe);\n+                        }\n+                    });\n+                case MethodModel m when location == TestLocation.METHOD -> cb\n+                    .transformMethod(m, (mb, me) -> {\n+                        if (me instanceof AccessFlags flags) {\n+                            mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                        } else {\n+                            mb.with(me);\n+                        }\n+                    });\n+                case InnerClassesAttribute attr when location == TestLocation.INNER_CLASS -> cb\n+                    .with(InnerClassesAttribute.of(attr.classes().stream()\n@@ -83,1 +93,0 @@\n-                }\n@@ -90,1 +99,1 @@\n-        new JavapTask(toolBox)\n+        var lines = new JavapTask(toolBox)\n@@ -93,1 +102,4 @@\n-            .run();\n+            .run(location == TestLocation.INNER_CLASS ? Task.Expect.SUCCESS : Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"Unmatched bit position\")), () -> String.join(\"\\n\", lines));\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"}]}