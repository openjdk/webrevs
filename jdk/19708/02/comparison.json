{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,6 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -41,0 +47,20 @@\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n+        }\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n+    }\n+\n@@ -49,0 +75,14 @@\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+        try {\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        } catch (IllegalArgumentException ex) {\n+            mask &= LOCATION_MASKS.get(location);\n+            report(ex);\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -449,1 +449,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -481,1 +481,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -564,1 +564,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -797,11 +797,3 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-    }\n-\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -817,2 +809,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -821,2 +813,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -825,2 +817,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -843,36 +835,0 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n-        }\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8333748\n+ * @summary javap should not fail if reserved access flag bits are set to 1\n+ * @library \/tools\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ * @enablePreview\n+ * @run junit UndefinedAccessFlagTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UndefinedAccessFlagTest {\n+\n+    final ToolBox toolBox = new ToolBox();\n+\n+    enum TestLocation {\n+        CLASS, FIELD, METHOD, INNER_CLASS\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestLocation.class)\n+    void test(TestLocation location) throws Throwable {\n+        var cf = of();\n+        ClassModel cm;\n+        try (var is = UndefinedAccessFlagTest.class.getResourceAsStream(\n+            \"\/UndefinedAccessFlagTest$SampleInnerClass.class\"\n+        )) {\n+            cm = cf.parse(is.readAllBytes());\n+        }\n+        var bytes = cf.transform(cm, (cb, ce) -> {\n+            switch (ce) {\n+                case AccessFlags flags when location == TestLocation.CLASS -> cb\n+                    .withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f when location == TestLocation.FIELD -> cb\n+                    .transformField(f, (fb, fe) -> {\n+                        if (fe instanceof AccessFlags flags) {\n+                            fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                        } else {\n+                            fb.with(fe);\n+                        }\n+                    });\n+                case MethodModel m when location == TestLocation.METHOD -> cb\n+                    .transformMethod(m, (mb, me) -> {\n+                        if (me instanceof AccessFlags flags) {\n+                            mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                        } else {\n+                            mb.with(me);\n+                        }\n+                    });\n+                case InnerClassesAttribute attr when location == TestLocation.INNER_CLASS -> cb\n+                    .with(InnerClassesAttribute.of(attr.classes().stream()\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .toList()));\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+        Files.write(Path.of(\"transformed.class\"), bytes);\n+\n+        var lines = new JavapTask(toolBox)\n+            .classes(\"transformed.class\")\n+            .options(\"-c\", \"-p\", \"-v\")\n+            .run(location == TestLocation.INNER_CLASS ? Task.Expect.SUCCESS : Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"Unmatched bit position\")), () -> String.join(\"\\n\", lines));\n+    }\n+\n+    static class SampleInnerClass {\n+        String field;\n+        void method() {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}