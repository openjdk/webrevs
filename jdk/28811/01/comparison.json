{"files":[{"patch":"@@ -510,2 +510,2 @@\n-  const Type* recv_type = C->initial_gvn()->type(receiver);\n-  if (recv_type->maybe_null()) {\n+  const TypeOopPtr* recv_type = C->initial_gvn()->type(receiver)->isa_oopptr();\n+  if (recv_type == nullptr || recv_type->maybe_null()) {\n@@ -530,0 +530,1 @@\n+                                        recv_type \/*receiver_type*\/,\n@@ -1107,0 +1108,1 @@\n+        const TypeOopPtr* receiver_type = nullptr;\n@@ -1110,2 +1112,2 @@\n-          Node*             receiver_node = kit.argument(0);\n-          const TypeOopPtr* receiver_type = gvn.type(receiver_node)->isa_oopptr();\n+          Node* receiver_node = kit.argument(0);\n+          receiver_type = gvn.type(receiver_node)->isa_oopptr();\n@@ -1127,0 +1129,1 @@\n+                                              receiver_type,\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -984,1 +984,3 @@\n-                                   JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = nullptr,\n+                                   JVMState* jvms, bool allow_inline, float profile_factor,\n+                                   const TypeOopPtr* receiver_type = nullptr,\n+                                   ciKlass* speculative_receiver_type = nullptr,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,2 +90,3 @@\n-                                       JVMState* jvms, bool allow_inline,\n-                                       float prof_factor, ciKlass* speculative_receiver_type,\n+                                       JVMState* jvms, bool allow_inline, float prof_factor,\n+                                       const TypeOopPtr* receiver_type,\n+                                       ciKlass* speculative_receiver_type,\n@@ -154,2 +155,2 @@\n-        CallGenerator* inline_cg = this->call_generator(callee,\n-              vtable_index, call_does_dispatch, jvms, allow_inline, prof_factor, speculative_receiver_type, false);\n+        CallGenerator* inline_cg = this->call_generator(callee, vtable_index, call_does_dispatch, jvms, allow_inline,\n+                                                        prof_factor, receiver_type, speculative_receiver_type, false);\n@@ -328,3 +329,3 @@\n-    \/\/ may be able to bind this invoke directly to the implementing\n-    \/\/ klass but we need both a dependence on the single interface\n-    \/\/ and on the method we bind to. Additionally since all we know\n+    \/\/ may be able to bind this invoke directly to the implementing klass,\n+    \/\/ but we need both a dependence on the single interface and\n+    \/\/ on the method we bind to. Additionally, since all we know\n@@ -334,7 +335,3 @@\n-    \/\/ they are roughly equivalent to Object.\n-    \/\/ The number of implementors for declared_interface is less or\n-    \/\/ equal to the number of implementors for target->holder() so\n-    \/\/ if number of implementors of target->holder() == 1 then\n-    \/\/ number of implementors for decl_interface is 0 or 1. If\n-    \/\/ it's 0 then no class implements decl_interface and there's\n-    \/\/ no point in inlining.\n+    \/\/ they are roughly equivalent to Object, but receiver type can be used\n+    \/\/ to narrow context type beyond declared_interface, so a more specific\n+    \/\/ interface with a unique implementor can be used instead.\n@@ -342,1 +339,2 @@\n-      ciInstanceKlass* declared_interface = nullptr;\n+      ciInstanceKlass* context_intf = nullptr;\n+      \/\/ Use declared interface class as a starting point.\n@@ -347,1 +345,1 @@\n-        declared_interface = callee->holder();\n+        context_intf = callee->holder();\n@@ -350,1 +348,12 @@\n-        declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+        context_intf = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+      }\n+      assert(context_intf->is_interface(), \"required\");\n+\n+      \/\/ Based on receiver info, narrow context to one of most specific superinterfaces with a unique implementor.\n+      if (receiver_type != nullptr && receiver_type->isa_instptr()) {\n+        ciInstanceKlass* intf = receiver_type->is_instptr()->has_unique_implementor(context_intf);\n+        if (intf != nullptr && intf != context_intf) {\n+          assert(intf->is_subtype_of(context_intf), \"not related\");\n+          assert(intf->unique_implementor() != nullptr, \"no unique implementor\");\n+          context_intf = intf;\n+        }\n@@ -352,2 +361,0 @@\n-      assert(declared_interface->is_interface(), \"required\");\n-      ciInstanceKlass* singleton = declared_interface->unique_implementor();\n@@ -355,0 +362,1 @@\n+      ciInstanceKlass* singleton = context_intf->unique_implementor();\n@@ -356,1 +364,1 @@\n-        assert(singleton != declared_interface, \"not a unique implementor\");\n+        assert(singleton != context_intf, \"not a unique implementor\");\n@@ -359,1 +367,1 @@\n-            callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);\n+            callee->find_monomorphic_target(caller->holder(), context_intf, singleton, check_access);\n@@ -366,2 +374,2 @@\n-          CallGenerator* hit_cg = call_generator(cha_monomorphic_target,\n-              vtable_index, !call_does_dispatch, jvms, allow_inline, prof_factor);\n+          CallGenerator* hit_cg = call_generator(cha_monomorphic_target, vtable_index, !call_does_dispatch, jvms,\n+                                                 allow_inline, prof_factor);\n@@ -371,1 +379,2 @@\n-              Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+                                                                    Deoptimization::Reason_class_check,\n+                                                                    Deoptimization::Action_none);\n@@ -376,2 +385,2 @@\n-            dependencies()->assert_unique_implementor(declared_interface, singleton);\n-            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target, declared_interface, callee);\n+            dependencies()->assert_unique_implementor(context_intf, singleton);\n+            dependencies()->assert_unique_concrete_method(context_intf, cha_monomorphic_target, context_intf, callee);\n@@ -598,0 +607,1 @@\n+  const TypeOopPtr* receiver_type = nullptr;\n@@ -600,2 +610,2 @@\n-    Node* receiver_node             = stack(sp() - nargs);\n-    const TypeOopPtr* receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n+    Node* receiver_node = stack(sp() - nargs);\n+    receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n@@ -612,1 +622,1 @@\n-    speculative_receiver_type = receiver_type != nullptr ? receiver_type->speculative_type() : nullptr;\n+    speculative_receiver_type = (receiver_type != nullptr ? receiver_type->speculative_type() : nullptr);\n@@ -658,1 +668,2 @@\n-  CallGenerator* cg = C->call_generator(callee, vtable_index, call_does_dispatch, jvms, try_inline, prof_factor(), speculative_receiver_type);\n+  CallGenerator* cg = C->call_generator(callee, vtable_index, call_does_dispatch, jvms, try_inline, prof_factor(),\n+                                        receiver_type, speculative_receiver_type);\n@@ -703,1 +714,3 @@\n-    cg = C->call_generator(cg->method(), vtable_index, call_does_dispatch, jvms, try_inline, prof_factor(), speculative_receiver_type, \/* allow_intrinsics= *\/ false);\n+    cg = C->call_generator(cg->method(), vtable_index, call_does_dispatch, jvms, try_inline, prof_factor(),\n+                           receiver_type, speculative_receiver_type,\n+                           false \/*allow_intrinsics*\/);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":44,"deletions":31,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3461,0 +3461,16 @@\n+\/\/ Look for a leaf interface with unique implementor under context class. Report one of possibly many.\n+ciInstanceKlass* TypeInterfaces::has_unique_implementor(ciInstanceKlass* context) const {\n+  assert(context->is_interface(), \"not an interface\");\n+  ciInstanceKlass* candidate = nullptr;\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciInstanceKlass* intf = _interfaces.at(i);\n+    if (intf->is_subtype_of(context) && (intf->unique_implementor() != nullptr)) {\n+      if (candidate == nullptr || intf->is_subtype_of(candidate)) {\n+        assert(candidate == nullptr || (candidate->unique_implementor() != nullptr), \"not a candidate\");\n+        candidate = intf;\n+      }\n+    }\n+  }\n+  return candidate;\n+}\n+\n@@ -4570,0 +4586,13 @@\n+\/\/ Does the type represent an interface instance?\n+bool TypeInstPtr::is_interface() const {\n+  return (instance_klass() == ciEnv::current()->Object_klass()) && !_interfaces->empty();\n+}\n+\n+\/\/ For an interface instance reports one of most specific superinterfaces with a unique implementor.\n+ciInstanceKlass* TypeInstPtr::has_unique_implementor(ciInstanceKlass* context_intf) const {\n+  if (is_interface() && context_intf->is_interface()) {\n+    return _interfaces->has_unique_implementor(context_intf);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1162,0 +1162,2 @@\n+\n+  ciInstanceKlass* has_unique_implementor(ciInstanceKlass* context) const;\n@@ -1619,0 +1621,5 @@\n+  bool is_interface() const;\n+\n+  \/\/ Find one (of possibly many) most specific superinterfaces with a unique implementor.\n+  ciInstanceKlass* has_unique_implementor(ciInstanceKlass* context_intf) const;\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n- * @requires !vm.graal.enabled\n- * @requires vm.opt.StressMethodHandleLinkerInlining == null | !vm.opt.StressMethodHandleLinkerInlining\n- * @requires vm.opt.StressUnstableIfTraps == null | !vm.opt.StressUnstableIfTraps\n+ * @requires vm.flagless\n@@ -61,0 +59,1 @@\n+import java.util.concurrent.Callable;\n@@ -63,0 +62,1 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n@@ -85,0 +85,5 @@\n+        \/\/ Receiver type information is only available in C2.\n+        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n+            run(MultipleInterfacesOnReceiver.class);\n+            run(MultipleInterfacesOnReceiver.TestMH.class, MultipleInterfacesOnReceiver.class);\n+        }\n@@ -465,10 +470,4 @@\n-            if (contextClass() == I.class) {\n-                initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n-                           K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n-                           K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n-                assertCompiled();\n-            } else if (contextClass() == J.class) {\n-                \/\/ no classes to initialize w\/o breaking a dependency\n-            } else {\n-                throw new InternalError(\"unsupported context: \" + contextClass());\n-            }\n+            initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n+                       K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n+                       K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n+            assertCompiled();\n@@ -559,4 +558,0 @@\n-        Class<?> contextClass() {\n-            return I.class;\n-        }\n-\n@@ -571,5 +566,0 @@\n-            @Override\n-            Class<?> contextClass() {\n-                return J.class;\n-            }\n-\n@@ -741,11 +731,5 @@\n-            if (contextClass() == I.class) {\n-                initialize(DJ.class,   \/\/       DJ.m                               <: intf J.m ABSTRACT\n-                           K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n-                           K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n-                           DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n-                assertCompiled();\n-            } else if (contextClass() == J.class) {\n-                \/\/ no classes to initialize w\/o breaking a dependency\n-            } else {\n-                throw new InternalError(\"unsupported context: \" + contextClass());\n-            }\n+            initialize(DJ.class,   \/\/       DJ.m                               <: intf J.m ABSTRACT\n+                       K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n+                       K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n+                       DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n+            assertCompiled();\n@@ -778,4 +762,0 @@\n-        Class<?> contextClass() {\n-            return I.class;\n-        }\n-\n@@ -790,5 +770,0 @@\n-            @Override\n-            Class<?> contextClass() {\n-                return J.class;\n-            }\n-\n@@ -839,14 +814,5 @@\n-            if (contextClass() == I.class) {\n-                initialize(DJ1.class, \/\/      DJ1.m                               <: intf J1\n-                           DJ2.class, \/\/      DJ2.m                               <:          intf J2.m ABSTRACT\n-                           K1.class,  \/\/ intf  K1            <: intf I            <: intf J1, intf J2.m ABSTRACT\n-                           K2.class,  \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J1, intf J2.m ABSTRACT\n-                           K3.class); \/\/ intf  K3.m DEFAULT  <: intf I            <: intf J1, intf J2.m ABSTRACT\n-            } else if (contextClass() == J2.class) {\n-                initialize(DJ1.class, \/\/      DJ1.m                               <: intf J1\n-                           K1.class,  \/\/ intf  K1            <: intf I            <: intf J1, intf J2.m ABSTRACT\n-                           K2.class,  \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J1, intf J2.m ABSTRACT\n-                           K3.class); \/\/ intf  K3.m DEFAULT  <: intf I            <: intf J1, intf J2.m ABSTRACT\n-            } else {\n-                throw new InternalError(\"unsupported context: \" + contextClass());\n-            }\n+            initialize(DJ1.class, \/\/      DJ1.m                               <: intf J1\n+                       DJ2.class, \/\/      DJ2.m                               <:          intf J2.m ABSTRACT\n+                       K1.class,  \/\/ intf  K1            <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                       K2.class,  \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                       K3.class); \/\/ intf  K3.m DEFAULT  <: intf I            <: intf J1, intf J2.m ABSTRACT\n@@ -886,4 +852,0 @@\n-        Class<?> contextClass() {\n-            return I.class;\n-        }\n-\n@@ -899,2 +861,2 @@\n-            Class<?> contextClass() {\n-                return J2.class;\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n@@ -902,0 +864,80 @@\n+        }\n+    }\n+\n+    public static class MultipleInterfacesOnReceiver extends ATest<MultipleInterfacesOnReceiver.I> {\n+        public MultipleInterfacesOnReceiver() { super(I.class, D.class); }\n+\n+        interface L1 {}\n+        interface L2 {}\n+\n+        interface J           { Object m(); }\n+        interface I extends J {}\n+\n+        interface I1 extends I {}\n+        interface I2 extends I {}\n+        interface I3 extends I {}\n+        interface I4 extends I {}\n+\n+        interface K1 extends I1 {}\n+        interface K2 extends I2 {}\n+        interface K3 extends I3 {}\n+        interface K4 extends I4 {}\n+\n+        static class C implements I { public Object m() { return WRONG; }}\n+\n+        static class D implements K1, K2, K3, K4, L1, L2 { public Object m() { return CORRECT; }}\n+\n+        static class F1 implements K1 { public Object m() { return WRONG; }}\n+        static class F2 implements K2 { public Object m() { return WRONG; }}\n+        static class F3 implements K3 { public Object m() { return WRONG; }}\n+        static class F4 implements K4 { public Object m() { return WRONG; }}\n+\n+        @DontInline\n+        public Object test(I i) throws Throwable {\n+            \/\/ K1, K2, K3, and K4 are interfaces with unique implementor D until F1, ..., F4 are loaded.\n+            if (i instanceof K1 && i instanceof K2 && i instanceof K3 && i instanceof K4 &&\n+                i instanceof L1 && i instanceof L2) {\n+                return i.m(); \/\/ I <: J.m ABSTRACT; i <: (K1 & K2 & K3 & K4 & L1 & L2)\n+            } else {\n+                return WRONG;\n+            }\n+        }\n+\n+        @TestCase\n+        public void testMega() throws Exception {\n+            assertTrue(!jdk.test.whitebox.code.Compiler.isC1Enabled(), \"C2 only\");\n+\n+            initialize(C.class); \/\/ exclude I\n+\n+            \/\/ NB! Avoid accessing context classes directly to delay their loading until context invalidation.\n+            for (Callable<?> context : new Callable[] { () -> F1.class, () -> F2.class,\n+                                                        () -> F3.class, () -> F4.class }) {\n+                \/\/ Trigger compilation of a megamorphic call site\n+                resetCompiledState();\n+                compile(megamorphic());\n+                assertCompiled();\n+\n+                \/\/ Dependency: type = unique_concrete_method, context = F1...F4, method = D.m\n+\n+                initialize((Class<?>)context.call()); \/\/ context class doesn't have a unique implementor anymore,\n+                                                      \/\/ but we can't say which one is chosen as a context by the JVM\n+            }\n+            assertNotCompiled();\n+\n+            compile(megamorphic());\n+            assertCompiled();\n+\n+            initialize(L1.class, L2.class); \/\/ unrelated interfaces\n+            assertCompiled();\n+\n+            repeat(100, () -> call(new D() {})); \/\/ new implementor\n+            assertCompiled();\n+        }\n+\n+        @Override\n+        public void checkInvalidReceiver() {\n+            \/\/ nothing to check; test has instanceof guards\n+        }\n+\n+        public static class TestMH extends MultipleInterfacesOnReceiver {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n@@ -904,2 +946,7 @@\n-            public Object test(I obj) throws Throwable {\n-                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            public Object test(I i) throws Throwable {\n+                if (i instanceof K1 && i instanceof K2 && i instanceof K3 && i instanceof K4 &&\n+                    i instanceof L1 && i instanceof L2) {\n+                    return TEST_MH.invokeExact(i); \/\/ invokeinterface I.m(); i <: (K1 & K2 & K3 & K4 & L1 & L2)\n+                } else {\n+                    return WRONG;\n+                }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":111,"deletions":64,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -161,0 +161,5 @@\n+\n+        public void resetCompiledState() {\n+            prevNM = null;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}