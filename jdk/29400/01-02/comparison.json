{"files":[{"patch":"@@ -98,1 +98,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc_impl.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -605,0 +605,32 @@\n+\/\/ Override vDSO path to kernel directory (\/lib\/modules\/<version>\/vdso) if possible.\n+\/\/ Then lib_name would be overwritten that path.\n+\/\/ Otherwise copy vDSO memory in coredump to temporal memory generated by memfd_create().\n+\/\/ Returns FD for vDSO (should be closed by caller).\n+static int handle_vdso(struct ps_prochandle* ph, char* lib_name, size_t lib_name_len) {\n+  int lib_fd;\n+  struct utsname uts;\n+  uname(&uts);\n+\n+  \/\/ Check vDSO binary first (for referring debuginfo if possible).\n+  char *vdso_path = (char*)malloc(lib_name_len);\n+  snprintf(vdso_path, lib_name_len, \"\/lib\/modules\/%s\/vdso\/vdso64.so\", uts.release);\n+  if (access(vdso_path, F_OK) == 0) {\n+    print_debug(\"replace vDSO: %s -> %s\\n\", lib_name, vdso_path);\n+    strncpy(lib_name, vdso_path, lib_name_len);\n+    lib_fd = pathmap_open(lib_name);\n+  } else {\n+    \/\/ Copy vDSO memory segment from core to temporal memory\n+    \/\/ if vDSO binary is not available.\n+    lib_fd = memfd_create(\"[vdso] in core\", 0);\n+    off64_t ofs = ph->core->vdso_offset;\n+    if (sendfile64(lib_fd, ph->core->core_fd, &ofs, ph->core->vdso_size) == -1) {\n+      print_debug(\"can't copy vDSO (%d)\\n\", errno);\n+      close(lib_fd);\n+      lib_fd = -1;\n+    }\n+  }\n+\n+  free(vdso_path);\n+  return lib_fd;\n+}\n+\n@@ -702,28 +734,1 @@\n-            struct utsname uts;\n-            uname(&uts);\n-\n-            const char *vdso_name\n-#ifdef _LP64\n-              = \"vdso64.so\";\n-#else\n-              = \"vdso32.so\";\n-#endif\n-\n-            \/\/ Check vDSO binary first (for referring debuginfo if possible).\n-            char vdso_path[PATH_MAX];\n-            snprintf(vdso_path, sizeof(vdso_path), \"\/lib\/modules\/%s\/vdso\/%s\", uts.release, vdso_name);\n-            if (access(vdso_path, F_OK) == 0) {\n-               print_debug(\"replace vDSO: %s -> %s\\n\", lib_name, vdso_path);\n-               strcpy(lib_name, vdso_path);\n-               lib_fd = pathmap_open(lib_name);\n-            } else {\n-               \/\/ Copy vDSO memory segment from core to temporal memory\n-               \/\/ if vDSO binary is not available.\n-               lib_fd = memfd_create(\"[vdso] in core\", 0);\n-               off64_t ofs = ph->core->vdso_offset;\n-               if (sendfile64(lib_fd, ph->core->core_fd, &ofs, ph->core->vdso_size) == -1) {\n-                  print_debug(\"can't copy vDSO (%d)\\n\", errno);\n-                  close(lib_fd);\n-                  lib_fd = -1;\n-               }\n-            }\n+           lib_fd = handle_vdso(ph, lib_name, sizeof(lib_name));\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"}]}