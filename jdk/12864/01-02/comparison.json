{"files":[{"patch":"@@ -1,853 +0,0 @@\n-\n-#line 1 \"hb-buffer-deserialize-text.rl\"\n-\/*\n- * Copyright Â© 2013  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_BUFFER_DESERIALIZE_TEXT_HH\n-#define HB_BUFFER_DESERIALIZE_TEXT_HH\n-\n-#include \"hb.hh\"\n-\n-\n-#line 36 \"hb-buffer-deserialize-text.hh\"\n-static const unsigned char _deserialize_text_trans_keys[] = {\n-        0u, 0u, 9u, 91u, 85u, 85u, 43u, 43u, 48u, 102u, 9u, 85u, 48u, 57u, 45u, 57u,\n-        48u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u,\n-        43u, 124u, 45u, 57u, 48u, 57u, 9u, 124u, 9u, 124u, 0u, 0u, 9u, 85u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 0\n-};\n-\n-static const char _deserialize_text_key_spans[] = {\n-        0, 83, 1, 1, 55, 77, 10, 13,\n-        10, 10, 13, 10, 1, 13, 10, 14,\n-        82, 13, 10, 116, 116, 0, 77, 116,\n-        116, 116, 116, 116, 116, 116, 116, 116,\n-        116, 116, 116, 116, 116\n-};\n-\n-static const short _deserialize_text_index_offsets[] = {\n-        0, 0, 84, 86, 88, 144, 222, 233,\n-        247, 258, 269, 283, 294, 296, 310, 321,\n-        336, 419, 433, 444, 561, 678, 679, 757,\n-        874, 991, 1108, 1225, 1342, 1459, 1576, 1693,\n-        1810, 1927, 2044, 2161, 2278\n-};\n-\n-static const char _deserialize_text_indicies[] = {\n-        0, 0, 0, 0, 0, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        0, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 2, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 3, 1, 4, 1, 5,\n-        1, 6, 6, 6, 6, 6, 6, 6,\n-        6, 6, 6, 1, 1, 1, 1, 1,\n-        1, 1, 6, 6, 6, 6, 6, 6,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 6, 6, 6, 6, 6, 6,\n-        1, 7, 7, 7, 7, 7, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        7, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 4, 1, 8,\n-        9, 9, 9, 9, 9, 9, 9, 9,\n-        9, 1, 10, 1, 1, 11, 12, 12,\n-        12, 12, 12, 12, 12, 12, 12, 1,\n-        13, 14, 14, 14, 14, 14, 14, 14,\n-        14, 14, 1, 15, 16, 16, 16, 16,\n-        16, 16, 16, 16, 16, 1, 17, 1,\n-        1, 18, 19, 19, 19, 19, 19, 19,\n-        19, 19, 19, 1, 20, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 1, 22,\n-        1, 23, 1, 1, 24, 25, 25, 25,\n-        25, 25, 25, 25, 25, 25, 1, 26,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 1, 22, 1, 1, 1, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        1, 28, 28, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 28, 1, 1, 28, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 28, 28, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 28, 1, 29, 1, 1, 30,\n-        31, 31, 31, 31, 31, 31, 31, 31,\n-        31, 1, 32, 33, 33, 33, 33, 33,\n-        33, 33, 33, 33, 1, 34, 34, 34,\n-        34, 34, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 34, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 35, 35, 35, 35,\n-        35, 35, 35, 35, 35, 35, 1, 1,\n-        1, 36, 37, 1, 1, 35, 35, 35,\n-        35, 35, 35, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 35, 35, 35,\n-        35, 35, 35, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        38, 1, 39, 39, 39, 39, 39, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 39, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 40,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 41, 1, 1,\n-        7, 7, 7, 7, 7, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 7,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 4, 1, 42, 42,\n-        42, 42, 42, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 42, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 43, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 44, 1, 42, 42, 42, 42, 42,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 42, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 1, 1, 1, 1,\n-        43, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 44, 1,\n-        47, 47, 47, 47, 47, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 47,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 48, 1, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 49, 46, 46, 50,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 51, 52, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 53, 46, 54, 54, 54,\n-        54, 54, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 54, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 55,\n-        1, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 56, 28, 28, 57, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        58, 59, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        60, 28, 61, 61, 61, 61, 61, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 61, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 62, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 63, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 64, 1, 65,\n-        65, 65, 65, 65, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 65, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 40, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 66, 1, 67, 67, 67, 67,\n-        67, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 67, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 48, 1,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        49, 46, 46, 50, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 51,\n-        52, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 53,\n-        46, 68, 68, 68, 68, 68, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        68, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 69, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        70, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 43, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 71, 1, 72, 72,\n-        72, 72, 72, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 72, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        73, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 74, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 75, 1, 72, 72, 72, 72, 72,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 72, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 73, 1, 1,\n-        1, 1, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 74,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 75, 1,\n-        68, 68, 68, 68, 68, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 68,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 69, 1, 1, 1, 1, 76,\n-        76, 76, 76, 76, 76, 76, 76, 76,\n-        76, 1, 1, 1, 1, 1, 1, 70,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 43, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 71, 1, 77, 77, 77,\n-        77, 77, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 77, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 78, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        79, 1, 77, 77, 77, 77, 77, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 77, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 33, 33, 33, 33, 33, 33, 33,\n-        33, 33, 33, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 78, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 79, 1, 61,\n-        61, 61, 61, 61, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 61, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 62, 1, 1, 1, 14, 14,\n-        14, 14, 14, 14, 14, 14, 14, 14,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 63, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 64, 1, 0\n-};\n-\n-static const char _deserialize_text_trans_targs[] = {\n-        1, 0, 2, 25, 3, 4, 19, 5,\n-        23, 24, 8, 27, 36, 27, 36, 30,\n-        33, 11, 12, 15, 12, 15, 13, 14,\n-        31, 32, 31, 32, 26, 18, 34, 35,\n-        34, 35, 20, 19, 6, 21, 22, 20,\n-        21, 22, 20, 21, 22, 24, 26, 26,\n-        7, 9, 10, 16, 21, 29, 26, 7,\n-        9, 10, 16, 21, 29, 28, 17, 21,\n-        29, 28, 29, 29, 28, 7, 10, 29,\n-        28, 7, 21, 29, 33, 28, 21, 29\n-};\n-\n-static const char _deserialize_text_trans_actions[] = {\n-        0, 0, 0, 0, 1, 0, 2, 0,\n-        2, 2, 3, 4, 4, 5, 5, 4,\n-        4, 3, 3, 3, 0, 0, 6, 3,\n-        4, 4, 5, 5, 5, 3, 4, 4,\n-        5, 5, 7, 8, 9, 7, 7, 0,\n-        0, 0, 10, 10, 10, 8, 12, 13,\n-        14, 14, 14, 15, 11, 11, 17, 18,\n-        18, 18, 0, 16, 16, 19, 20, 19,\n-        19, 0, 0, 13, 10, 21, 21, 10,\n-        22, 23, 22, 22, 5, 24, 24, 24\n-};\n-\n-static const char _deserialize_text_eof_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 7, 0, 0, 0, 10,\n-        10, 11, 16, 19, 0, 11, 10, 22,\n-        22, 10, 24, 24, 19\n-};\n-\n-static const int deserialize_text_start = 1;\n-static const int deserialize_text_first_final = 19;\n-static const int deserialize_text_error = 0;\n-\n-static const int deserialize_text_en_main = 1;\n-\n-\n-#line 114 \"hb-buffer-deserialize-text.rl\"\n-\n-\n-static hb_bool_t\n-_hb_buffer_deserialize_text (hb_buffer_t *buffer,\n-                                    const char *buf,\n-                                    unsigned int buf_len,\n-                                    const char **end_ptr,\n-                                    hb_font_t *font)\n-{\n-  const char *p = buf, *pe = buf + buf_len;\n-\n-  \/* Ensure we have positions. *\/\n-  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n-\n-  while (p < pe && ISSPACE (*p))\n-    p++;\n-\n-  const char *eof = pe, *tok = nullptr;\n-  int cs;\n-  hb_glyph_info_t info = {0};\n-  hb_glyph_position_t pos = {0};\n-\n-#line 428 \"hb-buffer-deserialize-text.hh\"\n-        {\n-        cs = deserialize_text_start;\n-        }\n-\n-#line 433 \"hb-buffer-deserialize-text.hh\"\n-        {\n-        int _slen;\n-        int _trans;\n-        const unsigned char *_keys;\n-        const char *_inds;\n-        if ( p == pe )\n-                goto _test_eof;\n-        if ( cs == 0 )\n-                goto _out;\n-_resume:\n-        _keys = _deserialize_text_trans_keys + (cs<<1);\n-        _inds = _deserialize_text_indicies + _deserialize_text_index_offsets[cs];\n-\n-        _slen = _deserialize_text_key_spans[cs];\n-        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n-                (*p) <= _keys[1] ?\n-                (*p) - _keys[0] : _slen ];\n-\n-        cs = _deserialize_text_trans_targs[_trans];\n-\n-        if ( _deserialize_text_trans_actions[_trans] == 0 )\n-                goto _again;\n-\n-        switch ( _deserialize_text_trans_actions[_trans] ) {\n-        case 1:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-        break;\n-        case 3:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-        break;\n-        case 5:\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 8:\n-#line 56 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n-        break;\n-        case 18:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-        break;\n-        case 9:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-        break;\n-        case 21:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-        break;\n-        case 6:\n-#line 69 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-        break;\n-        case 23:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-        break;\n-        case 20:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-        break;\n-        case 15:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-        break;\n-        case 4:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 2:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 56 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n-        break;\n-        case 16:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 7:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 10:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 22:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 19:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 24:\n-#line 72 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 12:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 14:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-        break;\n-        case 17:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 11:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 13:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-#line 722 \"hb-buffer-deserialize-text.hh\"\n-        }\n-\n-_again:\n-        if ( cs == 0 )\n-                goto _out;\n-        if ( ++p != pe )\n-                goto _resume;\n-        _test_eof: {}\n-        if ( p == eof )\n-        {\n-        switch ( _deserialize_text_eof_actions[cs] ) {\n-        case 16:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 7:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 10:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 22:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 19:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 24:\n-#line 72 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 11:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-#line 839 \"hb-buffer-deserialize-text.hh\"\n-        }\n-        }\n-\n-        _out: {}\n-        }\n-\n-#line 138 \"hb-buffer-deserialize-text.rl\"\n-\n-\n-  *end_ptr = p;\n-\n-  return p == pe && *(p-1) != ']';\n-}\n-\n-#endif \/* HB_BUFFER_DESERIALIZE_TEXT_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text.hh","additions":0,"deletions":853,"binary":false,"changes":853,"status":"deleted"},{"patch":"@@ -1,290 +0,0 @@\n-\/*\n- * Copyright Â© 2009  Red Hat, Inc.\n- * Copyright Â© 2009  Keith Stribley\n- * Copyright Â© 2011  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Red Hat Author(s): Behdad Esfahbod\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifdef HAVE_ICU\n-\n-#include \"hb-icu.h\"\n-\n-#include \"hb-machinery.hh\"\n-\n-#include <unicode\/uchar.h>\n-#include <unicode\/unorm2.h>\n-#include <unicode\/ustring.h>\n-#include <unicode\/utf16.h>\n-#include <unicode\/uversion.h>\n-\n-\/* ICU extra semicolon, fixed since 65, https:\/\/github.com\/unicode-org\/icu\/commit\/480bec3 *\/\n-#if U_ICU_VERSION_MAJOR_NUM < 65 && (defined(__GNUC__) || defined(__clang__))\n-#define HB_ICU_EXTRA_SEMI_IGNORED\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wextra-semi-stmt\"\n-#endif\n-\n-\/**\n- * SECTION:hb-icu\n- * @title: hb-icu\n- * @short_description: ICU integration\n- * @include: hb-icu.h\n- *\n- * Functions for using HarfBuzz with the International Components for Unicode\n- * (ICU) library. HarfBuzz supports using ICU to provide Unicode data, by attaching\n- * ICU functions to the virtual methods in a #hb_unicode_funcs_t function\n- * structure.\n- **\/\n-\n-\/**\n- * hb_icu_script_to_script:\n- * @script: The UScriptCode identifier to query\n- *\n- * Fetches the #hb_script_t script that corresponds to the\n- * specified UScriptCode identifier.\n- *\n- * Return value: the #hb_script_t script found\n- *\n- **\/\n-\n-hb_script_t\n-hb_icu_script_to_script (UScriptCode script)\n-{\n-  if (unlikely (script == USCRIPT_INVALID_CODE))\n-    return HB_SCRIPT_INVALID;\n-\n-  return hb_script_from_string (uscript_getShortName (script), -1);\n-}\n-\n-\/**\n- * hb_icu_script_from_script:\n- * @script: The #hb_script_t script to query\n- *\n- * Fetches the UScriptCode identifier that corresponds to the\n- * specified #hb_script_t script.\n- *\n- * Return value: the UScriptCode identifier found\n- *\n- **\/\n-UScriptCode\n-hb_icu_script_from_script (hb_script_t script)\n-{\n-  if (unlikely (script == HB_SCRIPT_INVALID))\n-    return USCRIPT_INVALID_CODE;\n-\n-  unsigned int numScriptCode = 1 + u_getIntPropertyMaxValue (UCHAR_SCRIPT);\n-  for (unsigned int i = 0; i < numScriptCode; i++)\n-    if (unlikely (hb_icu_script_to_script ((UScriptCode) i) == script))\n-      return (UScriptCode) i;\n-\n-  return USCRIPT_UNKNOWN;\n-}\n-\n-\n-static hb_unicode_combining_class_t\n-hb_icu_unicode_combining_class (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                                hb_codepoint_t      unicode,\n-                                void               *user_data HB_UNUSED)\n-\n-{\n-  return (hb_unicode_combining_class_t) u_getCombiningClass (unicode);\n-}\n-\n-static hb_unicode_general_category_t\n-hb_icu_unicode_general_category (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                                 hb_codepoint_t      unicode,\n-                                 void               *user_data HB_UNUSED)\n-{\n-  switch (u_getIntPropertyValue(unicode, UCHAR_GENERAL_CATEGORY))\n-  {\n-  case U_UNASSIGNED:                    return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;\n-\n-  case U_UPPERCASE_LETTER:              return HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER;\n-  case U_LOWERCASE_LETTER:              return HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER;\n-  case U_TITLECASE_LETTER:              return HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER;\n-  case U_MODIFIER_LETTER:               return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER;\n-  case U_OTHER_LETTER:                  return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER;\n-\n-  case U_NON_SPACING_MARK:              return HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK;\n-  case U_ENCLOSING_MARK:                return HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK;\n-  case U_COMBINING_SPACING_MARK:        return HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK;\n-\n-  case U_DECIMAL_DIGIT_NUMBER:          return HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER;\n-  case U_LETTER_NUMBER:                 return HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER;\n-  case U_OTHER_NUMBER:                  return HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER;\n-\n-  case U_SPACE_SEPARATOR:               return HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR;\n-  case U_LINE_SEPARATOR:                return HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR;\n-  case U_PARAGRAPH_SEPARATOR:           return HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR;\n-\n-  case U_CONTROL_CHAR:                  return HB_UNICODE_GENERAL_CATEGORY_CONTROL;\n-  case U_FORMAT_CHAR:                   return HB_UNICODE_GENERAL_CATEGORY_FORMAT;\n-  case U_PRIVATE_USE_CHAR:              return HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE;\n-  case U_SURROGATE:                     return HB_UNICODE_GENERAL_CATEGORY_SURROGATE;\n-\n-\n-  case U_DASH_PUNCTUATION:              return HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION;\n-  case U_START_PUNCTUATION:             return HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION;\n-  case U_END_PUNCTUATION:               return HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION;\n-  case U_CONNECTOR_PUNCTUATION:         return HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION;\n-  case U_OTHER_PUNCTUATION:             return HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION;\n-\n-  case U_MATH_SYMBOL:                   return HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL;\n-  case U_CURRENCY_SYMBOL:               return HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL;\n-  case U_MODIFIER_SYMBOL:               return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL;\n-  case U_OTHER_SYMBOL:                  return HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL;\n-\n-  case U_INITIAL_PUNCTUATION:           return HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION;\n-  case U_FINAL_PUNCTUATION:             return HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION;\n-  }\n-\n-  return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;\n-}\n-\n-static hb_codepoint_t\n-hb_icu_unicode_mirroring (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                          hb_codepoint_t      unicode,\n-                          void               *user_data HB_UNUSED)\n-{\n-  return u_charMirror(unicode);\n-}\n-\n-static hb_script_t\n-hb_icu_unicode_script (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                       hb_codepoint_t      unicode,\n-                       void               *user_data HB_UNUSED)\n-{\n-  UErrorCode status = U_ZERO_ERROR;\n-  UScriptCode scriptCode = uscript_getScript(unicode, &status);\n-\n-  if (unlikely (U_FAILURE (status)))\n-    return HB_SCRIPT_UNKNOWN;\n-\n-  return hb_icu_script_to_script (scriptCode);\n-}\n-\n-static hb_bool_t\n-hb_icu_unicode_compose (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                        hb_codepoint_t      a,\n-                        hb_codepoint_t      b,\n-                        hb_codepoint_t     *ab,\n-                        void               *user_data)\n-{\n-  const UNormalizer2 *normalizer = (const UNormalizer2 *) user_data;\n-  UChar32 ret = unorm2_composePair (normalizer, a, b);\n-  if (ret < 0) return false;\n-  *ab = ret;\n-  return true;\n-}\n-\n-static hb_bool_t\n-hb_icu_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED,\n-                          hb_codepoint_t      ab,\n-                          hb_codepoint_t     *a,\n-                          hb_codepoint_t     *b,\n-                          void               *user_data)\n-{\n-  const UNormalizer2 *normalizer = (const UNormalizer2 *) user_data;\n-  UChar decomposed[4];\n-  int len;\n-  UErrorCode icu_err = U_ZERO_ERROR;\n-  len = unorm2_getRawDecomposition (normalizer, ab, decomposed,\n-                                    ARRAY_LENGTH (decomposed), &icu_err);\n-  if (U_FAILURE (icu_err) || len < 0) return false;\n-\n-  len = u_countChar32 (decomposed, len);\n-  if (len == 1)\n-  {\n-    U16_GET_UNSAFE (decomposed, 0, *a);\n-    *b = 0;\n-    return *a != ab;\n-  }\n-  else if (len == 2)\n-  {\n-    len = 0;\n-    U16_NEXT_UNSAFE (decomposed, len, *a);\n-    U16_NEXT_UNSAFE (decomposed, len, *b);\n-  }\n-  return true;\n-}\n-\n-\n-static inline void free_static_icu_funcs ();\n-\n-static struct hb_icu_unicode_funcs_lazy_loader_t : hb_unicode_funcs_lazy_loader_t<hb_icu_unicode_funcs_lazy_loader_t>\n-{\n-  static hb_unicode_funcs_t *create ()\n-  {\n-    void *user_data = nullptr;\n-    UErrorCode icu_err = U_ZERO_ERROR;\n-    user_data = (void *) unorm2_getNFCInstance (&icu_err);\n-    assert (user_data);\n-\n-    hb_unicode_funcs_t *funcs = hb_unicode_funcs_create (nullptr);\n-\n-    hb_unicode_funcs_set_combining_class_func (funcs, hb_icu_unicode_combining_class, nullptr, nullptr);\n-    hb_unicode_funcs_set_general_category_func (funcs, hb_icu_unicode_general_category, nullptr, nullptr);\n-    hb_unicode_funcs_set_mirroring_func (funcs, hb_icu_unicode_mirroring, nullptr, nullptr);\n-    hb_unicode_funcs_set_script_func (funcs, hb_icu_unicode_script, nullptr, nullptr);\n-    hb_unicode_funcs_set_compose_func (funcs, hb_icu_unicode_compose, user_data, nullptr);\n-    hb_unicode_funcs_set_decompose_func (funcs, hb_icu_unicode_decompose, user_data, nullptr);\n-\n-    hb_unicode_funcs_make_immutable (funcs);\n-\n-    hb_atexit (free_static_icu_funcs);\n-\n-    return funcs;\n-  }\n-} static_icu_funcs;\n-\n-static inline\n-void free_static_icu_funcs ()\n-{\n-  static_icu_funcs.free_instance ();\n-}\n-\n-\/**\n- * hb_icu_get_unicode_funcs:\n- *\n- * Fetches a Unicode-functions structure that is populated\n- * with the appropriate ICU function for each method.\n- *\n- * Return value: (transfer none): a pointer to the #hb_unicode_funcs_t Unicode-functions structure\n- *\n- * Since: 0.9.38\n- **\/\n-hb_unicode_funcs_t *\n-hb_icu_get_unicode_funcs ()\n-{\n-  return static_icu_funcs.get_unconst ();\n-}\n-\n-#ifdef HB_ICU_EXTRA_SEMI_IGNORED\n-#pragma GCC diagnostic pop\n-#endif\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-icu.cc","additions":0,"deletions":290,"binary":false,"changes":290,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright Â© 2009  Red Hat, Inc.\n- * Copyright Â© 2011  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Red Hat Author(s): Behdad Esfahbod\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_ICU_H\n-#define HB_ICU_H\n-\n-#include \"hb.h\"\n-\n-#include <unicode\/uscript.h>\n-\n-HB_BEGIN_DECLS\n-\n-\n-HB_EXTERN hb_script_t\n-hb_icu_script_to_script (UScriptCode script);\n-\n-HB_EXTERN UScriptCode\n-hb_icu_script_from_script (hb_script_t script);\n-\n-\n-HB_EXTERN hb_unicode_funcs_t *\n-hb_icu_get_unicode_funcs (void);\n-\n-\n-HB_END_DECLS\n-\n-#endif \/* HB_ICU_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-icu.h","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright Â© 2011,2012,2013  Google, Inc.\n- * Copyright Â© 2021  Khaled Hosny\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_MS_FEATURE_RANGES_HH\n-#define HB_MS_FEATURE_RANGES_HH\n-\n-#include \"hb.hh\"\n-\n-\/* Variations of this code exist in hb-coretext.cc as well\n- * as hb-aat-map.cc... *\/\n-\n-typedef struct hb_ms_feature_t {\n-  uint32_t tag_le;\n-  uint32_t value;\n-} hb_ms_feature_t;\n-\n-typedef struct hb_ms_features_t {\n-  hb_ms_feature_t *features;\n-  uint32_t         num_features;\n-} hb_ms_features_t;\n-\n-struct hb_ms_active_feature_t {\n-  hb_ms_feature_t fea;\n-  unsigned int order;\n-\n-  HB_INTERNAL static int cmp (const void *pa, const void *pb) {\n-    const auto *a = (const hb_ms_active_feature_t *) pa;\n-    const auto *b = (const hb_ms_active_feature_t *) pb;\n-    return a->fea.tag_le < b->fea.tag_le ? -1 : a->fea.tag_le > b->fea.tag_le ? 1 :\n-           a->order < b->order ? -1 : a->order > b->order ? 1 :\n-           a->fea.value < b->fea.value ? -1 : a->fea.value > b->fea.value ? 1 :\n-           0;\n-  }\n-  bool operator== (const hb_ms_active_feature_t& f) const\n-  { return cmp (this, &f) == 0; }\n-};\n-\n-struct hb_ms_feature_event_t {\n-  unsigned int index;\n-  bool start;\n-  hb_ms_active_feature_t feature;\n-\n-  HB_INTERNAL static int cmp (const void *pa, const void *pb)\n-  {\n-    const auto *a = (const hb_ms_feature_event_t *) pa;\n-    const auto *b = (const hb_ms_feature_event_t *) pb;\n-    return a->index < b->index ? -1 : a->index > b->index ? 1 :\n-           a->start < b->start ? -1 : a->start > b->start ? 1 :\n-           hb_ms_active_feature_t::cmp (&a->feature, &b->feature);\n-  }\n-};\n-\n-struct hb_ms_range_record_t {\n-  hb_ms_features_t features;\n-  unsigned int index_first; \/* == start *\/\n-  unsigned int index_last;  \/* == end - 1 *\/\n-};\n-\n-static inline bool\n-hb_ms_setup_features (const hb_feature_t                *features,\n-                      unsigned int                       num_features,\n-                      hb_vector_t<hb_ms_feature_t>      &feature_records, \/* OUT *\/\n-                      hb_vector_t<hb_ms_range_record_t> &range_records \/* OUT *\/)\n-{\n-  feature_records.shrink(0);\n-  range_records.shrink(0);\n-\n-  \/* Sort features by start\/end events. *\/\n-  hb_vector_t<hb_ms_feature_event_t> feature_events;\n-  for (unsigned int i = 0; i < num_features; i++)\n-  {\n-    hb_ms_active_feature_t feature;\n-    feature.fea.tag_le = hb_uint32_swap (features[i].tag);\n-    feature.fea.value = features[i].value;\n-    feature.order = i;\n-\n-    hb_ms_feature_event_t *event;\n-\n-    event = feature_events.push ();\n-    event->index = features[i].start;\n-    event->start = true;\n-    event->feature = feature;\n-\n-    event = feature_events.push ();\n-    event->index = features[i].end;\n-    event->start = false;\n-    event->feature = feature;\n-  }\n-  feature_events.qsort ();\n-  \/* Add a strategic final event. *\/\n-  {\n-    hb_ms_active_feature_t feature;\n-    feature.fea.tag_le = 0;\n-    feature.fea.value = 0;\n-    feature.order = num_features + 1;\n-\n-    auto *event = feature_events.push ();\n-    event->index = 0; \/* This value does magic. *\/\n-    event->start = false;\n-    event->feature = feature;\n-  }\n-\n-  \/* Scan events and save features for each range. *\/\n-  hb_vector_t<hb_ms_active_feature_t> active_features;\n-  unsigned int last_index = 0;\n-  for (unsigned int i = 0; i < feature_events.length; i++)\n-  {\n-    auto *event = &feature_events[i];\n-\n-    if (event->index != last_index)\n-    {\n-      \/* Save a snapshot of active features and the range. *\/\n-      auto *range = range_records.push ();\n-      auto offset = feature_records.length;\n-\n-      active_features.qsort ();\n-      for (unsigned int j = 0; j < active_features.length; j++)\n-      {\n-        if (!j || active_features[j].fea.tag_le != feature_records[feature_records.length - 1].tag_le)\n-        {\n-          feature_records.push (active_features[j].fea);\n-        }\n-        else\n-        {\n-          \/* Overrides value for existing feature. *\/\n-          feature_records[feature_records.length - 1].value = active_features[j].fea.value;\n-        }\n-      }\n-\n-      \/* Will convert to pointer after all is ready, since feature_records.array\n-       * may move as we grow it. *\/\n-      range->features.features = reinterpret_cast<hb_ms_feature_t *> (offset);\n-      range->features.num_features = feature_records.length - offset;\n-      range->index_first = last_index;\n-      range->index_last  = event->index - 1;\n-\n-      last_index = event->index;\n-    }\n-\n-    if (event->start)\n-    {\n-      active_features.push (event->feature);\n-    }\n-    else\n-    {\n-      auto *feature = active_features.lsearch (event->feature);\n-      if (feature)\n-        active_features.remove_ordered (feature - active_features.arrayZ);\n-    }\n-  }\n-\n-  if (!range_records.length) \/* No active feature found. *\/\n-    num_features = 0;\n-\n-  \/* Fixup the pointers. *\/\n-  for (unsigned int i = 0; i < range_records.length; i++)\n-  {\n-    auto *range = &range_records[i];\n-    range->features.features = (hb_ms_feature_t *) feature_records + reinterpret_cast<uintptr_t> (range->features.features);\n-  }\n-\n-  return !!num_features;\n-}\n-\n-static inline void\n-hb_ms_make_feature_ranges (hb_vector_t<hb_ms_feature_t>      &feature_records,\n-                           hb_vector_t<hb_ms_range_record_t> &range_records,\n-                           unsigned int                       chars_offset,\n-                           unsigned int                       chars_len,\n-                           uint16_t                          *log_clusters,\n-                           hb_vector_t<hb_ms_features_t*>    &range_features, \/* OUT *\/\n-                           hb_vector_t<uint32_t>             &range_counts \/* OUT *\/)\n-{\n-  range_features.shrink (0);\n-  range_counts.shrink (0);\n-\n-  auto *last_range = &range_records[0];\n-  for (unsigned int i = chars_offset; i < chars_len; i++)\n-  {\n-    auto *range = last_range;\n-    while (log_clusters[i] < range->index_first)\n-      range--;\n-    while (log_clusters[i] > range->index_last)\n-      range++;\n-    if (!range_features.length ||\n-        &range->features != range_features[range_features.length - 1])\n-    {\n-      auto **features = range_features.push ();\n-      auto *c = range_counts.push ();\n-      if (unlikely (!features || !c))\n-      {\n-        range_features.shrink (0);\n-        range_counts.shrink (0);\n-        break;\n-      }\n-      *features = &range->features;\n-      *c = 1;\n-    }\n-    else\n-    {\n-      range_counts[range_counts.length - 1]++;\n-    }\n-\n-    last_range = range;\n-  }\n-}\n-\n-#endif \/* HB_MS_FEATURE_RANGES_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ms-feature-ranges.hh","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,997 +0,0 @@\n-\/*\n- * Copyright Â© 2016  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Seigo Nonaka, Calder Kitagawa\n- *\/\n-\n-#ifndef HB_OT_COLOR_CBDT_TABLE_HH\n-#define HB_OT_COLOR_CBDT_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-\n-\/*\n- * CBLC -- Color Bitmap Location\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cblc\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/eblc\n- * CBDT -- Color Bitmap Data\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cbdt\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/ebdt\n- *\/\n-#define HB_OT_TAG_CBLC HB_TAG('C','B','L','C')\n-#define HB_OT_TAG_CBDT HB_TAG('C','B','D','T')\n-\n-\n-namespace OT {\n-\n-struct cblc_bitmap_size_subset_context_t\n-{\n-  const char *cbdt;\n-  unsigned int cbdt_length;\n-  hb_vector_t<char> *cbdt_prime;\n-  unsigned int size;            \/* INOUT\n-                                 *  Input: old size of IndexSubtable\n-                                 *  Output: new size of IndexSubtable\n-                                 *\/\n-  unsigned int num_tables;      \/* INOUT\n-                                 *  Input: old number of subtables.\n-                                 *  Output: new number of subtables.\n-                                 *\/\n-  hb_codepoint_t start_glyph;   \/* OUT *\/\n-  hb_codepoint_t end_glyph;     \/* OUT *\/\n-};\n-\n-static inline bool\n-_copy_data_to_cbdt (hb_vector_t<char> *cbdt_prime,\n-                    const void        *data,\n-                    unsigned           length)\n-{\n-  unsigned int new_len = cbdt_prime->length + length;\n-  if (unlikely (!cbdt_prime->alloc (new_len))) return false;\n-  memcpy (cbdt_prime->arrayZ + cbdt_prime->length, data, length);\n-  cbdt_prime->length = new_len;\n-  return true;\n-}\n-\n-struct SmallGlyphMetrics\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  void get_extents (hb_font_t *font, hb_glyph_extents_t *extents) const\n-  {\n-    extents->x_bearing = font->em_scale_x (bearingX);\n-    extents->y_bearing = font->em_scale_y (bearingY);\n-    extents->width = font->em_scale_x (width);\n-    extents->height = font->em_scale_y (-static_cast<int>(height));\n-  }\n-\n-  HBUINT8       height;\n-  HBUINT8       width;\n-  HBINT8        bearingX;\n-  HBINT8        bearingY;\n-  HBUINT8       advance;\n-  public:\n-  DEFINE_SIZE_STATIC (5);\n-};\n-\n-struct BigGlyphMetrics : SmallGlyphMetrics\n-{\n-  HBINT8        vertBearingX;\n-  HBINT8        vertBearingY;\n-  HBUINT8       vertAdvance;\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-struct SBitLineMetrics\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBINT8        ascender;\n-  HBINT8        decender;\n-  HBUINT8       widthMax;\n-  HBINT8        caretSlopeNumerator;\n-  HBINT8        caretSlopeDenominator;\n-  HBINT8        caretOffset;\n-  HBINT8        minOriginSB;\n-  HBINT8        minAdvanceSB;\n-  HBINT8        maxBeforeBL;\n-  HBINT8        minAfterBL;\n-  HBINT8        padding1;\n-  HBINT8        padding2;\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-\n-\/*\n- * Index Subtables.\n- *\/\n-\n-struct IndexSubtableHeader\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT16      indexFormat;\n-  HBUINT16      imageFormat;\n-  HBUINT32      imageDataOffset;\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-template <typename OffsetType>\n-struct IndexSubtableFormat1Or3\n-{\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  offsetArrayZ.sanitize (c, glyph_count + 1));\n-  }\n-\n-  bool get_image_data (unsigned int idx,\n-                       unsigned int *offset,\n-                       unsigned int *length) const\n-  {\n-    if (unlikely (offsetArrayZ[idx + 1] <= offsetArrayZ[idx]))\n-      return false;\n-\n-    *offset = header.imageDataOffset + offsetArrayZ[idx];\n-    *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];\n-    return true;\n-  }\n-\n-  bool add_offset (hb_serialize_context_t *c,\n-                   unsigned int offset,\n-                   unsigned int *size \/* OUT (accumulated) *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    Offset<OffsetType> embedded_offset;\n-    embedded_offset = offset;\n-    *size += sizeof (OffsetType);\n-    auto *o = c->embed (embedded_offset);\n-    return_trace ((bool) o);\n-  }\n-\n-  IndexSubtableHeader   header;\n-  UnsizedArrayOf<Offset<OffsetType>>\n-                        offsetArrayZ;\n-  public:\n-  DEFINE_SIZE_ARRAY (8, offsetArrayZ);\n-};\n-\n-struct IndexSubtableFormat1 : IndexSubtableFormat1Or3<HBUINT32> {};\n-struct IndexSubtableFormat3 : IndexSubtableFormat1Or3<HBUINT16> {};\n-\n-struct IndexSubtable\n-{\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!u.header.sanitize (c)) return_trace (false);\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: return_trace (u.format1.sanitize (c, glyph_count));\n-    case 3: return_trace (u.format3.sanitize (c, glyph_count));\n-    default:return_trace (true);\n-    }\n-  }\n-\n-  bool\n-  finish_subtable (hb_serialize_context_t *c,\n-                   unsigned int cbdt_prime_len,\n-                   unsigned int num_glyphs,\n-                   unsigned int *size \/* OUT (accumulated) *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    unsigned int local_offset = cbdt_prime_len - u.header.imageDataOffset;\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: return_trace (u.format1.add_offset (c, local_offset, size));\n-    case 3: {\n-      if (!u.format3.add_offset (c, local_offset, size))\n-        return_trace (false);\n-      if (!(num_glyphs & 0x01))  \/\/ Pad to 32-bit alignment if needed.\n-        return_trace (u.format3.add_offset (c, 0, size));\n-      return_trace (true);\n-    }\n-    \/\/ TODO: implement 2, 4, 5.\n-    case 2: case 4:  \/\/ No-op.\n-    case 5:  \/\/ Pad to 32-bit aligned.\n-    default: return_trace (false);\n-    }\n-  }\n-\n-  bool\n-  fill_missing_glyphs (hb_serialize_context_t *c,\n-                       unsigned int cbdt_prime_len,\n-                       unsigned int num_missing,\n-                       unsigned int *size \/* OUT (accumulated) *\/,\n-                       unsigned int *num_glyphs \/* OUT (accumulated) *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    unsigned int local_offset = cbdt_prime_len - u.header.imageDataOffset;\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: {\n-      for (unsigned int i = 0; i < num_missing; i++)\n-      {\n-        if (unlikely (!u.format1.add_offset (c, local_offset, size)))\n-          return_trace (false);\n-        *num_glyphs += 1;\n-      }\n-      return_trace (true);\n-    }\n-    case 3: {\n-      for (unsigned int i = 0; i < num_missing; i++)\n-      {\n-        if (unlikely (!u.format3.add_offset (c, local_offset, size)))\n-          return_trace (false);\n-        *num_glyphs += 1;\n-      }\n-      return_trace (true);\n-    }\n-    \/\/ TODO: implement 2, 4, 5.\n-    case 2:  \/\/ Add empty space in cbdt_prime?.\n-    case 4: case 5:  \/\/ No-op as sparse is supported.\n-    default: return_trace (false);\n-    }\n-  }\n-\n-  bool\n-  copy_glyph_at_idx (hb_serialize_context_t *c, unsigned int idx,\n-                     const char *cbdt, unsigned int cbdt_length,\n-                     hb_vector_t<char> *cbdt_prime \/* INOUT *\/,\n-                     IndexSubtable *subtable_prime \/* INOUT *\/,\n-                     unsigned int *size \/* OUT (accumulated) *\/) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    unsigned int offset, length, format;\n-    if (unlikely (!get_image_data (idx, &offset, &length, &format))) return_trace (false);\n-    if (unlikely (offset > cbdt_length || cbdt_length - offset < length)) return_trace (false);\n-\n-    auto *header_prime = subtable_prime->get_header ();\n-    unsigned int new_local_offset = cbdt_prime->length - (unsigned int) header_prime->imageDataOffset;\n-    if (unlikely (!_copy_data_to_cbdt (cbdt_prime, cbdt + offset, length))) return_trace (false);\n-\n-    return_trace (subtable_prime->add_offset (c, new_local_offset, size));\n-  }\n-\n-  bool\n-  add_offset (hb_serialize_context_t *c, unsigned int local_offset,\n-              unsigned int *size \/* OUT (accumulated) *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: return_trace (u.format1.add_offset (c, local_offset, size));\n-    case 3: return_trace (u.format3.add_offset (c, local_offset, size));\n-    \/\/ TODO: Implement tables 2, 4, 5\n-    case 2:  \/\/ Should be a no-op.\n-    case 4: case 5:  \/\/ Handle sparse cases.\n-    default: return_trace (false);\n-    }\n-  }\n-\n-  bool get_extents (hb_glyph_extents_t *extents HB_UNUSED) const\n-  {\n-    switch (u.header.indexFormat)\n-    {\n-    case 2: case 5: \/* TODO *\/\n-    case 1: case 3: case 4: \/* Variable-metrics formats do not have metrics here. *\/\n-    default:return (false);\n-    }\n-  }\n-\n-  bool\n-  get_image_data (unsigned int idx, unsigned int *offset,\n-                  unsigned int *length, unsigned int *format) const\n-  {\n-    *format = u.header.imageFormat;\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: return u.format1.get_image_data (idx, offset, length);\n-    case 3: return u.format3.get_image_data (idx, offset, length);\n-    default: return false;\n-    }\n-  }\n-\n-  const IndexSubtableHeader* get_header () const { return &u.header; }\n-\n-  void populate_header (unsigned index_format,\n-                        unsigned image_format,\n-                        unsigned int image_data_offset,\n-                        unsigned int *size)\n-  {\n-    u.header.indexFormat = index_format;\n-    u.header.imageFormat = image_format;\n-    u.header.imageDataOffset = image_data_offset;\n-    switch (u.header.indexFormat)\n-    {\n-    case 1: *size += IndexSubtableFormat1::min_size; break;\n-    case 3: *size += IndexSubtableFormat3::min_size; break;\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  IndexSubtableHeader   header;\n-  IndexSubtableFormat1  format1;\n-  IndexSubtableFormat3  format3;\n-  \/* TODO: Format 2, 4, 5. *\/\n-  } u;\n-  public:\n-  DEFINE_SIZE_UNION (8, header);\n-};\n-\n-struct IndexSubtableRecord\n-{\n-  \/* XXX Remove this and fix by not inserting it into vector. *\/\n-  IndexSubtableRecord& operator = (const IndexSubtableRecord &o)\n-  {\n-    firstGlyphIndex = o.firstGlyphIndex;\n-    lastGlyphIndex = o.lastGlyphIndex;\n-    offsetToSubtable = (unsigned) o.offsetToSubtable;\n-    assert (offsetToSubtable.is_null ());\n-    return *this;\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  firstGlyphIndex <= lastGlyphIndex &&\n-                  offsetToSubtable.sanitize (c, base, lastGlyphIndex - firstGlyphIndex + 1));\n-  }\n-\n-  const IndexSubtable* get_subtable (const void *base) const\n-  {\n-    return &(base+offsetToSubtable);\n-  }\n-\n-  bool add_new_subtable (hb_subset_context_t* c,\n-                         cblc_bitmap_size_subset_context_t *bitmap_size_context,\n-                         IndexSubtableRecord *record,\n-                         const hb_vector_t<hb_pair_t<hb_codepoint_t, const IndexSubtableRecord*>> *lookup, \/* IN *\/\n-                         const void *base,\n-                         unsigned int *start \/* INOUT *\/) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    auto *subtable = c->serializer->start_embed<IndexSubtable> ();\n-    if (unlikely (!subtable)) return_trace (false);\n-    if (unlikely (!c->serializer->extend_min (subtable))) return_trace (false);\n-\n-    auto *old_subtable = get_subtable (base);\n-    auto *old_header = old_subtable->get_header ();\n-\n-    subtable->populate_header (old_header->indexFormat,\n-                               old_header->imageFormat,\n-                               bitmap_size_context->cbdt_prime->length,\n-                               &bitmap_size_context->size);\n-\n-    unsigned int num_glyphs = 0;\n-    bool early_exit = false;\n-    for (unsigned int i = *start; i < lookup->length; i++)\n-    {\n-      hb_codepoint_t new_gid = (*lookup)[i].first;\n-      const IndexSubtableRecord *next_record = (*lookup)[i].second;\n-      const IndexSubtable *next_subtable = next_record->get_subtable (base);\n-      auto *next_header = next_subtable->get_header ();\n-      if (next_header != old_header)\n-      {\n-        *start = i;\n-        early_exit = true;\n-        break;\n-      }\n-      unsigned int num_missing = record->add_glyph_for_subset (new_gid);\n-      if (unlikely (!subtable->fill_missing_glyphs (c->serializer,\n-                                                    bitmap_size_context->cbdt_prime->length,\n-                                                    num_missing,\n-                                                    &bitmap_size_context->size,\n-                                                    &num_glyphs)))\n-        return_trace (false);\n-\n-      hb_codepoint_t old_gid = 0;\n-      c->plan->old_gid_for_new_gid (new_gid, &old_gid);\n-      if (old_gid < next_record->firstGlyphIndex)\n-        return_trace (false);\n-\n-      unsigned int old_idx = (unsigned int) old_gid - next_record->firstGlyphIndex;\n-      if (unlikely (!next_subtable->copy_glyph_at_idx (c->serializer,\n-                                                       old_idx,\n-                                                       bitmap_size_context->cbdt,\n-                                                       bitmap_size_context->cbdt_length,\n-                                                       bitmap_size_context->cbdt_prime,\n-                                                       subtable,\n-                                                       &bitmap_size_context->size)))\n-        return_trace (false);\n-      num_glyphs += 1;\n-    }\n-    if (!early_exit)\n-      *start = lookup->length;\n-    if (unlikely (!subtable->finish_subtable (c->serializer,\n-                                              bitmap_size_context->cbdt_prime->length,\n-                                              num_glyphs,\n-                                              &bitmap_size_context->size)))\n-      return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  bool add_new_record (hb_subset_context_t *c,\n-                       cblc_bitmap_size_subset_context_t *bitmap_size_context,\n-                       const hb_vector_t<hb_pair_t<hb_codepoint_t, const IndexSubtableRecord*>> *lookup, \/* IN *\/\n-                       const void *base,\n-                       unsigned int *start, \/* INOUT *\/\n-                       hb_vector_t<IndexSubtableRecord>* records \/* INOUT *\/) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto snap = c->serializer->snapshot ();\n-    unsigned int old_size = bitmap_size_context->size;\n-    unsigned int old_cbdt_prime_length = bitmap_size_context->cbdt_prime->length;\n-\n-    \/\/ Set to invalid state to indicate filling glyphs is not yet started.\n-    if (unlikely (!c->serializer->check_success (records->resize (records->length + 1))))\n-      return_trace (false);\n-\n-    (*records)[records->length - 1].firstGlyphIndex = 1;\n-    (*records)[records->length - 1].lastGlyphIndex = 0;\n-    bitmap_size_context->size += IndexSubtableRecord::min_size;\n-\n-    c->serializer->push ();\n-\n-    if (unlikely (!add_new_subtable (c, bitmap_size_context, &((*records)[records->length - 1]), lookup, base, start)))\n-    {\n-      c->serializer->pop_discard ();\n-      c->serializer->revert (snap);\n-      bitmap_size_context->cbdt_prime->shrink (old_cbdt_prime_length);\n-      bitmap_size_context->size = old_size;\n-      records->resize (records->length - 1);\n-      return_trace (false);\n-    }\n-\n-    bitmap_size_context->num_tables += 1;\n-    return_trace (true);\n-  }\n-\n-  unsigned int add_glyph_for_subset (hb_codepoint_t gid)\n-  {\n-    if (firstGlyphIndex > lastGlyphIndex)\n-    {\n-      firstGlyphIndex = gid;\n-      lastGlyphIndex = gid;\n-      return 0;\n-    }\n-    \/\/ TODO maybe assert? this shouldn't occur.\n-    if (lastGlyphIndex > gid)\n-      return 0;\n-    unsigned int num_missing = (unsigned int) (gid - lastGlyphIndex - 1);\n-    lastGlyphIndex = gid;\n-    return num_missing;\n-  }\n-\n-  bool get_extents (hb_glyph_extents_t *extents, const void *base) const\n-  { return (base+offsetToSubtable).get_extents (extents); }\n-\n-  bool get_image_data (unsigned int  gid,\n-                       const void   *base,\n-                       unsigned int *offset,\n-                       unsigned int *length,\n-                       unsigned int *format) const\n-  {\n-    if (gid < firstGlyphIndex || gid > lastGlyphIndex) return false;\n-    return (base+offsetToSubtable).get_image_data (gid - firstGlyphIndex,\n-                                                   offset, length, format);\n-  }\n-\n-  HBGlyphID16                   firstGlyphIndex;\n-  HBGlyphID16                   lastGlyphIndex;\n-  Offset32To<IndexSubtable>     offsetToSubtable;\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-struct IndexSubtableArray\n-{\n-  friend struct CBDT;\n-\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (indexSubtablesZ.sanitize (c, count, this));\n-  }\n-\n-  void\n-  build_lookup (hb_subset_context_t *c, cblc_bitmap_size_subset_context_t *bitmap_size_context,\n-                hb_vector_t<hb_pair_t<hb_codepoint_t,\n-                const IndexSubtableRecord*>> *lookup \/* OUT *\/) const\n-  {\n-    bool start_glyph_is_set = false;\n-    for (hb_codepoint_t new_gid = 0; new_gid < c->plan->num_output_glyphs (); new_gid++)\n-    {\n-      hb_codepoint_t old_gid;\n-      if (unlikely (!c->plan->old_gid_for_new_gid (new_gid, &old_gid))) continue;\n-\n-      const IndexSubtableRecord* record = find_table (old_gid, bitmap_size_context->num_tables);\n-      if (unlikely (!record)) continue;\n-\n-      \/\/ Don't add gaps to the lookup. The best way to determine if a glyph is a\n-      \/\/ gap is that it has no image data.\n-      unsigned int offset, length, format;\n-      if (unlikely (!record->get_image_data (old_gid, this, &offset, &length, &format))) continue;\n-\n-      lookup->push (hb_pair_t<hb_codepoint_t, const IndexSubtableRecord*> (new_gid, record));\n-\n-      if (!start_glyph_is_set)\n-      {\n-        bitmap_size_context->start_glyph = new_gid;\n-        start_glyph_is_set = true;\n-      }\n-\n-      bitmap_size_context->end_glyph = new_gid;\n-    }\n-  }\n-\n-  bool\n-  subset (hb_subset_context_t *c,\n-          cblc_bitmap_size_subset_context_t *bitmap_size_context) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    auto *dst = c->serializer->start_embed<IndexSubtableArray> ();\n-    if (unlikely (!dst)) return_trace (false);\n-\n-    hb_vector_t<hb_pair_t<hb_codepoint_t, const IndexSubtableRecord*>> lookup;\n-    build_lookup (c, bitmap_size_context, &lookup);\n-    if (unlikely (!c->serializer->propagate_error (lookup)))\n-      return false;\n-\n-    bitmap_size_context->size = 0;\n-    bitmap_size_context->num_tables = 0;\n-    hb_vector_t<IndexSubtableRecord> records;\n-    for (unsigned int start = 0; start < lookup.length;)\n-    {\n-      if (unlikely (!lookup[start].second->add_new_record (c, bitmap_size_context, &lookup, this, &start, &records)))\n-      {\n-        \/\/ Discard any leftover pushes to the serializer from successful records.\n-        for (unsigned int i = 0; i < records.length; i++)\n-          c->serializer->pop_discard ();\n-        return_trace (false);\n-      }\n-    }\n-\n-    \/* Workaround to ensure offset ordering is from least to greatest when\n-     * resolving links. *\/\n-    hb_vector_t<hb_serialize_context_t::objidx_t> objidxs;\n-    for (unsigned int i = 0; i < records.length; i++)\n-      objidxs.push (c->serializer->pop_pack ());\n-    for (unsigned int i = 0; i < records.length; i++)\n-    {\n-      IndexSubtableRecord* record = c->serializer->embed (records[i]);\n-      if (unlikely (!record)) return_trace (false);\n-      c->serializer->add_link (record->offsetToSubtable, objidxs[records.length - 1 - i]);\n-    }\n-    return_trace (true);\n-  }\n-\n-  public:\n-  const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const\n-  {\n-    for (unsigned int i = 0; i < numTables; ++i)\n-    {\n-      unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;\n-      unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;\n-      if (firstGlyphIndex <= glyph && glyph <= lastGlyphIndex)\n-        return &indexSubtablesZ[i];\n-    }\n-    return nullptr;\n-  }\n-\n-  protected:\n-  UnsizedArrayOf<IndexSubtableRecord>   indexSubtablesZ;\n-};\n-\n-struct BitmapSizeTable\n-{\n-  friend struct CBLC;\n-  friend struct CBDT;\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &&\n-                  horizontal.sanitize (c) &&\n-                  vertical.sanitize (c));\n-  }\n-\n-  const IndexSubtableRecord *\n-  find_table (hb_codepoint_t glyph, const void *base, const void **out_base) const\n-  {\n-    *out_base = &(base+indexSubtableArrayOffset);\n-    return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);\n-  }\n-\n-  bool\n-  subset (hb_subset_context_t *c, const void *base,\n-          const char *cbdt, unsigned int cbdt_length,\n-          hb_vector_t<char> *cbdt_prime \/* INOUT *\/) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out_table = c->serializer->embed (this);\n-    if (unlikely (!out_table)) return_trace (false);\n-\n-    cblc_bitmap_size_subset_context_t bitmap_size_context;\n-    bitmap_size_context.cbdt = cbdt;\n-    bitmap_size_context.cbdt_length = cbdt_length;\n-    bitmap_size_context.cbdt_prime = cbdt_prime;\n-    bitmap_size_context.size = indexTablesSize;\n-    bitmap_size_context.num_tables = numberOfIndexSubtables;\n-    bitmap_size_context.start_glyph = 1;\n-    bitmap_size_context.end_glyph = 0;\n-\n-    if (!out_table->indexSubtableArrayOffset.serialize_subset (c,\n-                                                               indexSubtableArrayOffset,\n-                                                               base,\n-                                                               &bitmap_size_context))\n-      return_trace (false);\n-    if (!bitmap_size_context.size ||\n-        !bitmap_size_context.num_tables ||\n-        bitmap_size_context.start_glyph > bitmap_size_context.end_glyph)\n-      return_trace (false);\n-\n-    out_table->indexTablesSize = bitmap_size_context.size;\n-    out_table->numberOfIndexSubtables = bitmap_size_context.num_tables;\n-    out_table->startGlyphIndex = bitmap_size_context.start_glyph;\n-    out_table->endGlyphIndex = bitmap_size_context.end_glyph;\n-    return_trace (true);\n-  }\n-\n-  protected:\n-  NNOffset32To<IndexSubtableArray>\n-                        indexSubtableArrayOffset;\n-  HBUINT32              indexTablesSize;\n-  HBUINT32              numberOfIndexSubtables;\n-  HBUINT32              colorRef;\n-  SBitLineMetrics       horizontal;\n-  SBitLineMetrics       vertical;\n-  HBGlyphID16           startGlyphIndex;\n-  HBGlyphID16           endGlyphIndex;\n-  HBUINT8               ppemX;\n-  HBUINT8               ppemY;\n-  HBUINT8               bitDepth;\n-  HBINT8                flags;\n-  public:\n-  DEFINE_SIZE_STATIC (48);\n-};\n-\n-\n-\/*\n- * Glyph Bitmap Data Formats.\n- *\/\n-\n-struct GlyphBitmapDataFormat17\n-{\n-  SmallGlyphMetrics     glyphMetrics;\n-  Array32Of<HBUINT8>    data;\n-  public:\n-  DEFINE_SIZE_ARRAY (9, data);\n-};\n-\n-struct GlyphBitmapDataFormat18\n-{\n-  BigGlyphMetrics       glyphMetrics;\n-  Array32Of<HBUINT8>    data;\n-  public:\n-  DEFINE_SIZE_ARRAY (12, data);\n-};\n-\n-struct GlyphBitmapDataFormat19\n-{\n-  Array32Of<HBUINT8>    data;\n-  public:\n-  DEFINE_SIZE_ARRAY (4, data);\n-};\n-\n-struct CBLC\n-{\n-  friend struct CBDT;\n-\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_CBLC;\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  likely (version.major == 2 || version.major == 3) &&\n-                  sizeTables.sanitize (c, this));\n-  }\n-\n-  static bool\n-  sink_cbdt (hb_subset_context_t *c, hb_vector_t<char>* cbdt_prime)\n-  {\n-    hb_blob_t *cbdt_prime_blob = hb_blob_create (cbdt_prime->arrayZ,\n-                                                 cbdt_prime->length,\n-                                                 HB_MEMORY_MODE_WRITABLE,\n-                                                 cbdt_prime->arrayZ,\n-                                                 hb_free);\n-    cbdt_prime->init ();  \/\/ Leak arrayZ to the blob.\n-    bool ret = c->plan->add_table (HB_OT_TAG_CBDT, cbdt_prime_blob);\n-    hb_blob_destroy (cbdt_prime_blob);\n-    return ret;\n-  }\n-\n-  bool\n-  subset_size_table (hb_subset_context_t *c, const BitmapSizeTable& table,\n-                     const char *cbdt \/* IN *\/, unsigned int cbdt_length,\n-                     CBLC *cblc_prime \/* INOUT *\/, hb_vector_t<char> *cbdt_prime \/* INOUT *\/) const\n-  {\n-    TRACE_SUBSET (this);\n-    cblc_prime->sizeTables.len++;\n-\n-    auto snap = c->serializer->snapshot ();\n-    auto cbdt_prime_len = cbdt_prime->length;\n-\n-    if (!table.subset (c, this, cbdt, cbdt_length, cbdt_prime))\n-    {\n-      cblc_prime->sizeTables.len--;\n-      c->serializer->revert (snap);\n-      cbdt_prime->shrink (cbdt_prime_len);\n-      return_trace (false);\n-    }\n-    return_trace (true);\n-  }\n-\n-  \/\/ Implemented in cc file as it depends on definition of CBDT.\n-  HB_INTERNAL bool subset (hb_subset_context_t *c) const;\n-\n-  protected:\n-  const BitmapSizeTable &choose_strike (hb_font_t *font) const\n-  {\n-    unsigned count = sizeTables.len;\n-    if (unlikely (!count))\n-      return Null (BitmapSizeTable);\n-\n-    unsigned int requested_ppem = hb_max (font->x_ppem, font->y_ppem);\n-    if (!requested_ppem)\n-      requested_ppem = 1<<30; \/* Choose largest strike. *\/\n-    unsigned int best_i = 0;\n-    unsigned int best_ppem = hb_max (sizeTables[0].ppemX, sizeTables[0].ppemY);\n-\n-    for (unsigned int i = 1; i < count; i++)\n-    {\n-      unsigned int ppem = hb_max (sizeTables[i].ppemX, sizeTables[i].ppemY);\n-      if ((requested_ppem <= ppem && ppem < best_ppem) ||\n-          (requested_ppem > best_ppem && ppem > best_ppem))\n-      {\n-        best_i = i;\n-        best_ppem = ppem;\n-      }\n-    }\n-\n-    return sizeTables[best_i];\n-  }\n-\n-  protected:\n-  FixedVersion<>                version;\n-  Array32Of<BitmapSizeTable>    sizeTables;\n-  public:\n-  DEFINE_SIZE_ARRAY (8, sizeTables);\n-};\n-\n-struct CBDT\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_CBDT;\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    {\n-      this->cblc = hb_sanitize_context_t ().reference_table<CBLC> (face);\n-      this->cbdt = hb_sanitize_context_t ().reference_table<CBDT> (face);\n-\n-      upem = hb_face_get_upem (face);\n-    }\n-    ~accelerator_t ()\n-    {\n-      this->cblc.destroy ();\n-      this->cbdt.destroy ();\n-    }\n-\n-    bool\n-    get_extents (hb_font_t *font, hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n-    {\n-      const void *base;\n-      const BitmapSizeTable &strike = this->cblc->choose_strike (font);\n-      const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &base);\n-      if (!subtable_record || !strike.ppemX || !strike.ppemY)\n-        return false;\n-\n-      if (subtable_record->get_extents (extents, base))\n-        return true;\n-\n-      unsigned int image_offset = 0, image_length = 0, image_format = 0;\n-      if (!subtable_record->get_image_data (glyph, base, &image_offset, &image_length, &image_format))\n-        return false;\n-\n-      unsigned int cbdt_len = cbdt.get_length ();\n-      if (unlikely (image_offset > cbdt_len || cbdt_len - image_offset < image_length))\n-        return false;\n-\n-      switch (image_format)\n-      {\n-      case 17: {\n-        if (unlikely (image_length < GlyphBitmapDataFormat17::min_size))\n-          return false;\n-        auto &glyphFormat17 = StructAtOffset<GlyphBitmapDataFormat17> (this->cbdt, image_offset);\n-        glyphFormat17.glyphMetrics.get_extents (font, extents);\n-        break;\n-      }\n-      case 18: {\n-        if (unlikely (image_length < GlyphBitmapDataFormat18::min_size))\n-          return false;\n-        auto &glyphFormat18 = StructAtOffset<GlyphBitmapDataFormat18> (this->cbdt, image_offset);\n-        glyphFormat18.glyphMetrics.get_extents (font, extents);\n-        break;\n-      }\n-      default: return false; \/* TODO: Support other image formats. *\/\n-      }\n-\n-      \/* Convert to font units. *\/\n-      float x_scale = upem \/ (float) strike.ppemX;\n-      float y_scale = upem \/ (float) strike.ppemY;\n-      extents->x_bearing = roundf (extents->x_bearing * x_scale);\n-      extents->y_bearing = roundf (extents->y_bearing * y_scale);\n-      extents->width = roundf (extents->width * x_scale);\n-      extents->height = roundf (extents->height * y_scale);\n-\n-      return true;\n-    }\n-\n-    hb_blob_t*\n-    reference_png (hb_font_t *font, hb_codepoint_t glyph) const\n-    {\n-      const void *base;\n-      const BitmapSizeTable &strike = this->cblc->choose_strike (font);\n-      const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &base);\n-      if (!subtable_record || !strike.ppemX || !strike.ppemY)\n-        return hb_blob_get_empty ();\n-\n-      unsigned int image_offset = 0, image_length = 0, image_format = 0;\n-      if (!subtable_record->get_image_data (glyph, base, &image_offset, &image_length, &image_format))\n-        return hb_blob_get_empty ();\n-\n-      unsigned int cbdt_len = cbdt.get_length ();\n-      if (unlikely (image_offset > cbdt_len || cbdt_len - image_offset < image_length))\n-        return hb_blob_get_empty ();\n-\n-      switch (image_format)\n-      {\n-      case 17:\n-      {\n-        if (unlikely (image_length < GlyphBitmapDataFormat17::min_size))\n-          return hb_blob_get_empty ();\n-        auto &glyphFormat17 = StructAtOffset<GlyphBitmapDataFormat17> (this->cbdt, image_offset);\n-        return hb_blob_create_sub_blob (cbdt.get_blob (),\n-                                        image_offset + GlyphBitmapDataFormat17::min_size,\n-                                        glyphFormat17.data.len);\n-      }\n-      case 18:\n-      {\n-        if (unlikely (image_length < GlyphBitmapDataFormat18::min_size))\n-          return hb_blob_get_empty ();\n-        auto &glyphFormat18 = StructAtOffset<GlyphBitmapDataFormat18> (this->cbdt, image_offset);\n-        return hb_blob_create_sub_blob (cbdt.get_blob (),\n-                                        image_offset + GlyphBitmapDataFormat18::min_size,\n-                                        glyphFormat18.data.len);\n-      }\n-      case 19:\n-      {\n-        if (unlikely (image_length < GlyphBitmapDataFormat19::min_size))\n-          return hb_blob_get_empty ();\n-        auto &glyphFormat19 = StructAtOffset<GlyphBitmapDataFormat19> (this->cbdt, image_offset);\n-        return hb_blob_create_sub_blob (cbdt.get_blob (),\n-                                        image_offset + GlyphBitmapDataFormat19::min_size,\n-                                        glyphFormat19.data.len);\n-      }\n-      default: return hb_blob_get_empty (); \/* TODO: Support other image formats. *\/\n-      }\n-    }\n-\n-    bool has_data () const { return cbdt.get_length (); }\n-\n-    private:\n-    hb_blob_ptr_t<CBLC> cblc;\n-    hb_blob_ptr_t<CBDT> cbdt;\n-\n-    unsigned int upem;\n-  };\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  likely (version.major == 2 || version.major == 3));\n-  }\n-\n-  protected:\n-  FixedVersion<>                version;\n-  UnsizedArrayOf<HBUINT8>       dataZ;\n-  public:\n-  DEFINE_SIZE_ARRAY (4, dataZ);\n-};\n-\n-inline bool\n-CBLC::subset (hb_subset_context_t *c) const\n-{\n-  TRACE_SUBSET (this);\n-\n-  auto *cblc_prime = c->serializer->start_embed<CBLC> ();\n-\n-  \/\/ Use a vector as a secondary buffer as the tables need to be built in parallel.\n-  hb_vector_t<char> cbdt_prime;\n-\n-  if (unlikely (!cblc_prime)) return_trace (false);\n-  if (unlikely (!c->serializer->extend_min (cblc_prime))) return_trace (false);\n-  cblc_prime->version = version;\n-\n-  hb_blob_t* cbdt_blob = hb_sanitize_context_t ().reference_table<CBDT> (c->plan->source);\n-  unsigned int cbdt_length;\n-  CBDT* cbdt = (CBDT *) hb_blob_get_data (cbdt_blob, &cbdt_length);\n-  if (unlikely (cbdt_length < CBDT::min_size))\n-  {\n-    hb_blob_destroy (cbdt_blob);\n-    return_trace (false);\n-  }\n-  _copy_data_to_cbdt (&cbdt_prime, cbdt, CBDT::min_size);\n-\n-  for (const BitmapSizeTable& table : + sizeTables.iter ())\n-    subset_size_table (c, table, (const char *) cbdt, cbdt_length, cblc_prime, &cbdt_prime);\n-\n-  hb_blob_destroy (cbdt_blob);\n-\n-  return_trace (CBLC::sink_cbdt (c, &cbdt_prime));\n-}\n-\n-struct CBDT_accelerator_t : CBDT::accelerator_t {\n-  CBDT_accelerator_t (hb_face_t *face) : CBDT::accelerator_t (face) {}\n-};\n-\n-\n-} \/* namespace OT *\/\n-\n-#endif \/* HB_OT_COLOR_CBDT_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cbdt-table.hh","additions":0,"deletions":997,"binary":false,"changes":997,"status":"deleted"},{"patch":"@@ -1,1541 +0,0 @@\n-\/*\n- * Copyright Â© 2018  Ebrahim Byagowi\n- * Copyright Â© 2020  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Calder Kitagawa\n- *\/\n-\n-#ifndef HB_OT_COLOR_COLR_TABLE_HH\n-#define HB_OT_COLOR_COLR_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-#include \"hb-ot-var-common.hh\"\n-\n-\/*\n- * COLR -- Color\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n- *\/\n-#define HB_OT_TAG_COLR HB_TAG('C','O','L','R')\n-\n-#ifndef HB_COLRV1_MAX_NESTING_LEVEL\n-#define HB_COLRV1_MAX_NESTING_LEVEL     100\n-#endif\n-\n-#ifndef COLRV1_ENABLE_SUBSETTING\n-#define COLRV1_ENABLE_SUBSETTING 1\n-#endif\n-\n-namespace OT {\n-\n-struct COLR;\n-struct hb_colrv1_closure_context_t :\n-       hb_dispatch_context_t<hb_colrv1_closure_context_t>\n-{\n-  template <typename T>\n-  return_t dispatch (const T &obj)\n-  {\n-    if (unlikely (nesting_level_left == 0))\n-      return hb_empty_t ();\n-\n-    if (paint_visited (&obj))\n-      return hb_empty_t ();\n-\n-    nesting_level_left--;\n-    obj.closurev1 (this);\n-    nesting_level_left++;\n-    return hb_empty_t ();\n-  }\n-  static return_t default_return_value () { return hb_empty_t (); }\n-\n-  bool paint_visited (const void *paint)\n-  {\n-    hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) paint - (uintptr_t) base);\n-    if (visited_paint.in_error() || visited_paint.has (delta))\n-      return true;\n-\n-    visited_paint.add (delta);\n-    return false;\n-  }\n-\n-  const COLR* get_colr_table () const\n-  { return reinterpret_cast<const COLR *> (base); }\n-\n-  void add_glyph (unsigned glyph_id)\n-  { glyphs->add (glyph_id); }\n-\n-  void add_layer_indices (unsigned first_layer_index, unsigned num_of_layers)\n-  { layer_indices->add_range (first_layer_index, first_layer_index + num_of_layers - 1); }\n-\n-  void add_palette_index (unsigned palette_index)\n-  { palette_indices->add (palette_index); }\n-\n-  public:\n-  const void *base;\n-  hb_set_t visited_paint;\n-  hb_set_t *glyphs;\n-  hb_set_t *layer_indices;\n-  hb_set_t *palette_indices;\n-  unsigned nesting_level_left;\n-\n-  hb_colrv1_closure_context_t (const void *base_,\n-                               hb_set_t *glyphs_,\n-                               hb_set_t *layer_indices_,\n-                               hb_set_t *palette_indices_,\n-                               unsigned nesting_level_left_ = HB_COLRV1_MAX_NESTING_LEVEL) :\n-                          base (base_),\n-                          glyphs (glyphs_),\n-                          layer_indices (layer_indices_),\n-                          palette_indices (palette_indices_),\n-                          nesting_level_left (nesting_level_left_)\n-  {}\n-};\n-\n-struct LayerRecord\n-{\n-  operator hb_ot_color_layer_t () const { return {glyphId, colorIdx}; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  public:\n-  HBGlyphID16   glyphId;        \/* Glyph ID of layer glyph *\/\n-  Index         colorIdx;       \/* Index value to use with a\n-                                 * selected color palette.\n-                                 * An index value of 0xFFFF\n-                                 * is a special case indicating\n-                                 * that the text foreground\n-                                 * color (defined by a\n-                                 * higher-level client) should\n-                                 * be used and shall not be\n-                                 * treated as actual index\n-                                 * into CPAL ColorRecord array. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-struct BaseGlyphRecord\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this)));\n-  }\n-\n-  public:\n-  HBGlyphID16   glyphId;        \/* Glyph ID of reference glyph *\/\n-  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n-                                 * the Layer Records) to the\n-                                 * layer record. There will be\n-                                 * numLayers consecutive entries\n-                                 * for this base glyph. *\/\n-  HBUINT16      numLayers;      \/* Number of color layers\n-                                 * associated with this glyph *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-template <typename T>\n-struct Variable\n-{\n-  Variable<T>* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed (this));\n-  }\n-\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { value.closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    if (!value.subset (c)) return_trace (false);\n-    return_trace (c->serializer->embed (varIdxBase));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && value.sanitize (c));\n-  }\n-\n-  protected:\n-  T      value;\n-  VarIdx varIdxBase;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + T::static_size);\n-};\n-\n-template <typename T>\n-struct NoVariable\n-{\n-  NoVariable<T>* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed (this));\n-  }\n-\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { value.closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    return_trace (value.subset (c));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && value.sanitize (c));\n-  }\n-\n-  T      value;\n-  public:\n-  DEFINE_SIZE_STATIC (T::static_size);\n-};\n-\n-\/\/ Color structures\n-\n-struct ColorStop\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { c->add_palette_index (paletteIndex); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  F2DOT14       stopOffset;\n-  HBUINT16      paletteIndex;\n-  F2DOT14       alpha;\n-  public:\n-  DEFINE_SIZE_STATIC (2 + 2 * F2DOT14::static_size);\n-};\n-\n-struct Extend : HBUINT8\n-{\n-  enum {\n-    EXTEND_PAD     = 0,\n-    EXTEND_REPEAT  = 1,\n-    EXTEND_REFLECT = 2,\n-  };\n-  public:\n-  DEFINE_SIZE_STATIC (1);\n-};\n-\n-template <template<typename> class Var>\n-struct ColorLine\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  {\n-    for (const auto &stop : stops.iter ())\n-      stop.closurev1 (c);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    if (!c->serializer->check_assign (out->extend, extend, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n-    if (!c->serializer->check_assign (out->stops.len, stops.len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW)) return_trace (false);\n-\n-    for (const auto& stop : stops.iter ())\n-    {\n-      if (!stop.subset (c)) return_trace (false);\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  stops.sanitize (c));\n-  }\n-\n-  Extend        extend;\n-  Array16Of<Var<ColorStop>>     stops;\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (3, stops);\n-};\n-\n-\/\/ Composition modes\n-\n-\/\/ Compositing modes are taken from https:\/\/www.w3.org\/TR\/compositing-1\/\n-\/\/ NOTE: a brief audit of major implementations suggests most support most\n-\/\/ or all of the specified modes.\n-struct CompositeMode : HBUINT8\n-{\n-  enum {\n-    \/\/ Porter-Duff modes\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators\n-    COMPOSITE_CLEAR          =  0,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_clear\n-    COMPOSITE_SRC            =  1,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_src\n-    COMPOSITE_DEST           =  2,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dst\n-    COMPOSITE_SRC_OVER       =  3,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcover\n-    COMPOSITE_DEST_OVER      =  4,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstover\n-    COMPOSITE_SRC_IN         =  5,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcin\n-    COMPOSITE_DEST_IN        =  6,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstin\n-    COMPOSITE_SRC_OUT        =  7,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcout\n-    COMPOSITE_DEST_OUT       =  8,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstout\n-    COMPOSITE_SRC_ATOP       =  9,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcatop\n-    COMPOSITE_DEST_ATOP      = 10,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstatop\n-    COMPOSITE_XOR            = 11,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_xor\n-    COMPOSITE_PLUS           = 12,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_plus\n-\n-    \/\/ Blend modes\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blending\n-    COMPOSITE_SCREEN         = 13,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingscreen\n-    COMPOSITE_OVERLAY        = 14,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingoverlay\n-    COMPOSITE_DARKEN         = 15,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdarken\n-    COMPOSITE_LIGHTEN        = 16,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinglighten\n-    COMPOSITE_COLOR_DODGE    = 17,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolordodge\n-    COMPOSITE_COLOR_BURN     = 18,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolorburn\n-    COMPOSITE_HARD_LIGHT     = 19,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghardlight\n-    COMPOSITE_SOFT_LIGHT     = 20,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsoftlight\n-    COMPOSITE_DIFFERENCE     = 21,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdifference\n-    COMPOSITE_EXCLUSION      = 22,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingexclusion\n-    COMPOSITE_MULTIPLY       = 23,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingmultiply\n-\n-    \/\/ Modes that, uniquely, do not operate on components\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingnonseparable\n-    COMPOSITE_HSL_HUE        = 24,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghue\n-    COMPOSITE_HSL_SATURATION = 25,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsaturation\n-    COMPOSITE_HSL_COLOR      = 26,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolor\n-    COMPOSITE_HSL_LUMINOSITY = 27,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingluminosity\n-  };\n-  public:\n-  DEFINE_SIZE_STATIC (1);\n-};\n-\n-struct Affine2x3\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBFixed xx;\n-  HBFixed yx;\n-  HBFixed xy;\n-  HBFixed yy;\n-  HBFixed dx;\n-  HBFixed dy;\n-  public:\n-  DEFINE_SIZE_STATIC (6 * HBFixed::static_size);\n-};\n-\n-struct PaintColrLayers\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->firstLayerIndex, c->plan->colrv1_layers->get (firstLayerIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 1 *\/\n-  HBUINT8       numLayers;\n-  HBUINT32      firstLayerIndex;  \/* index into COLRv1::layerList *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct PaintSolid\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { c->add_palette_index (paletteIndex); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 2(noVar) or 3(Var)*\/\n-  HBUINT16      paletteIndex;\n-  F2DOT14       alpha;\n-  public:\n-  DEFINE_SIZE_STATIC (3 + F2DOT14::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintLinearGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 4(noVar) or 5 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintLinearGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 x0;\n-  FWORD                 y0;\n-  FWORD                 x1;\n-  FWORD                 y1;\n-  FWORD                 x2;\n-  FWORD                 y2;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintRadialGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 6(noVar) or 7 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintRadialGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 x0;\n-  FWORD                 y0;\n-  UFWORD                radius0;\n-  FWORD                 x1;\n-  FWORD                 y1;\n-  UFWORD                radius1;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintSweepGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 8(noVar) or 9 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintSweepGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 centerX;\n-  FWORD                 centerY;\n-  F2DOT14               startAngle;\n-  F2DOT14               endAngle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size + 2 * F2DOT14::static_size);\n-};\n-\n-struct Paint;\n-\/\/ Paint a non-COLR glyph, filled as indicated by paint.\n-struct PaintGlyph\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    if (! c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n-                                       HB_SERIALIZE_ERROR_INT_OVERFLOW))\n-      return_trace (false);\n-\n-    return_trace (out->paint.serialize_subset (c, paint, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && paint.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 10 *\/\n-  Offset24To<Paint>     paint;  \/* Offset (from beginning of PaintGlyph table) to Paint subtable. *\/\n-  HBUINT16              gid;\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct PaintColrGlyph\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 11 *\/\n-  HBUINT16      gid;\n-  public:\n-  DEFINE_SIZE_STATIC (3);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintTransform\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  src.sanitize (c, this) &&\n-                  transform.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 12(noVar) or 13 (Var) *\/\n-  Offset24To<Paint>             src; \/* Offset (from beginning of PaintTransform table) to Paint subtable. *\/\n-  Offset24To<Var<Affine2x3>>    transform;\n-  public:\n-  DEFINE_SIZE_STATIC (7);\n-};\n-\n-struct PaintTranslate\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 14(noVar) or 15 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintTranslate table) to Paint subtable. *\/\n-  FWORD         dx;\n-  FWORD         dy;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size);\n-};\n-\n-struct PaintScale\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 16 (noVar) or 17(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScale table) to Paint subtable. *\/\n-  F2DOT14               scaleX;\n-  F2DOT14               scaleY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n-};\n-\n-struct PaintScaleAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 18 (noVar) or 19(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       scaleX;\n-  F2DOT14       scaleY;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintScaleUniform\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 20 (noVar) or 21(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniform table) to Paint subtable. *\/\n-  F2DOT14               scale;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n-};\n-\n-struct PaintScaleUniformAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 22 (noVar) or 23(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniformAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       scale;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintRotate\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 24 (noVar) or 25(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotate table) to Paint subtable. *\/\n-  F2DOT14               angle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n-};\n-\n-struct PaintRotateAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 26 (noVar) or 27(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotateAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       angle;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintSkew\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 28(noVar) or 29 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkew table) to Paint subtable. *\/\n-  F2DOT14               xSkewAngle;\n-  F2DOT14               ySkewAngle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n-};\n-\n-struct PaintSkewAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 30(noVar) or 31 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkewAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       xSkewAngle;\n-  F2DOT14       ySkewAngle;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintComposite\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n-    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  src.sanitize (c, this) &&\n-                  backdrop.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 32 *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintComposite table) to source Paint subtable. *\/\n-  CompositeMode         mode;   \/* If mode is unrecognized use COMPOSITE_CLEAR *\/\n-  Offset24To<Paint>     backdrop; \/* Offset (from beginning of PaintComposite table) to backdrop Paint subtable. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-struct ClipBoxFormat1\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  public:\n-  HBUINT8       format; \/* format = 1(noVar) or 2(Var)*\/\n-  FWORD         xMin;\n-  FWORD         yMin;\n-  FWORD         xMax;\n-  FWORD         yMax;\n-  public:\n-  DEFINE_SIZE_STATIC (1 + 4 * FWORD::static_size);\n-};\n-\n-struct ClipBoxFormat2 : Variable<ClipBoxFormat1> {};\n-\n-struct ClipBox\n-{\n-  ClipBox* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    switch (u.format) {\n-    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n-    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n-    default:return_trace (nullptr);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT8               format;         \/* Format identifier *\/\n-  ClipBoxFormat1        format1;\n-  ClipBoxFormat2        format2;\n-  } u;\n-};\n-\n-struct ClipRecord\n-{\n-  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n-    return_trace (out);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && clipBox.sanitize (c, base));\n-  }\n-\n-  public:\n-  HBUINT16              startGlyphID;  \/\/ first gid clip applies to\n-  HBUINT16              endGlyphID;    \/\/ last gid clip applies to, inclusive\n-  Offset24To<ClipBox>   clipBox;   \/\/ Box or VarBox\n-  public:\n-  DEFINE_SIZE_STATIC (7);\n-};\n-\n-struct ClipList\n-{\n-  unsigned serialize_clip_records (hb_serialize_context_t *c,\n-                                   const hb_set_t& gids,\n-                                   const hb_map_t& gid_offset_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (gids.is_empty () ||\n-        gid_offset_map.get_population () != gids.get_population ())\n-      return_trace (0);\n-\n-    unsigned count  = 0;\n-\n-    hb_codepoint_t start_gid= gids.get_min ();\n-    hb_codepoint_t prev_gid = start_gid;\n-\n-    unsigned offset = gid_offset_map.get (start_gid);\n-    unsigned prev_offset = offset;\n-    for (const hb_codepoint_t _ : gids.iter ())\n-    {\n-      if (_ == start_gid) continue;\n-\n-      offset = gid_offset_map.get (_);\n-      if (_ == prev_gid + 1 &&  offset == prev_offset)\n-      {\n-        prev_gid = _;\n-        continue;\n-      }\n-\n-      ClipRecord record;\n-      record.startGlyphID = start_gid;\n-      record.endGlyphID = prev_gid;\n-      record.clipBox = prev_offset;\n-\n-      if (!c->copy (record, this)) return_trace (0);\n-      count++;\n-\n-      start_gid = _;\n-      prev_gid = _;\n-      prev_offset = offset;\n-    }\n-\n-    \/\/last one\n-    {\n-      ClipRecord record;\n-      record.startGlyphID = start_gid;\n-      record.endGlyphID = prev_gid;\n-      record.clipBox = prev_offset;\n-      if (!c->copy (record, this)) return_trace (0);\n-      count++;\n-    }\n-    return_trace (count);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    if (!c->serializer->check_assign (out->format, format, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n-\n-    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    hb_map_t new_gid_offset_map;\n-    hb_set_t new_gids;\n-    for (const ClipRecord& record : clips.iter ())\n-    {\n-      unsigned start_gid = record.startGlyphID;\n-      unsigned end_gid = record.endGlyphID;\n-      for (unsigned gid = start_gid; gid <= end_gid; gid++)\n-      {\n-        if (!glyphset.has (gid) || !glyph_map.has (gid)) continue;\n-        unsigned new_gid = glyph_map.get (gid);\n-        new_gid_offset_map.set (new_gid, record.clipBox);\n-        new_gids.add (new_gid);\n-      }\n-    }\n-\n-    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n-    if (!count) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->clips.len, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && clips.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format;  \/\/ Set to 1.\n-  Array32Of<ClipRecord>         clips;  \/\/ Clip records, sorted by startGlyphID\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (5, clips);\n-};\n-\n-struct Paint\n-{\n-\n-  template <typename ...Ts>\n-  bool sanitize (hb_sanitize_context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_SANITIZE (this);\n-\n-    if (unlikely (!c->check_start_recursion (HB_COLRV1_MAX_NESTING_LEVEL)))\n-      return_trace (c->no_dispatch_return_value ());\n-\n-    return_trace (c->end_recursion (this->dispatch (c, std::forward<Ts> (ds)...)));\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.paintformat1, std::forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.paintformat2, std::forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.paintformat3, std::forward<Ts> (ds)...));\n-    case 4: return_trace (c->dispatch (u.paintformat4, std::forward<Ts> (ds)...));\n-    case 5: return_trace (c->dispatch (u.paintformat5, std::forward<Ts> (ds)...));\n-    case 6: return_trace (c->dispatch (u.paintformat6, std::forward<Ts> (ds)...));\n-    case 7: return_trace (c->dispatch (u.paintformat7, std::forward<Ts> (ds)...));\n-    case 8: return_trace (c->dispatch (u.paintformat8, std::forward<Ts> (ds)...));\n-    case 9: return_trace (c->dispatch (u.paintformat9, std::forward<Ts> (ds)...));\n-    case 10: return_trace (c->dispatch (u.paintformat10, std::forward<Ts> (ds)...));\n-    case 11: return_trace (c->dispatch (u.paintformat11, std::forward<Ts> (ds)...));\n-    case 12: return_trace (c->dispatch (u.paintformat12, std::forward<Ts> (ds)...));\n-    case 13: return_trace (c->dispatch (u.paintformat13, std::forward<Ts> (ds)...));\n-    case 14: return_trace (c->dispatch (u.paintformat14, std::forward<Ts> (ds)...));\n-    case 15: return_trace (c->dispatch (u.paintformat15, std::forward<Ts> (ds)...));\n-    case 16: return_trace (c->dispatch (u.paintformat16, std::forward<Ts> (ds)...));\n-    case 17: return_trace (c->dispatch (u.paintformat17, std::forward<Ts> (ds)...));\n-    case 18: return_trace (c->dispatch (u.paintformat18, std::forward<Ts> (ds)...));\n-    case 19: return_trace (c->dispatch (u.paintformat19, std::forward<Ts> (ds)...));\n-    case 20: return_trace (c->dispatch (u.paintformat20, std::forward<Ts> (ds)...));\n-    case 21: return_trace (c->dispatch (u.paintformat21, std::forward<Ts> (ds)...));\n-    case 22: return_trace (c->dispatch (u.paintformat22, std::forward<Ts> (ds)...));\n-    case 23: return_trace (c->dispatch (u.paintformat23, std::forward<Ts> (ds)...));\n-    case 24: return_trace (c->dispatch (u.paintformat24, std::forward<Ts> (ds)...));\n-    case 25: return_trace (c->dispatch (u.paintformat25, std::forward<Ts> (ds)...));\n-    case 26: return_trace (c->dispatch (u.paintformat26, std::forward<Ts> (ds)...));\n-    case 27: return_trace (c->dispatch (u.paintformat27, std::forward<Ts> (ds)...));\n-    case 28: return_trace (c->dispatch (u.paintformat28, std::forward<Ts> (ds)...));\n-    case 29: return_trace (c->dispatch (u.paintformat29, std::forward<Ts> (ds)...));\n-    case 30: return_trace (c->dispatch (u.paintformat30, std::forward<Ts> (ds)...));\n-    case 31: return_trace (c->dispatch (u.paintformat31, std::forward<Ts> (ds)...));\n-    case 32: return_trace (c->dispatch (u.paintformat32, std::forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT8                                       format;\n-  PaintColrLayers                               paintformat1;\n-  PaintSolid                                    paintformat2;\n-  Variable<PaintSolid>                          paintformat3;\n-  PaintLinearGradient<NoVariable>               paintformat4;\n-  Variable<PaintLinearGradient<Variable>>       paintformat5;\n-  PaintRadialGradient<NoVariable>               paintformat6;\n-  Variable<PaintRadialGradient<Variable>>       paintformat7;\n-  PaintSweepGradient<NoVariable>                paintformat8;\n-  Variable<PaintSweepGradient<Variable>>        paintformat9;\n-  PaintGlyph                                    paintformat10;\n-  PaintColrGlyph                                paintformat11;\n-  PaintTransform<NoVariable>                    paintformat12;\n-  PaintTransform<Variable>                      paintformat13;\n-  PaintTranslate                                paintformat14;\n-  Variable<PaintTranslate>                      paintformat15;\n-  PaintScale                                    paintformat16;\n-  Variable<PaintScale>                          paintformat17;\n-  PaintScaleAroundCenter                        paintformat18;\n-  Variable<PaintScaleAroundCenter>              paintformat19;\n-  PaintScaleUniform                             paintformat20;\n-  Variable<PaintScaleUniform>                   paintformat21;\n-  PaintScaleUniformAroundCenter                 paintformat22;\n-  Variable<PaintScaleUniformAroundCenter>       paintformat23;\n-  PaintRotate                                   paintformat24;\n-  Variable<PaintRotate>                         paintformat25;\n-  PaintRotateAroundCenter                       paintformat26;\n-  Variable<PaintRotateAroundCenter>             paintformat27;\n-  PaintSkew                                     paintformat28;\n-  Variable<PaintSkew>                           paintformat29;\n-  PaintSkewAroundCenter                         paintformat30;\n-  Variable<PaintSkewAroundCenter>               paintformat31;\n-  PaintComposite                                paintformat32;\n-  } u;\n-};\n-\n-struct BaseGlyphPaintRecord\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n-\n-  bool serialize (hb_serialize_context_t *s, const hb_map_t* glyph_map,\n-                  const void* src_base, hb_subset_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = s->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (!s->check_assign (out->glyphId, glyph_map->get (glyphId),\n-                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n-      return_trace (false);\n-\n-    return_trace (out->paint.serialize_subset (c, paint, src_base));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) && paint.sanitize (c, base)));\n-  }\n-\n-  public:\n-  HBGlyphID16           glyphId;    \/* Glyph ID of reference glyph *\/\n-  Offset32To<Paint>     paint;      \/* Offset (from beginning of BaseGlyphPaintRecord array) to Paint,\n-                                     * Typically PaintColrLayers *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct BaseGlyphList : SortedArray32Of<BaseGlyphPaintRecord>\n-{\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-    const hb_set_t* glyphset = c->plan->_glyphset_colred;\n-\n-    for (const auto& _ : as_array ())\n-    {\n-      unsigned gid = _.glyphId;\n-      if (!glyphset->has (gid)) continue;\n-\n-      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n-      else return_trace (false);\n-    }\n-\n-    return_trace (out->len != 0);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (SortedArray32Of<BaseGlyphPaintRecord>::sanitize (c, this));\n-  }\n-};\n-\n-struct LayerList : Array32OfOffset32To<Paint>\n-{\n-  const Paint& get_paint (unsigned i) const\n-  { return this+(*this)[i]; }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-\n-    for (const auto& _ : + hb_enumerate (*this)\n-                         | hb_filter (c->plan->colrv1_layers, hb_first))\n-\n-    {\n-      auto *o = out->serialize_append (c->serializer);\n-      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n-        return_trace (false);\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (Array32OfOffset32To<Paint>::sanitize (c, this));\n-  }\n-};\n-\n-struct COLR\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;\n-\n-  bool has_data () const { return numBaseGlyphs; }\n-\n-  unsigned int get_glyph_layers (hb_codepoint_t       glyph,\n-                                 unsigned int         start_offset,\n-                                 unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n-                                 hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/) const\n-  {\n-    const BaseGlyphRecord &record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);\n-\n-    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n-    hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n-                                                                       record.numLayers);\n-    if (count)\n-    {\n-      + glyph_layers.sub_array (start_offset, count)\n-      | hb_sink (hb_array (layers, *count))\n-      ;\n-    }\n-    return glyph_layers.length;\n-  }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    { colr = hb_sanitize_context_t ().reference_table<COLR> (face); }\n-    ~accelerator_t () { this->colr.destroy (); }\n-\n-    bool is_valid () { return colr.get_blob ()->length; }\n-\n-    void closure_glyphs (hb_codepoint_t glyph,\n-                         hb_set_t *related_ids \/* OUT *\/) const\n-    { colr->closure_glyphs (glyph, related_ids); }\n-\n-    void closure_V0palette_indices (const hb_set_t *glyphs,\n-                                    hb_set_t *palettes \/* OUT *\/) const\n-    { colr->closure_V0palette_indices (glyphs, palettes); }\n-\n-    void closure_forV1 (hb_set_t *glyphset,\n-                        hb_set_t *layer_indices,\n-                        hb_set_t *palette_indices) const\n-    { colr->closure_forV1 (glyphset, layer_indices, palette_indices); }\n-\n-    private:\n-    hb_blob_ptr_t<COLR> colr;\n-  };\n-\n-  void closure_glyphs (hb_codepoint_t glyph,\n-                       hb_set_t *related_ids \/* OUT *\/) const\n-  {\n-    const BaseGlyphRecord *record = get_base_glyph_record (glyph);\n-    if (!record) return;\n-\n-    auto glyph_layers = (this+layersZ).as_array (numLayers).sub_array (record->firstLayerIdx,\n-                                                                       record->numLayers);\n-    if (!glyph_layers.length) return;\n-    related_ids->add_array (&glyph_layers[0].glyphId, glyph_layers.length, LayerRecord::min_size);\n-  }\n-\n-  void closure_V0palette_indices (const hb_set_t *glyphs,\n-                                  hb_set_t *palettes \/* OUT *\/) const\n-  {\n-    if (!numBaseGlyphs || !numLayers) return;\n-    hb_array_t<const BaseGlyphRecord> baseGlyphs = (this+baseGlyphsZ).as_array (numBaseGlyphs);\n-    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n-\n-    for (const BaseGlyphRecord record : baseGlyphs)\n-    {\n-      if (!glyphs->has (record.glyphId)) continue;\n-      hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n-                                                                   record.numLayers);\n-      for (const LayerRecord layer : glyph_layers)\n-        palettes->add (layer.colorIdx);\n-    }\n-  }\n-\n-  void closure_forV1 (hb_set_t *glyphset,\n-                      hb_set_t *layer_indices,\n-                      hb_set_t *palette_indices) const\n-  {\n-    if (version != 1) return;\n-    hb_set_t visited_glyphs;\n-\n-    hb_colrv1_closure_context_t c (this, &visited_glyphs, layer_indices, palette_indices);\n-    const BaseGlyphList &baseglyph_paintrecords = this+baseGlyphList;\n-\n-    for (const BaseGlyphPaintRecord &baseglyph_paintrecord: baseglyph_paintrecords.iter ())\n-    {\n-      unsigned gid = baseglyph_paintrecord.glyphId;\n-      if (!glyphset->has (gid)) continue;\n-\n-      const Paint &paint = &baseglyph_paintrecords+baseglyph_paintrecord.paint;\n-      paint.dispatch (&c);\n-    }\n-    hb_set_union (glyphset, &visited_glyphs);\n-  }\n-\n-  const LayerList& get_layerList () const\n-  { return (this+layerList); }\n-\n-  const BaseGlyphList& get_baseglyphList () const\n-  { return (this+baseGlyphList); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n-                  (this+layersZ).sanitize (c, numLayers) &&\n-                  (version == 0 ||\n-                   (COLRV1_ENABLE_SUBSETTING && version == 1 &&\n-                    baseGlyphList.sanitize (c, this) &&\n-                    layerList.sanitize (c, this) &&\n-                    clipList.sanitize (c, this) &&\n-                    varIdxMap.sanitize (c, this) &&\n-                    varStore.sanitize (c, this))));\n-  }\n-\n-  template<typename BaseIterator, typename LayerIterator,\n-           hb_requires (hb_is_iterator (BaseIterator)),\n-           hb_requires (hb_is_iterator (LayerIterator))>\n-  bool serialize_V0 (hb_serialize_context_t *c,\n-                     unsigned version,\n-                     BaseIterator base_it,\n-                     LayerIterator layer_it)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (base_it.len () != layer_it.len ()))\n-      return_trace (false);\n-\n-    this->version = version;\n-    numLayers = 0;\n-    numBaseGlyphs = base_it.len ();\n-    if (numBaseGlyphs == 0)\n-    {\n-      baseGlyphsZ = 0;\n-      layersZ = 0;\n-      return_trace (true);\n-    }\n-\n-    c->push ();\n-    for (const hb_item_type<BaseIterator> _ : + base_it.iter ())\n-    {\n-      auto* record = c->embed (_);\n-      if (unlikely (!record)) return_trace (false);\n-      record->firstLayerIdx = numLayers;\n-      numLayers += record->numLayers;\n-    }\n-    c->add_link (baseGlyphsZ, c->pop_pack ());\n-\n-    c->push ();\n-    for (const hb_item_type<LayerIterator>& _ : + layer_it.iter ())\n-      _.as_array ().copy (c);\n-\n-    c->add_link (layersZ, c->pop_pack ());\n-\n-    return_trace (true);\n-  }\n-\n-  const BaseGlyphRecord* get_base_glyph_record (hb_codepoint_t gid) const\n-  {\n-    const BaseGlyphRecord* record = &(this+baseGlyphsZ).bsearch (numBaseGlyphs, (unsigned int) gid);\n-    if (record == &Null (BaseGlyphRecord) ||\n-        (record && (hb_codepoint_t) record->glyphId != gid))\n-      record = nullptr;\n-    return record;\n-  }\n-\n-  const BaseGlyphPaintRecord* get_base_glyph_paintrecord (hb_codepoint_t gid) const\n-  {\n-    const BaseGlyphPaintRecord* record = &(this+baseGlyphList).bsearch ((unsigned) gid);\n-    if ((record && (hb_codepoint_t) record->glyphId != gid))\n-      record = nullptr;\n-    return record;\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    const hb_map_t &reverse_glyph_map = *c->plan->reverse_glyph_map;\n-    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n-\n-    auto base_it =\n-    + hb_range (c->plan->num_output_glyphs ())\n-    | hb_filter ([&](hb_codepoint_t new_gid)\n-                 {\n-                    hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n-                    if (glyphset.has (old_gid)) return true;\n-                    return false;\n-                 })\n-    | hb_map_retains_sorting ([&](hb_codepoint_t new_gid)\n-                              {\n-                                hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n-\n-                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n-                                if (unlikely (!old_record))\n-                                  return hb_pair_t<bool, BaseGlyphRecord> (false, Null (BaseGlyphRecord));\n-                                BaseGlyphRecord new_record = {};\n-                                new_record.glyphId = new_gid;\n-                                new_record.numLayers = old_record->numLayers;\n-                                return hb_pair_t<bool, BaseGlyphRecord> (true, new_record);\n-                              })\n-    | hb_filter (hb_first)\n-    | hb_map_retains_sorting (hb_second)\n-    ;\n-\n-    auto layer_it =\n-    + hb_range (c->plan->num_output_glyphs ())\n-    | hb_map (reverse_glyph_map)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting ([&](hb_codepoint_t old_gid)\n-                              {\n-                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n-                                hb_vector_t<LayerRecord> out_layers;\n-\n-                                if (unlikely (!old_record ||\n-                                              old_record->firstLayerIdx >= numLayers ||\n-                                              old_record->firstLayerIdx + old_record->numLayers > numLayers))\n-                                  return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n-\n-                                auto layers = (this+layersZ).as_array (numLayers).sub_array (old_record->firstLayerIdx,\n-                                                                                             old_record->numLayers);\n-                                out_layers.resize (layers.length);\n-                                for (unsigned int i = 0; i < layers.length; i++) {\n-                                  out_layers[i] = layers[i];\n-                                  hb_codepoint_t new_gid = 0;\n-                                  if (unlikely (!c->plan->new_gid_for_old_gid (out_layers[i].glyphId, &new_gid)))\n-                                    return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n-                                  out_layers[i].glyphId = new_gid;\n-                                  out_layers[i].colorIdx = c->plan->colr_palettes->get (layers[i].colorIdx);\n-                                }\n-\n-                                return hb_pair_t<bool, hb_vector_t<LayerRecord>> (true, out_layers);\n-                              })\n-    | hb_filter (hb_first)\n-    | hb_map_retains_sorting (hb_second)\n-    ;\n-\n-    if (version == 0 && (!base_it || !layer_it))\n-      return_trace (false);\n-\n-    COLR *colr_prime = c->serializer->start_embed<COLR> ();\n-    if (unlikely (!c->serializer->extend_min (colr_prime)))  return_trace (false);\n-\n-    if (version == 0)\n-    return_trace (colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it));\n-\n-    auto snap = c->serializer->snapshot ();\n-    if (!c->serializer->allocate_size<void> (5 * HBUINT32::static_size)) return_trace (false);\n-    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n-    {\n-      if (c->serializer->in_error ()) return_trace (false);\n-      \/\/no more COLRv1 glyphs: downgrade to version 0\n-      c->serializer->revert (snap);\n-      return_trace (colr_prime->serialize_V0 (c->serializer, 0, base_it, layer_it));\n-    }\n-\n-    if (!colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it)) return_trace (false);\n-\n-    colr_prime->layerList.serialize_subset (c, layerList, this);\n-    colr_prime->clipList.serialize_subset (c, clipList, this);\n-    colr_prime->varIdxMap.serialize_copy (c->serializer, varIdxMap, this);\n-    \/\/TODO: subset varStore once it's implemented in fonttools\n-    return_trace (true);\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version number (starts at 0). *\/\n-  HBUINT16      numBaseGlyphs;  \/* Number of Base Glyph Records. *\/\n-  NNOffset32To<SortedUnsizedArrayOf<BaseGlyphRecord>>\n-                baseGlyphsZ;    \/* Offset to Base Glyph records. *\/\n-  NNOffset32To<UnsizedArrayOf<LayerRecord>>\n-                layersZ;        \/* Offset to Layer Records. *\/\n-  HBUINT16      numLayers;      \/* Number of Layer Records. *\/\n-  \/\/ Version-1 additions\n-  Offset32To<BaseGlyphList>             baseGlyphList;\n-  Offset32To<LayerList>                 layerList;\n-  Offset32To<ClipList>                  clipList;   \/\/ Offset to ClipList table (may be NULL)\n-  Offset32To<DeltaSetIndexMap>          varIdxMap;  \/\/ Offset to DeltaSetIndexMap table (may be NULL)\n-  Offset32To<VariationStore>            varStore;\n-  public:\n-  DEFINE_SIZE_MIN (14);\n-};\n-\n-struct COLR_accelerator_t : COLR::accelerator_t {\n-  COLR_accelerator_t (hb_face_t *face) : COLR::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLOR_COLR_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colr-table.hh","additions":0,"deletions":1541,"binary":false,"changes":1541,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright Â© 2018  Ebrahim Byagowi\n- * Copyright Â© 2020  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- *\/\n-\n-#ifndef HB_OT_COLR_COLRV1_CLOSURE_HH\n-#define HB_OT_COLR_COLRV1_CLOSURE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-#include \"hb-ot-color-colr-table.hh\"\n-\n-\/*\n- * COLR -- Color\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n- *\/\n-namespace OT {\n-\n-HB_INTERNAL void PaintColrLayers::closurev1 (hb_colrv1_closure_context_t* c) const\n-{\n-  c->add_layer_indices (firstLayerIndex, numLayers);\n-  const LayerList &paint_offset_lists = c->get_colr_table ()->get_layerList ();\n-  for (unsigned i = firstLayerIndex; i < firstLayerIndex + numLayers; i++)\n-  {\n-    const Paint &paint = std::addressof (paint_offset_lists) + paint_offset_lists[i];\n-    paint.dispatch (c);\n-  }\n-}\n-\n-HB_INTERNAL void PaintGlyph::closurev1 (hb_colrv1_closure_context_t* c) const\n-{\n-  c->add_glyph (gid);\n-  (this+paint).dispatch (c);\n-}\n-\n-HB_INTERNAL void PaintColrGlyph::closurev1 (hb_colrv1_closure_context_t* c) const\n-{\n-  const COLR *colr_table = c->get_colr_table ();\n-  const BaseGlyphPaintRecord* baseglyph_paintrecord = colr_table->get_base_glyph_paintrecord (gid);\n-  if (!baseglyph_paintrecord) return;\n-  c->add_glyph (gid);\n-\n-  const BaseGlyphList &baseglyph_list = colr_table->get_baseglyphList ();\n-  (&baseglyph_list+baseglyph_paintrecord->paint).dispatch (c);\n-}\n-\n-template <template<typename> class Var>\n-HB_INTERNAL void PaintTransform<Var>::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintTranslate::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintScale::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintScaleAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintScaleUniform::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintScaleUniformAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintRotate::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintRotateAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintSkew::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintSkewAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n-{ (this+src).dispatch (c); }\n-\n-HB_INTERNAL void PaintComposite::closurev1 (hb_colrv1_closure_context_t* c) const\n-{\n-  (this+src).dispatch (c);\n-  (this+backdrop).dispatch (c);\n-}\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLR_COLRV1_CLOSURE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colrv1-closure.hh","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,322 +0,0 @@\n-\/*\n- * Copyright Â© 2016  Google, Inc.\n- * Copyright Â© 2018  Ebrahim Byagowi\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Sascha Brawer\n- *\/\n-\n-#ifndef HB_OT_COLOR_CPAL_TABLE_HH\n-#define HB_OT_COLOR_CPAL_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-color.h\"\n-#include \"hb-ot-name.h\"\n-\n-\n-\/*\n- * CPAL -- Color Palette\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cpal\n- *\/\n-#define HB_OT_TAG_CPAL HB_TAG('C','P','A','L')\n-\n-namespace OT {\n-\n-\n-struct CPALV1Tail\n-{\n-  friend struct CPAL;\n-\n-  private:\n-  hb_ot_color_palette_flags_t get_palette_flags (const void *base,\n-                                                 unsigned int palette_index,\n-                                                 unsigned int palette_count) const\n-  {\n-    if (!paletteFlagsZ) return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;\n-    return (hb_ot_color_palette_flags_t) (uint32_t)\n-           (base+paletteFlagsZ).as_array (palette_count)[palette_index];\n-  }\n-\n-  hb_ot_name_id_t get_palette_name_id (const void *base,\n-                                       unsigned int palette_index,\n-                                       unsigned int palette_count) const\n-  {\n-    if (!paletteLabelsZ) return HB_OT_NAME_ID_INVALID;\n-    return (base+paletteLabelsZ).as_array (palette_count)[palette_index];\n-  }\n-\n-  hb_ot_name_id_t get_color_name_id (const void *base,\n-                                     unsigned int color_index,\n-                                     unsigned int color_count) const\n-  {\n-    if (!colorLabelsZ) return HB_OT_NAME_ID_INVALID;\n-    return (base+colorLabelsZ).as_array (color_count)[color_index];\n-  }\n-\n-  public:\n-  bool serialize (hb_serialize_context_t *c,\n-                  unsigned palette_count,\n-                  unsigned color_count,\n-                  const void *base,\n-                  const hb_map_t *color_index_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->allocate_size<CPALV1Tail> (static_size);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    out->paletteFlagsZ = 0;\n-    if (paletteFlagsZ)\n-      out->paletteFlagsZ.serialize_copy (c, paletteFlagsZ, base, 0, hb_serialize_context_t::Head, palette_count);\n-\n-    out->paletteLabelsZ = 0;\n-    if (paletteLabelsZ)\n-      out->paletteLabelsZ.serialize_copy (c, paletteLabelsZ, base, 0, hb_serialize_context_t::Head, palette_count);\n-\n-    const hb_array_t<const NameID> colorLabels = (base+colorLabelsZ).as_array (color_count);\n-    if (colorLabelsZ)\n-    {\n-      c->push ();\n-      for (const auto _ : colorLabels)\n-      {\n-        const hb_codepoint_t *v;\n-        if (!color_index_map->has (_, &v)) continue;\n-        NameID new_color_idx;\n-        new_color_idx = *v;\n-        if (!c->copy<NameID> (new_color_idx))\n-        {\n-          c->pop_discard ();\n-          return_trace (false);\n-        }\n-      }\n-      c->add_link (out->colorLabelsZ, c->pop_pack ());\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c,\n-                 const void *base,\n-                 unsigned int palette_count,\n-                 unsigned int color_count) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  (!paletteFlagsZ  || (base+paletteFlagsZ).sanitize (c, palette_count)) &&\n-                  (!paletteLabelsZ || (base+paletteLabelsZ).sanitize (c, palette_count)) &&\n-                  (!colorLabelsZ   || (base+colorLabelsZ).sanitize (c, color_count)));\n-  }\n-\n-  protected:\n-  \/\/ TODO(garretrieger): these offsets can hold nulls so we should not be using non-null offsets\n-  \/\/                     here. Currently they are needed since UnsizedArrayOf doesn't define null_size\n-  NNOffset32To<UnsizedArrayOf<HBUINT32>>\n-                paletteFlagsZ;          \/* Offset from the beginning of CPAL table to\n-                                         * the Palette Type Array. Set to 0 if no array\n-                                         * is provided. *\/\n-  NNOffset32To<UnsizedArrayOf<NameID>>\n-                paletteLabelsZ;         \/* Offset from the beginning of CPAL table to\n-                                         * the palette labels array. Set to 0 if no\n-                                         * array is provided. *\/\n-  NNOffset32To<UnsizedArrayOf<NameID>>\n-                colorLabelsZ;           \/* Offset from the beginning of CPAL table to\n-                                         * the color labels array. Set to 0\n-                                         * if no array is provided. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-typedef HBUINT32 BGRAColor;\n-\n-struct CPAL\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_CPAL;\n-\n-  bool has_data () const { return numPalettes; }\n-\n-  unsigned int get_size () const\n-  { return min_size + numPalettes * sizeof (colorRecordIndicesZ[0]); }\n-\n-  unsigned int get_palette_count () const { return numPalettes; }\n-  unsigned int   get_color_count () const { return numColors; }\n-\n-  hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette_index) const\n-  { return v1 ().get_palette_flags (this, palette_index, numPalettes); }\n-\n-  hb_ot_name_id_t get_palette_name_id (unsigned int palette_index) const\n-  { return v1 ().get_palette_name_id (this, palette_index, numPalettes); }\n-\n-  hb_ot_name_id_t get_color_name_id (unsigned int color_index) const\n-  { return v1 ().get_color_name_id (this, color_index, numColors); }\n-\n-  unsigned int get_palette_colors (unsigned int  palette_index,\n-                                   unsigned int  start_offset,\n-                                   unsigned int *color_count, \/* IN\/OUT.  May be NULL. *\/\n-                                   hb_color_t   *colors       \/* OUT.     May be NULL. *\/) const\n-  {\n-    if (unlikely (palette_index >= numPalettes))\n-    {\n-      if (color_count) *color_count = 0;\n-      return 0;\n-    }\n-    unsigned int start_index = colorRecordIndicesZ[palette_index];\n-    hb_array_t<const BGRAColor> all_colors ((this+colorRecordsZ).arrayZ, numColorRecords);\n-    hb_array_t<const BGRAColor> palette_colors = all_colors.sub_array (start_index,\n-                                                                       numColors);\n-    if (color_count)\n-    {\n-      + palette_colors.sub_array (start_offset, color_count)\n-      | hb_sink (hb_array (colors, *color_count))\n-      ;\n-    }\n-    return numColors;\n-  }\n-\n-  private:\n-  const CPALV1Tail& v1 () const\n-  {\n-    if (version == 0) return Null (CPALV1Tail);\n-    return StructAfter<CPALV1Tail> (*this);\n-  }\n-\n-  public:\n-  bool serialize (hb_serialize_context_t *c,\n-                  const hb_array_t<const HBUINT16> &color_record_indices,\n-                  const hb_array_t<const BGRAColor> &color_records,\n-                  const hb_vector_t<unsigned>& first_color_index_for_layer,\n-                  const hb_map_t& first_color_to_layer_index,\n-                  const hb_set_t &retained_color_indices) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    \/\/ TODO(grieger): limit total final size.\n-\n-    for (const auto idx : color_record_indices)\n-    {\n-      hb_codepoint_t layer_index = first_color_to_layer_index[idx];\n-\n-      HBUINT16 new_idx;\n-      new_idx = layer_index * retained_color_indices.get_population ();\n-      if (!c->copy<HBUINT16> (new_idx)) return_trace (false);\n-    }\n-\n-    c->push ();\n-    for (unsigned first_color_index : first_color_index_for_layer)\n-    {\n-      for (hb_codepoint_t color_index : retained_color_indices)\n-      {\n-        if (!c->copy<BGRAColor> (color_records[first_color_index + color_index]))\n-        {\n-          c->pop_discard ();\n-          return_trace (false);\n-        }\n-      }\n-    }\n-\n-    c->add_link (colorRecordsZ, c->pop_pack ());\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    if (!numPalettes) return_trace (false);\n-\n-    const hb_map_t *color_index_map = c->plan->colr_palettes;\n-    if (color_index_map->is_empty ()) return_trace (false);\n-\n-    hb_set_t retained_color_indices;\n-    for (const auto _ : color_index_map->keys ())\n-    {\n-      if (_ == 0xFFFF) continue;\n-      retained_color_indices.add (_);\n-    }\n-    if (retained_color_indices.is_empty ()) return_trace (false);\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-\n-    out->version = version;\n-    out->numColors = retained_color_indices.get_population ();\n-    out->numPalettes = numPalettes;\n-\n-    hb_vector_t<unsigned> first_color_index_for_layer;\n-    hb_map_t first_color_to_layer_index;\n-\n-    const hb_array_t<const HBUINT16> colorRecordIndices = colorRecordIndicesZ.as_array (numPalettes);\n-    for (const auto first_color_record_idx : colorRecordIndices)\n-    {\n-      if (first_color_to_layer_index.has (first_color_record_idx)) continue;\n-\n-      first_color_index_for_layer.push (first_color_record_idx);\n-      first_color_to_layer_index.set (first_color_record_idx,\n-                                      first_color_index_for_layer.length - 1);\n-    }\n-\n-    out->numColorRecords = first_color_index_for_layer.length\n-                           * retained_color_indices.get_population ();\n-\n-    const hb_array_t<const BGRAColor> color_records = (this+colorRecordsZ).as_array (numColorRecords);\n-    if (!out->serialize (c->serializer,\n-                         colorRecordIndices,\n-                         color_records,\n-                         first_color_index_for_layer,\n-                         first_color_to_layer_index,\n-                         retained_color_indices))\n-      return_trace (false);\n-\n-    if (version == 1)\n-      return_trace (v1 ().serialize (c->serializer, numPalettes, numColors, this, color_index_map));\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  (this+colorRecordsZ).sanitize (c, numColorRecords) &&\n-                  colorRecordIndicesZ.sanitize (c, numPalettes) &&\n-                  (version == 0 || v1 ().sanitize (c, this, numPalettes, numColors)));\n-  }\n-\n-  protected:\n-  HBUINT16      version;                \/* Table version number *\/\n-  \/* Version 0 *\/\n-  HBUINT16      numColors;              \/* Number of colors in each palette. *\/\n-  HBUINT16      numPalettes;            \/* Number of palettes in the table. *\/\n-  HBUINT16      numColorRecords;        \/* Total number of color records, combined for\n-                                         * all palettes. *\/\n-  NNOffset32To<UnsizedArrayOf<BGRAColor>>\n-                colorRecordsZ;          \/* Offset from the beginning of CPAL table to\n-                                         * the first ColorRecord. *\/\n-  UnsizedArrayOf<HBUINT16>\n-                colorRecordIndicesZ;    \/* Index of each paletteâs first color record in\n-                                         * the combined color record array. *\/\n-\/*CPALV1Tail    v1;*\/\n-  public:\n-  DEFINE_SIZE_ARRAY (12, colorRecordIndicesZ);\n-};\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLOR_CPAL_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cpal-table.hh","additions":0,"deletions":322,"binary":false,"changes":322,"status":"deleted"},{"patch":"@@ -1,423 +0,0 @@\n-\/*\n- * Copyright Â© 2018  Ebrahim Byagowi\n- * Copyright Â© 2020  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Calder Kitagawa\n- *\/\n-\n-#ifndef HB_OT_COLOR_SBIX_TABLE_HH\n-#define HB_OT_COLOR_SBIX_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-\n-\/*\n- * sbix -- Standard Bitmap Graphics\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/sbix\n- * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6sbix.html\n- *\/\n-#define HB_OT_TAG_sbix HB_TAG('s','b','i','x')\n-\n-\n-namespace OT {\n-\n-\n-struct SBIXGlyph\n-{\n-  SBIXGlyph* copy (hb_serialize_context_t *c, unsigned int data_length) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    SBIXGlyph* new_glyph = c->start_embed<SBIXGlyph> ();\n-    if (unlikely (!new_glyph)) return_trace (nullptr);\n-    if (unlikely (!c->extend_min (new_glyph))) return_trace (nullptr);\n-\n-    new_glyph->xOffset = xOffset;\n-    new_glyph->yOffset = yOffset;\n-    new_glyph->graphicType = graphicType;\n-    data.copy (c, data_length);\n-    return_trace (new_glyph);\n-  }\n-\n-  HBINT16       xOffset;        \/* The horizontal (x-axis) offset from the left\n-                                 * edge of the graphic to the glyphâs origin.\n-                                 * That is, the x-coordinate of the point on the\n-                                 * baseline at the left edge of the glyph. *\/\n-  HBINT16       yOffset;        \/* The vertical (y-axis) offset from the bottom\n-                                 * edge of the graphic to the glyphâs origin.\n-                                 * That is, the y-coordinate of the point on the\n-                                 * baseline at the left edge of the glyph. *\/\n-  Tag           graphicType;    \/* Indicates the format of the embedded graphic\n-                                 * data: one of 'jpg ', 'png ' or 'tiff', or the\n-                                 * special format 'dupe'. *\/\n-  UnsizedArrayOf<HBUINT8>\n-                data;           \/* The actual embedded graphic data. The total\n-                                 * length is inferred from sequential entries in\n-                                 * the glyphDataOffsets array and the fixed size\n-                                 * (8 bytes) of the preceding fields. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (8, data);\n-};\n-\n-struct SBIXStrike\n-{\n-  static unsigned int get_size (unsigned num_glyphs)\n-  { return min_size + num_glyphs * HBUINT32::static_size; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  imageOffsetsZ.sanitize_shallow (c, c->get_num_glyphs () + 1));\n-  }\n-\n-  hb_blob_t *get_glyph_blob (unsigned int  glyph_id,\n-                             hb_blob_t    *sbix_blob,\n-                             hb_tag_t      file_type,\n-                             int          *x_offset,\n-                             int          *y_offset,\n-                             unsigned int  num_glyphs,\n-                             unsigned int *strike_ppem) const\n-  {\n-    if (unlikely (!ppem)) return hb_blob_get_empty (); \/* To get Null() object out of the way. *\/\n-\n-    unsigned int retry_count = 8;\n-    unsigned int sbix_len = sbix_blob->length;\n-    unsigned int strike_offset = (const char *) this - (const char *) sbix_blob->data;\n-    assert (strike_offset < sbix_len);\n-\n-  retry:\n-    if (unlikely (glyph_id >= num_glyphs ||\n-                  imageOffsetsZ[glyph_id + 1] <= imageOffsetsZ[glyph_id] ||\n-                  imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] <= SBIXGlyph::min_size ||\n-                  (unsigned int) imageOffsetsZ[glyph_id + 1] > sbix_len - strike_offset))\n-      return hb_blob_get_empty ();\n-\n-    unsigned int glyph_offset = strike_offset + (unsigned int) imageOffsetsZ[glyph_id] + SBIXGlyph::min_size;\n-    unsigned int glyph_length = imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] - SBIXGlyph::min_size;\n-\n-    const SBIXGlyph *glyph = &(this+imageOffsetsZ[glyph_id]);\n-\n-    if (glyph->graphicType == HB_TAG ('d','u','p','e'))\n-    {\n-      if (glyph_length >= 2)\n-      {\n-        glyph_id = *((HBUINT16 *) &glyph->data);\n-        if (retry_count--)\n-          goto retry;\n-      }\n-      return hb_blob_get_empty ();\n-    }\n-\n-    if (unlikely (file_type != glyph->graphicType))\n-      return hb_blob_get_empty ();\n-\n-    if (strike_ppem) *strike_ppem = ppem;\n-    if (x_offset) *x_offset = glyph->xOffset;\n-    if (y_offset) *y_offset = glyph->yOffset;\n-    return hb_blob_create_sub_blob (sbix_blob, glyph_offset, glyph_length);\n-  }\n-\n-  bool subset (hb_subset_context_t *c, unsigned int available_len) const\n-  {\n-    TRACE_SUBSET (this);\n-    unsigned int num_output_glyphs = c->plan->num_output_glyphs ();\n-\n-    auto* out = c->serializer->start_embed<SBIXStrike> ();\n-    if (unlikely (!out)) return_trace (false);\n-    auto snap = c->serializer->snapshot ();\n-    if (unlikely (!c->serializer->extend (out, num_output_glyphs + 1))) return_trace (false);\n-    out->ppem = ppem;\n-    out->resolution = resolution;\n-    HBUINT32 head;\n-    head = get_size (num_output_glyphs + 1);\n-\n-    bool has_glyphs = false;\n-    for (unsigned new_gid = 0; new_gid < num_output_glyphs; new_gid++)\n-    {\n-      hb_codepoint_t old_gid;\n-      if (!c->plan->old_gid_for_new_gid (new_gid, &old_gid) ||\n-          unlikely (imageOffsetsZ[old_gid].is_null () ||\n-                    imageOffsetsZ[old_gid + 1].is_null () ||\n-                    imageOffsetsZ[old_gid + 1] <= imageOffsetsZ[old_gid] ||\n-                    imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid] <= SBIXGlyph::min_size) ||\n-                    (unsigned int) imageOffsetsZ[old_gid + 1] > available_len)\n-      {\n-        out->imageOffsetsZ[new_gid] = head;\n-        continue;\n-      }\n-      has_glyphs = true;\n-      unsigned int delta = imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid];\n-      unsigned int glyph_data_length = delta - SBIXGlyph::min_size;\n-      if (!(this+imageOffsetsZ[old_gid]).copy (c->serializer, glyph_data_length))\n-        return_trace (false);\n-      out->imageOffsetsZ[new_gid] = head;\n-      head += delta;\n-    }\n-    if (has_glyphs)\n-      out->imageOffsetsZ[num_output_glyphs] = head;\n-    else\n-      c->serializer->revert (snap);\n-    return_trace (has_glyphs);\n-  }\n-\n-  public:\n-  HBUINT16      ppem;           \/* The PPEM size for which this strike was designed. *\/\n-  HBUINT16      resolution;     \/* The device pixel density (in PPI) for which this\n-                                 * strike was designed. (E.g., 96 PPI, 192 PPI.) *\/\n-  protected:\n-  UnsizedArrayOf<Offset32To<SBIXGlyph>>\n-                imageOffsetsZ;  \/* Offset from the beginning of the strike data header\n-                                 * to bitmap data for an individual glyph ID. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, imageOffsetsZ);\n-};\n-\n-struct sbix\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_sbix;\n-\n-  bool has_data () const { return version; }\n-\n-  const SBIXStrike &get_strike (unsigned int i) const { return this+strikes[i]; }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    {\n-      table = hb_sanitize_context_t ().reference_table<sbix> (face);\n-      num_glyphs = face->get_num_glyphs ();\n-    }\n-    ~accelerator_t () { table.destroy (); }\n-\n-    bool has_data () const { return table->has_data (); }\n-\n-    bool get_extents (hb_font_t          *font,\n-                      hb_codepoint_t      glyph,\n-                      hb_glyph_extents_t *extents) const\n-    {\n-      \/* We only support PNG right now, and following function checks type. *\/\n-      return get_png_extents (font, glyph, extents);\n-    }\n-\n-    hb_blob_t *reference_png (hb_font_t      *font,\n-                              hb_codepoint_t  glyph_id,\n-                              int            *x_offset,\n-                              int            *y_offset,\n-                              unsigned int   *available_ppem) const\n-    {\n-      return choose_strike (font).get_glyph_blob (glyph_id, table.get_blob (),\n-                                                  HB_TAG ('p','n','g',' '),\n-                                                  x_offset, y_offset,\n-                                                  num_glyphs, available_ppem);\n-    }\n-\n-    private:\n-\n-    const SBIXStrike &choose_strike (hb_font_t *font) const\n-    {\n-      unsigned count = table->strikes.len;\n-      if (unlikely (!count))\n-        return Null (SBIXStrike);\n-\n-      unsigned int requested_ppem = hb_max (font->x_ppem, font->y_ppem);\n-      if (!requested_ppem)\n-        requested_ppem = 1<<30; \/* Choose largest strike. *\/\n-      \/* TODO Add DPI sensitivity as well? *\/\n-      unsigned int best_i = 0;\n-      unsigned int best_ppem = table->get_strike (0).ppem;\n-\n-      for (unsigned int i = 1; i < count; i++)\n-      {\n-        unsigned int ppem = (table->get_strike (i)).ppem;\n-        if ((requested_ppem <= ppem && ppem < best_ppem) ||\n-            (requested_ppem > best_ppem && ppem > best_ppem))\n-        {\n-          best_i = i;\n-          best_ppem = ppem;\n-        }\n-      }\n-\n-      return table->get_strike (best_i);\n-    }\n-\n-    struct PNGHeader\n-    {\n-      HBUINT8   signature[8];\n-      struct\n-      {\n-        struct\n-        {\n-          HBUINT32      length;\n-          Tag           type;\n-        }               header;\n-        HBUINT32        width;\n-        HBUINT32        height;\n-        HBUINT8         bitDepth;\n-        HBUINT8         colorType;\n-        HBUINT8         compressionMethod;\n-        HBUINT8         filterMethod;\n-        HBUINT8         interlaceMethod;\n-      } IHDR;\n-\n-      public:\n-      DEFINE_SIZE_STATIC (29);\n-    };\n-\n-    bool get_png_extents (hb_font_t          *font,\n-                          hb_codepoint_t      glyph,\n-                          hb_glyph_extents_t *extents) const\n-    {\n-      \/* Following code is safe to call even without data.\n-       * But faster to short-circuit. *\/\n-      if (!has_data ())\n-        return false;\n-\n-      int x_offset = 0, y_offset = 0;\n-      unsigned int strike_ppem = 0;\n-      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n-\n-      const PNGHeader &png = *blob->as<PNGHeader>();\n-\n-      if (png.IHDR.height >= 65536 || png.IHDR.width >= 65536)\n-      {\n-        hb_blob_destroy (blob);\n-        return false;\n-      }\n-\n-      extents->x_bearing = x_offset;\n-      extents->y_bearing = png.IHDR.height + y_offset;\n-      extents->width     = png.IHDR.width;\n-      extents->height    = -1 * png.IHDR.height;\n-\n-      \/* Convert to font units. *\/\n-      if (strike_ppem)\n-      {\n-        float scale = font->face->get_upem () \/ (float) strike_ppem;\n-        extents->x_bearing = font->em_scalef_x (extents->x_bearing * scale);\n-        extents->y_bearing = font->em_scalef_y (extents->y_bearing * scale);\n-        extents->width = font->em_scalef_x (extents->width * scale);\n-        extents->height = font->em_scalef_y (extents->height * scale);\n-      }\n-      else\n-      {\n-        extents->x_bearing = font->em_scale_x (extents->x_bearing);\n-        extents->y_bearing = font->em_scale_y (extents->y_bearing);\n-        extents->width = font->em_scale_x (extents->width);\n-        extents->height = font->em_scale_y (extents->height);\n-      }\n-\n-      hb_blob_destroy (blob);\n-\n-      return strike_ppem;\n-    }\n-\n-    private:\n-    hb_blob_ptr_t<sbix> table;\n-\n-    unsigned int num_glyphs;\n-  };\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) &&\n-                          version >= 1 &&\n-                          strikes.sanitize (c, this)));\n-  }\n-\n-  bool\n-  add_strike (hb_subset_context_t *c, unsigned i) const\n-  {\n-    if (strikes[i].is_null () || c->source_blob->length < (unsigned) strikes[i])\n-      return false;\n-\n-    return (this+strikes[i]).subset (c, c->source_blob->length - (unsigned) strikes[i]);\n-  }\n-\n-  bool serialize_strike_offsets (hb_subset_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    auto *out = c->serializer->start_embed<Array32OfOffset32To<SBIXStrike>> ();\n-    if (unlikely (!out)) return_trace (false);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    hb_vector_t<Offset32To<SBIXStrike>*> new_strikes;\n-    hb_vector_t<hb_serialize_context_t::objidx_t> objidxs;\n-    for (int i = strikes.len - 1; i >= 0; --i)\n-    {\n-      auto* o = out->serialize_append (c->serializer);\n-      if (unlikely (!o)) return_trace (false);\n-      *o = 0;\n-      auto snap = c->serializer->snapshot ();\n-      c->serializer->push ();\n-      bool ret = add_strike (c, i);\n-      if (!ret)\n-      {\n-        c->serializer->pop_discard ();\n-        out->pop ();\n-        c->serializer->revert (snap);\n-      }\n-      else\n-      {\n-        objidxs.push (c->serializer->pop_pack ());\n-        new_strikes.push (o);\n-      }\n-    }\n-    for (unsigned int i = 0; i < new_strikes.length; ++i)\n-      c->serializer->add_link (*new_strikes[i], objidxs[new_strikes.length - 1 - i]);\n-\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t* c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    sbix *sbix_prime = c->serializer->start_embed<sbix> ();\n-    if (unlikely (!sbix_prime)) return_trace (false);\n-    if (unlikely (!c->serializer->embed (this->version))) return_trace (false);\n-    if (unlikely (!c->serializer->embed (this->flags))) return_trace (false);\n-\n-    return_trace (serialize_strike_offsets (c));\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version number â set to 1 *\/\n-  HBUINT16      flags;          \/* Bit 0: Set to 1. Bit 1: Draw outlines.\n-                                 * Bits 2 to 15: reserved (set to 0). *\/\n-  Array32OfOffset32To<SBIXStrike>\n-                strikes;        \/* Offsets from the beginning of the 'sbix'\n-                                 * table to data for each individual bitmap strike. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (8, strikes);\n-};\n-\n-struct sbix_accelerator_t : sbix::accelerator_t {\n-  sbix_accelerator_t (hb_face_t *face) : sbix::accelerator_t (face) {}\n-};\n-\n-\n-} \/* namespace OT *\/\n-\n-#endif \/* HB_OT_COLOR_SBIX_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-sbix-table.hh","additions":0,"deletions":423,"binary":false,"changes":423,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright Â© 2018  Ebrahim Byagowi\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\/\n-\n-#ifndef HB_OT_COLOR_SVG_TABLE_HH\n-#define HB_OT_COLOR_SVG_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-\n-\/*\n- * SVG -- SVG (Scalable Vector Graphics)\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/svg\n- *\/\n-\n-#define HB_OT_TAG_SVG HB_TAG('S','V','G',' ')\n-\n-\n-namespace OT {\n-\n-\n-struct SVGDocumentIndexEntry\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < startGlyphID ? -1 : g > endGlyphID ? 1 : 0; }\n-\n-  hb_blob_t *reference_blob (hb_blob_t *svg_blob, unsigned int index_offset) const\n-  {\n-    return hb_blob_create_sub_blob (svg_blob,\n-                                    index_offset + (unsigned int) svgDoc,\n-                                    svgDocLength);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  svgDoc.sanitize (c, base, svgDocLength));\n-  }\n-\n-  protected:\n-  HBUINT16      startGlyphID;   \/* The first glyph ID in the range described by\n-                                 * this index entry. *\/\n-  HBUINT16      endGlyphID;     \/* The last glyph ID in the range described by\n-                                 * this index entry. Must be >= startGlyphID. *\/\n-  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n-                svgDoc;         \/* Offset from the beginning of the SVG Document Index\n-                                 * to an SVG document. Must be non-zero. *\/\n-  HBUINT32      svgDocLength;   \/* Length of the SVG document.\n-                                 * Must be non-zero. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-struct SVG\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_SVG;\n-\n-  bool has_data () const { return svgDocEntries; }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    { table = hb_sanitize_context_t ().reference_table<SVG> (face); }\n-    ~accelerator_t () { table.destroy (); }\n-\n-    hb_blob_t *reference_blob_for_glyph (hb_codepoint_t glyph_id) const\n-    {\n-      return table->get_glyph_entry (glyph_id).reference_blob (table.get_blob (),\n-                                                               table->svgDocEntries);\n-    }\n-\n-    bool has_data () const { return table->has_data (); }\n-\n-    private:\n-    hb_blob_ptr_t<SVG> table;\n-  };\n-\n-  const SVGDocumentIndexEntry &get_glyph_entry (hb_codepoint_t glyph_id) const\n-  { return (this+svgDocEntries).bsearch (glyph_id); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) &&\n-                          (this+svgDocEntries).sanitize_shallow (c)));\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version (starting at 0). *\/\n-  Offset32To<SortedArray16Of<SVGDocumentIndexEntry>>\n-                svgDocEntries;  \/* Offset (relative to the start of the SVG table) to the\n-                                 * SVG Documents Index. Must be non-zero. *\/\n-                                \/* Array of SVG Document Index Entries. *\/\n-  HBUINT32      reserved;       \/* Set to 0. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (10);\n-};\n-\n-struct SVG_accelerator_t : SVG::accelerator_t {\n-  SVG_accelerator_t (hb_face_t *face) : SVG::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLOR_SVG_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-svg-table.hh","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright Â© 2022  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- *\/\n-#include \"hb-repacker.hh\"\n-\n-#ifdef HB_EXPERIMENTAL_API\n-\n-\/**\n- * hb_subset_repack_or_fail:\n- * @table_tag: tag of the table being packed, needed to allow table specific optimizations.\n- * @hb_objects: raw array of struct hb_object_t, which provides\n- * object graph info\n- * @num_hb_objs: number of hb_object_t in the hb_objects array.\n- *\n- * Given the input object graph info, repack a table to eliminate\n- * offset overflows. A nullptr is returned if the repacking attempt fails.\n- * Table specific optimizations (eg. extension promotion in GSUB\/GPOS) may be performed.\n- * Passing HB_TAG_NONE will disable table specific optimizations.\n- *\n- * XSince: EXPERIMENTAL\n- **\/\n-hb_blob_t* hb_subset_repack_or_fail (hb_tag_t table_tag,\n-                                     hb_object_t* hb_objects,\n-                                     unsigned num_hb_objs)\n-{\n-  hb_vector_t<const hb_object_t *> packed;\n-  packed.alloc (num_hb_objs + 1);\n-  packed.push (nullptr);\n-  for (unsigned i = 0 ; i < num_hb_objs ; i++)\n-    packed.push (&(hb_objects[i]));\n-\n-  return hb_resolve_overflows (packed,\n-                               table_tag,\n-                               20,\n-                               true);\n-}\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-repacker.cc","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright Â© 2022  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- *\/\n-\n-#ifndef HB_SUBSET_REPACKER_H\n-#define HB_SUBSET_REPACKER_H\n-\n-#include \"hb.h\"\n-\n-HB_BEGIN_DECLS\n-\n-#ifdef HB_EXPERIMENTAL_API\n-\/*\n- * struct hb_link_t\n- * width:    offsetSize in bytes\n- * position: position of the offset field in bytes\n- * from beginning of subtable\n- * objidx:   index of subtable\n- *\/\n-struct hb_link_t\n-{\n-  unsigned width;\n-  unsigned position;\n-  unsigned objidx;\n-};\n-\n-typedef struct hb_link_t hb_link_t;\n-\n-\/*\n- * struct hb_object_t\n- * head:    start of object data\n- * tail:    end of object data\n- * num_real_links:    num of offset field in the object\n- * real_links:        pointer to array of offset info\n- * num_virtual_links: num of objects that must be packed\n- * after current object in the final serialized order\n- * virtual_links:     array of virtual link info\n- *\/\n-struct hb_object_t\n-{\n-  char *head;\n-  char *tail;\n-  unsigned num_real_links;\n-  hb_link_t *real_links;\n-  unsigned num_virtual_links;\n-  hb_link_t *virtual_links;\n-};\n-\n-typedef struct hb_object_t hb_object_t;\n-\n-HB_EXTERN hb_blob_t*\n-hb_subset_repack_or_fail (hb_tag_t table_tag,\n-                          hb_object_t* hb_objects,\n-                          unsigned num_hb_objs);\n-\n-#endif\n-\n-HB_END_DECLS\n-\n-#endif \/* HB_SUBSET_REPACKER_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-repacker.h","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"}]}