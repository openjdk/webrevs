{"files":[{"patch":"@@ -0,0 +1,90 @@\n+\/**\n+ * @test\n+ * bug\n+ * @summary C2 doesn't perform bimorphic inlining on a call site that was monomorphic during tier 3 compilation.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ *\n+ * @run driver compiler.inlining.InlineBimorphicVirtualCallAfterMorphismChanged\n+ *\/\n+package compiler.inlining;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class InlineBimorphicVirtualCallAfterMorphismChanged {\n+    public static abstract class AbstractBase {\n+        public final int callSiteHolder() {\n+            return inlinee();\n+        }\n+\n+        public abstract int inlinee();\n+\n+        public static void main(String[] args) {\n+            AbstractBase[] classes = new AbstractBase[] { firstInstance() };\n+            \/\/ first step: trigger a compilation while call site is monomorphic\n+            for (int i = 0; i < 10000; i++) {\n+                for (AbstractBase instance : classes) {\n+                    instance.callSiteHolder();\n+                }\n+            }\n+\n+            \/\/ second step: trigger recompilation by loading a second instance,\n+            \/\/ also make the call site bimorphic\n+            classes = new AbstractBase[] { firstInstance(), secondInstance() };\n+            for (int i = 0; i < 10000; i++) {\n+                for (AbstractBase instance : classes) {\n+                    instance.callSiteHolder();\n+                }\n+            }\n+        }\n+\n+        private static AbstractBase firstInstance() {\n+            return new FirstClass();\n+        }\n+\n+        private static AbstractBase secondInstance() {\n+            return new SecondClass();\n+        }\n+    }\n+\n+    public final static class FirstClass extends AbstractBase {\n+        public int inlinee() {\n+            return 1;\n+        }\n+    }\n+\n+    public final static class SecondClass extends AbstractBase {\n+        public int inlinee() {\n+            return 2;\n+        };\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"-XX:-TieredCompilation\");\n+        test(\"-XX:+TieredCompilation\");\n+    }\n+\n+    private static void test(String option) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-server\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+            \"-XX:CompileCommand=compileonly,*::callSiteHolder\", option,\n+            AbstractBase.class.getName()\n+        );\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+\n+        String re = \".*AbstractBase::inlinee.+virtual call.*\";\n+        boolean virtualInliningFailed = analyzer.asLines().stream()\n+                .anyMatch(s -> s.matches(re));\n+\n+        if (virtualInliningFailed) {\n+            analyzer.outputTo(System.out);\n+            throw new Exception(\n+                \"Bimorphic virtual call was not inlined with '\" + option + \"'\"\n+            );\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/InlineBimorphicVirtualCallAfterMorphismChanged.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}