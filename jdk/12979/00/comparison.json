{"files":[{"patch":"@@ -550,2 +550,0 @@\n-jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java                     8301183 linux-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import org.testng.Assert;\n@@ -31,1 +30,2 @@\n-import java.nio.charset.StandardCharsets;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n@@ -35,1 +35,2 @@\n-import java.util.List;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n@@ -37,0 +38,2 @@\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipEntry;\n@@ -38,0 +41,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -46,2 +50,1 @@\n- * @requires (os.family == \"linux\") | (os.family == \"mac\")\n- * @run testng\/manual TestLocOffsetFromZip64EF\n+ * @run testng TestLocOffsetFromZip64EF\n@@ -51,0 +54,3 @@\n+    \/\/ Buffer used when writing zero-filled entries in the sparse file\n+    private final static byte[] EMPTY_BYTES = new byte[16384];\n+\n@@ -52,5 +58,1 @@\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ The size (4GB) of the large file to be created\n+\n@@ -65,1 +67,0 @@\n-        System.out.println(\"In setup\");\n@@ -67,1 +68,0 @@\n-        createFiles();\n@@ -77,1 +77,0 @@\n-        System.out.println(\"In cleanup\");\n@@ -79,15 +78,0 @@\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n-    }\n-\n-    \/**\n-     * Create a Zip file that will result in a Zip64 Extra (EXT) header\n-     * being added to the CEN entry in order to find the LOC offset for\n-     * SMALL_FILE_NAME.\n-     *\/\n-    public static void createZipWithZip64Ext() {\n-        System.out.println(\"Executing zip...\");\n-        List<String> commands = List.of(\"zip\", \"-0\", ZIP_FILE_NAME,\n-                LARGE_FILE_NAME, SMALL_FILE_NAME);\n-        Result rc = run(new ProcessBuilder(commands));\n-        rc.assertSuccess();\n@@ -146,17 +130,2 @@\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n-     *\/\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile file = new RandomAccessFile(LARGE_FILE_NAME, \"rw\")\n-        ) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            file.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            Files.writeString(Path.of(SMALL_FILE_NAME), \"Hello\");\n-        }\n-    }\n-\n-    \/**\n-     * Utility method to execute a ProcessBuilder command\n-     * @param pb ProcessBuilder to execute\n-     * @return The Result(s) from the ProcessBuilder execution\n+     * Create a ZIP file where the second entry is large enough to output a\n+     * Zip64 CEN entry where the LOC offset is found inside a Zip64 Extra field.\n@@ -164,23 +133,22 @@\n-    private static Result run(ProcessBuilder pb) {\n-        Process p;\n-        System.out.printf(\"Running: %s%n\", pb.command());\n-        try {\n-            p = pb.start();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't start process '%s'\", pb.command()), e);\n-        }\n-\n-        String output;\n-        try {\n-            output = toString(p.getInputStream(), p.getErrorStream());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't read process output '%s'\", pb.command()), e);\n-        }\n-\n-        try {\n-            p.waitFor();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\n-                    format(\"Process hasn't finished '%s'\", pb.command()), e);\n+    public void createZipWithZip64Ext() throws IOException {\n+        \/\/ Make a ZIP with two entries\n+        try (FileOutputStream fileOutputStream = new FileOutputStream(new File(ZIP_FILE_NAME));\n+             ZipOutputStream zo = new ZipOutputStream(new SparseOutputStream(fileOutputStream))) {\n+\n+            \/\/ First entry is a small DEFLATED entry\n+            zo.putNextEntry(new ZipEntry(\"first\"));\n+\n+            \/\/ Second entry is STORED to enable sparse writing\n+            ZipEntry e = new ZipEntry(\"second\");\n+            e.setMethod(ZipEntry.STORED);\n+            e.setSize(LARGE_FILE_SIZE);\n+            e.setCrc(crc(LARGE_FILE_SIZE));\n+\n+            \/\/ This forces an Info-ZIP Extended Timestamp extra field to be produced\n+            e.setLastModifiedTime(FileTime.from(Instant.now()));\n+            zo.putNextEntry(e);\n+\n+            \/\/ Write LARGE_FILE_SIZE empty bytes\n+            for (int i = 0; i < LARGE_FILE_SIZE \/ EMPTY_BYTES.length; i++) {\n+                zo.write(EMPTY_BYTES, 0, EMPTY_BYTES.length);\n+            }\n@@ -188,1 +156,0 @@\n-        return new Result(p.exitValue(), output);\n@@ -192,5 +159,1 @@\n-     * Utility Method for combining the output from a ProcessBuilder invocation\n-     * @param in1 ProccessBuilder.getInputStream\n-     * @param in2 ProcessBuilder.getErrorStream\n-     * @return The ProcessBuilder output\n-     * @throws IOException if an error occurs\n+     * Compute the CRC for a file of the given size filled with zero-bytes\n@@ -198,5 +161,10 @@\n-    static String toString(InputStream in1, InputStream in2) throws IOException {\n-        try (ByteArrayOutputStream dst = new ByteArrayOutputStream();\n-             InputStream concatenated = new SequenceInputStream(in1, in2)) {\n-            concatenated.transferTo(dst);\n-            return new String(dst.toByteArray(), StandardCharsets.UTF_8);\n+    private static long crc(long size) {\n+        CRC32 crc32 = new CRC32();\n+        long rem = size;\n+        while (rem > 0) {\n+            int lim = EMPTY_BYTES.length;\n+            if (rem < lim) {\n+                lim = (int) rem;\n+            }\n+            crc32.update(EMPTY_BYTES, 0, lim);\n+            rem -= lim;\n@@ -204,0 +172,1 @@\n+        return crc32.getValue();\n@@ -207,1 +176,2 @@\n-     * Utility class used to hold the results from  a ProcessBuilder execution\n+     * An OutputStream which creates sparse holes when contents\n+     * from EMPTY_BYTES is written to it.\n@@ -209,3 +179,2 @@\n-    static class Result {\n-        final int ec;\n-        final String output;\n+    private class SparseOutputStream extends FilterOutputStream {\n+        private final FileChannel channel;\n@@ -213,3 +182,3 @@\n-        private Result(int ec, String output) {\n-            this.ec = ec;\n-            this.output = output;\n+        public SparseOutputStream(FileOutputStream fileOutputStream) {\n+            super(fileOutputStream);\n+            this.channel = fileOutputStream.getChannel();\n@@ -217,3 +186,8 @@\n-        Result assertSuccess() {\n-            assertTrue(ec == 0, \"Expected ec 0, got: \", ec, \" , output [\", output, \"]\");\n-            return this;\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            if (b == EMPTY_BYTES) {\n+                channel.position(channel.position() + len);\n+            } else {\n+                super.write(b, off, len);\n+            }\n@@ -222,8 +196,0 @@\n-    static void assertTrue(boolean cond, Object ... failedArgs) {\n-        if (cond)\n-            return;\n-        StringBuilder sb = new StringBuilder();\n-        for (Object o : failedArgs)\n-            sb.append(o);\n-        Assert.fail(sb.toString());\n-    }\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":64,"deletions":98,"binary":false,"changes":162,"status":"modified"}]}