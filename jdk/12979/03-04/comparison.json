{"files":[{"patch":"@@ -55,1 +55,2 @@\n-    \/\/ Size of a Zip64 extended information field\n+    \/\/ Size of a Zip64 extended information field with long fields\n+    \/\/ for 'uncompressed size', 'compressed size' and 'local header offset'\n@@ -60,2 +61,5 @@\n-            + Long.BYTES     \/\/ Loc offset\n-            + Integer.BYTES; \/\/ Start disk\n+            + Long.BYTES;    \/\/ Loc offset\n+    \/\/ Size of the extra field header (2 byte tag + 2 byte data size)\n+    public static short EXTRA_HEADER_SIZE = 2 * Short.BYTES;\n+    \/\/ Size of the data part of the Zip64 field  ( field size minus the header)\n+    public static short ZIP64_DATA_SIZE = (short) (ZIP64_SIZE - EXTRA_HEADER_SIZE);\n@@ -66,0 +70,2 @@\n+    \/\/ The 'Zip64 extended information' tag, see APPNOTE.txt\n+    private static final short ZIP64_TAG = (short) 0x1;\n@@ -159,1 +165,1 @@\n-            \/\/ Make it STORED and empty to simplify parsing\n+            \/\/ Add an entry, make it STORED and empty to simplify parsing\n@@ -163,0 +169,10 @@\n+            zo.putNextEntry(e);\n+\n+            \/\/ Add an additional entry as a sanity check that we can navigate past the first\n+            ZipEntry e2 = new ZipEntry(\"entry2\");\n+            e2.setMethod(ZipEntry.STORED);\n+            e2.setSize(0);\n+            e2.setCrc(0);\n+            zo.putNextEntry(e2);\n+\n+            zo.closeEntry(); \/\/ At this point, all LOC headers are written.\n@@ -164,1 +180,3 @@\n-            \/\/ Make ZipOutputStream output an 'Info-Zip extended timestamp' extra field\n+            \/\/ We want the first CEN entry to have two extra fields:\n+            \/\/ 1: A 'Info-Zip extended timestamp' extra field, generated by ZipOutputStream\n+            \/\/       when the following date fields are set:\n@@ -168,6 +186,3 @@\n-            \/\/ Add an opaque extra field, right-sized for a Zip64 extended field\n-            \/\/ We'll update this below\n-            byte[] zip64 = new byte[ZIP64_SIZE];\n-            ByteBuffer buffer = ByteBuffer.wrap(zip64).order(ByteOrder.LITTLE_ENDIAN);\n-            buffer.putShort(UNKNOWN_TAG); \/\/ Opaque tag makes ZipEntry.setExtra ignore it\n-            buffer.putShort((short) (zip64.length - 2 * Short.BYTES)); \/\/ Data size\n+            \/\/ 2: An opaque extra field, right-sized for a Zip64 extended field,\n+            \/\/    to be updated below\n+            byte[] zip64 = makeOpaqueExtraField();\n@@ -176,1 +191,1 @@\n-            zo.putNextEntry(e);\n+            zo.finish(); \/\/ Write out CEN and END records\n@@ -187,0 +202,16 @@\n+    \/**\n+     * Returns an opaque extra field with the tag 'unknown', which makes ZipEntry.setExtra ignore it.\n+     * The returned field has the expected field and data size of a Zip64 extended information field\n+     * including the fields 'uncompressed size' (8 bytes), 'compressed size' (8 bytes) and\n+     * 'local header offset' (8 bytes).\n+     *\/\n+    private static byte[] makeOpaqueExtraField() {\n+        byte[] zip64 = new byte[ZIP64_SIZE];\n+        ByteBuffer buffer = ByteBuffer.wrap(zip64).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Using the 'unknown' tag makes ZipEntry.setExtra ignore it\n+        buffer.putShort(UNKNOWN_TAG);\n+        \/\/ Data size\n+        buffer.putShort(ZIP64_DATA_SIZE);\n+        return zip64;\n+    }\n+\n@@ -194,7 +225,3 @@\n-        \/\/ Local header name length\n-        short nlenLoc = buffer.getShort(ZipFile.LOCNAM);\n-        \/\/ Local header extra field length\n-        short elenLoc = buffer.getShort(ZipFile.LOCEXT);\n-\n-        \/\/ Offset of the CEN header\n-        int cenOff = ZipFile.LOCHDR + nlenLoc + elenLoc;\n+        \/\/ Skip past two Local Headers to find the offset of the first CEN\n+        int secondLoc = skipLoc(buffer, 0);\n+        int cenOff = skipLoc(buffer, secondLoc);\n@@ -202,1 +229,1 @@\n-        \/\/ Read name, extra field and comment lengths\n+        \/\/ Read name, extra field and comment lengths from CEN\n@@ -206,1 +233,2 @@\n-        \/\/ Update CEN sizes and loc offset to 0'xFFFFFFFF\n+        \/\/ Update CEN sizes and loc offset to 0xFFFFFFFF, meaning\n+        \/\/ actual values should be read from the Zip64 field\n@@ -215,1 +243,14 @@\n-        buffer.position(extraOff + elen - ZIP64_SIZE);\n+        int zip64ExtraOff = extraOff + elen - ZIP64_SIZE;\n+\n+        \/\/ Update tag \/ Header ID to be the actual Zip64 tag instead of the 'unknown'\n+        buffer.putShort(zip64ExtraOff, ZIP64_TAG);\n+    }\n+\n+    \/**\n+     * Return the offset of the header following the Local Header starting at off\n+     *\/\n+    private static int skipLoc(ByteBuffer buffer, int off) {\n+        \/\/ Local header name length\n+        short nlenLoc = buffer.getShort(off + ZipFile.LOCNAM);\n+        \/\/ Local header extra field length\n+        short elenLoc = buffer.getShort(off + ZipFile.LOCEXT);\n@@ -217,2 +258,2 @@\n-        \/\/ Update the Zip64 field with the real tag\n-        buffer.putShort((short) 0x1); \/\/  Tag for Zip64\n+        \/\/ Offset of the next header\n+        return off + ZipFile.LOCHDR + nlenLoc + elenLoc;\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":65,"deletions":24,"binary":false,"changes":89,"status":"modified"}]}