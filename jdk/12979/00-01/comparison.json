{"files":[{"patch":"@@ -31,1 +31,1 @@\n-import java.nio.channels.FileChannel;\n+import java.nio.ByteOrder;\n@@ -38,1 +38,0 @@\n-import java.util.zip.CRC32;\n@@ -43,1 +42,1 @@\n-import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n@@ -54,2 +53,1 @@\n-    \/\/ Buffer used when writing zero-filled entries in the sparse file\n-    private final static byte[] EMPTY_BYTES = new byte[16384];\n+    private static final String ZIP_FILE_NAME = \"LocOffsetFromZip64.zip\";\n@@ -57,3 +55,7 @@\n-    private static final String ZIP_FILE_NAME = \"LargeZipTest.zip\";\n-\n-    private static final long LARGE_FILE_SIZE = 4L * 1024L * 1024L * 1024L;\n+    \/\/ Size of a Zip64 extended information field\n+    public static final int ZIP64_SIZE = Short.BYTES \/\/ Tag\n+            + Short.BYTES    \/\/ Data size\n+            + Long.BYTES     \/\/ Uncompressed size\n+            + Long.BYTES     \/\/ Compressed size\n+            + Long.BYTES     \/\/ Loc offset\n+            + Integer.BYTES; \/\/ Start disk\n@@ -63,0 +65,1 @@\n+     *\n@@ -130,2 +133,16 @@\n-     * Create a ZIP file where the second entry is large enough to output a\n-     * Zip64 CEN entry where the LOC offset is found inside a Zip64 Extra field.\n+     * This produces a ZIP with similar features as the one created by 'Info-ZIP' which\n+     * caused 'Extended timestamp' parsing to fail before JDK-8255380.\n+     *\n+     * The issue was sensitive to the ordering of 'Info-ZIP extended timestamp' fields and\n+     * 'Zip64 extended information' fields. ZipOutputStream and 'Info-ZIP' order these differently.\n+     *\n+     * ZipFileSystem tried to read the Local file header while parsing the extended timestamp,\n+     * but if the Zip64 extra field was not read yet, ZipFileSystem would incorrecly try to read\n+     * the Local File header from offset 0xFFFFFFFF.\n+     *\n+     * This method creates a ZIP file which includes a CEN with the following features:\n+     *\n+     * - Its extra field has a 'Info-ZIP extended timestamp' field followed by a\n+     *   'Zip64 extended information' field.\n+     * - The sizes and offset fields values of the CEN are set to 0xFFFFFFFF (Zip64 magic values)\n+     *\n@@ -134,6 +151,2 @@\n-        \/\/ Make a ZIP with two entries\n-        try (FileOutputStream fileOutputStream = new FileOutputStream(new File(ZIP_FILE_NAME));\n-             ZipOutputStream zo = new ZipOutputStream(new SparseOutputStream(fileOutputStream))) {\n-\n-            \/\/ First entry is a small DEFLATED entry\n-            zo.putNextEntry(new ZipEntry(\"first\"));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n@@ -141,2 +154,2 @@\n-            \/\/ Second entry is STORED to enable sparse writing\n-            ZipEntry e = new ZipEntry(\"second\");\n+            ZipEntry e = new ZipEntry(\"entry\");\n+            \/\/ Make it STORED and empty to simplify parsing\n@@ -144,2 +157,2 @@\n-            e.setSize(LARGE_FILE_SIZE);\n-            e.setCrc(crc(LARGE_FILE_SIZE));\n+            e.setSize(0);\n+            e.setCrc(0);\n@@ -147,1 +160,1 @@\n-            \/\/ This forces an Info-ZIP Extended Timestamp extra field to be produced\n+            \/\/ Make ZipOutputStream output an 'Info-Zip extended timestamp' extra field\n@@ -149,1 +162,1 @@\n-            zo.putNextEntry(e);\n+            e.setLastAccessTime(FileTime.from(Instant.now()));\n@@ -151,6 +164,7 @@\n-            \/\/ Write LARGE_FILE_SIZE empty bytes\n-            for (int i = 0; i < LARGE_FILE_SIZE \/ EMPTY_BYTES.length; i++) {\n-                zo.write(EMPTY_BYTES, 0, EMPTY_BYTES.length);\n-            }\n-        }\n-    }\n+            \/\/ Add an opaque extra field, right-sized for a Zip64 extended field\n+            \/\/ We'll update this below\n+            byte[] zip64 = new byte[ZIP64_SIZE];\n+            ByteBuffer buffer = ByteBuffer.wrap(zip64).order(ByteOrder.LITTLE_ENDIAN);\n+            buffer.putShort((short) 0x42); \/\/ Opaque tag makes ZipEntry.setExtra ignore it\n+            buffer.putShort((short) (zip64.length - 2 * Short.BYTES)); \/\/ Data size\n+            e.setExtra(zip64);\n@@ -158,13 +172,1 @@\n-    \/**\n-     * Compute the CRC for a file of the given size filled with zero-bytes\n-     *\/\n-    private static long crc(long size) {\n-        CRC32 crc32 = new CRC32();\n-        long rem = size;\n-        while (rem > 0) {\n-            int lim = EMPTY_BYTES.length;\n-            if (rem < lim) {\n-                lim = (int) rem;\n-            }\n-            crc32.update(EMPTY_BYTES, 0, lim);\n-            rem -= lim;\n+            zo.putNextEntry(e);\n@@ -172,1 +174,7 @@\n-        return crc32.getValue();\n+\n+        byte[] zip = out.toByteArray();\n+\n+        \/\/ ZIP now has the right structure, but we need to update the CEN to Zip64 format\n+        updateToZip64(zip);\n+        \/\/ Write the ZIP to disk\n+        Files.write(Path.of(ZIP_FILE_NAME), zip);\n@@ -176,2 +184,1 @@\n-     * An OutputStream which creates sparse holes when contents\n-     * from EMPTY_BYTES is written to it.\n+     * Update the CEN record to Zip64 format\n@@ -179,2 +186,1 @@\n-    private class SparseOutputStream extends FilterOutputStream {\n-        private final FileChannel channel;\n+    private static void updateToZip64(byte[] bytes) throws IOException {\n@@ -182,4 +188,1 @@\n-        public SparseOutputStream(FileOutputStream fileOutputStream) {\n-            super(fileOutputStream);\n-            this.channel = fileOutputStream.getChannel();\n-        }\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n@@ -187,8 +190,31 @@\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            if (b == EMPTY_BYTES) {\n-                channel.position(channel.position() + len);\n-            } else {\n-                super.write(b, off, len);\n-            }\n-        }\n+        \/\/ Local header name length\n+        short nlenLoc = buffer.getShort(ZipFile.LOCNAM);\n+        \/\/ Local header extra field length\n+        short elenLoc = buffer.getShort(ZipFile.LOCEXT);\n+\n+        \/\/ Offset of the CEN header\n+        int cenOff = ZipFile.LOCHDR + nlenLoc + elenLoc;\n+\n+        \/\/ Read name, extra field and comment lengths\n+        short nlen = buffer.getShort(cenOff + ZipFile.CENNAM);\n+        short clen = buffer.getShort(cenOff + ZipFile.CENCOM);\n+        short elen = buffer.getShort(cenOff + ZipFile.CENEXT);\n+\n+        \/\/ Update CEN sizes and loc offset to 0xFFFFFFFF\n+        buffer.putInt(cenOff + ZipFile.CENLEN, 0XFFFFFFFF);\n+        buffer.putInt(cenOff + ZipFile.CENSIZ, 0XFFFFFFFF);\n+        buffer.putInt(cenOff + ZipFile.CENOFF, 0xFFFFFFFF);\n+\n+        \/\/ Offset of the extra fields\n+        int extraOff = cenOff + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Position at the start of the Zip64 extra field\n+        buffer.position(extraOff + elen - ZIP64_SIZE);\n+\n+        \/\/ Update the Zip64 field with real values\n+        buffer.putShort((short) 0x1); \/\/  Tag for Zip64\n+        buffer.getShort(); \/\/ Data size is good\n+        buffer.putLong(0); \/\/ Uncompressed size\n+        buffer.putLong(0); \/\/ Compressed size\n+        buffer.putLong(0); \/\/ loc offset\n+        buffer.putInt(0);  \/\/ Set disk start\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":84,"deletions":58,"binary":false,"changes":142,"status":"modified"}]}