{"files":[{"patch":"@@ -550,2 +550,0 @@\n-jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java                     8301183 linux-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import org.testng.Assert;\n@@ -31,1 +30,2 @@\n-import java.nio.charset.StandardCharsets;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -35,1 +35,2 @@\n-import java.util.List;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n@@ -37,0 +38,1 @@\n+import java.util.zip.ZipEntry;\n@@ -38,0 +40,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -39,1 +42,1 @@\n-import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n@@ -46,2 +49,1 @@\n- * @requires (os.family == \"linux\") | (os.family == \"mac\")\n- * @run testng\/manual TestLocOffsetFromZip64EF\n+ * @run testng TestLocOffsetFromZip64EF\n@@ -51,7 +53,9 @@\n-    private static final String ZIP_FILE_NAME = \"LargeZipTest.zip\";\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ The size (4GB) of the large file to be created\n-    private static final long LARGE_FILE_SIZE = 4L * 1024L * 1024L * 1024L;\n+    private static final String ZIP_FILE_NAME = \"LocOffsetFromZip64.zip\";\n+\n+    \/\/ Size of a Zip64 extended information field\n+    public static final int ZIP64_SIZE = Short.BYTES \/\/ Tag\n+            + Short.BYTES    \/\/ Data size\n+            + Long.BYTES     \/\/ Uncompressed size\n+            + Long.BYTES     \/\/ Compressed size\n+            + Long.BYTES     \/\/ Loc offset\n+            + Integer.BYTES; \/\/ Start disk\n@@ -61,0 +65,1 @@\n+     *\n@@ -65,1 +70,0 @@\n-        System.out.println(\"In setup\");\n@@ -67,1 +71,0 @@\n-        createFiles();\n@@ -77,1 +80,0 @@\n-        System.out.println(\"In cleanup\");\n@@ -79,15 +81,0 @@\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n-    }\n-\n-    \/**\n-     * Create a Zip file that will result in a Zip64 Extra (EXT) header\n-     * being added to the CEN entry in order to find the LOC offset for\n-     * SMALL_FILE_NAME.\n-     *\/\n-    public static void createZipWithZip64Ext() {\n-        System.out.println(\"Executing zip...\");\n-        List<String> commands = List.of(\"zip\", \"-0\", ZIP_FILE_NAME,\n-                LARGE_FILE_NAME, SMALL_FILE_NAME);\n-        Result rc = run(new ProcessBuilder(commands));\n-        rc.assertSuccess();\n@@ -146,2 +133,16 @@\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n+     * This produces a ZIP with similar features as the one created by 'Info-ZIP' which\n+     * caused 'Extended timestamp' parsing to fail before JDK-8255380.\n+     *\n+     * The issue was sensitive to the ordering of 'Info-ZIP extended timestamp' fields and\n+     * 'Zip64 extended information' fields. ZipOutputStream and 'Info-ZIP' order these differently.\n+     *\n+     * ZipFileSystem tried to read the Local file header while parsing the extended timestamp,\n+     * but if the Zip64 extra field was not read yet, ZipFileSystem would incorrecly try to read\n+     * the Local File header from offset 0xFFFFFFFF.\n+     *\n+     * This method creates a ZIP file which includes a CEN with the following features:\n+     *\n+     * - Its extra field has a 'Info-ZIP extended timestamp' field followed by a\n+     *   'Zip64 extended information' field.\n+     * - The sizes and offset fields values of the CEN are set to 0xFFFFFFFF (Zip64 magic values)\n+     *\n@@ -149,7 +150,23 @@\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile file = new RandomAccessFile(LARGE_FILE_NAME, \"rw\")\n-        ) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            file.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            Files.writeString(Path.of(SMALL_FILE_NAME), \"Hello\");\n+    public void createZipWithZip64Ext() throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n+\n+            ZipEntry e = new ZipEntry(\"entry\");\n+            \/\/ Make it STORED and empty to simplify parsing\n+            e.setMethod(ZipEntry.STORED);\n+            e.setSize(0);\n+            e.setCrc(0);\n+\n+            \/\/ Make ZipOutputStream output an 'Info-Zip extended timestamp' extra field\n+            e.setLastModifiedTime(FileTime.from(Instant.now()));\n+            e.setLastAccessTime(FileTime.from(Instant.now()));\n+\n+            \/\/ Add an opaque extra field, right-sized for a Zip64 extended field\n+            \/\/ We'll update this below\n+            byte[] zip64 = new byte[ZIP64_SIZE];\n+            ByteBuffer buffer = ByteBuffer.wrap(zip64).order(ByteOrder.LITTLE_ENDIAN);\n+            buffer.putShort((short) 0x42); \/\/ Opaque tag makes ZipEntry.setExtra ignore it\n+            buffer.putShort((short) (zip64.length - 2 * Short.BYTES)); \/\/ Data size\n+            e.setExtra(zip64);\n+\n+            zo.putNextEntry(e);\n@@ -157,0 +174,7 @@\n+\n+        byte[] zip = out.toByteArray();\n+\n+        \/\/ ZIP now has the right structure, but we need to update the CEN to Zip64 format\n+        updateToZip64(zip);\n+        \/\/ Write the ZIP to disk\n+        Files.write(Path.of(ZIP_FILE_NAME), zip);\n@@ -160,3 +184,1 @@\n-     * Utility method to execute a ProcessBuilder command\n-     * @param pb ProcessBuilder to execute\n-     * @return The Result(s) from the ProcessBuilder execution\n+     * Update the CEN record to Zip64 format\n@@ -164,9 +186,1 @@\n-    private static Result run(ProcessBuilder pb) {\n-        Process p;\n-        System.out.printf(\"Running: %s%n\", pb.command());\n-        try {\n-            p = pb.start();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't start process '%s'\", pb.command()), e);\n-        }\n+    private static void updateToZip64(byte[] bytes) throws IOException {\n@@ -174,7 +188,1 @@\n-        String output;\n-        try {\n-            output = toString(p.getInputStream(), p.getErrorStream());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't read process output '%s'\", pb.command()), e);\n-        }\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n@@ -182,8 +190,4 @@\n-        try {\n-            p.waitFor();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\n-                    format(\"Process hasn't finished '%s'\", pb.command()), e);\n-        }\n-        return new Result(p.exitValue(), output);\n-    }\n+        \/\/ Local header name length\n+        short nlenLoc = buffer.getShort(ZipFile.LOCNAM);\n+        \/\/ Local header extra field length\n+        short elenLoc = buffer.getShort(ZipFile.LOCEXT);\n@@ -191,14 +195,2 @@\n-    \/**\n-     * Utility Method for combining the output from a ProcessBuilder invocation\n-     * @param in1 ProccessBuilder.getInputStream\n-     * @param in2 ProcessBuilder.getErrorStream\n-     * @return The ProcessBuilder output\n-     * @throws IOException if an error occurs\n-     *\/\n-    static String toString(InputStream in1, InputStream in2) throws IOException {\n-        try (ByteArrayOutputStream dst = new ByteArrayOutputStream();\n-             InputStream concatenated = new SequenceInputStream(in1, in2)) {\n-            concatenated.transferTo(dst);\n-            return new String(dst.toByteArray(), StandardCharsets.UTF_8);\n-        }\n-    }\n+        \/\/ Offset of the CEN header\n+        int cenOff = ZipFile.LOCHDR + nlenLoc + elenLoc;\n@@ -206,6 +198,4 @@\n-    \/**\n-     * Utility class used to hold the results from  a ProcessBuilder execution\n-     *\/\n-    static class Result {\n-        final int ec;\n-        final String output;\n+        \/\/ Read name, extra field and comment lengths\n+        short nlen = buffer.getShort(cenOff + ZipFile.CENNAM);\n+        short clen = buffer.getShort(cenOff + ZipFile.CENCOM);\n+        short elen = buffer.getShort(cenOff + ZipFile.CENEXT);\n@@ -213,16 +203,18 @@\n-        private Result(int ec, String output) {\n-            this.ec = ec;\n-            this.output = output;\n-        }\n-        Result assertSuccess() {\n-            assertTrue(ec == 0, \"Expected ec 0, got: \", ec, \" , output [\", output, \"]\");\n-            return this;\n-        }\n-    }\n-    static void assertTrue(boolean cond, Object ... failedArgs) {\n-        if (cond)\n-            return;\n-        StringBuilder sb = new StringBuilder();\n-        for (Object o : failedArgs)\n-            sb.append(o);\n-        Assert.fail(sb.toString());\n+        \/\/ Update CEN sizes and loc offset to 0xFFFFFFFF\n+        buffer.putInt(cenOff + ZipFile.CENLEN, 0XFFFFFFFF);\n+        buffer.putInt(cenOff + ZipFile.CENSIZ, 0XFFFFFFFF);\n+        buffer.putInt(cenOff + ZipFile.CENOFF, 0xFFFFFFFF);\n+\n+        \/\/ Offset of the extra fields\n+        int extraOff = cenOff + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Position at the start of the Zip64 extra field\n+        buffer.position(extraOff + elen - ZIP64_SIZE);\n+\n+        \/\/ Update the Zip64 field with real values\n+        buffer.putShort((short) 0x1); \/\/  Tag for Zip64\n+        buffer.getShort(); \/\/ Data size is good\n+        buffer.putLong(0); \/\/ Uncompressed size\n+        buffer.putLong(0); \/\/ Compressed size\n+        buffer.putLong(0); \/\/ loc offset\n+        buffer.putInt(0);  \/\/ Set disk start\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":96,"deletions":104,"binary":false,"changes":200,"status":"modified"}]}