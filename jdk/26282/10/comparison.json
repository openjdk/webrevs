{"files":[{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.PrimitiveIterator.OfInt;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8343110 8361299\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @summary tests the CharBuffer implementations behaving as CharSequence in various states (position, limit, offset)\n+ * @run junit CharBufferAsCharSequenceTest\n+ *\/\n+public class CharBufferAsCharSequenceTest {\n+\n+    private static final Random RAND = RandomFactory.getRandom();\n+    private static final int SIZE = RAND.nextInt(128, 1153);\n+\n+    private static char[] randomChars() {\n+        char[] chars = new char[SIZE];\n+        for (int i=0; i<SIZE; ++i) {\n+            chars[i] = (char) RAND.nextInt();\n+        }\n+        return chars;\n+    }\n+\n+    private static CharBuffer randomizeRange(CharBuffer cb) {\n+        int mid = cb.capacity() >>> 1;\n+        int start = RAND.nextInt(mid - 3); \/\/ from 0 to mid\n+        int end = RAND.nextInt(mid + 3, cb.capacity()); \/\/ from mid to capacity\n+        cb.position(start);\n+        cb.limit(end);\n+        return cb;\n+    }\n+\n+    private static void populateAndAddCases(String type, CharBuffer cb, List<Arguments> cases) {\n+        assert cb.position() == 0 && cb.limit() == cb.capacity();\n+        char[] buf = randomChars();\n+        cb.put(buf);\n+        cb.clear();\n+        addCases(type, buf, cb, cases);\n+    }\n+\n+    private static void addCases(String type, char[] buf, CharBuffer cb, List<Arguments> cases) {\n+        assert cb.position() == 0 && cb.limit() == cb.capacity();\n+        cases.add(Arguments.of(cb, buf, 0, buf.length, type + \" full\"));\n+\n+        CharBuffer rndRange = randomizeRange(cb.duplicate());\n+        cases.add(Arguments.of(rndRange, buf, rndRange.position(), rndRange.limit(), type + \"  at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+        cases.add(Arguments.of(rndRange.slice(), buf, rndRange.position(), rndRange.limit(), type + \" sliced at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+\n+        CharBuffer rndSlicedRange = randomizeRange(rndRange.slice());\n+        cases.add(Arguments.of(rndSlicedRange, buf, rndRange.position() + rndSlicedRange.position(), rndRange.position() + rndSlicedRange.limit(), type + \" sliced at \" + rndRange.position() + \" with position \" + rndSlicedRange.position() + \" and limit \" + rndSlicedRange.limit()));\n+    }\n+\n+    static List<Arguments> charBufferArguments() {\n+        List<Arguments> args = new ArrayList<>();\n+\n+        populateAndAddCases(\"HeapCharBuffer\", CharBuffer.allocate(SIZE), args);\n+        populateAndAddCases(\"BEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"LEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"BEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"LEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+\n+        char[] randomChars = randomChars();\n+        CharBuffer cb = CharBuffer.wrap(randomChars);\n+        addCases(\"StringCharBuffer over CharBuffer\", randomChars, CharBuffer.wrap(cb), args);\n+\n+        addCases(\"StringCharBuffer over String\", randomChars, CharBuffer.wrap(new String(randomChars)), args);\n+\n+        \/\/ nothing magic about 1273, it is just larger than 1k and an odd number - eliminating any alignment assumptions\n+        char[] buf = new char[1273];\n+        for (int i = 0; i < buf.length; ++i) {\n+            buf[i] = (char) i;\n+        }\n+        String stringBuf = new String(buf);\n+\n+        \/\/ nothing magic about 7, it is simply an odd number to advance - making sure no expectations of alignment\n+        \/\/ comparing to 29 results in 5 loops (0, 7, 14, 21, 28), giving decent coverage of offset and limits\n+        for (int i = 0; i < 29; i += 7) {\n+            CharBuffer buffer = CharBuffer.wrap(buf, i, buf.length - i);\n+            args.add(Arguments.of(buffer, buf, i, buf.length, \"HeapCharBuffer index \" + i + \" to end\"));\n+            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"HeapCharBuffer slice \" + i + \" to end\"));\n+\n+            args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - i)), buf, i, buf.length,\n+                    \"StringCharBuffer index \" + i + \" to end\"));\n+            buffer = CharBuffer.wrap(stringBuf);\n+            buffer.position(i);\n+            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"StringCharBuffer slice \" + i + \" to end\"));\n+\n+            CharBuffer lehbbAsCB = ByteBuffer.allocate(buf.length * 2)\n+                                             .order(ByteOrder.LITTLE_ENDIAN)\n+                                             .asCharBuffer()\n+                                             .put(buf)\n+                                             .position(i);\n+            args.add(Arguments.of(lehbbAsCB, buf, i, buf.length, \"LE HeapByteBuffer as CharBuffer index \" + i + \" to end\"));\n+\n+            CharBuffer behbdAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n+                                             .order(ByteOrder.BIG_ENDIAN)\n+                                             .asCharBuffer()\n+                                             .put(buf)\n+                                             .position(i);\n+            args.add(Arguments.of(behbdAsCB, buf, i, buf.length,\n+                    \"BE DirectByteBuffer as CharBuffer index \" + i + \" to end\"));\n+\n+            if (i > 0) {\n+                buffer = CharBuffer.wrap(buf, 1, buf.length - 1).slice();\n+                buffer.position(i - 1);\n+                args.add(Arguments.of(buffer, buf, i, buf.length,\n+                        \"HeapCharBuffer slice\/offset 1 index \" + (i - 1) + \" to end\"));\n+\n+                int end = buf.length - i;\n+\n+                buffer = CharBuffer.wrap(buf, i, buf.length - (2 * i));\n+                args.add(Arguments.of(buffer, buf, i, end, \"HeapCharBuffer index \" + i + \" to \" + end));\n+                args.add(Arguments.of(buffer.slice(), buf, i, end, \"HeapCharBuffer slice \" + i + \" to \" + end));\n+\n+                args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - (2 * i))), buf, i, end,\n+                        \"StringCharBuffer index \" + i + \" to \" + end));\n+                buffer = CharBuffer.wrap(stringBuf);\n+                buffer.position(i);\n+                buffer.limit(end);\n+                args.add(Arguments.of(buffer.slice(), buf, i, end, \"StringCharBuffer slice \" + i + \" to \" + end));\n+\n+                CharBuffer behbbAsCB = ByteBuffer.allocate(buf.length * 2)\n+                                                 .order(ByteOrder.BIG_ENDIAN)\n+                                                 .asCharBuffer()\n+                                                 .put(buf)\n+                                                 .position(1)\n+                                                 .slice()\n+                                                 .position(i - 1)\n+                                                 .limit(end - 1);\n+                args.add(Arguments.of(behbbAsCB, buf, i, buf.length - i, \"BE HeapByteBuffer as CharBuffer index \" + i + \" to \" + end));\n+\n+                CharBuffer ledbbAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n+                                                 .order(ByteOrder.LITTLE_ENDIAN)\n+                                                 .asCharBuffer()\n+                                                 .put(buf)\n+                                                 .position(1)\n+                                                 .slice()\n+                                                 .position(i - 1)\n+                                                 .limit(end - 1);\n+                args.add(Arguments.of(ledbbAsCB, buf, i, buf.length - i, \"LE DirectByteBuffer as CharBuffer index \" + i + \" to \" + end));\n+            }\n+        }\n+        return args;\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testToString(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertEquals(new String(expected, start, stop - start), actual.toString(), description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testLength(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertEquals(stop - start, actual.length(), description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsRange(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        int length = Math.min(10, stop - start - 1);\n+        actual.getChars(1, length + 1, val, 3);\n+\n+        for (int i = 0; i < length; ++i) {\n+            assertEquals(expected[i + start + 1], val[i + 3], \"val at offset of \" + i + \" from \" + description);\n+        }\n+        \/\/ test that calling getChars did not move the position\n+        assertEquals(expected[start], actual.charAt(0), \"first char after calling getChars: \" + description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsAll(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[stop - start];\n+        actual.getChars(0, val.length, val, 0);\n+\n+        for (int i = 0; i < val.length; ++i) {\n+            assertEquals(expected[i + start], val[i], \"val at offset of \" + i + \" from \" + description);\n+        }\n+        \/\/ test that calling getChars did not move the position\n+        assertEquals(expected[start], actual.charAt(0), \"first char after calling getChars: \" + description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeSourceBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(-1, 4, val, 1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeSourceEnd(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(0, -4, val, 1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsSourceEndBeforeBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(3, 2, val, 1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeDestBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 3, val, -1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsDestBegOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 4, val, val.length + 1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsDestLengthOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 4, val, val.length - 2));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNullDst(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(NullPointerException.class, () -> actual.getChars(0, 1, null, 0));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAt(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            assertEquals(expected[start + i], actual.charAt(i), \"chart at \" + i + \": \" + description);\n+        }\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAtNegativePos(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.charAt(-1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAtPosOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.charAt(stop - start + 1));\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testChars(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        OfInt chars = actual.chars().iterator();\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            assertEquals(expected[start + i], (char) chars.nextInt(), \"chart at \" + i + \": \" + description);\n+        }\n+        assertFalse(chars.hasNext(), \"chars has more elements than expected \" + description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testCodePoints(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        OfInt codePoints = actual.codePoints().iterator();\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            char c1 = expected[start + i];\n+            int expectedCodePoint = c1;\n+            if (Character.isHighSurrogate(c1) && (i + 1) < j) {\n+                char c2 = expected[start + i + 1];\n+                if (Character.isLowSurrogate(c2)) {\n+                    expectedCodePoint = Character.toCodePoint(c1, c2);\n+                    ++i;\n+                }\n+            }\n+            assertEquals(expectedCodePoint, codePoints.nextInt(), \"code point at \" + i + \": \" + description);\n+        }\n+        assertFalse(codePoints.hasNext(), \"codePoints has more elements than expected \" + description);\n+    }\n+\n+    @ParameterizedTest(name=\"{4}\")\n+    @MethodSource(\"charBufferArguments\")\n+    void testSubSequence(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        int maxTests = Math.min(7,  ((stop - start) >> 1) - 1);\n+        for (int i = 0; i < maxTests; ++i) {\n+            assertEquals(new String(expected, start + i, stop - start - (2 * i)),\n+                    actual.subSequence(i, actual.length() - i).toString(),\n+                    \"subsequence at index \" + i + \" for \" + description);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/Buffer\/CharBufferAsCharSequenceTest.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.CharBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Random;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\/**\n- * @test\n- * @bug 8343110 8361299\n- * @summary Check for expected behavior of CharBuffer.getChars().\n- * @run testng GetChars\n- * @key randomness\n- *\/\n-public class GetChars {\n-    private static CharBuffer CB = CharBuffer.wrap(\"Test\");\n-\n-    @Test\n-    public void testExactCopy() {\n-        var dst = new char[4];\n-        CB.getChars(0, 4, dst, 0);\n-        Assert.assertEquals(dst, new char[] {'T', 'e', 's', 't'});\n-    }\n-\n-    @Test\n-    public void testPartialCopy() {\n-        var dst = new char[2];\n-        CB.getChars(1, 3, dst, 0);\n-        Assert.assertEquals(dst, new char[] {'e', 's'});\n-    }\n-\n-    @Test\n-    public void testPositionedCopy() {\n-        var dst = new char[] {1, 2, 3, 4, 5, 6};\n-        CB.getChars(0, 4, dst, 1);\n-        Assert.assertEquals(dst, new char[] {1, 'T', 'e', 's', 't', 6});\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsNegative() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(-1, 3, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsNegationOfPosition() {\n-        CB.position(1);\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                            () -> {\n-                                try {\n-                                    CB.getChars(-1, 3, new char[4], 0);\n-                                } finally {\n-                                    CB.position(0);\n-                                }\n-                            });\n-    }\n-\n-    @Test\n-    public void testDstBeginIsNegative() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 4, new char[4], -1));\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsGreaterThanSrcEnd() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(4, 0, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testSrcEndIsGreaterThanSequenceLength() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 5, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testRequestedLengthIsGreaterThanDstLength() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 4, new char[3], 0));\n-    }\n-\n-    @Test\n-    public void testDstIsNull() {\n-        Assert.assertThrows(NullPointerException.class,\n-                () -> CB.getChars(0, 4, null, 0));\n-    }\n-\n-    private static final Random RAND = new Random();\n-    private static final int SIZE = 128 + RAND.nextInt(1024);\n-\n-    \/**\n-     * Randomize the char buffer's position and limit.\n-     *\/\n-    private static CharBuffer randomizeRange(CharBuffer cb) {\n-        int mid = cb.capacity() >>> 1;\n-        int start = RAND.nextInt(mid + 1); \/\/ from 0 to mid\n-        int end = mid + RAND.nextInt(cb.capacity() - mid + 1); \/\/ from mid to capacity\n-        cb.position(start);\n-        cb.limit(end);\n-        return cb;\n-    }\n-\n-    \/**\n-     * Randomize the char buffer's contents, position and limit.\n-     *\/\n-    private static CharBuffer randomize(CharBuffer cb) {\n-        while (cb.hasRemaining()) {\n-            cb.put((char)RAND.nextInt());\n-        }\n-        return randomizeRange(cb);\n-    }\n-\n-    \/**\n-     * Sums the remaining chars in the char buffer.\n-     *\/\n-    private static int intSum(CharBuffer cb) {\n-        int sum = 0;\n-        cb.mark();\n-        while (cb.hasRemaining()) {\n-            sum += cb.get();\n-        }\n-        cb.reset();\n-        return sum;\n-    }\n-\n-    \/**\n-     * Sums the chars in the char array.\n-     *\/\n-    private static int intSum(char[] ca) {\n-        int sum = 0;\n-        for (int i = 0; i < ca.length; i++)\n-            sum += ca[i];\n-        return sum;\n-    }\n-\n-    \/**\n-     * Creates char buffers to test, adding them to the given list.\n-     *\/\n-    private static void addCases(CharBuffer cb, List<CharBuffer> buffers) {\n-        randomize(cb);\n-        buffers.add(cb);\n-\n-        buffers.add(cb.slice());\n-        buffers.add(cb.duplicate());\n-        buffers.add(cb.asReadOnlyBuffer());\n-\n-        buffers.add(randomizeRange(cb.slice()));\n-        buffers.add(randomizeRange(cb.duplicate()));\n-        buffers.add(randomizeRange(cb.asReadOnlyBuffer()));\n-    }\n-\n-    @DataProvider(name = \"charbuffers\")\n-    public Object[][] createCharBuffers() {\n-        List<CharBuffer> buffers = new ArrayList<>();\n-\n-        \/\/ heap\n-        addCases(CharBuffer.allocate(SIZE), buffers);\n-        addCases(CharBuffer.wrap(new char[SIZE]), buffers);\n-        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n-                buffers);\n-        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n-                buffers);\n-\n-        \/\/ direct\n-        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n-                buffers);\n-        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n-                buffers);\n-\n-        \/\/ read-only buffer backed by a CharSequence\n-        buffers.add(CharBuffer.wrap(randomize(CharBuffer.allocate(SIZE))));\n-\n-        Object[][] params = new Object[buffers.size()][];\n-        for (int i = 0; i < buffers.size(); i++) {\n-            CharBuffer cb = buffers.get(i);\n-            params[i] = new Object[] { cb.getClass().getName(), cb };\n-        }\n-\n-        return params;\n-    }\n-\n-    @Test(dataProvider = \"charbuffers\")\n-    public void testGetChars(String type, CharBuffer cb) {\n-        System.out.format(\"%s position=%d, limit=%d%n\", type, cb.position(), cb.limit());\n-        int expected = intSum(cb);\n-        var dst = new char[cb.remaining()];\n-        cb.getChars(0, cb.remaining(), dst, 0);\n-        int actual = intSum(dst);\n-        assertEquals(actual, expected);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/Buffer\/GetChars.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"}]}