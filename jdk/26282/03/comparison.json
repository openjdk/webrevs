{"files":[{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.PrimitiveIterator.OfInt;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary tests the CharBuffer implementations behaving as CharSequence in various states (postion, limit, offset)\n+ * @run junit CharBufferAsCharSequenceTest\n+ *\/\n+public class CharBufferAsCharSequenceTest {\n+\n+    static List<Arguments> charBufferArguments() {\n+        List<Arguments> args = new ArrayList<>();\n+        char[] buf = new char[1273];\n+        for (int i = 0; i < buf.length; ++i) {\n+            buf[i] = (char) i;\n+        }\n+        String stringBuf = new String(buf);\n+\n+        for (int i = 0; i < 29; i += 7) {\n+            CharBuffer buffer = CharBuffer.wrap(buf, i, buf.length - i);\n+            args.add(Arguments.of(buffer, buf, i, buf.length, \"HeapCharBuffer index \" + i + \" to end\"));\n+            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"HeapCharBuffer slice \" + i + \" to end\"));\n+\n+            args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - i)), buf, i, buf.length,\n+                    \"StringCharBuffer index \" + i + \" to end\"));\n+            buffer = CharBuffer.wrap(stringBuf);\n+            buffer.position(i);\n+            args.add(Arguments.of(buffer.slice(), buf, i, buf.length, \"StringCharBuffer slice \" + i + \" to end\"));\n+\n+            CharBuffer lehbbAsCB = ByteBuffer.allocate(buf.length * 2)\n+                                             .order(ByteOrder.LITTLE_ENDIAN)\n+                                             .asCharBuffer()\n+                                             .put(buf)\n+                                             .position(i);\n+            args.add(Arguments.of(lehbbAsCB, buf, i, buf.length, \"LE HeapByteBuffer as CharBuffer index \" + i + \" to end\"));\n+\n+            CharBuffer behbdAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n+                                             .order(ByteOrder.BIG_ENDIAN)\n+                                             .asCharBuffer()\n+                                             .put(buf)\n+                                             .position(i);\n+            args.add(Arguments.of(behbdAsCB, buf, i, buf.length,\n+                    \"BE DirectByteBuffer as CharBuffer index \" + i + \" to end\"));\n+\n+            if (i > 0) {\n+                buffer = CharBuffer.wrap(buf, 1, buf.length - 1).slice();\n+                buffer.position(i - 1);\n+                args.add(Arguments.of(buffer, buf, i, buf.length,\n+                        \"HeapCharBuffer slice\/offset 1 index \" + (i - 1) + \" to end\"));\n+\n+                int end = buf.length - i;\n+\n+                buffer = CharBuffer.wrap(buf, i, buf.length - (2 * i));\n+                args.add(Arguments.of(buffer, buf, i, end, \"HeapCharBuffer index \" + i + \" to \" + end));\n+                args.add(Arguments.of(buffer.slice(), buf, i, end, \"HeapCharBuffer slice \" + i + \" to \" + end));\n+\n+                args.add(Arguments.of(CharBuffer.wrap(new String(buf, i, buf.length - (2 * i))), buf, i, end,\n+                        \"StringCharBuffer index \" + i + \" to \" + end));\n+                buffer = CharBuffer.wrap(stringBuf);\n+                buffer.position(i);\n+                buffer.limit(end);\n+                args.add(Arguments.of(buffer.slice(), buf, i, end, \"StringCharBuffer slice \" + i + \" to \" + end));\n+\n+                CharBuffer behbbAsCB = ByteBuffer.allocate(buf.length * 2)\n+                                                 .order(ByteOrder.BIG_ENDIAN)\n+                                                 .asCharBuffer()\n+                                                 .put(buf)\n+                                                 .position(1)\n+                                                 .slice()\n+                                                 .position(i - 1)\n+                                                 .limit(end - 1);\n+                args.add(Arguments.of(behbbAsCB, buf, i, buf.length - i, \"BE HeapByteBuffer as CharBuffer index \" + i + \" to \" + end));\n+\n+                CharBuffer ledbbAsCB = ByteBuffer.allocateDirect(buf.length * 2)\n+                                                 .order(ByteOrder.LITTLE_ENDIAN)\n+                                                 .asCharBuffer()\n+                                                 .put(buf)\n+                                                 .position(1)\n+                                                 .slice()\n+                                                 .position(i - 1)\n+                                                 .limit(end - 1);\n+                args.add(Arguments.of(ledbbAsCB, buf, i, buf.length - i, \"LE DirectByteBuffer as CharBuffer index \" + i + \" to \" + end));\n+            }\n+        }\n+        return args;\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testToString(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertEquals(new String(expected, start, stop - start), actual.toString(), description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testLength(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertEquals(stop - start, actual.length(), description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsRange(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        actual.getChars(1, 5, val, 3);\n+\n+        for (int i = 0; i < 4; ++i) {\n+            assertEquals(expected[i + start + 1], val[i + 3], \"val at offset of \" + i + \" from \" + description);\n+        }\n+        \/\/ test that calling getChars did not move the position\n+        assertEquals(expected[start], actual.charAt(0), \"first char after calling getChars: \" + description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsAll(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[stop - start];\n+        actual.getChars(0, val.length, val, 0);\n+\n+        for (int i = 0; i < val.length; ++i) {\n+            assertEquals(expected[i + start], val[i], \"val at offset of \" + i + \" from \" + description);\n+        }\n+        \/\/ test that calling getChars did not move the position\n+        assertEquals(expected[start], actual.charAt(0), \"first char after calling getChars: \" + description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeSourceBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(-1, 4, val, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeSourceEnd(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(0, -4, val, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsSourceEndBeforeBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(3, 2, val, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNegativeDestBeg(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 3, val, -1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsDestBegOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 4, val, val.length + 1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsDestLengthOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        char[] val = new char[16];\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.getChars(1, 4, val, val.length - 2));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAt(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            assertEquals(expected[start + i], actual.charAt(i), \"chart at \" + i + \": \" + description);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAtNegativePos(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.charAt(-1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testCharAtPosOOB(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> actual.charAt(stop - start + 1));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testChars(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        OfInt chars = actual.chars().iterator();\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            assertEquals(expected[start + i], (char) chars.nextInt(), \"chart at \" + i + \": \" + description);\n+        }\n+        assertFalse(chars.hasNext(), \"chars has more elements than expected \" + description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testCodePoints(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        OfInt codePoints = actual.codePoints().iterator();\n+        for (int i = 0, j = stop - start; i < j; ++i) {\n+            char c1 = expected[start + i];\n+            int expectedCodePoint = c1;\n+            if (Character.isHighSurrogate(c1) && (i + 1) < j) {\n+                char c2 = expected[i + 1];\n+                if (Character.isLowSurrogate(c2)) {\n+                    expectedCodePoint = Character.toCodePoint(c1, c2);\n+                    ++i;\n+                }\n+            }\n+            assertEquals(expectedCodePoint, codePoints.nextInt(), \"code point at \" + i + \": \" + description);\n+        }\n+        assertFalse(codePoints.hasNext(), \"codePoints has more elements than expected \" + description);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testSubSequence(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        for (int i = 0; i < 7; ++i) {\n+            assertEquals(new String(expected, start + i, stop - start - (2 * i)),\n+                    actual.subSequence(i, actual.length() - i).toString(),\n+                    \"subsequence at index \" + i + \" for \" + description);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/Buffer\/CharBufferAsCharSequenceTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"}]}