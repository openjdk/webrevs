{"files":[{"patch":"@@ -30,0 +30,3 @@\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n@@ -41,0 +44,3 @@\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -46,0 +52,40 @@\n+    private static final Random RAND = RandomFactory.getRandom();\n+    private static final int SIZE = 128 + RAND.nextInt(1024);\n+\n+    private static char[] randomChars() {\n+        char[] chars = new char[SIZE];\n+        for (int i=0; i<SIZE; ++i) {\n+            chars[i] = (char) RAND.nextInt();\n+        }\n+        return chars;\n+    }\n+\n+    private static CharBuffer randomizeRange(CharBuffer cb) {\n+        int mid = cb.capacity() >>> 1;\n+        int start = RAND.nextInt(mid + 1); \/\/ from 0 to mid\n+        int end = mid + RAND.nextInt(cb.capacity() - mid + 1); \/\/ from mid to capacity\n+        cb.position(start);\n+        cb.limit(end);\n+        return cb;\n+    }\n+\n+    private static void populateAndAddCases(String type, CharBuffer cb, List<Arguments> cases) {\n+        assert cb.position() == 0 && cb.limit() == cb.capacity();\n+        char[] buf = randomChars();\n+        cb.put(buf);\n+        cb.clear();\n+        addCases(type, buf, cb, cases);\n+    }\n+\n+    private static void addCases(String type, char[] buf, CharBuffer cb, List<Arguments> cases) {\n+        assert cb.position() == 0 && cb.limit() == cb.capacity();\n+        cases.add(Arguments.of(cb, buf, 0, buf.length, type + \" full\"));\n+\n+        CharBuffer rndRange = randomizeRange(cb.duplicate());\n+        cases.add(Arguments.of(rndRange, buf, rndRange.position(), rndRange.limit(), type + \"  at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+        cases.add(Arguments.of(rndRange.slice(), buf, rndRange.position(), rndRange.limit(), type + \" sliced at \" + rndRange.position() + \" through \" + rndRange.limit()));\n+\n+        CharBuffer rndSlicedRange = randomizeRange(rndRange.slice());\n+        cases.add(Arguments.of(rndSlicedRange, buf, rndRange.position() + rndSlicedRange.position(), rndRange.position() + rndSlicedRange.limit(), type + \" sliced at \" + rndRange.position() + \" with position \" + rndSlicedRange.position() + \" and limit \" + rndSlicedRange.limit()));\n+    }\n+\n@@ -48,0 +94,13 @@\n+\n+        populateAndAddCases(\"HeapCharBuffer\", CharBuffer.allocate(SIZE), args);\n+        populateAndAddCases(\"BEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"LEHeapByteBuffer\", ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"BEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(), args);\n+        populateAndAddCases(\"LEDirectByteBuffer\", ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(), args);\n+\n+        char[] randomChars = randomChars();\n+        CharBuffer cb = CharBuffer.wrap(randomChars);\n+        addCases(\"StringCharBuffer over CharBuffer\", randomChars, CharBuffer.wrap(cb), args);\n+\n+        addCases(\"StringCharBuffer over String\", randomChars, CharBuffer.wrap(new String(randomChars)), args);\n+\n@@ -203,0 +262,6 @@\n+    @ParameterizedTest\n+    @MethodSource(\"charBufferArguments\")\n+    void testGetCharsNullDst(CharSequence actual, char[] expected, int start, int stop, String description) {\n+        assertThrows(NullPointerException.class, () -> actual.getChars(1, 4, null, 0));\n+    }\n+\n@@ -241,1 +306,1 @@\n-                char c2 = expected[i + 1];\n+                char c2 = expected[start + i + 1];\n","filename":"test\/jdk\/java\/nio\/Buffer\/CharBufferAsCharSequenceTest.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"}]}