{"files":[{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.CharBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Random;\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\/**\n- * @test\n- * @bug 8343110 8361299\n- * @summary Check for expected behavior of CharBuffer.getChars().\n- * @run testng GetChars\n- * @key randomness\n- *\/\n-public class GetChars {\n-    private static CharBuffer CB = CharBuffer.wrap(\"Test\");\n-\n-    @Test\n-    public void testExactCopy() {\n-        var dst = new char[4];\n-        CB.getChars(0, 4, dst, 0);\n-        Assert.assertEquals(dst, new char[] {'T', 'e', 's', 't'});\n-    }\n-\n-    @Test\n-    public void testPartialCopy() {\n-        var dst = new char[2];\n-        CB.getChars(1, 3, dst, 0);\n-        Assert.assertEquals(dst, new char[] {'e', 's'});\n-    }\n-\n-    @Test\n-    public void testPositionedCopy() {\n-        var dst = new char[] {1, 2, 3, 4, 5, 6};\n-        CB.getChars(0, 4, dst, 1);\n-        Assert.assertEquals(dst, new char[] {1, 'T', 'e', 's', 't', 6});\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsNegative() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(-1, 3, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsNegationOfPosition() {\n-        CB.position(1);\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                            () -> {\n-                                try {\n-                                    CB.getChars(-1, 3, new char[4], 0);\n-                                } finally {\n-                                    CB.position(0);\n-                                }\n-                            });\n-    }\n-\n-    @Test\n-    public void testDstBeginIsNegative() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 4, new char[4], -1));\n-    }\n-\n-    @Test\n-    public void testSrcBeginIsGreaterThanSrcEnd() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(4, 0, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testSrcEndIsGreaterThanSequenceLength() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 5, new char[4], 0));\n-    }\n-\n-    @Test\n-    public void testRequestedLengthIsGreaterThanDstLength() {\n-        Assert.assertThrows(IndexOutOfBoundsException.class,\n-                () -> CB.getChars(0, 4, new char[3], 0));\n-    }\n-\n-    @Test\n-    public void testDstIsNull() {\n-        Assert.assertThrows(NullPointerException.class,\n-                () -> CB.getChars(0, 4, null, 0));\n-    }\n-\n-    private static final Random RAND = new Random();\n-    private static final int SIZE = 128 + RAND.nextInt(1024);\n-\n-    \/**\n-     * Randomize the char buffer's position and limit.\n-     *\/\n-    private static CharBuffer randomizeRange(CharBuffer cb) {\n-        int mid = cb.capacity() >>> 1;\n-        int start = RAND.nextInt(mid + 1); \/\/ from 0 to mid\n-        int end = mid + RAND.nextInt(cb.capacity() - mid + 1); \/\/ from mid to capacity\n-        cb.position(start);\n-        cb.limit(end);\n-        return cb;\n-    }\n-\n-    \/**\n-     * Randomize the char buffer's contents, position and limit.\n-     *\/\n-    private static CharBuffer randomize(CharBuffer cb) {\n-        while (cb.hasRemaining()) {\n-            cb.put((char)RAND.nextInt());\n-        }\n-        return randomizeRange(cb);\n-    }\n-\n-    \/**\n-     * Sums the remaining chars in the char buffer.\n-     *\/\n-    private static int intSum(CharBuffer cb) {\n-        int sum = 0;\n-        cb.mark();\n-        while (cb.hasRemaining()) {\n-            sum += cb.get();\n-        }\n-        cb.reset();\n-        return sum;\n-    }\n-\n-    \/**\n-     * Sums the chars in the char array.\n-     *\/\n-    private static int intSum(char[] ca) {\n-        int sum = 0;\n-        for (int i = 0; i < ca.length; i++)\n-            sum += ca[i];\n-        return sum;\n-    }\n-\n-    \/**\n-     * Creates char buffers to test, adding them to the given list.\n-     *\/\n-    private static void addCases(CharBuffer cb, List<CharBuffer> buffers) {\n-        randomize(cb);\n-        buffers.add(cb);\n-\n-        buffers.add(cb.slice());\n-        buffers.add(cb.duplicate());\n-        buffers.add(cb.asReadOnlyBuffer());\n-\n-        buffers.add(randomizeRange(cb.slice()));\n-        buffers.add(randomizeRange(cb.duplicate()));\n-        buffers.add(randomizeRange(cb.asReadOnlyBuffer()));\n-    }\n-\n-    @DataProvider(name = \"charbuffers\")\n-    public Object[][] createCharBuffers() {\n-        List<CharBuffer> buffers = new ArrayList<>();\n-\n-        \/\/ heap\n-        addCases(CharBuffer.allocate(SIZE), buffers);\n-        addCases(CharBuffer.wrap(new char[SIZE]), buffers);\n-        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n-                buffers);\n-        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n-                buffers);\n-\n-        \/\/ direct\n-        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n-                buffers);\n-        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n-                buffers);\n-\n-        \/\/ read-only buffer backed by a CharSequence\n-        buffers.add(CharBuffer.wrap(randomize(CharBuffer.allocate(SIZE))));\n-\n-        Object[][] params = new Object[buffers.size()][];\n-        for (int i = 0; i < buffers.size(); i++) {\n-            CharBuffer cb = buffers.get(i);\n-            params[i] = new Object[] { cb.getClass().getName(), cb };\n-        }\n-\n-        return params;\n-    }\n-\n-    @Test(dataProvider = \"charbuffers\")\n-    public void testGetChars(String type, CharBuffer cb) {\n-        System.out.format(\"%s position=%d, limit=%d%n\", type, cb.position(), cb.limit());\n-        int expected = intSum(cb);\n-        var dst = new char[cb.remaining()];\n-        cb.getChars(0, cb.remaining(), dst, 0);\n-        int actual = intSum(dst);\n-        assertEquals(actual, expected);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/Buffer\/GetChars.java","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"}]}