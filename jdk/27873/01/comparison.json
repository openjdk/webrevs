{"files":[{"patch":"@@ -109,1 +109,1 @@\n-        app = normalizeAppImageLayout(app);\n+        app = copyWithUnresolvedAppImageLayout(app);\n@@ -246,1 +246,1 @@\n-    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+    private static MacApplication copyWithUnresolvedAppImageLayout(MacApplication app) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass());\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n@@ -125,1 +125,1 @@\n-            final var appImageFileExtras = new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params));\n+            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,3 @@\n+\n+        externalApp = Objects.requireNonNull(app);\n+\n@@ -115,0 +118,13 @@\n+    Optional<ExternalApplication> externalApplication() {\n+        return Optional.ofNullable(externalApp);\n+    }\n+\n+    Optional<String> mainLauncherClassName() {\n+        return launchers()\n+                .map(ApplicationLaunchers::mainLauncher)\n+                .flatMap(Launcher::startupInfo)\n+                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n+                    return externalApplication().map(ExternalApplication::getMainClass);\n+                });\n+    }\n+\n@@ -211,0 +227,1 @@\n+    private ExternalApplication externalApp;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n@@ -48,1 +46,1 @@\n-        Files.createDirectories(getParent(destFile));\n+        Files.createDirectories(destFile.getParent());\n@@ -55,20 +53,0 @@\n-    public static boolean exists(Path path) {\n-        if (path == null) {\n-            return false;\n-        }\n-\n-        return Files.exists(path);\n-    }\n-\n-    \/\/ run \"launcher paramfile\" in the directory where paramfile is kept\n-    public static void run(String launcher, Path paramFile)\n-            throws IOException {\n-        if (IOUtils.exists(paramFile)) {\n-            ProcessBuilder pb =\n-                    new ProcessBuilder(launcher,\n-                        getFileName(paramFile).toString());\n-            pb = pb.directory(getParent(paramFile).toFile());\n-            exec(pb);\n-        }\n-    }\n-\n@@ -86,15 +64,0 @@\n-    \/\/ See JDK-8236282\n-    \/\/ Reading output from some processes (currently known \"hdiutil attach\")\n-    \/\/ might hang even if process already exited. Only possible workaround found\n-    \/\/ in \"hdiutil attach\" case is to redirect the output to a temp file and then\n-    \/\/ read this file back.\n-    public static void exec(ProcessBuilder pb, boolean writeOutputToFile)\n-            throws IOException {\n-        exec(pb, false, null, writeOutputToFile, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer) throws IOException {\n-        exec(pb, testForPresenceOnly, consumer, false, Executor.INFINITE_TIMEOUT);\n-    }\n-\n@@ -130,45 +93,0 @@\n-    public static int getProcessOutput(List<String> result, String... args)\n-            throws IOException, InterruptedException {\n-\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-\n-        final Process p = pb.start();\n-\n-        List<String> list = new ArrayList<>();\n-\n-        final BufferedReader in =\n-                new BufferedReader(new InputStreamReader(p.getInputStream()));\n-        final BufferedReader err =\n-                new BufferedReader(new InputStreamReader(p.getErrorStream()));\n-\n-        Thread t = new Thread(() -> {\n-            try {\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    list.add(line);\n-                }\n-            } catch (IOException ioe) {\n-                Log.verbose(ioe);\n-            }\n-\n-            try {\n-                String line;\n-                while ((line = err.readLine()) != null) {\n-                    Log.error(line);\n-                }\n-            } catch (IOException ioe) {\n-                  Log.verbose(ioe);\n-            }\n-        });\n-        t.setDaemon(true);\n-        t.start();\n-\n-        int ret = p.waitFor();\n-        Log.verbose(pb.command(), list, ret, IOUtils.getPID(p));\n-\n-        result.clear();\n-        result.addAll(list);\n-\n-        return ret;\n-    }\n-\n@@ -191,22 +109,0 @@\n-    public static Path getParent(Path p) {\n-        Path parent = p.getParent();\n-        if (parent == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return parent;\n-    }\n-\n-    public static Path getFileName(Path p) {\n-        Path filename = p.getFileName();\n-        if (filename == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return filename;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":105,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -28,0 +29,1 @@\n+import java.io.IOException;\n@@ -35,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -96,0 +99,46 @@\n+    \/**\n+     * Returns a list of paths that includes the location where the \"java.base\"\n+     * module can be found.\n+     * <p>\n+     * Returns the specified path list if \"java.base\" module can be found in one of\n+     * the paths from the specified path list.\n+     * <p>\n+     * Returns a new path list created from the specified path list with the path of\n+     * \"java.base\" module in the current runtime appended otherwise.\n+     *\n+     * @param modulePath the path list where to look up for \"java.base\" module\n+     * @return the path list that includes location of \"java.base\" module\n+     *\/\n+    static List<Path> ensureBaseModuleInModulePath(List<Path> modulePath) {\n+        if (modulePath.stream().anyMatch(path -> {\n+            return Files.isRegularFile(path.resolve(\"java.base.jmod\"));\n+        })) {\n+            return modulePath;\n+        } else {\n+            \/\/ There is no \"java.base.jmod\" file in the `modulePath` path list.\n+            \/\/ Pick items from the default module path list that are not yet\n+            \/\/ in the `modulePath` path list and append them to it.\n+\n+            var missingDefaultModulePath = getDefaultModulePath();\n+\n+            if (!modulePath.isEmpty()) {\n+                missingDefaultModulePath.stream().filter(defaultPath -> {\n+                    return modulePath.stream().anyMatch(path -> {\n+                        try {\n+                            return Files.isSameFile(path, defaultPath);\n+                        } catch (IOException ex) {\n+                            \/\/ Assume `defaultPath` path doesn't exist in `modulePath` list.\n+                            return false;\n+                        }\n+                    });\n+                }).toList();\n+            }\n+\n+            if (missingDefaultModulePath.isEmpty()) {\n+                return modulePath;\n+            } else {\n+                return Stream.of(modulePath, missingDefaultModulePath).flatMap(Collection::stream).toList();\n+            }\n+        }\n+    }\n+\n@@ -233,1 +282,1 @@\n-    };\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -183,0 +184,9 @@\n+    Source probe() {\n+        try {\n+            return saveToStream(null);\n+        } catch (IOException ex) {\n+            \/\/ Should never happen.\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OverridableResource.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -59,1 +58,0 @@\n-    private static final String JAVABASEJMOD = \"java.base.jmod\";\n@@ -418,1 +416,1 @@\n-                    p -> getDefaultModulePath(),\n+                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n@@ -423,20 +421,1 @@\n-                        Path javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-\n-                        \/\/ Add the default JDK module path to the module path.\n-                        if (javaBasePath == null) {\n-                            List<Path> jdkModulePath = getDefaultModulePath();\n-\n-                            if (jdkModulePath != null) {\n-                                modulePath = Stream.concat(modulePath.stream(),\n-                                        jdkModulePath.stream()).toList();\n-                                javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-                            }\n-                        }\n-\n-                        if (javaBasePath == null ||\n-                                !Files.exists(javaBasePath)) {\n-                            Log.error(String.format(I18N.getString(\n-                                    \"warning.no.jdk.modules.found\")));\n-                        }\n-\n-                        return modulePath;\n+                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n@@ -445,14 +424,0 @@\n-    \/\/ Returns the path to the JDK modules in the user defined module path.\n-    private static Path findPathOfModule( List<Path> modulePath, String moduleName) {\n-\n-        for (Path path : modulePath) {\n-            Path moduleNamePath = path.resolve(moduleName);\n-\n-            if (Files.exists(moduleNamePath)) {\n-                return path;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":2,"deletions":37,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public static Optional<ApplicationLaunchers> fromList(List<Launcher> launchers) {\n+    public static Optional<ApplicationLaunchers> fromList(List<? extends Launcher> launchers) {\n@@ -65,1 +65,1 @@\n-                    launchers.subList(1, launchers.size())));\n+                    List.copyOf(launchers.subList(1, launchers.size()))));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLaunchers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.module.ModuleFinder;\n@@ -49,1 +50,7 @@\n-     * Gets the default set of paths where to find Java modules.\n+     * Gets the default set of paths where jlink should look up for system Java\n+     * modules.\n+     *\n+     * <p>\n+     * These paths are for {@code jlink} command. Using them with\n+     * {@link ModuleFinder#of(Path...)} may not work as expected: attempt to find\n+     * \"java.base\" module in these paths will fail.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-warning.no.jdk.modules.found=Warning: No JDK Modules found\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                return IOUtils.getFileName(path).toString();\n+                return path.getFileName().toString();\n@@ -528,1 +528,1 @@\n-                IOUtils.getFileName(launcherPath), \"\").toString();\n+                launcherPath.getFileName(), \"\").toString();\n@@ -715,1 +715,1 @@\n-            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n+            xml.writeAttribute(\"Name\", dir.getFileName().toString());\n@@ -821,1 +821,1 @@\n-                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n+                if (src.getFileName().toString().endsWith(\".ico\")) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        Files.createDirectories(IOUtils.getParent(msi));\n+        Files.createDirectories(msi.getParent());\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-            Files.createDirectories(IOUtils.getParent(resourceSaveAsFile));\n+            Files.createDirectories(resourceSaveAsFile.getParent());\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourceConverter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}