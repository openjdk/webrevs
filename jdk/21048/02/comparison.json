{"files":[{"patch":"@@ -239,1 +239,1 @@\n-  if (Arguments::is_internal_module_property(key)) {\n+  if (Arguments::is_internal_module_property(key) && !Arguments::is_module_path_property(key)) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,1 +784,1 @@\n-      return true;\n+      return false;\n@@ -789,1 +789,1 @@\n-  return false;\n+  return true;\n@@ -813,1 +813,1 @@\n-  bool mismatch = false;\n+  bool match = true;\n@@ -826,1 +826,1 @@\n-        mismatch = true;\n+        match = false;\n@@ -843,1 +843,1 @@\n-      mismatch = check_paths(1, num, rp_array, 0, 0);\n+      match = check_paths(1, num, rp_array, 0, 0);\n@@ -848,1 +848,1 @@\n-      mismatch = true;\n+      match = false;\n@@ -852,1 +852,1 @@\n-  if (mismatch) {\n+  if (!match) {\n@@ -863,1 +863,1 @@\n-  bool mismatch = false;\n+  bool match = false;\n@@ -892,2 +892,2 @@\n-    mismatch = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n-    if (mismatch) {\n+    match = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n+    if (!match) {\n@@ -904,1 +904,1 @@\n-        mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+        match = check_paths(j, shared_app_paths_len, rp_array,\n@@ -907,1 +907,1 @@\n-      if (mismatch) {\n+      if (!match) {\n@@ -929,0 +929,9 @@\n+void FileMapInfo::extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths) {\n+  GrowableArray<const char*>* path_array = create_path_array(runtime_path);\n+  int num_paths = path_array->length();\n+  for (int i = 0; i < num_paths; i++) {\n+    const char* name = path_array->at(i);\n+    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n+  }\n+}\n+\n@@ -930,3 +939,7 @@\n-  const char* rp = Arguments::get_property(\"jdk.module.path\");\n-  int num_paths = CDSConfig::num_archives(rp);\n-  if (num_paths != header()->num_module_paths()) {\n+  const char* runtime_path = Arguments::get_property(\"jdk.module.path\");\n+  int archived_num_module_paths = header()->num_module_paths();\n+  if (runtime_path == nullptr && archived_num_module_paths == 0) {\n+    return true;\n+  }\n+  if ((runtime_path == nullptr && archived_num_module_paths > 0) ||\n+      (runtime_path != nullptr && archived_num_module_paths == 0)) {\n@@ -936,2 +949,9 @@\n-  GrowableArray<const char*>* rp_array = create_path_array(rp);\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array, 0, 0);\n+  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(3);\n+  extract_module_paths(runtime_path, module_paths);\n+  int num_paths = module_paths->length();\n+  if (num_paths != archived_num_module_paths) {\n+    return false;\n+  }\n+  \/\/ module paths are stored in sorted order in the CDS archive.\n+  module_paths->sort(ClassLoaderExt::compare_module_path_by_name);\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, module_paths, 0, 0);\n@@ -947,0 +967,10 @@\n+\n+  bool matched_module_paths = true;\n+  if (CDSConfig::is_dumping_dynamic_archive() || header()->has_full_module_graph()) {\n+    matched_module_paths = check_module_paths();\n+  }\n+  if (header()->has_full_module_graph() && !matched_module_paths) {\n+    CDSConfig::stop_using_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled because mismatched module paths\");\n+  }\n+\n@@ -962,1 +992,1 @@\n-      if (!check_module_paths()) {\n+      if (!matched_module_paths) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  bool has_full_module_graph()             const { return _has_full_module_graph; }\n@@ -557,0 +558,1 @@\n+  void  extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -876,0 +878,10 @@\n+  ResourceMark rm(THREAD);\n+  if ((strcmp(k->name()->as_C_string(), \"jdk\/internal\/module\/ArchivedModuleGraph\") == 0) &&\n+      !CDSConfig::is_using_optimized_module_handling() &&\n+      \/\/ archive was created with --module-path\n+      ClassLoaderExt::num_module_paths() > 0) {\n+    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+    return;\n+  }\n+\n@@ -1124,0 +1136,7 @@\n+    if (log_is_enabled(Trace, cds, heap)) {\n+      WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+      if (walker != nullptr) {\n+        LogStream ls(Log(cds, heap)::trace());\n+        CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+        ClassLoaderExt::init_num_module_paths(info->header()->num_module_paths());\n@@ -794,0 +795,3 @@\n+  } else {\n+    log_info(cds)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -582,0 +582,1 @@\n+    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+int ClassLoaderExt::_num_module_paths = 0;\n@@ -92,0 +93,4 @@\n+int ClassLoaderExt::compare_module_path_by_name(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n@@ -94,1 +99,1 @@\n-  GrowableArray<char*>* module_paths = new GrowableArray<char*>(5);\n+  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(5);\n@@ -98,1 +103,1 @@\n-    GrowableArray<char*>* _module_paths;\n+    GrowableArray<const char*>* _module_paths;\n@@ -100,1 +105,1 @@\n-    ModulePathsGatherer(JavaThread* current, GrowableArray<char*>* module_paths) :\n+    ModulePathsGatherer(JavaThread* current, GrowableArray<const char*>* module_paths) :\n@@ -106,3 +111,1 @@\n-        char* path_copy = NEW_RESOURCE_ARRAY(char, strlen(path) + 1);\n-        strcpy(path_copy, path);\n-        _module_paths->append(path_copy);\n+        extract_jar_files_from_path(path, _module_paths);\n@@ -119,0 +122,4 @@\n+  \/\/ Sort the module paths before storing into CDS archive for simpler\n+  \/\/ checking during runtime.\n+  module_paths->sort(compare_module_path_by_name);\n+\n@@ -134,0 +141,28 @@\n+bool ClassLoaderExt::has_jar_suffix(const char* filename) {\n+  const char* dot = strrchr(filename, '.');\n+  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void ClassLoaderExt::extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths) {\n+  DIR* dirp = os::opendir(path);\n+  if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n+    module_paths->append(path);\n+  } else {\n+    struct dirent* dentry;\n+    while ((dentry = os::readdir(dirp)) != nullptr) {\n+      const char* file_name = dentry->d_name;\n+      if (has_jar_suffix(file_name)) {\n+        size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n+        char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n+        int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n+        assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n+        module_paths->append(full_name);\n+      }\n+    }\n+    os::closedir(dirp);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":41,"deletions":6,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  \/\/ number of module paths\n+  static int _num_module_paths;\n@@ -62,0 +64,1 @@\n+  static bool has_jar_suffix(const char* filename);\n@@ -71,0 +74,2 @@\n+  static void extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths);\n+  static int compare_module_path_by_name(const char** p1, const char** p2);\n@@ -90,0 +95,2 @@\n+  static int num_module_paths() { return _num_module_paths; }\n+\n@@ -102,0 +109,4 @@\n+  static void init_num_module_paths(int num_module_paths) {\n+    _num_module_paths = num_module_paths;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -339,0 +339,11 @@\n+\/\/ Return true if the key matches the --module-path property name (\"jdk.module.path\").\n+bool Arguments::is_module_path_property(const char* key) {\n+  if (strncmp(key, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+    const char* property_suffix = key + MODULE_PROPERTY_PREFIX_LEN;\n+    if (matches_property_suffix(property_suffix, PATH, PATH_LEN)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+  static bool is_module_path_property(const char* key);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1088,0 +1088,6 @@\n+\n+    \/\/ Called during -Xshare:dump from AppClassLoader.resetArchivedStates().\n+    void resetArchivedStatesForAppClassLoader() {\n+        setClassPath(null);\n+        if (!moduleToReader.isEmpty()) moduleToReader.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BuiltinClassLoader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            setClassPath(null);\n+            resetArchivedStatesForAppClassLoader();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ClassLoaders.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -142,1 +143,0 @@\n-               getProperty(\"jdk.module.path\") == null &&\n@@ -206,1 +206,2 @@\n-        boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);\n+        boolean haveUpgradeModulePath = (upgradeModulePath != null);\n+        boolean haveModulePath = (appModulePath != null || haveUpgradeModulePath);\n@@ -466,1 +467,4 @@\n-        if (CDS.isDumpingStaticArchive() && !haveModulePath && addModules.isEmpty()) {\n+        if (CDS.isDumpingStaticArchive()\n+                && !haveUpgradeModulePath\n+                && addModules.isEmpty()\n+                && allJrtOrModularJar(cf)) {\n@@ -473,5 +477,5 @@\n-                                        hasIncubatorModules,\n-                                        systemModuleFinder,\n-                                        cf,\n-                                        clf,\n-                                        mainModule);\n+                    hasIncubatorModules,\n+                    systemModuleFinder,\n+                    cf,\n+                    clf,\n+                    mainModule);\n@@ -513,0 +517,23 @@\n+    \/**\n+     * Returns true if all modules in the configuration are in the run-time image or\n+     * modular JAR files.\n+     *\/\n+    private static boolean allJrtOrModularJar(Configuration cf) {\n+        return !cf.modules().stream()\n+                .map(m -> m.reference().location().orElseThrow())\n+                .anyMatch(uri -> !uri.getScheme().equalsIgnoreCase(\"jrt\")\n+                        && !isJarFile(uri));\n+    }\n+\n+    \/**\n+     * Returns true if the given URI locates a jar file on the file system.\n+     *\/\n+    private static boolean isJarFile(URI uri) {\n+        if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            Path path = Path.of(uri);\n+            return path.toString().endsWith(\".jar\") && Files.isRegularFile(path);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -94,2 +94,13 @@\n-        Supplier<ModuleReader> supplier = () -> new JarModuleReader(file, uri);\n-        HashSupplier hasher = (a) -> ModuleHashes.computeHash(supplier, a);\n+        String fileString = file.toString();\n+        Supplier<ModuleReader> supplier = new Supplier<>() {\n+            @Override\n+            public ModuleReader get() {\n+                return new JarModuleReader(fileString, uri);\n+            }\n+        };\n+        HashSupplier hasher = new HashSupplier() {\n+            @Override\n+            public byte[] generate(String algorithm) {\n+              return ModuleHashes.computeHash(supplier, algorithm);\n+            }\n+        };\n@@ -225,1 +236,1 @@\n-        static JarFile newJarFile(Path path) {\n+        static JarFile newJarFile(String path) {\n@@ -227,1 +238,1 @@\n-                return new JarFile(new File(path.toString()),\n+                return new JarFile(new File(path),\n@@ -236,1 +247,1 @@\n-        JarModuleReader(Path path, URI uri) {\n+        JarModuleReader(String path, URI uri) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -440,0 +440,2 @@\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,2 +216,4 @@\n-            .assertAbnormalExit(output -> {\n-                output.shouldMatch(\"Error: non-empty directory.*com.simple\");\n+            \/\/ After JDK-8328313, non-empty module path directory won't be included\n+            \/\/ in the shared paths table.\n+            .assertNormalExit(output -> {\n+                output.shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,2 +197,4 @@\n-        output.shouldHaveExitValue(1)\n-              .shouldMatch(\"Error: non-empty directory.*com.simple\");\n+        \/\/ After JDK-8328313, non-empty module path directory won't be included\n+        \/\/ in the shared paths table.\n+        output.shouldHaveExitValue(0)\n+              .shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8328313\n+ * @requires vm.cds & !vm.graal.enabled & vm.cds.write.archived.java.heap\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver ModulePathAndFMG\n+ * @summary test module path changes for full module graph handling.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ModulePathAndFMG {\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+    private static final Path MODS_DIR = Paths.get(\"mody\");\n+\n+    \/\/ the module name of the test module\n+    private static final String MAIN_MODULE = \"com.bars\";\n+    private static final String TEST_MODULE = \"com.foos\";\n+    private static final String DUP_MODULE = \"com.foos3\";\n+\n+    \/\/ the module main class\n+    private static final String MAIN_CLASS = \"com.bars.Main\";\n+    private static final String TEST_CLASS = \"com.foos.Test\";\n+\n+    private static String PATH_LIBS = \"modylibs\";\n+    private static String DUP_LIBS = \"duplibs\";\n+    private static Path libsDir = null;\n+    private static Path dupDir = null;\n+    private static Path mainJar = null;\n+    private static Path testJar = null;\n+    private static Path dupJar = null;\n+\n+    private static String CLASS_FOUND_MESSAGE = \"com.foos.Test found\";\n+    private static String CLASS_NOT_FOUND_MESSAGE = \"java.lang.ClassNotFoundException: com.foos.Test\";\n+    private static String OPTIMIZE_ENABLED = \"] optimized module handling: enabled\";\n+    private static String OPTIMIZE_DISABLED = \"] optimized module handling: disabled\";\n+    private static String FMG_ENABLED = \"] full module graph: enabled\";\n+    private static String FMG_DISABLED = \"] full module graph: disabled\";\n+    private static String MAIN_FROM_JAR = \"class,load.*com.bars.Main.*[.]jar\";\n+    private static String MAIN_FROM_CDS = \"class,load.*com.bars.Main.*shared objects file\";\n+    private static String MAIN_FROM_MODULE = \"class,load.*com.bars.Main.*mody\/com.bars\";\n+    private static String TEST_FROM_JAR = \"class,load.*com.foos.Test.*[.]jar\";\n+    private static String TEST_FROM_CDS = \"class,load.*com.foos.Test.*shared objects file\";\n+    private static String MAP_FAILED  = \"Unable to use shared archive\";\n+    private static String PATH_SEPARATOR = File.pathSeparator;\n+    private static String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n+    private static String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n+\n+    public static void buildTestModule() throws Exception {\n+\n+        \/\/ javac -d mods\/$TESTMODULE src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.resolve(TEST_MODULE),\n+                                 null);\n+\n+        \/\/ javac -d mods\/$TESTMODULE --module-path MOD_DIR src\/$TESTMODULE\/**\n+        JarBuilder.compileModule(SRC_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.toString());\n+\n+        libsDir = Files.createTempDirectory(USER_DIR, PATH_LIBS);\n+        mainJar = libsDir.resolve(MAIN_MODULE + \".jar\");\n+        testJar = libsDir.resolve(TEST_MODULE + \".jar\");\n+\n+        \/\/ modylibs contains both modules com.foos.jar, com.bars.jar\n+        \/\/ build com.foos.jar\n+        String classes = MODS_DIR.resolve(TEST_MODULE).toString();\n+        JarBuilder.createModularJar(testJar.toString(), classes, TEST_CLASS);\n+\n+        \/\/ build com.bars.jar\n+        classes = MODS_DIR.resolve(MAIN_MODULE).toString();\n+        JarBuilder.createModularJar(mainJar.toString(), classes, MAIN_CLASS);\n+\n+        dupDir = Files.createTempDirectory(USER_DIR, DUP_LIBS);\n+        dupJar = dupDir.resolve(DUP_MODULE + \".jar\");\n+        Files.copy(testJar, dupJar, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        runWithModulePath();\n+        runWithExplodedModule();\n+    }\n+\n+    private static void tty(String... args) {\n+        for (String s : args) {\n+            System.out.print(s + \" \");\n+        }\n+        System.out.print(\"\\n\");\n+    }\n+\n+    public static void runWithModulePath(String... extraRuntimeArgs) throws Exception {\n+        \/\/ compile the modules and create the modular jar files\n+        buildTestModule();\n+        \/\/ create an archive with the classes in the modules built in the\n+        \/\/ previous step\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        libsDir.toString(),\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"1. run with CDS on, with module path same as dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 libsDir.toString(), \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        tty(\"2. run with CDS on, with jar on path\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-Xlog:class+load\",\n+                       \"-cp\", mainJar.toString() + PATH_SEPARATOR + testJar.toString(),\n+                       MAIN_CLASS)\n+            .assertNormalExit(out -> {\n+                out.shouldContain(CLASS_FOUND_MESSAGE)\n+                   .shouldMatch(MAIN_FROM_JAR)\n+                   .shouldMatch(TEST_FROM_JAR)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED);\n+            });\n+\n+        tty(\"3. run with CDS on, with --module-path, with jar should fail\");\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"-Xlog:class+load\",\n+                       \"-p\", libsDir.toString(),\n+                       \"-cp\", mainJar.toString(),\n+                       MAIN_CLASS)\n+            .assertNormalExit(out -> {\n+                out.shouldContain(CLASS_NOT_FOUND_MESSAGE)\n+                   .shouldMatch(MAIN_FROM_JAR)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED);\n+            });\n+\n+        final String modularJarPath = mainJar.toString() + PATH_SEPARATOR + testJar.toString();\n+\n+        tty(\"4. run with CDS on, with modular jars specified --module-path, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 modularJarPath,     \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS);       \/\/ archived Main class is for module only\n+            });\n+\n+        final String extraModulePath = libsDir.toString() + PATH_SEPARATOR + dupDir.toString();\n+        \/\/ create an archive with an extra module which is not referenced\n+        output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        extraModulePath,\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"5. run with CDS on, without the extra module specified in dump time, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 libsDir.toString(), \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+        tty(\"6. run with CDS on, with the extra module specified in dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraModulePath,    \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        final String extraJarPath = modularJarPath + PATH_SEPARATOR + dupJar.toString();\n+\n+        \/\/ create an archive by specifying modular jars in the --module-path with an extra module which is not referenced\n+        output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        extraJarPath,\n+                                        \"-m\", MAIN_MODULE);\n+        TestCommon.checkDump(output);\n+        tty(\"7. run with CDS on, without the extra module specified in dump time, should pass\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 modularJarPath,     \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+\n+        tty(\"8. run with CDS on, with the extra module specified in dump time\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraJarPath,       \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+        tty(\"9. same as test case 8 but with paths instead of modular jars in the --module-path\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 extraModulePath,    \/\/ --module-path\n+                                 MAIN_MODULE)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_CDS)       \/\/ archived Main class is for module only\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+    }\n+\n+    public static void runWithExplodedModule(String... extraRuntimeArgs) throws Exception {\n+        \/\/ create an archive with an exploded module in the module path.\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        MODS_DIR.toString(),\n+                                        \"-m\", MAIN_MODULE + \"\/\" + MAIN_CLASS);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"10. run with CDS on, with exploded module in the module path\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 MODS_DIR.toString(), \/\/ --module-path\n+                                 MAIN_MODULE + \"\/\" + MAIN_CLASS)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_MODULE) \/\/ Main class loaded from the exploded module\n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires vm.cds & !vm.graal.enabled\n+ * @requires vm.cds & !vm.graal.enabled & vm.cds.write.archived.java.heap\n@@ -67,2 +67,2 @@\n-    private static String OPTIMIZE_ENABLED = \"optimized module handling: enabled\";\n-    private static String OPTIMIZE_DISABLED = \"optimized module handling: disabled\";\n+    private static String OPTIMIZE_ENABLED = \"] optimized module handling: enabled\";\n+    private static String OPTIMIZE_DISABLED = \"] optimized module handling: disabled\";\n@@ -157,1 +157,1 @@\n-        String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds\", \"-Xlog:class+load\"};\n+        String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n@@ -163,2 +163,2 @@\n-                out.shouldNotContain(OPTIMIZE_ENABLED)\n-                   .shouldContain(OPTIMIZE_DISABLED)\n+                out.shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(OPTIMIZE_ENABLED)\n@@ -177,2 +177,2 @@\n-                   .shouldContain(OPTIMIZE_DISABLED)\n-                   .shouldNotContain(OPTIMIZE_ENABLED);\n+                   .shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_DISABLED);\n@@ -234,1 +234,0 @@\n-                   .shouldContain(OPTIMIZE_DISABLED)           \/\/ mapping info\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}