{"files":[{"patch":"@@ -929,8 +929,0 @@\n-bool FileMapInfo::is_jar_suffix(const char* filename) {\n-  const char* dot = strrchr(filename, '.');\n-  if (strcmp(dot + 1, \"jar\") == 0) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -942,17 +934,1 @@\n-    DIR* dirp = os::opendir(name);\n-    if (dirp == nullptr && errno == ENOTDIR && is_jar_suffix(name)) {\n-      module_paths->append(name);\n-    } else {\n-      struct dirent* dentry;\n-      while ((dentry = os::readdir(dirp)) != nullptr) {\n-        const char* file_name = dentry->d_name;\n-        if (is_jar_suffix(file_name)) {\n-          size_t full_name_len = strlen(name) + strlen(file_name) + strlen(os::file_separator()) + 1;\n-          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n-          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", name, os::file_separator(), file_name);\n-          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n-          module_paths->append(full_name);\n-        }\n-      }\n-      os::closedir(dirp);\n-    }\n+    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -558,1 +558,0 @@\n-  bool  is_jar_suffix(const char* filename);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -883,2 +883,2 @@\n-    log_info(cds, heap)(\"    is_using_optimized_module_handling %d num_module_paths %d jdk.module.main %s\",\n-        CDSConfig::is_using_optimized_module_handling(), ClassLoaderExt::num_module_paths(), Arguments::get_property(\"jdk.module.main\"));\n+    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -582,0 +582,1 @@\n+    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,3 +111,1 @@\n-        char* path_copy = NEW_RESOURCE_ARRAY(char, strlen(path) + 1);\n-        strcpy(path_copy, path);\n-        _module_paths->append(path_copy);\n+        extract_jar_files_from_path(path, _module_paths);\n@@ -143,0 +141,28 @@\n+bool ClassLoaderExt::has_jar_suffix(const char* filename) {\n+  const char* dot = strrchr(filename, '.');\n+  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void ClassLoaderExt::extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths) {\n+  DIR* dirp = os::opendir(path);\n+  if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n+    module_paths->append(path);\n+  } else {\n+    struct dirent* dentry;\n+    while ((dentry = os::readdir(dirp)) != nullptr) {\n+      const char* file_name = dentry->d_name;\n+      if (has_jar_suffix(file_name)) {\n+        size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n+        char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n+        int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n+        assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n+        module_paths->append(full_name);\n+      }\n+    }\n+    os::closedir(dirp);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static bool has_jar_suffix(const char* filename);\n@@ -73,0 +74,1 @@\n+  static void extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -466,1 +467,4 @@\n-        if (CDS.isDumpingStaticArchive() && !haveUpgradeModulePath && addModules.isEmpty()) {\n+        if (CDS.isDumpingStaticArchive()\n+                && !haveUpgradeModulePath\n+                && addModules.isEmpty()\n+                && allJrtOrModularJar(cf)) {\n@@ -473,5 +477,5 @@\n-                                        hasIncubatorModules,\n-                                        systemModuleFinder,\n-                                        cf,\n-                                        clf,\n-                                        mainModule);\n+                    hasIncubatorModules,\n+                    systemModuleFinder,\n+                    cf,\n+                    clf,\n+                    mainModule);\n@@ -513,0 +517,23 @@\n+    \/**\n+     * Returns true if all modules in the configuration are in the run-time image or\n+     * modular JAR files.\n+     *\/\n+    private static boolean allJrtOrModularJar(Configuration cf) {\n+        return !cf.modules().stream()\n+                .map(m -> m.reference().location().orElseThrow())\n+                .anyMatch(uri -> !uri.getScheme().equalsIgnoreCase(\"jrt\")\n+                        && !isJarFile(uri));\n+    }\n+\n+    \/**\n+     * Returns true if the given URI locates a jar file on the file system.\n+     *\/\n+    private static boolean isJarFile(URI uri) {\n+        if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            Path path = Path.of(uri);\n+            return path.toString().endsWith(\".jar\") && Files.isRegularFile(path);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -154,7 +154,0 @@\n-    \/**\n-     * Computes the SHA-256 hash from the names and content of a module.\n-     *\/\n-    static byte[] computeHash(Supplier<ModuleReader> supplier) {\n-        return computeHash(supplier, \"SHA-256\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleHashes.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-        byte[] hash = ModuleHashes.computeHash(supplier);\n@@ -105,1 +104,1 @@\n-                return hash;\n+              return ModuleHashes.computeHash(supplier, algorithm);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -216,2 +216,4 @@\n-            .assertAbnormalExit(output -> {\n-                output.shouldMatch(\"Error: non-empty directory.*com.simple\");\n+            \/\/ After JDK-8328313, non-empty module path directory won't be included\n+            \/\/ in the shared paths table.\n+            .assertNormalExit(output -> {\n+                output.shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,2 +197,4 @@\n-        output.shouldHaveExitValue(1)\n-              .shouldMatch(\"Error: non-empty directory.*com.simple\");\n+        \/\/ After JDK-8328313, non-empty module path directory won't be included\n+        \/\/ in the shared paths table.\n+        output.shouldHaveExitValue(0)\n+              .shouldNotMatch(\"Error: non-empty directory.*com.simple\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    private static String MAIN_FROM_MODULE = \"class,load.*com.bars.Main.*mody\/com.bars\";\n@@ -82,0 +83,2 @@\n+    private static String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n+    private static String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n@@ -115,0 +118,1 @@\n+        runWithExplodedModule();\n@@ -127,1 +131,0 @@\n-        String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n@@ -138,1 +141,0 @@\n-        String prefix[] = {\"-Djava.class.path=\", \"-Xlog:cds,class+load,class+path=info\"};\n@@ -282,0 +284,20 @@\n+    public static void runWithExplodedModule(String... extraRuntimeArgs) throws Exception {\n+        \/\/ create an archive with an exploded module in the module path.\n+        OutputAnalyzer output = TestCommon.createArchive(\n+                                        null, appClasses,\n+                                        \"--module-path\",\n+                                        MODS_DIR.toString(),\n+                                        \"-m\", MAIN_MODULE + \"\/\" + MAIN_CLASS);\n+        TestCommon.checkDump(output);\n+\n+        tty(\"10. run with CDS on, with exploded module in the module path\");\n+        TestCommon.runWithModules(prefix,\n+                                 null,               \/\/ --upgrade-module-path\n+                                 MODS_DIR.toString(), \/\/ --module-path\n+                                 MAIN_MODULE + \"\/\" + MAIN_CLASS)        \/\/ -m\n+            .assertNormalExit(out -> {\n+                out.shouldContain(FMG_DISABLED)\n+                   .shouldMatch(MAIN_FROM_MODULE) \/\/ Main class loaded from the exploded module \n+                   .shouldContain(CLASS_FOUND_MESSAGE);\n+            });\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"}]}