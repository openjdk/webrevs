{"files":[{"patch":"@@ -100,1 +100,1 @@\n-  friend class ClassLoaderDataGraphKlassIteratorAtomic;\n+  friend class ClassLoaderDataGraphIteratorAtomic;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -492,2 +492,2 @@\n-ClassLoaderDataGraphKlassIteratorAtomic::ClassLoaderDataGraphKlassIteratorAtomic()\n-    : _next_klass(nullptr) {\n+ClassLoaderDataGraphIteratorAtomic::ClassLoaderDataGraphIteratorAtomic()\n+    : _cld(nullptr) {\n@@ -495,13 +495,1 @@\n-  ClassLoaderData* cld = ClassLoaderDataGraph::_head;\n-  Klass* klass = nullptr;\n-\n-  \/\/ Find the first klass in the CLDG.\n-  while (cld != nullptr) {\n-    assert_locked_or_safepoint(cld->metaspace_lock());\n-    klass = cld->_klasses;\n-    if (klass != nullptr) {\n-      _next_klass = klass;\n-      return;\n-    }\n-    cld = cld->next();\n-  }\n+  _cld = AtomicAccess::load_acquire(&ClassLoaderDataGraph::_head);\n@@ -510,13 +498,5 @@\n-Klass* ClassLoaderDataGraphKlassIteratorAtomic::next_klass_in_cldg(Klass* klass) {\n-  Klass* next = klass->next_link();\n-  if (next != nullptr) {\n-    return next;\n-  }\n-\n-  \/\/ No more klasses in the current CLD. Time to find a new CLD.\n-  ClassLoaderData* cld = klass->class_loader_data();\n-  assert_locked_or_safepoint(cld->metaspace_lock());\n-  while (next == nullptr) {\n-    cld = cld->next();\n-    if (cld == nullptr) {\n-      break;\n+ClassLoaderData* ClassLoaderDataGraphIteratorAtomic::next() {\n+  ClassLoaderData* cur = AtomicAccess::load(&_cld);\n+  for (;;) {\n+    if (cur == nullptr) {\n+      return nullptr;\n@@ -524,16 +504,4 @@\n-    next = cld->_klasses;\n-  }\n-\n-  return next;\n-}\n-\n-Klass* ClassLoaderDataGraphKlassIteratorAtomic::next_klass() {\n-  Klass* head = _next_klass;\n-\n-  while (head != nullptr) {\n-    Klass* next = next_klass_in_cldg(head);\n-\n-    Klass* old_head = AtomicAccess::cmpxchg(&_next_klass, head, next);\n-\n-    if (old_head == head) {\n-      return head; \/\/ Won the CAS.\n+    ClassLoaderData* next = cur->next();\n+    ClassLoaderData* old;\n+    if ((old = AtomicAccess::cmpxchg(&_cld, cur, next)) == cur) {\n+      return cur;\n@@ -541,2 +509,1 @@\n-\n-    head = old_head;\n+    cur = old;\n@@ -544,4 +511,0 @@\n-\n-  \/\/ Nothing more for the iterator to hand out.\n-  assert(head == nullptr, \"head is \" PTR_FORMAT \", expected not null:\", p2i(head));\n-  return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":13,"deletions":50,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  friend class ClassLoaderDataGraphKlassIteratorAtomic;\n+  friend class ClassLoaderDataGraphIteratorAtomic;\n@@ -143,8 +143,8 @@\n-\/\/ An iterator that distributes Klasses to parallel worker threads.\n-class ClassLoaderDataGraphKlassIteratorAtomic : public StackObj {\n- Klass* volatile _next_klass;\n- public:\n-  ClassLoaderDataGraphKlassIteratorAtomic();\n-  Klass* next_klass();\n- private:\n-  static Klass* next_klass_in_cldg(Klass* klass);\n+\/\/ An iterator that distributes Klasses to parallel worker threads based on CLDs.\n+class ClassLoaderDataGraphIteratorAtomic : public StackObj {\n+  ClassLoaderData* volatile _cld;\n+\n+public:\n+  ClassLoaderDataGraphIteratorAtomic();\n+\n+  ClassLoaderData* next();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n@@ -97,9 +97,4 @@\n-KlassCleaningTask::KlassCleaningTask() :\n-  _clean_klass_tree_claimed(false),\n-  _klass_iterator() {\n-}\n-\n-bool KlassCleaningTask::claim_clean_klass_tree_task() {\n-  if (_clean_klass_tree_claimed) {\n-    return false;\n-  }\n+void KlassCleaningTask::work() {\n+  for (ClassLoaderData* cur = _cld_iterator.next(); cur != nullptr; cur = _cld_iterator.next()) {\n+      class CleanKlasses : public KlassClosure {\n+      public:\n@@ -107,2 +102,2 @@\n-  return !AtomicAccess::cmpxchg(&_clean_klass_tree_claimed, false, true);\n-}\n+        void do_klass(Klass* klass) override {\n+          klass->clean_subklass(true);\n@@ -110,5 +105,2 @@\n-InstanceKlass* KlassCleaningTask::claim_next_klass() {\n-  Klass* klass;\n-  do {\n-    klass =_klass_iterator.next_klass();\n-  } while (klass != nullptr && !klass->is_instance_klass());\n+          Klass* sibling = klass->next_sibling(true);\n+          klass->set_next_sibling(sibling);\n@@ -116,3 +108,3 @@\n-  \/\/ this can be null so don't call InstanceKlass::cast\n-  return static_cast<InstanceKlass*>(klass);\n-}\n+          if (klass->is_instance_klass()) {\n+            Klass::clean_weak_instanceklass_links(InstanceKlass::cast(klass));\n+          }\n@@ -120,5 +112,4 @@\n-void KlassCleaningTask::work() {\n-  \/\/ One worker will clean the subklass\/sibling klass tree.\n-  if (claim_clean_klass_tree_task()) {\n-    Klass::clean_weak_klass_links(true \/* class_unloading_occurred *\/, false \/* clean_alive_klasses *\/);\n-  }\n+          assert(klass->subklass() == nullptr || klass->subklass()->is_loader_alive(), \"must be\");\n+          assert(klass->next_sibling(false) == nullptr || klass->next_sibling(false)->is_loader_alive(), \"must be\");\n+        }\n+      } cl;\n@@ -126,4 +117,1 @@\n-  \/\/ All workers will help cleaning the classes,\n-  InstanceKlass* klass;\n-  while ((klass = claim_next_klass()) != nullptr) {\n-    Klass::clean_weak_instanceklass_links(klass);\n+      cur->classes_do(&cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":17,"deletions":29,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -57,5 +57,1 @@\n-  volatile bool _clean_klass_tree_claimed;\n-  ClassLoaderDataGraphKlassIteratorAtomic _klass_iterator;\n-\n-  bool claim_clean_klass_tree_task();\n-  InstanceKlass* claim_next_klass();\n+  ClassLoaderDataGraphIteratorAtomic _cld_iterator;\n@@ -64,1 +60,1 @@\n-  KlassCleaningTask();\n+  KlassCleaningTask() : _cld_iterator() { }\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -616,2 +616,1 @@\n-\/\/ The log parameter is for clean_weak_klass_links to report unlinked classes.\n-Klass* Klass::subklass(bool log) const {\n+Klass* Klass::subklass() const {\n@@ -628,5 +627,0 @@\n-    } else if (log) {\n-      if (log_is_enabled(Trace, class, unload)) {\n-        ResourceMark rm;\n-        log_trace(class, unload)(\"unlinking class (subclass): %s\", chain->external_name());\n-      }\n@@ -703,1 +697,2 @@\n-void Klass::clean_subklass() {\n+\/\/ The log parameter is for clean_weak_klass_links to report unlinked classes.\n+Klass* Klass::clean_subklass(bool log) {\n@@ -708,1 +703,5 @@\n-      return;\n+      return subklass;\n+    }\n+    if (log && log_is_enabled(Trace, class, unload)) {\n+      ResourceMark rm;\n+      log_trace(class, unload)(\"unlinking class (subclass): %s\", subklass->external_name());\n@@ -711,1 +710,1 @@\n-    AtomicAccess::cmpxchg(&_subklass, subklass, subklass->next_sibling());\n+    AtomicAccess::cmpxchg(&_subklass, subklass, subklass->next_sibling(log));\n@@ -730,2 +729,1 @@\n-    Klass* sub = current->subklass(true);\n-    current->clean_subklass();\n+    Klass* sub = current->clean_subklass(true);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-  Klass* subklass(bool log = false) const;\n+  Klass* subklass() const;\n@@ -414,0 +414,1 @@\n+  void     set_next_sibling(Klass* s);\n@@ -416,1 +417,0 @@\n-  void     set_next_sibling(Klass* s);\n@@ -744,1 +744,1 @@\n-  void clean_subklass();\n+  Klass* clean_subklass(bool log = false);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}