{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * Interface defining methods to control mirror of debuggee (i.e. debugged VM).\n+ * Class defining methods to control mirror of debuggee (i.e. debugged VM).\n@@ -35,1 +35,1 @@\n-public interface Debuggee {\n+public class Debuggee extends LocalProcess {\n@@ -42,40 +42,0 @@\n-    \/**\n-     * Launch debuggee.\n-     *\n-     * @throws IOException\n-     *\/\n-    public void launch (String[] args) throws IOException;\n-\n-    \/** Return exit status. *\/\n-    public int getStatus ();\n-\n-    \/** Check whether the process has been terminated. *\/\n-    public boolean terminated();\n-\n-    \/** Kill the debuggee VM. *\/\n-    public void killDebuggee ();\n-\n-    \/** Wait until the debuggee VM shutdown or crash. *\/\n-    public int waitForDebuggee () throws InterruptedException;\n-\n-    \/** Get a pipe to write to the debuggee's stdin stream. *\/\n-    public OutputStream getInPipe ();\n-\n-    \/** Get a pipe to read the debuggee's stdout stream. *\/\n-    public InputStream getOutPipe ();\n-\n-    \/** Get a pipe to read the debuggee's stderr stream. *\/\n-    public InputStream getErrPipe ();\n-\n-    \/** Redirect stdout stream to <code>Log<\/code> *\/\n-    public void redirectStdout(Log log, String prefix);\n-\n-    \/** Redirect stderr stream to <code>Log<\/code> *\/\n-    public void redirectStderr(Log log, String prefix);\n-}\n-\n-\/**\n- * Mirror of locally launched debuggee.\n- *\/\n-final class LocalLaunchedDebuggee extends LocalProcess implements Debuggee {\n-\n@@ -93,1 +53,1 @@\n-    LocalLaunchedDebuggee (Launcher launcher) {\n+    Debuggee(Launcher launcher) {\n@@ -238,67 +198,0 @@\n-\/**\n- * Mirror of remotely launched debuggee.\n- *\/\n-final class RemoteLaunchedDebuggee implements Debuggee {\n-\n-    \/** Launcher that creates this debuggee. *\/\n-    private Launcher launcher = null;\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    RemoteLaunchedDebuggee (Launcher launcher) {\n-        super();\n-        this.launcher = launcher;\n-    }\n-\n-    \/**\n-     * Launch debugee on remote host via <code>Launcher<\/code> object.\n-     *\/\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        launcher.display(\"Starting remote java process:\\n\" + cmdLine);\n-        launcher.launchRemoteProcess(args);\n-    }\n-\n-    \/** Return exit status of the debuggee VM. *\/\n-    public int getStatus () {\n-        return launcher.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debuggee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return launcher.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debuggee VM. *\/\n-    public void killDebuggee () {\n-        launcher.killRemoteProcess();\n-    }\n-\n-    \/** Wait until the debuggee VM shutdown or crash. *\/\n-    public int waitForDebuggee () {\n-        return launcher.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debuggee's stdin stream. *\/\n-    public OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debuggee's stdout stream. *\/\n-    public InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debuggee's stderr stream. *\/\n-    public InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Debuggee.java","additions":4,"deletions":111,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-        if (argumentHandler.isLaunchedLocally()) {\n+        if (argumentHandler.isDefaultConnector()) {\n@@ -108,1 +108,1 @@\n-            if (argumentHandler.isDefaultConnector()) {\n+            localDefaultLaunch(jdbCmdArgs, classToExecute);\n@@ -110,1 +110,1 @@\n-                localDefaultLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isRawLaunchingConnector()) {\n@@ -112,1 +112,1 @@\n-            } else if (argumentHandler.isRawLaunchingConnector()) {\n+            localRawLaunch(jdbCmdArgs, classToExecute);\n@@ -114,1 +114,1 @@\n-                localRawLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isLaunchingConnector()) {\n@@ -116,1 +116,1 @@\n-            } else if (argumentHandler.isLaunchingConnector()) {\n+            localLaunch(jdbCmdArgs, classToExecute);\n@@ -118,1 +118,1 @@\n-                localLaunch(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isAttachingConnector()) {\n@@ -120,1 +120,1 @@\n-            } else if (argumentHandler.isAttachingConnector()) {\n+            localLaunchAndAttach(jdbCmdArgs, classToExecute);\n@@ -122,1 +122,1 @@\n-                localLaunchAndAttach(jdbCmdArgs, classToExecute);\n+        } else if (argumentHandler.isListeningConnector()) {\n@@ -124,16 +124,1 @@\n-            } else if (argumentHandler.isListeningConnector()) {\n-\n-                localLaunchAndListen(jdbCmdArgs, classToExecute);\n-\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for local launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedRemotely()) {\n-\n-            connectToBindServer(classToExecute);\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-\n-                remoteLaunchAndAttach(jdbCmdArgs, classToExecute);\n+            localLaunchAndListen(jdbCmdArgs, classToExecute);\n@@ -141,8 +126,0 @@\n-            } else if (argumentHandler.isListeningConnector()) {\n-\n-                remoteLaunchAndListen(jdbCmdArgs, classToExecute);\n-\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for remote launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n@@ -150,1 +127,2 @@\n-            throw new Failure(\"Unexpected launching mode: \" + argumentHandler.getLaunchMode());\n+            throw new TestBug(\"Unexpected connector type for local launch mode\"\n+                              + argumentHandler.getConnectorType());\n@@ -152,0 +130,1 @@\n+\n@@ -201,5 +180,1 @@\n-                    if (argumentHandler.isLaunchedLocally()) {\n-                        connectorAddress = argumentHandler.getTransportPort();\n-                    } else {\n-                        connectorAddress = argumentHandler.getDebugeeHost() + \":\" + argumentHandler.getTransportPort();\n-                    }\n+                    connectorAddress = argumentHandler.getTransportPort();\n@@ -250,2 +225,0 @@\n-                    if (argumentHandler.isLaunchedRemotely())\n-                        connect.append(\",hostname=\" + argumentHandler.getDebugeeHost().trim());\n@@ -327,1 +300,1 @@\n-        debuggee = new LocalLaunchedDebuggee(this);\n+        debuggee = new Debuggee(this);\n@@ -349,1 +322,1 @@\n-        debuggee = new LocalLaunchedDebuggee(this);\n+        debuggee = new Debuggee(this);\n@@ -356,45 +329,0 @@\n-    \/**\n-     * Run test in remote mode using attaching connector.\n-     *\/\n-    private void remoteLaunchAndAttach\n-       (String[] jdbCmdArgs, String classToExecute) throws IOException {\n-\n-        debuggee = new RemoteLaunchedDebuggee(this);\n-        String address = makeTransportAddress();\n-        String[] javaCmdArgs = makeCommandLineArgs(classToExecute, address);\n-        try {\n-            debuggee.launch(javaCmdArgs);\n-        } catch (IOException e) {\n-            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n-                            + e);\n-        };\n-\n-        display(\"Start jdb attaching to remote debuggee\");\n-        jdb = Jdb.startAttachingJdb (this, jdbCmdArgs, JDB_STARTED);\n-\/\/        jdb.waitForPrompt(0, false);\n-    }\n-\n-    \/**\n-     * Run test in remote mode using listening connector.\n-     *\/\n-    private void remoteLaunchAndListen\n-       (String[] jdbCmdArgs, String classToExecute) throws IOException {\n-\n-        jdb = new Jdb(this);\n-        display(\"Starting jdb listening to remote debuggee\");\n-        jdb.launch(jdbCmdArgs);\n-        String address = jdb.waitForListeningJdb();\n-        display(\"Listening address found: \" + address);\n-\n-        debuggee = new RemoteLaunchedDebuggee(this);\n-        String[] javaCmdArgs = makeCommandLineArgs(classToExecute);\n-        try {\n-            debuggee.launch(javaCmdArgs);\n-        } catch (IOException e) {\n-            throw new Failure(\"Caught exception while launching debuggee VM process:\\n\\t\"\n-                            + e);\n-        };\n-\n-        jdb.waitForMessage(0, JDB_STARTED);\n-\/\/        jdb.waitForPrompt(0, false);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":17,"deletions":89,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -460,12 +460,0 @@\n-        if (! isLaunchedLocally() && ! isDefaultDebugeeSuspendMode()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-debugee.launch=\" + getLaunchMode()\n-                                + \" and -debugee.suspend=\" + getDebugeeSuspendMode());\n-        }\n-\n-        if (! isLaunchedLocally() && isLaunchingConnector()) {\n-            throw new BadOption(\"inconsistent options: \"\n-                                + \"-debugee.launch=\" + getLaunchMode()\n-                                + \" and -connector=\" + getConnectorType());\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,2 +130,1 @@\n-        LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(process, this);\n-        return debugee;\n+        return new Debugee(process, this);\n@@ -192,41 +191,10 @@\n-        if (argumentHandler.isLaunchedLocally()) {\n-\n-            if (argumentHandler.isDefaultConnector()) {\n-                debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isRawLaunchingConnector()) {\n-                debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isLaunchingConnector()) {\n-                debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isAttachingConnector()) {\n-                debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedRemotely()) {\n-\n-            connectToBindServer(classToExecute);\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-                debugee = remoteLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = remoteLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for remote debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n-        } else if (argumentHandler.isLaunchedManually()) {\n-\n-            if (argumentHandler.isAttachingConnector()) {\n-                debugee = manualLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n-            } else if (argumentHandler.isListeningConnector()) {\n-                debugee = manualLaunchAndListenDebugee(vmm, classToExecute, classPath);\n-            } else {\n-                throw new TestBug(\"Unexpected connector type for manual debugee launch mode\"\n-                                  + argumentHandler.getConnectorType());\n-            }\n-\n+        if (argumentHandler.isDefaultConnector()) {\n+            debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isRawLaunchingConnector()) {\n+            debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isLaunchingConnector()) {\n+            debugee = localLaunchDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isAttachingConnector()) {\n+            debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);\n+        } else if (argumentHandler.isListeningConnector()) {\n+            debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);\n@@ -234,1 +202,2 @@\n-            throw new Failure(\"Unexpected debugee launching mode: \" + argumentHandler.getLaunchMode());\n+            throw new TestBug(\"Unexpected connector type for local debugee launch mode\"\n+                              + argumentHandler.getConnectorType());\n@@ -237,0 +206,1 @@\n+\n@@ -489,188 +459,0 @@\n-    \/**\n-     * Launch debugee VM remotely via <code>BindServer<\/code> and connect to it using\n-     * <code>AttachingConnector<\/code>.\n-     *\/\n-    private Debugee remoteLaunchAndAttachDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        AttachingConnector connector =\n-            (AttachingConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.attachingConnectors());\n-\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupAttachingConnector(connector, classToExecute, classPath);\n-\n-        String address = makeTransportAddress();\n-        String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting remote java process:\\n\\t\" + javaCmdLine);\n-        Debugee debugee = startRemoteDebugee(cmdLineArgs);\n-\n-        display(\"Attaching to debugee\");\n-        VirtualMachine vm;\n-        IOException ioe = null;\n-        for (int i = 0; i < CONNECT_TRIES; i++) {\n-            try {\n-                vm = connector.attach(arguments);\n-                display(\"Debugee attached\");\n-                debugee.setupVM(vm);\n-                return debugee;\n-            } catch (IOException e) {\n-                display(\"Attempt #\" + i + \" to connect to debugee VM failed:\\n\\t\" + e);\n-                ioe = e;\n-                if (debugee.terminated()) {\n-                    throw new Failure(\"Unable to connect to debuggee VM: VM process is terminated\");\n-                }\n-                try {\n-                    Thread.currentThread().sleep(CONNECT_TRY_DELAY);\n-                } catch (InterruptedException ie) {\n-                    ie.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Thread interrupted while pausing connection attempts:\\n\\t\"\n-                                    + ie);\n-                }\n-            } catch (IllegalConnectorArgumentsException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new TestBug(\"Wrong connector arguments used to attach to debuggee VM:\\n\\t\" + e);\n-            }\n-        }\n-        throw new Failure(\"Unable to connect to debugee VM after \" + CONNECT_TRIES\n-                        + \" tries:\\n\\t\" + ioe);\n-    }\n-\n-    \/**\n-     * Launch debugee VM remotely via <code>BindServer<\/code> and connect to it using\n-     * <code>ListeningConnector<\/code>.\n-     *\/\n-    private Debugee remoteLaunchAndListenDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        ListeningConnector connector =\n-            (ListeningConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.listeningConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupListeningConnector(connector, classToExecute, classPath);\n-\n-        String address = null;\n-        try {\n-            display(\"Listening for connection from debugee\");\n-            address = connector.startListening(arguments);\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while starting listening debugee VM:\\n\\t\" + e);\n-        };\n-\n-        String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting remote java process:\\n\\t\" + javaCmdLine);\n-        Debugee debugee = startRemoteDebugee(cmdLineArgs);\n-\n-        display(\"Waiting for connection from debugee\");\n-        VirtualMachine vm;\n-        IOException ioe = null;\n-        for (int i = 0; i < CONNECT_TRIES; i++) {\n-            try {\n-                vm = connector.accept(arguments);\n-                connector.stopListening(arguments);\n-                display(\"Debugee attached\");\n-                debugee.setupVM(vm);\n-                return debugee;\n-            } catch (IOException e) {\n-                display(\"Attempt #\" + i + \" to listen debugee VM failed:\\n\\t\" + e);\n-                ioe = e;\n-                if (debugee.terminated()) {\n-                    throw new Failure(\"Unable to connect to debuggee VM: VM process is terminated\");\n-                }\n-                try {\n-                    Thread.currentThread().sleep(CONNECT_TRY_DELAY);\n-                } catch (InterruptedException ie) {\n-                    ie.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Thread interrupted while pausing connection attempts:\\n\\t\"\n-                                    + ie);\n-                }\n-            } catch (IllegalConnectorArgumentsException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-            }\n-        }\n-        throw new Failure(\"Unable to connect to debugee VM after \" + CONNECT_TRIES\n-                        + \" tries:\\n\\t\" + ioe);\n-    }\n-\n-    \/\/ -------------------------------------------------- \/\/\n-\n-    \/**\n-     * Prompt to manually launch debugee VM and connect to it using\n-     * <code>AttachingConnector<\/code>.\n-     *\/\n-    private Debugee manualLaunchAndAttachDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        AttachingConnector connector =\n-            (AttachingConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.attachingConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupAttachingConnector(connector, classToExecute, classPath);\n-\n-        String address = makeTransportAddress();\n-        String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-\n-        display(\"Starting manual java process:\\n\\t\" + javaCmdLine);\n-        ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);\n-\n-        VirtualMachine vm;\n-        try {\n-            display(\"Attaching to debugee\");\n-            vm = connector.attach(arguments);\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to attach to debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while attaching to debugee VM:\\n\\t\" + e);\n-        };\n-        display(\"Debugee attached\");\n-\n-        debugee.setupVM(vm);\n-        return debugee;\n-    }\n-\n-    \/**\n-     * Prompt to manually launch debugee VM and connect to it using\n-     * <code>ListeningConnector<\/code>.\n-     *\/\n-    private Debugee manualLaunchAndListenDebugee (VirtualMachineManager vmm,\n-                                                    String classToExecute,\n-                                                    String classPath) {\n-        display(\"Finding connector: \" + argumentHandler.getConnectorName() );\n-        ListeningConnector connector =\n-            (ListeningConnector) findConnector(argumentHandler.getConnectorName(),\n-                                                vmm.listeningConnectors());\n-        Map<java.lang.String,? extends com.sun.jdi.connect.Connector.Argument> arguments = setupListeningConnector(connector, classToExecute, classPath);\n-\n-        VirtualMachine vm;\n-        try {\n-            display(\"Listening for connection from debugee\");\n-            String address = connector.startListening(arguments);\n-            String javaCmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-            display(\"Starting manual java process:\\n\\t\" + javaCmdLine);\n-            ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);\n-            display(\"Waiting for connection from debugee\");\n-            vm = connector.accept(arguments);\n-            display(\"Debugee attached\");\n-            connector.stopListening(arguments);\n-            debugee.setupVM(vm);\n-            return debugee;\n-        } catch (IllegalConnectorArgumentsException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new TestBug(\"Wrong connector arguments used to listen debuggee VM:\\n\\t\" + e);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while listening to debugee VM:\\n\\t\" + e);\n-        }\n-    }\n-\n@@ -923,27 +705,0 @@\n-    \/**\n-     * Launch remote debuggee process with specified command line arguments\n-     * and make initial <code>Debugee<\/code> mirror.\n-     *\/\n-    protected RemoteLaunchedDebugee startRemoteDebugee(String[] cmdArgs) {\n-        try {\n-            launchRemoteProcess(cmdArgs);\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while launching remote debuggee VM process:\\n\\t\"\n-                            + e);\n-        }\n-\n-        RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);\n-        return debugee;\n-    }\n-\n-    \/**\n-     * Launch manual debuggee process with specified command line arguments\n-     * and make initial <code>Debugee<\/code> mirror.\n-     *\/\n-    protected ManualLaunchedDebugee startManualDebugee(String cmd) {\n-        ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);\n-        debugee.launchDebugee(cmd);\n-        return debugee;\n-    }\n-\n@@ -998,284 +753,1 @@\n-}\n-\n-\n-\/**\n- * Mirror of locally launched debugee.\n- *\/\n-final class LocalLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the locally started VM process. *\/\n-    public LocalLaunchedDebugee (Process process, Binder binder) {\n-        super(binder);\n-        this.process = process;\n-        checkTermination = true;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return process.exitValue();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if (process == null)\n-            return true;\n-\n-        try {\n-            int value = process.exitValue();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            process.destroy();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () throws InterruptedException {\n-        int code = process.waitFor();\n-        return code;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return process.getOutputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return process.getInputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return process.getErrorStream();\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of remotely launched debugee.\n- *\/\n-final class RemoteLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the remotely started VM process. *\/\n-    public RemoteLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return binder.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return binder.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            binder.killRemoteProcess();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        return binder.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of manually launched debugee.\n- *\/\n-final class ManualLaunchedDebugee extends Debugee {\n-    \/** Enwrap the manually started VM process. *\/\n-    public ManualLaunchedDebugee (Binder binder) {\n-        super(binder);\n-        makeInputReader();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    private int exitCode = 0;\n-    private boolean finished = false;\n-    private static BufferedReader bin = null;\n-\n-    public void launchDebugee(String commandLine) {\n-        makeInputReader();\n-\n-        putMessage(\"Launch target VM using such command line:\\n\"\n-                    + commandLine);\n-        String answer = askQuestion(\"Has the VM successfully started? (yes\/no)\", \"yes\");\n-        for ( ; ; ) {\n-            if (answer.equals(\"yes\"))\n-                break;\n-            if (answer.equals(\"no\"))\n-                throw new Failure (\"Unable to manually launch debugee VM\");\n-            answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-        }\n-    }\n-\n-    private static void makeInputReader() {\n-        if (bin == null) {\n-            bin = new BufferedReader(new InputStreamReader(System.in));\n-        }\n-    }\n-\n-    private static void destroyInputReader() {\n-        if (bin != null) {\n-            try {\n-                bin.close();\n-            } catch (IOException e) {\n-\/\/                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while closing input stream:\\n\\t\" + e);\n-            }\n-            bin = null;\n-        }\n-    }\n-\n-    private static void putMessage(String msg) {\n-        System.out.println(\"\\n>>> \" + msg);\n-    }\n-\n-    private static String askQuestion(String question, String defaultAnswer) {\n-        try {\n-            System.out.print(\"\\n>>> \" + question);\n-            System.out.print(\" [\" + defaultAnswer + \"] \");\n-            System.out.flush();\n-            String answer = bin.readLine();\n-            if (answer.equals(\"\"))\n-                return defaultAnswer;\n-            return answer;\n-        } catch (IOException e) {\n-\/\/            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while reading answer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        if (! finished) {\n-            throw new Failure(\"Unable to get status of debugee VM: process still alive\");\n-        }\n-        return exitCode;\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return finished;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            putMessage(\"Kill launched VM\");\n-            String answer = askQuestion(\"Has the VM successfully terminated? (yes\/no)\", \"yes\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    break;\n-                }\n-                if (answer.equals(\"no\"))\n-                    throw new Failure (\"Unable to manually kill debugee VM\");\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        putMessage(\"Wait for launched VM to exit.\");\n-        String answer = askQuestion(\"What is VM exit code?\", \"95\");\n-        for ( ; ; ) {\n-            try {\n-                exitCode = Integer.parseInt(answer);\n-                break;\n-            } catch (NumberFormatException e) {\n-                answer = askQuestion(\"Wrong answer. Please type integer value\", \"95\");\n-            }\n-        }\n-        finished = true;\n-        return exitCode;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-    public void close() {\n-        destroyInputReader();\n-        super.close();\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":15,"deletions":543,"binary":false,"changes":558,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-abstract public class Debugee extends DebugeeProcess {\n+public class Debugee extends DebugeeProcess {\n@@ -68,0 +68,7 @@\n+        this.argumentHandler = (ArgumentHandler)binder.getArgumentHandler();\n+    }\n+\n+    protected Debugee (Process process, Binder binder) {\n+        super(binder);\n+        this.process = process;\n+        this.binder = binder;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Debugee.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,7 +101,2 @@\n-        if (argumentHandler.isLaunchedRemotely()) {\n-            connectToBindServer(classToExecute);\n-            debugee = launchDebugee(classToExecute);\n-        } else {\n-            debugee = launchDebugee(classToExecute);\n-            debugee.redirectOutput(log);\n-        }\n+        debugee = launchDebugee(classToExecute);\n+        debugee.redirectOutput(log);\n@@ -120,33 +115,7 @@\n-\n-            if (argumentHandler.isLaunchedLocally()) {\n-                LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String[] argsArray = makeCommandLineArgs(classToExecute, address);\n-                debugee.launch(argsArray);\n-                return debugee;\n-            }\n-\n-            if (argumentHandler.isLaunchedRemotely()) {\n-                RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String[] argsArray = makeCommandLineArgs(classToExecute, address);\n-                debugee.launch(argsArray);\n-                return debugee;\n-            }\n-\n-            if (argumentHandler.isLaunchedManually()) {\n-                ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);\n-                String address = debugee.prepareTransport(argumentHandler);\n-                if (address == null)\n-                    address = makeTransportAddress();\n-                String cmdLine = makeCommandLineString(classToExecute, address, \"\\\"\");\n-                debugee.launch(cmdLine);\n-                return debugee;\n-            }\n-\n-            throw new TestBug(\"Unexpected launching mode: \"\n-                            + argumentHandler.getLaunchMode());\n+            Debugee debugee = new Debugee(this);\n+            String address = debugee.prepareTransport(argumentHandler);\n+            if (address == null)\n+                address = makeTransportAddress();\n+            String[] argsArray = makeCommandLineArgs(classToExecute, address);\n+            debugee.launch(argsArray);\n+            return debugee;\n@@ -158,293 +127,1 @@\n-\n-}\n-\n-\/**\n- * Mirror of locally launched debugee.\n- *\/\n-final class LocalLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public LocalLaunchedDebugee (Binder binder) {\n-        super(binder);\n-        checkTermination = true;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        display(\"Starting java process:\\n\" + cmdLine);\n-        process = binder.launchProcess(args);\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return process.exitValue();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if (process == null)\n-            return true;\n-\n-        try {\n-            int value = process.exitValue();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            process.destroy();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () throws InterruptedException {\n-        return process.waitFor();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return process.getOutputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return process.getInputStream();\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return process.getErrorStream();\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of remotely launched debugee.\n- *\/\n-final class RemoteLaunchedDebugee extends Debugee {\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public RemoteLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String[] args) throws IOException {\n-        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n-        display(\"Starting remote java process:\\n\" + cmdLine);\n-        binder.launchRemoteProcess(args);\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        return binder.getRemoteProcessStatus();\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        return binder.isRemoteProcessTerminated();\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            log.display(\"Killing debugee VM process\");\n-            binder.killRemoteProcess();\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        return binder.waitForRemoteProcess();\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-}\n-\n-\n-\/**\n- * Mirror of manually launched debugee.\n- *\/\n-final class ManualLaunchedDebugee extends Debugee {\n-\n-    private int exitCode = 0;\n-    private boolean finished = false;\n-    private static BufferedReader bin = new BufferedReader(new InputStreamReader(System.in));\n-\n-    \/** Enwrap the existing <code>VM<\/code> mirror. *\/\n-    public ManualLaunchedDebugee (Binder binder) {\n-        super(binder);\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    public void launch(String commandLine) throws IOException {\n-        putMessage(\"Launch target VM using such command line:\\n\"\n-                    + commandLine);\n-        String answer = askQuestion(\"Has the VM successfully started? (yes\/no)\", \"yes\");\n-        for ( ; ; ) {\n-            if (answer.equals(\"yes\"))\n-                break;\n-            if (answer.equals(\"no\"))\n-                throw new Failure (\"Unable to manually launch debugee VM\");\n-            answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-        }\n-    }\n-\n-    private void putMessage(String msg) {\n-        System.out.println(\"\\n>>> \" + msg);\n-    }\n-\n-    private String askQuestion(String question, String defaultAnswer) {\n-        try {\n-            System.out.print(\"\\n>>> \" + question);\n-            System.out.print(\" [\" + defaultAnswer + \"] \");\n-            System.out.flush();\n-            String answer = bin.readLine();\n-            if (answer.equals(\"\"))\n-                return defaultAnswer;\n-            return answer;\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Caught exception while reading answer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/** Return exit status of the debugee VM. *\/\n-    public int getStatus () {\n-        if (! terminated()) {\n-            throw new Failure(\"Unable to get status of debugee VM: process still alive\");\n-        }\n-        return exitCode;\n-    }\n-\n-    \/** Check whether the debugee VM has been terminated. *\/\n-    public boolean terminated () {\n-        if(! finished) {\n-            String answer = askQuestion(\"Has the VM exited?\", \"no\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"no\"))\n-                    return false;\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    waitForDebugee();\n-                    break;\n-                }\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-        return finished;\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/** Kill the debugee VM. *\/\n-    protected void killDebugee () {\n-        super.killDebugee();\n-        if (!terminated()) {\n-            putMessage(\"Kill launched VM\");\n-            String answer = askQuestion(\"Has the VM successfully terminated? (yes\/no)\", \"yes\");\n-            for ( ; ; ) {\n-                if (answer.equals(\"yes\")) {\n-                    finished = true;\n-                    break;\n-                }\n-                if (answer.equals(\"no\"))\n-                    throw new Failure (\"Unable to manually kill debugee VM\");\n-                answer = askQuestion(\"Wrong answer. Please type yes or no\", \"yes\");\n-            }\n-        }\n-    }\n-\n-    \/** Wait until the debugee VM shutdown or crash. *\/\n-    protected int waitForDebugee () {\n-        putMessage(\"Wait for launched VM to exit.\");\n-        String answer = askQuestion(\"What is VM exit code?\", \"95\");\n-        for ( ; ; ) {\n-            try {\n-                exitCode = Integer.parseInt(answer);\n-                break;\n-            } catch (NumberFormatException e) {\n-                answer = askQuestion(\"Wrong answer. Please type integer value\", \"95\");\n-            }\n-        }\n-        finished = true;\n-        return exitCode;\n-    }\n-\n-    \/** Get a pipe to write to the debugee's stdin stream. *\/\n-    protected OutputStream getInPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stdout stream. *\/\n-    protected InputStream getOutPipe () {\n-        return null;\n-    }\n-\n-    \/** Get a pipe to read the debugee's stderr stream. *\/\n-    protected InputStream getErrPipe () {\n-        return null;\n-    }\n-\n-    public void redirectStdout(OutputStream out) {\n-    }\n-\n-    public void redirectStdout(Log log, String prefix) {\n-    }\n-\n-    public void redirectStderr(OutputStream out) {\n-    }\n-\n-    public void redirectStderr(Log log, String prefix) {\n-    }\n-\n-    public void close() {\n-        try {\n-            bin.close();\n-        } catch (IOException e) {\n-            log.display(\"WARNING: Caught IOException while closing InputStream\");\n-        }\n-        bin = null;\n-        super.close();\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/Binder.java","additions":10,"deletions":333,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-abstract public class Debugee extends DebugeeProcess {\n+public class Debugee extends DebugeeProcess {\n@@ -66,0 +66,6 @@\n+    public void launch(String[] args) throws IOException {\n+        String cmdLine = ArgumentHandler.joinArguments(args, \"\\\"\");\n+        display(\"Starting java process:\\n\" + cmdLine);\n+        process = binder.launchProcess(args);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/Debugee.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n- * <li> <code>-debugee.launch=[local|remote|manual]<\/code> -\n- *   launch and bind to debugee VM locally, remotely (via BindSever) or manually\n@@ -278,5 +276,2 @@\n-        if (isLaunchedLocally()) {\n-            String mode = getDebugeeSuspendMode();\n-            return mode.equals(\"no\");\n-        }\n-        return true;\n+        String mode = getDebugeeSuspendMode();\n+        return mode.equals(\"no\");\n@@ -340,48 +335,0 @@\n-    \/**\n-     * Return debugee VM launching mode, specified by\n-     * <code>-launch.mode<\/code> command line option, or\n-     * \"<i>local<\/i>\" string by default.\n-     *\n-     * Possible values for this option are:\n-     * <ul>\n-     * <li> \"<code>local<\/code>\"\n-     * <li> \"<code>remote<\/code>\"\n-     * <li> \"<code>manual<\/code>\"\n-     * <\/ul>\n-     *\n-     * @see #isLaunchedLocally()\n-     * @see #isLaunchedRemotely()\n-     * @see #isLaunchedManually()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getLaunchMode() {\n-        return options.getProperty(\"debugee.launch\", \"local\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched locally.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedLocally() {\n-        return getLaunchMode().equals(\"local\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched remotely via\n-     * BindServer.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedRemotely() {\n-        return getLaunchMode().equals(\"remote\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee should be launched manually by user.\n-     *\n-     * @see #getLaunchMode()\n-     *\/\n-    public boolean isLaunchedManually() {\n-        return getLaunchMode().equals(\"manual\");\n-    }\n@@ -713,3 +660,1 @@\n-        if (option.equals(\"test.host\")\n-            || option.equals(\"debugee.host\")\n-            || option.equals(\"debugee.vmkind\")\n+        if (option.equals(\"debugee.vmkind\")\n@@ -751,8 +696,4 @@\n-        if (option.equals(\"debugee.launch\")) {\n-            if ((!value.equals(\"local\"))\n-                && (!value.equals(\"remote\"))\n-                && (!value.equals(\"manual\"))) {\n-                throw new BadOption(option + \": must be one of: \"\n-                                           + \"local, remote, manual \" + value);\n-            }\n-            return true;\n+        if (option.equals(\"debugee.launch\")\n+                || option.equals(\"debugee.host\")\n+                || option.equals(\"test.host\")) {\n+            throw new RuntimeException(\"debugee.host option is not supported.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -38,9 +38,0 @@\n- * The present version of <code>Binder<\/code> allows\n- * to launch debuggee VM either on local machine (<i>local<\/i> launch mode),\n- * or on remote host using <code>BindServer<\/code> utility\n- * (<i>remote<\/i> launch mode). Also there is an ability to launch\n- * debuggee VM manually as a separate process on local or remote machine\n- * (<i>manual<\/i> launch mode), which is usefull for debugging.\n- * All these launching modes are specified by command line option\n- * <code>-debugee.launch<\/code> recognized by <code>DebugeeArgumentHandler<\/code>.\n- * <p>\n@@ -108,2 +99,0 @@\n-\n-    private BindServerListener bindServerListener = null;\n@@ -389,147 +378,0 @@\n-    \/**\n-     * Make connection to remote BindServer and start BindServerListener thread.\n-     *\n-     * @throws IOException if I\/O error occured while connecting\n-     *\/\n-    public void connectToBindServer(String taskID) {\n-        if (bindServerListener != null) {\n-            throw new Failure(\"Connection to BindServer already exists\");\n-        }\n-        try {\n-            bindServerListener = new BindServerListener(this);\n-            bindServerListener.setDaemon(true);\n-            bindServerListener.connect(taskID);\n-            bindServerListener.start();\n-        } catch (IOException e) {\n-            e.printStackTrace(getOutStream());\n-            throw new Failure(\"Caught exception while connecting to BindServer:\\n\\t\" + e);\n-        }\n-    }\n-\n-    \/**\n-     * Split string into list of substrings using specified separator.\n-     *\/\n-    private static String[] splitString(String givenString, String separator) {\n-        Vector<String> tmpList = new Vector<String>();\n-        StringTokenizer tokenizer = new StringTokenizer(givenString, separator);\n-        while(tokenizer.hasMoreTokens()) {\n-            tmpList.add(tokenizer.nextToken());\n-        }\n-        String[] list = new String[tmpList.size()];\n-        for (int i = 0; i < tmpList.size(); i++) {\n-            list[i] = tmpList.elementAt(i);\n-        }\n-        return list;\n-    }\n-\n-    \/**\n-     * Send command to remote <code>BindServer<\/code> and receive reply.\n-     *\n-     * @throws IOException if I\/O error occured while launching process\n-     *\/\n-    public synchronized Object sendRemoteCommand(Object command) {\n-        try {\n-            bindServerListener.sendCommand(command);\n-            Object reply = bindServerListener.getReply();\n-            return reply;\n-        } catch (IOException e) {\n-            e.printStackTrace(log.getOutStream());\n-            throw new Failure(\"Unexpected exception while sending command to BindServer:\\n\\t\"\n-                            + e);\n-        }\n-    }\n-\n-    \/**\n-     * Launch remote process using request to <code>BindServer<\/code>.\n-     *\n-     * @throws IOException if I\/O error occured\n-     *\/\n-    public void launchRemoteProcess(String[] args) throws IOException {\n-        String pathSeparator = System.getProperty(\"path.separator\");\n-        BindServer.LaunchDebugee command =\n-            new BindServer.LaunchDebugee(args,\n-                    System.getProperty(\"file.separator\"),\n-                    System.getProperty(\"user.dir\"),\n-                    splitString(System.getProperty(\"java.library.path\"), pathSeparator),\n-                    splitString(System.getProperty(\"java.class.path\"), pathSeparator),\n-                    splitString(System.getProperty(\"java.library.path\"), pathSeparator));\n-\n-        Object reply = sendRemoteCommand(command);\n-        if (reply instanceof BindServer.OK) {\n-            \/\/ do nothing\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Return exit status of the remotely launched process\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public int getRemoteProcessStatus () {\n-        Object reply = sendRemoteCommand(new BindServer.DebugeeExitCode());\n-        if (reply instanceof BindServer.OK) {\n-            BindServer.OK castedReply = (BindServer.OK)reply;\n-            return (int)castedReply.info;\n-        } else if (reply instanceof BindServer.CaughtException) {\n-            BindServer.CaughtException castedReply = (BindServer.CaughtException)reply;\n-            throw new IllegalThreadStateException(castedReply.reason);\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Check whether the remotely launched process has been terminated\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public boolean isRemoteProcessTerminated () {\n-        try {\n-            int value = getRemoteProcessStatus();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/\/ ---------------------------------------------- \/\/\n-\n-    \/**\n-     * Kill the remotely launched process\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public void killRemoteProcess () {\n-        Object reply = sendRemoteCommand(new BindServer.KillDebugee());\n-        if (reply instanceof BindServer.OK) {\n-            return;\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n-\n-    \/**\n-     * Wait until the remotely launched process exits or crashes\n-     * using request to <code>BindServer<\/code>.\n-     *\/\n-    public int waitForRemoteProcess () {\n-\n-        Object reply = sendRemoteCommand(new BindServer.WaitForDebugee(0));\n-        if (reply instanceof BindServer.OK) {\n-            BindServer.OK castedReply = (BindServer.OK)reply;\n-            return (int)castedReply.info;\n-        } else if (reply instanceof BindServer.RequestFailed) {\n-            BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-            throw new Failure(\"BindServer error: \" + castedReply.reason);\n-        } else {\n-            throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-        }\n-    }\n@@ -541,3 +383,0 @@\n-        if (bindServerListener != null) {\n-            bindServerListener.close();\n-        }\n@@ -547,194 +386,0 @@\n-    \/**\n-     * Separate thread for listening connection from <code>BindServer<\/code>.\n-     *\/\n-    private class BindServerListener extends Thread {\n-        private SocketConnection connection = null;\n-        private Log.Logger logger = null;\n-\n-        \/** List of received responses from <code>BindServer<\/code>. *\/\n-        private LinkedList<BindServer.Response> replies = new LinkedList<BindServer.Response>();\n-\n-        \/**\n-         * Make thread.\n-         *\/\n-        public BindServerListener(Log.Logger logger) {\n-            this.logger = logger;\n-        }\n-\n-        \/**\n-         * Establish connection to <code>BindServer<\/code>.\n-         *\/\n-        public void connect(String taskID) throws IOException {\n-            String host = argumentHandler.getDebugeeHost();\n-            int port = argumentHandler.getBindPortNumber();\n-            display(\"Connecting to BindServer: \" + host + \":\" + port);\n-            connection = new SocketConnection(logger, \"BindServer\");\n-\/\/            connection.setPingTimeout(DebugeeBinder.PING_TIMEOUT);\n-            connection.attach(host, port);\n-            handshake(taskID);\n-        }\n-\n-        \/**\n-         * Receive OK(version) from BindServer and check received version number.\n-         *\/\n-        private void handshake(String taskID) {\n-            \/\/ receive OK(version)\n-            trace(TRACE_LEVEL_ACTIONS, \"Waiting for initial OK(version) from BindServer\");\n-            Object reply = connection.readObject();\n-            trace(TRACE_LEVEL_ACTIONS, \"Got initial OK(version) from BindServer: \" + reply);\n-            if (reply instanceof BindServer.RequestFailed) {\n-                BindServer.RequestFailed castedReply = (BindServer.RequestFailed)reply;\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is RequestFailed: throw Failure\");\n-                throw new Failure(\"BindServer error: \" + castedReply.reason);\n-            } else if (reply instanceof BindServer.OK) {\n-                BindServer.OK castedReply = (BindServer.OK)reply;\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is OK: check BindServer version\");\n-                if (castedReply.info != BindServer.VERSION) {\n-                    throw new Failure(\"Wrong version of BindServer: \" + castedReply.info\n-                                    + \" (expected: \" + BindServer.VERSION + \")\");\n-                }\n-                display(\"Connected to BindServer: version \" + castedReply.info);\n-            } else {\n-                trace(TRACE_LEVEL_ACTIONS, \"Reply is unknown: throw Failure\");\n-                throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-            }\n-\n-            \/\/ send TaskID(id)\n-            try {\n-                trace(TRACE_LEVEL_ACTIONS, \"Sending TaskID(id) to BindServer\");\n-                sendCommand(new BindServer.TaskID(taskID));\n-                trace(TRACE_LEVEL_ACTIONS, \"Sent TaskID(id) to BindServer\");\n-            } catch (IOException e) {\n-                throw new Failure(\"Caught IOException while sending TaskID(id) to BindServer:\\n\\t\"\n-                                + e);\n-            }\n-        }\n-\n-        \/**\n-         * Check if thread is connected to <code>BindServer<\/code>.\n-         *\/\n-        public boolean isConnected() {\n-            return (connection != null && connection.isConnected());\n-        }\n-\n-        \/**\n-         * Send a command to <\/code>BindServer<\/code>.\n-         *\/\n-        public synchronized void sendCommand(Object command) throws IOException {\n-            connection.writeObject(command);\n-        }\n-\n-        \/**\n-         * Receive response from <code>BindServer<\/code>.\n-         *\/\n-        public Object getReply() {\n-            synchronized (replies) {\n-                while (replies.isEmpty()) {\n-                    if (!isConnected()) {\n-                        throw new Failure(\"No reply from BindServer: connection lost\");\n-                    }\n-                    try {\n-                        replies.wait(TRY_DELAY);\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace(getOutStream());\n-                        throw new Failure(\"Thread interrupted while waiting for reply from BindServer:\\n\\t\"\n-                                        + e);\n-                    }\n-                }\n-                Object reply = replies.removeFirst();\n-                if (reply == null) {\n-                    throw new Failure(\"No reply from BindServer: connection lost\");\n-                }\n-                return reply;\n-            }\n-        }\n-\n-        \/**\n-         * Add response object to the list of received responses.\n-         *\/\n-        private void addReply(BindServer.Response reply) {\n-            synchronized (replies) {\n-                replies.add(reply);\n-                replies.notifyAll();\n-            }\n-        }\n-\n-        \/**\n-         * Read packets from <code>BindServer<code> connection and\n-         * notify waiting thread if response or IOPipe message received.\n-         * Received lines of redirected streams are put into log.\n-         *\/\n-        public void run() {\n-            trace(TRACE_LEVEL_THREADS, \"BindServerListener thread started\");\n-            try {\n-                for (;;) {\n-                    Object reply = connection.readObject();\n-                    if (reply == null) {\n-                        break;\n-                    } else if (reply instanceof BindServer.Disconnect) {\n-                        reply = null;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is Disconnect: close connection\");\n-                        break;\n-                    } else if (reply instanceof BindServer.RedirectedStream) {\n-                        BindServer.RedirectedStream castedReply = (BindServer.RedirectedStream)reply;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is RedirectedStream: put message into log\");\n-                        log.println(castedReply.line);\n-                    } else if (reply instanceof BindServer.Response) {\n-                        BindServer.Response castedReply = (BindServer.Response)reply;\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is reply: notify all threads waiting for reply\");\n-                        addReply(castedReply);\n-                    } else {\n-                        trace(TRACE_LEVEL_ACTIONS, \"Packet is unknown: throw Failure\");\n-                        throw new Failure(\"Wrong reply from BindServer: \" + reply);\n-                    }\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace(getOutStream());\n-                complain(\"Caught exception while reading packets from BindServer:\\n\\t\" + e);\n-            } finally {\n-                closeConnection();\n-                addReply(null);\n-                trace(TRACE_LEVEL_THREADS, \"BindServerListener thread finished\");\n-            }\n-        }\n-\n-        \/**\n-         * Send Disconnect command to <\/code>BindServer<\/code>.\n-         *\/\n-        public void disconnect() {\n-            if (connection == null) return;\n-            try {\n-                sendCommand(new BindServer.Disconnect());\n-            } catch (IOException e) {\n-                display(\"Caught IOException while requesting disconnection with BindServer\");\n-            }\n-        }\n-\n-        \/**\n-         * Close socket connection.\n-         *\/\n-        public void closeConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-        }\n-\n-        \/**\n-         * Wait for thread finished in the specified timeout or interrupt it.\n-         *\/\n-        public void waitForThread(long millis) {\n-            DebugeeBinder.waitForThread(this, millis, logger);\n-        }\n-\n-        \/**\n-         * Close this thread by waiting for it finishes or interrupt it\n-         * and close socket connection.\n-         *\/\n-        public void close() {\n-            disconnect();\n-            waitForThread(DebugeeBinder.THREAD_TIMEOUT);\n-            closeConnection();\n-        }\n-\n-    } \/\/ BindServerListener\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":0,"deletions":355,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-    \/** Need or not to check debuggee process termination at exit. *\/\n-    protected boolean checkTermination = false;\n+    \/** Need or not to check debuggee process termination. *\/\n+    private boolean checkTermination = true;\n@@ -167,1 +167,3 @@\n-    abstract protected int waitForDebugee () throws InterruptedException;\n+    protected int waitForDebugee() throws InterruptedException {\n+        return process.waitFor();\n+    }\n@@ -170,1 +172,6 @@\n-    abstract protected void killDebugee ();\n+    protected void killDebugee() {\n+        if (!terminated()) {\n+            log.display(\"Killing debugee VM process\");\n+            process.destroy();\n+        }\n+    }\n@@ -173,1 +180,11 @@\n-    abstract public boolean terminated ();\n+     public boolean terminated() {\n+        if (process == null)\n+            return true;\n+\n+        try {\n+            int value = process.exitValue();\n+            return true;\n+        } catch (IllegalThreadStateException e) {\n+            return false;\n+        }\n+    }\n@@ -176,1 +193,3 @@\n-    abstract public int getStatus ();\n+    public int getStatus() {\n+        return process.exitValue();\n+    }\n@@ -179,1 +198,3 @@\n-    abstract protected OutputStream getInPipe ();\n+    protected OutputStream getInPipe() {\n+        return process.getOutputStream();\n+    }\n@@ -182,1 +203,3 @@\n-    abstract protected InputStream getOutPipe ();\n+    protected InputStream getOutPipe() {\n+        return process.getInputStream();\n+    }\n@@ -185,2 +208,3 @@\n-    abstract protected InputStream getErrPipe ();\n-\n+    protected InputStream getErrPipe() {\n+        return process.getErrorStream();\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"}]}