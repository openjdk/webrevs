{"files":[{"patch":"@@ -2096,0 +2096,32 @@\n+bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n+                                         const G1GCCounters& counters_before) {\n+  assert_heap_not_locked();\n+\n+  while(true) {\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+\n+    \/\/ Request is trivially finished.\n+    if (op.gc_succeeded() || cause == GCCause::_g1_periodic_collection) {\n+      return op.gc_succeeded();\n+    }\n+\n+    uint full_gc_count = 0;\n+    {\n+      MutexLocker ml(Heap_lock);\n+      full_gc_count = total_full_collections();\n+    }\n+\n+    if (counters_before.total_full_collections() != full_gc_count) {\n+      return true;\n+    }\n+\n+    if (GCLocker::is_active_and_needs_gc()) {\n+      \/\/ If GCLocker is active, wait until clear before retrying.\n+      GCLocker::stall_until_clear();\n+    }\n+  }\n+}\n+\n@@ -2119,5 +2151,1 @@\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-    return op.gc_succeeded();\n+    return try_collect_fullgc(cause, counters_before);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -287,0 +287,3 @@\n+  bool try_collect_fullgc(GCCause::Cause cause,\n+                          const G1GCCounters& counters_before);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -552,2 +552,20 @@\n-  VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);\n-  VMThread::execute(&op);\n+  while (true) {\n+    VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);\n+    VMThread::execute(&op);\n+\n+    if (!VM_ParallelGCSystemGC::is_cause_full(cause) || op.full_gc_succeeded()) {\n+      return;\n+    }\n+\n+    {\n+      MutexLocker ml(Heap_lock);\n+      if (full_gc_count != total_full_collections()) {\n+        return;\n+      }\n+    }\n+\n+    if (GCLocker::is_active_and_needs_gc()) {\n+      \/\/ If GCLocker is active, wait until clear before retrying.\n+      GCLocker::stall_until_clear();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  inline void invoke_scavenge();\n+  inline bool invoke_scavenge();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-inline void ParallelScavengeHeap::invoke_scavenge() {\n-  PSScavenge::invoke();\n+inline bool ParallelScavengeHeap::invoke_scavenge() {\n+  return PSScavenge::invoke();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1681,1 +1681,1 @@\n-void PSParallelCompact::invoke(bool maximum_heap_compaction) {\n+bool PSParallelCompact::invoke(bool maximum_heap_compaction) {\n@@ -1698,2 +1698,2 @@\n-  PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n-                                      maximum_heap_compaction);\n+  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||\n+                                             maximum_heap_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-  static void invoke(bool maximum_heap_compaction);\n+  static bool invoke(bool maximum_heap_compaction);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-static bool is_cause_full(GCCause::Cause cause) {\n+bool VM_ParallelGCSystemGC::is_cause_full(GCCause::Cause cause) {\n@@ -61,1 +61,2 @@\n-  VM_GC_Operation(gc_count, gc_cause, full_gc_count, is_cause_full(gc_cause))\n+  VM_GC_Operation(gc_count, gc_cause, full_gc_count, is_cause_full(gc_cause)),\n+  _full_gc_succeeded(false)\n@@ -73,1 +74,1 @@\n-    heap->invoke_scavenge();\n+    _full_gc_succeeded = heap->invoke_scavenge();\n@@ -75,1 +76,1 @@\n-    heap->do_full_collection(false);\n+    _full_gc_succeeded = PSParallelCompact::invoke(false);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+  bool _full_gc_succeeded;\n@@ -47,0 +48,2 @@\n+  bool full_gc_succeeded() const { return _full_gc_succeeded; }\n+  static bool is_cause_full(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -799,3 +799,22 @@\n-  VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n-                       cause, max_generation);\n-  VMThread::execute(&op);\n+  while (true) {\n+    VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n+                        cause, max_generation);\n+    VMThread::execute(&op);\n+\n+    if (should_run_young_gc) {\n+      return;\n+    }\n+\n+    {\n+      MutexLocker ml(Heap_lock);\n+      \/\/ Read the GC count while holding the Heap_lock\n+      if (full_gc_count_before != total_full_collections()) {\n+        return;\n+      }\n+    }\n+\n+    if (GCLocker::is_active_and_needs_gc()) {\n+      \/\/ If GCLocker is active, wait until clear before retrying.\n+      GCLocker::stall_until_clear();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test G1 Full GC execution when JNICritical is active\n+ * @summary Check that Full GC calls are not ignored if concurrent with an active GCLocker.\n+ * @bug 8057586\n+ * @requires vm.gc.G1\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xms3g -Xmx3g -Xmn2g -Xlog:gc TestJNICriticalStressTest 30 4 1 G1\n+ *\/\n+\n+ \/*\n+ * @test Parallel Full GC execution when JNICritical is active\n+ * @bug 8057586\n+ * @requires vm.gc.Parallel\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -Xms3g -Xmx3g -Xmn2g -Xlog:gc TestJNICriticalStressTest 30 4 1 Parallel\n+ *\/\n+\n+\/*\n+ * @test Serial Full GC execution when JNICritical is active\n+ * @bug 8057586\n+ * @requires vm.gc.Serial\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseSerialGC -Xms3g -Xmx3g -Xmn2g -Xlog:gc TestJNICriticalStressTest 30 4 1 Serial\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.Deflater;\n+\n+\/**\n+ * Test verifies that Full GC calls are not ignored if concurrent with an active GCLocker.\n+ *\n+ * The test checks that at least a full gc is executed in the duration of a WhiteBox.fullGC() call;\n+ * either by the calling thread or a concurrent thread.\n+ *\/\n+public class TestJNICriticalStressTest {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    static private final int LARGE_MAP_SIZE = 64 * 1024;\n+\n+    static private final int MAP_ARRAY_LENGTH = 4;\n+    static private final int MAP_SIZE = 1024;\n+\n+    static private final int BYTE_ARRAY_LENGTH = 16 * 1024;\n+\n+    static private final long SYSTEM_GC_PERIOD_MS = 5 * 1000;\n+    static private long gcCountBefore = 0;\n+    static private GarbageCollectorMXBean collector = null;\n+\n+    static private void println(String str) { System.out.println(str); }\n+    static private void exit(int code)      { System.exit(code);       }\n+\n+    static Map<Integer,String> populateMap(int size) {\n+        Map<Integer,String> map = new HashMap<Integer,String>();\n+        for (int i = 0; i < size; i += 1) {\n+            Integer keyInt = Integer.valueOf(i);\n+            String valStr = \"value is [\" + i + \"]\";\n+            map.put(keyInt,valStr);\n+        }\n+        return map;\n+    }\n+\n+    static private class AllocatingWorker implements Runnable {\n+        private final Object[] array = new Object[MAP_ARRAY_LENGTH];\n+        private int arrayIndex = 0;\n+\n+        private void doStep() {\n+            Map<Integer,String> map = populateMap(MAP_SIZE);\n+            array[arrayIndex] = map;\n+            arrayIndex = (arrayIndex + 1) % MAP_ARRAY_LENGTH;\n+        }\n+\n+        public void run() {\n+            while (true) {\n+                doStep();\n+            }\n+        }\n+    }\n+\n+    static private class JNICriticalWorker implements Runnable {\n+        private int count;\n+\n+        private void doStep() {\n+            byte[] inputArray = new byte[BYTE_ARRAY_LENGTH];\n+            for (int i = 0; i < inputArray.length; i += 1) {\n+                inputArray[i] = (byte) (count + i);\n+            }\n+\n+            Deflater deflater = new Deflater();\n+            deflater.setInput(inputArray);\n+            deflater.finish();\n+\n+            byte[] outputArray = new byte[2 * inputArray.length];\n+            deflater.deflate(outputArray);\n+            deflater.end();\n+\n+            count += 1;\n+        }\n+\n+        public void run() {\n+            while (true) {\n+                doStep();\n+            }\n+        }\n+    }\n+\n+    static private class SystemGCWorker implements Runnable {\n+        public void run() {\n+            long fullGcCounts = 0;\n+            while (true) {\n+                try {\n+                    Thread.sleep(SYSTEM_GC_PERIOD_MS);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                    return;\n+                }\n+\n+                long gcCountBefore = collector.getCollectionCount();\n+                wb.fullGC();\n+                long gcCountAfter = collector.getCollectionCount();\n+\n+                Asserts.assertLessThan(gcCountBefore, gcCountAfter, \"Triggered more Full GCs than expected\");\n+            }\n+        }\n+    }\n+\n+    static public Map<Integer,String> largeMap;\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length < 4) {\n+            println(\"usage: JNICriticalStressTest <duration sec> <alloc threads> <jni critical threads> <gc name>\");\n+            exit(-1);\n+        }\n+\n+        long durationSec = Long.parseLong(args[0]);\n+        int allocThreadNum = Integer.parseInt(args[1]);\n+        int jniCriticalThreadNum = Integer.parseInt(args[2]);\n+\n+        StringBuilder OldGCName = new StringBuilder();\n+        switch (args[3]) {\n+            case \"G1\":\n+                OldGCName.append(\"G1 Old Generation\");\n+                break;\n+            case \"Parallel\":\n+                OldGCName.append(\"PS MarkSweep\");\n+                break;\n+            case \"Serial\":\n+                OldGCName.append(\"MarkSweepCompact\");\n+                break;\n+            default:\n+                throw new RuntimeException(\"Unsupported GC selected\");\n+        }\n+\n+        List<GarbageCollectorMXBean> collectors = ManagementFactory.getGarbageCollectorMXBeans();\n+\n+        for (int i = 0; i < collectors.size(); i++) {\n+            if (collectors.get(i).getName().contains(OldGCName.toString())) {\n+                collector = collectors.get(i);\n+                break;\n+            }\n+        }\n+\n+        if (collector == null) {\n+            throw new RuntimeException(OldGCName.toString() + \" not found\");\n+        }\n+\n+        println(\"Running for \" + durationSec + \" secs\");\n+\n+        largeMap = populateMap(LARGE_MAP_SIZE);\n+\n+        println(\"Starting \" + allocThreadNum + \" allocating threads\");\n+        for (int i = 0; i < allocThreadNum; i += 1) {\n+            new Thread(new AllocatingWorker()).start();\n+        }\n+\n+        println(\"Starting \" + jniCriticalThreadNum + \" jni critical threads\");\n+        for (int i = 0; i < jniCriticalThreadNum; i += 1) {\n+            new Thread(new JNICriticalWorker()).start();\n+        }\n+\n+        new Thread(new SystemGCWorker()).start();\n+\n+        long durationMS = (long) (1000 * durationSec);\n+        long start = System.currentTimeMillis();\n+        long now = start;\n+        long soFar = now - start;\n+        while (soFar < durationMS) {\n+            try {\n+                Thread.sleep(durationMS - soFar);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                return;\n+            }\n+            now = System.currentTimeMillis();\n+            soFar = now - start;\n+        }\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestJNICriticalStressTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"}]}