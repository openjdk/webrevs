{"files":[{"patch":"@@ -63,1 +63,1 @@\n-  JavaThread* _target;\n+  JavaThread* _current;\n@@ -69,2 +69,2 @@\n-    _vthread(t, t->vthread()), _target(t), _result(freeze_pinned_native), _failed(false) {\n-    assert(!_target->is_in_VTMS_transition(), \"must be\");\n+    _vthread(t, t->vthread()), _current(t), _result(freeze_pinned_native), _failed(false) {\n+    assert(!_current->is_in_VTMS_transition(), \"must be\");\n@@ -78,2 +78,2 @@\n-        JvmtiThreadState* state = _target->jvmti_thread_state();\n-        if (_target->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n+        JvmtiThreadState* state = _current->jvmti_thread_state();\n+        if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n@@ -86,1 +86,1 @@\n-      if (_target->has_async_exception_condition()) {\n+      if (_current->has_async_exception_condition()) {\n@@ -90,1 +90,1 @@\n-      _target->set_is_in_VTMS_transition(true);\n+      _current->set_is_in_VTMS_transition(true);\n@@ -95,1 +95,1 @@\n-    assert(!_target->is_suspended(), \"must be\");\n+    assert(!_current->is_suspended(), \"must be\");\n@@ -97,1 +97,1 @@\n-    assert(_target->is_in_VTMS_transition(), \"must be\");\n+    assert(_current->is_in_VTMS_transition(), \"must be\");\n@@ -109,1 +109,1 @@\n-        _target->set_is_in_VTMS_transition(false);\n+        _current->set_is_in_VTMS_transition(false);\n@@ -118,3 +118,3 @@\n-static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* target) {\n-  if (target->is_in_VTMS_transition()) {\n-    \/\/ We caught target at the end of a mount transition.\n+static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* current) {\n+  if (current->is_in_VTMS_transition()) {\n+    \/\/ We are at the end of a mount transition.\n@@ -127,1 +127,1 @@\n-static bool is_vthread_safe_to_preempt(JavaThread* target, oop vthread) {\n+static bool is_vthread_safe_to_preempt(JavaThread* current, oop vthread) {\n@@ -132,1 +132,1 @@\n-  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(target)) NOT_JVMTI(true);\n+  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(current)) NOT_JVMTI(true);\n@@ -137,6 +137,6 @@\n-static void verify_preempt_preconditions(JavaThread* target, oop continuation) {\n-  assert(target == JavaThread::current(), \"no support for external preemption\");\n-  assert(target->has_last_Java_frame(), \"\");\n-  assert(!target->preempting(), \"\");\n-  assert(target->last_continuation() != nullptr, \"\");\n-  assert(target->last_continuation()->cont_oop(target) == continuation, \"\");\n+static void verify_preempt_preconditions(JavaThread* current, oop continuation) {\n+  assert(current == JavaThread::current(), \"no support for external preemption\");\n+  assert(current->has_last_Java_frame(), \"\");\n+  assert(!current->preempting(), \"\");\n+  assert(current->last_continuation() != nullptr, \"\");\n+  assert(current->last_continuation()->cont_oop(current) == continuation, \"\");\n@@ -144,1 +144,1 @@\n-  assert(!target->has_pending_exception(), \"\");\n+  assert(!current->has_pending_exception(), \"\");\n@@ -147,2 +147,2 @@\n-freeze_result Continuation::try_preempt(JavaThread* target, oop continuation) {\n-  verify_preempt_preconditions(target, continuation);\n+freeze_result Continuation::try_preempt(JavaThread* current, oop continuation) {\n+  verify_preempt_preconditions(current, continuation);\n@@ -154,1 +154,1 @@\n-  if (!is_vthread_safe_to_preempt(target, target->vthread())) {\n+  if (!is_vthread_safe_to_preempt(current, current->vthread())) {\n@@ -158,1 +158,1 @@\n-  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(target);)\n+  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(current);)\n@@ -160,1 +160,1 @@\n-  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(target, target->last_Java_sp());\n+  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(current, current->last_Java_sp());\n@@ -164,1 +164,1 @@\n-  if (target->has_pending_exception()) {\n+  if (current->has_pending_exception()) {\n@@ -168,1 +168,1 @@\n-    target->clear_pending_exception();\n+    current->clear_pending_exception();\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=monitorenter\n+ * @bug 8345266\n+ * @summary Test OOM while trying to unmount vthread on monitorenter\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME false\n+ *\/\n+\n+\/*\n+ * @test id=timedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 5\n+ *\/\n+\n+\/*\n+ * @test id=untimedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 0\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class MonitorEnterWaitOOME {\n+    static volatile Object data;\n+    static Thread.State dummyState = Thread.State.RUNNABLE; \/\/ load java.lang.Thread$State\n+\n+    public static void main(String[] args) throws Throwable {\n+        final boolean testWait = args.length >= 1 ? Boolean.parseBoolean(args[0]) : false;\n+        final long timeout = testWait && args.length == 2 ? Long.parseLong(args[1]) : 0L;\n+\n+        Thread vthread;\n+        var lock = new Object();\n+        var canFillHeap = new AtomicBoolean();\n+        var heapFilled = new AtomicBoolean();\n+        var heapCollected = new AtomicBoolean();\n+        var exRef = new AtomicReference<Throwable>();\n+        synchronized (lock) {\n+            vthread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    awaitTrue(canFillHeap);\n+                    data = fillHeap();\n+                    heapFilled.set(true);\n+                    synchronized (lock) {\n+                        if (testWait) {\n+                            lock.wait(timeout);\n+                        }\n+                    }\n+                    data = null;\n+                    System.gc();\n+                    heapCollected.set(true);\n+                } catch (Throwable e) {\n+                    data = null;\n+                    System.gc(); \/\/ avoid nested OOME\n+                    exRef.set(e);\n+                }\n+            });\n+            canFillHeap.set(true);\n+            awaitTrue(heapFilled);\n+            awaitState(vthread, Thread.State.BLOCKED);\n+        }\n+        if (testWait && timeout == 0) {\n+            awaitState(vthread, Thread.State.WAITING);\n+            synchronized (lock) {\n+                lock.notify();\n+            }\n+        }\n+        joinVThread(vthread, heapCollected, exRef);\n+        assert exRef.get() == null;\n+    }\n+\n+    private static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+\n+    private static void awaitTrue(AtomicBoolean ready) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (!ready.get()) {}\n+    }\n+\n+    private static void awaitState(Thread thread, Thread.State expectedState) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (thread.getState() != expectedState) {}\n+    }\n+\n+    private static void joinVThread(Thread vthread, AtomicBoolean ready, AtomicReference<Throwable> exRef) throws Throwable {\n+        \/\/ Don't call anything that might allocate from the Java heap until ready is set.\n+        while (!ready.get()) {\n+            Throwable ex = exRef.get();\n+            if (ex != null) {\n+                throw ex;\n+            }\n+        }\n+        vthread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterWaitOOME.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=monitorenter\n- * @bug 8345266\n- * @summary Test OOM while trying to unmount vthread on monitorenter\n- * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorOOM false\n- *\/\n-\n-\/*\n- * @test id=wait\n- * @bug 8345266\n- * @summary Test OOM while trying to unmount vthread on Object.wait\n- * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n- * @library \/test\/lib\n- * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorOOM true\n- *\/\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-public class MonitorOOM {\n-    static volatile Object data;\n-\n-    public static void main(String[] args) throws Throwable {\n-        final boolean testWait = args.length == 1 ? Boolean.parseBoolean(args[0]) : false;\n-\n-        Thread vthread;\n-        var lock = new Object();\n-        var canFillHeap = new AtomicBoolean();\n-        var heapFilled = new AtomicBoolean();\n-        var heapCollected = new AtomicBoolean();\n-        var exRef = new AtomicReference<Throwable>();\n-        synchronized (lock) {\n-            vthread = Thread.ofVirtual().start(() -> {\n-                try {\n-                    awaitTrue(canFillHeap);\n-                    data = fillHeap();\n-                    heapFilled.set(true);\n-                    synchronized (lock) {\n-                        if (testWait) {\n-                            lock.wait(5);\n-                        }\n-                    }\n-                    data = null;\n-                    System.gc();\n-                    heapCollected.set(true);\n-                } catch (Throwable e) {\n-                    data = null;\n-                    System.gc(); \/\/ avoid nested OOME\n-                    exRef.set(e);\n-                }\n-            });\n-            canFillHeap.set(true);\n-            awaitTrue(heapFilled);\n-            loopMillis(100); \/\/ allow vthread to reach synchronized\n-        }\n-        joinVThread(vthread, heapCollected, exRef);\n-        assert exRef.get() == null;\n-    }\n-\n-    private static Object[] fillHeap() {\n-        Object[] first = null, last = null;\n-        int size = 1 << 20;\n-        while (size > 0) {\n-            try {\n-                Object[] array = new Object[size];\n-                if (first == null) {\n-                    first = array;\n-                } else {\n-                    last[0] = array;\n-                }\n-                last = array;\n-            } catch (OutOfMemoryError oome) {\n-                size = size >>> 1;\n-            }\n-        }\n-        return first;\n-    }\n-\n-    private static void awaitTrue(AtomicBoolean ready) {\n-        \/\/ Don't call anything that might allocate from the Java heap.\n-        while (!ready.get()) {}\n-    }\n-\n-    private static void loopMillis(long millis) {\n-        \/\/ Don't call anything that might allocate from the Java heap.\n-        long start = System.currentTimeMillis();\n-        while ((System.currentTimeMillis() - start) < millis) {}\n-    }\n-\n-    private static void joinVThread(Thread vthread, AtomicBoolean ready, AtomicReference<Throwable> exRef) throws Throwable {\n-        \/\/ Don't call anything that might allocate from the Java heap until ready is set.\n-        while (!ready.get()) {\n-            Throwable ex = exRef.get();\n-            if (ex != null) {\n-                throw ex;\n-            }\n-        }\n-        vthread.join();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorOOM.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"}]}