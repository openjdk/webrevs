{"files":[{"patch":"@@ -163,0 +163,7 @@\n+\n+  if (target->has_pending_exception()) {\n+    assert(res == freeze_exception, \"\");\n+    \/\/ We don't want to throw exceptions, especially when returning\n+    \/\/ from monitorenter since the compiler does not expect one.\n+    target->clear_pending_exception();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java 8345266 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=monitorenter\n+ * @bug 8345266\n+ * @summary Test OOM while trying to unmount vthread on monitorenter\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorOOM false\n+ *\/\n+\n+\/*\n+ * @test id=wait\n+ * @bug 8345266\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorOOM true\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class MonitorOOM {\n+    static volatile Object data;\n+\n+    public static void main(String[] args) throws Throwable {\n+        final boolean testWait = args.length == 1 ? Boolean.parseBoolean(args[0]) : false;\n+\n+        Thread vthread;\n+        var lock = new Object();\n+        var canFillHeap = new AtomicBoolean();\n+        var heapFilled = new AtomicBoolean();\n+        var heapCollected = new AtomicBoolean();\n+        var exRef = new AtomicReference<Throwable>();\n+        synchronized (lock) {\n+            vthread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    awaitTrue(canFillHeap);\n+                    data = fillHeap();\n+                    heapFilled.set(true);\n+                    synchronized (lock) {\n+                        if (testWait) {\n+                            lock.wait(5);\n+                        }\n+                    }\n+                    data = null;\n+                    System.gc();\n+                    heapCollected.set(true);\n+                } catch (Throwable e) {\n+                    data = null;\n+                    System.gc(); \/\/ avoid nested OOME\n+                    exRef.set(e);\n+                }\n+            });\n+            canFillHeap.set(true);\n+            awaitTrue(heapFilled);\n+            loopMillis(100); \/\/ allow vthread to reach synchronized\n+        }\n+        joinVThread(vthread, heapCollected, exRef);\n+        assert exRef.get() == null;\n+    }\n+\n+    private static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+\n+    private static void awaitTrue(AtomicBoolean ready) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (!ready.get()) {}\n+    }\n+\n+    private static void loopMillis(long millis) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        long start = System.currentTimeMillis();\n+        while ((System.currentTimeMillis() - start) < millis) {}\n+    }\n+\n+    private static void joinVThread(Thread vthread, AtomicBoolean ready, AtomicReference<Throwable> exRef) throws Throwable {\n+        \/\/ Don't call anything that might allocate from the Java heap until ready is set.\n+        while (!ready.get()) {\n+            Throwable ex = exRef.get();\n+            if (ex != null) {\n+                throw ex;\n+            }\n+        }\n+        vthread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorOOM.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}