{"files":[{"patch":"@@ -329,4 +329,2 @@\n-                                                  buf.thisClass().asSymbol(),\n-                                                  methodInfo.methodName().stringValue(),\n-                                                  MethodTypeDesc.ofDescriptor(methodInfo.methodType().stringValue()),\n-                                                  (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0,\n+                                                  buf.thisClass(),\n+                                                  methodInfo,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.classfile.impl.Util.findParams;\n@@ -158,1 +159,0 @@\n-    private static final String OBJECT_INITIALIZER_NAME = \"<init>\";\n@@ -187,1 +187,1 @@\n-    private final MethodTypeDesc methodDesc;\n+    private final String methodDesc;\n@@ -208,3 +208,1 @@\n-     * @param methodName method name to generate stack maps for\n-     * @param methodDesc method descriptor to generate stack maps for\n-     * @param isStatic information whether the method is static\n+     * @param methodInfo method info to generate stack maps for\n@@ -217,4 +215,2 @@\n-                     ClassDesc thisClass,\n-                     String methodName,\n-                     MethodTypeDesc methodDesc,\n-                     boolean isStatic,\n+                     ClassEntry thisClass,\n+                     MethodInfo methodInfo,\n@@ -224,4 +220,4 @@\n-        this.thisType = Type.referenceType(thisClass);\n-        this.methodName = methodName;\n-        this.methodDesc = methodDesc;\n-        this.isStatic = isStatic;\n+        this.thisType = Type.referenceType(thisClass.asSymbol());\n+        this.methodName = methodInfo.methodName().stringValue();\n+        this.methodDesc = methodInfo.methodType().stringValue();\n+        this.isStatic = (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0;\n@@ -256,2 +252,11 @@\n-        for (var f : frames) {\n-            if (f.offset == offset) return f;\n+        int low = 0;\n+        int high = frames.size() - 1;\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            var f = frames.get(mid);\n+            if (f.offset < offset)\n+                low = mid + 1;\n+            else if (f.offset > offset)\n+                high = mid - 1;\n+            else\n+                return f;\n@@ -795,1 +800,1 @@\n-            if (OBJECT_INITIALIZER_NAME.equals(invokeMethodName)) {\n+            if (INIT_NAME.equals(invokeMethodName)) {\n@@ -829,1 +834,1 @@\n-        currentFrame.pushStack(cpIndexToType(index, cp).toArray());\n+        currentFrame.pushStack(Type.toArray(cpIndexToType(index, cp)));\n@@ -846,1 +851,1 @@\n-        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s%s\".formatted(\n@@ -850,1 +855,1 @@\n-                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+                methodDesc.substring(0, methodDesc.indexOf(')') + 1)));\n@@ -855,1 +860,1 @@\n-            clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n+            clb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodDesc), isStatic ? ACC_STATIC : 0, mb ->\n@@ -964,1 +969,1 @@\n-        boolean localsChanged = true;\n+        boolean localsChanged = false;\n@@ -994,2 +999,2 @@\n-            return switch (desc.descriptorString()) {\n-                case \"J\" ->\n+            return switch (desc.descriptorString().charAt(0)) {\n+                case 'J' ->\n@@ -997,1 +1002,1 @@\n-                case \"D\" ->\n+                case 'D' ->\n@@ -999,1 +1004,1 @@\n-                case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -1001,1 +1006,1 @@\n-                case \"F\" ->\n+                case 'F' ->\n@@ -1003,1 +1008,1 @@\n-                case \"V\" ->\n+                case 'V' ->\n@@ -1005,1 +1010,1 @@\n-                default ->\n+                case '[', 'L' ->\n@@ -1007,0 +1012,2 @@\n+                default ->\n+                    throw new IllegalArgumentException(\"Unknown descriptor \" + desc.descriptorString());\n@@ -1041,1 +1048,1 @@\n-                if (locals[i].equals(old_object)) {\n+                if (old_object.equals(locals[i])) {\n@@ -1047,1 +1054,1 @@\n-                if (stack[i].equals(old_object)) {\n+                if (old_object.equals(stack[i])) {\n@@ -1060,2 +1067,0 @@\n-                Arrays.fill(locals, Type.TOP_TYPE);\n-                localsChanged = true;\n@@ -1065,2 +1070,0 @@\n-                Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n-                localsChanged = true;\n@@ -1075,1 +1078,0 @@\n-                Arrays.fill(stack, Type.TOP_TYPE);\n@@ -1079,1 +1081,0 @@\n-                Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n@@ -1085,0 +1086,1 @@\n+            localsChanged |= !Objects.equals(type, locals[index]);\n@@ -1086,1 +1088,0 @@\n-            localsChanged = true;\n@@ -1089,1 +1090,1 @@\n-        void setLocalsFromArg(String name, MethodTypeDesc methodDesc, boolean isStatic, Type thisKlass) {\n+        void setLocalsFromArg(String name, String methodDesc, boolean isStatic, Type thisKlass) {\n@@ -1093,1 +1094,1 @@\n-                if (OBJECT_INITIALIZER_NAME.equals(name) && !CD_Object.equals(thisKlass.sym)) {\n+                if (INIT_NAME.equals(name) && !CD_Object.equals(thisKlass.sym)) {\n@@ -1100,6 +1101,13 @@\n-            for (int i = 0; i < methodDesc.parameterCount(); i++) {\n-                var desc = methodDesc.parameterType(i);\n-                if (desc.isClassOrInterface() || desc.isArray()) {\n-                    setLocalRawInternal(localsSize++, Type.referenceType(desc));\n-                } else switch (desc.descriptorString()) {\n-                    case \"J\" -> {\n+            if (methodDesc.charAt(0) != '(') throw new IllegalArgumentException(\"Invalid method type decriptor \" + methodDesc);\n+            for (int i = 1; i < methodDesc.length(); ++i) {\n+                switch (methodDesc.charAt(i)) {\n+                    case '[', 'L' -> {\n+                        int s = i;\n+                        while (methodDesc.charAt(i) == '[') i++;\n+                        if (methodDesc.charAt(i) == 'L') {\n+                            while (methodDesc.charAt(++i) != ';')\n+                                ;\n+                        }\n+                        setLocalRawInternal(localsSize++, Type.referenceType(ClassDesc.ofDescriptor(methodDesc.substring(s, i + 1))));\n+                    }\n+                    case 'J' -> {\n@@ -1109,1 +1117,1 @@\n-                    case \"D\" -> {\n+                    case 'D' -> {\n@@ -1113,1 +1121,1 @@\n-                    case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                    case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -1115,1 +1123,1 @@\n-                    case \"F\" ->\n+                    case 'F' ->\n@@ -1117,1 +1125,4 @@\n-                    default -> throw new AssertionError(\"Should not reach here\");\n+                    case ')' ->\n+                        i = methodDesc.length();\n+                    default ->\n+                        throw new IllegalArgumentException(\"Invalid method type decriptor \" + methodDesc);\n@@ -1123,1 +1134,1 @@\n-            if (locals != null && src.localsSize < locals.length) Arrays.fill(locals, src.localsSize, locals.length, Type.TOP_TYPE);\n+            if (locals != null && src.localsSize < locals.length) Arrays.fill(locals, src.localsSize, locals.length, null);\n@@ -1127,1 +1138,1 @@\n-            if (stack != null && src.stackSize < stack.length) Arrays.fill(stack, src.stackSize, stack.length, Type.TOP_TYPE);\n+            if (stack != null && src.stackSize < stack.length) Arrays.fill(stack, src.stackSize, stack.length, null);\n@@ -1173,1 +1184,1 @@\n-                setLocalRawInternal(index + 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index + 1, null);\n@@ -1176,1 +1187,1 @@\n-                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index - 1, null);\n@@ -1187,1 +1198,1 @@\n-                setLocalRawInternal(index + 2, Type.TOP_TYPE);\n+                setLocalRawInternal(index + 2, null);\n@@ -1191,1 +1202,1 @@\n-                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index - 1, null);\n@@ -1202,1 +1213,1 @@\n-            var newTo = to.mergeFrom(me, classHierarchy);\n+            var newTo = Type.mergeFrom(to, me, classHierarchy);\n@@ -1210,1 +1221,1 @@\n-            while (count > 0 && types[count - 1] == Type.TOP_TYPE) count--;\n+            while (count > 0 && types[count - 1] == null) count--;\n@@ -1213,2 +1224,3 @@\n-                if (!types[i].isCategory2_2nd()) {\n-                    types[compressed++] = types[i];\n+                var t = types[i];\n+                if (t == null || !t.isCategory2_2nd()) {\n+                    types[compressed++] = t;\n@@ -1241,1 +1253,1 @@\n-                        for (int i=commonLocalsSize; i<localsSize; i++) locals[i].writeTo(out, cp);\n+                        for (int i=commonLocalsSize; i<localsSize; i++) Type.writeTo(locals[i], out, cp);\n@@ -1252,1 +1264,1 @@\n-                stack[0].writeTo(out, cp);\n+                Type.writeTo(stack[0], out, cp);\n@@ -1259,1 +1271,1 @@\n-            for (int i=0; i<localsSize; i++) locals[i].writeTo(out, cp);\n+            for (int i=0; i<localsSize; i++) Type.writeTo(locals[i], out, cp);\n@@ -1261,1 +1273,1 @@\n-            for (int i=0; i<stackSize; i++) stack[i].writeTo(out, cp);\n+            for (int i=0; i<stackSize; i++) Type.writeTo(stack[i], out, cp);\n@@ -1268,2 +1280,1 @@\n-        static final Type TOP_TYPE = simpleType(ITEM_TOP),\n-                NULL_TYPE = simpleType(ITEM_NULL),\n+        static final Type NULL_TYPE = simpleType(ITEM_NULL),\n@@ -1331,3 +1342,3 @@\n-        Type mergeFrom(Type from, ClassHierarchyImpl context) {\n-            if (this == TOP_TYPE || this == from || equals(from)) {\n-                return this;\n+        static Type mergeFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n+            if (thisType == null || thisType == from || thisType.equals(from)) {\n+                return thisType;\n@@ -1335,1 +1346,1 @@\n-                return switch (tag) {\n+                return switch (thisType.tag) {\n@@ -1337,1 +1348,1 @@\n-                        from == INTEGER_TYPE ? this : TOP_TYPE;\n+                        from == INTEGER_TYPE ? thisType : null;\n@@ -1339,1 +1350,1 @@\n-                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                        thisType.isReference() && from != null && from.isReference() ? mergeReferenceFrom(thisType, from, context) : null;\n@@ -1344,3 +1355,3 @@\n-        Type mergeComponentFrom(Type from, ClassHierarchyImpl context) {\n-            if (this == TOP_TYPE || this == from || equals(from)) {\n-                return this;\n+        static Type mergeComponentFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n+            if (thisType == null || thisType == from || thisType.equals(from)) {\n+                return thisType;\n@@ -1348,1 +1359,1 @@\n-                return switch (tag) {\n+                return switch (thisType.tag) {\n@@ -1350,1 +1361,1 @@\n-                        TOP_TYPE;\n+                        null;\n@@ -1352,1 +1363,1 @@\n-                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                        thisType.isReference() && from != null && from.isReference() ? mergeReferenceFrom(thisType, from, context) : null;\n@@ -1360,1 +1371,1 @@\n-        private Type mergeReferenceFrom(Type from, ClassHierarchyImpl context) {\n+        static private Type mergeReferenceFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n@@ -1362,2 +1373,2 @@\n-                return this;\n-            } else if (this == NULL_TYPE) {\n+                return thisType;\n+            } else if (thisType == NULL_TYPE) {\n@@ -1365,5 +1376,5 @@\n-            } else if (sym.equals(from.sym)) {\n-                return this;\n-            } else if (isObject()) {\n-                if (CD_Object.equals(sym)) {\n-                    return this;\n+            } else if (thisType.sym.equals(from.sym)) {\n+                return thisType;\n+            } else if (thisType.isObject()) {\n+                if (CD_Object.equals(thisType.sym)) {\n+                    return thisType;\n@@ -1371,3 +1382,3 @@\n-                if (context.isInterface(sym)) {\n-                    if (!from.isArray() || CD_Cloneable.equals(sym) || CD_Serializable.equals(sym)) {\n-                        return this;\n+                if (context.isInterface(thisType.sym)) {\n+                    if (!from.isArray() || CD_Cloneable.equals(thisType.sym) || CD_Serializable.equals(thisType.sym)) {\n+                        return thisType;\n@@ -1376,2 +1387,2 @@\n-                    var anc = context.commonAncestor(sym, from.sym);\n-                    return anc == null ? this : Type.referenceType(anc);\n+                    var anc = context.commonAncestor(thisType.sym, from.sym);\n+                    return anc == null ? thisType : Type.referenceType(anc);\n@@ -1379,2 +1390,2 @@\n-            } else if (isArray() && from.isArray()) {\n-                Type compThis = getComponent();\n+            } else if (thisType.isArray() && from.isArray()) {\n+                Type compThis = thisType.getComponent();\n@@ -1382,2 +1393,2 @@\n-                if (compThis != TOP_TYPE && compFrom != TOP_TYPE) {\n-                    return  compThis.mergeComponentFrom(compFrom, context).toArray();\n+                if (compThis != null && compFrom != null) {\n+                    return  Type.toArray(mergeComponentFrom(compThis, compFrom, context));\n@@ -1389,2 +1400,2 @@\n-        Type toArray() {\n-            return switch (tag) {\n+        static Type toArray(Type t) {\n+            return t == null ? OBJECT_TYPE : switch (t.tag) {\n@@ -1399,1 +1410,1 @@\n-                case ITEM_OBJECT -> Type.referenceType(sym.arrayType());\n+                case ITEM_OBJECT -> Type.referenceType(t.sym.arrayType());\n@@ -1417,1 +1428,1 @@\n-                        default -> Type.TOP_TYPE;\n+                        default -> null;\n@@ -1422,1 +1433,1 @@\n-            return Type.TOP_TYPE;\n+            return null;\n@@ -1425,7 +1436,11 @@\n-        void writeTo(BufWriter bw, ConstantPoolBuilder cp) {\n-            bw.writeU1(tag);\n-            switch (tag) {\n-                case ITEM_OBJECT ->\n-                    bw.writeU2(cp.classEntry(sym).index());\n-                case ITEM_UNINITIALIZED ->\n-                    bw.writeU2(bci);\n+        static void writeTo(Type t, BufWriter bw, ConstantPoolBuilder cp) {\n+            if (t == null) {\n+                bw.writeU1(ITEM_TOP);\n+            } else {\n+                bw.writeU1(t.tag);\n+                switch (t.tag) {\n+                    case ITEM_OBJECT ->\n+                        bw.writeU2(cp.classEntry(t.sym).index());\n+                    case ITEM_UNINITIALIZED ->\n+                        bw.writeU2(t.bci);\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":121,"deletions":106,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.classfile.constantpool.ClassEntry;\n@@ -40,0 +41,1 @@\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n@@ -43,0 +45,1 @@\n+import jdk.internal.classfile.impl.MethodInfo;\n@@ -64,4 +67,4 @@\n-                    ClassDesc thisClass,\n-                    String methodName,\n-                    MethodTypeDesc methodDesc,\n-                    boolean isStatic,\n+                    ClassEntry thisClass,\n+                    Utf8Entry methodName,\n+                    Utf8Entry methodType,\n+                    int methodFlags,\n@@ -70,1 +73,6 @@\n-                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {}\n+                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) implements MethodInfo {\n+\n+        public int parameterSlot(int paramNo) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n@@ -82,1 +90,1 @@\n-                var thisCls = clm.thisClass().asSymbol();\n+                var thisCls = clm.thisClass();\n@@ -90,3 +98,3 @@\n-                                m.methodName().stringValue(),\n-                                m.methodTypeSymbol(),\n-                                (m.flags().flagsMask() & Classfile.ACC_STATIC) != 0,\n+                                m.methodName(),\n+                                m.methodType(),\n+                                m.flags().flagsMask(),\n@@ -112,3 +120,1 @@\n-                d.methodName(),\n-                d.methodDesc(),\n-                d.isStatic(),\n+                d,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"}]}