{"files":[{"patch":"@@ -170,5 +170,6 @@\n-        return String.format(\"(%s)%s\",\n-                             Stream.of(parameterArray())\n-                                   .map(ClassDesc::descriptorString)\n-                                   .collect(Collectors.joining()),\n-                             returnType().descriptorString());\n+        var sb = new StringBuilder();\n+        sb.append('(');\n+        for (int i=0; i<parameterCount(); i++) {\n+            sb.append(parameterType(i).descriptorString());\n+        }\n+        return sb.append(')').append(returnType().descriptorString()).toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,2 +74,6 @@\n-        ClassDesc[] paramTypes = types.stream().skip(1).map(ClassDesc::ofDescriptor).toArray(ClassDesc[]::new);\n-        return new MethodTypeDescImpl(ClassDesc.ofDescriptor(types.get(0)), paramTypes);\n+        ClassDesc[] paramTypes = new ClassDesc[types.size() - 1];\n+        var ret = ClassDesc.ofDescriptor(types.get(0));\n+        for (int i = 0; i < paramTypes.length; i++) {\n+            paramTypes[i] = ClassDesc.ofDescriptor(types.get(i + 1));\n+        }\n+        return new MethodTypeDescImpl(ret, paramTypes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -623,0 +623,1 @@\n+            Objects.requireNonNull(interfaces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,4 +28,4 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.misc.VM;\n@@ -33,1 +33,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -37,0 +36,3 @@\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,0 +44,1 @@\n+import java.util.HashMap;\n@@ -46,0 +49,1 @@\n+import java.util.Objects;\n@@ -47,1 +51,1 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -56,1 +60,1 @@\n-final class ProxyGenerator extends ClassWriter {\n+final class ProxyGenerator {\n@@ -58,25 +62,27 @@\n-    private static final String JL_CLASS = \"java\/lang\/Class\";\n-    private static final String JL_OBJECT = \"java\/lang\/Object\";\n-    private static final String JL_THROWABLE = \"java\/lang\/Throwable\";\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n-\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n-    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n-    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n-\n-    private static final String JLR_INVOCATION_HANDLER = \"java\/lang\/reflect\/InvocationHandler\";\n-    private static final String JLR_PROXY = \"java\/lang\/reflect\/Proxy\";\n-    private static final String JLR_UNDECLARED_THROWABLE_EX = \"java\/lang\/reflect\/UndeclaredThrowableException\";\n-\n-    private static final String LJL_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String LJL_CLASSLOADER = \"Ljava\/lang\/ClassLoader;\";\n-    private static final String LJLR_METHOD = \"Ljava\/lang\/reflect\/Method;\";\n-    private static final String LJLR_INVOCATION_HANDLER = \"Ljava\/lang\/reflect\/InvocationHandler;\";\n-\n-    private static final String MJLR_INVOCATIONHANDLER = \"(Ljava\/lang\/reflect\/InvocationHandler;)V\";\n-\n-    private static final String NAME_CTOR = \"<init>\";\n-    private static final String NAME_CLINIT = \"<clinit>\";\n+\n+    private static final ClassDesc\n+            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n+            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n+            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n+            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n+            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n+            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n+            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n+            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n+            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n+            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+\n+    private static final MethodTypeDesc\n+            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n+            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDesc.of(CD_Class),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n+            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n+            MTD_String = MethodTypeDesc.of(CD_String);\n+\n@@ -124,1 +130,1 @@\n-    private final String className;\n+    private final ClassDesc classDesc;\n@@ -158,1 +164,0 @@\n-        super(ClassWriter.COMPUTE_FRAMES);\n@@ -160,1 +165,1 @@\n-        this.className = className;\n+        this.classDesc = ClassDesc.of(className);\n@@ -177,0 +182,1 @@\n+        Objects.requireNonNull(interfaces);\n@@ -188,1 +194,1 @@\n-                                    Path dir = Path.of(dotToSlash(name.substring(0, i)));\n+                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n@@ -208,5 +214,2 @@\n-     * Return an array of the class and interface names from an array of Classes.\n-     *\n-     * @param classes an array of classes or interfaces\n-     * @return the array of class and interface names; or null if classes is\n-     * null or empty\n+     * {@return the {@code ClassDesc} of the given type}\n+     * @param type the {@code Class} object\n@@ -214,8 +217,2 @@\n-    private static String[] typeNames(List<Class<?>> classes) {\n-        if (classes == null || classes.size() == 0)\n-            return null;\n-        int size = classes.size();\n-        String[] ifaces = new String[size];\n-        for (int i = 0; i < size; i++)\n-            ifaces[i] = dotToSlash(classes.get(i).getName());\n-        return ifaces;\n+    private static ClassDesc toClassDesc(Class<?> type) {\n+        return ClassDesc.ofDescriptor(type.descriptorString());\n@@ -339,1 +336,1 @@\n-    private static List<Class<?>> computeUniqueCatchList(Class<?>[] exceptions) {\n+    private static List<ClassDesc> computeUniqueCatchList(Class<?>[] exceptions) {\n@@ -387,29 +384,1 @@\n-        return uniqueList;\n-    }\n-\n-    \/**\n-     * Convert a fully qualified class name that uses '.' as the package\n-     * separator, the external representation used by the Java language\n-     * and APIs, to a fully qualified class name that uses '\/' as the\n-     * package separator, the representation used in the class file\n-     * format (see JVMS section {@jvms 4.2}).\n-     *\/\n-    private static String dotToSlash(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    \/**\n-     * Return the number of abstract \"words\", or consecutive local variable\n-     * indexes, required to contain a value of the given type.  See JVMS\n-     * section {@jvms 3.6.1}.\n-     * <p>\n-     * Note that the original version of the JVMS contained a definition of\n-     * this abstract notion of a \"word\" in section 3.4, but that definition\n-     * was removed for the second edition.\n-     *\/\n-    private static int getWordsPerType(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            return 2;\n-        } else {\n-            return 1;\n-        }\n+        return uniqueList.stream().map(ProxyGenerator::toClassDesc).toList();\n@@ -442,11 +411,0 @@\n-    \/**\n-     * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n-     * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n-     * default.\n-     *\n-     * @return ClassLoader\n-     *\/\n-    protected ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-\n@@ -458,2 +416,23 @@\n-        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n-                JLR_PROXY, typeNames(interfaces));\n+        var localCache = new HashMap<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo>();\n+        return Classfile.build(classDesc, List.of(Classfile.Option.classHierarchyResolver(classDesc ->\n+                \/*\n+                 * Class hierarchy resolution is critical for stack maps generation.\n+                 * Provided loader is used to retrieve class hierarchy info and the info is cached.\n+                 *\/\n+                localCache.computeIfAbsent(classDesc, cd -> {\n+                    try {\n+                        var desc = cd.descriptorString();\n+                        var cls = Class.forName(desc.substring(1, desc.length() - 1).replace('\/', '.'), false, loader);\n+                        var superCls = cls.getSuperclass();\n+                        return new ClassHierarchyResolver.ClassHierarchyInfo(cd,\n+                                                                             cls.isInterface(),\n+                                                                             superCls == null ? null : toClassDesc(superCls));\n+                    } catch (ClassNotFoundException e) {\n+                        throw new TypeNotPresentException(cd.descriptorString(), e);\n+                    }\n+                })\n+        )), clb -> {\n+            clb.withFlags(accessFlags);\n+            clb.withSuperclass(CD_Proxy);\n+            clb.withInterfaceSymbols(interfaces.stream().map(ProxyGenerator::toClassDesc).toList());\n+            clb.withVersion(CLASSFILE_VERSION, 0);\n@@ -461,10 +440,10 @@\n-        \/*\n-         * Add proxy methods for the hashCode, equals,\n-         * and toString methods of java.lang.Object.  This is done before\n-         * the methods from the proxy interfaces so that the methods from\n-         * java.lang.Object take precedence over duplicate methods in the\n-         * proxy interfaces.\n-         *\/\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+            \/*\n+             * Add proxy methods for the hashCode, equals,\n+             * and toString methods of java.lang.Object.  This is done before\n+             * the methods from the proxy interfaces so that the methods from\n+             * java.lang.Object take precedence over duplicate methods in the\n+             * proxy interfaces.\n+             *\/\n+            addProxyMethod(hashCodeMethod);\n+            addProxyMethod(equalsMethod);\n+            addProxyMethod(toStringMethod);\n@@ -472,7 +451,8 @@\n-        \/*\n-         * Accumulate all of the methods from the proxy interfaces.\n-         *\/\n-        for (Class<?> intf : interfaces) {\n-            for (Method m : intf.getMethods()) {\n-                if (!Modifier.isStatic(m.getModifiers())) {\n-                    addProxyMethod(m, intf);\n+            \/*\n+             * Accumulate all of the methods from the proxy interfaces.\n+             *\/\n+            for (Class<?> intf : interfaces) {\n+                for (Method m : intf.getMethods()) {\n+                    if (!Modifier.isStatic(m.getModifiers())) {\n+                        addProxyMethod(m, intf);\n+                    }\n@@ -481,1 +461,0 @@\n-        }\n@@ -483,7 +462,7 @@\n-        \/*\n-         * For each set of proxy methods with the same signature,\n-         * verify that the methods' return types are compatible.\n-         *\/\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            checkReturnTypes(sigmethods);\n-        }\n+            \/*\n+             * For each set of proxy methods with the same signature,\n+             * verify that the methods' return types are compatible.\n+             *\/\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                checkReturnTypes(sigmethods);\n+            }\n@@ -491,1 +470,1 @@\n-        generateConstructor();\n+            generateConstructor(clb);\n@@ -493,5 +472,4 @@\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -499,2 +477,3 @@\n-                \/\/ Generate code for proxy method\n-                pm.generateMethod(this, className);\n+                    \/\/ Generate code for proxy method\n+                    pm.generateMethod(clb, classDesc);\n+                }\n@@ -502,1 +481,0 @@\n-        }\n@@ -504,3 +482,3 @@\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+            generateStaticInitializer(clb);\n+            generateLookupAccessor(clb);\n+        });\n@@ -566,14 +544,6 @@\n-    private void generateConstructor() {\n-        MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, null, null);\n-        ctor.visitParameter(null, 0);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitVarInsn(ALOAD, 1);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, false);\n-        ctor.visitInsn(RETURN);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+    private void generateConstructor(ClassBuilder clb) {\n+        clb.withMethodBody(INIT_NAME, MTD_void_InvocationHandler, ACC_PUBLIC, cob -> cob\n+               .aload(cob.receiverSlot())\n+               .aload(cob.parameterSlot(0))\n+               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .return_());\n@@ -585,57 +555,29 @@\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        \/\/ Put ClassLoader at local variable index 0, used by\n-        \/\/ Class.forName(String, boolean, ClassLoader) calls\n-        mv.visitLdcInsn(Type.getObjectType(dotToSlash(className)));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + LJL_CLASSLOADER, false);\n-        mv.visitVarInsn(ASTORE, 0);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n-            }\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> cob\n+                \/\/ Put ClassLoader at local variable index 0, used by\n+                \/\/ Class.forName(String, boolean, ClassLoader) calls\n+                .constantInstruction(classDesc)\n+                .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n+                .astore(0)\n+                .trying(tryb -> {\n+                    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                        for (ProxyMethod pm : sigmethods) {\n+                            pm.codeFieldInitialization(tryb, classDesc);\n+                        }\n+                    }\n+                    tryb.return_();\n+                }, cb -> cb\n+                    .catching(CD_NoSuchMethodException, nsmb -> nsmb\n+                            .new_(CD_NoSuchMethodError)\n+                            .dup_x1()\n+                            .swap()\n+                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n+                            .invokespecial(CD_NoSuchMethodError, INIT_NAME, MTD_void_String)\n+                            .athrow())\n+                    .catching(CD_ClassNotFoundException, cnfb -> cnfb\n+                            .new_(CD_NoClassDefFoundError)\n+                            .dup_x1()\n+                            .swap()\n+                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n+                            .invokespecial(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String)\n+                            .athrow())));\n@@ -649,33 +591,22 @@\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateLookupAccessor(ClassBuilder clb) {\n+        clb.withMethod(NAME_LOOKUP_ACCESSOR,\n+                MTD_MethodHandles$Lookup_MethodHandles$Lookup,\n+                ACC_PRIVATE | ACC_STATIC,\n+                mb -> mb.with(ExceptionsAttribute.of(List.of(mb.constantPool().classEntry(CD_IllegalAccessException))))\n+                        .withCode(cob -> cob\n+                            .block(blockBuilder -> blockBuilder\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .if_acmpne(blockBuilder.breakLabel())\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n+                                    .ifeq(blockBuilder.breakLabel())\n+                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                                    .areturn())\n+                            .new_(CD_IllegalAccessException)\n+                            .dup()\n+                            .aload(cob.parameterSlot(0))\n+                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n+                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                            .athrow()));\n@@ -719,2 +650,2 @@\n-                    method.getSharedParameterTypes(), method.getReturnType(),\n-                    method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedParameterTypes(), method.getReturnType(),\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -726,60 +657,34 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n-            MethodType mt = MethodType.methodType(returnType, parameterTypes);\n-            String desc = mt.toMethodDescriptorString();\n-            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n-            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n-\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                    method.getName(), desc, null,\n-                    typeNames(Arrays.asList(exceptionTypes)));\n-\n-            int[] parameterSlot = new int[parameterTypes.length];\n-            int nextSlot = 1;\n-            for (int i = 0; i < parameterSlot.length; i++) {\n-                parameterSlot[i] = nextSlot;\n-                nextSlot += getWordsPerType(parameterTypes[i]);\n-            }\n-\n-            mv.visitCode();\n-            Label L_startBlock = new Label();\n-            Label L_endBlock = new Label();\n-            Label L_RuntimeHandler = new Label();\n-            Label L_ThrowableHandler = new Label();\n-\n-            List<Class<?>> catchList = computeUniqueCatchList(exceptionTypes);\n-            if (catchList.size() > 0) {\n-                for (Class<?> ex : catchList) {\n-                    mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,\n-                            dotToSlash(ex.getName()));\n-                }\n-\n-                mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,\n-                        JL_THROWABLE);\n-            }\n-            mv.visitLabel(L_startBlock);\n-\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,\n-                    LJLR_INVOCATION_HANDLER);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n-\n-            if (parameterTypes.length > 0) {\n-                \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                emitIconstInsn(mv, parameterTypes.length);\n-                mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);\n-                for (int i = 0; i < parameterTypes.length; i++) {\n-                    mv.visitInsn(DUP);\n-                    emitIconstInsn(mv, i);\n-                    codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);\n-                    mv.visitInsn(Opcodes.AASTORE);\n-                }\n-            } else {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-            }\n-\n-            mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,\n-                    \"invoke\",\n-                    \"(Ljava\/lang\/Object;Ljava\/lang\/reflect\/Method;\" +\n-                            \"[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", true);\n+        private void generateMethod(ClassBuilder clb, ClassDesc className) {\n+            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n+                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+            int accessFlags = (method.isVarArgs()) ? ACC_VARARGS | ACC_PUBLIC | ACC_FINAL\n+                                                   : ACC_PUBLIC | ACC_FINAL;\n+            var catchList = computeUniqueCatchList(exceptionTypes);\n+            clb.withMethod(method.getName(), desc, accessFlags, mb -> {\n+                ConstantPoolBuilder cpb = mb.constantPool();\n+                List<ClassEntry> exceptionClassEntries = Arrays.asList(exceptionTypes)\n+                        .stream()\n+                        .map(ProxyGenerator::toClassDesc)\n+                        .map(cpb::classEntry)\n+                        .toList();\n+                mb.with(ExceptionsAttribute.of(exceptionClassEntries));\n+                mb.withCode(cob ->\n+                    cob.trying(tryb -> {\n+                        tryb.aload(tryb.receiverSlot())\n+                            .getfield(CD_Proxy, handlerFieldName, CD_InvocationHandler)\n+                            .aload(tryb.receiverSlot())\n+                            .getstatic(className, methodFieldName, CD_Method);\n+\n+                        if (parameterTypes.length > 0) {\n+                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                            tryb.constantInstruction(parameterTypes.length)\n+                                .anewarray(CD_Object);\n+                            for (int i = 0; i < parameterTypes.length; i++) {\n+                                tryb.dup()\n+                                    .constantInstruction(i);\n+                                codeWrapArgument(tryb, parameterTypes[i], tryb.parameterSlot(i));\n+                                tryb.aastore();\n+                            }\n+                        } else {\n+                            tryb.aconst_null();\n+                        }\n@@ -787,6 +692,1 @@\n-            if (returnType == void.class) {\n-                mv.visitInsn(POP);\n-                mv.visitInsn(RETURN);\n-            } else {\n-                codeUnwrapReturnValue(mv, returnType);\n-            }\n+                        tryb.invokeinterface(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n@@ -794,17 +694,20 @@\n-            mv.visitLabel(L_endBlock);\n-\n-            \/\/ Generate exception handler\n-            mv.visitLabel(L_RuntimeHandler);\n-            mv.visitInsn(ATHROW);   \/\/ just rethrow the exception\n-\n-            mv.visitLabel(L_ThrowableHandler);\n-            mv.visitVarInsn(ASTORE, 1);\n-            mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);\n-            mv.visitInsn(DUP);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,\n-                    \"<init>\", \"(Ljava\/lang\/Throwable;)V\", false);\n-            mv.visitInsn(ATHROW);\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n+                        if (returnType == void.class) {\n+                            tryb.pop()\n+                                .return_();\n+                        } else {\n+                            codeUnwrapReturnValue(tryb, returnType);\n+                        }\n+                    }, catchBuilder -> {\n+                        if (!catchList.isEmpty()) {\n+                            catchBuilder.catchingMulti(catchList, ehb -> ehb\n+                                    .athrow());   \/\/ just rethrow the exception\n+\n+                            catchBuilder.catching(CD_Throwable, ehb -> ehb\n+                                    .new_(CD_UndeclaredThrowableException)\n+                                    .dup_x1()\n+                                    .swap()\n+                                    .invokespecial(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable)\n+                                    .athrow());\n+                        }\n+                    }));\n+            });\n@@ -819,1 +722,1 @@\n-        private void codeWrapArgument(MethodVisitor mv, Class<?> type, int slot) {\n+        private void codeWrapArgument(CodeBuilder cob, Class<?> type, int slot) {\n@@ -821,0 +724,1 @@\n+                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n@@ -822,4 +726,1 @@\n-\n-                mv.visitVarInsn(prim.loadOpcode, slot);\n-                mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, \"valueOf\",\n-                        prim.wrapperValueOfDesc, false);\n+                cob.invokestatic(prim.wrapperClass, \"valueOf\", prim.wrapperValueOf);\n@@ -827,1 +728,1 @@\n-                mv.visitVarInsn(ALOAD, slot);\n+                cob.aload(slot);\n@@ -836,1 +737,1 @@\n-        private void codeUnwrapReturnValue(MethodVisitor mv, Class<?> type) {\n+        private void codeUnwrapReturnValue(CodeBuilder cob, Class<?> type) {\n@@ -840,6 +741,3 @@\n-                mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);\n-                mv.visitMethodInsn(INVOKEVIRTUAL,\n-                        prim.wrapperClassName,\n-                        prim.unwrapMethodName, prim.unwrapMethodDesc, false);\n-\n-                mv.visitInsn(prim.returnOpcode);\n+                cob.typeCheckInstruction(Opcode.CHECKCAST, prim.wrapperClass)\n+                   .invokevirtual(prim.wrapperClass, prim.unwrapMethodName, prim.unwrapMethodType)\n+                   .returnInstruction(TypeKind.from(type).asLoadable());\n@@ -847,2 +745,2 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n-                mv.visitInsn(ARETURN);\n+                cob.checkcast(toClassDesc(type))\n+                   .areturn();\n@@ -857,4 +755,2 @@\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n+        private void codeFieldInitialization(CodeBuilder cob, ClassDesc className) {\n+            codeClassForName(cob, fromClass);\n@@ -862,3 +758,3 @@\n-            emitIconstInsn(mv, parameterTypes.length);\n-\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n+            cob.constantInstruction(Opcode.LDC, method.getName())\n+               .constantInstruction(parameterTypes.length)\n+               .anewarray(CD_Class);\n@@ -868,3 +764,2 @@\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n+                cob.dup()\n+                   .constantInstruction(i);\n@@ -872,4 +767,2 @@\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.wrapperClass, \"TYPE\", CD_Class);\n@@ -877,1 +770,1 @@\n-                    codeClassForName(mv, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i]);\n@@ -879,1 +772,1 @@\n-                mv.visitInsn(Opcodes.AASTORE);\n+                cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -882,9 +775,2 @@\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n+            cob.invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_ClassArray)\n+               .putstatic(className, methodFieldName, CD_Method);\n@@ -904,27 +790,5 @@\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitInsn(ICONST_0); \/\/ false\n-            mv.visitVarInsn(ALOAD, 0); \/\/ classLoader\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\",\n-                    \"(Ljava\/lang\/String;Z\" + LJL_CLASSLOADER + \")Ljava\/lang\/Class;\",\n-                    false);\n-        }\n-\n-        \/**\n-         * Visit a bytecode for a constant.\n-         *\n-         * @param mv  The MethodVisitor\n-         * @param cst The constant value\n-         *\/\n-        private void emitIconstInsn(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-            } else {\n-                mv.visitLdcInsn(cst);\n-            }\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.constantInstruction(Opcode.LDC, cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader);\n@@ -945,8 +809,8 @@\n-        BYTE(byte.class, ILOAD, IRETURN),\n-        CHAR(char.class, ILOAD, IRETURN),\n-        DOUBLE(double.class, DLOAD, DRETURN),\n-        FLOAT(float.class, FLOAD, FRETURN),\n-        INT(int.class, ILOAD, IRETURN),\n-        LONG(long.class, LLOAD, LRETURN),\n-        SHORT(short.class, ILOAD, IRETURN),\n-        BOOLEAN(boolean.class, ILOAD, IRETURN);\n+        BYTE(byte.class, CD_byte, CD_Byte),\n+        CHAR(char.class, CD_char, CD_Character),\n+        DOUBLE(double.class, CD_double, CD_Double),\n+        FLOAT(float.class, CD_float, CD_Float),\n+        INT(int.class, CD_int, CD_Integer),\n+        LONG(long.class, CD_long, CD_Long),\n+        SHORT(short.class, CD_short, CD_Short),\n+        BOOLEAN(boolean.class, CD_boolean, CD_Boolean);\n@@ -957,1 +821,1 @@\n-        private final String wrapperClassName;\n+        private final ClassDesc wrapperClass;\n@@ -961,1 +825,1 @@\n-        private final String wrapperValueOfDesc;\n+        private final MethodTypeDesc wrapperValueOf;\n@@ -969,25 +833,8 @@\n-        private final String unwrapMethodDesc;\n-        \/**\n-         * Load opcode used by this primitive\n-         *\/\n-        private final int loadOpcode;\n-        \/**\n-         * Return opcode used by this primitive\n-         *\/\n-        private final int returnOpcode;\n-\n-        PrimitiveTypeInfo(Class<?> primitiveClass, int loadOpcode, int returnOpcode) {\n-            assert primitiveClass.isPrimitive();\n-            assert returnOpcode - IRETURN == loadOpcode - ILOAD;\n-\n-            Wrapper wrapper = Wrapper.forPrimitiveType(primitiveClass);\n-            \/\/ single-char BaseType descriptor (see JVMS section 4.3.2)\n-            String baseTypeString = wrapper.basicTypeString();\n-            var wrapperType = wrapper.wrapperType();\n-            wrapperClassName = dotToSlash(wrapperType.getName());\n-            wrapperValueOfDesc =\n-                    \"(\" + baseTypeString + \")\" + wrapperType.descriptorString();\n-            unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            unwrapMethodDesc = \"()\" + baseTypeString;\n-            this.loadOpcode = loadOpcode;\n-            this.returnOpcode = returnOpcode;\n+        private final MethodTypeDesc unwrapMethodType;\n+\n+        PrimitiveTypeInfo(Class<?> primitiveClass, ClassDesc baseType, ClassDesc wrapperClass) {\n+            assert baseType.isPrimitive();\n+            this.wrapperClass = wrapperClass;\n+            this.wrapperValueOf = MethodTypeDesc.of(wrapperClass, baseType);\n+            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n+            this.unwrapMethodType = MethodTypeDesc.of(baseType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":267,"deletions":420,"binary":false,"changes":687,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry.ClassEntryImpl;\n@@ -160,1 +161,3 @@\n-        return classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ClassEntryImpl ret = (ClassEntryImpl)classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ret.sym = classDesc;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -166,0 +166,4 @@\n+            this(cpm, index, s, hashString(s.hashCode()));\n+        }\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s, int hash) {\n@@ -173,1 +177,1 @@\n-            this.hash = hashString(s.hashCode());\n+            this.hash = hash;\n@@ -559,0 +563,2 @@\n+        public ClassDesc sym = null;\n+\n@@ -565,1 +571,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n@@ -570,1 +582,4 @@\n-            return Util.toClassDesc(asInternalName());\n+            if (sym == null) {\n+                sym = Util.toClassDesc(asInternalName());\n+            }\n+            return sym;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -329,4 +329,2 @@\n-                                                  buf.thisClass().asSymbol(),\n-                                                  methodInfo.methodName().stringValue(),\n-                                                  MethodTypeDesc.ofDescriptor(methodInfo.methodType().stringValue()),\n-                                                  (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0,\n+                                                  buf.thisClass(),\n+                                                  methodInfo,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+        this.doneFullScan = true;\n@@ -371,2 +372,3 @@\n-        var ce = tryFindUtf8(AbstractPoolEntry.hashString(s.hashCode()), s);\n-        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s)) : ce;\n+        int hash = AbstractPoolEntry.hashString(s.hashCode());\n+        var ce = tryFindUtf8(hash, s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, hash)) : ce;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.classfile.impl.Util.findParams;\n@@ -158,1 +159,0 @@\n-    private static final String OBJECT_INITIALIZER_NAME = \"<init>\";\n@@ -183,0 +183,2 @@\n+    record RawExceptionCatch(int start, int end, int handler, Type catchType) {}\n+\n@@ -185,1 +187,1 @@\n-    private final MethodTypeDesc methodDesc;\n+    private final String methodDesc;\n@@ -190,1 +192,2 @@\n-    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> exceptionTable;\n+    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers;\n+    private final List<RawExceptionCatch> rawHandlers;\n@@ -205,3 +208,1 @@\n-     * @param methodName method name to generate stack maps for\n-     * @param methodDesc method descriptor to generate stack maps for\n-     * @param isStatic information whether the method is static\n+     * @param methodInfo method info to generate stack maps for\n@@ -214,4 +215,2 @@\n-                     ClassDesc thisClass,\n-                     String methodName,\n-                     MethodTypeDesc methodDesc,\n-                     boolean isStatic,\n+                     ClassEntry thisClass,\n+                     MethodInfo methodInfo,\n@@ -221,4 +220,4 @@\n-        this.thisType = Type.referenceType(thisClass);\n-        this.methodName = methodName;\n-        this.methodDesc = methodDesc;\n-        this.isStatic = isStatic;\n+        this.thisType = Type.referenceType(thisClass.asSymbol());\n+        this.methodName = methodInfo.methodName().stringValue();\n+        this.methodDesc = methodInfo.methodType().stringValue();\n+        this.isStatic = (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0;\n@@ -228,1 +227,2 @@\n-        this.exceptionTable = handlers;\n+        this.handlers = handlers;\n+        this.rawHandlers = new ArrayList<>(handlers.size());\n@@ -251,6 +251,12 @@\n-    private int getFrameIndexFromOffset(int offset) {\n-        int i = 0;\n-        for (; i < frames.size(); i++) {\n-            if (frames.get(i).offset == offset) {\n-                return i;\n-            }\n+    private Frame getFrame(int offset) {\n+        int low = 0;\n+        int high = frames.size() - 1;\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            var f = frames.get(mid);\n+            if (f.offset < offset)\n+                low = mid + 1;\n+            else if (f.offset > offset)\n+                high = mid - 1;\n+            else\n+                return f;\n@@ -258,1 +264,1 @@\n-        return i;\n+        return null;\n@@ -262,2 +268,1 @@\n-        int index = getFrameIndexFromOffset(target);\n-        frame.checkAssignableTo(frames.get(index));\n+        frame.checkAssignableTo(getFrame(target));\n@@ -278,1 +283,1 @@\n-        for (var exhandler : exceptionTable) {\n+        for (var exhandler : handlers) {\n@@ -281,2 +286,9 @@\n-            if (start_pc < exMin) exMin = start_pc;\n-            if (end_pc > exMax) exMax = end_pc;\n+            int handler_pc = labelContext.labelToBci(exhandler.handler());\n+            if (start_pc >= 0 && end_pc >= 0 && end_pc > start_pc && handler_pc >= 0) {\n+                if (start_pc < exMin) exMin = start_pc;\n+                if (end_pc > exMax) exMax = end_pc;\n+                var catchType = exhandler.catchType();\n+                rawHandlers.add(new RawExceptionCatch(start_pc, end_pc, handler_pc,\n+                        catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp)\n+                                              : Type.THROWABLE_TYPE));\n+            }\n@@ -320,1 +332,1 @@\n-        var it = exceptionTable.listIterator();\n+        var it = handlers.listIterator();\n@@ -651,2 +663,2 @@\n-        for (var exhandler : exceptionTable) {\n-            if (bci >= labelContext.labelToBci(exhandler.tryStart()) && bci < labelContext.labelToBci(exhandler.tryEnd())) {\n+        for (var ex : rawHandlers) {\n+            if (bci == ex.start || (currentFrame.localsChanged && bci > ex.start && bci < ex.end)) {\n@@ -655,5 +667,2 @@\n-                Frame newFrame = currentFrame.frameInExceptionHandler(flags);\n-                var catchType = exhandler.catchType();\n-                newFrame.pushStack(catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp) : Type.THROWABLE_TYPE);\n-                int handler = labelContext.labelToBci(exhandler.handler());\n-                if (handler != -1) checkJumpTarget(newFrame, handler);\n+                Frame newFrame = currentFrame.frameInExceptionHandler(flags, ex.catchType);\n+                checkJumpTarget(newFrame, ex.handler);\n@@ -662,0 +671,1 @@\n+        currentFrame.localsChanged = false;\n@@ -790,1 +800,1 @@\n-            if (OBJECT_INITIALIZER_NAME.equals(invokeMethodName)) {\n+            if (INIT_NAME.equals(invokeMethodName)) {\n@@ -824,1 +834,1 @@\n-        currentFrame.pushStack(cpIndexToType(index, cp).toArray());\n+        currentFrame.pushStack(Type.toArray(cpIndexToType(index, cp)));\n@@ -841,1 +851,1 @@\n-        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s%s\".formatted(\n@@ -845,1 +855,1 @@\n-                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+                methodDesc.substring(0, methodDesc.indexOf(')') + 1)));\n@@ -850,1 +860,1 @@\n-            clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n+            clb.withMethod(methodName, MethodTypeDesc.ofDescriptor(methodDesc), isStatic ? ACC_STATIC : 0, mb ->\n@@ -943,2 +953,2 @@\n-        for (var exhandler : exceptionTable) try {\n-            offsets.set(labelContext.labelToBci(exhandler.handler()));\n+        for (var exhandler : rawHandlers) try {\n+            offsets.set(exhandler.handler());\n@@ -959,0 +969,1 @@\n+        boolean localsChanged = false;\n@@ -988,2 +999,2 @@\n-            return switch (desc.descriptorString()) {\n-                case \"J\" ->\n+            return switch (desc.descriptorString().charAt(0)) {\n+                case 'J' ->\n@@ -991,1 +1002,1 @@\n-                case \"D\" ->\n+                case 'D' ->\n@@ -993,1 +1004,1 @@\n-                case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -995,1 +1006,1 @@\n-                case \"F\" ->\n+                case 'F' ->\n@@ -997,1 +1008,1 @@\n-                case \"V\" ->\n+                case 'V' ->\n@@ -999,1 +1010,1 @@\n-                default ->\n+                case '[', 'L' ->\n@@ -1001,0 +1012,2 @@\n+                default ->\n+                    throw new IllegalArgumentException(\"Unknown descriptor \" + desc.descriptorString());\n@@ -1028,2 +1041,2 @@\n-        Frame frameInExceptionHandler(int flags) {\n-            return new Frame(offset, flags, localsSize, 0, locals, new Type[] {Type.TOP_TYPE}, classHierarchy);\n+        Frame frameInExceptionHandler(int flags, Type excType) {\n+            return new Frame(offset, flags, localsSize, 1, locals, new Type[] {excType}, classHierarchy);\n@@ -1035,1 +1048,1 @@\n-                if (locals[i].equals(old_object)) {\n+                if (old_object.equals(locals[i])) {\n@@ -1037,0 +1050,1 @@\n+                    localsChanged = true;\n@@ -1040,1 +1054,1 @@\n-                if (stack[i].equals(old_object)) {\n+                if (old_object.equals(stack[i])) {\n@@ -1053,1 +1067,0 @@\n-                Arrays.fill(locals, Type.TOP_TYPE);\n@@ -1057,1 +1070,0 @@\n-                Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n@@ -1066,1 +1078,0 @@\n-                Arrays.fill(stack, Type.TOP_TYPE);\n@@ -1070,1 +1081,0 @@\n-                Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n@@ -1076,0 +1086,1 @@\n+            localsChanged |= !Objects.equals(type, locals[index]);\n@@ -1079,1 +1090,1 @@\n-        void setLocalsFromArg(String name, MethodTypeDesc methodDesc, boolean isStatic, Type thisKlass) {\n+        void setLocalsFromArg(String name, String methodDesc, boolean isStatic, Type thisKlass) {\n@@ -1083,1 +1094,1 @@\n-                if (OBJECT_INITIALIZER_NAME.equals(name) && !CD_Object.equals(thisKlass.sym)) {\n+                if (INIT_NAME.equals(name) && !CD_Object.equals(thisKlass.sym)) {\n@@ -1090,6 +1101,13 @@\n-            for (int i = 0; i < methodDesc.parameterCount(); i++) {\n-                var desc = methodDesc.parameterType(i);\n-                if (desc.isClassOrInterface() || desc.isArray()) {\n-                    setLocalRawInternal(localsSize++, Type.referenceType(desc));\n-                } else switch (desc.descriptorString()) {\n-                    case \"J\" -> {\n+            if (methodDesc.charAt(0) != '(') throw new IllegalArgumentException(\"Invalid method type decriptor \" + methodDesc);\n+            for (int i = 1; i < methodDesc.length(); ++i) {\n+                switch (methodDesc.charAt(i)) {\n+                    case '[', 'L' -> {\n+                        int s = i;\n+                        while (methodDesc.charAt(i) == '[') i++;\n+                        if (methodDesc.charAt(i) == 'L') {\n+                            while (methodDesc.charAt(++i) != ';')\n+                                ;\n+                        }\n+                        setLocalRawInternal(localsSize++, Type.referenceType(ClassDesc.ofDescriptor(methodDesc.substring(s, i + 1))));\n+                    }\n+                    case 'J' -> {\n@@ -1099,1 +1117,1 @@\n-                    case \"D\" -> {\n+                    case 'D' -> {\n@@ -1103,1 +1121,1 @@\n-                    case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                    case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -1105,1 +1123,1 @@\n-                    case \"F\" ->\n+                    case 'F' ->\n@@ -1107,1 +1125,4 @@\n-                    default -> throw new AssertionError(\"Should not reach here\");\n+                    case ')' ->\n+                        i = methodDesc.length();\n+                    default ->\n+                        throw new IllegalArgumentException(\"Invalid method type decriptor \" + methodDesc);\n@@ -1113,1 +1134,1 @@\n-            if (locals != null && src.localsSize < locals.length) Arrays.fill(locals, src.localsSize, locals.length, Type.TOP_TYPE);\n+            if (locals != null && src.localsSize < locals.length) Arrays.fill(locals, src.localsSize, locals.length, null);\n@@ -1117,1 +1138,1 @@\n-            if (stack != null && src.stackSize < stack.length) Arrays.fill(stack, src.stackSize, stack.length, Type.TOP_TYPE);\n+            if (stack != null && src.stackSize < stack.length) Arrays.fill(stack, src.stackSize, stack.length, null);\n@@ -1122,0 +1143,1 @@\n+            localsChanged = true;\n@@ -1162,1 +1184,1 @@\n-                setLocalRawInternal(index + 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index + 1, null);\n@@ -1165,1 +1187,1 @@\n-                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index - 1, null);\n@@ -1176,1 +1198,1 @@\n-                setLocalRawInternal(index + 2, Type.TOP_TYPE);\n+                setLocalRawInternal(index + 2, null);\n@@ -1180,1 +1202,1 @@\n-                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+                setLocalRawInternal(index - 1, null);\n@@ -1191,1 +1213,1 @@\n-            var newTo = to.mergeFrom(me, classHierarchy);\n+            var newTo = Type.mergeFrom(to, me, classHierarchy);\n@@ -1199,1 +1221,1 @@\n-            while (count > 0 && types[count - 1] == Type.TOP_TYPE) count--;\n+            while (count > 0 && types[count - 1] == null) count--;\n@@ -1202,2 +1224,3 @@\n-                if (!types[i].isCategory2_2nd()) {\n-                    types[compressed++] = types[i];\n+                var t = types[i];\n+                if (t == null || !t.isCategory2_2nd()) {\n+                    types[compressed++] = t;\n@@ -1230,1 +1253,1 @@\n-                        for (int i=commonLocalsSize; i<localsSize; i++) locals[i].writeTo(out, cp);\n+                        for (int i=commonLocalsSize; i<localsSize; i++) Type.writeTo(locals[i], out, cp);\n@@ -1241,1 +1264,1 @@\n-                stack[0].writeTo(out, cp);\n+                Type.writeTo(stack[0], out, cp);\n@@ -1248,1 +1271,1 @@\n-            for (int i=0; i<localsSize; i++) locals[i].writeTo(out, cp);\n+            for (int i=0; i<localsSize; i++) Type.writeTo(locals[i], out, cp);\n@@ -1250,1 +1273,1 @@\n-            for (int i=0; i<stackSize; i++) stack[i].writeTo(out, cp);\n+            for (int i=0; i<stackSize; i++) Type.writeTo(stack[i], out, cp);\n@@ -1257,2 +1280,1 @@\n-        static final Type TOP_TYPE = simpleType(ITEM_TOP),\n-                NULL_TYPE = simpleType(ITEM_NULL),\n+        static final Type NULL_TYPE = simpleType(ITEM_NULL),\n@@ -1320,3 +1342,3 @@\n-        Type mergeFrom(Type from, ClassHierarchyImpl context) {\n-            if (this == TOP_TYPE || this == from || equals(from)) {\n-                return this;\n+        static Type mergeFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n+            if (thisType == null || thisType == from || thisType.equals(from)) {\n+                return thisType;\n@@ -1324,1 +1346,1 @@\n-                return switch (tag) {\n+                return switch (thisType.tag) {\n@@ -1326,1 +1348,1 @@\n-                        from == INTEGER_TYPE ? this : TOP_TYPE;\n+                        from == INTEGER_TYPE ? thisType : null;\n@@ -1328,1 +1350,1 @@\n-                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                        thisType.isReference() && from != null && from.isReference() ? mergeReferenceFrom(thisType, from, context) : null;\n@@ -1333,3 +1355,3 @@\n-        Type mergeComponentFrom(Type from, ClassHierarchyImpl context) {\n-            if (this == TOP_TYPE || this == from || equals(from)) {\n-                return this;\n+        static Type mergeComponentFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n+            if (thisType == null || thisType == from || thisType.equals(from)) {\n+                return thisType;\n@@ -1337,1 +1359,1 @@\n-                return switch (tag) {\n+                return switch (thisType.tag) {\n@@ -1339,1 +1361,1 @@\n-                        TOP_TYPE;\n+                        null;\n@@ -1341,1 +1363,1 @@\n-                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                        thisType.isReference() && from != null && from.isReference() ? mergeReferenceFrom(thisType, from, context) : null;\n@@ -1349,1 +1371,1 @@\n-        private Type mergeReferenceFrom(Type from, ClassHierarchyImpl context) {\n+        static private Type mergeReferenceFrom(Type thisType, Type from, ClassHierarchyImpl context) {\n@@ -1351,2 +1373,2 @@\n-                return this;\n-            } else if (this == NULL_TYPE) {\n+                return thisType;\n+            } else if (thisType == NULL_TYPE) {\n@@ -1354,5 +1376,5 @@\n-            } else if (sym.equals(from.sym)) {\n-                return this;\n-            } else if (isObject()) {\n-                if (CD_Object.equals(sym)) {\n-                    return this;\n+            } else if (thisType.sym.equals(from.sym)) {\n+                return thisType;\n+            } else if (thisType.isObject()) {\n+                if (CD_Object.equals(thisType.sym)) {\n+                    return thisType;\n@@ -1360,3 +1382,3 @@\n-                if (context.isInterface(sym)) {\n-                    if (!from.isArray() || CD_Cloneable.equals(sym) || CD_Serializable.equals(sym)) {\n-                        return this;\n+                if (context.isInterface(thisType.sym)) {\n+                    if (!from.isArray() || CD_Cloneable.equals(thisType.sym) || CD_Serializable.equals(thisType.sym)) {\n+                        return thisType;\n@@ -1365,2 +1387,2 @@\n-                    var anc = context.commonAncestor(sym, from.sym);\n-                    return anc == null ? this : Type.referenceType(anc);\n+                    var anc = context.commonAncestor(thisType.sym, from.sym);\n+                    return anc == null ? thisType : Type.referenceType(anc);\n@@ -1368,2 +1390,2 @@\n-            } else if (isArray() && from.isArray()) {\n-                Type compThis = getComponent();\n+            } else if (thisType.isArray() && from.isArray()) {\n+                Type compThis = thisType.getComponent();\n@@ -1371,2 +1393,2 @@\n-                if (compThis != TOP_TYPE && compFrom != TOP_TYPE) {\n-                    return  compThis.mergeComponentFrom(compFrom, context).toArray();\n+                if (compThis != null && compFrom != null) {\n+                    return  Type.toArray(mergeComponentFrom(compThis, compFrom, context));\n@@ -1378,2 +1400,2 @@\n-        Type toArray() {\n-            return switch (tag) {\n+        static Type toArray(Type t) {\n+            return t == null ? OBJECT_TYPE : switch (t.tag) {\n@@ -1388,1 +1410,1 @@\n-                case ITEM_OBJECT -> Type.referenceType(sym.arrayType());\n+                case ITEM_OBJECT -> Type.referenceType(t.sym.arrayType());\n@@ -1406,1 +1428,1 @@\n-                        default -> Type.TOP_TYPE;\n+                        default -> null;\n@@ -1411,1 +1433,1 @@\n-            return Type.TOP_TYPE;\n+            return null;\n@@ -1414,7 +1436,11 @@\n-        void writeTo(BufWriter bw, ConstantPoolBuilder cp) {\n-            bw.writeU1(tag);\n-            switch (tag) {\n-                case ITEM_OBJECT ->\n-                    bw.writeU2(cp.classEntry(sym).index());\n-                case ITEM_UNINITIALIZED ->\n-                    bw.writeU2(bci);\n+        static void writeTo(Type t, BufWriter bw, ConstantPoolBuilder cp) {\n+            if (t == null) {\n+                bw.writeU1(ITEM_TOP);\n+            } else {\n+                bw.writeU1(t.tag);\n+                switch (t.tag) {\n+                    case ITEM_OBJECT ->\n+                        bw.writeU2(cp.classEntry(t.sym).index());\n+                    case ITEM_UNINITIALIZED ->\n+                        bw.writeU2(t.bci);\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":152,"deletions":126,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.classfile.constantpool.ClassEntry;\n@@ -40,0 +41,1 @@\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n@@ -43,0 +45,1 @@\n+import jdk.internal.classfile.impl.MethodInfo;\n@@ -64,4 +67,4 @@\n-                    ClassDesc thisClass,\n-                    String methodName,\n-                    MethodTypeDesc methodDesc,\n-                    boolean isStatic,\n+                    ClassEntry thisClass,\n+                    Utf8Entry methodName,\n+                    Utf8Entry methodType,\n+                    int methodFlags,\n@@ -70,1 +73,6 @@\n-                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {}\n+                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) implements MethodInfo {\n+\n+        public int parameterSlot(int paramNo) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n@@ -82,1 +90,1 @@\n-                var thisCls = clm.thisClass().asSymbol();\n+                var thisCls = clm.thisClass();\n@@ -90,3 +98,3 @@\n-                                m.methodName().stringValue(),\n-                                m.methodTypeSymbol(),\n-                                (m.flags().flagsMask() & Classfile.ACC_STATIC) != 0,\n+                                m.methodName(),\n+                                m.methodType(),\n+                                m.flags().flagsMask(),\n@@ -112,3 +120,1 @@\n-                d.methodName(),\n-                d.methodDesc(),\n-                d.isStatic(),\n+                d,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"}]}