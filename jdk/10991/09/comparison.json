{"files":[{"patch":"@@ -170,5 +170,6 @@\n-        return String.format(\"(%s)%s\",\n-                             Stream.of(parameterArray())\n-                                   .map(ClassDesc::descriptorString)\n-                                   .collect(Collectors.joining()),\n-                             returnType().descriptorString());\n+        var sb = new StringBuilder();\n+        sb.append('(');\n+        for (int i=0; i<parameterCount(); i++) {\n+            sb.append(parameterType(i).descriptorString());\n+        }\n+        return sb.append(')').append(returnType().descriptorString()).toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,2 +74,6 @@\n-        ClassDesc[] paramTypes = types.stream().skip(1).map(ClassDesc::ofDescriptor).toArray(ClassDesc[]::new);\n-        return new MethodTypeDescImpl(ClassDesc.ofDescriptor(types.get(0)), paramTypes);\n+        ClassDesc[] paramTypes = new ClassDesc[types.size() - 1];\n+        var ret = ClassDesc.ofDescriptor(types.get(0));\n+        for (int i = 0; i < paramTypes.length; i++) {\n+            paramTypes[i] = ClassDesc.ofDescriptor(types.get(i + 1));\n+        }\n+        return new MethodTypeDescImpl(ret, paramTypes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -623,0 +623,1 @@\n+            Objects.requireNonNull(interfaces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,4 +28,4 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.misc.VM;\n@@ -33,1 +33,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -37,0 +36,3 @@\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,0 +44,1 @@\n+import java.util.HashMap;\n@@ -46,0 +49,1 @@\n+import java.util.Objects;\n@@ -47,1 +51,1 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -56,1 +60,1 @@\n-final class ProxyGenerator extends ClassWriter {\n+final class ProxyGenerator {\n@@ -58,5 +62,0 @@\n-    private static final String JL_CLASS = \"java\/lang\/Class\";\n-    private static final String JL_OBJECT = \"java\/lang\/Object\";\n-    private static final String JL_THROWABLE = \"java\/lang\/Throwable\";\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n@@ -64,16 +63,26 @@\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n-    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n-    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n-\n-    private static final String JLR_INVOCATION_HANDLER = \"java\/lang\/reflect\/InvocationHandler\";\n-    private static final String JLR_PROXY = \"java\/lang\/reflect\/Proxy\";\n-    private static final String JLR_UNDECLARED_THROWABLE_EX = \"java\/lang\/reflect\/UndeclaredThrowableException\";\n-\n-    private static final String LJL_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String LJL_CLASSLOADER = \"Ljava\/lang\/ClassLoader;\";\n-    private static final String LJLR_METHOD = \"Ljava\/lang\/reflect\/Method;\";\n-    private static final String LJLR_INVOCATION_HANDLER = \"Ljava\/lang\/reflect\/InvocationHandler;\";\n-\n-    private static final String MJLR_INVOCATIONHANDLER = \"(Ljava\/lang\/reflect\/InvocationHandler;)V\";\n+    private static final ClassDesc\n+            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n+            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n+            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n+            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n+            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n+            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n+            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n+            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n+            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n+            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+\n+    private static final MethodTypeDesc\n+            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n+            MTD_void = MethodTypeDesc.of(CD_void),\n+            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDesc.of(CD_Class),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n+            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n+            MTD_String = MethodTypeDesc.of(CD_String);\n@@ -124,1 +133,1 @@\n-    private final String className;\n+    private final ClassDesc classDesc;\n@@ -158,1 +167,0 @@\n-        super(ClassWriter.COMPUTE_FRAMES);\n@@ -160,1 +168,1 @@\n-        this.className = className;\n+        this.classDesc = ClassDesc.of(className);\n@@ -177,0 +185,1 @@\n+        Objects.requireNonNull(interfaces);\n@@ -188,1 +197,1 @@\n-                                    Path dir = Path.of(dotToSlash(name.substring(0, i)));\n+                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n@@ -208,5 +217,2 @@\n-     * Return an array of the class and interface names from an array of Classes.\n-     *\n-     * @param classes an array of classes or interfaces\n-     * @return the array of class and interface names; or null if classes is\n-     * null or empty\n+     * {@return the {@code ClassDesc} of the given type}\n+     * @param type the {@code Class} object\n@@ -214,8 +220,2 @@\n-    private static String[] typeNames(List<Class<?>> classes) {\n-        if (classes == null || classes.size() == 0)\n-            return null;\n-        int size = classes.size();\n-        String[] ifaces = new String[size];\n-        for (int i = 0; i < size; i++)\n-            ifaces[i] = dotToSlash(classes.get(i).getName());\n-        return ifaces;\n+    private static ClassDesc toClassDesc(Class<?> type) {\n+        return ClassDesc.ofDescriptor(type.descriptorString());\n@@ -339,1 +339,1 @@\n-    private static List<Class<?>> computeUniqueCatchList(Class<?>[] exceptions) {\n+    private static List<ClassDesc> computeUniqueCatchList(Class<?>[] exceptions) {\n@@ -387,29 +387,1 @@\n-        return uniqueList;\n-    }\n-\n-    \/**\n-     * Convert a fully qualified class name that uses '.' as the package\n-     * separator, the external representation used by the Java language\n-     * and APIs, to a fully qualified class name that uses '\/' as the\n-     * package separator, the representation used in the class file\n-     * format (see JVMS section {@jvms 4.2}).\n-     *\/\n-    private static String dotToSlash(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    \/**\n-     * Return the number of abstract \"words\", or consecutive local variable\n-     * indexes, required to contain a value of the given type.  See JVMS\n-     * section {@jvms 3.6.1}.\n-     * <p>\n-     * Note that the original version of the JVMS contained a definition of\n-     * this abstract notion of a \"word\" in section 3.4, but that definition\n-     * was removed for the second edition.\n-     *\/\n-    private static int getWordsPerType(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            return 2;\n-        } else {\n-            return 1;\n-        }\n+        return uniqueList.stream().map(ProxyGenerator::toClassDesc).toList();\n@@ -442,11 +414,0 @@\n-    \/**\n-     * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n-     * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n-     * default.\n-     *\n-     * @return ClassLoader\n-     *\/\n-    protected ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-\n@@ -458,2 +419,23 @@\n-        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n-                JLR_PROXY, typeNames(interfaces));\n+        var localCache = new HashMap<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo>();\n+        return Classfile.build(classDesc, List.of(Classfile.Option.classHierarchyResolver(classDesc ->\n+                \/*\n+                 * Class hierarchy resolution is critical for stack maps generation.\n+                 * Provided loader is used to retrieve class hierarchy info and the info is cached.\n+                 *\/\n+                localCache.computeIfAbsent(classDesc, cd -> {\n+                    try {\n+                        var desc = cd.descriptorString();\n+                        var cls = Class.forName(desc.substring(1, desc.length() - 1).replace('\/', '.'), false, loader);\n+                        var superCls = cls.getSuperclass();\n+                        return new ClassHierarchyResolver.ClassHierarchyInfo(cd,\n+                                                                             cls.isInterface(),\n+                                                                             superCls == null ? null : toClassDesc(superCls));\n+                    } catch (ClassNotFoundException e) {\n+                        throw new TypeNotPresentException(cd.descriptorString(), e);\n+                    }\n+                })\n+        )), clb -> {\n+            clb.withFlags(accessFlags);\n+            clb.withSuperclass(CD_Proxy);\n+            clb.withInterfaceSymbols(interfaces.stream().map(ProxyGenerator::toClassDesc).toList());\n+            clb.withVersion(CLASSFILE_VERSION, 0);\n@@ -461,10 +443,10 @@\n-        \/*\n-         * Add proxy methods for the hashCode, equals,\n-         * and toString methods of java.lang.Object.  This is done before\n-         * the methods from the proxy interfaces so that the methods from\n-         * java.lang.Object take precedence over duplicate methods in the\n-         * proxy interfaces.\n-         *\/\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+            \/*\n+             * Add proxy methods for the hashCode, equals,\n+             * and toString methods of java.lang.Object.  This is done before\n+             * the methods from the proxy interfaces so that the methods from\n+             * java.lang.Object take precedence over duplicate methods in the\n+             * proxy interfaces.\n+             *\/\n+            addProxyMethod(hashCodeMethod);\n+            addProxyMethod(equalsMethod);\n+            addProxyMethod(toStringMethod);\n@@ -472,7 +454,8 @@\n-        \/*\n-         * Accumulate all of the methods from the proxy interfaces.\n-         *\/\n-        for (Class<?> intf : interfaces) {\n-            for (Method m : intf.getMethods()) {\n-                if (!Modifier.isStatic(m.getModifiers())) {\n-                    addProxyMethod(m, intf);\n+            \/*\n+             * Accumulate all of the methods from the proxy interfaces.\n+             *\/\n+            for (Class<?> intf : interfaces) {\n+                for (Method m : intf.getMethods()) {\n+                    if (!Modifier.isStatic(m.getModifiers())) {\n+                        addProxyMethod(m, intf);\n+                    }\n@@ -481,1 +464,0 @@\n-        }\n@@ -483,7 +465,7 @@\n-        \/*\n-         * For each set of proxy methods with the same signature,\n-         * verify that the methods' return types are compatible.\n-         *\/\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            checkReturnTypes(sigmethods);\n-        }\n+            \/*\n+             * For each set of proxy methods with the same signature,\n+             * verify that the methods' return types are compatible.\n+             *\/\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                checkReturnTypes(sigmethods);\n+            }\n@@ -491,1 +473,1 @@\n-        generateConstructor();\n+            generateConstructor(clb);\n@@ -493,5 +475,4 @@\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -499,2 +480,3 @@\n-                \/\/ Generate code for proxy method\n-                pm.generateMethod(this, className);\n+                    \/\/ Generate code for proxy method\n+                    pm.generateMethod(clb, classDesc);\n+                }\n@@ -502,1 +484,0 @@\n-        }\n@@ -504,3 +485,3 @@\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+            generateStaticInitializer(clb);\n+            generateLookupAccessor(clb);\n+        });\n@@ -566,14 +547,6 @@\n-    private void generateConstructor() {\n-        MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, null, null);\n-        ctor.visitParameter(null, 0);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitVarInsn(ALOAD, 1);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, false);\n-        ctor.visitInsn(RETURN);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+    private void generateConstructor(ClassBuilder clb) {\n+        clb.withMethodBody(NAME_CTOR, MTD_void_InvocationHandler, ACC_PUBLIC, cob -> cob\n+               .aload(cob.receiverSlot())\n+               .aload(cob.parameterSlot(0))\n+               .invokespecial(CD_Proxy, NAME_CTOR, MTD_void_InvocationHandler)\n+               .return_());\n@@ -585,57 +558,29 @@\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        \/\/ Put ClassLoader at local variable index 0, used by\n-        \/\/ Class.forName(String, boolean, ClassLoader) calls\n-        mv.visitLdcInsn(Type.getObjectType(dotToSlash(className)));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + LJL_CLASSLOADER, false);\n-        mv.visitVarInsn(ASTORE, 0);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n-            }\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(NAME_CLINIT, MTD_void, ACC_STATIC, cob -> cob\n+                \/\/ Put ClassLoader at local variable index 0, used by\n+                \/\/ Class.forName(String, boolean, ClassLoader) calls\n+                .constantInstruction(classDesc)\n+                .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n+                .astore(0)\n+                .trying(tryb -> {\n+                    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                        for (ProxyMethod pm : sigmethods) {\n+                            pm.codeFieldInitialization(tryb, classDesc);\n+                        }\n+                    }\n+                    tryb.return_();\n+                }, cb -> cb\n+                    .catching(CD_NoSuchMethodException, nsmb -> nsmb\n+                            .new_(CD_NoSuchMethodError)\n+                            .dup_x1()\n+                            .swap()\n+                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n+                            .invokespecial(CD_NoSuchMethodError, NAME_CTOR, MTD_void_String)\n+                            .athrow())\n+                    .catching(CD_ClassNotFoundException, cnfb -> cnfb\n+                            .new_(CD_NoClassDefFoundError)\n+                            .dup_x1()\n+                            .swap()\n+                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n+                            .invokespecial(CD_NoClassDefFoundError, NAME_CTOR, MTD_void_String)\n+                            .athrow())));\n@@ -649,33 +594,22 @@\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateLookupAccessor(ClassBuilder clb) {\n+        clb.withMethod(NAME_LOOKUP_ACCESSOR,\n+                MTD_MethodHandles$Lookup_MethodHandles$Lookup,\n+                ACC_PRIVATE | ACC_STATIC,\n+                mb -> mb.with(ExceptionsAttribute.of(List.of(mb.constantPool().classEntry(CD_IllegalAccessException))))\n+                        .withCode(cob -> cob\n+                            .block(blockBuilder -> blockBuilder\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .if_acmpne(blockBuilder.breakLabel())\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n+                                    .ifeq(blockBuilder.breakLabel())\n+                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                                    .areturn())\n+                            .new_(CD_IllegalAccessException)\n+                            .dup()\n+                            .aload(cob.parameterSlot(0))\n+                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n+                            .invokespecial(CD_IllegalAccessException, NAME_CTOR, MTD_void_String)\n+                            .athrow()));\n@@ -719,2 +653,2 @@\n-                    method.getSharedParameterTypes(), method.getReturnType(),\n-                    method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedParameterTypes(), method.getReturnType(),\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -726,60 +660,34 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n-            MethodType mt = MethodType.methodType(returnType, parameterTypes);\n-            String desc = mt.toMethodDescriptorString();\n-            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n-            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n-\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                    method.getName(), desc, null,\n-                    typeNames(Arrays.asList(exceptionTypes)));\n-\n-            int[] parameterSlot = new int[parameterTypes.length];\n-            int nextSlot = 1;\n-            for (int i = 0; i < parameterSlot.length; i++) {\n-                parameterSlot[i] = nextSlot;\n-                nextSlot += getWordsPerType(parameterTypes[i]);\n-            }\n-\n-            mv.visitCode();\n-            Label L_startBlock = new Label();\n-            Label L_endBlock = new Label();\n-            Label L_RuntimeHandler = new Label();\n-            Label L_ThrowableHandler = new Label();\n-\n-            List<Class<?>> catchList = computeUniqueCatchList(exceptionTypes);\n-            if (catchList.size() > 0) {\n-                for (Class<?> ex : catchList) {\n-                    mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,\n-                            dotToSlash(ex.getName()));\n-                }\n-\n-                mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,\n-                        JL_THROWABLE);\n-            }\n-            mv.visitLabel(L_startBlock);\n-\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,\n-                    LJLR_INVOCATION_HANDLER);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n-\n-            if (parameterTypes.length > 0) {\n-                \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                emitIconstInsn(mv, parameterTypes.length);\n-                mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);\n-                for (int i = 0; i < parameterTypes.length; i++) {\n-                    mv.visitInsn(DUP);\n-                    emitIconstInsn(mv, i);\n-                    codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);\n-                    mv.visitInsn(Opcodes.AASTORE);\n-                }\n-            } else {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-            }\n-\n-            mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,\n-                    \"invoke\",\n-                    \"(Ljava\/lang\/Object;Ljava\/lang\/reflect\/Method;\" +\n-                            \"[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", true);\n+        private void generateMethod(ClassBuilder clb, ClassDesc className) {\n+            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n+                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+            int accessFlags = (method.isVarArgs()) ? ACC_VARARGS | ACC_PUBLIC | ACC_FINAL\n+                                                   : ACC_PUBLIC | ACC_FINAL;\n+            var catchList = computeUniqueCatchList(exceptionTypes);\n+            clb.withMethod(method.getName(), desc, accessFlags, mb -> {\n+                ConstantPoolBuilder cpb = mb.constantPool();\n+                List<ClassEntry> exceptionClassEntries = Arrays.asList(exceptionTypes)\n+                        .stream()\n+                        .map(ProxyGenerator::toClassDesc)\n+                        .map(cpb::classEntry)\n+                        .toList();\n+                mb.with(ExceptionsAttribute.of(exceptionClassEntries));\n+                mb.withCode(cob ->\n+                    cob.trying(tryb -> {\n+                        tryb.aload(tryb.receiverSlot())\n+                            .getfield(CD_Proxy, handlerFieldName, CD_InvocationHandler)\n+                            .aload(tryb.receiverSlot())\n+                            .getstatic(className, methodFieldName, CD_Method);\n+\n+                        if (parameterTypes.length > 0) {\n+                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                            tryb.constantInstruction(parameterTypes.length)\n+                                .anewarray(CD_Object);\n+                            for (int i = 0; i < parameterTypes.length; i++) {\n+                                tryb.dup()\n+                                    .constantInstruction(i);\n+                                codeWrapArgument(tryb, parameterTypes[i], tryb.parameterSlot(i));\n+                                tryb.aastore();\n+                            }\n+                        } else {\n+                            tryb.aconst_null();\n+                        }\n@@ -787,6 +695,1 @@\n-            if (returnType == void.class) {\n-                mv.visitInsn(POP);\n-                mv.visitInsn(RETURN);\n-            } else {\n-                codeUnwrapReturnValue(mv, returnType);\n-            }\n+                        tryb.invokeinterface(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n@@ -794,17 +697,20 @@\n-            mv.visitLabel(L_endBlock);\n-\n-            \/\/ Generate exception handler\n-            mv.visitLabel(L_RuntimeHandler);\n-            mv.visitInsn(ATHROW);   \/\/ just rethrow the exception\n-\n-            mv.visitLabel(L_ThrowableHandler);\n-            mv.visitVarInsn(ASTORE, 1);\n-            mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);\n-            mv.visitInsn(DUP);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,\n-                    \"<init>\", \"(Ljava\/lang\/Throwable;)V\", false);\n-            mv.visitInsn(ATHROW);\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n+                        if (returnType == void.class) {\n+                            tryb.pop()\n+                                .return_();\n+                        } else {\n+                            codeUnwrapReturnValue(tryb, returnType);\n+                        }\n+                    }, catchBuilder -> {\n+                        if (!catchList.isEmpty()) {\n+                            catchBuilder.catchingMulti(catchList, ehb -> ehb\n+                                    .athrow());   \/\/ just rethrow the exception\n+\n+                            catchBuilder.catching(CD_Throwable, ehb -> ehb\n+                                    .new_(CD_UndeclaredThrowableException)\n+                                    .dup_x1()\n+                                    .swap()\n+                                    .invokespecial(CD_UndeclaredThrowableException, NAME_CTOR, MTD_void_Throwable)\n+                                    .athrow());\n+                        }\n+                    }));\n+            });\n@@ -819,1 +725,1 @@\n-        private void codeWrapArgument(MethodVisitor mv, Class<?> type, int slot) {\n+        private void codeWrapArgument(CodeBuilder cob, Class<?> type, int slot) {\n@@ -821,0 +727,1 @@\n+                cob.loadInstruction(TypeKind.fromDescriptor(type.descriptorString()).asLoadable(), slot);\n@@ -822,4 +729,1 @@\n-\n-                mv.visitVarInsn(prim.loadOpcode, slot);\n-                mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, \"valueOf\",\n-                        prim.wrapperValueOfDesc, false);\n+                cob.invokestatic(prim.wrapperClass, \"valueOf\", prim.wrapperValueOf);\n@@ -827,1 +731,1 @@\n-                mv.visitVarInsn(ALOAD, slot);\n+                cob.aload(slot);\n@@ -836,1 +740,1 @@\n-        private void codeUnwrapReturnValue(MethodVisitor mv, Class<?> type) {\n+        private void codeUnwrapReturnValue(CodeBuilder cob, Class<?> type) {\n@@ -840,6 +744,3 @@\n-                mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);\n-                mv.visitMethodInsn(INVOKEVIRTUAL,\n-                        prim.wrapperClassName,\n-                        prim.unwrapMethodName, prim.unwrapMethodDesc, false);\n-\n-                mv.visitInsn(prim.returnOpcode);\n+                cob.typeCheckInstruction(Opcode.CHECKCAST, prim.wrapperClass)\n+                   .invokevirtual(prim.wrapperClass, prim.unwrapMethodName, prim.unwrapMethodType)\n+                   .returnInstruction(TypeKind.fromDescriptor(type.descriptorString()).asLoadable());\n@@ -847,2 +748,2 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n-                mv.visitInsn(ARETURN);\n+                cob.checkcast(toClassDesc(type))\n+                   .areturn();\n@@ -857,4 +758,2 @@\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n+        private void codeFieldInitialization(CodeBuilder cob, ClassDesc className) {\n+            codeClassForName(cob, fromClass);\n@@ -862,3 +761,3 @@\n-            emitIconstInsn(mv, parameterTypes.length);\n-\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n+            cob.constantInstruction(Opcode.LDC, method.getName())\n+               .constantInstruction(parameterTypes.length)\n+               .anewarray(CD_Class);\n@@ -868,3 +767,2 @@\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n+                cob.dup()\n+                   .constantInstruction(i);\n@@ -872,4 +770,2 @@\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.wrapperClass, \"TYPE\", CD_Class);\n@@ -877,1 +773,1 @@\n-                    codeClassForName(mv, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i]);\n@@ -879,1 +775,1 @@\n-                mv.visitInsn(Opcodes.AASTORE);\n+                cob.arrayStoreInstruction(TypeKind.ReferenceType);\n@@ -882,9 +778,2 @@\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n+            cob.invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_ClassArray)\n+               .putstatic(className, methodFieldName, CD_Method);\n@@ -904,27 +793,5 @@\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitInsn(ICONST_0); \/\/ false\n-            mv.visitVarInsn(ALOAD, 0); \/\/ classLoader\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\",\n-                    \"(Ljava\/lang\/String;Z\" + LJL_CLASSLOADER + \")Ljava\/lang\/Class;\",\n-                    false);\n-        }\n-\n-        \/**\n-         * Visit a bytecode for a constant.\n-         *\n-         * @param mv  The MethodVisitor\n-         * @param cst The constant value\n-         *\/\n-        private void emitIconstInsn(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-            } else {\n-                mv.visitLdcInsn(cst);\n-            }\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.constantInstruction(Opcode.LDC, cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader);\n@@ -945,8 +812,8 @@\n-        BYTE(byte.class, ILOAD, IRETURN),\n-        CHAR(char.class, ILOAD, IRETURN),\n-        DOUBLE(double.class, DLOAD, DRETURN),\n-        FLOAT(float.class, FLOAD, FRETURN),\n-        INT(int.class, ILOAD, IRETURN),\n-        LONG(long.class, LLOAD, LRETURN),\n-        SHORT(short.class, ILOAD, IRETURN),\n-        BOOLEAN(boolean.class, ILOAD, IRETURN);\n+        BYTE(byte.class, CD_byte, CD_Byte),\n+        CHAR(char.class, CD_char, CD_Character),\n+        DOUBLE(double.class, CD_double, CD_Double),\n+        FLOAT(float.class, CD_float, CD_Float),\n+        INT(int.class, CD_int, CD_Integer),\n+        LONG(long.class, CD_long, CD_Long),\n+        SHORT(short.class, CD_short, CD_Short),\n+        BOOLEAN(boolean.class, CD_boolean, CD_Boolean);\n@@ -957,1 +824,1 @@\n-        private final String wrapperClassName;\n+        private final ClassDesc wrapperClass;\n@@ -961,1 +828,1 @@\n-        private final String wrapperValueOfDesc;\n+        private final MethodTypeDesc wrapperValueOf;\n@@ -969,25 +836,8 @@\n-        private final String unwrapMethodDesc;\n-        \/**\n-         * Load opcode used by this primitive\n-         *\/\n-        private final int loadOpcode;\n-        \/**\n-         * Return opcode used by this primitive\n-         *\/\n-        private final int returnOpcode;\n-\n-        PrimitiveTypeInfo(Class<?> primitiveClass, int loadOpcode, int returnOpcode) {\n-            assert primitiveClass.isPrimitive();\n-            assert returnOpcode - IRETURN == loadOpcode - ILOAD;\n-\n-            Wrapper wrapper = Wrapper.forPrimitiveType(primitiveClass);\n-            \/\/ single-char BaseType descriptor (see JVMS section 4.3.2)\n-            String baseTypeString = wrapper.basicTypeString();\n-            var wrapperType = wrapper.wrapperType();\n-            wrapperClassName = dotToSlash(wrapperType.getName());\n-            wrapperValueOfDesc =\n-                    \"(\" + baseTypeString + \")\" + wrapperType.descriptorString();\n-            unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            unwrapMethodDesc = \"()\" + baseTypeString;\n-            this.loadOpcode = loadOpcode;\n-            this.returnOpcode = returnOpcode;\n+        private final MethodTypeDesc unwrapMethodType;\n+\n+        PrimitiveTypeInfo(Class<?> primitiveClass, ClassDesc baseType, ClassDesc wrapperClass) {\n+            assert baseType.isPrimitive();\n+            this.wrapperClass = wrapperClass;\n+            this.wrapperValueOf = MethodTypeDesc.of(wrapperClass, baseType);\n+            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n+            this.unwrapMethodType = MethodTypeDesc.of(baseType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":266,"deletions":416,"binary":false,"changes":682,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry.ClassEntryImpl;\n@@ -160,1 +161,3 @@\n-        return classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ClassEntryImpl ret = (ClassEntryImpl)classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ret.sym = classDesc;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -559,0 +559,2 @@\n+        public ClassDesc sym = null;\n+\n@@ -565,1 +567,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n@@ -570,1 +578,4 @@\n-            return Util.toClassDesc(asInternalName());\n+            if (sym == null) {\n+                sym = Util.toClassDesc(asInternalName());\n+            }\n+            return sym;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"}]}